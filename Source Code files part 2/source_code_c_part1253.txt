eviceExtensionHub->HubFlags |= HUBFLAG_IN_IDLE_CHECK;
    KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);

    rootHubDevExt = USBH_GetRootHubDevExt(DeviceExtensionHub);

    if (rootHubDevExt->CurrentSystemPowerState != PowerSystemWorking) {

        LOGENTRY(LOG_PNP, "hCkS", DeviceExtensionHub, DeviceExtensionHub->HubFlags,
            rootHubDevExt->CurrentSystemPowerState);
        USBH_KdPrint((1,"'CheckHubIdle: System not at S0, fail\n"));

        goto USBH_CheckHubIdleDone;
    }

#ifdef NEW_START
    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_OK_TO_ENUMERATE)) {

        USBH_KdPrint((1,"'Defer idle\n"));        
        goto USBH_CheckHubIdleDone;
    }
#endif

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) ||
        (DeviceExtensionHub->HubFlags &
         (HUBFLAG_DEVICE_STOPPING |
          HUBFLAG_HUB_GONE |
          HUBFLAG_HUB_FAILURE |
          HUBFLAG_CHILD_DELETES_PENDING |
          HUBFLAG_WW_SET_D0_PENDING |
          HUBFLAG_POST_ESD_ENUM_PENDING |
          HUBFLAG_HUB_HAS_LOST_BRAINS))) {

        LOGENTRY(LOG_PNP, "hCkN", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'CheckHubIdle: Hub not started, stopping, removed, failed, powering up, or delete pending, fail\n"));

        goto USBH_CheckHubIdleDone;
    }

    if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

        DeviceExtensionHub->HubFlags |= HUBFLAG_NEED_IDLE_CHECK;

        LOGENTRY(LOG_PNP, "hCkP", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);
        USBH_KdPrint((1,"'CheckHubIdle: ChangeIndication workitem pending, skip\n"));

        goto USBH_CheckHubIdleDone;
    }

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_NEED_IDLE_CHECK;

    // Ensure that child port configuration does not change while in this
    // function, i.e. don't allow QBR.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    IoAcquireCancelSpinLock(&irql);

    bAllIdle = TRUE;    // Assume that everyone wants to idle.

    for (i = 0; i < DeviceExtensionHub->HubDescriptor->bNumberOfPorts; i++) {

        if (DeviceExtensionHub->PortData[i].DeviceObject) {

            childDeviceExtensionPort = DeviceExtensionHub->PortData[i].DeviceObject->DeviceExtension;

            if (!childDeviceExtensionPort->IdleNotificationIrp) {
                bAllIdle = FALSE;
                break;
            }
        }
    }

    if (bAllIdle &&
        !(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_IDLE_IRP)) {

        // We're gonna submit the idle irp once we release the spin lock.
        DeviceExtensionHub->HubFlags |= HUBFLAG_PENDING_IDLE_IRP;
        KeResetEvent(&DeviceExtensionHub->SubmitIdleEvent);
        submitIdle = TRUE;

    }

    IoReleaseCancelSpinLock(irql);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (bAllIdle) {

        LOGENTRY(LOG_PNP, "hCkA", DeviceExtensionHub, 0, 0);
        USBH_KdPrint((1,"'CheckHubIdle: All devices on hub %x idle!\n",
            DeviceExtensionHub));

        // And when all the child PDO's have been idled, we can now idle
        // the hub itself.
        //
        // BUGBUG: What do we do if this fails?  Do we even care?

        if (submitIdle) {
            USBH_FdoSubmitIdleRequestIrp(DeviceExtensionHub);
        }
    }

USBH_CheckHubIdleDone:

    KeAcquireSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, &irql);
    DeviceExtensionHub->HubFlags &= ~HUBFLAG_IN_IDLE_CHECK;
    KeReleaseSpinLock(&DeviceExtensionHub->CheckIdleSpinLock, irql);

    ;
}


NTSTATUS
USBH_PortIdleNotificationRequest(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function handles a request by a USB client driver to tell us
  * that the device wants to idle (selective suspend).
  *
  * Arguments:
  *
  * DeviceExtensionPort - the PDO extension
  * Irp - the request packet
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    PDRIVER_CANCEL oldCancelRoutine;
    NTSTATUS ntStatus = STATUS_PENDING;
    KIRQL irql;

    LOGENTRY(LOG_PNP, "IdlP", DeviceExtensionPort, Irp, 0);
    USBH_KdPrint((1,"'Idle request %x, IRP %x\n", DeviceExtensionPort, Irp));

    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionPort->IdleNotificationIrp != NULL) {

        IoReleaseCancelSpinLock(irql);

        LOGENTRY(LOG_PNP, "Idl2", DeviceExtensionPort, Irp, 0);
        UsbhWarning(DeviceExtensionPort,
                    "Idle IRP submitted while already one pending\n",
                    TRUE);

        Irp->IoStatus.Status = STATUS_DEVICE_BUSY;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_DEVICE_BUSY;
    }

    idleCallbackInfo = (PUSB_IDLE_CALLBACK_INFO)
        IoGetCurrentIrpStackLocation(Irp)->\
            Parameters.DeviceIoControl.Type3InputBuffer;

    if (!idleCallbackInfo || !idleCallbackInfo->IdleCallback) {

        LOGENTRY(LOG_PNP, "Idl4", DeviceExtensionPort, Irp, 0);
        USBH_KdPrint((1,"'Idle request: No callback provided with idle IRP!\n"));
        IoReleaseCancelSpinLock(irql);

        Irp->IoStatus.Status = STATUS_NO_CALLBACK_ACTIVE;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return STATUS_NO_CALLBACK_ACTIVE;
    }

    //
    //  Must set cancel routine before checking Cancel flag.
    //

    oldCancelRoutine = IoSetCancelRoutine(Irp, USBH_PortIdleNotificationCancelRoutine);
    USBH_ASSERT(!oldCancelRoutine);

    if (Irp->Cancel) {
        //
        //  Irp was cancelled. Check whether cancel routine was called.
        //
        oldCancelRoutine = IoSetCancelRoutine(Irp, NULL);
        if (oldCancelRoutine) {
            //
            //  Cancel routine was NOT called. So complete the irp here.
            //
            LOGENTRY(LOG_PNP, "Idl3", DeviceExtensionPort, Irp, 0);
            USBH_KdPrint((1,"'Idle request: Idle IRP already cancelled, complete it here!\n"));
            IoReleaseCancelSpinLock(irql);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            ntStatus = STATUS_CANCELLED;

        } else {
            //
            //  Cancel routine was called, and it will complete the IRP
            //  as soon as we drop the spinlock.
            //  Return STATUS_PENDING so we don't touch the IRP.
            //
            LOGENTRY(LOG_PNP, "Idl5", DeviceExtensionPort, Irp, 0);
            USBH_KdPrint((1,"'Idle request: Idle IRP already cancelled, don't complete here!\n"));
            IoMarkIrpPending(Irp);
            IoReleaseCancelSpinLock(irql);

            ntStatus = STATUS_PENDING;
        }

    } else {

        // IRP was not cancelled, so keep it.

        DeviceExtensionPort->IdleNotificationIrp = Irp;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_IDLE_NOTIFIED;
        IoMarkIrpPending(Irp);

        IoReleaseCancelSpinLock(irql);

        ntStatus = STATUS_PENDING;

        // See if we are ready to idle out this hub.

        USBH_CheckHubIdle(deviceExtensionHub);
    }

    return ntStatus;
}


#ifdef DRM_SUPPORT

NTSTATUS
USBH_PdoSetContentId
(
    IN PIRP                          irp,
    IN PKSP_DRMAUDIOSTREAM_CONTENTID pKsProperty,
    IN PKSDRMAUDIOSTREAM_CONTENTID   pvData
)
 /* ++
  *
  * Description:
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    ULONG ContentId;
    PIO_STACK_LOCATION ioStackLocation;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PDEVICE_OBJECT forwardDeviceObject;
    USBD_PIPE_HANDLE hPipe;
    NTSTATUS ntStatus;

    PAGED_CODE();

    ASSERT(irp);
    ASSERT(pKsProperty);
    ASSERT(pvData);

    ioStackLocation = IoGetCurrentIrpStackLocation(irp);
    deviceExtensionPort = ioStackLocation->DeviceObject->DeviceExtension;
    forwardDeviceObject = deviceExtensionPort->DeviceExtensionHub->TopOfHcdStackDeviceObject;
    hPipe = pKsProperty->Context;
    ContentId = pvData->ContentId;

    return pKsProperty->DrmForwardContentToDeviceObject(ContentId, forwardDeviceObject, hPipe);
}

#endif


NTSTATUS
USBH_PdoDispatch(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp)
 /*
  * Description:
  *
  *     This function handles calls to PDOs we have created
  *     since we are the bottom driver for the PDO it is up
  *     to us to complete the irp -- with one exception.
  *
  *     api calls to the USB stack are forwarded directly
  *     to the PDO for the root hub which is owned by the USB
  *     HC.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PURB urb;

    USBH_KdPrint((2,"'PdoDispatch DeviceExtension %x Irp %x\n", DeviceExtensionPort, Irp));
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    
    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:
        USBH_KdPrint((2,"'HUB PDO IRP_MJ_CREATE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_CLOSE:
        USBH_KdPrint((2,"'HUB PDO IRP_MJ_CLOSE\n"));
        ntStatus = STATUS_SUCCESS;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Internal Device Control\n"));

        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETED_PDO) {
#if DBG
            UsbhWarning(DeviceExtensionPort,
                "Client Device Driver is sending requests to a device that has been removed.\n",
                (BOOLEAN)((USBH_Debug_Trace_Level > 0) ? TRUE : FALSE));
#endif

            ntStatus = STATUS_DEVICE_NOT_CONNECTED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

// Take this out.  This breaks SyncDisablePort, AbortInterruptPipe.
//
//        if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DELETE_PENDING) {
//            ntStatus = STATUS_DELETE_PENDING;
//            USBH_CompleteIrp(Irp, ntStatus);
//            break;
//        }

        if (DeviceExtensionPort->DeviceState != PowerDeviceD0) {
#if DBG
            UsbhWarning(DeviceExtensionPort,
                "Client Device Driver is sending requests to a device in a low power state.\n",
                (BOOLEAN)((USBH_Debug_Trace_Level > 0) ? TRUE : FALSE));
#endif

            // Must use an error code here that can be mapped to Win32 in
            // rtl\generr.c

            ntStatus = STATUS_DEVICE_POWERED_OFF;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }

        ioControlCode = 
            ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        //
        // old comments:
        // **
        // The following code used to check for HUBFLAG_HUB_GONE,
        // HUBFLAG_DEVICE_STOPPING, and HUBFLAG_HUB_HAS_LOST_BRAINS also,
        // but doing so breaks the case where a hub with a downstream
        // device is disconnected or powered off and the driver for the
        // child device sends an AbortPipe request, but the driver hangs
        // waiting for the pending requests to complete which never do
        // because the USBPORT never saw the AbortPipe request.
        // **
        //
        // 
        // jd new comments:  
        //
        // the backref to the parent is always removed when the PDO processes
        // the remove irp so it is safe to fail APIs when DevExtHub is NULL. 
        // The device handle is gone at this point so there should be no traffic
        // pending is usbport.
        //
        // there is one execption -- the GET_RRO_HUB_PDO api. we need to let 
        // this one thru since the hub driver will call it from add device

        if (IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO == ioControlCode) {
            deviceExtensionHub = DeviceExtensionPort->HubExtSave;
        }
        
        if (!deviceExtensionHub) {
            ntStatus = STATUS_DEVICE_BUSY;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }
        USBH_ASSERT(deviceExtensionHub);

        switch (ioControlCode) {

        case IOCTL_INTERNAL_USB_GET_HUB_COUNT:

            //
            // This PDO belongs to a hub, bump the count and pass
            // on to the parent hub that this hub is connected to

            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
                PULONG count;
                //
                // bump the count and pass on to our PDO
                //
                count = ioStackLocation->Parameters.Others.Argument1;
                (*count)++;

                // bump the count for this hub and pass on to next PDO

                ntStatus = USBH_SyncGetRootHubPdo(deviceExtensionHub->TopOfStackDeviceObject,
                                                  NULL,
                                                  NULL,
                                                  count);

                USBH_CompleteIrp(Irp, ntStatus);

            } else {
                ntStatus = STATUS_INVALID_PARAMETER;
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_CONTROLLER_NAME:
            {
            PUSB_HUB_NAME hubName;
            ULONG length;

            length = PtrToUlong( ioStackLocation->Parameters.Others.Argument2 );
            hubName = ioStackLocation->Parameters.Others.Argument1;

            ntStatus = USBHUB_GetControllerName(deviceExtensionHub,
                                                hubName,
                                                length);
            }
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_GET_BUS_INFO:
            //ntStatus = USBH_PassIrp(Irp,
            //                        deviceExtensionHub->RootHubPdo);
            {
            PUSB_BUS_NOTIFICATION busInfo;

            busInfo = ioStackLocation->Parameters.Others.Argument1;

            ntStatus = USBHUB_GetBusInfoDevice(deviceExtensionHub,
                                               DeviceExtensionPort,
                                               busInfo);
            }
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_GET_ROOTHUB_PDO:

            if (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB) {
                ntStatus = USBH_PassIrp(Irp,
                                        deviceExtensionHub->RootHubPdo);
            } else {
                //
                // if this is not a hub return NULL for the root hub pdo
                // so that the hub driver will act as parent
                //
                PDEVICE_OBJECT *rootHubPdo;
                rootHubPdo = ioStackLocation ->Parameters.Others.Argument1;

                *rootHubPdo = NULL;

                ntStatus = STATUS_SUCCESS;

                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_URB:
            //
            // note: we forward apis on from here in case a filter driver
            // was inserted above the PDO for the device.
            //

            urb = ioStackLocation->Parameters.Others.Argument1;
            urb->UrbHeader.UsbdDeviceHandle = DeviceExtensionPort->DeviceData;

            if (DeviceExtensionPort->DeviceData == NULL) {
                //ntStatus = STATUS_DEVICE_NOT_CONNECTED;
                //USBH_CompleteIrp(Irp, ntStatus);
                ENUMLOG(&deviceExtensionHub->UsbdiBusIf, 
                    USBDTAG_HUB, 'dev!', 0, DeviceExtensionPort->PortNumber);
                urb->UrbHeader.UsbdDeviceHandle = (PVOID) (-1);
                ntStatus = USBH_PassIrp(Irp,
                                        deviceExtensionHub->TopOfHcdStackDeviceObject);

            } else {
                ntStatus = USBH_PdoUrbFilter(DeviceExtensionPort,
                                             Irp);
            }
            break;

        case IOCTL_INTERNAL_USB_GET_PORT_STATUS:

            ntStatus = USBH_PdoIoctlGetPortStatus(DeviceExtensionPort,
                                                  Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_DEVICE_HANDLE:

            {
            PUSB_DEVICE_HANDLE *p;

            p = ioStackLocation->Parameters.Others.Argument1;
            *p = DeviceExtensionPort->DeviceData;

            ntStatus = STATUS_SUCCESS;
            }

            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_INTERNAL_USB_RESET_PORT:

            if (DeviceExtensionPort->PortPdoFlags & (PORTPDO_RESET_PENDING | 
                                                     PORTPDO_CYCLED)) {
                ntStatus = STATUS_UNSUCCESSFUL;
                USBH_CompleteIrp(Irp, ntStatus);
            } else {

                PUSBH_RESET_WORK_ITEM workItemReset;

                //
                // Schedule a work item to process this reset.
                //
                workItemReset = UsbhExAllocatePool(NonPagedPool,
                                                   sizeof(USBH_RESET_WORK_ITEM));

                if (workItemReset) {

                    DeviceExtensionPort->PortPdoFlags |= PORTPDO_RESET_PENDING;

                    workItemReset->DeviceExtensionPort = DeviceExtensionPort;
                    workItemReset->Irp = Irp;

                    ntStatus = STATUS_PENDING;
                    IoMarkIrpPending(Irp);

                    ExInitializeWorkItem(&workItemReset->WorkQueueItem,
                                         USBH_ResetPortWorker,
                                         workItemReset);

                    LOGENTRY(LOG_PNP, "rITM", DeviceExtensionPort,
                        &workItemReset->WorkQueueItem, 0);

                    ExQueueWorkItem(&workItemReset->WorkQueueItem,
                                    DelayedWorkQueue);

                    // The WorkItem is freed by USBH_ResetPortWorker()
                    // Don't try to access the WorkItem after it is queued.

                } else {
                    //
                    // could not queue the work item
                    // re-
                    // in case the condition is temporary

                    TEST_TRAP();
                    ntStatus = STATUS_UNSUCCESSFUL;
                    USBH_CompleteIrp(Irp, ntStatus);
                }
            }
            break;

        case IOCTL_INTERNAL_USB_ENABLE_PORT:

            ntStatus = USBH_PdoIoctlEnablePort(DeviceExtensionPort,
                                               Irp);
            break;

        case IOCTL_INTERNAL_USB_CYCLE_PORT:

            ntStatus = USBH_PdoIoctlCyclePort(DeviceExtensionPort,
                                              Irp);
            break;

        case IOCTL_INTERNAL_USB_GET_HUB_NAME:

            ntStatus = USBH_IoctlHubSymbolicName(DeviceExtensionPort,
                                                 Irp);

            break;

        case IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO:
            {
            PDEVICE_OBJECT *parent;
            PULONG portNumber;
            PDEVICE_OBJECT *rootHubPdo;

            // return Parents PDO
            parent = ioStackLocation->Parameters.Others.Argument1;
            if (parent) {
                *parent = deviceExtensionHub->PhysicalDeviceObject;
            }

            // return port number
            portNumber = ioStackLocation->Parameters.Others.Argument2;
            if (portNumber) {
                *portNumber = DeviceExtensionPort->PortNumber;
            }

            // return bus context (root hub pdo)
            rootHubPdo = ioStackLocation->Parameters.Others.Argument4;
            if (rootHubPdo) {
                *rootHubPdo = deviceExtensionHub->RootHubPdo;
            }

            ntStatus = STATUS_SUCCESS;

            USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION:

            ntStatus = USBH_PortIdleNotificationRequest(DeviceExtensionPort, Irp);
            break;

        default:
            USBH_KdPrint((2,"'InternalDeviceControl IOCTL unknown\n"));
            ntStatus = Irp->IoStatus.Status;
            USBH_CompleteIrp(Irp, ntStatus);
        }
        break;

        }

    case IRP_MJ_DEVICE_CONTROL:
    {
        ULONG ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        switch (ioControlCode) {

#ifdef DRM_SUPPORT

        case IOCTL_KS_PROPERTY:
            ntStatus = KsPropertyHandleDrmSetContentId(Irp, USBH_PdoSetContentId);
            USBH_CompleteIrp(Irp, ntStatus);
            break;
#endif

        case IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER:
            ntStatus = STATUS_NOT_SUPPORTED;
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        default:
            // Unknown Irp, shouldn't be here.
            USBH_KdBreak(("Unhandled IOCTL for Pdo %x IoControlCode %x\n",
                       deviceObject, ioControlCode));
            ntStatus = Irp->IoStatus.Status;
            USBH_CompleteIrp(Irp, ntStatus);
            break;
        }
        break;

    }

    case IRP_MJ_PNP:
        {
        BOOLEAN completeIrp;

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus =
            USBH_PdoPnP(DeviceExtensionPort,
                        Irp,
                        ioStackLocation->MinorFunction,
                        &completeIrp);
        if (completeIrp) {
            USBH_CompleteIrp(Irp, ntStatus);
        }
        }
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_PdoPower(DeviceExtensionPort, Irp, ioStackLocation->MinorFunction);
        //
        // power routines handle irp completion
        //
        break;

#ifdef WMI_SUPPORT
    case IRP_MJ_SYSTEM_CONTROL:
        USBH_KdPrint((2,"'PDO IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus =
            USBH_PortSystemControl(DeviceExtensionPort, Irp);
        break;
#endif

    default:

        USBH_KdBreak(("Unhandled Irp for Pdo %x Irp_Mj %x\n",
                       deviceObject, ioStackLocation->MajorFunction));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        USBH_CompleteIrp(Irp, ntStatus);
        break;

    }

    USBH_KdPrint((2,"' exit USBH_PdoDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_ResetDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN KeepConfiguration,
    IN ULONG RetryIteration
    )
 /* ++
  *
  * Description:
  *
  * Given a port device object re-create the USB device attached to it
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub FDO extension that has a new connected port
  * PortNumber - the port that has a device connected. IsLowSpeed - to
  *     indicate if the attached device is a low speed one
  *
  * Return:
  *
  * this function returns an error if the device could not be created or
  * if the device is different from the previous device.
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObjectPort;
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    BOOLEAN fNeedResetBeforeSetAddress = TRUE;
    PPORT_DATA portData;
    BOOLEAN isLowSpeed;
    PVOID deviceData, oldDeviceData = NULL;
    PORT_STATE portState;
    USHORT portStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'ResetDevice for port %x\n", PortNumber));

    LOGENTRY(LOG_PNP, "rst1",
                DeviceExtensionHub,
                PortNumber,
                0);

    // validate that there is actually a device still conected
    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    if (!(NT_SUCCESS(ntStatus) &&
          (portState.PortStatus & PORT_STATUS_CONNECT))) {

        // error or no device connected

        LOGENTRY(LOG_PNP, "rstx",
                DeviceExtensionHub,
                PortNumber,
                ntStatus);

        return STATUS_UNSUCCESSFUL;
    }

    // Don't allow QBR while we are resetting this device because QBR will
    // toss any PDO for a port that does not have the connect bit set,
    // and this will be the case for this device after we have reset the port
    // until we have finished resetting it.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    oldDeviceData = NULL;

    LOGENTRY(LOG_PNP, "resD", DeviceExtensionHub,
                 PortNumber,
                 KeepConfiguration);

    //
    // First get the PDO for the connected device
    //

    portData = &DeviceExtensionHub->PortData[PortNumber - 1];

    deviceObjectPort = portData->DeviceObject;
    if (!deviceObjectPort) {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto USBH_ResetDevice_Done;
    }

    deviceExtensionPort =
        (PDEVICE_EXTENSION_PORT) deviceObjectPort->DeviceExtension;

    portStatus = portData->PortState.PortStatus;
    isLowSpeed = (portData->PortState.PortStatus &
                               PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;

    LOGENTRY(LOG_PNP, "resP", DeviceExtensionHub,
                 deviceObjectPort,
                 deviceExtensionPort->DeviceData);

#if DBG
    if (KeepConfiguration) {
        USBH_ASSERT(deviceExtensionPort->DeviceData != NULL);
    }
#endif

    deviceData = InterlockedExchangePointer(
                    &deviceExtensionPort->DeviceData,
                    NULL);

    if (deviceData == NULL) {
        // device data is null if we are restoring a device associated
        // with an existing pdo (ie remove-refresh)
        oldDeviceData = NULL;
        LOGENTRY(LOG_PNP, "rstn", ntStatus, PortNumber, oldDeviceData);
    } else {

        if (deviceExtensionPort->PortPdoFlags & PORTPDO_DD_REMOVED) {
            oldDeviceData = deviceData;
            LOGENTRY(LOG_PNP, "rst0", ntStatus, PortNumber, oldDeviceData);
        } else {
#ifdef USB2
            ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                         deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         (UCHAR) (KeepConfiguration ?
                                             USBD_KEEP_DEVICE_DATA : 0));
#else
            ntStatus = USBD_RemoveDevice(deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         (UCHAR) (KeepConfiguration ?
                                             USBD_KEEP_DEVICE_DATA : 0));
#endif

            oldDeviceData = deviceData;
            LOGENTRY(LOG_PNP, "rst2", ntStatus, PortNumber, oldDeviceData);
            deviceExtensionPort->PortPdoFlags |= PORTPDO_DD_REMOVED;
        }

    }
    //
    // reset the port
    //
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
        LOGENTRY(LOG_PNP, "rst3", ntStatus, PortNumber, oldDeviceData);
    }

    // for USB 2 we won't know if the device is high speed until after reset
    // refresh status now
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                          PortNumber,
                                          (PUCHAR) &portData->PortState,
                                          sizeof(portData->PortState));
        portStatus = portData->PortState.PortStatus;                                          
    }                                          

    if (NT_SUCCESS(ntStatus)) {
        //
        // call usbd to create device for this connection
        //
#ifdef USB2
        ntStatus = USBD_CreateDeviceEx(DeviceExtensionHub,
                                       &deviceExtensionPort->DeviceData,
                                       DeviceExtensionHub->RootHubPdo,
                                       0, // optional default endpoint0 max packet
                                          // size
                                       &deviceExtensionPort->DeviceHackFlags,
                                       portStatus,
                                       PortNumber);
#else
        ntStatus = USBD_CreateDevice(&deviceExtensionPort->DeviceData,
                                      DeviceExtensionHub->RootHubPdo,
                                      isLowSpeed,
                                      0, // optional default endpoint0 max packet
                                         // size
                                      &deviceExtensionPort->DeviceHackFlags);
                                                        // flag to indicate if
                                                        // we need a second
                                                        // reset
#endif

#if DBG
        if (UsbhPnpTest & PNP_TEST_FAIL_RESTORE) {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
#endif
        LOGENTRY(LOG_PNP, "rst4", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }

    //
    // some early versions of USB firmware could not handle the premature
    // termination of a control command.
    //

    if (fNeedResetBeforeSetAddress && NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'NeedResetBeforeSetAddress\n"));
        ntStatus = USBH_SyncResetPort(DeviceExtensionHub, PortNumber);
#if DBG
        if (!NT_SUCCESS(ntStatus)) {
           USBH_KdBreak(("Failure on second reset %x fail %x\n", PortNumber, ntStatus));
        }
#endif

        // For some reason, the amount of time between the GetDescriptor request
        // and the SetAddress request decreased when we switched from the older
        // monolithic UHCD.SYS to the new USBUHCI.SYS miniport.  And apparently,
        // there have been found at least two devices that were dependent on
        // the longer delay.  According to GlenS who looked at one of these
        // devices on the CATC, delta time was ~80ms with UHCD.SYS and ~35ms
        // with USBUHCI.SYS.  So, Glen found that by inserting a 50ms delay
        // here, it allows at least one of these devices to now enumerate
        // properly.  For performance reasons, we have decided to only insert
        // this delay if a previous enumeration retry has failed, so as not
        // to impact the enumeration time of all devices.

        if (RetryIteration) {
            UsbhWait(50);
        }

        LOGENTRY(LOG_PNP, "rst5", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }

    if (NT_SUCCESS(ntStatus)) {
#ifdef USB2
        ntStatus = USBD_InitializeDeviceEx(DeviceExtensionHub,
                                         deviceExtensionPort->DeviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         &deviceExtensionPort->DeviceDescriptor,
                                         sizeof(USB_DEVICE_DESCRIPTOR),
                                         &deviceExtensionPort->ConfigDescriptor,
                                         sizeof(USB_CONFIGURATION_DESCRIPTOR));
#else
        ntStatus = USBD_InitializeDevice(deviceExtensionPort->DeviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         &deviceExtensionPort->DeviceDescriptor,
                                         sizeof(USB_DEVICE_DESCRIPTOR),
                                         &deviceExtensionPort->ConfigDescriptor,
                                         sizeof(USB_CONFIGURATION_DESCRIPTOR));
#endif
        if (!NT_SUCCESS(ntStatus)) {
            // InitializeDevice frees the DeviceData structure on failure
            deviceExtensionPort->DeviceData = NULL;
        }

        LOGENTRY(LOG_PNP, "rst6", ntStatus, PortNumber,
            deviceExtensionPort->DeviceData);
    }


    if (NT_SUCCESS(ntStatus) && KeepConfiguration) {
        // device is now addressed, restore the old config if possible
#ifdef USB2
        ntStatus = USBD_RestoreDeviceEx(DeviceExtensionHub,
                                        oldDeviceData,
                                        deviceExtensionPort->DeviceData,
                                        DeviceExtensionHub->RootHubPdo);
#else
        ntStatus = USBD_RestoreDevice(oldDeviceData,
                                      deviceExtensionPort->DeviceData,
                                      DeviceExtensionHub->RootHubPdo);
#endif

        LOGENTRY(LOG_PNP, "rst7", ntStatus, PortNumber,
            oldDeviceData);

        if (!NT_SUCCESS(ntStatus)) {
            // if we fail here remove the newly created device

            deviceData = InterlockedExchangePointer(
                            &deviceExtensionPort->DeviceData,
                            NULL);

#ifdef USB2
            USBD_RemoveDeviceEx(DeviceExtensionHub,
                              deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#else
            USBD_RemoveDevice(deviceData,
                              DeviceExtensionHub->RootHubPdo,
                              0);
#endif

            LOGENTRY(LOG_PNP, "rst8", ntStatus, PortNumber,
                oldDeviceData);

            USBH_SyncDisablePort(DeviceExtensionHub,
                                 PortNumber);
                                 
            ntStatus = STATUS_NO_SUCH_DEVICE;
            goto USBH_ResetDevice_Done;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {

        //
        // we have a failure, device data should be freed
        //

        USBH_KdPrint((2,"'InitDevice (reset) for port %x failed %x\n",
            PortNumber, ntStatus));

        LOGENTRY(LOG_PNP, "rst!", ntStatus, PortNumber,
                oldDeviceData);

        //
        // note: oldDeviceData may be null
        //

        deviceData = InterlockedExchangePointer(
                        &deviceExtensionPort->DeviceData,
                        oldDeviceData);

        if (deviceData != NULL) {
            //
            // we need to remove the device data we created in the restore
            // attempt
            //
#ifdef USB2
            ntStatus = USBD_RemoveDeviceEx(DeviceExtensionHub,
                                         deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         0);
#else
            ntStatus = USBD_RemoveDevice(deviceData,
                                         DeviceExtensionHub->RootHubPdo,
                                         FALSE);
#endif
            LOGENTRY(LOG_PNP, "rst9", ntStatus, PortNumber,
                    oldDeviceData);
        }

        //
        // disable the port, device is in a bad state
        //

        // NOTE: we don't disable the port on failed reset here
        // in case we need to retry
        //USBH_SyncDisablePort(DeviceExtensionHub,
        //                     PortNumber);

        // possibly signal the device has been removed
        //
        USBH_KdPrint((0,"'Warning: device/port reset failed\n"));

    } else {
        deviceExtensionPort->PortPdoFlags &= ~PORTPDO_DD_REMOVED;
        LOGENTRY(LOG_PNP, "rsOK", ntStatus, PortNumber,
                oldDeviceData);
    }

USBH_ResetDevice_Done:

    USBH_KdPrint((2,"'Exit Reset PDO=%x\n", deviceObjectPort));

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    return ntStatus;
}


NTSTATUS
USBH_RestoreDevice(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN BOOLEAN KeepConfiguration
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub FDO extension that has a new connected port
  *
  * Return:
  *
  * this function returns an error if the device could not be created or
  * if the device is different from the previous device.
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PPORT_DATA portData;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    ULONG count = 0;

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;
    ASSERT_HUB(deviceExtensionHub);

    if (!deviceExtensionHub) {
        return STATUS_UNSUCCESSFUL;
    }

    portData = &deviceExtensionHub->PortData[
                    DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "RSdv", DeviceExtensionPort,
                deviceExtensionHub,
                DeviceExtensionPort->PortNumber);

    //
    // doule check that this device did not disaaper on us

    //

    LOGENTRY(LOG_PNP, "chkD",
                DeviceExtensionPort->PortPhysicalDeviceObject,
                portData->DeviceObject,
                0);

    if (DeviceExtensionPort->PortPhysicalDeviceObject !=
        portData->DeviceObject) {
        TEST_TRAP();

        return STATUS_UNSUCCESSFUL;
    }

    //
    // we need to refresh the port data since it was lost on the stop
    //
    ntStatus = USBH_SyncGetPortStatus(deviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portData->PortState,
                                      sizeof(portData->PortState));

    USBH_ASSERT(DeviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET);

    // try the reset three times

    if (NT_SUCCESS(ntStatus)) {
        do {
            LOGENTRY(LOG_PNP, "tryR", count, ntStatus, 0);
            ntStatus = USBH_ResetDevice(deviceExtensionHub,
                                        DeviceExtensionPort->PortNumber,
                                        KeepConfiguration,
                                        count);
            count++;
            if (NT_SUCCESS(ntStatus) || ntStatus == STATUS_NO_SUCH_DEVICE) {
                break;
            }
#if DBG
            if (count == 1) {
            
                UsbhWarning(NULL,
                            "USB device failed first reset attempt in USBH_RestoreDevice\n",
                            (BOOLEAN)((USBH_Debug_Trace_Level >= 3) ? TRUE : FALSE));
            }
#endif

            //
            // Sometimes the MS USB speakers need a little more time.
            //
            UsbhWait(1000);

        } while (count < USBH_MAX_ENUMERATION_ATTEMPTS);
    }

    DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_NEED_RESET;

    //
    // If the device could not be properly restored then do not allow any
    // requests to it.
    //
    if (ntStatus != STATUS_SUCCESS) {

        USBH_KdPrint((0,"'Warning: device/port restore failed\n"));

        LOGENTRY(LOG_PNP, "RSd!", DeviceExtensionPort,
                    deviceExtensionHub,
                    DeviceExtensionPort->PortNumber);

        DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_FAILED;
        DeviceExtensionPort->PortPdoFlags |= PORTPDO_DEVICE_ENUM_ERROR;

        // Generate a WMI event so UI can inform the user.
        USBH_PdoEvent(deviceExtensionHub, DeviceExtensionPort->PortNumber);

    } else {
        DeviceExtensionPort->PortPdoFlags &= ~PORTPDO_DEVICE_FAILED;
    }

    USBH_KdBreak(("'USBH_RestoreDevice = %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_PdoQueryDeviceText(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES).
  * Supposedly, this is a message forwarded by port device Fdo.
  *
  * Argument:
  *
  * DeviceExtensionPort - This is a a Pdo extension we created for the port
  * device. Irp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION ioStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    DEVICE_TEXT_TYPE deviceTextType;
    LANGID languageId;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSB_STRING_DESCRIPTOR usbString;
    PWCHAR deviceText;
    ULONG ulBytes = 0;

    PAGED_CODE();
    deviceObject = DeviceExtensionPort->PortPhysicalDeviceObject;
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    deviceExtensionHub = DeviceExtensionPort->DeviceExtensionHub;

    deviceTextType = ioStack->
            Parameters.QueryDeviceText.DeviceTextType;

    // Validate DeviceTextType for IrpAssert

    if (deviceTextType != DeviceTextDescription &&
        deviceTextType != DeviceTextLocationInformation) {

        USBH_KdPrint((2, "'PdoQueryDeviceText called with bogus DeviceTextType\n"));
        //
        // return the original status passed to us
        //
        ntStatus = Irp->IoStatus.Status;
        goto USBH_PdoQueryDeviceTextDone;
    }

    languageId = (LANGID)(ioStack->Parameters.QueryDeviceText.LocaleId >> 16);

    USBH_KdPrint((2,"'PdoQueryDeviceText Pdo %x type = %x, lang = %x locale %x\n",
            deviceObject, deviceTextType, languageId, ioStack->Parameters.QueryDeviceText.LocaleId));

    if (!languageId) {
        languageId = 0x0409;    // Use English if no language ID.
    }

    //
    // See if the device supports strings.  For non compliant device mode
    // we won't even try.
    //

    if (DeviceExtensionPort->DeviceData == NULL ||
        DeviceExtensionPort->DeviceDescriptor.iProduct == 0 ||
        (DeviceExtensionPort->DeviceHackFlags & USBD_DEVHACK_DISABLE_SN) ||
        (DeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_ENUM_ERROR)) {
        // string descriptor
        USBH_KdBreak(("no product string\n", deviceObject));
        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (NT_SUCCESS(ntStatus)) {

        usbString = UsbhExAllocatePool(NonPagedPool, MAXIMUM_USB_STRING_LENGTH);

        if (usbString) {

QDT_Retry:
            ntStatus = USBH_CheckDeviceLanguage(deviceObject,
                                                languageId);

            if (NT_SUCCESS(ntStatus)) {
                //
                // Device supports our language, get the string.
                //

                ntStatus = USBH_SyncGetStringDescriptor(deviceObject,
                                                        DeviceExtensionPort->DeviceDescriptor.iProduct, //index
                                                        languageId, //langid
                                                        usbString,
                                                        MAXIMUM_USB_STRING_LENGTH,
                                                        NULL,
                                                        TRUE);

                if (!NT_SUCCESS(ntStatus) && languageId != 0x409) {

                    // We are running a non-English flavor of the OS, but the
                    // attached USB device does not contain device text in
                    // the requested language.  Let's try again for English.

                    languageId = 0x0409;
                    goto QDT_Retry;
                }

                if (NT_SUCCESS(ntStatus) &&
                    usbString->bLength <= sizeof(UNICODE_NULL)) {

                    ntStatus = STATUS_UNSUCCESSFUL;
                }

                if (NT_SUCCESS(ntStatus)) {
                    //
                    // return the string
                    //

                    //
                    // must use stock alloc function because the caller frees the
                    // buffer
                    //
                    // note: the descriptor header is the same size as
                    // a unicode NULL so we don't have to adjust the size
                    //

                    deviceText = ExAllocatePoolWithTag(PagedPool, usbString->bLength, USBHUB_HEAP_TAG);
                    if (deviceText) {
                        RtlZeroMemory(deviceText, usbString->bLength);
                        RtlCopyMemory(deviceText, &usbString->bString[0],
                            usbString->bLength - sizeof(UNICODE_NULL));

                        Irp->IoStatus.Information = (ULONG_PTR) deviceText;

                        USBH_KdBreak(("Returning Device Text %x\n", deviceText));
                    } else {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }
            } else if (languageId != 0x409) {

                // We are running a non-English flavor of the OS, but the
                // attached USB device does support the requested language.
                // Let's try again for English.

                languageId = 0x0409;
                goto QDT_Retry;
            }

            UsbhExFreePool(usbString);

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (!NT_SUCCESS(ntStatus) && GenericUSBDeviceString) {
        USBH_KdPrint((2, "'No product string for devobj (%x), returning generic string\n", deviceObject));

        STRLEN(ulBytes, GenericUSBDeviceString);

        ulBytes += sizeof(UNICODE_NULL);

        deviceText = ExAllocatePoolWithTag(PagedPool, ulBytes, USBHUB_HEAP_TAG);
        if (deviceText) {
            RtlZeroMemory(deviceText, ulBytes);
            RtlCopyMemory(deviceText,
                          GenericUSBDeviceString,
                          ulBytes);
            Irp->IoStatus.Information = (ULONG_PTR) deviceText;
            ntStatus = STATUS_SUCCESS;
        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

USBH_PdoQueryDeviceTextDone:

    return ntStatus;
}

#ifdef _WIN64
#define BAD_POINTER ((PVOID)0xFFFFFFFFFFFFFFFE)
#else
#define BAD_POINTER ((PVOID)0xFFFFFFFE)
#endif
#define ISPTR(ptr) ((ptr) && ((ptr) != BAD_POINTER))


NTSTATUS
USBH_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    LPGUID lpGuid
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;


    if (CreateFlag){

        /*
         *  Create the symbolic link
         */
        ntStatus = IoRegisterDeviceInterface(
                    DeviceExtensionPort->PortPhysicalDeviceObject,
                    lpGuid,
                    NULL,
                    &DeviceExtensionPort->SymbolicLinkName);

        if (NT_SUCCESS(ntStatus)) {

            /*
             *  Now set the symbolic link for the association and store it..
             */
            //USBH_ASSERT(ISPTR(pdoExt->name));

            //
            // (lonnym): Previously, the following call was being made with
            // &DeviceExtensionPort->PdoName passed as the second parameter.
            // Code review this change, to see whether or not you still need to keep
            // this information around.
            //

            // write the symbolic name to the registry
            {
                WCHAR hubNameKey[] = L"SymbolicName";

                USBH_SetPdoRegistryParameter (
                    DeviceExtensionPort->PortPhysicalDeviceObject,
                    &hubNameKey[0],
                    sizeof(hubNameKey),
                    &DeviceExtensionPort->SymbolicLinkName.Buffer[0],
                    DeviceExtensionPort->SymbolicLinkName.Length,
                    REG_SZ,
                    PLUGPLAY_REGKEY_DEVICE);
            }

            ntStatus = IoSetDeviceInterfaceState(&DeviceExtensionPort->SymbolicLinkName, TRUE);
        }
    } else {

        /*
         *  Disable the symbolic link
         */
        if (ISPTR(DeviceExtensionPort->SymbolicLinkName.Buffer)) {
            ntStatus = IoSetDeviceInterfaceState(&DeviceExtensionPort->SymbolicLinkName, FALSE);
            ExFreePool( DeviceExtensionPort->SymbolicLinkName.Buffer );
            DeviceExtensionPort->SymbolicLinkName.Buffer = BAD_POINTER;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    UNICODE_STRING keyNameUnicodeString;

    PAGED_CODE();

    RtlInitUnicodeString(&keyNameUnicodeString, KeyName);

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     DevInstKeyType,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);


    if (NT_SUCCESS(ntStatus)) {
/*
        RtlInitUnicodeString(&keyName, L"DeviceFoo");
        ZwSetValueKey(handle,
                      &keyName,
                      0,
                      REG_DWORD,
                      ComplienceFlags,
                      sizeof(*ComplienceFlags));
*/

        USBH_SetRegistryKeyValue(handle,
                                 &keyNameUnicodeString,
                                 Data,
                                 DataLength,
                                 KeyType);

        ZwClose(handle);
    }

    USBH_KdPrint((3,"'USBH_SetPdoRegistryParameter status 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    PAGED_CODE();

//    InitializeObjectAttributes( &objectAttributes,
//                                KeyNameString,
//                                OBJ_CASE_INSENSITIVE,
//                                Handle,
//                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //
#if 0
    ntStatus = ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
#endif
    ntStatus = ZwSetValueKey(Handle,
                             KeyNameUnicodeString,
                             0,
                             KeyType,
                             Data,
                             DataLength);

    USBH_KdPrint((2,"' ZwSetKeyValue = 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           ValueName,
    OUT PVOID           Data,
    IN ULONG            DataLength,
    OUT PULONG          Type,
    OUT PULONG          ActualDataLength
    )
/*++

Routine Description:

    This routines queries the data for a registry value entry associated
    with the device instance specific registry key for the PDO.

    The registry value entry would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    PhysicalDeviceObject - Yep, the PDO

    ValueName - Name of the registry value entry for which the data is requested

    Data - Buffer in which the requested data is returned

    DataLength - Length of the data buffer

    Type - (optional) The data type (e.g. REG_SZ, REG_DWORD) is returned here

    ActualDataLength - (optional) The actual length of the data is returned here
                       If this is larger than DataLength then not all of the
                       value data has been returned.

Return Value:

--*/
{
    HANDLE      handle;
    NTSTATUS    ntStatus;

    PAGED_CODE();
    
    ntStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                       PLUGPLAY_REGKEY_DEVICE,
                                       STANDARD_RIGHTS_ALL,
                                       &handle);

    if (NT_SUCCESS(ntStatus))
    {
        PKEY_VALUE_PARTIAL_INFORMATION  partialInfo;
        UNICODE_STRING                  valueName;
        ULONG                           length;
        ULONG                           resultLength;

        RtlInitUnicodeString(&valueName, ValueName);

        // Size and allocate a KEY_VALUE_PARTIAL_INFORMATION structure,
        // including room for the returned value data.
        //
        length = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) +
                 DataLength;

        partialInfo = UsbhExAllocatePool(PagedPool, length);

        if (partialInfo)
        {
            // Query the value data.
            //
            ntStatus = ZwQueryValueKey(handle,
                                       &valueName,
                                       KeyValuePartialInformation,
                                       partialInfo,
                                       length,
                                       &resultLength);

            // If we got any data that is good enough
            //
            if (ntStatus == STATUS_BUFFER_OVERFLOW)
            {
                ntStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(ntStatus))
            {
                // Only copy the smaller of the the requested data length or
                // the actual data length.
                //
                RtlCopyMemory(Data,
                              partialInfo->Data,
                              DataLength < partialInfo->DataLength ?
                              DataLength :
                              partialInfo->DataLength);

                // Return the value data type and actual length, if requested.
                //
                if (Type)
                {
                    *Type = partialInfo->Type;
                }

                if (ActualDataLength)
                {
                    *ActualDataLength = partialInfo->DataLength;
                }
            }

            UsbhExFreePool(partialInfo);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        ZwClose(handle);
    }

    return ntStatus;
}



NTSTATUS
USBH_OsVendorCodeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
{
    PAGED_CODE();

    if (ValueType != REG_BINARY ||
        ValueLength != 2 * sizeof(UCHAR))
    {
        return STATUS_INVALID_PARAMETER;
    }

    ((PUCHAR)EntryContext)[0] = ((PUCHAR)ValueData)[0];
    ((PUCHAR)EntryContext)[1] = ((PUCHAR)ValueData)[1];

    return STATUS_SUCCESS;
}

#ifndef USBHUB20
VOID
USBH_GetMsOsVendorCode(
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION_PORT      deviceExtensionPort;
    WCHAR                       path[] = L"usbflags\\vvvvpppprrrr";
    USHORT                      idVendor;
    USHORT                      idProduct;
    USHORT                      bcdDevice;
    ULONG                       i;
    RTL_QUERY_REGISTRY_TABLE    paramTable[2];
    UCHAR                       osvc[2];
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_PORT == deviceExtensionPort->ExtensionType);

    // Build the registry path string for the device
    //
    idVendor  = deviceExtensionPort->DeviceDescriptor.idVendor,
    idProduct = deviceExtensionPort->DeviceDescriptor.idProduct,
    bcdDevice = deviceExtensionPort->DeviceDescriptor.bcdDevice,

    i = sizeof("usbflags\\") - 1;

    path[i++] = NibbleToHexW(idVendor >> 12);
    path[i++] = NibbleToHexW((idVendor >> 8) & 0x000f);
    path[i++] = NibbleToHexW((idVendor >> 4) & 0x000f);
    path[i++] = NibbleToHexW(idVendor & 0x000f);

    path[i++] = NibbleToHexW(idProduct >> 12);
    path[i++] = NibbleToHexW((idProduct >> 8) & 0x000f);
    path[i++] = NibbleToHexW((idProduct >> 4) & 0x000f);
    path[i++] = NibbleToHexW(idProduct & 0x000f);

    path[i++] = NibbleToHexW(bcdDevice >> 12);
    path[i++] = NibbleToHexW((bcdDevice >> 8) & 0x000f);
    path[i++] = NibbleToHexW((bcdDevice >> 4) & 0x000f);
    path[i++] = NibbleToHexW(bcdDevice & 0x000f);

    // Check if MsOsVendorCode is already set in the registry.
    //
    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].QueryRoutine  = USBH_OsVendorCodeQueryRoutine;
    paramTable[0].Flags         = RTL_QUERY_REGISTRY_REQUIRED;
    paramTable[0].Name          = L"osvc";
    paramTable[0].EntryContext  = &osvc;

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_CONTROL,
                                      path,
                                      &paramTable[0],
                                      NULL,             // Context
                                      NULL);            // Environment

    // If the MsOsVendorCode value in the registry is valid, it indicates
    // whether or not the device supports the MS OS Descriptor request, and if
    // does, what the Vendor Code is.
    //
    if (NT_SUCCESS(ntStatus))
    {
        if (osvc[0] == 1)
        {
            deviceExtensionPort->FeatureDescVendorCode = osvc[1];

            deviceExtensionPort->PortPdoFlags |= PORTPDO_MS_VENDOR_CODE_VALID;
        }

        return;
    }

    // If we have not asked the device for the MS OS String Descriptor yet
    // do that now, but only if the device indicates that it has some other
    // string descriptors.
    //
    if (deviceExtensionPort->DeviceDescriptor.idVendor != 0 ||
        deviceExtensionPort->DeviceDescriptor.iProduct != 0 ||
        deviceExtensionPort->DeviceDescriptor.iSerialNumber != 0)
    {
        OS_STRING   osString;
        ULONG       bytesReturned;

        // Try to retrieve the MS OS String Descriptor from the device.
        //
        ntStatus = USBH_SyncGetStringDescriptor(
                       DeviceObject,
                       OS_STRING_DESCRIPTOR_INDEX,
                       0,
                       (PUSB_STRING_DESCRIPTOR)&osString,
                       sizeof(OS_STRING),
                       &bytesReturned,
                       TRUE);

        if (NT_SUCCESS(ntStatus) &&
            (bytesReturned == sizeof(OS_STRING)) &&
            (RtlCompareMemory(&osString.MicrosoftString,
                              MS_OS_STRING_SIGNATURE,
                              sizeof(osString.MicrosoftString)) ==
             sizeof(osString.MicrosoftString)))
        {
            // This device has a valid MS OS String Descriptor.
            // Let's pluck out the corresponding Vendor Code and
            // save that away in the device extension.
            //
            deviceExtensionPort->FeatureDescVendorCode = osString.bVendorCode;

            deviceExtensionPort->PortPdoFlags |= PORTPDO_MS_VENDOR_CODE_VALID;
        }
        else
        {
            // Maybe we've wedged the device by sending it our questionable
            // proprietary request.  Reset the device for good measure.
            //
            USBH_SyncResetDevice(DeviceObject);
        }
    }

    // Write the MsOsVendorCode value to the registry.  It indicates whether
    // or not the device supports the MS OS Descriptor request, and if
    // does, what the Vendor Code is.
    //
    if (deviceExtensionPort->PortPdoFlags & PORTPDO_MS_VENDOR_CODE_VALID)
    {
        osvc[0] = 1;
        osvc[1] = deviceExtensionPort->FeatureDescVendorCode;
    }
    else
    {
        osvc[0] = 0;
        osvc[1] = 0;
    }

    ntStatus = RtlWriteRegistryValue(RTL_REGISTRY_CONTROL,
                                     path,
                                     L"osvc",
                                     REG_BINARY,
                                     &osvc[0],
                                     sizeof(osvc));
}


NTSTATUS
USBH_GetMsOsFeatureDescriptor(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            Interface,
    IN USHORT           Index,
    IN OUT PVOID        DataBuffer,
    IN ULONG            DataBufferLength,
    OUT PULONG          BytesReturned
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_PORT                      deviceExtensionPort;
    USHORT                                      function;
    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *urb;
    NTSTATUS                                    ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;
    USBH_ASSERT(EXTENSION_TYPE_PORT == deviceExtensionPort->ExtensionType);

    *BytesReturned = 0;

    // Make sure the device supports the MS OS Descriptor request
    //
    if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_MS_VENDOR_CODE_VALID))
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Device, Endpoint, or Interface request?
    //
    switch (Recipient)
    {
        case 0:
            function = URB_FUNCTION_VENDOR_DEVICE;
            break;
        case 1:
            function = URB_FUNCTION_VENDOR_INTERFACE;
            break;
        case 2:
            function = URB_FUNCTION_VENDOR_ENDPOINT;
            break;
        default:
            return STATUS_INVALID_PARAMETER;
    }

    // Make sure the requested buffer length is valid
    //
    if (DataBufferLength == 0 ||
        DataBufferLength > 0xFF * 0xFFFF)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate a URB for the request
    //
    urb = UsbhExAllocatePool(NonPagedPool, sizeof(*urb));

    if (NULL == urb)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        ULONG   bytesReturned;
        UCHAR   pageNumber;

        bytesReturned = 0;

        pageNumber = 0;

        while (1)
        {
            // Initialize the URB for the current page
            //
            RtlZeroMemory(urb, sizeof(*urb));

            urb->Hdr.Length = sizeof(*urb);

            urb->Hdr.Function = function;

            urb->TransferFlags = USBD_TRANSFER_DIRECTION_IN;

            urb->TransferBufferLength = DataBufferLength < 0xFFFF ?
                                        DataBufferLength :
                                        0xFFFF;

            urb->TransferBuffer = DataBuffer;

            urb->Request = deviceExtensionPort->FeatureDescVendorCode;

            urb->Value = (Interface << 8) | pageNumber;

            urb->Index = Index;

            // Send down the URB for the current page
            //
            ntStatus = USBH_SyncSubmitUrb(DeviceObject, (PURB)urb);

            // If the request failed then we are done.
            //
            if (!NT_SUCCESS(ntStatus))
            {
                break;
            }

            (PUCHAR)DataBuffer += urb->TransferBufferLength;

            DataBufferLength   -= urb->TransferBufferLength;

            bytesReturned      += urb->TransferBufferLength;

            pageNumber++;

            // If the result was less than the max page size or there are
            // no more bytes remaining then we are done.
            //
            if (urb->TransferBufferLength < 0xFFFF ||
                DataBufferLength == 0)
            {
                *BytesReturned = bytesReturned;

                break;
            }

        }

        // Done with the URB now, free it
        //
        UsbhExFreePool(urb);
    }

    return ntStatus;
}


VOID
USBH_InstallExtPropDesc (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routines queries a device for an Extended Properties Descriptor, but
    only once the very first time for a given instance of a device.

    If the Extended Properties Descriptor and all of the Custom Property
    Sections appear valid then each Custom Property section <ValueName,
    ValueData> pair is installed in the device instance specific registry key
    for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    DeviceObject - The PDO

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION_PORT  deviceExtensionPort;
    static WCHAR            USBH_DidExtPropDescKey[] = L"ExtPropDescSemaphore";
    ULONG                   didExtPropDesc;
    MS_EXT_PROP_DESC_HEADER msExtPropDescHeader;
    PMS_EXT_PROP_DESC       pMsExtPropDesc;
    ULONG                   bytesReturned;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtensionPort = DeviceObject->DeviceExtension;

    // Check if the semaphore value is already set in the registry.  We only
    // care whether or not it already exists, not what data it has.
    //
    ntStatus = USBH_GetPdoRegistryParameter(DeviceObject,
                                            USBH_DidExtPropDescKey,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL);
    
    if (NT_SUCCESS(ntStatus))
    {
        // Already did this once for this device instance.  Don't do it again.
        //
        return;
    }

    // Set the semaphore key in the registry so that we only run the following
    // code once per device.

    didExtPropDesc = 1;

    USBH_SetPdoRegistryParameter(DeviceObject,
                                 USBH_DidExtPropDescKey,
                                 sizeof(USBH_DidExtPropDescKey),
                                 &didExtPropDesc,
                                 sizeof(didExtPropDesc),
                                 REG_DWORD,
                                 PLUGPLAY_REGKEY_DEVICE);


    RtlZeroMemory(&msExtPropDescHeader, sizeof(MS_EXT_PROP_DESC_HEADER));

    // Request just the header of the MS Extended Property Descriptor 
    //
    ntStatus = USBH_GetMsOsFeatureDescriptor(
                   DeviceObject,
                   1,   // Recipient Interface
                   0,   // Interface
                   MS_EXT_PROP_DESCRIPTOR_INDEX,
                   &msExtPropDescHeader,
                   sizeof(MS_EXT_PROP_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Property Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.dwLength >= sizeof(MS_EXT_PROP_DESC_HEADER) &&
        msExtPropDescHeader.bcdVersion == MS_EXT_PROP_DESC_VER &&
        msExtPropDescHeader.wIndex == MS_EXT_PROP_DESCRIPTOR_INDEX &&
        msExtPropDescHeader.wCount > 0)
    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtPropDesc = UsbhExAllocatePool(NonPagedPool,
                                            msExtPropDescHeader.dwLength);

        
        if (pMsExtPropDesc)
        {
            RtlZeroMemory(pMsExtPropDesc, msExtPropDescHeader.dwLength);

            // Request the entire MS Extended Property Descriptor
            //
            ntStatus = USBH_GetMsOsFeatureDescriptor(
                           DeviceObject,
                           1,   // Recipient Interface
                           0,   // Interface
                           MS_EXT_PROP_DESCRIPTOR_INDEX,
                           pMsExtPropDesc,
                           msExtPropDescHeader.dwLength,
                           &bytesReturned);

            if (NT_SUCCESS(ntStatus) &&
                bytesReturned == msExtPropDescHeader.dwLength &&
                RtlCompareMemory(&msExtPropDescHeader,
                                 pMsExtPropDesc,
                                 sizeof(MS_EXT_PROP_DESC_HEADER)) ==
                sizeof(MS_EXT_PROP_DESC_HEADER))
            {
                // MS Extended Property Descriptor retrieved ok, parse and
                // install each Custom Property Section it contains.
                //
                USBH_InstallExtPropDescSections(DeviceObject,
                                                pMsExtPropDesc);
            }

            // Done with the MS Extended Property Descriptor buffer, free it
            //
            UsbhExFreePool(pMsExtPropDesc);
        }
    }
}

VOID
USBH_InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    )
/*++

Routine Description:

    This routines parses an Extended Properties Descriptor and validates each
    Custom Property Section contained in the Extended Properties Descriptor.

    If all of the Custom Property Sections appear valid then each Custom
    Property section <ValueName, ValueData> pair is installed in the device
    instance specific registry key for the PDO.

    The registry value entries would be found under this registry key:
    HKLM\System\CCS\Enum\<DeviceID>\<InstanceID>\Device Parameters

Arguments:

    DeviceObject - The PDO

    pMsExtPropDesc - Pointer to an Extended Properties Descriptor buffer.
                     It is assumed that the header of this descriptor has
                     already been validated.

Return Value:

    None

--*/
{
    PUCHAR  p;
    PUCHAR  end;
    ULONG   pass;
    ULONG   i;

    ULONG   dwSize;
    ULONG   dwPropertyDataType;
    USHORT  wPropertyNameLength;
    PWCHAR  bPropertyName;
    ULONG   dwPropertyDataLength;
    PVOID   bPropertyData;

    NTSTATUS    ntStatus;

    PAGED_CODE();

    // Get a pointer to the end of the entire Extended Properties Descriptor
    //
    end = (PUCHAR)pMsExtPropDesc + pMsExtPropDesc->Header.dwLength;

    // First pass:  Validate each Custom Property Section
    // Second pass: Install  each Custom Property Section (if first pass ok)
    //
    for (pass = 0; pass < 2; pass++)
    {
        // Get a pointer to the first Custom Property Section
        //
        p = (PUCHAR)&pMsExtPropDesc->CustomSection[0];

        // Iterate over all of the Custom Property Sections
        //
        for (i = 0; i < pMsExtPropDesc->Header.wCount; i++)
        {
            ULONG   offset;

            // Make sure the dwSize field is in bounds 
            //
            if (p + sizeof(ULONG) > end)
            {
                break;
            }

            // Extract the dwSize field and advance running offset
            //
            dwSize = *((PULONG)p);

            offset = sizeof(ULONG);

            // Make sure the entire structure is in bounds
            //
            if (p + dwSize > end)
            {
                break;
            }

            // Make sure the dwPropertyDataType field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataType field and advance running offset
            //
            dwPropertyDataType = *((PULONG)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the wPropertyNameLength field is in bounds
            //
            if (dwSize < offset + sizeof(USHORT))
            {
                break;
            }

            // Extract the wPropertyNameLength field and advance running offset
            //
            wPropertyNameLength = *((PUSHORT)(p + offset));

            offset += sizeof(USHORT);

            // Make sure the bPropertyName field is in bounds
            //
            if (dwSize < offset + wPropertyNameLength)
            {
                break;
            }

            // Set the bPropertyName pointer and advance running offset
            //
            bPropertyName = (PWCHAR)(p + offset);

            offset += wPropertyNameLength;

            // Make sure the dwPropertyDataLength field is in bounds

            if (dwSize < offset + sizeof(ULONG))
            {
                break;
            }

            // Extract the dwPropertyDataLength field and advance running offset
            //
            dwPropertyDataLength = *((ULONG UNALIGNED*)(p + offset));

            offset += sizeof(ULONG);

            // Make sure the bPropertyData field is in bounds
            //
            if (dwSize < offset + dwPropertyDataLength)
            {
                break;
            }

            // Set the bPropertyData pointer and advance running offset
            //
            bPropertyData = p + offset;

            offset += wPropertyNameLength;


            // Make sure the dwPropertyDataType is valid
            //
            if (dwPropertyDataType < REG_SZ ||
                dwPropertyDataType > REG_MULTI_SZ)
            {
                break;
            }

            // Make sure the wPropertyNameLength is valid
            //
            if (wPropertyNameLength == 0 ||
                (wPropertyNameLength % sizeof(WCHAR)) != 0)
            {
                break;
            }

            // Make sure bPropertyName is NULL terminated
            //
            if (bPropertyName[(wPropertyNameLength / sizeof(WCHAR)) - 1] !=
                UNICODE_NULL)
            {
                break;
            }

            // Everything looks ok, 
            //
            if (pass > 0)
            {
                ntStatus = USBH_SetPdoRegistryParameter(
                               DeviceObject,
                               bPropertyName,
                               wPropertyNameLength,
                               bPropertyData,
                               dwPropertyDataLength,
                               dwPropertyDataType,
                               PLUGPLAY_REGKEY_DEVICE);
            }
        }     
        
        // Skip the second pass if we bailed out of the first pass
        //
        if (i < pMsExtPropDesc->Header.wCount)
        {
            break;
        }
    }
}


PMS_EXT_CONFIG_DESC
USBH_GetExtConfigDesc (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routines queries a device for an Extended Configuration Descriptor.

Arguments:

    DeviceObject - The PDO

Return Value:

    If successful, a pointer to the Extended Configuration Descriptor, which the
    caller must free, else NULL.

--*/
{
    MS_EXT_CONFIG_DESC_HEADER   msExtConfigDescHeader;
    PMS_EXT_CONFIG_DESC         pMsExtConfigDesc;
    ULONG                       bytesReturned;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    pMsExtConfigDesc = NULL;

    RtlZeroMemory(&msExtConfigDescHeader, sizeof(MS_EXT_CONFIG_DESC_HEADER));

    // Request just the header of the MS Extended Configuration Descriptor 
    //
    ntStatus = USBH_GetMsOsFeatureDescriptor(
                   DeviceObject,
                   0,   // Recipient Device
                   0,   // Interface
                   MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                   &msExtConfigDescHeader,
                   sizeof(MS_EXT_CONFIG_DESC_HEADER),
                   &bytesReturned);

    // Make sure the MS Extended Configuration Descriptor header looks ok
    //
    if (NT_SUCCESS(ntStatus) &&
        bytesReturned == sizeof(MS_EXT_CONFIG_DESC_HEADER) &&
        msExtConfigDescHeader.bcdVersion == MS_EXT_CONFIG_DESC_VER &&
        msExtConfigDescHeader.wIndex == MS_EXT_CONFIG_DESCRIPTOR_INDEX &&
        msExtConfigDescHeader.bCount > 0 &&
        msExtConfigDescHeader.dwLength == sizeof(MS_EXT_CONFIG_DESC_HEADER) +
        msExtConfigDescHeader.bCount * sizeof(MS_EXT_CONFIG_DESC_FUNCTION))
        
    {
        // Allocate a buffer large enough for the entire descriptor
        //
        pMsExtConfigDesc = UsbhExAllocatePool(NonPagedPool,
                                              msExtConfigDescHeader.dwLength);

        
        if (pMsExtConfigDesc)
        {
            RtlZeroMemory(pMsExtConfigDesc, msExtConfigDescHeader.dwLength);

            // Request the entire MS Extended Configuration Descriptor
            //
            ntStatus = USBH_GetMsOsFeatureDescriptor(
                           DeviceObject,
                           0,   // Recipient Device
                           0,   // Interface
                           MS_EXT_CONFIG_DESCRIPTOR_INDEX,
                           pMsExtConfigDesc,
                           msExtConfigDescHeader.dwLength,
                           &bytesReturned);

            if (!(NT_SUCCESS(ntStatus) &&
                  bytesReturned == msExtConfigDescHeader.dwLength &&
                  RtlCompareMemory(&msExtConfigDescHeader,
                                   pMsExtConfigDesc,
                                   sizeof(MS_EXT_CONFIG_DESC_HEADER)) ==
                  sizeof(MS_EXT_CONFIG_DESC_HEADER)))
            {
                // Something went wrong retrieving the MS Extended Configuration
                // Descriptor.  Free the buffer.
                
                UsbhExFreePool(pMsExtConfigDesc);

                pMsExtConfigDesc = NULL;
            }
        }
    }

    return pMsExtConfigDesc;
}

BOOLEAN
USBH_ValidateExtConfigDesc (
    IN PMS_EXT_CONFIG_DESC              MsExtConfigDesc,
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor
    )
/*++

Routine Description:

    This routines validates an Extended Configuration Descriptor.

Arguments:

    MsExtConfigDesc - The Extended Configuration Descriptor to be validated.
                      It is assumed that the header of this descriptor has
                      already been validated.

    ConfigurationDescriptor - Configuration Descriptor, assumed to already
                              validated.

Return Value:

    TRUE if the Extended Configuration Descriptor appears to be valid,
    else FALSE.

--*/
{
    UCHAR   interfacesRemaining;
    ULONG   i;
    ULONG   j;
    UCHAR   c;
    BOOLEAN gotNull;

    PAGED_CODE();

    interfacesRemaining = ConfigurationDescriptor->bNumInterfaces;

    for (i = 0; i < MsExtConfigDesc->Header.bCount; i++)
    {
        // Make sure that there is at least one interface in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount == 0)
        {
            return FALSE;
        }

        // Make sure that there are not too many interfaces in this function.
        //
        if (MsExtConfigDesc->Function[i].bInterfaceCount > interfacesRemaining)
        {
            return FALSE;
        }

        interfacesRemaining -= MsExtConfigDesc->Function[i].bInterfaceCount;

        // Make sure the no interfaces were skipped between the interfaces
        // of the previous function and the interfaces of this function.
        //
        if (i &&
            MsExtConfigDesc->Function[i-1].bFirstInterfaceNumber +
            MsExtConfigDesc->Function[i-1].bInterfaceCount !=
            MsExtConfigDesc->Function[i].bFirstInterfaceNumber)
        {
            return FALSE;
        }

        // Make sure that the CompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].CompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].CompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that the SubCompatibleID is valid.
        // Valid characters are 'A' through 'Z', '0' through '9', and '_"
        // and null padded to the the right end of the array, but not
        // necessarily null terminated.
        //
        for (j = 0, gotNull = FALSE;
             j < sizeof(MsExtConfigDesc->Function[i].SubCompatibleID);
             j++)
        {
            c = MsExtConfigDesc->Function[i].SubCompatibleID[j];

            if (c == 0)
            {
                gotNull = TRUE;
            }
            else
            {
                if (gotNull ||
                    !((c >= 'A' && c <= 'Z') ||
                      (c >= '0' && c <= '9') ||
                      (c == '_')))
                {
                    return FALSE;
                }
            }
        }

        // Make sure that if the SubCompatibleID is non-null then the
        // CompatibleID is also non-null.
        //
        if (MsExtConfigDesc->Function[i].SubCompatibleID[0] != 0 &&
            MsExtConfigDesc->Function[i].CompatibleID[0] == 0)
        {
            return FALSE;
        }
    }

    // Make sure that all of the interfaces were consumed by functions.
    //
    if (interfacesRemaining > 0)
    {
        return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\usbhub.c ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:

    USBHUB.C

Abstract:

    This module contains code for the hub to function as a
    device on the USB. All USBH_Fdo functions live here.

Author:

    John Lee

Environment:

    kernel mode only

Notes:


Revision History:

    02-02-96 : created
    10-31-06 : jd, use worker thread to process change indications

--*/

#include <wdm.h>
#include <windef.h>
#include <ks.h>
#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wdmguid.h>
#endif /* WMI_SUPPORT */
#include "usbhub.h"
#include <stdio.h>


#define ESD_RECOVERY_TIMEOUT    5000    // Timeout in ms (5 sec)
#define ESD_RESET_TIMEOUT       5000


#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBH_ChangeIndicationWorker)
#pragma alloc_text(PAGE, USBH_ProcessHubStateChange)
// #pragma alloc_text(PAGE, USBH_ProcessPortStateChange)
#pragma alloc_text(PAGE, USBH_GetNameFromPdo)
//#pragma alloc_text(PAGE, USBH_MakeName)
//#pragma alloc_text(PAGE, USBH_GenerateDeviceName)
#pragma alloc_text(PAGE, USBH_FdoStartDevice)
#pragma alloc_text(PAGE, USBH_QueryCapabilities)
#pragma alloc_text(PAGE, USBH_FdoHubStartDevice)
// #pragma alloc_text(PAGE, UsbhFdoCleanup)
#pragma alloc_text(PAGE, USBH_FdoStopDevice)
#pragma alloc_text(PAGE, USBH_FdoRemoveDevice)
#pragma alloc_text(PAGE, USBH_FdoQueryBusRelations)
#pragma alloc_text(PAGE, USBH_HubIsBusPowered)
#pragma alloc_text(PAGE, USBH_HubESDRecoveryWorker)
#pragma alloc_text(PAGE, USBH_RegQueryDeviceIgnoreHWSerNumFlag)
#pragma alloc_text(PAGE, USBH_RegQueryGenericUSBDeviceString)
#pragma alloc_text(PAGE, USBH_DeviceIs2xDualMode)

// Win98 breaks if we have an INIT segment
//#pragma alloc_text(INIT, DriverEntry )
#endif
#endif

#ifdef WMI_SUPPORT

#define NUM_WMI_SUPPORTED_GUIDS     3

WMIGUIDREGINFO USB_WmiGuidList[NUM_WMI_SUPPORTED_GUIDS];

extern WMIGUIDREGINFO USB_PortWmiGuidList[];

#endif /* WMI_SUPPORT */


PWCHAR GenericUSBDeviceString = NULL;


NTSTATUS
USBH_GetConfigValue(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    )
/*++

Routine Description:

	This routine is a callback routine for RtlQueryRegistryValues
    It is called for each entry in the Parameters
    node to set the config values. The table is set up
    so that this function will be called with correct default
    values for keys that are not present.

Arguments:

    ValueName - The name of the value (ignored).
	ValueType - The type of the value
	ValueData - The data for the value.
	ValueLength - The length of ValueData.
	Context - A pointer to the CONFIG structure.
	EntryContext - The index in Config->Parameters to save the value.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PWCHAR tmpStr;

    USBH_KdPrint((2,"'Type 0x%x, Length 0x%x\n", ValueType, ValueLength));

    switch (ValueType) {
    case REG_DWORD:
  		*(PVOID*)EntryContext = *(PVOID*)ValueData;
  	    break;
    case REG_BINARY:
        RtlCopyMemory(EntryContext, ValueData, ValueLength);
        break;
    case REG_SZ:
        if (ValueLength) {
            tmpStr = UsbhExAllocatePool(PagedPool, ValueLength);
            if (tmpStr) {
                RtlZeroMemory(tmpStr, ValueLength);
                RtlCopyMemory(tmpStr, ValueData, ValueLength);
                *(PWCHAR *)EntryContext = tmpStr;
            } else {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        } else {
            ntStatus = STATUS_INVALID_PARAMETER;
        }
        break;
    default:
        TEST_TRAP();
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    return ntStatus;
}


NTSTATUS
USBH_RegQueryUSBGlobalSelectiveSuspend(
    IN OUT PBOOLEAN DisableSelectiveSuspend
    )
/*++

Routine Description:

    See if selective suspend is glabllay disabled 
    
Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usb  = L"usb";
    ULONG disableSS;
#define G_DISABLE_SS_KEY                L"DisableSelectiveSuspend"


    PAGED_CODE();

    disableSS = 0;
    *DisableSelectiveSuspend = FALSE;      // Default is enabled.

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = G_DISABLE_SS_KEY;
    QueryTable[0].EntryContext = &disableSS;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &disableSS;
    QueryTable[0].DefaultLength = sizeof(disableSS);

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    *DisableSelectiveSuspend = disableSS ? TRUE : FALSE;
    
    USBH_KdPrint((1,"'USB\\DisableSelectiveSuspend = 0x%x\n", 
        *DisableSelectiveSuspend));

    return ntStatus;
}


NTSTATUS
USBH_RegQueryDeviceIgnoreHWSerNumFlag(
    IN USHORT idVendor,
    IN USHORT idProduct,
    IN OUT PBOOLEAN IgnoreHWSerNumFlag
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    WCHAR buffer[sizeof(WCHAR) * 128];
    WCHAR tmplate[] = L"IgnoreHWSerNum%04x%04x";

    PAGED_CODE();

    *IgnoreHWSerNumFlag = FALSE;    // Default is don't ignore.

    swprintf(buffer, tmplate, idVendor, idProduct);

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = buffer;
    QueryTable[0].EntryContext = IgnoreHWSerNumFlag;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    return ntStatus;
}


NTSTATUS
USBH_RegQueryGenericUSBDeviceString(
    IN OUT PWCHAR *GenericUSBDeviceString
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[2];
    PWCHAR usbstr = L"usbflags";
    PWCHAR valuename = L"GenericUSBDeviceString";

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // Upgrade install flag
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
    QueryTable[0].Name = valuename;
    QueryTable[0].EntryContext = GenericUSBDeviceString;
    QueryTable[0].DefaultType = 0;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    //
    // Stop
    //
    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_CONTROL,
                usbstr,
                QueryTable,					// QueryTable
                NULL,						// Context
                NULL);						// Environment

    return ntStatus;
}


//
// Make the DriverEntry discardable
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING UniRegistryPath)
 /* ++ Routine Description:
  *
  * Installable driver initialization entry point. We will remember the pointer
  * to our DeviceObject.
  *
  * Arguments:
  *
  * pDriverObject - pointer to driver object pustRegisterPath - pointer to a
  * unicode string representing the path to driver specific key in the
  * registry.
  *
  * Return Values:
  *
  * STATUS_SUCCESS - if successful
  * STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS status, ntStatus = STATUS_SUCCESS;
    PUNICODE_STRING registryPath = &UsbhRegistryPath;

    USBH_KdPrint((2,"'enter DriverEntry\n"));

    USBH_LogInit();

    UsbhDriverObject = DriverObject;  // remember ourselves
    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE] =
        DriverObject->MajorFunction[IRP_MJ_CLOSE] =
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] =
        DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] =
        DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = USBH_HubDispatch;

    DriverObject->DriverUnload = USBH_DriverUnload;
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE) USBH_AddDevice;

    DriverObject->MajorFunction[IRP_MJ_PNP] = USBH_HubDispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = USBH_HubDispatch;


     //
    // Need to ensure that the registry path is null-terminated.
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length = UniRegistryPath->Length;
    registryPath->Buffer = ExAllocatePoolWithTag(
                              PagedPool,
                              registryPath->MaximumLength,
                              USBHUB_HEAP_TAG);

    if (!registryPath->Buffer) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        USBH_LogFree();
        goto DriverEntry_Exit;
    } else {

        RtlZeroMemory (registryPath->Buffer, registryPath->MaximumLength);

        RtlMoveMemory (registryPath->Buffer,
                       UniRegistryPath->Buffer,
                       UniRegistryPath->Length);

#ifdef WMI_SUPPORT

        // These are the GUIDs that we support for the HUB.

        USB_WmiGuidList[0].Guid = (LPCGUID)&GUID_USB_WMI_STD_DATA;
        USB_WmiGuidList[0].InstanceCount = 1;
        USB_WmiGuidList[0].Flags = 0;

        USB_WmiGuidList[1].Guid = (LPCGUID)&GUID_USB_WMI_STD_NOTIFICATION;
        USB_WmiGuidList[1].InstanceCount = 1;
        USB_WmiGuidList[1].Flags = 0;

        // NB: GUID_POWER_DEVICE_ENABLE MUST be last because we only support
        // it for the Root Hub, and we omit the last one in the list if not
        // the Root Hub.

        USB_WmiGuidList[2].Guid = (LPCGUID)&GUID_POWER_DEVICE_ENABLE;
        USB_WmiGuidList[2].InstanceCount = 1;
        USB_WmiGuidList[2].Flags = 0;

        // These are the GUIDs that we support for the PORT PDOs.

        USB_PortWmiGuidList[0].Guid = (LPCGUID)&MSDeviceUI_FirmwareRevision_GUID;
        USB_PortWmiGuidList[0].InstanceCount = 1;
        USB_PortWmiGuidList[0].Flags = 0;

#endif /* WMI_SUPPORT */
    }

    USBH_RegQueryGenericUSBDeviceString(&GenericUSBDeviceString);

DriverEntry_Exit:

    USBH_KdPrint((2,"' exit DriverEntry %x\n", ntStatus));
    return ntStatus;
}


#if DBG
VOID
USBH_ShowPortState(
    IN USHORT PortNumber,
    IN PPORT_STATE PortState)
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * None
  *
  * -- */
{
    USBH_KdPrint((2,"' Port state for port %x status = %x change = %x\n", PortNumber,
        PortState->PortStatus,  PortState->PortChange));

    if (PortState->PortStatus & PORT_STATUS_CONNECT) {
        USBH_KdPrint((2,"'PORT_STATUS_CONNECT\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_ENABLE) {
        USBH_KdPrint((2,"'PORT_STATUS_ENABLE\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_SUSPEND) {
        USBH_KdPrint((2,"'PORT_STATUS_SUSPEND\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_OVER_CURRENT) {
        USBH_KdPrint((2,"'PORT_STATUS_OVER_CURRENT\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_RESET) {
        USBH_KdPrint((2,"'PORT_STATUS_RESET\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_POWER) {
        USBH_KdPrint((2,"'PORT_STATUS_POWER\n"));
    }

    if (PortState->PortStatus & PORT_STATUS_LOW_SPEED) {
        USBH_KdPrint((2,"'PORT_STATUS_LOW_SPEED\n"));
    }


    if (PortState->PortChange & PORT_STATUS_CONNECT) {
        USBH_KdPrint((2,"'PORT_CHANGE_CONNECT\n"));
    }

    if (PortState->PortChange & PORT_STATUS_ENABLE) {
        USBH_KdPrint((2,"'PORT_CHANGE_ENABLE\n"));
    }

    if (PortState->PortChange & PORT_STATUS_SUSPEND) {
        USBH_KdPrint((2,"'PORT_CHANGE_SUSPEND\n"));
    }

    if (PortState->PortChange & PORT_STATUS_OVER_CURRENT) {
        USBH_KdPrint((2,"'PORT_CHANGE_OVER_CURRENT\n"));
    }

    if (PortState->PortChange & PORT_STATUS_RESET) {
        USBH_KdPrint((2,"'PORT_CHANGE_RESET\n"));
    }

    if (PortState->PortChange & PORT_STATUS_POWER) {
        USBH_KdPrint((2,"'PORT_CHANGE_POWER\n"));
    }

    if (PortState->PortChange & PORT_STATUS_LOW_SPEED) {
        USBH_KdPrint((2,"'PORT_CHANGE_LOW_SPEED\n"));
    }

    return;
}
#endif

VOID
USBH_CompleteIrp(
     IN PIRP Irp,
     IN NTSTATUS NtStatus)
 /* ++
  *
  * Description:
  *
  * This function complete the specified Irp with no priority boost. It also
  * sets up the IoStatusBlock.
  *
  * Arguments:
  *
  * Irp - the Irp to be completed by us NtStatus - the status code we want to
  * return
  *
  * Return:
  *
  * None
  *
  * -- */
{
    Irp->IoStatus.Status = NtStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
USBH_PassIrp(
    IN PIRP Irp,
    IN PDEVICE_OBJECT NextDeviceObject)
 /* ++
  *
  * Description:
  *
  * This function pass the Irp to lower level driver.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;

    USBH_KdPrint((2,"'PassIrp\n"));

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(NextDeviceObject, Irp);

    USBH_KdPrint((2,"'Exit PassIrp\n"));

    return ntStatus;
}


NTSTATUS
USBH_FdoDispatch(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp)
 /* ++
  *
  * Description:
  *
  * All external Irps on FDO come here.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the extension of the Fdo pIrp - the request
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION ioStackLocation;    // our stack location
    PDEVICE_OBJECT deviceObject;
    BOOLEAN bDoCheckHubIdle = FALSE;

    USBH_KdPrint((2,"'FdoDispatch DeviceExtension %x Irp %x\n", DeviceExtensionHub, Irp));
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    //
    // Get a pointer to IoStackLocation so we can retrieve parameters.
    //
    ioStackLocation = IoGetCurrentIrpStackLocation(Irp);

    LOGENTRY(LOG_PNP, "hIRP", DeviceExtensionHub,
        ioStackLocation->MajorFunction, ioStackLocation->MinorFunction);
    //
    // the called functions will complete the irp if necessary
    //

    switch (ioStackLocation->MajorFunction) {
    case IRP_MJ_CREATE:

        USBH_KdPrint((2,"'IRP_MJ_CREATE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_CLOSE:

        USBH_KdPrint((2,"'IRP_MJ_CLOSE\n"));
        USBH_CompleteIrp(Irp, STATUS_SUCCESS);
        break;

    case IRP_MJ_DEVICE_CONTROL:

        {
        ULONG ioControlCode;

        USBH_KdPrint((2,"'Hub FDO IRP_MJ_DEVICE_CONTROL\n"));

        // If this hub is currently Selective Suspended, then we need to
        // power up the hub first before sending any IOCTL requests along to it.
        // Make sure hub has been started, though.

        if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
            (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

            bDoCheckHubIdle = TRUE;
            USBH_HubSetD0(DeviceExtensionHub);
        }

        ioControlCode = ioStackLocation->Parameters.DeviceIoControl.IoControlCode;
        ntStatus = STATUS_DEVICE_BUSY;

        switch (ioControlCode) {
        case IOCTL_USB_GET_NODE_INFORMATION:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeInformation(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_DRIVERKEY_NAME:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionDriverKeyName(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_INFORMATION:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionInformation(DeviceExtensionHub,
                                                                  Irp,
                                                                  FALSE);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;
        // EX api returns speed            
        case IOCTL_USB_GET_NODE_CONNECTION_INFORMATION_EX:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionInformation(DeviceExtensionHub,
                                                                  Irp,
                                                                  TRUE);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;            

        case IOCTL_USB_GET_NODE_CONNECTION_ATTRIBUTES:
            // note, when rev all internal apps we can remove this
            // code
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeConnectionAttributes(DeviceExtensionHub,
                                                                   Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_NODE_CONNECTION_NAME:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetNodeName(DeviceExtensionHub,
                                                 Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetDescriptorForPDO(DeviceExtensionHub,
                                                         Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_USB_GET_HUB_CAPABILITIES:
            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_STOPPED)) {
                ntStatus = USBH_IoctlGetHubCapabilities(DeviceExtensionHub,
                                                        Irp);
            } else {
                USBH_CompleteIrp(Irp, ntStatus);
            }
            break;

        case IOCTL_KS_PROPERTY:
            ntStatus = STATUS_INVALID_DEVICE_REQUEST;
            USBH_CompleteIrp(Irp, ntStatus);
            break;

        case IOCTL_USB_HUB_CYCLE_PORT:
        
            ntStatus = USBH_IoctlCycleHubPort(DeviceExtensionHub,
                                              Irp);
            break;            

        default:

            ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->RootHubPdo);

        }

        if (bDoCheckHubIdle) {
            USBH_CheckHubIdle(DeviceExtensionHub);
        }
        }
        break;

    case IRP_MJ_INTERNAL_DEVICE_CONTROL:

        USBH_KdPrint((2,"'InternlDeviceControl IOCTL unknown pass on\n"));
        ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);

        break;

    case IRP_MJ_PNP:

        USBH_KdPrint((2,"'IRP_MJ_PNP\n"));
        ntStatus = USBH_FdoPnP(DeviceExtensionHub, Irp, ioStackLocation->MinorFunction);
        break;

    case IRP_MJ_POWER:

        USBH_KdPrint((2,"'IRP_MJ_POWER\n"));
        ntStatus = USBH_FdoPower(DeviceExtensionHub, Irp, ioStackLocation->MinorFunction);
        break;

#ifdef WMI_SUPPORT
    case IRP_MJ_SYSTEM_CONTROL:
        USBH_KdPrint((2,"'IRP_MJ_SYSTEM_CONTROL\n"));
        ntStatus =
            USBH_SystemControl ((PDEVICE_EXTENSION_FDO) DeviceExtensionHub, Irp);
        break;
#endif

    default:
        //
        // Unknown Irp -- pass on
        //
        USBH_KdBreak(("Unknown Irp for fdo %x Irp_Mj %x\n",
                  deviceObject, ioStackLocation->MajorFunction));
        ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);
        break;
    }

//USBH_FdoDispatch_Done:

    USBH_KdPrint((2,"' exit USBH_FdoDispatch Object %x Status %x\n",
                  deviceObject, ntStatus));

    //
    // always return a status code
    //

    return ntStatus;
}


NTSTATUS
USBH_HubDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
 /* ++
  *
  * Routine Description:
  *
  *     This is the dispatch routine for all Irps passed to the hub driver.
  *     It is here that we determine if the call was passed throug the FDO
  *     for the hub itself or a PDO owned by the hub.
  *
  * Arguments:
  *
  * Return Value:
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    //
    // Get the pointer to the device extension.
    //

    //
    // examine the extension
    //

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    switch(deviceExtensionHeader->ExtensionType) {
    case EXTENSION_TYPE_HUB:
        ntStatus = USBH_FdoDispatch((PDEVICE_EXTENSION_HUB) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_PORT:
        ntStatus = USBH_PdoDispatch((PDEVICE_EXTENSION_PORT) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_PARENT:
        ntStatus = USBH_ParentDispatch((PDEVICE_EXTENSION_PARENT) deviceExtensionHeader, Irp);
        break;

    case EXTENSION_TYPE_FUNCTION:
        ntStatus = USBH_FunctionPdoDispatch((PDEVICE_EXTENSION_FUNCTION) deviceExtensionHeader, Irp);
        break;

    default:
        USBH_KdBreak(("bad extension type\n"));
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    return ntStatus;
}


VOID
USBH_DriverUnload(
    IN PDRIVER_OBJECT DriverObject)
 /* ++
  *
  * Description:
  *
  * This function will clean up all resources we allocated.
  *
  * Arguments:
  *
  * pDriverObject - Ourselves
  *
  * Return:
  *
  * None
  *
  * -- */
{
    PUNICODE_STRING registryPath = &UsbhRegistryPath;

    USBH_KdPrint((1, "'USBHUB.SYS unload\n"));

    USBH_LogFree();

    if (registryPath->Buffer) {
        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    if (GenericUSBDeviceString) {
        UsbhExFreePool(GenericUSBDeviceString);
        GenericUSBDeviceString = NULL;
    }

    // assert here that all PDOs for this hub have been removed

    return;
}


NTSTATUS
USBH_AbortInterruptPipe(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *     Abort our pending transfer on the interrupt
  *     pipe.
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PURB urb;

    USBH_KdPrint((2,"'Enter AbortInterruptPipe pExt=%x\n", DeviceExtensionHub));
    LOGENTRY(LOG_PNP, "ABRT", DeviceExtensionHub, 0,  0);

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {
        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = DeviceExtensionHub->PipeInformation.PipeHandle;

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject, urb);

        //
        // wait on the abort event
        //

        //
        // timeout here?
        LOGENTRY(LOG_PNP, "hWAT", DeviceExtensionHub,
                        &DeviceExtensionHub->AbortEvent, ntStatus);

        if (NT_SUCCESS(ntStatus)) {
            status = KeWaitForSingleObject(
                           &DeviceExtensionHub->AbortEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           NULL);
        }

        UsbhExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    USBH_KdPrint((2,"'Exit AbortInterruptPipe %x\n", ntStatus));

    return ntStatus;
}


#if 0
NTSTATUS
USBH_GetHubConfigurationDescriptor(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  * Get our configuration info.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG numBytes;              // transfer length
    PUCHAR buffer;                // a pointer to the transfer buffer
    PDEVICE_OBJECT deviceObject;

    USBH_KdPrint((2,"'enter GetConfigurationDescriptor\n"));

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    USBH_ASSERT(DeviceExtensionHub->ConfigurationDescriptor == NULL);

    //
    // Most likely a Hub has 1 configuration, 1 interface and 1 endpoint
    // possibly follwed by the hub descriptor, try to get it on the first
    // pass
    //
    numBytes = sizeof(USB_CONFIGURATION_DESCRIPTOR) +
        sizeof(USB_INTERFACE_DESCRIPTOR) +
        sizeof(USB_ENDPOINT_DESCRIPTOR) +
        sizeof(USB_HUB_DESCRIPTOR);

    //
    // Allocate an Urb and descriptor buffer.
    //

    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (NULL == urb) {
        USBH_KdBreak(("GetConfigurationDescriptor fail alloc Urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    if (NT_SUCCESS(ntStatus)) {

        //
        // got the urb no try to get descriptor data
        //

USBH_GetHubConfigurationDescriptor_Retry:

        buffer = (PUCHAR) UsbhExAllocatePool(NonPagedPool, numBytes);

        if (buffer != NULL) {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         buffer,
                                         NULL,
                                         numBytes,
                                         NULL);

            ntStatus = USBH_FdoSyncSubmitUrb(deviceObject, urb);
        } else {
            USBH_KdBreak(("GetConfigurationDescriptor fail alloc memory\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if (!NT_SUCCESS(ntStatus)) {

            UsbhExFreePool(buffer);
            USBH_KdPrint((2,"'GetConfigurationDescriptor fail calling Usbd code %x\n",
                ntStatus));

        } else {

            if (((PUSB_CONFIGURATION_DESCRIPTOR) buffer)->wTotalLength > numBytes) {
                //
                // should only hit this if the hub has > 7 ports
                //
                UsbhExFreePool(buffer);
                USBH_KdBreak(("GetConfigurationDescriptor 2nd try\n"));
                goto USBH_GetHubConfigurationDescriptor_Retry;

            } else {
                //
                // success
                //
                DeviceExtensionHub->ConfigurationDescriptor =
                    (PUSB_CONFIGURATION_DESCRIPTOR) buffer;

            }

        }
    }
    //
    // Free the Urb and first buffer for descriptors
    //
    if (urb != NULL) {
        UsbhExFreePool(urb);
    }
    return ntStatus;
}
#endif


BOOLEAN
IsBitSet(
    PVOID Bitmap,
    ULONG PortNumber)
 /* ++
  *
  * Description:
  *
  * Check if a bit is set given a string of bytes.
  *
  * Arguments:
  *
  * pul - the string of bitmap ulPortNumber - the bit location to check for the
  * port
  *
  * Return:
  *
  * TRUE - if the corresponding bit is set. FALSE - otherwise
  *
  * -- */
{
    ULONG dwordOffset;
    ULONG bitOffset;
    PUCHAR l = (PUCHAR) Bitmap;

    dwordOffset = PortNumber / 8;
    bitOffset = PortNumber % 8;

    return ((l[dwordOffset] & (1 << bitOffset)) ? TRUE : FALSE);
}


NTSTATUS
USBH_OpenConfiguration(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *     Configure the USB hub device.
  *
  * Argument:
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    USBD_INTERFACE_LIST_ENTRY interfaceList[2];

    USBH_KdPrint((2,"'Enter OpenConfiguration\n"));

    //
    // I do not believe it is legal to have a hub with any other
    // interfaces.
    //
    // This code will locate the 'HUB' interface and configure
    // the device as if this were the only interface.
    //

    //
    // find the hub interface
    //

    if ((DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) &&
        !IS_ROOT_HUB(DeviceExtensionHub)) {
        // 2.0 hubs may have multiple interfaces
        // one for per port TTs
        // one for a global TT
        // these are diferentiated by the bportocol field we attempt
        // to select the multi-TT version by default
        //

        USBH_KdPrint((1,"'Configure 2.0 hub %x\n",
            DeviceExtensionHub->ConfigurationDescriptor));

        // find a Multi TT interface
        interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    2); // multi TT protocol

        if (interfaceDescriptor != NULL) {
            USBH_KdPrint((1,"'USB 2.0 hub - Multi TT\n"));

            DeviceExtensionHub->HubFlags |= HUBFLAG_USB20_MULTI_TT;
            
        } else {
            // locate the single TT protocol, may be zero or 1
            interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    1); // single TT protocol

            if (interfaceDescriptor == NULL) {
                // locate the single TT protocol
                interfaceDescriptor =
                    USBD_ParseConfigurationDescriptorEx(
                        (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                        (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                        -1, //interface, don't care
                        -1, //alt setting, don't care
                        USB_DEVICE_CLASS_HUB, // hub class
                        -1, // subclass, don't care
                        0); // single TT protocol
            }

            if (interfaceDescriptor != NULL) {
                USBH_KdPrint((1,"'USB 2.0 hub - Single TT\n"));
            }
        }
    } else {
        // just do what we always did to be safe
        interfaceDescriptor =
                USBD_ParseConfigurationDescriptorEx(
                    (PUSB_CONFIGURATION_DESCRIPTOR) DeviceExtensionHub->ConfigurationDescriptor,
                    (PVOID) DeviceExtensionHub->ConfigurationDescriptor,
                    -1, //interface, don't care
                    -1, //alt setting, don't care
                    USB_DEVICE_CLASS_HUB, // hub class
                    -1, // subclass, don't care
                    -1); // protocol, don't care
    }

    if (interfaceDescriptor == NULL ||
        interfaceDescriptor->bInterfaceClass != USB_DEVICE_CLASS_HUB) {
        USBH_KdBreak(("OpenConfiguration interface not found\n"));
        return STATUS_UNSUCCESSFUL;
    }

    interfaceList[0].InterfaceDescriptor =
        interfaceDescriptor;

    // terminate the list
    interfaceList[1].InterfaceDescriptor =
        NULL;

    urb = USBD_CreateConfigurationRequestEx(DeviceExtensionHub->ConfigurationDescriptor,
                                            &interfaceList[0]);

    if (NULL == urb) {
        USBH_KdBreak(("OpenConfiguration aloc Urb failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject, urb);

    if (NT_SUCCESS(ntStatus)) {
        PUSBD_INTERFACE_INFORMATION interface;

        //
        // interface we selected
        //

        interface =  interfaceList[0].Interface;

        //
        // Save the pipe handle for the Interrupt pipe
        //
        DeviceExtensionHub->PipeInformation =
            interface->Pipes[0];
        DeviceExtensionHub->Configuration =
            urb->UrbSelectConfiguration.ConfigurationHandle;
    }

    ExFreePool(urb);

    USBH_KdPrint((2,"'Exit OpenConfiguration PipeInfo %x\n", DeviceExtensionHub->PipeInformation));

    return ntStatus;
}


NTSTATUS
USBH_CloseConfiguration(
    IN PDEVICE_EXTENSION_FDO DeviceExtensionFdo
    )
 /* ++
  *
  * Description:
  *
  * Close our confiuration on USB to prepare for removal of ourselves. Before
  * this is called, the InterruptTransfer should have been removed by
  * USBH_AbortInterruptPipe.
  *
  * Argument:
  *
  * DeviceExtensionHub - pointer to the FDO extension
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    NTSTATUS ntStatus;
    PURB urb;

    USBH_KdPrint((2,"'Enter CloseConfiguration\n"));
    urb = UsbhExAllocatePool(NonPagedPool, sizeof(struct _URB_SELECT_CONFIGURATION));
    if (NULL == urb) {
        USBH_KdBreak(("OpenConfiguration aloc Urb failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    urb->UrbHeader.Length = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb->UrbHeader.Function = URB_FUNCTION_SELECT_CONFIGURATION;

    urb->UrbSelectConfiguration.ConfigurationDescriptor = NULL;

    ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionFdo->FunctionalDeviceObject, urb);

    UsbhExFreePool(urb);

    USBH_KdPrint((2,"'Exit CloseConfiguration %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_SubmitInterruptTransfer(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * To submit a listen down for Status Change interrupt transfer. When the
  * transfer is completed, the USBH_ChangeIndication will be called.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the hub we are listening
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    PIRP irp;
    PURB urb;
    CHAR stackSize;

    USBH_KdPrint((2,"'Enter Submit IntTrans\n"));

    irp = DeviceExtensionHub->Irp;

    USBH_ASSERT(NULL != irp);

    // Synchronize with FdoPower.  Don't let the IRP slip through if FdoPower
    // has already set the HUBFLAG_DEVICE_LOW_POWER flag.
    //
    // It is ok to allow this through in the REMOVE case
    // (i.e. HUBFLAG_DEVICE_STOPPING is set) because the IRP will need to
    // be submitted so that it can be aborted by USBH_FdoCleanup.

    if (DeviceExtensionHub->HubFlags & HUBFLAG_DEVICE_LOW_POWER) {

        irp = NULL;
    }

    if (!irp) {
        ntStatus = STATUS_INVALID_DEVICE_STATE;
        LOGENTRY(LOG_PNP, "Int!", DeviceExtensionHub,
            DeviceExtensionHub->HubFlags, 0);
        goto SubmitIntTrans_Exit;
    }

    urb = &DeviceExtensionHub->Urb;

    USBH_ASSERT(NULL != urb);
    USBH_ASSERT(sizeof(*urb) >= sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER));
    //
    // Fill in Urb header
    //

    LOGENTRY(LOG_PNP, "Int>", DeviceExtensionHub, urb, irp);

    urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    urb->UrbHeader.Function =
        URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;
    urb->UrbHeader.UsbdDeviceHandle = NULL;

    //
    // Fill in Urb body
    //
    urb->UrbBulkOrInterruptTransfer.PipeHandle = DeviceExtensionHub->PipeInformation.PipeHandle;
    urb->UrbBulkOrInterruptTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK;
    urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
        DeviceExtensionHub->TransferBufferLength;
    urb->UrbBulkOrInterruptTransfer.TransferBuffer = DeviceExtensionHub->TransferBuffer;
    urb->UrbBulkOrInterruptTransfer.TransferBufferMDL = NULL;
    urb->UrbBulkOrInterruptTransfer.UrbLink = NULL;

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(irp);
    nextStack->Parameters.Others.Argument1 = urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(irp,    // Irp
                           USBH_ChangeIndication,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    //
    // Call the USB stack
    //

    //
    // reset the abort event to not-signaled
    //

    KeResetEvent(&DeviceExtensionHub->AbortEvent);

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, irp);

    //
    // completion routine will handle errors.
    //

SubmitIntTrans_Exit:

    USBH_KdPrint((2,"'Exit SubmitIntTrans %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_QueryCapsComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * This is a call back when the listen of Interrupt control completes.
  *
  * Arguments:
  *
  * pDeviceObject - should be NULL in our case pIrp - the Irp that is completed
  * for the interrupt transfer. pContext - context value for this Irp.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    NTSTATUS ntStatus;
    PDEVICE_CAPABILITIES deviceCapabilities;
    PIO_STACK_LOCATION ioStack;

    deviceExtensionHub = Context;
    ntStatus = Irp->IoStatus.Status;

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    //cause we said 'invoke on success'
    USBH_ASSERT(NT_SUCCESS(ntStatus));

    ioStack = IoGetCurrentIrpStackLocation(Irp);
    deviceCapabilities = ioStack->Parameters.DeviceCapabilities.Capabilities;
    USBH_ASSERT(ioStack != NULL);
    USBH_ASSERT(ioStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(ioStack->MinorFunction == IRP_MN_QUERY_CAPABILITIES);
    deviceCapabilities->SurpriseRemovalOK = TRUE;

    USBH_KdPrint((1,"'Setting SurpriseRemovalOK to TRUE\n"));

    return ntStatus;
}


NTSTATUS
USBH_HRPPCancelComplete(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PLONG  lock = (PLONG) Context;

    if (InterlockedExchange(lock, 3) == 1) {

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
USBH_HubResetParentPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Resets the hub parent port.

Arguments:

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    LARGE_INTEGER dueTime;
    LONG lock;

    USBH_KdPrint((1,"'Reset Hub Parent Port, Hub DevExt: %x, PDO: %x\n",
        DeviceExtensionHub, DeviceExtensionHub->PhysicalDeviceObject));

    LOGENTRY(LOG_PNP, "HRPP", DeviceExtensionHub,
        DeviceExtensionHub->TopOfStackDeviceObject,
        DeviceExtensionHub->RootHubPdo);

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    lock = 0;

    IoSetCompletionRoutine(
        irp,
        USBH_HRPPCancelComplete,
        &lock,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    if (ntStatus == STATUS_PENDING) {

        dueTime.QuadPart = -10000 * ESD_RESET_TIMEOUT;

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       &dueTime);

        if (status == STATUS_TIMEOUT) {

            LOGENTRY(LOG_PNP, "HRPX", DeviceExtensionHub,
                DeviceExtensionHub->TopOfStackDeviceObject,
                DeviceExtensionHub->RootHubPdo);

            USBH_KdPrint((1,"'Reset Hub Parent Port timed out!\n"));

            if (InterlockedExchange(&lock, 1) == 0) {

                //
                // We got it to the IRP before it was completed. We can cancel
                // the IRP without fear of losing it, as the completion routine
                // won't let go of the IRP until we say so.
                //
                IoCancelIrp(irp);

                //
                // Release the completion routine. If it already got there,
                // then we need to complete it ourselves. Otherwise we got
                // through IoCancelIrp before the IRP completed entirely.
                //
                if (InterlockedExchange(&lock, 2) == 3) {

                    //
                    // Mark it pending because we switched threads.
                    //
                    IoMarkIrpPending(irp);
                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                }
            }

            KeWaitForSingleObject(&event, Suspended, KernelMode, FALSE, NULL);

            // Return STATUS_TIMEOUT
            ioStatus.Status = status;
        }

    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    return ntStatus;
}


VOID
USBH_HubESDRecoveryDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL.



Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext -

    SystemArgument1 - not used.

    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PHUB_ESD_RECOVERY_CONTEXT hubESDRecoveryContext = DeferredContext;
    PDEVICE_EXTENSION_HUB deviceExtensionHub =
                            hubESDRecoveryContext->DeviceExtensionHub;
    PUSBH_HUB_ESD_RECOVERY_WORK_ITEM workItemHubESDRecovery;

    USBH_KdPrint((1,"'Hub ESD Recovery DPC\n"));

    UsbhExFreePool(hubESDRecoveryContext);

    InterlockedExchange(&deviceExtensionHub->InESDRecovery, 0);

    if (!(deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING)) {
        //
        // Schedule a work item to process this.
        //
        workItemHubESDRecovery = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(USBH_HUB_ESD_RECOVERY_WORK_ITEM));

        if (workItemHubESDRecovery) {

            workItemHubESDRecovery->DeviceExtensionHub = deviceExtensionHub;

            ExInitializeWorkItem(&workItemHubESDRecovery->WorkQueueItem,
                                 USBH_HubESDRecoveryWorker,
                                 workItemHubESDRecovery);

            LOGENTRY(LOG_PNP, "hESD", deviceExtensionHub,
                &workItemHubESDRecovery->WorkQueueItem, 0);

            ExQueueWorkItem(&workItemHubESDRecovery->WorkQueueItem,
                            DelayedWorkQueue);

            // The WorkItem is freed by USBH_HubESDRecoveryWorker()
            // Don't try to access the WorkItem after it is queued.

        } else {
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }

    } else {
        USBH_KdPrint((1,"'Hub stopping, nothing to do\n"));

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
    }
}


NTSTATUS
USBH_ScheduleESDRecovery(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * Schedules the timer event to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PHUB_ESD_RECOVERY_CONTEXT hubESDRecoveryContext = NULL;
    LARGE_INTEGER dueTime;
    NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;

    // Only do this for external hubs.

    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        USBH_KdPrint((1,"'RootHub failed\n"));
        return STATUS_UNSUCCESSFUL;
    }

    if (InterlockedExchange(&DeviceExtensionHub->InESDRecovery, 1) == 1) {

        // We already have a timer event scheduled for this.  Don't reschedule.

    } else {

        USBH_KdPrint((1,"'Schedule ESD Recovery\n"));

        LOGENTRY(LOG_PNP, "ESDs", DeviceExtensionHub,
            DeviceExtensionHub->HubFlags, 0);

        hubESDRecoveryContext = UsbhExAllocatePool(NonPagedPool,
                                    sizeof(*hubESDRecoveryContext));

        if (hubESDRecoveryContext) {

            hubESDRecoveryContext->DeviceExtensionHub = DeviceExtensionHub;

            KeInitializeTimer(&hubESDRecoveryContext->TimeoutTimer);
            KeInitializeDpc(&hubESDRecoveryContext->TimeoutDpc,
                            USBH_HubESDRecoveryDPC,
                            hubESDRecoveryContext);

            dueTime.QuadPart = -10000 * ESD_RECOVERY_TIMEOUT;

            KeSetTimer(&hubESDRecoveryContext->TimeoutTimer,
                       dueTime,
                       &hubESDRecoveryContext->TimeoutDpc);

            USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);

            ntStatus = STATUS_SUCCESS;
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_HubESDRecoverySetD0Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus, status;
    PDEVICE_EXTENSION_HUB deviceExtensionHub = Context;

    ntStatus = IoStatus->Status;

    if (NT_SUCCESS(ntStatus)) {

        // Hub is now powered back on and fully recovered.  Now find the
        // devices attached to the hub.

        deviceExtensionHub->HubFlags &=
            ~(HUBFLAG_HUB_HAS_LOST_BRAINS | HUBFLAG_HUB_FAILURE);

        // Don't allow selective suspend while post-ESD enumeration is
        // pending.

        deviceExtensionHub->HubFlags |= HUBFLAG_POST_ESD_ENUM_PENDING;

        USBH_IoInvalidateDeviceRelations(deviceExtensionHub->PhysicalDeviceObject,
                                         BusRelations);

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

    } else {

        // Setting hub parent port to D0 failed, we are likely still
        // experiencing ESD.  Reschedule the ESD recovery.

        status = USBH_ScheduleESDRecovery(deviceExtensionHub);

        if (status == STATUS_SUCCESS) {
            // Remove extra pending count bump
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }
    }

    return ntStatus;
}


NTSTATUS
USBH_HubESDRecoverySetD3Completion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus;
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent, 1, FALSE);

    ntStatus = IoStatus->Status;

    return ntStatus;
}


VOID
USBH_HubESDRecoveryWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to handle a hub ESD failure.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    PUSBH_HUB_ESD_RECOVERY_WORK_ITEM workItemHubESDRecovery;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    POWER_STATE powerState;
    PORT_STATE portState;
    NTSTATUS ntStatus, status;

    PAGED_CODE();

    workItemHubESDRecovery = Context;
    deviceExtensionHub = workItemHubESDRecovery->DeviceExtensionHub;

    UsbhExFreePool(workItemHubESDRecovery);

    USBH_KdPrint((1,"'Hub ESD Recovery Worker\n"));

    // NB: Because I now check for HUBFLAG_DEVICE_STOPPING in
    // USBH_HubESDRecoveryDPC, some of the following sanity checking might
    // not be necessary, but I'll leave it in anyway to be safe.

    // In the case where there are nested hubs, the hub device extension
    // for one of the downstream hubs might be invalid by the time this
    // workitem is called.  Check for that here.

    if (deviceExtensionHub->ExtensionType != EXTENSION_TYPE_HUB) {
        USBH_KdPrint((1,"'Downstream hub already removed, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // If the hub has been physically removed from the bus, then we have
    // nothing to do here.

    if (!deviceExtensionHub->PhysicalDeviceObject) {
        USBH_KdPrint((1,"'Hub has been removed (no PDO), nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    hubParentDeviceExtensionPort = deviceExtensionHub->PhysicalDeviceObject->DeviceExtension;

    LOGENTRY(LOG_PNP, "ESDw", deviceExtensionHub,
        hubParentDeviceExtensionPort->PortPdoFlags, deviceExtensionHub->HubFlags);

//    USBH_KdPrint((1,"'Hub parent port PortPdoFlags: %x\n",
//        hubParentDeviceExtensionPort->PortPdoFlags));

    // We definitely need the following check, so don't remove this.

    if (hubParentDeviceExtensionPort->PortPdoFlags &
        (PORTPDO_DELETED_PDO | PORTPDO_DELETE_PENDING) ||
        !(hubParentDeviceExtensionPort->PortPdoFlags & PORTPDO_DEVICE_IS_HUB)) {

        USBH_KdPrint((1,"'Hub has been removed, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // Be sure that the hub hasn't stopped or set to a low power state before
    // this workitem had a chance to run.

    if (deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {

        USBH_KdPrint((1,"'Hub has is stopping or in low power, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // One last sanity check.  Check the port status for the parent port
    // of this hub and be sure that a device is still connected.

    ntStatus = USBH_SyncGetPortStatus(
                hubParentDeviceExtensionPort->DeviceExtensionHub,
                hubParentDeviceExtensionPort->PortNumber,
                (PUCHAR) &portState,
                sizeof(portState));

    if (!NT_SUCCESS(ntStatus) ||
        !(portState.PortStatus & PORT_STATUS_CONNECT)) {

        USBH_KdPrint((1,"'Hub device has been physically disconnected, nothing to do\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    // Reset the parent port for this hub.

    ntStatus = USBH_HubResetParentPort(deviceExtensionHub);

    USBH_KdPrint((1,"'USBH_HubResetParentPort returned %x\n", ntStatus));

    if (ntStatus == STATUS_INVALID_PARAMETER) {

        // Looks like we lost the port PDO somewhere along the way.
        // (Call to USBH_ResetDevice from USBH_RestoreDevice failed.)
        // Bail out of this ESD recovery, and the user will have to
        // unplug/replug the hub to get it back.  Maybe we can revisit
        // this later.

        USBH_KdPrint((1,"'Lost hub PDO during reset, bail\n"));
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    if (ntStatus == STATUS_TIMEOUT) {

        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        return;
    }

    if (NT_SUCCESS(ntStatus)) {

        KEVENT event;

        // On Memphis we must tell power management that the hub is in D3.
        // (It thinks that the hub is in D0 because it does not know that
        // resetting the hub's parent port causes the hub to lose power.
        //
        // We need to do this on Memphis because power management appears to
        // track the power state of devices and will suppress sending a power
        // request to a device if it thinks that the device is already in that
        // power state.  Under NT they don't seem to care and will send the
        // request along anyway.

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        powerState.DeviceState = PowerDeviceD3;

        // "Power down" the hub.
        ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     USBH_HubESDRecoverySetD3Completion,
                                     &event,
                                     NULL);

        USBH_ASSERT(ntStatus == STATUS_PENDING);
        if (ntStatus == STATUS_PENDING) {

            USBH_KdPrint((2,"'Wait for single object\n"));

            status = KeWaitForSingleObject(&event,
                                           Suspended,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));
        }

        deviceExtensionHub->CurrentPowerState = PowerDeviceD3;

        powerState.DeviceState = PowerDeviceD0;

        // Power up the hub.
        ntStatus = PoRequestPowerIrp(deviceExtensionHub->PhysicalDeviceObject,
                                     IRP_MN_SET_POWER,
                                     powerState,
                                     USBH_HubESDRecoverySetD0Completion,
                                     deviceExtensionHub,
                                     NULL);

        if (ntStatus != STATUS_PENDING) {
            // Power IRP request was not successful.  Reschedule the recovery
            // so that we can try again later.

            status = USBH_ScheduleESDRecovery(deviceExtensionHub);

            if (status == STATUS_SUCCESS) {
                // Remove extra pending count bump
                USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
            }
        }

    } else {
        // Reset hub parent port failed, we are likely still experiencing ESD.
        // Reschedule the ESD recovery.

        status = USBH_ScheduleESDRecovery(deviceExtensionHub);

        if (status == STATUS_SUCCESS) {
            // Remove extra pending count bump
            USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);
        }
    }
}


NTSTATUS
USBH_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * This is a call back when the listen of Interrupt control completes.
  *
  * Arguments:
  *
  * pDeviceObject - should be NULL in our case pIrp - the Irp that is completed
  * for the interrupt transfer. pContext - context value for this Irp.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    PURB urb;                  // the Urb assocaited with this Irp
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PUSBH_WORK_ITEM workItem;
    BOOLEAN requestReset = FALSE;
    USHORT portNumber, numberOfPorts;

    deviceExtensionHub = (PDEVICE_EXTENSION_HUB) Context; // the context is
                                                          // DeviceExtensionHub
    urb = &deviceExtensionHub->Urb;

    USBH_KdPrint((2,"'ChangeIndication Irp status %x  URB status = %x\n",
        Irp->IoStatus.Status, urb->UrbHeader.Status));

    LOGENTRY(LOG_PNP, "chID", deviceExtensionHub, urb, Irp);

    if (NT_ERROR(Irp->IoStatus.Status) ||
        USBD_ERROR(urb->UrbHeader.Status) ||
        (deviceExtensionHub->HubFlags & (HUBFLAG_HUB_FAILURE |
                                         HUBFLAG_DEVICE_STOPPING)) ||
        urb->UrbHeader.Status == USBD_STATUS_CANCELED) {
        requestReset = TRUE;
        deviceExtensionHub->ErrorCount++;

        //
        // An error has occurred submitting the interrupt
        // transfer, possible causes:

        //
        // 1. the interrupt pipe is stalled
        // 2. the hub is experiencing a temporary problem
        // 3. the hub is messed up and we need to reset it
        // 4. we are stopping the device
        // 5. the hub has been removed from the bus
        //
        // In any case we will need to take some action.

        //
        // if an abort event is waiting signal it
        //
        LOGENTRY(LOG_PNP, "cERR", deviceExtensionHub,
            &deviceExtensionHub->AbortEvent, deviceExtensionHub->ErrorCount);

        if ((deviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) ||
            deviceExtensionHub->ErrorCount > USBH_MAX_ERRORS ||
            (deviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) ||
            Irp->IoStatus.Status == STATUS_DELETE_PENDING) {
            //
            // shutting down the hub, do not schedule any more
            // work items while in this state.
            //
            USBH_KdPrint((2,"'ChangeIndication, device stopping or hub failure\n"));

#if DBG
            if (deviceExtensionHub->ErrorCount > USBH_MAX_ERRORS) {

                // we may ideed have a hub failure, more liekly
                // the device was just unplugged, if the hub has
                // failed we should pick this up when we try to
                // do control tranfers to it.

                LOGENTRY(LOG_PNP, "xERR", deviceExtensionHub,
                    0, deviceExtensionHub->ErrorCount);
            }
#endif

            // Set the AbortEvent after checking the HubFlags, not before.
            // As soon as the AbortEvent is set the thread waiting on it may
            // run and cause the HubFlags to change.
            //
            KeSetEvent(&deviceExtensionHub->AbortEvent,
                       1,
                       FALSE);

            goto USBH_ChangeIndication_Done;
        }

        // Set the AbortEvent after checking the HubFlags, not before.
        //
        KeSetEvent(&deviceExtensionHub->AbortEvent,
                   1,
                   FALSE);

    } else {
        // reset error count on successful
        // transfer
         LOGENTRY(LOG_PNP, "zERR", deviceExtensionHub,
            0, deviceExtensionHub->ErrorCount);

        deviceExtensionHub->ErrorCount = 0;
    }


    USBH_KdPrint((2,"'Enter ChangeIndication Transfer %x \n",
                  deviceExtensionHub->TransferBuffer));
#if DBG
    {
    ULONG i;
    for (i=0; i< deviceExtensionHub->TransferBufferLength; i++) {
        USBH_KdPrint((2,"'TransferBuffer[%d] = %x\n", i,
                       deviceExtensionHub->TransferBuffer[i]));
    }
    }
#endif

    //
    // Schedule a work item to process this change
    //
    workItem = UsbhExAllocatePool(NonPagedPool, sizeof(USBH_WORK_ITEM)+
                    deviceExtensionHub->TransferBufferLength);

    if (workItem) {
        NTSTATUS status;

        workItem->Flags = 0;
        if (requestReset) {
            workItem->Flags = USBH_WKFLAG_REQUEST_RESET;
        }

         // i-friend, indicate we have a workitem pendingf=
        {
        LONG cWKPendingCount;

        cWKPendingCount = InterlockedIncrement(
                &deviceExtensionHub->ChangeIndicationWorkitemPending);

        // Prevent hub from powering down or being removed if there is a
        // ChangeIndicationAckChange pending.

        if (cWKPendingCount == 1) {
            KeResetEvent(&deviceExtensionHub->CWKEvent);
        }
        }

        workItem->DeviceExtensionHub = deviceExtensionHub;

        USBH_ASSERT(deviceExtensionHub->WorkItemToQueue == NULL);
        deviceExtensionHub->WorkItemToQueue = workItem;

        RtlCopyMemory(&workItem->Data[0], deviceExtensionHub->TransferBuffer,
            deviceExtensionHub->TransferBufferLength);

        ExInitializeWorkItem(&workItem->WorkQueueItem,
                             USBH_ChangeIndicationWorker,
                             workItem);

        // now process the change, this will signal any waiting
        // reset or resume withoutr reqireing a work item

        LOGENTRY(LOG_PNP, "cITM", deviceExtensionHub,
            &workItem->WorkQueueItem, 0);

        numberOfPorts = deviceExtensionHub->HubDescriptor->bNumberOfPorts;
        for (portNumber = 0; portNumber <= numberOfPorts; portNumber++) {
            if (IsBitSet(&workItem->Data[0],
                         portNumber)) {
                break;
            }
        }

        // If none of the bits for the ports were set in the loop above
        // (i.e. we can't find a change on any of the ports), then just
        // assume port zero and USBH_ChangeIndicationQueryChange will
        // handle accordingly.

        if (portNumber > numberOfPorts) {
            portNumber = 0;
        }

        status = USBH_ChangeIndicationQueryChange(
            deviceExtensionHub,
            Irp,
            urb,
            portNumber);

        if (NT_ERROR(status)) {
            HUB_FAILURE(deviceExtensionHub);
        }

    }

#if DBG
      else {
        LOGENTRY(LOG_PNP, "XMEM", deviceExtensionHub, 0, 0);
        UsbhWarning(NULL,
                    "Memory allocation error in USBH_ChangeIndication, cannot process hub changes.\n",
                    FALSE);
    }
#endif

USBH_ChangeIndication_Done:

    //
    // keep the irp
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
USBH_ChangeIndicationQueryChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port
    )
 /* ++
  *
  * Description:
  *
  *     Queries what changed, ie checks the port to see what changed
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    CHAR stackSize;
    PUSBH_WORK_ITEM workItem;
    LONG cWKPendingCount;

    LOGENTRY(LOG_PNP, "QCH>", DeviceExtensionHub, Urb, Port);

    // bump the io count now this represents pending workitem
    // we will queue on completion of this irp
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);

    if (Port == 0) {

        //
        // if we have a hub status change just queue our
        // workitem and get out
        //
        USBH_ASSERT(DeviceExtensionHub->WorkItemToQueue != NULL);
        workItem = DeviceExtensionHub->WorkItemToQueue;
        DeviceExtensionHub->WorkItemToQueue = NULL;

        LOGENTRY(LOG_PNP, "qIT2", DeviceExtensionHub,
                &workItem->WorkQueueItem, 0);

        ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);


        return ntStatus;
    }

    Urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    Urb->UrbHeader.Function = URB_FUNCTION_CLASS_OTHER;

    //
    // Fill in Urb body
    //

    UsbhBuildVendorClassUrb(Urb,
                            NULL,
                            URB_FUNCTION_CLASS_OTHER,
                            USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK,
                            REQUEST_TYPE_GET_PORT_STATUS,
                            REQUEST_GET_STATUS,
                            0,
                            Port,
                            sizeof(DeviceExtensionHub->PortStateBuffer),
                            &DeviceExtensionHub->PortStateBuffer);

    DeviceExtensionHub->ResetPortNumber = Port;

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(Irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp,    // Irp
                           USBH_ChangeIndicationProcessChange,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
USBH_ChangeIndicationProcessChange(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     Take some action based on change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PPORT_STATE currentPortState;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PUSBH_WORK_ITEM workItem;
    PURB urb;
    NTSTATUS status;
    USHORT wFeatureSelector;
    LONG cWKPendingCount;

    deviceExtensionHub = Context;
    currentPortState = &(deviceExtensionHub->PortStateBuffer);
    urb = &deviceExtensionHub->Urb;

    LOGENTRY(LOG_PNP, "PCHc", deviceExtensionHub,
            *((PULONG)currentPortState), Irp);

    if ((NT_SUCCESS(Irp->IoStatus.Status) ||
         USBD_SUCCESS(urb->UrbHeader.Status)) &&
         (currentPortState->PortChange & PORT_STATUS_RESET ||
          currentPortState->PortChange & PORT_STATUS_ENABLE)) {

        //
        // bit 4 RESET completed
        //

        // no workitem
        LOGENTRY(LOG_PNP, "nITM", deviceExtensionHub,
            0, 0);
        USBH_DEC_PENDING_IO_COUNT(deviceExtensionHub);

        UsbhExFreePool(deviceExtensionHub->WorkItemToQueue);
        deviceExtensionHub->WorkItemToQueue = NULL;

        //
        // Signal the PNP thread that a the reset has completed
        //
        // once we do this we can get antother change indication
        // so we free the workitem first.
        //

        LOGENTRY(LOG_PNP, "RESc", deviceExtensionHub,
            deviceExtensionHub->ResetPortNumber, 0);

        if (currentPortState->PortChange & PORT_STATUS_RESET) {
            wFeatureSelector = FEATURE_C_PORT_RESET;
        } else {
            wFeatureSelector = FEATURE_C_PORT_ENABLE;
        }

        status = USBH_ChangeIndicationAckChange(
                    deviceExtensionHub,
                    Irp,
                    urb,
                    (USHORT)deviceExtensionHub->ResetPortNumber,
                    wFeatureSelector);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

//    if (deviceExtensionHub->HubFlags & HUBFLAG_PENDING_PORT_RESET) {
//        USBH_KdPrint((0,"'port change broke reset\n"));
//        TEST_TRAP();
//    }

    //
    // now queue the workitem to finish the processing
    //

    USBH_ASSERT(deviceExtensionHub->WorkItemToQueue != NULL);
    workItem = deviceExtensionHub->WorkItemToQueue;
    deviceExtensionHub->WorkItemToQueue = NULL;

    LOGENTRY(LOG_PNP, "qITM", deviceExtensionHub,
            &workItem->WorkQueueItem, 0);

    ExQueueWorkItem(&workItem->WorkQueueItem,
                        DelayedWorkQueue);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
USBH_ChangeIndicationAckChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port,
    IN USHORT FeatureSelector
    )
 /* ++
  *
  * Description:
  *
  *     Ack a reset change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION nextStack;  // next stack of the Irp
    CHAR stackSize;

    LOGENTRY(LOG_PNP, "ACH>", DeviceExtensionHub, FeatureSelector, Port);

    Urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);
    Urb->UrbHeader.Function = URB_FUNCTION_CLASS_OTHER;

    //
    // Fill in Urb body
    //

    UsbhBuildVendorClassUrb(Urb,
                            NULL,
                            URB_FUNCTION_CLASS_OTHER,
                            USBD_TRANSFER_DIRECTION_OUT | USBD_SHORT_TRANSFER_OK,
                            REQUEST_TYPE_SET_PORT_FEATURE,
                            REQUEST_CLEAR_FEATURE,
                            FeatureSelector,
                            Port,
                            0,
                            NULL);

    stackSize = DeviceExtensionHub->TopOfStackDeviceObject->StackSize;

    IoInitializeIrp(Irp,
                    (USHORT) (sizeof(IRP) + stackSize * sizeof(IO_STACK_LOCATION)),
                    (CCHAR) stackSize);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = Urb;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
    nextStack->Parameters.DeviceIoControl.IoControlCode = IOCTL_INTERNAL_USB_SUBMIT_URB;

    IoSetCompletionRoutine(Irp,    // Irp
                           USBH_ChangeIndicationAckChangeComplete,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           TRUE,    // invoke on error
                           TRUE);   // invoke on cancel

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);

    return ntStatus;

}


NTSTATUS
USBH_ChangeIndicationAckChangeComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    )
 /* ++
  *
  * Description:
  *
  *     ack a reset change
  *
  * Arguments:
  *
  * Return:
  *
  *
  * -- */
{
    PPORT_STATE currentPortState;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;
    PPORT_STATE hubExtensionPortState;
    PURB urb;
    PKEVENT resetEvent;
    LONG pendingWorkitem = 0;

    deviceExtensionHub = Context;
    currentPortState = &(deviceExtensionHub->PortStateBuffer);
    urb = &deviceExtensionHub->Urb;

    LOGENTRY(LOG_PNP, "aCHc", deviceExtensionHub,
            *((PULONG)currentPortState), Irp);

    hubExtensionPortState =
        &(deviceExtensionHub->PortData + deviceExtensionHub->ResetPortNumber - 1)->PortState;

    *hubExtensionPortState = *currentPortState;

    resetEvent = InterlockedExchangePointer(&deviceExtensionHub->Event, NULL);

    if (resetEvent) {

        LOGENTRY(LOG_PNP, "WAKr", deviceExtensionHub, resetEvent, 0);
        KeSetEvent(resetEvent,
                   1,
                   FALSE);
    }

    USBH_SubmitInterruptTransfer(deviceExtensionHub);

    pendingWorkitem = InterlockedDecrement(
                        &deviceExtensionHub->ChangeIndicationWorkitemPending);

    // If USBH_FdoPower or USBH_FdoCleanup is waiting on this
    // ChangeIndicationAckChangeComplete, then signal the thread
    // that it may now continue.

    if (!pendingWorkitem) {
        KeSetEvent(&deviceExtensionHub->CWKEvent, 1, FALSE);
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}


VOID
USBH_ChangeIndicationWorker(
    IN PVOID Context)
 /* ++
  *
  * Description:
  *
  * Work item scheduled to process a change indication from the hub. we process
  * the URB here and if necessary re-submit the interrupt transfer.
  *
  *
  * Arguments:
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    ULONG numberOfPorts;      // total ports on this hub
    ULONG portNumber;  // port that has status change
    PDEVICE_EXTENSION_HUB DeviceExtensionHub;
    PUSBH_WORK_ITEM workItem;
    ULONG state;
    //LONG ioCount;
    BOOLEAN newTransfer = FALSE;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PPORT_DATA p;
    ULONG i;
    PORT_STATE portState;
    LONG pendingWorkitem = 0;

    PAGED_CODE();
    USBH_ASSERT(sizeof(state) == sizeof(HUB_STATE));
    USBH_ASSERT(sizeof(state) == sizeof(PORT_STATE));

    workItem = Context;
    DeviceExtensionHub = workItem->DeviceExtensionHub;

    LOGENTRY(LOG_PNP, "cWK+", DeviceExtensionHub, Context, 0);

    USBH_KdPrint((2,"'Enter ChangeIndicationWorker %x\n", DeviceExtensionHub));

    // lock access to the hub ports

    // pending count inc'ed when work item was schedued
    USBH_KdPrint((2,"'***WAIT hub mutex %x\n", DeviceExtensionHub));
    KeWaitForSingleObject(&DeviceExtensionHub->HubMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT hub mutex done %x\n", DeviceExtensionHub));

    //
    // device is stopping, perform no processing
    // of the change request.
    //

    if (DeviceExtensionHub->HubFlags & HUBFLAG_DEVICE_STOPPING) {
        // set the abort event since we will not be
        // submitting another transfer
        KeSetEvent(&DeviceExtensionHub->AbortEvent,
                   1,
                   FALSE);
        goto USBH_ChangeIndicationWorker_Exit;
    }

    // Check for hub ESD failure.
    // Make sure that this is an external hub.

    if (DeviceExtensionHub->ErrorCount &&
        DeviceExtensionHub->PhysicalDeviceObject != DeviceExtensionHub->RootHubPdo) {

        hubParentDeviceExtensionPort =
                DeviceExtensionHub->PhysicalDeviceObject->DeviceExtension;

        if (hubParentDeviceExtensionPort->PortPdoFlags & PORTPDO_USB_SUSPEND) {

            // Hub likely failed during power up.  Don't do recovery here.
            // The Peracom hub (TI chipset) generally fails the first power
            // up if one of its downstream devices caused the wake, but the
            // next power up (from set S0 request) is successful.  Performing
            // ESD recovery at this time interferes with this.

            goto USBH_CIW_NoESD;
        }

        // if hub backpointer is null then this device is removed, attempt 
        // no ESD crap here.
        
        if (hubParentDeviceExtensionPort->DeviceExtensionHub == NULL) {
            goto USBH_CIW_NoESD;
        }

        // See if we can differentiate between hub removal and ESD.
        // Check the upstream port status.

        ntStatus = USBH_SyncGetPortStatus(
                    hubParentDeviceExtensionPort->DeviceExtensionHub,
                    hubParentDeviceExtensionPort->PortNumber,
                    (PUCHAR) &portState,
                    sizeof(portState));

//        if (!NT_SUCCESS(ntStatus) ||
//            portState.PortStatus & PORT_STATUS_CONNECT) {

        if (NT_SUCCESS(ntStatus) &&
            portState.PortStatus & PORT_STATUS_CONNECT) {

            // ESD
            USBH_KdPrint((1,"'Looks like ESD event (hub failure)\n"));

            if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_HAS_LOST_BRAINS)) {

                DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_HAS_LOST_BRAINS;

                LOGENTRY(LOG_PNP, "ESD!", DeviceExtensionHub,
                    0, DeviceExtensionHub->ErrorCount);

#if DBG
                UsbhWarning(NULL,
                    "ESD or hub failure occurred, attempting recovery.\n",
                    FALSE);
#endif

                numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
                USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
                p = DeviceExtensionHub->PortData;
                for (i=0; i<numberOfPorts; i++, p++) {

                    if (p->DeviceObject) {
                        USBH_KdPrint((1,"'Marking PDO %x for removal\n", p->DeviceObject));

                        deviceExtensionPort = p->DeviceObject->DeviceExtension;
                        deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                    }
//
// Note that we hold onto the hub's reference to the device object here.
// We need to do this for the case where a hub fails, and the downstream device
// had open references to it (open files on USB storage device).  In this case
// PnP won't send the remove to the device until the files have been closed, and
// we need the reference to the device object in the hub device extension so
// that we can properly cleanup after the device in USBH_FdoCleanup when the
// hub is removed.  If we do not do this then we will fault in
// USBH_PdoRemoveDevice when trying to dereference the pointer to the hub
// device extension that this device in connected to because the hub is long
// gone by then.
//
//                    p->DeviceObject = NULL;

                    p->ConnectionStatus = NoDeviceConnected;
                }

                // Tell PnP that there are no devices on this hub.
                // FdoQueryBusRelations will return zero devices for this hub
                // if the HUBFLAG_HUB_HAS_LOST_BRAINS is set.

                USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                                 BusRelations);

                // Start timer to start workitem to reset hub and attempt recovery.

                USBH_ScheduleESDRecovery(DeviceExtensionHub);

                goto USBH_ChangeIndicationWorker_Exit;
            }

        } else {
            // No ESD, hub was removed.
            LOGENTRY(LOG_PNP, "HubY", DeviceExtensionHub,
                DeviceExtensionHub->HubFlags, 0);
            USBH_KdPrint((1,"'Looks like hub was removed\n"));

            DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_GONE;
            // set the abort event since we will not be
            // submitting another transfer (parent hub may already be
            // selectively suspended)
            KeSetEvent(&DeviceExtensionHub->AbortEvent,
                       1,
                       FALSE);
            goto USBH_ChangeIndicationWorker_Exit;
        }
    }

USBH_CIW_NoESD:

    //
    // request reset flag is set indicating that the device
    // needs some attention
    //


    if (workItem->Flags & USBH_WKFLAG_REQUEST_RESET) {
        // reset the hub
        LOGENTRY(LOG_PNP, "rrST", DeviceExtensionHub, Context, 0);
        USBH_ResetHub(DeviceExtensionHub);

        // re-submit the interrupt transfer
        newTransfer = TRUE;
        goto USBH_ChangeIndicationWorker_Exit;
    }


#if DBG
    {
    ULONG i;
    for (i=0; i< DeviceExtensionHub->TransferBufferLength; i++) {
        USBH_KdPrint((2,"'Data[%d] = %x\n", i,
                       workItem->Data[i]));
    }
    }
#endif

    //
    // Check to see what has changed
    //

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
    for (portNumber = 0; portNumber <= numberOfPorts; portNumber++) {
        if (IsBitSet( &workItem->Data[0],
                     portNumber)) {
            break;
        }
    }

#if 0
    //
    // Work around for Philips hub bug. This should be temporary because it
    // will cost extraneous
    // CPU cycles for spec conformant external hubs. Remove the code for
    // formal build.
    //
#pragma message( "!!!!! Workaround for Philips external hub Vid==0471 && Rev==0030 !!!!!")
    if ((0x0471 == DeviceExtensionHub->DeviceDescriptor.idVendor) &&
    // (0x0101 == DeviceExtensionHub->DeviceDescriptor.idProduct) &&
        (0x0030 == DeviceExtensionHub->DeviceDescriptor.bcdDevice)) {
        //
        // This phillips external hub reports port status-change shift by 1
        // bit
        //
        USBH_KdBreak(("Shift By One hack fo philips hub\n"));
        portNumber--;
    }
#endif          /* PHILIPS_HACK_ENABLED */
    if (portNumber > numberOfPorts) {
        USBH_KdPrint((2,"'StatusChangeIndication nothing has changed\n"));

        //
        // nothing to do here
        // put the listen back down and get out.
        //

        newTransfer = TRUE;
        goto USBH_ChangeIndicationWorker_Exit;
    }

    USBH_KdPrint((2,"'Port number %x changed (0 indicates hub)\n", portNumber));
    LOGENTRY(LOG_PNP, "pCHG", DeviceExtensionHub, Context, portNumber);

    if (portNumber != 0)  {
        ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                          (USHORT)portNumber,
                                          (PUCHAR) &state,
                                          sizeof(state));
    } else {
        ntStatus = USBH_SyncGetHubStatus(DeviceExtensionHub,
                                         (PUCHAR) &state,
                                         sizeof(state));
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("ChangeIndication GetStatus failed code %x\n", ntStatus));

        //
        // an error occured getting the status for the port
        // put the listen back down and get out
        //
        // this condition may be temoprary in which case the
        // listen will cause us to retry

        DeviceExtensionHub->ErrorCount++;
        if (DeviceExtensionHub->ErrorCount > USBH_MAX_ERRORS) {
            HUB_FAILURE(DeviceExtensionHub);
        } else {
            newTransfer = TRUE;
        }
        goto USBH_ChangeIndicationWorker_Exit;
    }
    //
    // no error
    // process the status change
    //

    USBH_KdPrint((2,"'Process State = %x\n", state));

    if (portNumber != 0) {
        USBH_ProcessPortStateChange((PPORT_STATE)&state, (USHORT)portNumber, DeviceExtensionHub);
    } else {
        USBH_ProcessHubStateChange((PHUB_STATE)&state, DeviceExtensionHub);
    }

    newTransfer = TRUE;

USBH_ChangeIndicationWorker_Exit:

    UsbhExFreePool(workItem);

    //
    // The stopping thread can be signaled even though there is a transfer irp
    // pending.  because of this the stopping thread also waits on the
    // AbortEvent for the pending transfer.
    //

    if (newTransfer) {
        //
        // Put our listen transfer back down now that
        // we have acknowledged the change.
        //
        // NOTE: This could result in another work item being queued,
        // but only if the device stopping flag clear.
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);
    }

    //
    // allow others to access the ports
    //
    USBH_KdPrint((2,"'***RELEASE hub mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->HubMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);

    //
    // the pending count can only go to zero if the stopping flag has been set
    //
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

    pendingWorkitem = InterlockedDecrement(
                        &DeviceExtensionHub->ChangeIndicationWorkitemPending);

    // If USBH_FdoPower or USBH_FdoCleanup is waiting on this
    // ChangeIndicationWorker, then signal the thread that it
    // may now continue.

    if (!pendingWorkitem) {
        KeSetEvent(&DeviceExtensionHub->CWKEvent, 1, FALSE);
    }

    if (!pendingWorkitem &&
        DeviceExtensionHub->HubFlags & HUBFLAG_NEED_IDLE_CHECK) {

        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    LOGENTRY(LOG_PNP, "cWK-", DeviceExtensionHub, Context, 0);
    USBH_KdPrint((2,"'Exit ChangeIndicationWorker\n"));
}


VOID
USBH_ProcessHubStateChange(
    IN PHUB_STATE CurrentHubState,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *         Process a hub change indictaion from a hub
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    //
    // process hub status
    //
    PHUB_STATE hubExtensionState;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    ULONG statusBit;
    PPORT_DATA p;
    ULONG numberOfPorts, i;

    PAGED_CODE();
    if (CurrentHubState->HubChange & HUB_STATUS_LOCAL_POWER) {
        TEST_TRAP();
        USBH_KdPrint((2,"'StatusIndication hub local power changed\n"));
        statusBit = CurrentHubState->HubStatus & HUB_STATUS_LOCAL_POWER;
        hubExtensionState = &DeviceExtensionHub->HubState;
        USBH_KdPrint((2,"'Hub local power bit was %d is %d\n", \
             hubExtensionState->HubStatus & HUB_STATUS_LOCAL_POWER, statusBit));

        //
        // update our record
        //
        hubExtensionState->HubStatus &= ~HUB_STATUS_LOCAL_POWER;
        hubExtensionState->HubStatus |= statusBit;

        //
        // ack the change
        //
        USBH_SyncClearHubStatus(DeviceExtensionHub,
                                FEATURE_C_HUB_LOCAL_POWER);

        //
        // jd
        // What further action should be taken here?
        //

    } else if (CurrentHubState->HubChange & HUB_STATUS_OVER_CURRENT) {

        USBH_KdPrint(( 1, "Hub is reporting overcurrent\n"));
#ifdef MAX_DEBUG
        TEST_TRAP();
#endif
        statusBit = CurrentHubState->HubStatus & HUB_STATUS_OVER_CURRENT;
        hubExtensionState = &DeviceExtensionHub->HubState;
        USBH_KdPrint((2,"'Hub over current bit was %d is %d\n",
            hubExtensionState->HubStatus & HUB_STATUS_OVER_CURRENT, statusBit));

        //
        // update our record
        //
        hubExtensionState->HubStatus &= ~HUB_STATUS_OVER_CURRENT;
        hubExtensionState->HubStatus |= statusBit;

        //
        // set the ack status change
        //
        USBH_SyncClearHubStatus(DeviceExtensionHub,
                                FEATURE_C_HUB_OVER_CURRENT);

        //
        // We have a global overcurrent condition for the hub itself
        // chances are the entire hub has lost it -- we will mark the
        // hub as failed
        //
        if (hubExtensionState->HubStatus & HUB_STATUS_OVER_CURRENT) {

            USBH_KdPrint(( 1, "Hub disabled by overcurrent --> this is bad\n"));

            USBH_WriteFailReason(
                DeviceExtensionHub->PhysicalDeviceObject,
                USBH_FAILREASON_HUB_OVERCURRENT);

            HUB_FAILURE(DeviceExtensionHub);

            numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
            USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
            p = DeviceExtensionHub->PortData;
            for (i=0; i<numberOfPorts; i++, p++) {

                if (p->DeviceObject) {
                    USBH_KdPrint((1,"'Marking PDO %x for removal\n", p->DeviceObject));

                    deviceExtensionPort = p->DeviceObject->DeviceExtension;
                    deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                }
//
// Note that we hold onto the hub's reference to the device object here.
// We need to do this for the case where a hub fails, and the downstream device
// had open references to it (open files on USB storage device).  In this case
// PnP won't send the remove to the device until the files have been closed, and
// we need the reference to the device object in the hub device extension so
// that we can properly cleanup after the device in USBH_FdoCleanup when the
// hub is removed.  If we do not do this then we will fault in
// USBH_PdoRemoveDevice when trying to dereference the pointer to the hub
// device extension that this device in connected to because the hub is long
// gone by then.
//
//                    p->DeviceObject = NULL;

                p->ConnectionStatus = NoDeviceConnected;
            }

            // Tell PnP that there are no devices on this hub.
            // FdoQueryBusRelations will return zero devices for this hub
            // if the HUBFLAG_HUB_HAS_LOST_BRAINS is set.

            USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                             BusRelations);

            // Try to recover the hub.
            USBH_ScheduleESDRecovery(DeviceExtensionHub);
        }

    } else {
        USBH_KdBreak(("Unrecognized hub change code %x\n", CurrentHubState->HubChange));
    }
}


NTSTATUS
USBH_FlushPortChange(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
//    PPORT_DATA portData;
    PORT_STATE portState;

    ASSERT_HUB(DeviceExtensionHub);

//    portData = &deviceExtensionHub->PortData[
//                    DeviceExtensionPort->PortNumber - 1];

    LOGENTRY(LOG_PNP, "Pfls", DeviceExtensionPort,
                DeviceExtensionHub,
                DeviceExtensionPort->PortNumber);
    USBH_KdPrint((1,"'USBH_FlushPortChange, port number %x\n",
        DeviceExtensionPort->PortNumber));

    //
    // we need to refresh the port data since it was lost on the stop
    //

    ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                      DeviceExtensionPort->PortNumber,
                                      (PUCHAR) &portState,
                                      sizeof(portState));

    LOGENTRY(LOG_PNP, "PfST", DeviceExtensionPort,
                portState.PortChange,
                portState.PortStatus);

    if (NT_SUCCESS(ntStatus) &&
        portState.PortChange & PORT_STATUS_CONNECT) {

        LOGENTRY(LOG_PNP, "PfCL", DeviceExtensionPort,
                DeviceExtensionPort->PortNumber,
                ntStatus);

        ntStatus = USBH_SyncClearPortStatus(DeviceExtensionHub,
                                            DeviceExtensionPort->PortNumber,
                                            FEATURE_C_PORT_CONNECT);
    }

    return ntStatus;
}


VOID
USBH_ProcessPortStateChange(
    IN PPORT_STATE CurrentPortState,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub)
 /* ++
  *
  * Description:
  *
  *         Process a port change indication from the hub
  *
  *         this code assumes that only one change bit is set at a time
  *
  * Arguments:
  *
  * Return:
  *
  * -- */
{
    //
    // this code assumes that only one change bit is set at a time
    //

    PPORT_STATE hubExtensionPortState;
    USHORT statusBit;
    PPORT_DATA portData;
    BOOLEAN validConnectChange = TRUE;
    PDEVICE_EXTENSION_PORT deviceExtensionPort = NULL;
    PIRP irp;
    PIRP hubWaitWake = NULL;
    KIRQL irql;
    LONG pendingPortWWs;
    PWCHAR sernumbuf;
    PKEVENT suspendEvent;
#ifdef EARLY_RESOURCE_RELEASE
    PVOID deviceData;
#endif

    // Can't acquire (cancel) spin locks in paged code!
    // TODO:  isolate the pieces of code that require the spin lock into helper
    // functions
    // PAGED_CODE();
    USBH_ASSERT(DeviceExtensionHub->PortData != NULL);
    hubExtensionPortState = &(DeviceExtensionHub->PortData + PortNumber - 1)->PortState;

    USBH_KdPrint((2,"'USBH_ProcessPortStateChange for Port %x Old Dword %x\n", PortNumber, *(ULONG *) hubExtensionPortState));
    LOGENTRY(LOG_PNP, "PSCn", DeviceExtensionHub,
        CurrentPortState->PortStatus, CurrentPortState->PortChange);

    if (CurrentPortState->PortChange & PORT_STATUS_CONNECT) {
        //
        // bit 0, connect status change
        //
        USHORT oldStatusBit;

        USBH_KdPrint((2,"'Status Indication port connect changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_CONNECT;
        oldStatusBit = hubExtensionPortState->PortStatus & PORT_STATUS_CONNECT;

        USBH_KdPrint((2,"'Port connect was %x is %x\n", oldStatusBit, statusBit));

        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //

        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_CONNECT);


        //
        // If the conn status stays the same, clear the change. Otherwise,
        // tell to reenumerate.
        // A disconn->conn->disconn sequence is neglegible.
        // A conn->discconn->conn is considered only possible with the same
        // device.
        //

        USBH_ASSERT(PortNumber > 0);
        portData = &DeviceExtensionHub->PortData[PortNumber-1];

        if (!(oldStatusBit ^ statusBit)) {

            // we should only see this in the case where
            // the hub has lost power
            USBH_KdPrint((1,"'status change but nothing has changed\n"));


            LOGENTRY(LOG_PNP, "Pchg", DeviceExtensionHub,
                    PortNumber, validConnectChange);
        }

        if (portData->DeviceObject) {

            deviceExtensionPort = portData->DeviceObject->DeviceExtension;

            if (deviceExtensionPort->PortPdoFlags & PORTPDO_OVERCURRENT) {
                USBH_KdPrint((1,"'port overcurrent detected\n"));
                validConnectChange = FALSE;
                LOGENTRY(LOG_PNP, "Povr", DeviceExtensionHub,
                    PortNumber, validConnectChange);
            }

        }

        if (validConnectChange) {
            // we have a valid port connect status change
            LOGENTRY(LOG_PNP, "CONc", DeviceExtensionHub, PortNumber, 0);

            //
            // Notify PnP to enumerate this PDO for the device
            // that has arrived or left
            //

            // if a pdo exists for this port we must delete it since the
            // device may arrive agian before we get to QueryBusRelations

            if (portData->DeviceObject) {

                //
                // see if the PDO has not been started if so we can ignore
                // connect change on this port since the device will have to be
                // reset.
                //
                deviceExtensionPort =
                    portData->DeviceObject->DeviceExtension;

                if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
                    PDEVICE_OBJECT pdo;

                    pdo = portData->DeviceObject;    
                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    LOGENTRY(LOG_PNP, "pd2", pdo, 0, 0);
                    // legacy flags
                    DeviceExtensionHub->HubFlags |= HUBFLAG_CHILD_DELETES_PENDING;

                    if (pdo) {
                        // place the removed PDO on our list
                        InsertTailList(&DeviceExtensionHub->DeletePdoList, 
                                       &PDO_EXT(pdo)->DeletePdoLink);
                    }
                    // Prevent double free of SerialNumberBuffer in
                    // USBH_FdoQueryBusRelations.

                    sernumbuf = InterlockedExchangePointer(
                                    &deviceExtensionPort->SerialNumberBuffer,
                                    NULL);

                    if (sernumbuf) {
                        UsbhExFreePool(sernumbuf);
                    }

#ifdef EARLY_RESOURCE_RELEASE

                    //
                    // Remove the device data now to free
                    // up the bus resources.
                    //

                    deviceData = InterlockedExchangePointer(
                                    &deviceExtensionPort->DeviceData,
                                    NULL);

                    if (deviceData) {
#ifdef USB2
                        USBD_RemoveDeviceEx(DeviceExtensionHub,
                                            deviceData,
                                            DeviceExtensionHub->RootHubPdo,
                                            0);
#else
                        USBD_RemoveDevice(deviceData,
                                          DeviceExtensionHub->RootHubPdo,
                                          0);
#endif

                        USBH_SyncDisablePort(DeviceExtensionHub,
                                             PortNumber);
                    }

#endif  // EARLY_RESOURCE_RELEASE

                }
            }

            USBH_KdPrint((2,"'Notify BusCheck by FDO extension %x\n", DeviceExtensionHub));

            USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
                                             BusRelations);

            USBH_KdPrint((2,"'StatusIndication Conn Changed port %x\n", PortNumber));
        }


    } else if (CurrentPortState->PortChange & PORT_STATUS_RESET) {

        //
        // bit 4 RESET completed
        //

        //
        // we simply ack the change and signal the PnP thread that is
        // waiting.
        //

        USBH_KdPrint((2,"'Status Indication port reset changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_RESET;
        USBH_KdPrint((2,"'Port reset was %x is %x\n",
                hubExtensionPortState->PortStatus & PORT_STATUS_RESET, statusBit));

        // port status will not be enabled if the device failed
#if DBG
        if (!(CurrentPortState->PortStatus & PORT_STATUS_ENABLE)) {
            USBH_KdPrint((1, "'Device failed after reset\n"));
        }
#endif
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_RESET);

        //
        // Signal the PNP thread that a the reset has completed
        //
        LOGENTRY(LOG_PNP, "RESp", DeviceExtensionHub, PortNumber, 0);

    } else if (CurrentPortState->PortChange & PORT_STATUS_ENABLE) {

        //
        // ways to hit this code:
        // 1. frame babble causes the port to be disabled
        // 2. overcurrent causes a port disable



        // bit 1 port has been enabled
        USBH_KdPrint((2,"'Status Indication port enable changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_ENABLE;
        USBH_KdPrint((2,"'Port enable was %x is %x\n",
               hubExtensionPortState->PortStatus & PORT_STATUS_ENABLE,
               statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //

        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_ENABLE);

        LOGENTRY(LOG_PNP, "ENAc", DeviceExtensionHub, PortNumber, 0);

    } else if (CurrentPortState->PortChange & PORT_STATUS_SUSPEND) {
        //
        // bit 2 suspend changed
        //

        USBH_KdPrint((2,"'Status Indication port suspend changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_SUSPEND;
        USBH_KdPrint((2,"'Port suspend was %x is %x\n",
              hubExtensionPortState->PortStatus & PORT_STATUS_SUSPEND,
              statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_SUSPEND);

        LOGENTRY(LOG_PNP, "SUSc", DeviceExtensionHub, PortNumber, 0);

        suspendEvent = InterlockedExchangePointer(&DeviceExtensionHub->Event, NULL);

        if (suspendEvent) {

            LOGENTRY(LOG_PNP, "WAKs", DeviceExtensionHub, PortNumber, 0);
            KeSetEvent(suspendEvent,
                       1,
                       FALSE);

        }

        // Complete the WW IRP, if any, for this port.
        //
        // Note that we only want to do this for the selective suspend case
        // and not the general resume case.  (We don't want to be completing
        // port WW IRPs while the system is suspending just because someone
        // moved the mouse.)
        //
        // Note also that in our current Selective Suspend implementation,
        // this code is not really even necessary because we only suspend
        // when the entire bus can suspend, which includes the root hub,
        // and if the root hub is suspended then the bus is reawoken by
        // USBPORT completing the WW IRP for the root hub.  This code here
        // is only used if a child device indicates resume signalling while
        // the parent hub is powered and fully operational.

        USBH_ASSERT(PortNumber > 0);
        portData = &DeviceExtensionHub->PortData[PortNumber-1];
        if (portData->DeviceObject) {
            deviceExtensionPort = portData->DeviceObject->DeviceExtension;
        }

        if (deviceExtensionPort && deviceExtensionPort->IdleNotificationIrp) {

            IoAcquireCancelSpinLock(&irql);
            irp = deviceExtensionPort->WaitWakeIrp;
            deviceExtensionPort->WaitWakeIrp = NULL;
            // signal the waitwake irp if we have one
            if (irp) {

                USBH_KdPrint((1,"'Signaling WaitWake IRP (%x) (resume signalling)\n", irp));
                LOGENTRY(LOG_PNP, "rsWW", deviceExtensionPort,
                    deviceExtensionPort->DeviceState, DeviceExtensionHub->HubFlags);

                IoSetCancelRoutine(irp, NULL);

                deviceExtensionPort->PortPdoFlags &=
                    ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                pendingPortWWs =
                    InterlockedDecrement(&DeviceExtensionHub->NumberPortWakeIrps);

                if (0 == pendingPortWWs && DeviceExtensionHub->PendingWakeIrp) {
                    hubWaitWake = DeviceExtensionHub->PendingWakeIrp;
                    DeviceExtensionHub->PendingWakeIrp = NULL;
                }
                IoReleaseCancelSpinLock(irql);

                //
                // If there are no more outstanding WW irps, we need to cancel the WW
                // to the hub.
                //
                if (hubWaitWake) {
                    USBH_HubCancelWakeIrp(DeviceExtensionHub, hubWaitWake);
                }

                USBH_CompletePowerIrp(DeviceExtensionHub, irp, STATUS_SUCCESS);

            } else {
                IoReleaseCancelSpinLock(irql);
            }
        }

    } else if (CurrentPortState->PortChange & PORT_STATUS_OVER_CURRENT) {
        //
        // bit 3
        //


        USBH_KdPrint((2,"'Status Indication port over current changed\n"));
        statusBit = CurrentPortState->PortStatus & PORT_STATUS_OVER_CURRENT;
        USBH_KdPrint((2,"'Port over current was %x is %x\n",
             hubExtensionPortState->PortStatus & PORT_STATUS_OVER_CURRENT,
             statusBit));

        //
        // update our record
        //
        *hubExtensionPortState = *CurrentPortState;

        //
        // ack the change
        //
        USBH_SyncClearPortStatus(DeviceExtensionHub,
                                 PortNumber,
                                 FEATURE_C_PORT_OVER_CURRENT);

        LOGENTRY(LOG_PNP, "OVRc", DeviceExtensionHub, PortNumber, 0);

        // The hub has reported overcurrent contion on the port, we will note
        // this for the PDO.  note that if a true overcurrent condition has occurred
        // the port should be disabled and powered off as well.

        // for some reason the NEC controller will report an overcurrent
        // condition if the MS USB mouse is plugged in during boot
        //

        if (!(hubExtensionPortState->PortStatus & PORT_STATUS_POWER)) {

            USBH_ASSERT(PortNumber > 0);
            portData = &DeviceExtensionHub->PortData[PortNumber-1];

            USBH_KdPrint((1,"'warning: overcurrent detected for port %d\n",
                PortNumber));

            USBH_SyncRefreshPortAttributes(DeviceExtensionHub);

            // ignore overcurrent on CC ports
            if (!(portData->PortAttributes & 
                  USB_PORTATTR_NO_OVERCURRENT_UI)) {
                      
                if (portData->DeviceObject != NULL) {
                
                    deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                    //xxx ?? IoInvalidateDeviceRelations?
                    
                    // ignore overcurrent on CC ports
                    deviceExtensionPort->PortPdoFlags |= PORTPDO_OVERCURRENT;
                    UsbhWarning(NULL,
                               "port disabled/off due to overcurrent\n",
                                FALSE);

                    USBH_InvalidatePortDeviceState(
                            DeviceExtensionHub,
                            UsbhGetConnectionStatus(deviceExtensionPort),
                            deviceExtensionPort->PortNumber);
                 } else {
                    // NOTE: for some reason the NEC controller on Toshiba laptops
                    // does this.
  
                    USBH_KdPrint((1,"'warning: port has no device attached! %d\n",
                        PortNumber));

                    USBH_InvalidatePortDeviceState(
                            DeviceExtensionHub,
                            DeviceCausedOvercurrent,
                            PortNumber);
                }                    
            }

        }

    } else {
        LOGENTRY(LOG_PNP, "???c", DeviceExtensionHub, PortNumber, 0);
        USBH_KdBreak(("Unknown chnage bit, ignore\n"));
    }

    USBH_KdPrint((2,"'Exit ProcessPortState\n"));
}

NTSTATUS
USBH_GetNameFromPdo(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    )
/*++

Routine Description:

    Returns the device name for the give instance of the HCD

Arguments:

    DeviceObject -

    DeviceNameUnicodeString - ptr to unicode string to initialize
                    with device name.

Return Value:

    NT status code

--*/
{
    ULONG actualSize;
    NTSTATUS ntStatus;

    PAGED_CODE();
    ntStatus=IoGetDeviceProperty(PdoDeviceObject,
                                 DevicePropertyPhysicalDeviceObjectName,
                                 0,
                                 NULL,
                                 &actualSize);

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        DeviceNameUnicodeString->Length=(USHORT)actualSize-sizeof(UNICODE_NULL);
        DeviceNameUnicodeString->MaximumLength=(USHORT)actualSize;
        //
        // Must use ExAllocatePool directly here because we call
        // RtlFreeUnicode string to free the buffer
        //
        DeviceNameUnicodeString->Buffer =
            ExAllocatePoolWithTag(PagedPool, actualSize, USBHUB_HEAP_TAG);
        if (!DeviceNameUnicodeString->Buffer) {
            ntStatus=STATUS_INSUFFICIENT_RESOURCES;
        } else {

            ntStatus=IoGetDeviceProperty(PdoDeviceObject,
                                         DevicePropertyPhysicalDeviceObjectName,
                                         actualSize,
                                         DeviceNameUnicodeString->Buffer,
                                         &actualSize);

            if (!NT_SUCCESS(ntStatus)) {
                ExFreePool(DeviceNameUnicodeString->Buffer);
            } else {

                // now strip off the "\Device\"
                RtlCopyMemory(DeviceNameUnicodeString->Buffer,
                              DeviceNameUnicodeString->Buffer+8,
                              actualSize-8*sizeof(WCHAR));
                DeviceNameUnicodeString->Length -= 16;
            }
        }
    } else {
        ntStatus=STATUS_INSUFFICIENT_RESOURCES;
    }

    USBH_KdPrint((2,"'USBH_GetNameFromPdo = %x\n", ntStatus));

    return(ntStatus);
}

#if 0
NTSTATUS
USBH_MakeName(
    PDEVICE_OBJECT PdoDeviceObject,
    ULONG NameLength,
    PWCHAR Name,
    PUNICODE_STRING UnicodeString
    )
/*++

Routine Description:

    Creates a hub name unicode string from uncode 'Name' string passed in
    and the unique name associated with the Pdo.

Arguments:

    PdoDeviceObject - a PDO

    NameLength - length (in bytes) of 'Name' unicode string,
                including NULL.

    Name - NULL terminated unicode string suffix

Return Value:

    None

--*/
{
    UNICODE_STRING keyUnicodeString;
    NTSTATUS ntStatus;
    PWCHAR buffer;
    USHORT length;

    PAGED_CODE();
    //
    // get the name from the Pdo
    //

    ntStatus = USBH_GetNameFromPdo(PdoDeviceObject,
                                   &keyUnicodeString);


    USBH_ASSERT(NameLength > 0);

    if (NT_SUCCESS(ntStatus)) {
        // ok we have the unique name, now we
        // need to allocate a buffer big enough
        // for it plus the 'Name' string

        // keyname + prefix + NULL (Namelength includes NULL)
        length = keyUnicodeString.Length +
                (USHORT) NameLength;

        //
        // Must use normal api so that caller can use RtlFreeUnicodeString
        //

        buffer = ExAllocatePool(PagedPool, length, USBHUB_HEAP_TAG);

        if (buffer) {
            RtlCopyMemory(buffer, Name, NameLength);

            RtlInitUnicodeString(UnicodeString,
                                 buffer);

            UnicodeString->MaximumLength = length;

            USBH_ASSERT(*(buffer+((NameLength/2)-1)) == NULL);

            ntStatus = RtlAppendUnicodeStringToString(UnicodeString,
                                                      &keyUnicodeString);
            USBH_KdPrint((2,"'USBH_MakeName = key string = %x %x\n", &keyUnicodeString,
                    UnicodeString));

        } else {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            TEST_TRAP();
        }

        RtlFreeUnicodeString(&keyUnicodeString);

    }

    return ntStatus;
}

NTSTATUS
USBH_GenerateDeviceName(
    PDEVICE_OBJECT PdoDeviceObject,
    PUNICODE_STRING DeviceNameUnicodeString,
    PUNICODE_STRING DeviceLinkUnicodeString,
    PUNICODE_STRING NameUnicodeString
    )
/*++

Routine Description:

    Generates device name strings for use with IoCreateDevice and
    IoCreateSymbolicLink.

Arguments:

    PdoDeviceObject - a PDO

    DeviceNameUnicodeString

    DeviceLinkUnicodeString -

    NameUnicodeString

Return Value:

    NT Status code.

--*/
{
    WCHAR deviceLink[]  = L"\\DosDevices\\";
    WCHAR deviceName[]  = L"\\Device\\";
    WCHAR name[]  = L"";
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN gotDevname = FALSE, gotName = FALSE, gotLinkname = FALSE;

    PAGED_CODE();

    if (DeviceNameUnicodeString) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(deviceName),
                                 deviceName,
                                 DeviceNameUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotDevname = TRUE;
        }
    }

    if (DeviceLinkUnicodeString && NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(deviceLink),
                                 deviceLink,
                                 DeviceLinkUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotLinkname = TRUE;
        }
    }

    if (NameUnicodeString && NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_MakeName(PdoDeviceObject,
                                 sizeof(name),
                                 name,
                                 NameUnicodeString);

        if (NT_SUCCESS(ntStatus)) {
            gotName = TRUE;
        }
    }

    if (!NT_SUCCESS(ntStatus)) {

        //
        // cleanup all the strings if we fail
        //

        // an error here is most likely a bug
        USBH_KdTrap(("failed to generate Hub device name\n"));

        if (gotDevname) {
            RtlFreeUnicodeString(DeviceNameUnicodeString);
        }

        if (gotLinkname) {
            RtlFreeUnicodeString(DeviceLinkUnicodeString);
        }

        if (gotName) {
            RtlFreeUnicodeString(NameUnicodeString);
        }
    }

    USBH_KdPrint((2,"'USBH_GenerateDeviceName = %x\n", ntStatus));

    return ntStatus;
}
#endif


NTSTATUS
USBH_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject)
 /* ++ Description:
  *
  * Called whenever the hub driver is loaded to control a device.
  * Possible reasons:
  * 1. a hub was attached to the USB
  * 2. we where loaded as the generic parent for a composite device
  * 3. we were loaded as a configuring driver.
  *
  * Arguments:
  *
  * PhysicalDeviceObject - Parent device object PDO created to handle us.
  * DriverObject - Store the pointer to the object representing us.
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL, rootHubPdo = NULL, dummyPdo = NULL;
    PDEVICE_OBJECT topOfStackDeviceObject = NULL;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;  // pointer to our device
                                               // extension
    USBH_KdPrint((2,"'Enter AddDevice\n"));
    LOGENTRY(LOG_PNP, "hADD", PhysicalDeviceObject, 0, 0);

#if DBG
    USBH_GetClassGlobalDebugRegistryParameters();
#endif

    //
    // Create a new hub on the USB
    //
    //

    USBH_KdBreak(("Add Device for hub\n"));

    if (NT_SUCCESS(ntStatus)) {

        USBH_ASSERT(sizeof(DEVICE_EXTENSION_HUB) >= sizeof(DEVICE_EXTENSION_PARENT));
        ntStatus = IoCreateDevice(DriverObject,    // our driver object
                                  sizeof(DEVICE_EXTENSION_HUB), // extension size for us
                                  NULL,  // name for this device
                                  FILE_DEVICE_USB_HUB,  // HUB type
                                  FILE_AUTOGENERATED_DEVICE_NAME,                // device characteristics
                                  FALSE,            // Not exclusive
                                  &deviceObject);   // Our device object

        if (NT_SUCCESS(ntStatus)) {

            deviceExtensionHub = (PDEVICE_EXTENSION_HUB) deviceObject->DeviceExtension;
            deviceExtensionHub->ExtensionType = EXTENSION_TYPE_HUB;
        }
    }

    if (NT_SUCCESS(ntStatus)) {
        topOfStackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);
        if (!topOfStackDeviceObject) {
            ntStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(ntStatus)) {

        // Initialize the rest of the hub device extension

        deviceExtensionHub->FunctionalDeviceObject = deviceObject;
        deviceExtensionHub->PhysicalDeviceObject = PhysicalDeviceObject;

        deviceExtensionHub->TopOfStackDeviceObject = topOfStackDeviceObject;
        USBH_KdPrint((2,"'stack device object stack size = %x\n",
                deviceExtensionHub->TopOfStackDeviceObject->StackSize));

        deviceObject->Flags |= DO_POWER_PAGABLE;
        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

#ifdef WMI_SUPPORT
        {

        PWMILIB_CONTEXT wmiLibInfo;
        extern WMIGUIDREGINFO USB_WmiGuidList[NUM_WMI_SUPPORTED_GUIDS];

        wmiLibInfo = &deviceExtensionHub->WmiLibInfo;

        wmiLibInfo->GuidCount = sizeof (USB_WmiGuidList) /
                                 sizeof (WMIGUIDREGINFO);
        ASSERT(NUM_WMI_SUPPORTED_GUIDS == wmiLibInfo->GuidCount);

        // Omit the last GUID in the list if this is not a Root Hub.

        USBH_SyncGetRootHubPdo(deviceExtensionHub->TopOfStackDeviceObject,
                               &rootHubPdo,
                               &dummyPdo,
                               NULL);

        if (rootHubPdo != PhysicalDeviceObject) {

            // Dump the last WMI GUID.
            wmiLibInfo->GuidCount--;
        }

        wmiLibInfo->GuidList = USB_WmiGuidList;
        wmiLibInfo->QueryWmiRegInfo = USBH_QueryWmiRegInfo;
        wmiLibInfo->QueryWmiDataBlock = USBH_QueryWmiDataBlock;
        wmiLibInfo->SetWmiDataBlock = USBH_SetWmiDataBlock;
        wmiLibInfo->SetWmiDataItem = NULL;
        wmiLibInfo->ExecuteWmiMethod = USBH_ExecuteWmiMethod;
        wmiLibInfo->WmiFunctionControl = NULL;

        IoWMIRegistrationControl(deviceObject,
                                 WMIREG_ACTION_REGISTER
                                 );
        }
#endif

    } else {
        // failed to create device object or symbolic link
        TEST_TRAP();
        if (deviceObject) {
            IoDeleteDevice(deviceObject);
        }
    }

    USBH_KdPrint((2,"'AddDevice return %x\n", ntStatus));

    return ntStatus;
}


#if DBG

NTSTATUS
USBH_GetClassGlobalDebugRegistryParameters(
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    RTL_QUERY_REGISTRY_TABLE QueryTable[3];
    PWCHAR usb = L"usb";
#define DEBUG_LEVEL                     L"debuglevel"
#define DEBUG_WIN9X                     L"debugWin9x"
    extern ULONG USBH_W98_Debug_Trace;

    PAGED_CODE();

    //
    // Set up QueryTable to do the following:
    //

    // spew level
    QueryTable[0].QueryRoutine = USBH_GetConfigValue;
    QueryTable[0].Flags = 0;
    QueryTable[0].Name = DEBUG_LEVEL;
    QueryTable[0].EntryContext = &USBH_Debug_Trace_Level;
    QueryTable[0].DefaultType = REG_DWORD;
    QueryTable[0].DefaultData = &USBH_Debug_Trace_Level;
    QueryTable[0].DefaultLength = sizeof(USBH_Debug_Trace_Level);

    // ntkern trace buffer
    QueryTable[1].QueryRoutine = USBH_GetConfigValue;
    QueryTable[1].Flags = 0;
    QueryTable[1].Name = DEBUG_WIN9X;
    QueryTable[1].EntryContext = &USBH_W98_Debug_Trace;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = &USBH_W98_Debug_Trace;
    QueryTable[1].DefaultLength = sizeof(USBH_W98_Debug_Trace);

    //
    // Stop
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    ntStatus = RtlQueryRegistryValues(
                RTL_REGISTRY_SERVICES,
                usb,
                QueryTable,     // QueryTable
                NULL,           // Context
                NULL);          // Environment

    if (NT_SUCCESS(ntStatus)) {
         USBH_KdPrint((1, "'Debug Trace Level Set: (%d)\n", USBH_Debug_Trace_Level));

        if (USBH_W98_Debug_Trace) {
            USBH_KdPrint((1, "'NTKERN Trace is ON\n"));
        } else {
            USBH_KdPrint((1, "'NTKERN Trace is OFF\n"));
        }

        if (USBH_Debug_Trace_Level > 0) {
            ULONG UHCD_Debug_Asserts = 1;
        }
    }

    if ( STATUS_OBJECT_NAME_NOT_FOUND == ntStatus ) {
        ntStatus = STATUS_SUCCESS;
    }

    return ntStatus;
}

#endif

#if 0
NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus;

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);
    LOGENTRY(LOG_PNP, "STRT", DeviceExtensionHub, 0, 0);
 
    ntStatus = USBH_FdoHubStartDevice(DeviceExtensionHub,
                                      Irp);

    return ntStatus;                                      
}
#endif

// since we no longer use the hub as parent we will always treat 
// the device as a hub

NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS ntStatus, status;
    PDEVICE_EXTENSION_PARENT parent;

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    LOGENTRY(LOG_PNP, "STRT", DeviceExtensionHub, 0, 0);
    //
    // collect some inforantion from the device, like the root hub
    // pdo for our fast-path
    //

    DeviceExtensionHub->RootHubPdo = NULL;
    ntStatus =
        USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                               &DeviceExtensionHub->RootHubPdo,
                               &DeviceExtensionHub->TopOfHcdStackDeviceObject,
                               NULL);

    if (!NT_SUCCESS(ntStatus)) {
        KeInitializeEvent(&DeviceExtensionHub->PnpStartEvent, NotificationEvent, FALSE);

        USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(Irp,
                               USBH_HubPnPIrp_Complete,
                               // always pass FDO to completion routine
                               DeviceExtensionHub,
                               TRUE,
                               TRUE,
                               TRUE);

        status = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                              Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject(&DeviceExtensionHub->PnpStartEvent,
                                  Suspended,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        //
        // complete the start Irp now since we pended it with
        // our completion handler.
        //

        LOGENTRY(LOG_PNP, "STR!", DeviceExtensionHub, 0, ntStatus);
        USBH_CompleteIrp(Irp, ntStatus);

    } else if (DeviceExtensionHub->RootHubPdo != NULL) {
        // stack reports a root hub PDO then this
        // is a hub
        ntStatus = USBH_FdoHubStartDevice(DeviceExtensionHub,
                                          Irp);
    } else {
        //
        // if no root hub PDO then we are being loaded
        // as a configuring parent driver.
        //

        DeviceExtensionHub->ExtensionType = EXTENSION_TYPE_PARENT;

        //
        // Initialize this parent
        //
        parent = (PDEVICE_EXTENSION_PARENT) DeviceExtensionHub;

        parent->PowerIrp = NULL;
        parent->PendingWakeIrp = NULL;
        parent->NumberFunctionWakeIrps = 0;
        parent->FunctionCount = 0;
        parent->FunctionList.Next = NULL;
        parent->ParentFlags = 0;
        parent->NeedCleanup = FALSE;
        parent->ConfigurationDescriptor = NULL;
        KeInitializeSpinLock (&parent->ParentSpinLock);

        //
        // Start it.
        //
        ntStatus = USBH_ParentFdoStartDevice(parent, Irp, TRUE);

    }

    return ntStatus;
}



VOID
USBH_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    )

/*++

Routine Description:

    This routine reads or write config space.

Arguments:

    DeviceObject        - Physical DeviceObject for this USB controller.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION nextStack;
    PIRP irp;
    NTSTATUS ntStatus;
    KEVENT event;

    PAGED_CODE();
    USBH_KdPrint((2,"'USBH_QueryCapabilities\n"));

    irp = IoAllocateIrp(PdoDeviceObject->StackSize, FALSE);

    if (!irp) {
        USBH_KdTrap(("Allocate Irp failed\n"));
        return;
    }

    // All PnP IRP's need the Status field initialized to STATUS_NOT_SUPPORTED.
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           USBH_DeferIrpCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    USBH_ASSERT(nextStack != NULL);
    nextStack->MajorFunction= IRP_MJ_PNP;
    nextStack->MinorFunction= IRP_MN_QUERY_CAPABILITIES;
    //this is different from the latest version of busdd.doc
    nextStack->Parameters.DeviceCapabilities.Capabilities = DeviceCapabilities;

    // IrpAssert: Initialize these fields in the DeviceCapabilities structure
    // before passing down.

    RtlZeroMemory(nextStack->Parameters.DeviceCapabilities.Capabilities,
        sizeof(DEVICE_CAPABILITIES));
    nextStack->Parameters.DeviceCapabilities.Capabilities->Address = -1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->UINumber = -1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->Version = 1;
    nextStack->Parameters.DeviceCapabilities.Capabilities->Size =
        sizeof(DEVICE_CAPABILITIES);

    ntStatus = IoCallDriver(PdoDeviceObject,
                            irp);

    USBH_KdPrint((2,"'ntStatus from IoCallDriver to hub PDO = 0x%x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
//        TEST_TRAP();

        KeWaitForSingleObject(
            &event,
            Suspended,
            KernelMode,
            FALSE,
            NULL);
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdTrap(("Query capabilities failed!\n"));
    }

    IoFreeIrp(irp);
}

BOOLEAN
USBH_HubIsBusPowered(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
 /* ++
  *
  * Description:
  *
  * Return:
  *
  *     TRUE if the hub is bus powered
  *
  * -- */
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    USHORT power, statusBits;
    BOOLEAN busPowered;

    PAGED_CODE();
    USBH_KdPrint((2,"'enter HubIsBusPowered\n"));

    // read the power bits from the config descriptor
    power = ConfigurationDescriptor->bmAttributes &
                USB_CONFIG_POWERED_MASK;

    //
    // now attempt to get the status bits from the device
    //
    ntStatus = USBH_SyncGetStatus(DeviceObject,
                                  &statusBits,
                                  URB_FUNCTION_GET_STATUS_FROM_DEVICE,
                                  0);

    if (NT_SUCCESS(ntStatus)) {
        USBH_KdPrint((2,"'hub status bits %x\n", statusBits));

        busPowered = !(statusBits & USB_GETSTATUS_SELF_POWERED);

    } else {
        USBH_KdBreak(("device failed get status %x, power bits = %x\n",
                ntStatus, power));

        //
        // device failed get_status, fall back to the values in the
        // config descriptor.
        //

        busPowered = power == USB_CONFIG_BUS_POWERED;
    }

    return busPowered;
}


NTSTATUS
USBH_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_FDO deviceExtension;

    USBH_KdPrint((2,"'enter USBH_PnPIrp_Complete\n"));

    deviceExtension = Context;

    // kenray sez we should be calling IoMarkIrpPending
    // from our completion routine.
    //

    if (Irp->PendingReturned) {
        IoMarkIrpPending(Irp);
    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBH_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    USBH_KdPrint((2,"'IRP_MN_START_DEVICE (fdo), completion routine\n"));

    // signal the start device dispatch to finsh
    KeSetEvent(&deviceExtension->PnpStartEvent,
               1,
               FALSE);

    // defer completion
    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    Irp->IoStatus.Status = ntStatus;

    USBH_KdPrint((2,"'exit USH_PnPIrp_Complete %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_HubPnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION_HUB deviceExtensionHub;

    USBH_KdPrint((2,"'enter USBH_HubPnPIrp_Complete\n"));

    deviceExtensionHub = Context;

    // kenray sez we should be calling IoMarkIrpPending
    // from our completion routine.
    //

// No. Since this IRP is completed synchronously (on the same thread that
// created it), we should not do this.
//
//    if (Irp->PendingReturned) {
//        IoMarkIrpPending(Irp);
//    }

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBH_ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    USBH_ASSERT(irpStack->MinorFunction == IRP_MN_START_DEVICE);

    USBH_KdPrint((2,"'IRP_MN_START_DEVICE (fdo), completion routine\n"));

    // signal the start device dispatch to finsh
    KeSetEvent(&deviceExtensionHub->PnpStartEvent,
               1,
               FALSE);

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        deviceExtensionHub->HubFlags |= HUBFLAG_HUB_FAILURE;
    }

    // defer completion
    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    Irp->IoStatus.Status = ntStatus;

    USBH_KdPrint((2,"'exit USH_HubPnPIrp_Complete %x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_FdoHubStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp)
 /* ++ Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_START_DEVICE). We will
  * initialize the hub and ready all ports.
  *
  * Argument:
  *
  * Return:
  *
  * STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise
  *
  * -- */
{
    NTSTATUS status, ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PORT hubParentDeviceExtensionPort;
    PPORT_DATA portData;
    DEVICE_CAPABILITIES deviceCapabilities;
    ULONG hubCount = 0, p;
    LONG i;
#if DBG
    BOOLEAN bWakeSupported = FALSE;
#endif

    PAGED_CODE();
    USBH_KdPrint((2,"'Enter Hub StartDevice\n"));
    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    //
    // New hub
    //
    LOGENTRY(LOG_PNP, "hSTR", DeviceExtensionHub, 0, 0);

    //
    // initailize allocated structures to NULL;
    //

    DeviceExtensionHub->HubDescriptor = NULL;
    DeviceExtensionHub->Irp = NULL;
    DeviceExtensionHub->TransferBuffer = NULL;
    DeviceExtensionHub->ConfigurationDescriptor = NULL;
    // transition to zero signals the event
    DeviceExtensionHub->PendingRequestCount = 1;
    DeviceExtensionHub->HubFlags = 0;
    DeviceExtensionHub->PendingWakeIrp = NULL;
    DeviceExtensionHub->NumberPortWakeIrps = 0;
    DeviceExtensionHub->PendingIdleIrp = NULL;
    DeviceExtensionHub->ChangeIndicationWorkitemPending = 0;
    // Although this is only used for the Root Hub, we initialize for all hubs.
    DeviceExtensionHub->CurrentSystemPowerState = PowerSystemWorking;

    KeInitializeEvent(&DeviceExtensionHub->PnpStartEvent, NotificationEvent, FALSE);

    KeInitializeSpinLock (&DeviceExtensionHub->CheckIdleSpinLock);
    InitializeListHead(&DeviceExtensionHub->DeletePdoList);

    USBH_KdPrint((2,"'Set PnPIrp Completion Routine\n"));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp,
                           USBH_HubPnPIrp_Complete,
                           // always pass FDO to completion routine
                           DeviceExtensionHub,
                           TRUE,
                           TRUE,
                           TRUE);

    status = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                          Irp);

    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&DeviceExtensionHub->PnpStartEvent,
                              Suspended,
                              KernelMode,
                              FALSE,
                              NULL);
    }

    DeviceExtensionHub->RootHubPdo = NULL;
    ntStatus =
        USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                               &DeviceExtensionHub->RootHubPdo,
                               &DeviceExtensionHub->TopOfHcdStackDeviceObject,
                               NULL);
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_SyncGetRootHubPdo fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }        
    // init our failreason

    USBH_WriteFailReason(
            DeviceExtensionHub->PhysicalDeviceObject,
            USBH_FAILREASON_HUB_GENERAL_FAILURE);


    if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {

        ntStatus = STATUS_UNSUCCESSFUL;
        USBH_KdBreak(("Hub Start Failure\n"));

        goto USBH_StartDeviceDone;
    }

    // assume device supports wakeup by default
    DeviceExtensionHub->HubFlags |= HUBFLAG_SUPPORT_WAKEUP;
    {
        NTSTATUS status;
        ULONG disableWakeup = 0;
        WCHAR USBH_RemoteWakeupKey[] = L"DisableRemoteWakeup";

        status =
            USBD_GetPdoRegistryParameter(DeviceExtensionHub->PhysicalDeviceObject,
                                         &disableWakeup,
                                         sizeof(disableWakeup),
                                         USBH_RemoteWakeupKey,
                                         sizeof(USBH_RemoteWakeupKey));

        if (NT_SUCCESS(status) && disableWakeup) {
            DeviceExtensionHub->HubFlags &= ~HUBFLAG_SUPPORT_WAKEUP;
            USBH_KdPrint((1, "'Warning: remote wakeup disabled in registry\n"));
        }
    }

    DeviceExtensionHub->CurrentPowerState = PowerDeviceD0;

    KeInitializeEvent(&DeviceExtensionHub->AbortEvent, NotificationEvent,
        TRUE);

    // initial state is not signaled
    KeInitializeEvent(&DeviceExtensionHub->PendingRequestEvent, NotificationEvent,
        FALSE);

    KeInitializeEvent(&DeviceExtensionHub->SubmitIdleEvent, NotificationEvent,
        FALSE);

    // This one defaults to signalled.
    KeInitializeEvent(&DeviceExtensionHub->CWKEvent, NotificationEvent,
        TRUE);

    KeInitializeSemaphore(&DeviceExtensionHub->HubMutex, 1, 1);
    KeInitializeSemaphore(&DeviceExtensionHub->HubPortResetMutex, 1, 1);
    KeInitializeSemaphore(&DeviceExtensionHub->ResetDeviceMutex, 1, 1);

    USBH_ASSERT(DeviceExtensionHub->RootHubPdo);

    USBH_SyncGetRootHubPdo(DeviceExtensionHub->TopOfStackDeviceObject,
                           NULL,
                           NULL,
                           &hubCount);

#ifdef USB2

    ntStatus = USBHUB_GetBusInterface(DeviceExtensionHub->RootHubPdo,
                                      &DeviceExtensionHub->BusIf);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBHUB_GetBusInterface fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    ntStatus = USBHUB_GetBusInterfaceUSBDI(DeviceExtensionHub->TopOfStackDeviceObject,
                                           &DeviceExtensionHub->UsbdiBusIf);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBHUB_GetBusInterfaceUSBDI fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    USBH_InitializeUSB2Hub(DeviceExtensionHub);

#endif

    USBH_KdPrint((2,"'Hub Count is %d\n", hubCount));
    //
    // allow no more than five physical hubs plus the root
    // (7.1.16)
    //
#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_HUB_COUNT) {
        hubCount = 7;
    }
#endif
    if (hubCount > 6) {

        USBH_WriteFailReason(
            DeviceExtensionHub->PhysicalDeviceObject,
            USBH_FAILREASON_MAXHUBS_CONNECTED);

        USBH_KdPrint((1,"'StartDevice: hubs are stacked too deep (%x)\n", hubCount - 1));

        hubParentDeviceExtensionPort = DeviceExtensionHub->PhysicalDeviceObject->DeviceExtension;
        portData = &hubParentDeviceExtensionPort->DeviceExtensionHub->PortData[hubParentDeviceExtensionPort->PortNumber-1];

        portData->ConnectionStatus = DeviceHubNestedTooDeeply;
// Don't clear the hub's reference to this PDO because we will just try to
// create a new one when QDR is called and we see that there is still a device
// connected to the port.
//        portData->DeviceObject = NULL;

        // generate a WMI event so UI can inform the user
        USBH_PdoEvent(hubParentDeviceExtensionPort->DeviceExtensionHub,
                      hubParentDeviceExtensionPort->PortNumber);

        // We fail the hub here but don't return an error so that the device
        // is not removed and the UI can display an error message about it.

        HUB_FAILURE(DeviceExtensionHub);
    }

    // Initialize DeviceCapabilities structure in case USBH_QueryCapabilities
    // is unsuccessful.

    RtlZeroMemory(&deviceCapabilities, sizeof(DEVICE_CAPABILITIES));

    USBH_QueryCapabilities(DeviceExtensionHub->TopOfStackDeviceObject,
                           &deviceCapabilities);
    //
    // save the system state mapping
    //

    for (i = 0 ; i< PowerSystemMaximum ; i++) {
        DeviceExtensionHub->DeviceState[i] = PowerDeviceD3;
    }

    RtlCopyMemory(&DeviceExtensionHub->DeviceState[0],
                  &deviceCapabilities.DeviceState[0],
                  sizeof(deviceCapabilities.DeviceState));

    DeviceExtensionHub->SystemWake = deviceCapabilities.SystemWake;
    DeviceExtensionHub->DeviceWake = deviceCapabilities.DeviceWake;

#if DBG
    USBH_KdPrint((1,"'>>>>>> Hub DeviceCaps\n"));
    USBH_KdPrint((1,"'SystemWake = (%d)\n", DeviceExtensionHub->SystemWake));
    USBH_KdPrint((1,"'DeviceWake = (D%d)\n",
        DeviceExtensionHub->DeviceWake-1));

    for (i=PowerSystemUnspecified; i< PowerSystemHibernate; i++) {

        USBH_KdPrint((1,"'Device State Map: sysstate %d = devstate 0x%x\n", i,
             DeviceExtensionHub->DeviceState[i]));
    }
    USBH_KdBreak(("'>>>>>> Hub DeviceCaps\n"));

    // Spit out message on the debugger indicating whether the Root Hub
    // will support wake, according to the mapping table.

    if (IS_ROOT_HUB(DeviceExtensionHub)) {

        USBH_KdPrint((1,"'\n\tWake support summary for USB Root Hub:\n\n"));

        if (DeviceExtensionHub->SystemWake <= PowerSystemWorking) {
            USBH_KdPrint((1,"'USB Root Hub can't wake machine because SystemWake does not support it.\n"));
        } else {
            for (i = PowerSystemSleeping1, bWakeSupported = FALSE; i <= DeviceExtensionHub->SystemWake; i++) {
                if (DeviceExtensionHub->DeviceState[i] != PowerDeviceUnspecified &&
                    DeviceExtensionHub->DeviceState[i] <= DeviceExtensionHub->DeviceWake) {

                    bWakeSupported = TRUE;
                    USBH_KdPrint((1,"'USB Root Hub can wake machine from S%x (maps to D%x).\n",
                        i - 1, DeviceExtensionHub->DeviceState[i] - 1));
                }
            }

            if (!bWakeSupported) {
                USBH_KdPrint((1,"'USB Root Hub can't wake machine because DeviceState table does not support it.\n"));
            }
        }
    }
#endif

    //
    // get our device descriptor
    //
    ntStatus = USBH_GetDeviceDescriptor(DeviceExtensionHub->FunctionalDeviceObject,
                                        &DeviceExtensionHub->DeviceDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_GetHubDeviceDescriptor fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    ntStatus = USBH_GetConfigurationDescriptor(DeviceExtensionHub->FunctionalDeviceObject,
                                               &DeviceExtensionHub->ConfigurationDescriptor);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("Hub StartDevice USBH_GetConfigurationDescriptor fail code %x\n",
                       ntStatus));
        goto USBH_StartDeviceDone;
    }

    //
    // Get Hub specific descriptor.
    //
    // port data array allocated by this function
    //

    ntStatus = USBH_SyncGetHubDescriptor(DeviceExtensionHub);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_GetHubDescriptor fail code %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    if (USBH_HubIsBusPowered(DeviceExtensionHub->FunctionalDeviceObject,
                             DeviceExtensionHub->ConfigurationDescriptor)) {

        // we have 500 mA to work with
        DeviceExtensionHub->MaximumPowerPerPort = 100;

        //
        // The amount of current a bus powered hub will draw (mA)
        // should be calculated as follows:
        //
        // NumberOfExternalPorts * 100 + HubCntrolCurrent +
        // power required for embeded functions
        //
        // this value cannot exceed 500 ma, the hub config
        // descriptor should report this value but in most cases
        // does not so we set it to the worst case value to insure
        // that a bus powered hub cannot be connected to another
        // bus powered hub.

        UsbhInfo(DeviceExtensionHub);

        DeviceExtensionHub->ConfigurationDescriptor->MaxPower = 250;

    } else {
        // self powered hub can supply 500 mA per port
        DeviceExtensionHub->MaximumPowerPerPort = 500;

        UsbhInfo(DeviceExtensionHub);
    }

    USBH_KdPrint((2,"'per port power for hub = %d\n", DeviceExtensionHub->MaximumPowerPerPort));

    //
    // attempt to configure the device
    //

    ntStatus = USBH_OpenConfiguration(DeviceExtensionHub);

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_OpenConfiguration fail code %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    // if this is a usb 2 hub

    if (DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) {
        ntStatus = USBD_InitUsb2Hub(DeviceExtensionHub);
    }

    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice failed USB 2.0 init %x\n", ntStatus));
        goto USBH_StartDeviceDone;
    }

    //
    // Allocate a permanent Irp for this hub
    //

    DeviceExtensionHub->Irp =
        IoAllocateIrp(DeviceExtensionHub->FunctionalDeviceObject->StackSize, FALSE);

    USBH_KdPrint((2,"'StartDevice AllocateIrp Irp %x StackSize %d\n",
                   DeviceExtensionHub->Irp, DeviceExtensionHub->FunctionalDeviceObject->StackSize));

    if (NULL == DeviceExtensionHub->Irp) {
        USBH_KdBreak(("StartDevice failed to alloc Irp\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_StartDeviceDone;
    }

    //
    // Allocate a transfer buffer which together with the permanent Irp and
    // Urb
    // for the hub will be use to do InterruptTransfer.
    //

    DeviceExtensionHub->TransferBufferLength =
        DeviceExtensionHub->PipeInformation.MaximumPacketSize;

    DeviceExtensionHub->TransferBuffer = UsbhExAllocatePool(NonPagedPool,
                 DeviceExtensionHub->TransferBufferLength);

    if (NULL == DeviceExtensionHub->TransferBuffer) {
        USBH_KdBreak(("StartDevice fail alloc TransferBuffer\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_StartDeviceDone;
    }

    USBH_KdPrint((2,"'StartDevice TransferBuffer %x size %x\n",
                  DeviceExtensionHub->TransferBuffer,
                  DeviceExtensionHub->PipeInformation.MaximumPacketSize));

    //
    // Power on all down stream ports.
    // Be it ganged powered, individual powered or none switched
    //

    ntStatus = USBH_SyncPowerOnPorts(DeviceExtensionHub);

#if DBG
    if (!NT_SUCCESS(ntStatus)) {
        USBH_KdBreak(("StartDevice USBH_SyncPowerOnPorts fail code %x\n", ntStatus));
    }
#endif

#if DBG
    if (UsbhPnpTest & PNP_TEST_FAIL_HUB) {
        ntStatus = STATUS_UNSUCCESSFUL;
    }
#endif


USBH_StartDeviceDone:

    if (NT_SUCCESS(ntStatus)) {
        //
        // So we are started.
        //

        DeviceExtensionHub->HubFlags |= HUBFLAG_NEED_CLEANUP;

        //
        // first clear any status changes the hub may be asserting
        //

        for (p=1; p<= DeviceExtensionHub->HubDescriptor->bNumberOfPorts; p++) {
            USBH_SyncClearPortStatus(DeviceExtensionHub,
                                     (USHORT)p,
                                     FEATURE_C_PORT_CONNECT);
        }

        //
        // Tell the OS that this PDO can have kids.
        //
//
// Workaround for PnP bug #406381 - RC3SS: Bluescreen failure when
//                                  installing/deinstalling communication ports
//
//===== Assigned by santoshj on 09/23/99 10:27:20 to kenray =====
// This is a race condition between IopInitializeSystemDrivers and
// IoInvalidateDeviceRelations. The real fix is too big a change at this
// stage of the product and has potential of exposing other problems. This
// problem can be solved if USBHUB does not invalidate device relations on
// every start which is redundant anyway (and also exposes this bug).
//
//        USBH_IoInvalidateDeviceRelations(DeviceExtensionHub->PhysicalDeviceObject,
//                                         BusRelations);

        //
        // Start polling the hub
        //
#ifdef NEW_START
        // establish callback to start the hub

        if (IS_ROOT_HUB(DeviceExtensionHub)) {
            USBD_RegisterRhHubCallBack(DeviceExtensionHub);
        } else {
            DeviceExtensionHub->HubFlags |= HUBFLAG_OK_TO_ENUMERATE;
            USBH_SubmitInterruptTransfer(DeviceExtensionHub);
        }

#else 
        USBH_SubmitInterruptTransfer(DeviceExtensionHub);
#endif

    } else {

        //
        // clean up allocated structures
        //

        USBH_KdBreak(("USBH_FdoStartDevice_Error\n"));
        LOGENTRY(LOG_PNP, "STR!", DeviceExtensionHub, 0, 0);

        if (DeviceExtensionHub->HubDescriptor) {
            UsbhExFreePool(DeviceExtensionHub->HubDescriptor);
            DeviceExtensionHub->HubDescriptor = NULL;
        }
        if (DeviceExtensionHub->Irp) {
            IoFreeIrp(DeviceExtensionHub->Irp);
            DeviceExtensionHub->Irp = NULL;
        }
        if (DeviceExtensionHub->TransferBuffer) {
            UsbhExFreePool(DeviceExtensionHub->TransferBuffer);
            DeviceExtensionHub->TransferBuffer = NULL;
        }
        if (DeviceExtensionHub->ConfigurationDescriptor) {
            UsbhExFreePool(DeviceExtensionHub->ConfigurationDescriptor);
            DeviceExtensionHub->ConfigurationDescriptor = NULL;
        }

    }

    //
    // complete the start Irp now since we pended it with
    // our completion handler.
    //

    LOGENTRY(LOG_PNP, "STRc", DeviceExtensionHub, 0, ntStatus);
    USBH_CompleteIrp(Irp, ntStatus);

    return ntStatus;
}


VOID
UsbhFdoCleanup(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This routine is called to shut down the hub.
  *
  * All we do here is abort or pending interrupt transfer and wait for it to
  * complete and fre up memeory resources
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a a hub device extension.
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    PPORT_DATA portData;
    USHORT p, numberOfPorts;
    KIRQL irql;
    PIRP wWIrp = NULL;
    PIRP hubIdleIrp = NULL;
    PIRP idleIrp = NULL;
    PIRP waitWakeIrp = NULL;
    PVOID deviceData;
    NTSTATUS status, ntStatus;
    BOOLEAN bRet;

    // Can't acquire (cancel) spin locks in paged code!
    // TODO:  isolate the pieces of code that require the spin lock into helper
    // functions
    // PAGED_CODE();
    USBH_KdPrint((2,"'UsbhFdoCleanup Fdo extension %x\n", DeviceExtensionHub));

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;

    USBD_UnRegisterRhHubCallBack(DeviceExtensionHub);

    //
    // set our stop flag so that ChangeIndication does not submit
    // any more transfers or queue more workitems, important to do
    // this before we send the abort.
    //

    DeviceExtensionHub->HubFlags |= HUBFLAG_DEVICE_STOPPING;


    // If there is a ChangeIndicationWorkitem pending, then we
    // must wait for that to complete.

    if (DeviceExtensionHub->ChangeIndicationWorkitemPending) {

        USBH_KdPrint((2,"'Wait for single object\n"));

        ntStatus = KeWaitForSingleObject(&DeviceExtensionHub->CWKEvent,
                                         Suspended,
                                         KernelMode,
                                         FALSE,
                                         NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", ntStatus));
    }

    LOGENTRY(LOG_PNP, "fdoX", DeviceExtensionHub, deviceObject,
        DeviceExtensionHub->HubFlags);

    //
    // dump our wake request
    //
    IoAcquireCancelSpinLock(&irql);

    if (DeviceExtensionHub->PendingWakeIrp) {
        LOGENTRY(LOG_PNP, "CwkI", DeviceExtensionHub, 0,
            DeviceExtensionHub->PendingWakeIrp);
        USBH_ASSERT(DeviceExtensionHub->HubFlags & HUBFLAG_PENDING_WAKE_IRP);

        wWIrp = DeviceExtensionHub->PendingWakeIrp;
        DeviceExtensionHub->PendingWakeIrp = NULL;
    }

    if (DeviceExtensionHub->PendingIdleIrp) {
        hubIdleIrp = DeviceExtensionHub->PendingIdleIrp;
        DeviceExtensionHub->PendingIdleIrp = NULL;
    }

    IoReleaseCancelSpinLock(irql);

    if (wWIrp) {
        USBH_HubCancelWakeIrp(DeviceExtensionHub, wWIrp);
    }

    USBH_HubCompletePortWakeIrps(DeviceExtensionHub, STATUS_DELETE_PENDING);

    if (hubIdleIrp) {
        USBH_HubCancelIdleIrp(DeviceExtensionHub, hubIdleIrp);
    }

    //
    // wait for all work items to finish...
    //  the event is not signaled if a work item is pending
    //
    // this code takes care of work items that may have been queued
    // before the ShutDown flag was set.
    // note: no additional work items will be queued once the
    // HUBFLAG_DEVICE_STOPPING flag is set.
    //

    if (InterlockedDecrement(&DeviceExtensionHub->PendingRequestCount) > 0) {
        //
        // need to wait
        //

        LOGENTRY(LOG_PNP, "hWAT", DeviceExtensionHub,
            &DeviceExtensionHub->PendingRequestEvent,
            DeviceExtensionHub->PendingRequestCount);

        status = KeWaitForSingleObject(
                       &DeviceExtensionHub->PendingRequestEvent,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
    }

    USBH_KdPrint((2,"'Work Items Finished %x\n", DeviceExtensionHub));

    USBH_ASSERT(DeviceExtensionHub->PendingRequestCount == 0);

    //
    // now cancel any outstanding transfers
    //

    if (DeviceExtensionHub->Irp) {

        status = USBH_AbortInterruptPipe(DeviceExtensionHub);

        // If the ABORT_PIPE request failed then we should cancel
        // the Interrupt IRP before freeing it, otherwise we are likely
        // freeing the IRP while it is still in use.

        if (!NT_SUCCESS(status)) {
            bRet = IoCancelIrp(DeviceExtensionHub->Irp);

            // Only wait on the abort event if the IRP was actually
            // cancelled.

            if (bRet) {
            LOGENTRY(LOG_PNP, "aWAT", DeviceExtensionHub,
                    &DeviceExtensionHub->AbortEvent,  0);

            status = KeWaitForSingleObject(
                       &DeviceExtensionHub->AbortEvent,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);
            }
        }

        IoFreeIrp(DeviceExtensionHub->Irp);
        DeviceExtensionHub->Irp = NULL;
    }

    USBH_KdPrint((2,"'Abort Finished %x\n", DeviceExtensionHub));

    //
    // disable the ports in case we are re-started
    //
    USBH_ASSERT(DeviceExtensionHub->HubDescriptor != NULL);
    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
    portData = DeviceExtensionHub->PortData;

    if (portData) {
        for (p = 1;
             p <= numberOfPorts;
             p++, portData++) {

            PDEVICE_EXTENSION_PORT deviceExtensionPort;

            //
            // do this after we abort are interrupt pipe,
            // it doesn't matter if it fails.
            //

            LOGENTRY(LOG_PNP, "offP", DeviceExtensionHub,
                p,  portData->DeviceObject);

            //
            // check our PDOs -- if this is a remove then we should have
            // none -- otherwise this is a stop.
            //

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;

                //
                // it is possible that the PDO was never actually started
                // if this is the case then the PDO won't be marked for reset
                // we mark it here and free up the associated bus resources

                IoAcquireCancelSpinLock(&irql);

                if (deviceExtensionPort->IdleNotificationIrp) {
                    idleIrp = deviceExtensionPort->IdleNotificationIrp;
                    deviceExtensionPort->IdleNotificationIrp = NULL;
                    deviceExtensionPort->PortPdoFlags &= ~PORTPDO_IDLE_NOTIFIED;

                    if (idleIrp->Cancel) {
                        idleIrp = NULL;
                    }

                    if (idleIrp) {
                        IoSetCancelRoutine(idleIrp, NULL);
                    }
                }

                if (deviceExtensionPort->WaitWakeIrp) {

                    waitWakeIrp = deviceExtensionPort->WaitWakeIrp;
                    deviceExtensionPort->WaitWakeIrp = NULL;
                    deviceExtensionPort->PortPdoFlags &=
                        ~PORTPDO_REMOTE_WAKEUP_ENABLED;

                    if (waitWakeIrp->Cancel || IoSetCancelRoutine(waitWakeIrp, NULL) == NULL) {
                        waitWakeIrp = NULL;

                        // Must decrement pending request count here because
                        // we don't complete the IRP below and USBH_WaitWakeCancel
                        // won't either because we have cleared the IRP pointer
                        // in the device extension above.

                        USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);
                    }

                    UsbhWarning(deviceExtensionPort,
                    "Device Driver did not cancel wait_wake irp on stop/remove\n",
                    FALSE);
                }

                //
                // Finally, release the cancel spin lock
                //
                IoReleaseCancelSpinLock(irql);

                if (idleIrp) {
                    idleIrp->IoStatus.Status = STATUS_CANCELLED;
                    IoCompleteRequest(idleIrp, IO_NO_INCREMENT);
                }

                if (waitWakeIrp) {
                    USBH_CompletePowerIrp(DeviceExtensionHub, waitWakeIrp,
                        STATUS_CANCELLED);
                }

                if (!(deviceExtensionPort->PortPdoFlags & PORTPDO_NEED_RESET)) {
                    USBH_KdPrint((1,
                        "'do %x was never started, marking for reset\n",
                            portData->DeviceObject));

                    deviceData = InterlockedExchangePointer(
                                    &deviceExtensionPort->DeviceData,
                                    NULL);

                    if (deviceData) {
#ifdef USB2
                       USBD_RemoveDeviceEx(DeviceExtensionHub,
                                           deviceData,
                                           deviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                           0);
#else
                       USBD_RemoveDevice(deviceData,
                                         deviceExtensionPort->DeviceExtensionHub->RootHubPdo,
                                         0);
#endif
                    }

                    deviceExtensionPort->PortPdoFlags |= PORTPDO_NEED_RESET;
                }
            }

            USBH_SyncDisablePort(DeviceExtensionHub, p);
        }
    }

    //
    // Clean up buffers
    //

    if (DeviceExtensionHub->TransferBuffer) {
        UsbhExFreePool(DeviceExtensionHub->TransferBuffer);
    }

    if (DeviceExtensionHub->HubDescriptor) {
        UsbhExFreePool(DeviceExtensionHub->HubDescriptor);
    }

    if (DeviceExtensionHub->ConfigurationDescriptor) {
        UsbhExFreePool(DeviceExtensionHub->ConfigurationDescriptor);
    }

    //
    // NOTE: we do not free the per port data (PortData) because
    // we will need it if we start up agian
    //

    DeviceExtensionHub->TransferBuffer = NULL;
    DeviceExtensionHub->Irp = NULL;
    DeviceExtensionHub->ConfigurationDescriptor =
        (PVOID) DeviceExtensionHub->HubDescriptor = NULL;

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_NEED_CLEANUP;

    return;
}


NTSTATUS
USBH_FdoStopDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_STOP_DEVICE).
  *
  * Argument:
  *
  * DeviceExtensionHub -
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    NTSTATUS ntStatus;

    PAGED_CODE();
    USBH_KdPrint((2,"'FdoStopDevice Fdo extension %x\n", DeviceExtensionHub));

    LOGENTRY(LOG_PNP, "hSTP", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);

    // walk thru our list of PDOs and verify that stop was passed down
    // for each one
    {
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData = DeviceExtensionHub->PortData;

    // NOTE:
    // if we get a stop as a result of an error during stop
    // then we may not have allocated portdata or a HubDescriptor

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            LOGENTRY(LOG_PNP, "chkS", DeviceExtensionHub,
                nextPortNumber,  portData->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                //
                // port is still started, print a warning
                //
                LOGENTRY(LOG_PNP, "chk1", DeviceExtensionHub,
                    nextPortNumber,  deviceExtensionPort->PortPdoFlags);

                if (deviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) {
                    USBH_KdPrint((1,
                        "'client driver failed to pass the stop IRP\n"));

                    // remove it now
                    USBH_PdoStopDevice(deviceExtensionPort, Irp);
                }
            }
        }
    }
    }


    if (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) {
        (VOID) UsbhFdoCleanup(DeviceExtensionHub);
    }

    //
    // note that some hub structures are free at this point
    //

    if (DeviceExtensionHub->Configuration) {
        (VOID) USBH_CloseConfiguration((PDEVICE_EXTENSION_FDO) DeviceExtensionHub);
        DeviceExtensionHub->Configuration = NULL;
    }

    // note that we are stopped
    DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_STOPPED;

    //
    // And we need to pass this message on to lower level driver
    //
    ntStatus = USBH_PassIrp(Irp,
                            DeviceExtensionHub->TopOfStackDeviceObject);

    return ntStatus;
}


VOID
USBH_FdoSurpriseRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * Handle surprise remove.  If we get a surprise remove then PnP will know 
  * that all of our children are gone (same as a QBR) and remove them before 
  * removing us.
  * Therefore we mark the devices as no longer present so that we process the 
  * remove properly when we get if for the PDO
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a hub device extension. pIrp - the request
  *
  * Return:
  *
  * This call is non-falable, no status is returned
  * -- */
{
    PPORT_DATA pd;
    USHORT portNumber;
    USHORT numberOfPorts;
    
    pd = DeviceExtensionHub->PortData;

    if (pd &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (portNumber = 1;
             portNumber <= numberOfPorts;
             portNumber++, pd++) {

            LOGENTRY(LOG_PNP, "chsX", DeviceExtensionHub,
                portNumber,  pd->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", pd, pd->DeviceObject));

            if (pd->DeviceObject != NULL) {
                LOGENTRY(LOG_PNP, "chs", DeviceExtensionHub,
                    portNumber,  PDO_EXT(pd->DeviceObject));

                // we no longer track this device, it is gone
                //
                PDO_EXT(pd->DeviceObject)->PortPdoFlags |= PORTPDO_DELETE_PENDING;
                PDO_EXT(pd->DeviceObject)->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;

                pd->DeviceObject = NULL;
                pd->ConnectionStatus = NoDeviceConnected;

                // note that we leave the device handle in the port extension
                // this will be removed when the remove_device meassage is 
                // processed for the PDO
            }
        }
    } else {
        // I would like to  know the circumstances where 
        // either of these are NULL
        TEST_TRAP();
    }

}



NTSTATUS
USBH_FdoRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This routine is called by PnP via (IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE).
  *
  * Argument:
  *
  * DeviceExtensionHub - This is a hub device extension. pIrp - the request
  *
  * Return:
  *
  * STATUS_SUCCESS
  *
  * -- */
{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    PAGED_CODE();
    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'FdoRemoveDevice Fdo %x\n", deviceObject));
    LOGENTRY(LOG_PNP, "hREM", DeviceExtensionHub, DeviceExtensionHub->HubFlags, 0);

    // walk thru our list of PDOs and verify that remove was passed down
    // for each one
    {
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;

    portData = DeviceExtensionHub->PortData;

    //
    // hub descriptor will be null if the hub is already stopped
    //

    if (portData &&
        DeviceExtensionHub->HubDescriptor) {

        numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

        for (nextPortNumber = 1;
             nextPortNumber <= numberOfPorts;
             nextPortNumber++, portData++) {

            LOGENTRY(LOG_PNP, "chkX", DeviceExtensionHub,
                nextPortNumber,  portData->DeviceObject);

            USBH_KdPrint((2,"'portdata %x, do %x\n", portData, portData->DeviceObject));

            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                //
                // port is still started, print a warning
                //
                LOGENTRY(LOG_PNP, "chk2", DeviceExtensionHub,
                    nextPortNumber,  deviceExtensionPort->PortPdoFlags);

                portData->DeviceObject = NULL;
                portData->ConnectionStatus = NoDeviceConnected;

// We removed this trap because this is normal in the case where the hub is
// being removed due to hub failure and one of the downstream devices still
// had open references to it (open files on a USB storage device).  In this
// case, PnP will not send the remove to the device until such references
// have been closed.
//
//                if (deviceExtensionPort->PortPdoFlags & PORTPDO_STARTED) {
//                    USBH_KdPrint((1,
//                        "'client driver failed to pass the remove IRP\n"));
//                    USBH_KdTrap(("client driver bug\n"));
//
//                }

                // remove the PDO
                USBH_PdoRemoveDevice(deviceExtensionPort, 
                                     DeviceExtensionHub,
                                     Irp);
            }
        }
    }
    }

    //
    // see if we need cleanup
    //
    if (DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP) {
        UsbhFdoCleanup(DeviceExtensionHub);
    }

    //
    // free the per port data now
    //
    if (DeviceExtensionHub->PortData) {
        UsbhExFreePool(DeviceExtensionHub->PortData);
        DeviceExtensionHub->PortData = NULL;
    }


#ifdef WMI_SUPPORT
    // de-register with WMI
    IoWMIRegistrationControl(deviceObject,
                             WMIREG_ACTION_DEREGISTER);

#endif

    //
    // And we need to pass this message on to lower level driver
    //

    ntStatus = USBH_PassIrp(Irp, DeviceExtensionHub->TopOfStackDeviceObject);

    //
    // Detach FDO from PDO
    //
    IoDetachDevice(DeviceExtensionHub->TopOfStackDeviceObject);

    // delete FDO
    LOGENTRY(LOG_PNP, "hXXX", DeviceExtensionHub, 0, 0);

    IoDeleteDevice(deviceObject);

    return ntStatus;
}


BOOLEAN
USBH_DeviceIs2xDualMode(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    )
 /* ++
  *
  * Description:
  *
  * This function determines if the device is a 2.x compliant dual-mode device.
  *
  * Arguments:
  *
  * DeviceExtensionPort
  *
  * Return:
  *
  * BOOLEAN indicating whether the given device is a 2.x compliant dual-mode
  * device or not.
  *
  * -- */
{
    USB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor;
    NTSTATUS ntStatus;
    BOOLEAN bDeviceIs2xDualMode = FALSE;

    if (DeviceExtensionPort->DeviceDescriptor.bcdUSB >= 0x0200) {

        ntStatus = USBH_GetDeviceQualifierDescriptor(
                        DeviceExtensionPort->PortPhysicalDeviceObject,
                        &DeviceQualifierDescriptor);

        if (NT_SUCCESS(ntStatus) &&
            DeviceQualifierDescriptor.bcdUSB >= 0x0200) {

            bDeviceIs2xDualMode = TRUE;
        }
    }

    return bDeviceIs2xDualMode;
}


PDEVICE_EXTENSION_HUB
USBH_GetRootHubDevExt(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
 /* ++
  *
  * Description:
  *
  * This function gets the DevExt for the RootHub upstream of the given
  * DeviceExtensionHub
  *
  * Arguments:
  *
  * DeviceExtensionHub
  *
  * Return:
  *
  * DeviceExtensionHub for the RootHub FDO.
  *
  * -- */
{
    PDEVICE_OBJECT rootHubPdo, rootHubFdo;
    PDEVICE_EXTENSION_HUB rootHubDevExt;
    PDRIVER_OBJECT hubDriver;

    hubDriver = DeviceExtensionHub->FunctionalDeviceObject->DriverObject;
    
    if (IS_ROOT_HUB(DeviceExtensionHub)) {
        rootHubDevExt = DeviceExtensionHub;
    } else {
        rootHubPdo = DeviceExtensionHub->RootHubPdo;
        do {
            rootHubFdo = rootHubPdo->AttachedDevice;
            rootHubPdo = rootHubFdo;
        } while (rootHubFdo->DriverObject != hubDriver);
 
        rootHubDevExt = rootHubFdo->DeviceExtension;
    }

    USBH_ASSERT(rootHubDevExt &&
                rootHubDevExt->ExtensionType == EXTENSION_TYPE_HUB);

    return rootHubDevExt;
}


NTSTATUS
USBH_FdoQueryBusRelations(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    )
 /* ++
  *
  * Description:
  *
  * This function responds to Bus_Reference_Next_Device, Bus_Query_Bus_Check,
  * //Bus_Query_Id: Bus_Id, HardwareIDs, CompatibleIDs and InstanceID.
  *
  * Arguments:
  *
  * DeviceExtensionHub - should be the FDO we created for ourselves pIrp - the
  * Irp
  *
  * Return:
  *
  * NtStatus
  *
  * -- */
{
    PIO_STACK_LOCATION ioStack;
    PPORT_DATA portData;
    USHORT nextPortNumber;
    USHORT numberOfPorts;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    //BOOLEAN IsLowSpeed;
    USHORT portStatus;
    PDEVICE_RELATIONS deviceRelations = NULL;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_EXTENSION_PORT deviceExtensionPort;
    PWCHAR sernumbuf;
#ifdef EARLY_RESOURCE_RELEASE
    PVOID deviceData;
#endif

    PAGED_CODE();

    USBH_KdPrint((1, "'Query Bus Relations (HUB) %x\n",
        DeviceExtensionHub->PhysicalDeviceObject));
    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //
    ioStack = IoGetCurrentIrpStackLocation(Irp);

    USBH_KdPrint((2,"'FdoQueryBusRelations %x\n", ioStack->Parameters.QueryDeviceRelations.Type));
    LOGENTRY(LOG_PNP, "QBR+", DeviceExtensionHub, 0, 0);

    USBH_ASSERT(ioStack->Parameters.QueryDeviceRelations.Type == BusRelations);

    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_NEED_CLEANUP)) {

        // Hub device has not been started yet.  Fail the IRP.

        UsbhWarning(NULL,
                   "Hub device not started in FdoQueryBusRelations\n",
                    FALSE);

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto USBH_FdoQueryBusRelations_Done2;
    }

    if (!DeviceExtensionHub->HubDescriptor) {
        // Sometimes HubDescriptor is NULL when running Test's
        // "Rebalance" test.

        UsbhWarning(NULL,
                   "NULL HubDescriptor in FdoQueryBusRelations\n",
                    FALSE);

        ntStatus = STATUS_UNSUCCESSFUL;
        goto USBH_FdoQueryBusRelations_Done2;
    }

    USBH_KdPrint((2,"'FdoQueryBusRelations enumerate device\n"));
#ifdef NEW_START
    if (!(DeviceExtensionHub->HubFlags & HUBFLAG_OK_TO_ENUMERATE)) {

        USBH_KdPrint((1,"'Defer enumeration\n"));        
        

        ntStatus = STATUS_SUCCESS;
        goto USBH_FdoQueryBusRelations_Done2;
    }
#endif

    //
    // It should be Function device object.
    //

    USBH_ASSERT(EXTENSION_TYPE_HUB == DeviceExtensionHub->ExtensionType);

    // Sometimes during rebalance we will receive a QBR for a hub while one
    // of the devices attached to hub is being restored.  This will cause us to
    // toss the PDO for that port because GetPortStatus for that port will show
    // that there is no device connected.  So, we synchronize with ResetDevice
    // here.

    USBH_KdPrint((2,"'***WAIT reset device mutex %x\n", DeviceExtensionHub));
    USBH_INC_PENDING_IO_COUNT(DeviceExtensionHub);
    KeWaitForSingleObject(&DeviceExtensionHub->ResetDeviceMutex,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);
    USBH_KdPrint((2,"'***WAIT reset device mutex done %x\n", DeviceExtensionHub));

    numberOfPorts = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;

    //
    // Must use ExAllocatePool directly here because the OS
    // will free the buffer
    //
    deviceRelations = ExAllocatePoolWithTag(
        PagedPool, sizeof(*deviceRelations) + (numberOfPorts - 1) *
        sizeof(PDEVICE_OBJECT), USBHUB_HEAP_TAG);

    if (deviceRelations == NULL) {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto USBH_FdoQueryBusRelations_Done;
    }

USBH_FdoQueryBusRelations_Start:

    deviceRelations->Count = 0;

    if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_HAS_LOST_BRAINS) {

        // If we are trying to recover from ESD failure, then just tell PnP
        // that there are no devices.

        USBH_KdPrint((1,"'FdoQueryBusRelations: ESD recovery, returning no devices\n"));

        ntStatus = STATUS_SUCCESS;
        goto USBH_FdoQueryBusRelations_Done;
    }

    // Allow selective suspend once again if we were suppressing it waiting
    // for post-ESD enumeration to occur.

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_POST_ESD_ENUM_PENDING;

    //
    // This is the first call for enumeration
    //
    //
    // Find a ready device on our ports
    //

    portData = DeviceExtensionHub->PortData;
    for (nextPortNumber = 1;
         nextPortNumber <= numberOfPorts;
         nextPortNumber++, portData++) {

        //
        // This query is redundant since we go here due to a change
        // indication from the hub, however since we check all
        // ports it will allow us to process another change may occur after
        // the first one but before we get to this routine.

        DBG_ONLY(USBH_ShowPortState( nextPortNumber,
                                     &portData->PortState));

        //
        // don't bother to query the hub if it has failed
        //
        if (!(DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE)) {
            ntStatus = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                              nextPortNumber,
                                              (PUCHAR) &portData->PortState,
                                              sizeof(portData->PortState));

            LOGENTRY(LOG_PNP, "nwPS", nextPortNumber,
                portData->PortState.PortStatus,
                portData->PortState.PortChange);

            if (NT_SUCCESS(ntStatus)) {
                //
                // mark the port status as connected if we show
                // overcurrent on this port, this will prevent us
                // from tossing the PDO.
                // Since the port is powered off we can't really
                // know if anything is connected.
                //

                if (portData->DeviceObject) {

                    deviceExtensionPort =
                        portData->DeviceObject->DeviceExtension;

                    if (deviceExtensionPort->PortPdoFlags &
                         PORTPDO_OVERCURRENT) {

                        LOGENTRY(LOG_PNP, "mOVR", deviceExtensionPort, 0, 0);
                        portData->PortState.PortStatus |= PORT_STATUS_CONNECT;
                    } else if (!(deviceExtensionPort->PortPdoFlags &
                                 PORTPDO_DELETE_PENDING)) {
//                      We now handle resetting ConnectionStatus in
//                      USBH_ResetPortOvercurrent.
//                        portData->ConnectionStatus = DeviceConnected;
                        USBH_ASSERT(portData->ConnectionStatus != NoDeviceConnected);
                    }
                }
            } else {
                //
                // NOTE (Doron Holan, 12/21/00):
                // Setting the failure bit here will mean that ntStatus will not
                // be touched again until the loop has exited and this function
                // will complete this request with an error.
                //
                // Perhaps it would be more clear if we broke out of the loop
                // here instead of starting over.
                //
                USBH_KdPrint((2,"'SyncGetPortStatus failed %x\n", ntStatus));
                HUB_FAILURE(DeviceExtensionHub);

                goto USBH_FdoQueryBusRelations_Start;
            }

            DBG_ONLY(USBH_ShowPortState( nextPortNumber,
                                         &portData->PortState));
        }

        //
        // do we have a device on this port?
        //
        if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {
            // if the hub has failed just return what we know about
            deviceObject = portData->DeviceObject;
        } else if (portData->PortState.PortStatus & PORT_STATUS_CONNECT) {
            // Yes,
            // did we already know about this device?

            //
            // check to see if the pdo is an orphan, if so toss the PDO
            //

            deviceObject = portData->DeviceObject;

            if (portData->DeviceObject) {
                // Yes,
                // return the old PDO
                deviceObject = portData->DeviceObject;
                ObReferenceObject(deviceObject);
                deviceObject->Flags |= DO_POWER_PAGABLE;
                deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                deviceRelations->Count++;

                deviceExtensionPort = deviceObject->DeviceExtension;
                deviceExtensionPort->PortPdoFlags &= ~PORTPDO_USB_SUSPEND;

                LOGENTRY(LOG_PNP, "PDO1", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);

                USBH_KdPrint((2,"'DoBusExtension Enum Return old device on port %x PDO=%x\n", \
                              nextPortNumber, portData->DeviceObject));

            } else {
                NTSTATUS status;
                // No
                // This means we have a new device on the bus

                //
                // wait 100ms  for port device power to stablize before
                // we assert Reset.
                //
                UsbhWait(100);

                // USB 1.1 make sure we get speed of device after reset
                status = USBH_SyncResetPort(DeviceExtensionHub, nextPortNumber);

                // failure of reset is normal on USB 2.0 so we must ignore it.
                if ((DeviceExtensionHub->HubFlags & HUBFLAG_USB20_HUB) &&
                    !NT_SUCCESS(status)) {

                    portData->DeviceObject = NULL;
                    portData->ConnectionStatus = NoDeviceConnected;

                    continue;
                }

                if (NT_SUCCESS(status)) {
                    // get the speed of the device

                    status = USBH_SyncGetPortStatus(DeviceExtensionHub,
                                                    nextPortNumber,
                                                    (PUCHAR) &portData->PortState,
                                                     sizeof(portData->PortState));

                    LOGENTRY(LOG_PNP, "gps1", nextPortNumber,
                        portData->PortState.PortChange,
                        portData->PortState.PortStatus);

//                    createDevice now figures out if it is low speed
//                    IsLowSpeed = (portData->PortState.PortStatus &
//                                   PORT_STATUS_LOW_SPEED) ? TRUE : FALSE;

                    portStatus = portData->PortState.PortStatus;
                }


                if (NT_SUCCESS(status)) {

                    ULONG count = 0;

                    // reset completed
                    //
                    // A successful return has the PortData->DeviceObject set
                    //

                    //
                    // we will make three attempts to enumerate this device
                    //
                    for(;;) {

                        status = USBH_CreateDevice(DeviceExtensionHub,
                                                   nextPortNumber,
                                                   portStatus,
                                                   count);

                        if (!NT_SUCCESS(status)) {

                            count++;
                            USBH_KdPrint((1,"'Enumeration Failed count = %d, %x\n",
                                count, status));
#if DBG
                            if (count == 1) {
                                UsbhWarning(NULL,
                                            "USB device failed first enumeration attempt\n",
                                            (BOOLEAN)((USBH_Debug_Trace_Level >= 3) ? TRUE : FALSE));
                                            
                            }
#endif
                            UsbhWait(500);

                            if (count >= USBH_MAX_ENUMERATION_ATTEMPTS) {
                                USBH_KdBreak(("Max tries exceeded\n"));
                                break;
                            }

                            if (portData->DeviceObject) {
                                //
                                // clean up the device object we created
                                //
                                IoDeleteDevice(portData->DeviceObject);
                                portData->DeviceObject = NULL;
                                portData->ConnectionStatus = NoDeviceConnected;

                            }

                            //
                            // enumeration failed, reset the port and try again
                            //
                            USBH_SyncResetPort(DeviceExtensionHub, nextPortNumber);

                        } else {
                            // enumeration success

                            // If this is a high-speed capable 2.x device
                            // connected to a legacy 1.x hub, then inform
                            // the UI.

                            if (portData->DeviceObject) {

                                deviceExtensionPort =
                                    portData->DeviceObject->DeviceExtension;

                                if (!(deviceExtensionPort->PortPdoFlags &
                                     PORTPDO_LOW_SPEED_DEVICE) &&
                                    !(deviceExtensionPort->PortPdoFlags &
                                     PORTPDO_HIGH_SPEED_DEVICE) &&
                                    !(DeviceExtensionHub->HubFlags &
                                      HUBFLAG_USB20_HUB)) {

                                    // We have a device in full-speed mode
                                    // connected to a 1.x hub.  Determine if
                                    // the device is high-speed capable.

                                    if (USBH_DeviceIs2xDualMode(deviceExtensionPort)) {

                                        deviceExtensionPort->PortPdoFlags |=
                                            PORTPDO_USB20_DEVICE_IN_LEGACY_HUB;

                                        USBH_KdPrint((1,"'USB 2.x dual-mode device connected to legacy hub (%x)\n", deviceExtensionPort));

                                        // Generate a WMI event so UI can inform
                                        // the user.
                                        USBH_PdoEvent(DeviceExtensionHub,
                                                      nextPortNumber);
                                    }
                                }
                            }
                            break;
                        }
                    }
                } else {
                    // unable to reset the port

#if DBG
                    USBH_SyncGetPortStatus(DeviceExtensionHub,
                                           nextPortNumber,
                                           (PUCHAR) &portData->PortState,
                                           sizeof(portData->PortState));

                    LOGENTRY(LOG_PNP, "gps2", nextPortNumber,
                        portData->PortState.PortChange,
                        portData->PortState.PortStatus);
#endif

                    // we will assume this is due to a jittery
                    // connection
                    USBH_KdPrint((0,"'Unable to reset port %d\n",
                              nextPortNumber));
                }

                if (NT_SUCCESS(status)) {
                    //
                    // A successful return from CreateDevice the
                    // PortData->DeviceObject
                    // set.
                    //
                    USBH_ASSERT(portData->DeviceObject != NULL);
                    deviceObject = portData->DeviceObject;
                    ObReferenceObject(deviceObject);
                    deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                    deviceObject->Flags |= DO_POWER_PAGABLE;
                    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                    deviceRelations->Count++;

                    deviceExtensionPort = deviceObject->DeviceExtension;
                    portData->ConnectionStatus = DeviceConnected;

                    LOGENTRY(LOG_PNP, "PDO2", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);

                    USBH_KdPrint((2,"'DoBusExtension Enum Return device on port %x\n",
                        nextPortNumber));
                } else {
                    USBH_KdBreak(("ResetPort or CreateDevice failed, disable port\n"));

                    UsbhWarning(NULL,
                                "Device Failed Enumeration\n",
                                FALSE);

                    portData->ConnectionStatus = DeviceFailedEnumeration;

                    // generate a WMI event so UI can inform the user
                    USBH_PdoEvent(DeviceExtensionHub, nextPortNumber);

                    // failed to initialize the device
                    // disable the port here.
                    status = USBH_SyncDisablePort(DeviceExtensionHub,
                                nextPortNumber);

                    if (NT_ERROR(status)) {
                        HUB_FAILURE(DeviceExtensionHub);
                    }

                    //
                    // return the deviceObject even for errors
                    // so that PnP knows there is something on the
                    // bus.
                    //

                    deviceObject = portData->DeviceObject;
                    //
                    // NOTE: we won't have a device object if we failed to reset
                    // the port
                    //
                    if (deviceObject) {
                        ObReferenceObject(deviceObject);
                        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
                        deviceRelations->Objects[deviceRelations->Count] = deviceObject;
                        deviceRelations->Count++;
                        deviceExtensionPort = deviceObject->DeviceExtension;


                        LOGENTRY(LOG_PNP, "PDO3", DeviceExtensionHub, deviceObject
                        , deviceRelations->Count);
                    }
                }
            }
        } else {
            //
            // No,
            // There is no device on this port now
            //

            // if there was a device here mark the PDO as delete pending
            if (portData->DeviceObject) {
                deviceExtensionPort = portData->DeviceObject->DeviceExtension;
                deviceExtensionPort->PortPdoFlags |= PORTPDO_DELETE_PENDING;

                // pnp will no longer see this device as present
                deviceExtensionPort->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;

                // Prevent double free of SerialNumberBuffer in
                // USBH_ProcessPortStateChange.

                sernumbuf = InterlockedExchangePointer(
                                &deviceExtensionPort->SerialNumberBuffer,
                                NULL);

                if (sernumbuf) {
                    UsbhExFreePool(sernumbuf);
                }

#ifdef EARLY_RESOURCE_RELEASE

                //
                // Remove the device data now to free
                // up the bus resources.
                //

                deviceData = InterlockedExchangePointer(
                                &deviceExtensionPort->DeviceData,
                                NULL);

                if (deviceData) {
#ifdef USB2
                    USBD_RemoveDeviceEx(DeviceExtensionHub,
                                        deviceData,
                                        DeviceExtensionHub->RootHubPdo,
                                        0);
#else
                    USBD_RemoveDevice(deviceData,
                                      DeviceExtensionHub->RootHubPdo,
                                      0);
#endif

                    USBH_SyncDisablePort(DeviceExtensionHub,
                                         nextPortNumber);
                }

#endif // EARLY_RESOURCE_RELEASE

            }

            // indicate no device
            portData->DeviceObject = NULL;
            portData->ConnectionStatus = NoDeviceConnected;
        }
    }                           /* for */

USBH_FdoQueryBusRelations_Done:
    LOGENTRY(LOG_PNP, "QBR-", DeviceExtensionHub, 0, 0);

    USBH_KdPrint((2,"'***RELEASE reset device mutex %x\n", DeviceExtensionHub));
    KeReleaseSemaphore(&DeviceExtensionHub->ResetDeviceMutex,
                       LOW_REALTIME_PRIORITY,
                       1,
                       FALSE);
    USBH_DEC_PENDING_IO_COUNT(DeviceExtensionHub);

USBH_FdoQueryBusRelations_Done2:

    Irp->IoStatus.Status = ntStatus;

    if (NT_SUCCESS(ntStatus)) {
        USHORT p, n=0, c=0;
        PPORT_DATA pd;

        // we may return NULL relations on success
        if (deviceRelations != NULL) {
            
            USBH_KdPrint((1, "'Query Bus Relations (HUB) %x passed on\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            // we have crafted device relations, set the PnP flags
            // to indicate that PnP now knows about these PDOs
            if (DeviceExtensionHub->HubDescriptor) {
                n = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
            } 
            
            pd = DeviceExtensionHub->PortData;
            for (p = 1;
                 pd && p <= n;
                 p++, pd++) {

                if (pd->DeviceObject) {
                     PDO_EXT(pd->DeviceObject)->PnPFlags |= PDO_PNPFLAG_DEVICE_PRESENT;
                     c++;
                }                 
            }

            // we should be reporting all PDOs
            USBH_ASSERT(c == deviceRelations->Count);
        } else { 
            // retrning NULL relations, any PDO previously reported will 
            // be lost -- PnP will consider them removed
            USBH_KdPrint((1, "'Query Bus Relations (HUB) %x passed on (NULL)\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            pd = DeviceExtensionHub->PortData;
            for (p = 1;
                 pd && p <= n;
                 p++, pd++) {

                if (pd->DeviceObject) {
                    TEST_TRAP();
                    PDO_EXT(pd->DeviceObject)->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;
                }                 
            }
        }
        
        Irp->IoStatus.Information=(ULONG_PTR) deviceRelations;

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
    } else {
        // returning error and no relations
        
        USHORT p, n=0;
        PPORT_DATA pd;
        DEVICE_EXTENSION_PORT portDevExt;    

        // we are reporting that everything is gone 
        // mark the PDOs as gone now.

        if (DeviceExtensionHub->HubDescriptor) {
            n = DeviceExtensionHub->HubDescriptor->bNumberOfPorts;
        } 
        
        pd = DeviceExtensionHub->PortData;
        for (p = 1;
             pd && p <= n;
             p++, pd++) {

            if (pd->DeviceObject) {
                 PDO_EXT(pd->DeviceObject)->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;
            }                 
        }
    
        Irp->IoStatus.Information=0;

        if (deviceRelations != NULL) {
            ExFreePool(deviceRelations);
            deviceRelations = NULL;
        }

        USBH_CompleteIrp(Irp, ntStatus);
    }

    // now flush the deleted pdo list, these are the PDOs that PNP now
    // knows are gone
    {
        PDEVICE_EXTENSION_PORT dePort;
        PLIST_ENTRY listEntry;

        while (!IsListEmpty(&DeviceExtensionHub->DeletePdoList)) {
            listEntry = RemoveHeadList(&DeviceExtensionHub->DeletePdoList);
            dePort = CONTAINING_RECORD(listEntry, DEVICE_EXTENSION_PORT, 
                            DeletePdoLink);
            dePort->PnPFlags &= ~PDO_PNPFLAG_DEVICE_PRESENT;
        }
    }
    
    return ntStatus;
}


NTSTATUS
USBH_FdoPnP(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN UCHAR MinorFunction)
 /* ++
  *
  * Description:
  *
  * This function responds to IoControl PnPPower for the FDO. This function is
  * synchronous.
  *
  * Arguments:
  *
  * DeviceExtensionHub - the FDO extension pIrp - the request packet
  * MinorFunction - the minor function of the PnP Power request.
  *
  * Return:
  *
  * NTSTATUS
  *
  * -- */
{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
    PIO_STACK_LOCATION irpStack;
    BOOLEAN bDoCheckHubIdle = FALSE;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceObject = DeviceExtensionHub->FunctionalDeviceObject;
    USBH_KdPrint((2,"'PnP Power Fdo %x minor %x\n", deviceObject, MinorFunction));

    // If this hub is currently Selective Suspended, then we need to
    // power up the hub first before sending any PnP requests along to it.
    // Make sure hub has been started, though.
    // Actually, in the case where a hub has been started, stopped, and now
    // restarted, we want to power up the parent hub to handle the restart.

    if (DeviceExtensionHub->CurrentPowerState != PowerDeviceD0 &&
        (DeviceExtensionHub->HubFlags &
         (HUBFLAG_NEED_CLEANUP | HUBFLAG_HUB_STOPPED))) {

        bDoCheckHubIdle = TRUE;
        USBH_HubSetD0(DeviceExtensionHub);
    }

    switch (MinorFunction) {
    case IRP_MN_START_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_START_DEVICE Fdo %x\n", deviceObject));
        bDoCheckHubIdle = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoStartDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_STOP_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_STOP_DEVICE Fdo %x", deviceObject));
        bDoCheckHubIdle = FALSE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoStopDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_REMOVE_DEVICE:
        USBH_KdPrint((2,"'IRP_MN_REMOVE_DEVICE Fdo %x\n", deviceObject));
        bDoCheckHubIdle = FALSE;
        DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_GONE;
        Irp->IoStatus.Status = STATUS_SUCCESS;
        ntStatus = USBH_FdoRemoveDevice(DeviceExtensionHub, Irp);
        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:
        switch (irpStack->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:

            bDoCheckHubIdle = TRUE;
            ASSERT(!( DeviceExtensionHub->HubFlags & HUBFLAG_HUB_BUSY));
            DeviceExtensionHub->HubFlags |= HUBFLAG_HUB_BUSY;
            ntStatus = USBH_FdoQueryBusRelations(DeviceExtensionHub, Irp);
            DeviceExtensionHub->HubFlags &= ~HUBFLAG_HUB_BUSY;

            break;

        case TargetDeviceRelation:
            //
            // this one gets passed on
            //
            USBH_KdPrint((1, "'Query Relations, TargetDeviceRelation(HUB) %x\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionHub->TopOfStackDeviceObject);
            break;

        default:

            USBH_KdPrint((1, "'Query Relations ? (HUB) %x complete\n",
                DeviceExtensionHub->PhysicalDeviceObject));

            ntStatus = USBH_PassIrp(Irp,
                                    DeviceExtensionHub->TopOfStackDeviceObject);

        }
        break;

     case IRP_MN_QUERY_CAPABILITIES:
        USBH_KdPrint((2,"'IRP_MN_QUERY_CAPABILITIES on fdo %x  %x\n",
                      deviceObject, MinorFunction));

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp,    // Irp
                           USBH_QueryCapsComplete,
                           DeviceExtensionHub, // context
                           TRUE,    // invoke on success
                           FALSE,    // invoke on error
                           FALSE);   // invoke on cancel
        ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject, Irp);
        break;

        //
        // or pass the Irp down
        //

    case IRP_MN_QUERY_PNP_DEVICE_STATE:
        if (DeviceExtensionHub->HubFlags & HUBFLAG_HUB_FAILURE) {
            USBH_KdPrint((2,"'reporting failed hub\n"));
            Irp->IoStatus.Information
                |= PNP_DEVICE_FAILED;
            LOGENTRY(LOG_PNP, "pnpS", DeviceExtensionHub,
                Irp->IoStatus.Information, 0);
            // note that (at least on memphis) this will result in
            // a stop message being sent to the device.
        }
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;

    case IRP_MN_SURPRISE_REMOVAL:      
        USBH_KdPrint((1,"'IRP_MN_SURPRISE_REMOVAL on fdo %x\n", deviceObject));
        USBH_FdoSurpriseRemoveDevice(DeviceExtensionHub,
                                     Irp);
        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;

    case IRP_MN_QUERY_STOP_DEVICE:
    case IRP_MN_CANCEL_STOP_DEVICE:
    case IRP_MN_QUERY_REMOVE_DEVICE:
    case IRP_MN_CANCEL_REMOVE_DEVICE:
    case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        Irp->IoStatus.Status = STATUS_SUCCESS;

        // Fall through

    default:
        USBH_KdPrint((2,"'PnP request on fdo %x  %x\n",
                      deviceObject, MinorFunction));

        ntStatus = USBH_PassIrp(Irp,
                                DeviceExtensionHub->TopOfStackDeviceObject);
        break;
    }

    if (bDoCheckHubIdle) {
        USBH_CheckHubIdle(DeviceExtensionHub);
    }

    DeviceExtensionHub->HubFlags &= ~HUBFLAG_CHILD_DELETES_PENDING;

    USBH_KdPrint((2,"'FdoPnP exit %x\n", ntStatus));
    return ntStatus;
}


NTSTATUS
USBH_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT event = Context;


    KeSetEvent(event,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
USBH_ResetInterruptPipe(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;

    USBH_KdPrint((2,"'Reset Pipe\n"));

    urb = UsbhExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle =
            DeviceExtensionHub->PipeInformation.PipeHandle;

        ntStatus = USBH_FdoSyncSubmitUrb(DeviceExtensionHub->FunctionalDeviceObject,
                                         urb);

        UsbhExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // if the reset pipe request is successful,
    // reset our error counter
    //
    if (NT_SUCCESS(ntStatus)) {
        DeviceExtensionHub->ErrorCount = 0;
        LOGENTRY(LOG_PNP, "rZER", DeviceExtensionHub, ntStatus, 0);
    }

    LOGENTRY(LOG_PNP, "rPIP", DeviceExtensionHub, ntStatus,
                DeviceExtensionHub->ErrorCount);

    return ntStatus;
}


NTSTATUS
USBH_GetPortStatus(
    IN IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PULONG PortStatus
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    USBH_KdPrint((2,"'enter USBH_GetPortStatus\n"));

    *PortStatus = 0;

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    USBH_ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    USBH_KdPrint((2,"'calling USBD port status api\n"));

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2, "'Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    USBH_KdPrint((2,"'Port status = %x\n", *PortStatus));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBH_KdPrint((2,"'USBH_GetPortStatus (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_EnableParentPort(
    IN IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceExtension - pointer to the device extension for this instance of an USB camera

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;

    USBH_KdPrint((2,"'enter USBH_EnablePort\n"));

    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_ENABLE_PORT,
                DeviceExtensionHub->TopOfStackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    USBH_KdPrint((2,"'calling USBD enable port api\n"));

    ntStatus = IoCallDriver(DeviceExtensionHub->TopOfStackDeviceObject,
                            irp);

    USBH_KdPrint((2,"'return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {

        USBH_KdPrint((2, "'Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBH_KdPrint((2,"'Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    LOGENTRY(LOG_PNP, "hEPP", DeviceExtensionHub, ntStatus,  0);
    USBH_KdPrint((2,"'USBH_EnablePort (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBH_ResetHub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    ULONG portStatus;

    //
    // Check the port state, if it is disabled we will need
    // to re-enable it
    //
    ntStatus = USBH_GetPortStatus(DeviceExtensionHub, &portStatus);

    if (NT_SUCCESS(ntStatus) &&
        !(portStatus & USBD_PORT_ENABLED) &&
        (portStatus & USBD_PORT_CONNECTED)) {
        //
        // port is disabled, attempt reset
        //
        LOGENTRY(LOG_PNP, "rEPP", DeviceExtensionHub, portStatus,
            DeviceExtensionHub->ErrorCount);
        USBH_EnableParentPort(DeviceExtensionHub);
    }

    //
    // now attempt to reset the stalled pipe, this will clear the stall
    // on the device as well.
    //

    if (NT_SUCCESS(ntStatus)) {
        ntStatus = USBH_ResetInterruptPipe(DeviceExtensionHub);
    }

    //
    // send the feature command to clear endpoint stall
    //

    return ntStatus;
}

#if 0
NTSTATUS
USBH_WriteRegistryKeyString (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN PVOID Data,
    IN ULONG DataLength
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING keyName;

    PAGED_CODE();


    RtlInitUnicodeString(&keyName, KeyNameString);

    ntStatus = ZwSetValueKey(Handle,
                    &keyName,
                    0,
                    REG_SZ,
                    Data,
                    DataLength);

    return ntStatus;
}
#endif

NTSTATUS
USBH_WriteRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN ULONG Data
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    UNICODE_STRING keyName;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, KeyNameString);

    ntStatus = ZwSetValueKey(Handle,
                    &keyName,
                    0,
                    REG_DWORD,
                    &Data,
                    sizeof(ULONG));

    return ntStatus;
}


NTSTATUS
USBH_WriteFailReason(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG FailReason
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    WCHAR USBH_FailReasonKey[] = L"FailReasonID";

    PAGED_CODE();
    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {

        USBH_WriteRegistryKeyValue(handle,
                                    USBH_FailReasonKey,
                                    sizeof(USBH_FailReasonKey),
                                    FailReason);

        ZwClose(handle);
    }

    return ntStatus;
}


#if 0 // NOT USED
NTSTATUS
USBH_WriteFailReasonString(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR FailReasonString,
    IN ULONG FailReasonStringLength
    )
/*++

Routine Description:

    Reset The ubs interrupt pipe.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    WCHAR USBH_FailReasonKey[] = L"FailReasonString";

    PAGED_CODE();
    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     PLUGPLAY_REGKEY_DEVICE,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);

    if (NT_SUCCESS(ntStatus)) {

        USBH_WriteRegistryKeyString(handle,
                                    USBH_FailReasonKey,
                                    sizeof(USBH_FailReasonKey),
                                    FailReasonString,
                                    FailReasonStringLength);

        ZwClose(handle);
    }

    return ntStatus;
}
#endif


NTSTATUS
USBH_InvalidatePortDeviceState(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USB_CONNECTION_STATUS ConnectStatus,
    IN USHORT PortNumber
    )
/*++

Routine Description:

    This function updates the connection status for a
    port. It inavlidates the PDO if there is one, writes
    a failreason to the registry and triggers a WMI event.

    Invalidating the PDO should trigger a Q_PNP_DEVICE_STATE

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    ULONG failReason = 0;
    PPORT_DATA portData;

    USBH_ASSERT(DeviceExtensionHub != NULL);

    portData = &DeviceExtensionHub->PortData[PortNumber-1];
    portData->ConnectionStatus = ConnectStatus;

    //
    // figure out if we have a failreason we can write
    // to the registry
    //

    switch(ConnectStatus) {
    case DeviceConnected:
        // this will reset the failreasonId
        break;

    case DeviceFailedEnumeration:
        failReason = USBH_FAILREASON_ENUM_FAILED;
        break;

    case DeviceGeneralFailure:
        failReason = USBH_FAILREASON_GEN_DEVICE_FAILURE;
        break;

    case DeviceCausedOvercurrent:
        failReason = USBH_FAILREASON_PORT_OVERCURRENT;
        break;

    case DeviceNotEnoughPower:
        failReason = USBH_FAILREASON_NOT_ENOUGH_POWER;
        break;

    default:
        TEST_TRAP();
    }

    if (failReason) {
        // this writes a code to the registry so that win98 devman
        // can display an error message

        if (portData->DeviceObject) {
            USBH_WriteFailReason(portData->DeviceObject,
                                 failReason);
        }
    }

    // generate a WMI event so UI can inform the user
    USBH_PdoEvent(DeviceExtensionHub, PortNumber);

    //
    // Invalidate the state of the PDO -- this should
    // trigger a Q_PNP_DEVICE_STATE
    //

    if (portData->DeviceObject) {
        IoInvalidateDeviceState(portData->DeviceObject);
    }

    return ntStatus;
}


PDEVICE_EXTENSION_PORT
PdoExt(
    PDEVICE_OBJECT DeviceObject
    )
{
    USBH_ASSERT(DeviceObject);

    if (DeviceObject == NULL) {
        return (PDEVICE_EXTENSION_PORT) -1;
    } else {
        return (PDEVICE_EXTENSION_PORT) DeviceObject->DeviceExtension;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\ioctl.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    IOCTL.H

Abstract:

    Header file for I82930 driver

Environment:

    kernel and user mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

// {0B677572-2B5B-46c7-B1F3-D140A341888C}
DEFINE_GUID(GUID_CLASS_I82930, 
0xb677572, 0x2b5b, 0x46c7, 0xb1, 0xf3, 0xd1, 0x40, 0xa3, 0x41, 0x88, 0x8c);


#define I82930_IOCTL_INDEX  0x0000

#define IOCTL_I82930_GET_DEVICE_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+0,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_GET_CONFIG_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+1,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_SET_CONFIG_DESCRIPTOR \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+2,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_GET_PIPE_INFORMATION \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+3,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_RESET_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+4,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_STALL_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+5,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_ABORT_PIPE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+6,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_RESET_DEVICE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+7,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)

#define IOCTL_I82930_SELECT_ALTERNATE_INTERFACE \
    CTL_CODE(FILE_DEVICE_UNKNOWN,  \
             I82930_IOCTL_INDEX+8,\
             METHOD_BUFFERED,  \
             FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\hub.pnp\usbhub.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usbhub.h

Abstract:

    This header define structures and macros for USB Hub driver.

Author:

    JohnLee

Environment:

    Kernel mode

Revision History:

    2-2-96 : created
    11-18-96 : jdunn -- added composite device support

--*/

#include <wdmwarn4.h>

#include <usb.h>        // usbdi.h has been replaced by usb.h
#include <usbdlib.h>
#include <msosdesc.h>   // contains internal definitions for MS OS Desc.

#ifdef USB2
#include "hubbusif.h"    // hub service bus interface
#include "usbbusif.h"    // usb client service bus interface
#else
#include <hcdi.h>
#include <usbdlibi.h>
#endif
#include <usbioctl.h>
#include <wmidata.h>

#include <enumlog.h>

//enable pageable code
#ifndef PAGE_CODE
#define PAGE_CODE
#endif

#define MULTI_FUNCTION_SUPPORT
#define EARLY_RESOURCE_RELEASE
#define RESUME_PERF

#define USBH_MAX_FUNCTION_INTERFACES 4


#define BcdNibbleToAscii( byte ) (byte)+ '0'


//
// fail reason codes
//

// "Device Failed Enumeration"
// indicates the device failed some part of the enumeration process
// when this happens we cannot tell enough about the device to load
// the appropriate driver.
#define USBH_FAILREASON_ENUM_FAILED             1
// "Device General Failure"
// this is our 'if it does not fit any other catagory' error
#define USBH_FAILREASON_GEN_DEVICE_FAILURE      2
// "Device Caused Overcurrent"
// if a hub supports per port power switching and the device
// causes an overcurrent condition (over-current is like blowing
// a fuse) the we report this error.
#define USBH_FAILREASON_PORT_OVERCURRENT        3
// "Not Enough Power"
// indicates that the device requested a configuration that requires
// more power than the hub can provide.
#define USBH_FAILREASON_NOT_ENOUGH_POWER        4
// "Hub General failure"
// if the hub starts failing transfer requests the driver will
// disable it and report this error.
#define USBH_FAILREASON_HUB_GENERAL_FAILURE     5
// "Cannot connect more than five hubs"
#define USBH_FAILREASON_MAXHUBS_CONNECTED       6
// "An overcurrent condition has disabled the hub"
// if a device generates overcurrent and the hub implements
// gang power switching the entire hub will be disabled and
// this error reported.
#define USBH_FAILREASON_HUB_OVERCURRENT         7

//
//  Struc definitions
//

//
// Work item
//
#define USBH_WKFLAG_REQUEST_RESET       0x00000001

typedef struct _USBH_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    ULONG Flags;
    PVOID Context;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    KDPC Dpc;
    KTIMER Timer;
    UCHAR Data[0];
} USBH_WORK_ITEM, *PUSBH_WORK_ITEM;

typedef struct _USBH_RESET_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    PIRP Irp;
} USBH_RESET_WORK_ITEM, *PUSBH_RESET_WORK_ITEM;

typedef struct _USBH_COMP_RESET_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
} USBH_COMP_RESET_WORK_ITEM, *PUSBH_COMP_RESET_WORK_ITEM;

typedef struct _USBH_BANDWIDTH_TIMEOUT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
} USBH_BANDWIDTH_TIMEOUT_WORK_ITEM, *PUSBH_BANDWIDTH_TIMEOUT_WORK_ITEM;

typedef struct _USBH_COMP_RESET_TIMEOUT_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
} USBH_COMP_RESET_TIMEOUT_WORK_ITEM, *PUSBH_COMP_RESET_TIMEOUT_WORK_ITEM;

typedef struct _USBH_SET_POWER_D0_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    PIRP Irp;
} USBH_SET_POWER_D0_WORK_ITEM, *PUSBH_SET_POWER_D0_WORK_ITEM;

typedef struct _USBH_HUB_ESD_RECOVERY_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
} USBH_HUB_ESD_RECOVERY_WORK_ITEM, *PUSBH_HUB_ESD_RECOVERY_WORK_ITEM;

typedef struct _USBH_HUB_IDLE_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    NTSTATUS ntStatus;
} USBH_HUB_IDLE_POWER_WORK_ITEM, *PUSBH_HUB_IDLE_POWER_WORK_ITEM;

typedef struct _USBH_PORT_IDLE_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    PIRP Irp;
} USBH_PORT_IDLE_POWER_WORK_ITEM, *PUSBH_PORT_IDLE_POWER_WORK_ITEM;

typedef struct _USBH_COMPLETE_PORT_IRPS_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
    LIST_ENTRY IrpsToComplete;
    NTSTATUS ntStatus;
} USBH_COMPLETE_PORT_IRPS_WORK_ITEM, *PUSBH_COMPLETE_PORT_IRPS_WORK_ITEM;

typedef struct _USBH_HUB_ASYNC_POWER_WORK_ITEM {
    WORK_QUEUE_ITEM WorkQueueItem;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    PIRP Irp;
    UCHAR MinorFunction;
} USBH_HUB_ASYNC_POWER_WORK_ITEM, *PUSBH_HUB_ASYNC_POWER_WORK_ITEM;

typedef struct _HUB_TIMEOUT_CONTEXT {
    PIRP Irp;
    KEVENT Event;
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    KSPIN_LOCK TimeoutSpin;
    BOOLEAN Complete;
} HUB_TIMEOUT_CONTEXT, *PHUB_TIMEOUT_CONTEXT;

typedef struct _PORT_TIMEOUT_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_PORT *DeviceExtensionPort;
    BOOLEAN CancelFlag;
} PORT_TIMEOUT_CONTEXT, *PPORT_TIMEOUT_CONTEXT;

typedef struct _COMP_RESET_TIMEOUT_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_PARENT *DeviceExtensionParent;
    BOOLEAN CancelFlag;
} COMP_RESET_TIMEOUT_CONTEXT, *PCOMP_RESET_TIMEOUT_CONTEXT;

typedef struct _HUB_ESD_RECOVERY_CONTEXT {
    KDPC TimeoutDpc;
    KTIMER TimeoutTimer;
    struct _DEVICE_EXTENSION_HUB *DeviceExtensionHub;
} HUB_ESD_RECOVERY_CONTEXT, *PHUB_ESD_RECOVERY_CONTEXT;

typedef struct _USB_DEVICE_UI_FIRMWARE_REVISION
{
    USHORT Length;
    WCHAR FirmwareRevisionString[1];

} USB_DEVICE_UI_FIRMWARE_REVISION, *PUSB_DEVICE_UI_FIRMWARE_REVISION;

typedef struct _HUB_STATE {
    USHORT HubStatus;
    USHORT HubChange;
} HUB_STATE, *PHUB_STATE;

typedef struct _PORT_STATE {
    USHORT PortStatus;
    USHORT PortChange;
} PORT_STATE, *PPORT_STATE;

//
// Hub and Port status defined below also apply to StatusChnage bits
//
#define HUB_STATUS_LOCAL_POWER      0x01
#define HUB_STATUS_OVER_CURRENT     0x02

#define PORT_STATUS_CONNECT         0x001
#define PORT_STATUS_ENABLE          0x002
#define PORT_STATUS_SUSPEND         0x004
#define PORT_STATUS_OVER_CURRENT    0x008
#define PORT_STATUS_RESET           0x010
#define PORT_STATUS_POWER           0x100
#define PORT_STATUS_LOW_SPEED       0x200
#define PORT_STATUS_HIGH_SPEED      0x400

//
// Port data to describe relevant info about a port
//

// values for PortFlags
// #define PORTFLAG_ 0x00000001


typedef struct _PORT_DATA {
    PORT_STATE              PortState;          // the status & change bit mask of the port
    PDEVICE_OBJECT          DeviceObject;       // the PDO
    USB_CONNECTION_STATUS   ConnectionStatus;
    // extended port attributes as defined in USB.H
    ULONG                   PortAttributes;
    // revised port data structure
    ULONG                   PortFlags;
} PORT_DATA, *PPORT_DATA;

//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//
#define FILE_DEVICE_USB_HUB  0x00008600

#define USBH_MAX_ENUMERATION_ATTEMPTS   3

//
// Common fields for Pdo and Fdo extensions
//
#define EXTENSION_TYPE_PORT 0x54524f50      // "PORT"
#define EXTENSION_TYPE_HUB  0x20425548      // "HUB "
#define EXTENSION_TYPE_PARENT  0x50525400   // "PRT "
#define EXTENSION_TYPE_FUNCTION  0xfefefeff   // ""

typedef struct _USBH_POWER_WORKER {
    PIRP Irp;
    WORK_QUEUE_ITEM WorkQueueItem;
} USBH_POWER_WORKER, *PUSBH_POWER_WORKER;

typedef struct _DEVICE_EXTENSION_HEADER {
    ULONG ExtensionType;
} DEVICE_EXTENSION_HEADER, *PDEVICE_EXTENSION_HEADER;


typedef struct _DEVICE_EXTENSION_COMMON {
    PDEVICE_OBJECT  FunctionalDeviceObject; // points back to owner device object
    PDEVICE_OBJECT  PhysicalDeviceObject;   // the PDO for this device
    PDEVICE_OBJECT  TopOfStackDeviceObject; // to of stack passed to adddevice
} DEVICE_EXTENSION_COMMON, *PDEVICE_EXTENSION_COMMON;

// common to FDO for hub and generic parent
typedef struct _DEVICE_EXTENSION_FDO {
    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;
    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

} DEVICE_EXTENSION_FDO, *PDEVICE_EXTENSION_FDO;


//
// Device_Extension for HUB
//
typedef struct _DEVICE_EXTENSION_HUB {
    //
    // *** NOTE the first four fields must match
    // DEVICE_EXTENSION_FDO
    //

    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;
    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

    //
    // Pdo created by HCD for the root hub
    //
    PDEVICE_OBJECT          RootHubPdo;
    //
    // top of the host controller stack
    // typically this is the FDO for the HCD
    //
    PDEVICE_OBJECT          TopOfHcdStackDeviceObject;

    ULONG                   HubFlags;

    //
    // we use the hub mutex to serialize access to the
    // hub ports between ioctls and pnp events
    //

    ULONG                   PendingRequestCount;
    ULONG                   ErrorCount;
    HUB_STATE               HubState;
    PIRP                    Irp;

    PIRP                    PendingWakeIrp;
    LONG                    NumberPortWakeIrps;
    PUCHAR                  TransferBuffer;
    ULONG                   TransferBufferLength;
    PKEVENT                 Event;

    PUSB_HUB_DESCRIPTOR     HubDescriptor;
    PPORT_DATA              PortData;
    USBD_CONFIGURATION_HANDLE Configuration;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;

    DEVICE_POWER_STATE      DeviceState[PowerSystemMaximum];
    SYSTEM_POWER_STATE      SystemWake;
    DEVICE_POWER_STATE      DeviceWake;
    DEVICE_POWER_STATE      CurrentPowerState;
    LONG                    MaximumPowerPerPort;
    PORT_STATE              PortStateBuffer;

    LONG                    ResetPortNumber;
    PUSBH_WORK_ITEM         WorkItemToQueue;

    KEVENT                  AbortEvent;
    KEVENT                  PendingRequestEvent;

    //
    // we use the hub mutex to serialize access to the
    // hub ports between ioctls and pnp events
    //

    KSEMAPHORE              HubMutex;
    KSEMAPHORE              HubPortResetMutex;
    KSEMAPHORE              ResetDeviceMutex;

    USB_DEVICE_DESCRIPTOR   DeviceDescriptor;
    USBD_PIPE_INFORMATION   PipeInformation;
    URB                     Urb;

    LONG                    InESDRecovery;

#ifdef USB2
    USB_BUS_INTERFACE_HUB_V5 BusIf;
    USB_BUS_INTERFACE_USBDI_V2 UsbdiBusIf;
#endif

    PIRP                    PendingIdleIrp;
    USB_IDLE_CALLBACK_INFO  IdleCallbackInfo;
    KEVENT                  SubmitIdleEvent;

    LONG                    ChangeIndicationWorkitemPending;

    LONG                    WaitWakeIrpCancelFlag;
    LONG                    IdleIrpCancelFlag;

    KEVENT                  CWKEvent;

    // Only used for the Root Hub!
    SYSTEM_POWER_STATE      CurrentSystemPowerState;

    KSPIN_LOCK              CheckIdleSpinLock;

    // revised extension

    // deleted Pdo list, we use this list to handle 
    // async deletion of PDOs.  Basically these are 
    // PDO we have not reported gone to PnP yet.
    LIST_ENTRY              DeletePdoList;


} DEVICE_EXTENSION_HUB, *PDEVICE_EXTENSION_HUB;

#define HUBFLAG_NEED_CLEANUP            0x00000001
#define HUBFLAG_ENABLED_FOR_WAKEUP      0x00000002
#define HUBFLAG_DEVICE_STOPPING         0x00000004
#define HUBFLAG_HUB_FAILURE             0x00000008
#define HUBFLAG_SUPPORT_WAKEUP          0x00000010
#define HUBFLAG_HUB_STOPPED             0x00000020
#define HUBFLAG_HUB_BUSY                0x00000040
#define HUBFLAG_PENDING_WAKE_IRP        0x00000080
#define HUBFLAG_PENDING_PORT_RESET      0x00000100
#define HUBFLAG_HUB_HAS_LOST_BRAINS     0x00000200
#define HUBFLAG_SET_D0_PENDING          0x00000400
#define HUBFLAG_DEVICE_LOW_POWER        0x00000800
#define HUBFLAG_PENDING_IDLE_IRP        0x00001000
#define HUBFLAG_CHILD_DELETES_PENDING   0x00002000
#define HUBFLAG_HUB_GONE                0x00004000
#define HUBFLAG_USB20_HUB               0x00008000
#define HUBFLAG_NEED_IDLE_CHECK         0x00010000
#define HUBFLAG_WW_SET_D0_PENDING       0x00020000
#define HUBFLAG_USB20_MULTI_TT          0x00040000
#define HUBFLAG_POST_ESD_ENUM_PENDING   0x00080000
#define HUBFLAG_OK_TO_ENUMERATE         0x00100000
#define HUBFLAG_IN_IDLE_CHECK           0x00200000
#define HUBFLAG_HIBER                   0x00400000



typedef struct _DEVICE_EXTENSION_PARENT {
    DEVICE_EXTENSION_HEADER;
    DEVICE_EXTENSION_COMMON;

    KEVENT PnpStartEvent;
    PIRP PowerIrp;
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT  WmiLibInfo;
#endif /* WMI_SUPPORT */

    PIRP PendingWakeIrp;
    LONG NumberFunctionWakeIrps;
    ULONG FunctionCount;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;
    SINGLE_LIST_ENTRY FunctionList;
    DEVICE_POWER_STATE DeviceState[PowerSystemMaximum];
    SYSTEM_POWER_STATE SystemWake;
    DEVICE_POWER_STATE DeviceWake;
    DEVICE_POWER_STATE CurrentPowerState;
    ULONG ParentFlags;
    BOOLEAN NeedCleanup;
    UCHAR CurrentConfig;
    UCHAR Reserved[2];
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;

    PCOMP_RESET_TIMEOUT_CONTEXT CompResetTimeoutContext;
    KSEMAPHORE ParentMutex;
    KSPIN_LOCK ParentSpinLock;

} DEVICE_EXTENSION_PARENT, *PDEVICE_EXTENSION_PARENT;

typedef struct _FUNCTION_INTERFACE {
    PUSBD_INTERFACE_INFORMATION InterfaceInformation;
    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor;
    ULONG InterfaceDescriptorLength;
} FUNCTION_INTERFACE, *PFUNCTION_INTERFACE;


typedef struct _DEVICE_EXTENSION_FUNCTION {
    DEVICE_EXTENSION_HEADER;

    PDEVICE_EXTENSION_PARENT DeviceExtensionParent;
    PDEVICE_OBJECT FunctionPhysicalDeviceObject;
    PIRP WaitWakeIrp;
    PIRP ResetIrp;
    ULONG InterfaceCount;
    ULONG FunctionPdoFlags;
    SINGLE_LIST_ENTRY ListEntry;
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;
    WCHAR UniqueIdString[4]; // room for three unicode digits plus
                             // NULL
    FUNCTION_INTERFACE FunctionInterfaceList[USBH_MAX_FUNCTION_INTERFACES];
} DEVICE_EXTENSION_FUNCTION, *PDEVICE_EXTENSION_FUNCTION;

//
// Device Extension for Port
//
typedef struct _DEVICE_EXTENSION_PORT {
    DEVICE_EXTENSION_HEADER;
    PDEVICE_OBJECT                  PortPhysicalDeviceObject;
    PDEVICE_EXTENSION_HUB           DeviceExtensionHub;
    USHORT                          PortNumber;
    // port you are on on your parent hub.
    USHORT                          SerialNumberBufferLength;
    PVOID                           DeviceData;
    DEVICE_POWER_STATE              DeviceState;
    PIRP                            WaitWakeIrp;
    // these flags describe the state of the PDO and
    // the capabilities of the device connected
    ULONG                           PortPdoFlags;
    ULONG                           DeviceHackFlags;

    PWCHAR                          SerialNumberBuffer;

    WCHAR                           UniqueIdString[4];
    // room for three unicode digits plus NULL
    UNICODE_STRING                  SymbolicLinkName;
    USB_DEVICE_DESCRIPTOR           DeviceDescriptor;
    USB_DEVICE_DESCRIPTOR           OldDeviceDescriptor;
    USB_CONFIGURATION_DESCRIPTOR    ConfigDescriptor;
    USB_INTERFACE_DESCRIPTOR        InterfaceDescriptor;

    // information returned through WMI
    //
    ULONG                           FailReasonId;
    ULONG                           PowerRequested;
    ULONG                           RequestedBandwidth;
    ULONG                           EnumerationFailReason;

    PPORT_TIMEOUT_CONTEXT           PortTimeoutContext;

    UCHAR                           FeatureDescVendorCode;
    PIRP                            IdleNotificationIrp;
    KSPIN_LOCK                      PortSpinLock;

    DEVICE_CAPABILITIES             DevCaps;
    PDEVICE_EXTENSION_HUB           HubExtSave;
    
#ifdef WMI_SUPPORT
    WMILIB_CONTEXT                  WmiLibInfo;
#endif /* WMI_SUPPORT */

    // revised extension

    // Storage for MS Extended Config Descriptor Compatible IDs
    UCHAR                           CompatibleID[8];
    UCHAR                           SubCompatibleID[8];

    ULONG                           PnPFlags;

    LIST_ENTRY                      DeletePdoLink;

} DEVICE_EXTENSION_PORT, *PDEVICE_EXTENSION_PORT;


// values for PNP flags 
// #define PDO_PNPFLAG_     
#define PDO_PNPFLAG_DEVICE_PRESENT      0x00000001

typedef struct _SERIAL_NUMBER_ENTRY {
    ULONG   Vid;
    ULONG   Pid;
    PVOID   Pdo;
} SERIAL_NUMBER_ENTRY, *PSERIAL_NUMBER_ENTRY;

typedef struct _SERIAL_NUMBER_TABLE {
    ULONG                   NumEntries;
    ULONG                   MaxEntries;
    PSERIAL_NUMBER_ENTRY    Entries;
    FAST_MUTEX              Mutex;
} SERIAL_NUMBER_TABLE, * PSERIAL_NUMBER_TABLE;


//
// values for PortPdoFlags
//

#define PORTPDO_DEVICE_IS_HUB               0x00000001
#define PORTPDO_DEVICE_IS_PARENT            0x00000002
#define PORTPDO_DEVICE_ENUM_ERROR           0x00000004
#define PORTPDO_LOW_SPEED_DEVICE            0x00000008
#define PORTPDO_REMOTE_WAKEUP_SUPPORTED     0x00000010
#define PORTPDO_REMOTE_WAKEUP_ENABLED       0x00000020
#define PORTPDO_DELETED_PDO                 0x00000040
// revised
// set when the device for a PDO is removed from bus  
// (physically detached from hub)
// PnP may or may not know the device is gone.
#define PORTPDO_DELETE_PENDING              0x00000080
#define PORTPDO_NEED_RESET                  0x00000100
#define PORTPDO_STARTED                     0x00000200
#define PORTPDO_USB20_DEVICE_IN_LEGACY_HUB  0x00000400
#define PORTPDO_SYM_LINK                    0x00000800
#define PORTPDO_DEVICE_FAILED               0x00001000
#define PORTPDO_USB_SUSPEND                 0x00002000
#define PORTPDO_OVERCURRENT                 0x00004000
#define PORTPDO_DD_REMOVED                  0x00008000
#define PORTPDO_NOT_ENOUGH_POWER            0x00010000
// revised not used
//#define PORTPDO_PDO_RETURNED                0x00020000
#define PORTPDO_NO_BANDWIDTH                0x00040000
#define PORTPDO_RESET_PENDING               0x00080000
#define PORTPDO_OS_STRING_DESC_REQUESTED    0x00100000
#define PORTPDO_MS_VENDOR_CODE_VALID        0x00200000
#define PORTPDO_IDLE_NOTIFIED               0x00400000
#define PORTPDO_HIGH_SPEED_DEVICE           0x00800000
#define PORTPDO_NEED_CLEAR_REMOTE_WAKEUP    0x01000000
#define PORTPDO_WMI_REGISTERED              0x02000000
#define PORTPDO_VALID_FOR_PNP_FUNCTION      0x04000000
#define PORTPDO_CYCLED                      0x08000000

//
// NOTE: this macro will alway inavlidate the device state but
//      never change the current "fail reason"

#define HUB_FAILURE(de) \
    { \
    de->HubFlags |= HUBFLAG_HUB_FAILURE; \
    USBH_KdPrint((1, "'hub failure, VID %x PID %x line %d file %s\n", \
        de->DeviceDescriptor.idVendor, \
        de->DeviceDescriptor.idProduct, __LINE__, __FILE__)); \
    LOGENTRY(LOG_PNP, "HUB!", de, __LINE__, de->HubFlags); \
    }

//#define DEVICE_FAILURE(dep) \
//    { \
//    dep->PortPdoFlags |= PORTPDO_DEVICE_FAILED; \
//    USBH_KdPrint((1, "'device failure, VID %x PID %x line %d file %s\n", \
//        dep->DeviceDescriptor.idVendor, \
//        dep->DeviceDescriptor.idProduct,\
//        __LINE__, __FILE__)); \
//    LOGENTRY(LOG_PNP, "DEV!", dep, 0, 0); \
//    }

#define IS_ROOT_HUB(de) (de->PhysicalDeviceObject == de->RootHubPdo)

#define USBH_IoInvalidateDeviceRelations(devobj, b) \
    { \
    LOGENTRY(LOG_PNP, "HUBr", devobj, 0, 0); \
    USBH_KdPrint((1, "'IoInvalidateDeviceRelations %x\n", devobj));\
    IoInvalidateDeviceRelations(devobj, b); \
    }

//
// Length of buffer for Hub and port status are both 4
//
#define STATUS_HUB_OR_PORT_LENGTH 4

//
// Hub Characterics
//
//
// Powere switch mode
//
#define HUB_CHARS_POWER_SWITCH_MODE_MASK    0x0003
#define HUB_CHARS_POWER_SWITCH_GANGED       0x0000 //00
#define HUB_CHARS_POWER_SWITCH_INDIVIDUAL   0x0001 //01
#define HUB_CHARS_POWER_SWITCH_NONE         0x0002 //1X

#define HUB_IS_GANG_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_MODE_MASK) == HUB_CHARS_POWER_SWITCH_GANGED)

#define HUB_IS_NOT_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_NONE) ==  HUB_CHARS_POWER_SWITCH_NONE)

#define HUB_IS_PORT_POWER_SWITCHED(hc) \
    (((hc) & HUB_CHARS_POWER_SWITCH_MODE_MASK) == HUB_CHARS_POWER_SWITCH_INDIVIDUAL)


BOOLEAN
IsBitSet(
    PVOID Bitmap,
    ULONG PortNumber
    );

#define PORT_ALWAYS_POWER_SWITCHED(hd, p) \
    IsBitSet(&(hd)->bRemoveAndPowerMask[((hd)->bNumberOfPorts)/8 + 1], \
             (p))

#define PORT_DEVICE_NOT_REMOVABLE(hd, p) \
    IsBitSet(&(hd)->bRemoveAndPowerMask[0], \
             (p))

//
// Compound Device
//
#define HUB_CHARS_COMPOUND_DEVICE           0x4

//
// Over Current Protection Mode
//
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_MASK          0x18
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_GLOBAL        0x0
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_INDIVIDUAL    0x8
#define HUB_CHARS_OVERCURRENT_PROTECTION_MODE_NONE          0x10


//
// Request codes, defined in Ch11
//
#define REQUEST_GET_STATUS          0
#define REQUEST_CLEAR_FEATURE       1
#define REQUEST_GET_STATE           2
#define REQUEST_SET_FEATURE         3
#define REQUEST_SET_ADDRESS         5
#define REQUEST_GET_DESCRIPTOR      6
#define REQUEST_SET_DESCRIPTOR      7
#define REQUEST_GET_CONFIGURATION   8
#define REQUEST_SET_CONFIGURATION   9
#define REQUEST_GET_INTERFACE       10
#define REQUEST_SET_INTERFACE       11
#define REQUEST_SYNCH_FRAME         12

//
// These request types can be composed.
// But it is just easy to define them.
//
#define REQUEST_TYPE_CLEAR_HUB_FEATURE  0x20
#define REQUEST_TYPE_CLEAR_PORT_FEATURE 0x23
#define REQUEST_TYPE_GET_BUS_STATE      0xa3
#define REQUEST_TYPE_GET_HUB_DESCRIPTOR 0xa0
#define REQUEST_TYPE_GET_HUB_STATUS     0xa0
#define REQUEST_TYPE_GET_PORT_STATUS    0xa3
#define REQUEST_TYPE_SET_HUB_DESCRIPTOR 0x20
#define REQUEST_TYPE_SET_HUB_FEATURE    0x20
#define REQUEST_TYPE_SET_PORT_FEATURE   0x23

//
// Feature selector, defined in Ch11
//
#define FEATURE_C_HUB_LOCAL_POWER   0
#define FEATURE_C_HUB_OVER_CURRENT  1
#define FEATURE_PORT_CONNECT        0
#define FEATURE_PORT_ENABLE         1
#define FEATURE_PORT_SUSPEND        2
#define FEATURE_PORT_OVER_CURRENT   3
#define FEATURE_PORT_RESET          4
#define FEATURE_PORT_POWER          8
#define FEATURE_PORT_LOW_SPEED      9
#define FEATURE_C_PORT_CONNECT      16
#define FEATURE_C_PORT_ENABLE       17
#define FEATURE_C_PORT_SUSPEND      18
#define FEATURE_C_PORT_OVER_CURRENT 19
#define FEATURE_C_PORT_RESET        20

//----------------------------------------------------------------------------------
// Utility Macros

#define UsbhBuildGetDescriptorUrb(\
                                pUrb, \
                                pDeviceData, \
                                bDescriptorType, \
                                bDescriptorIndex, \
                                wLanguageId, \
                                ulTransferLength, \
                                pTransferBuffer) \
    {\
    (pUrb)->UrbHeader.UsbdDeviceHandle = pDeviceData;\
    (pUrb)->UrbHeader.Length = (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST);\
    (pUrb)->UrbHeader.Function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;\
    (pUrb)->UrbControlDescriptorRequest.DescriptorType = bDescriptorType;\
    (pUrb)->UrbControlDescriptorRequest.Index =  bDescriptorIndex;\
    (pUrb)->UrbControlDescriptorRequest.LanguageId = wLanguageId;\
    (pUrb)->UrbControlDescriptorRequest.TransferBufferLength = ulTransferLength;\
    (pUrb)->UrbControlDescriptorRequest.TransferBuffer = pTransferBuffer;\
    (pUrb)->UrbControlDescriptorRequest.TransferBufferMDL = NULL;\
    (pUrb)->UrbControlVendorClassRequest.UrbLink = NULL;\
    }

#define UsbhBuildVendorClassUrb(\
                                    pUrb,\
                                    pDeviceData,\
                                    wFunction,\
                                    ulTransferFlags,\
                                    bRequestType,\
                                    bRequest,\
                                    wFeatureSelector,\
                                    wPort,\
                                    ulTransferBufferLength,\
                                    pTransferBuffer)\
    {\
    (pUrb)->UrbHeader.Length = (USHORT) sizeof( struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST);\
    (pUrb)->UrbHeader.Function = wFunction;\
    (pUrb)->UrbHeader.UsbdDeviceHandle = pDeviceData;\
    (pUrb)->UrbControlVendorClassRequest.TransferFlags = ulTransferFlags;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferLength = ulTransferBufferLength;\
    (pUrb)->UrbControlVendorClassRequest.TransferBuffer = pTransferBuffer;\
    (pUrb)->UrbControlVendorClassRequest.TransferBufferMDL = NULL;\
    (pUrb)->UrbControlVendorClassRequest.RequestTypeReservedBits = bRequestType;\
    (pUrb)->UrbControlVendorClassRequest.Request = bRequest;\
    (pUrb)->UrbControlVendorClassRequest.Value = wFeatureSelector;\
    (pUrb)->UrbControlVendorClassRequest.Index = wPort;\
    (pUrb)->UrbControlVendorClassRequest.UrbLink = NULL;\
    }

//----------------------------------------------------------------------------------
//
// string macros. these work with char and wide char strings
//
//  Counting the byte count of an ascii string or wide char string
//
#define STRLEN( Length, p )\
    {\
    int i;\
    for ( i=0; (p)[i]; i++ );\
    Length = i*sizeof(*p);\
    }

//
// copy wide char string
//
#define STRCPY( pDst, pSrc )\
    {\
    int nLength, i;\
    STRLEN( nLength, pSrc );\
    nLength /= sizeof( *pSrc );\
    for ( i=0; i < nLength; i++ ) pDst[i] = pSrc[i];\
    pDst[i] = 0;\
    }

//
// concat (wide) char strings
//
#define STRCAT( pFirst, pSecond )\
    {\
    int j, k;\
    int nLength;\
    STRLEN( j, pFirst );\
    STRLEN( nLength, pSecond );\
    j /= sizeof( *pFirst );\
    nLength /= sizeof( *pSecond);\
    for ( k=0; k < nLength; k++, j++ ) pFirst[j] = pSecond[k];\
    pFirst[j] = 0;\
    }

//
// append a (wide) char,
//
#define APPEND( pString, ch )\
    {\
    int nLength;\
    STRLEN( nLength, pString );\
    nLength /= sizeof( *pString );\
    pString[nLength] = ch;\
    pString[nLength+1] = 0;\
    }

//----------------------------------------------------------------------------------
//
// Debug Macros
//

#ifdef NTKERN
// Win95 only
#define DBGBREAK() _asm {int 3}
#else
#define DBGBREAK() DbgBreakPoint()
#endif

#define USBHUB_HEAP_TAG 0x42554855  //"UHUB"
#define USBHUB_FREE_TAG 0x62756875  //"uhub"

#if DBG

PVOID
UsbhGetHeap(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

VOID
UsbhRetHeap(
    IN PVOID P,
    IN ULONG Signature,
    IN PLONG TotalAllocatedHeapSpace
    );

// TEST_TRAP() is a code coverage trap these should be removed
// if you are able to 'g' past the OK
//
// KdTrap() breaks in the debugger on the debug build
// these indicate bugs in client drivers, kernel apis or fatal error
// conditions that should be debugged. also used to mark
// code for features not implemented yet.
//
// KdBreak() breaks in the debugger when in MAX_DEBUG mode
// ie debug trace info is turned on, these are intended to help
// debug drivers devices and special conditions on the
// bus.

ULONG
_cdecl
USBH_KdPrintX(
    ULONG l,
    PCH Format,
    ...
    );

#define UsbhExAllocatePool(pt, l) UsbhGetHeap(pt, l, USBHUB_HEAP_TAG, \
    &UsbhHeapCount)
#define UsbhExFreePool(p)   UsbhRetHeap(p, USBHUB_HEAP_TAG, &UsbhHeapCount)
#define DBG_ONLY(s) s
#define USBH_KdPrint(_s_) USBH_KdPrintX _s_

//#define USBH_KdPrintAlways(s) { DbgPrint( "USBH: "); \
//                                DbgPrint s; \
//                              }
#ifdef MAX_DEBUG
#define USBH_KdBreak(s) if (USBH_Debug_Trace_Level) { \
                            DbgPrint( "USBH: "); \
                            DbgPrint s; \
                         } \
                         DBGBREAK();
#else
#define USBH_KdBreak(s)
#endif /* MAX_DEBUG */

#define USBH_KdTrap(s)  { DbgPrint( "USBH: ");\
                          DbgPrint s; \
                          DBGBREAK(); }

#define TEST_TRAP()  { DbgPrint( "USBH: Code coverage trap %s line: %d\n", __FILE__, __LINE__);\
                       DBGBREAK();}
#else // not debug
#define UsbhExAllocatePool(pt, l) ExAllocatePoolWithTag(pt, l, USBHUB_HEAP_TAG)
#define UsbhExFreePool(p)   ExFreePool(p)
#define DBG_ONLY(s)
#define USBH_KdPrint(_s_)
#define USBH_KdBreak(s)
#define USBH_KdTrap(s)
//#define USBH_KdPrintAlways(s)
#define TEST_TRAP();
#endif

#ifdef HOST_GLOBALS
#define DECLARE(type, var, init_value ) type var = init_value;
#define DECLARE_NO_INIT(type, var) type var;
#else
#define DECLARE(type, var, init_value ) extern type var;
#define DECLARE_NO_INIT(type, var ) extern type var;
#endif

//----------------------------------------------------------------------------------
//
// Global Variables
//

//
// Remember our driver object
//
DECLARE( PDRIVER_OBJECT, UsbhDriverObject, NULL)

extern PWCHAR GenericUSBDeviceString;


#if DBG
//
// keep track of heap allocations
//
DECLARE( ULONG, UsbhHeapCount, 0)

#define PNP_TEST_FAIL_ENUM          0x00000001
#define PNP_TEST_FAIL_DEV_POWER     0x00000002
#define PNP_TEST_FAIL_HUB_COUNT     0x00000004
#define PNP_TEST_FAIL_HUB           0x00000008
#define PNP_TEST_FAIL_PORT_RESET    0x00000010
#define PNP_TEST_FAIL_WAKE_REQUEST  0x00000020
#define PNP_TEST_FAIL_RESTORE       0x00000040

DECLARE( ULONG, UsbhPnpTest, 0)
#endif

//
// The following strings are used to build HardwareId etc.
//
// USB string
//
DECLARE( PWCHAR, pwchUsbSlash, L"USB\\");

// Vendor ID string
//
DECLARE( PWCHAR, pwchVid, L"Vid_");

//
// Product Id string
//
DECLARE( PWCHAR, pwchPid, L"Pid_");

//
// Revision string
//
DECLARE( PWCHAR, pwchRev, L"Rev_");

//
// Device Class string
//
DECLARE( PWCHAR, pwchDevClass, L"DevClass_");

//
// Class string
//
DECLARE( PWCHAR, pwchClass, L"Class_");

//
// Composite
//
DECLARE( PWCHAR, pwchComposite, L"USB\\COMPOSITE");

//
// SubClass string
//
DECLARE( PWCHAR, pwchSubClass, L"SubClass_");

//
// MultiInterface string
//
DECLARE( PWCHAR, pwchMultiInterface, L"USB\\MI");

//
// Device Protocol string
//
DECLARE( PWCHAR, pwchProt, L"Prot_");


DECLARE_NO_INIT( UNICODE_STRING, UsbhRegistryPath);

//
// To set the verbose level of the debug print
//
#ifdef MAX_DEBUG
#define DEBUG3
#endif /* MAX_DEBUG */

#ifdef DEBUG3
DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 3))
#else
    #ifdef DEBUG2
    DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 2))
    #else
        #ifdef DEBUG1
        DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 1))
        #else
        DBG_ONLY( DECLARE( ULONG, USBH_Debug_Trace_Level, 0))
        #endif // DEBUG1
    #endif // DEBUG2
#endif // DEBUG3

#define USBH_DEBUGFLAG_BREAK_PDO_START       0x00000001

DBG_ONLY( DECLARE( ULONG, USBH_Debug_Flags, 0))

#if DBG

VOID
UsbhWarning(
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    PUCHAR Message,
    BOOLEAN DebugBreak
    );

#define ASSERT_HUB(de) USBH_ASSERT(EXTENSION_TYPE_HUB == ((PDEVICE_EXTENSION_HUB) de)->ExtensionType)
#define ASSERT_PORT(de) USBH_ASSERT(EXTENSION_TYPE_PORT == ((PDEVICE_EXTENSION_PORT) de)->ExtensionType)
#define ASSERT_FUNCTION(de) USBH_ASSERT(EXTENSION_TYPE_FUNCTION == ((PDEVICE_EXTENSION_FUNCTION) de)->ExtensionType)
#else

#define UsbhWarning(x, y, z)

#define ASSERT_HUB(de)
#define ASSERT_PORT(de)
#define ASSERT_FUNCTION(de)
#endif

#define TO_USB_DEVICE       0
#define TO_USB_INTERFACE    1
#define TO_USB_ENDPOINT     2


//
// maximum number of times we will attempt to reset
// the hub before giving up
//

#define USBH_MAX_ERRORS     3

//----------------------------------------------------------------------------------
//
// Function Prototypes
//

#ifdef USB2

VOID
USBH_InitializeUSB2Hub(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

// use version 5
#define PUSB_HUB_BUS_INTERFACE PUSB_BUS_INTERFACE_HUB_V5
#define HUB_BUSIF_VERSION USB_BUSIF_HUB_VERSION_5    

NTSTATUS
USBHUB_GetBusInterface(
    IN PDEVICE_OBJECT RootHubPdo,
    IN PUSB_HUB_BUS_INTERFACE BusInterface
    );

NTSTATUS
USBD_CreateDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE *DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG DeviceHackFlags,
    IN USHORT PortStatus,
    IN USHORT PortNumber
    );

VOID
USBHUB_FlushAllTransfers(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );    

NTSTATUS
USBD_InitializeDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
    IN ULONG DeviceDescriptorLength,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
    IN ULONG ConfigDescriptorLength
    );

NTSTATUS
USBD_RemoveDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData,
    IN PDEVICE_OBJECT RootHubPdo,
    IN ULONG Flags
    );

NTSTATUS
USBD_GetDeviceInformationEx(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_NODE_CONNECTION_INFORMATION_EX DeviceInformation,
    IN ULONG DeviceInformationLength,
    IN PUSB_DEVICE_HANDLE DeviceData
    );

NTSTATUS
USBD_MakePdoNameEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUNICODE_STRING PdoNameUnicodeString,
    IN ULONG Index
    );

ULONG
USBD_CalculateUsbBandwidthEx(
    IN ULONG MaxPacketSize,
    IN UCHAR EndpointType,
    IN BOOLEAN LowSpeed
    );

NTSTATUS
USBD_RestoreDeviceEx(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PUSB_DEVICE_HANDLE OldDeviceData,
    IN OUT PUSB_DEVICE_HANDLE NewDeviceData,
    IN PDEVICE_OBJECT RootHubPdo
    );

NTSTATUS
USBD_QuerySelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PBOOLEAN SelectiveSuspendEnabled
    );

NTSTATUS
USBD_SetSelectiveSuspendEnabled(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN BOOLEAN SelectiveSuspendEnabled
    );

NTSTATUS
USBHUB_GetRootHubName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PVOID Buffer,
    IN PULONG BufferLength
    );

//ULONG
//USBD_GetHackFlags(
//    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
//    );
#endif

NTSTATUS
USBH_SyncResetPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBH_SyncResumePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncSuspendPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

VOID
USBH_ProcessHubStateChange(
    IN PHUB_STATE CurrentHubState,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

VOID
USBH_ProcessPortStateChange(
    IN PPORT_STATE CurrentPortState,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
USBH_SyncGetPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength);

NTSTATUS
USBH_SyncClearPortStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN USHORT Feature);

NTSTATUS
USBH_SyncClearHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT Feature);

NTSTATUS
USBH_SyncEnablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncPowerOnPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN WaitForPowerGood);

NTSTATUS
USBH_SyncPowerOffPort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncPowerOnPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING UniRegistryPath);

NTSTATUS
USBH_HubDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp);

VOID
USBH_DriverUnload(
    IN PDRIVER_OBJECT DriverObject);

VOID
UsbhWait(
    ULONG MiliSeconds);

NTSTATUS
USBH_PdoDispatch(
    PDEVICE_EXTENSION_PORT pDeviceExtensionPort,
    PIRP pIrp);

NTSTATUS
USBH_SyncGetHubDescriptor(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub);

NTSTATUS
USBH_SyncGetDeviceConfigurationDescriptor(
    PDEVICE_OBJECT DeviceObject,
    PUCHAR DataBuffer,
    ULONG DataBufferLength,
    OUT PULONG BytesReturned);

BOOLEAN
USBH_ValidateSerialNumberString(
    PWCHAR DeviceId
    );

NTSTATUS
USBH_CreateDevice(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    USHORT PortNumber,
    USHORT PortStatus,
    ULONG RetryIteration
    );

NTSTATUS
USBH_FdoSyncSubmitUrb(
    PDEVICE_OBJECT HubDeviceObject,
    IN PURB Urb);

NTSTATUS
USBH_SyncGetRootHubPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *HcdDeviceObject,
    IN OUT PULONG Count
    );

NTSTATUS
USBH_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject);

NTSTATUS
USBH_FdoPnP(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PIRP Irp,
    UCHAR MinorFunction);

NTSTATUS
USBH_FdoPower(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PIRP Irp,
    UCHAR MinorFunction);

NTSTATUS
USBH_ChangeIndication(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context);

VOID
USBH_ChangeIndicationWorker(
    PVOID Context);

NTSTATUS
USBH_PassIrp(
    PIRP Irp,
    PDEVICE_OBJECT NextDeviceObject);

VOID
USBH_CompleteIrp(
     IN PIRP Irp,
     IN NTSTATUS NtStatus);

NTSTATUS
USBH_SyncDisablePort(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber);

NTSTATUS
USBH_SyncGetHubStatus(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength);

NTSTATUS
USBH_FdoHubStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp);

NTSTATUS
USBH_ParentFdoStartDevice(
    IN OUT PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp,
    IN BOOLEAN NewList
    );

NTSTATUS
USBH_ParentDispatch(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_GetConfigurationDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUSB_CONFIGURATION_DESCRIPTOR *DataBuffer
    );

PWCHAR
USBH_BuildDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    );

PWCHAR
USBH_BuildHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId,
    IN BOOLEAN IsHubClass
    );

PWCHAR
USBH_BuildCompatibleIDs(
    IN PUCHAR CompatibleID,
    IN PUCHAR SubCompatibleID,
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    );

PWCHAR
USBH_BuildInstanceID(
    IN PWCHAR UniqueIdString,
    IN ULONG Length
    );

NTSTATUS
USBH_GetDeviceDescriptor(
    IN PDEVICE_OBJECT HubFDO,
    OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor
    );

NTSTATUS
USBH_GetDeviceQualifierDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    OUT PUSB_DEVICE_QUALIFIER_DESCRIPTOR DeviceQualifierDescriptor
    );

NTSTATUS
USBH_FunctionPdoDispatch(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_CloseConfiguration(
    IN PDEVICE_EXTENSION_FDO DeviceExtensionFdo
    );

NTSTATUS
USBH_IoctlGetNodeInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetHubCapabilities(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetNodeConnectionInformation(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN BOOLEAN ExApi
    );

NTSTATUS
USBH_IoctlGetDescriptorForPDO(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_SyncSubmitUrb(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

NTSTATUS
USBH_Transact(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    IN BOOLEAN DataOutput,
    IN USHORT Function,
    IN UCHAR RequestType,
    IN UCHAR Request,
    IN USHORT Feature,
    IN USHORT Port,
    OUT PULONG BytesTransferred
    );

NTSTATUS
USBH_GetNameFromPdo(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN OUT PUNICODE_STRING DeviceNameUnicodeString
    );

NTSTATUS
USBH_MakeName(
    PDEVICE_OBJECT PdoDeviceObject,
    ULONG NameLength,
    PWCHAR Name,
    PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBH_FdoStartDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_QueryCapabilities(
    IN PDEVICE_OBJECT PdoDeviceObject,
    IN PDEVICE_CAPABILITIES DeviceCapabilities
    );

NTSTATUS
USBH_FdoStopDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoRemoveDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoQueryBusRelations(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
UsbhFdoCleanup(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ProcessDeviceInformation(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoQueryId(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoPnP(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN PBOOLEAN CompleteIrp
    );

NTSTATUS
USBH_PdoRemoveDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoQueryCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoSetPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ParentFdoStopDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_ParentFdoRemoveDevice(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

VOID
UsbhParentFdoCleanup(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    );

NTSTATUS
USBH_ParentQueryBusRelations(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoQueryId(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoQueryDeviceText(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp
    );

NTSTATUS
USBH_FunctionPdoPnP(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN PIRP Irp,
    IN UCHAR MinorFunction,
    IN OUT PBOOLEAN IrpNeedsCompletion
    );

NTSTATUS
USBH_IoctlGetNodeName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

BOOLEAN
USBH_HubIsBusPowered(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
USBH_SyncGetStatus(
    IN PDEVICE_OBJECT HubFDO,
    IN OUT PUSHORT StatusBits,
    IN USHORT function,
    IN USHORT Index
    );

NTSTATUS
USBH_GetSerialNumberString(
    IN PDEVICE_OBJECT DevicePDO,
    IN OUT PWCHAR *SerialNumberBuffer,
    IN OUT PUSHORT SerialNumberBufferLength,
    IN LANGID LanguageId,
    IN UCHAR StringIndex
    );

NTSTATUS
USBH_SyncGetStringDescriptor(
    IN PDEVICE_OBJECT DevicePDO,
    IN UCHAR Index,
    IN USHORT LangId,
    IN OUT PUSB_STRING_DESCRIPTOR Buffer,
    IN ULONG BufferLength,
    IN PULONG BytesReturned,
    IN BOOLEAN ExpectHeader
    );

NTSTATUS
USBH_SyncFeatureRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT FeatureSelector,
    IN USHORT Index,
    IN USHORT Target,
    IN BOOLEAN ClearFeature
    );

NTSTATUS
USBH_PdoIoctlGetPortStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_PdoIoctlEnablePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoDeferPoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
USBH_DeferIrpCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_BuildFunctionConfigurationDescriptor(
    IN PDEVICE_EXTENSION_FUNCTION DeviceExtensionFunction,
    IN OUT PUCHAR Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned
    );

NTSTATUS
USBH_ResetHub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ResetDevice(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN BOOLEAN KeepConfiguration,
    IN ULONG RetryIteration
    );

NTSTATUS
USBH_PdoIoctlResetPort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_SetPowerD1orD2(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SetPowerD0(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SetPowerD3(
    IN PIRP Irp,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoQueryDeviceText(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_CheckDeviceLanguage(
    IN PDEVICE_OBJECT DevicePDO,
    IN LANGID LanguageId
    );

NTSTATUS
USBH_PdoPower(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp,
    IN UCHAR MinorFunction
    );

NTSTATUS
USBH_SubmitInterruptTransfer(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_SymbolicLink(
    BOOLEAN CreateFlag,
    PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    LPGUID lpGuid
    );

NTSTATUS
USBH_SyncPowerOffPorts(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_RestoreDevice(
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN BOOLEAN KeepConfiguration
    );

NTSTATUS
USBH_PnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ParentCreateFunctionList(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN PUSBD_INTERFACE_LIST_ENTRY InterfaceList,
    IN PURB Urb
    );

NTSTATUS
USBH_PdoStopDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ChangeIndicationProcessChange(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ChangeIndicationAckChangeComplete(
    IN PDEVICE_OBJECT PNull,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_ChangeIndicationAckChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port,
    IN USHORT FeatureSelector
    );

NTSTATUS
USBH_IoctlGetNodeConnectionDriverKeyName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_ChangeIndicationQueryChange(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN PURB Urb,
    IN USHORT Port
    );

NTSTATUS
USBH_InvalidatePortDeviceState(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USB_CONNECTION_STATUS ConnectStatus,
    IN USHORT PortNumber
    );

NTSTATUS
USBH_PdoEvent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber
    );

USB_CONNECTION_STATUS
UsbhGetConnectionStatus(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_ParentSubmitWaitWakeIrp(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent
    );

NTSTATUS
USBH_WriteFailReason(
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN ULONG FailReason
    );

NTSTATUS
USBH_WriteRegistryKeyValue (
    IN HANDLE Handle,
    IN PWCHAR KeyNameString,
    IN ULONG KeyNameStringLength,
    IN ULONG Data
    );

NTSTATUS
USBH_SystemControl (
    IN  PDEVICE_EXTENSION_FDO DeviceExtensionFdo,
    IN  PIRP            Irp
    );

NTSTATUS
USBH_PortSystemControl (
    IN  PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN  PIRP Irp
    );

NTSTATUS
USBH_ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN OUT PUCHAR Buffer
    );

NTSTATUS
USBH_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
USBH_PortQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
USBH_FlushPortChange(
    IN OUT PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN OUT PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_PdoIoctlCyclePort(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_ResetPortOvercurrent(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

NTSTATUS
USBH_SyncGetControllerInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    IN ULONG Ioctl
    );

NTSTATUS
USBH_SyncGetHubName(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
USBH_IoctlHubSymbolicName(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

NTSTATUS
USBH_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
USBH_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

NTSTATUS
USBH_PortQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG OutBufferSize,
    OUT PUCHAR Buffer
    );

NTSTATUS
USBH_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    );

NTSTATUS
USBH_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    );

NTSTATUS
USBH_GetPdoRegistryParameter(
    IN PDEVICE_OBJECT   PhysicalDeviceObject,
    IN PWCHAR           ValueName,
    OUT PVOID           Data,
    IN ULONG            DataLength,
    OUT PULONG          Type,
    OUT PULONG          ActualDataLength
    );

NTSTATUS
USBH_OsVendorCodeQueryRoutine(
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
    );

VOID
USBH_GetMsOsVendorCode(
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBH_GetMsOsFeatureDescriptor(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            Interface,
    IN USHORT           Index,
    IN OUT PVOID        DataBuffer,
    IN ULONG            DataBufferLength,
    OUT PULONG          BytesReturned
    );

VOID
USBH_InstallExtPropDesc (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
USBH_InstallExtPropDescSections (
    PDEVICE_OBJECT      DeviceObject,
    PMS_EXT_PROP_DESC   pMsExtPropDesc
    );

PMS_EXT_CONFIG_DESC
USBH_GetExtConfigDesc (
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
USBH_ValidateExtConfigDesc (
    IN PMS_EXT_CONFIG_DESC              MsExtConfigDesc,
    IN PUSB_CONFIGURATION_DESCRIPTOR    ConfigurationDescriptor
    );

NTSTATUS
USBH_CalculateInterfaceBandwidth(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT PULONG Bandwidth // in kenr units?
    );

NTSTATUS
USBH_RegQueryDeviceIgnoreHWSerNumFlag(
    IN USHORT idVendor,
    IN USHORT idProduct,
    IN OUT PBOOLEAN IgnoreHWSerNumFlag
    );

NTSTATUS
USBH_RegQueryGenericUSBDeviceString(
    IN OUT PWCHAR *GenericUSBDeviceString
    );

VOID
USBH_ParentCompleteFunctionWakeIrps(
    IN PDEVICE_EXTENSION_PARENT DeviceExtensionParent,
    IN NTSTATUS NtStatus
    );

BOOLEAN
USBH_ValidateConfigurationDescriptor(
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    USBD_STATUS *UsbdSatus
    );

VOID
USBH_HubCompletePortWakeIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    );

VOID
USBH_HubCompletePortIdleIrps(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN NTSTATUS NtStatus
    );

PUSB_DEVICE_HANDLE
USBH_SyncGetDeviceHandle(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
USBH_CompletePowerIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp,
    IN NTSTATUS NtStatus
    );

VOID
USBH_HubESDRecoveryWorker(
    IN PVOID Context);

NTSTATUS
USBH_ScheduleESDRecovery(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

// these are for the USB2 'backport'
PWCHAR
USBH_BuildHubHardwareIDs(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN USHORT BcdDevice,
    IN LONG MiId
    );

PWCHAR
USBH_BuildHubCompatibleIDs(
    IN UCHAR Class,
    IN UCHAR SubClass,
    IN UCHAR Protocol,
    IN BOOLEAN DeviceClass,
    IN BOOLEAN DeviceIsHighSpeed
    );

NTSTATUS
USBH_IoctlCycleHubPort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_InternalCyclePort(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT PortNumber,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );    

PWCHAR
USBH_BuildHubDeviceID(
    IN USHORT IdVendor,
    IN USHORT IdProduct,
    IN LONG MiId
    );

NTSTATUS
USBHUB_GetBusInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_BUS_NOTIFICATION BusInfo,
    IN PVOID BusContext
    );

NTSTATUS
USBHUB_GetBusInfoDevice(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PUSB_BUS_NOTIFICATION BusInfo
    );

NTSTATUS
USBHUB_GetBusInterfaceUSBDI(
    IN PDEVICE_OBJECT HubPdo,
    IN PUSB_BUS_INTERFACE_USBDI_V2 BusInterface
    );

USB_DEVICE_TYPE
USBH_GetDeviceType(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_DEVICE_HANDLE DeviceData
    );

VOID
USBH_CompletePortIdleNotification(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

VOID
USBH_PortIdleNotificationCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBH_FdoSubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_HubSetD0(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBHUB_GetControllerName(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_HUB_NAME Buffer,
    IN ULONG BufferLength
    );

NTSTATUS
USBHUB_GetExtendedHubInfo(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PUSB_EXTHUB_INFORMATION_0 ExtendedHubInfo
    );

BOOLEAN
USBH_DoesHubNeedWaitWake(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_CheckHubIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_PdoSetContentId(
    IN PIRP                          irp,
    IN PVOID                         pKsProperty,
    IN PVOID                         pvData
    );

BOOLEAN
USBH_CheckDeviceIDUnique(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN USHORT IDVendor,
    IN USHORT IDProduct,
    IN PWCHAR SerialNumberBuffer,
    IN USHORT SerialNumberBufferLength
    );

VOID
USBH_IdleCompletePowerHubWorker(
    IN PVOID Context
    );

BOOLEAN
USBH_DeviceIs2xDualMode(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );

PDEVICE_EXTENSION_HUB
USBH_GetRootHubDevExt(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_CheckLeafHubsIdle(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_HubCancelWakeIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_HubCancelIdleIrp(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

NTSTATUS
USBH_IoctlGetNodeConnectionAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    IN PIRP Irp
    );

VOID
USBH_CompletePortIdleIrpsWorker(
    IN PVOID Context);

VOID
USBH_CompletePortWakeIrpsWorker(
    IN PVOID Context);

VOID
USBH_HubAsyncPowerWorker(
    IN PVOID Context);

VOID
USBH_IdleCancelPowerHubWorker(
    IN PVOID Context);

NTSTATUS
USBD_InitUsb2Hub(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_PdoSetCapabilities(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort
    );    

NTSTATUS
USBH_HubPnPIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBH_RegQueryUSBGlobalSelectiveSuspend(
    IN OUT PBOOLEAN DisableSelectiveSuspend
    );

VOID
USBH_SyncRefreshPortAttributes(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBD_RegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBD_UnRegisterRhHubCallBack(
    IN PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

NTSTATUS
USBH_PdoStartDevice(
    IN PDEVICE_EXTENSION_PORT DeviceExtensionPort,
    IN PIRP Irp
    );

VOID
USBHUB_SetDeviceHandleData(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub,
    PDEVICE_OBJECT PdoDeviceObject,
    PVOID DeviceData 
    );        

#define PDO_EXT(p) PdoExt((p))

PDEVICE_EXTENSION_PORT
PdoExt(
    PDEVICE_OBJECT DeviceObject
    );    
    
#ifdef TEST_MS_DESC

#pragma message ("Warning! Compiling in non-retail test code!")

NTSTATUS
USBH_SyncGetMsOsDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Index,
    IN OUT PUCHAR DataBuffer,
    IN ULONG DataBufferLength,
    OUT PULONG BytesReturned);

NTSTATUS
USBH_TestGetMsOsDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT Index
    );

#endif

#define LOG_PNP 0x00000001

#if DBG

NTSTATUS
USBH_GetClassGlobalDebugRegistryParameters(
    );

VOID
UsbhInfo(
    PDEVICE_EXTENSION_HUB DeviceExtensionHub
    );

VOID
USBH_ShowPortState(
    IN USHORT PortNumber,
    IN PPORT_STATE PortState
    );

#define DEBUG_LOG

#define USBH_ASSERT(exp) \
    if (!(exp)) { \
        USBH_Assert( #exp, __FILE__, __LINE__, NULL );\
    }

VOID
USBH_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    );
#else
#define USBH_ASSERT(exp)
#define UsbhInfo(de)
#endif

#ifdef DEBUG_LOG
VOID
USBH_LogInit(
    );

VOID
USBH_LogFree(
    );

#define LOGENTRY(mask, sig, info1, info2, info3) \
    USBH_Debug_LogEntry(mask, sig,               \
                        (ULONG_PTR)info1,        \
                        (ULONG_PTR)info2,        \
                        (ULONG_PTR)info3)

VOID
USBH_Debug_LogEntry(
    IN ULONG Mask,
    IN CHAR *Name,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
    );

#else
#define LOGENTRY(mask, sig, info1, info2, info3)
#define USBH_LogInit()
#define USBH_LogFree()
#endif

// last workitem will let the shutdown code continue
// !! do not reference the devicExtension beyond this point
// if event is signaled
#define USBH_DEC_PENDING_IO_COUNT(de) \
    LOGENTRY(LOG_PNP, "PEN-", de, &de->PendingRequestEvent, de->PendingRequestCount); \
    if (InterlockedDecrement(&de->PendingRequestCount) == 0) {\
        USBH_ASSERT(de->HubFlags & HUBFLAG_DEVICE_STOPPING); \
        LOGENTRY(LOG_PNP, "hWAK", de, &de->PendingRequestEvent, de->PendingRequestCount); \
        KeSetEvent(&de->PendingRequestEvent, 1, FALSE); \
    }

#define USBH_INC_PENDING_IO_COUNT(de) \
    {\
    LOGENTRY(LOG_PNP, "PEN+", de, &de->PendingRequestEvent, de->PendingRequestCount); \
    InterlockedIncrement(&de->PendingRequestCount);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\exe\info\info.c ===
/*++

Module Name:

    INFO.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usbdi.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ShowDeviceInfo (
    PCHAR DevicePath
);

VOID ShowInterfaceInfo (
    PUSBD_INTERFACE_INFORMATION InterfaceInfo
);

PCHAR
GetPipeType (
    USBD_PIPE_TYPE PipeType
);

PCHAR
GetPipeDirection (
    UCHAR EndpointAddress
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    while (deviceNode)
    {
        ShowDeviceInfo(deviceNode->DevicePath);

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ShowDeviceInfo (
    PCHAR DevicePath
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    size = sizeof(USBD_INTERFACE_INFORMATION) -
           sizeof(USBD_PIPE_INFORMATION);

    interfaceInfo = GlobalAlloc(GPTR, size);

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_PIPE_INFORMATION,
                              NULL,
                              0,
                              interfaceInfo,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        size = interfaceInfo->Length;

        interfaceInfo =  GlobalReAlloc(interfaceInfo,
                                       size,
                                       GMEM_MOVEABLE | GMEM_ZEROINIT);

        success = DeviceIoControl(devHandle,
                                  IOCTL_I82930_GET_PIPE_INFORMATION,
                                  NULL,
                                  0,
                                  interfaceInfo,
                                  size,
                                  &nBytes,
                                  NULL);
        if (success)
        {
            ShowInterfaceInfo(interfaceInfo);
        }
    }

    printf("\n");

    GlobalFree(interfaceInfo);

    CloseHandle(devHandle);
}

//*****************************************************************************
//
// ShowInterfaceInfo()
//
//*****************************************************************************

VOID ShowInterfaceInfo (
    PUSBD_INTERFACE_INFORMATION InterfaceInfo
)
{
    ULONG i;

    printf("*** Number Of Pipes %02.2d\n",
           InterfaceInfo->NumberOfPipes);


    for (i=0; i<InterfaceInfo->NumberOfPipes; i++)
    {
        PUSBD_PIPE_INFORMATION pipeInfo;

        pipeInfo = &InterfaceInfo->Pipes[i];

        printf("PIPE%02d :: EP address (0x%02.2x)-(%s %s) Max Packet = %02.2d bytes [%d ms]\n",
               i,
               pipeInfo->EndpointAddress,
               GetPipeType(pipeInfo->PipeType),
               GetPipeDirection(pipeInfo->EndpointAddress),
               pipeInfo->MaximumPacketSize,
               pipeInfo->PipeType == UsbdPipeTypeInterrupt ?
               pipeInfo->Interval : 0
              );

        printf("     MaximumTransferSize = 0x%x\n",
               pipeInfo->MaximumTransferSize);
    }
}

//*****************************************************************************
//
// GetPipeType()
//
//*****************************************************************************

PCHAR
GetPipeType (
    USBD_PIPE_TYPE PipeType
)
{

    switch (PipeType)
    {
        case UsbdPipeTypeControl:
            return "Control  ";             
        case UsbdPipeTypeIsochronous:
            return "Iso      ";         
        case UsbdPipeTypeBulk:
            return "Bulk     "; 
        case UsbdPipeTypeInterrupt:
            return "Interrupt";
        default:
            return "???      "; 
    }
}

//*****************************************************************************
//
// GetPipeDirection()
//
//*****************************************************************************

PCHAR
GetPipeDirection (
    UCHAR EndpointAddress
)
{
    if (USB_ENDPOINT_DIRECTION_IN(EndpointAddress))
    {
        return "in ";
    }
    else
    {
        return "out";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\exe\reconfig\reconfig.c ===
/*++

Module Name:

    RECONFIG.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-2001 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usb100.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ReconfigureDevice (
    PCHAR DevicePath,
    ULONG MPSCount,
    ULONG MPS[]
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;
    ULONG       devInstance;
    ULONG       devCount;
    ULONG       mpsCount;
    ULONG       mps[15];

    devInstance = 1;    // set this with cmd line arg

    for (mpsCount = 0;
         (mpsCount < (ULONG)(argc-1)) && (mpsCount < 15);
         mpsCount++)
    {
        mps[mpsCount] = atoi(argv[mpsCount+1]);
    }

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    devCount = 0;

    while (deviceNode)
    {
        devCount++;

        if (devCount == devInstance)
        {
            ReconfigureDevice(deviceNode->DevicePath,
                              mpsCount,
                              mps);
        }

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ReconfigureDevice (
    PCHAR DevicePath,
    ULONG MPSCount,
    ULONG MPS[]
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDesc;
    PUSB_ENDPOINT_DESCRIPTOR        endpointDesc;
    ULONG                           i;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    for (i = 0; i < MPSCount; i++)
    {
        printf("MPS[%2d] = %4d\n", i, MPS[i]);
    }

    size = sizeof(USB_CONFIGURATION_DESCRIPTOR) +
           sizeof(USB_INTERFACE_DESCRIPTOR) +
           sizeof(USB_ENDPOINT_DESCRIPTOR) * MPSCount;

    configDesc = GlobalAlloc(GPTR, size);

    if (configDesc == NULL)
    {
        return;
    }

    //
    // Initialize the Configuration Descriptor
    //
    configDesc->bLength             = sizeof(USB_CONFIGURATION_DESCRIPTOR);
    configDesc->bDescriptorType     = USB_CONFIGURATION_DESCRIPTOR_TYPE;
    configDesc->wTotalLength        = (USHORT)size;
    configDesc->bNumInterfaces      = 1;
    configDesc->bConfigurationValue = 1;
    configDesc->iConfiguration      = 0;
    configDesc->bmAttributes        = USB_CONFIG_BUS_POWERED |
                                      USB_CONFIG_SELF_POWERED;
    configDesc->MaxPower            = 0;

    //
    // Initialize the Interface Descriptor
    //
    interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)(configDesc + 1);

    interfaceDesc->bLength              = sizeof(USB_INTERFACE_DESCRIPTOR);
    interfaceDesc->bDescriptorType      = USB_INTERFACE_DESCRIPTOR_TYPE;
    interfaceDesc->bInterfaceNumber     = 0;
    interfaceDesc->bAlternateSetting    = 0;
    interfaceDesc->bNumEndpoints        = (UCHAR)MPSCount;
    interfaceDesc->bInterfaceClass      = 0xFF;
    interfaceDesc->bInterfaceSubClass   = 0xFF;
    interfaceDesc->bInterfaceProtocol   = 0xFF;
    interfaceDesc->iInterface           = 0;

    //
    // Initialize the Endpoint Descriptors
    //
    endpointDesc = (PUSB_ENDPOINT_DESCRIPTOR)(interfaceDesc + 1);

    for (i = 0; i < MPSCount; i++)
    {
        endpointDesc->bLength           = sizeof(USB_ENDPOINT_DESCRIPTOR);
        endpointDesc->bDescriptorType   = USB_ENDPOINT_DESCRIPTOR_TYPE;
        endpointDesc->bEndpointAddress  = (UCHAR)(i + 1);
        endpointDesc->bmAttributes      = USB_ENDPOINT_TYPE_ISOCHRONOUS;
        endpointDesc->wMaxPacketSize    = (USHORT)MPS[i];
        endpointDesc->bInterval         = 0;

        endpointDesc++;
    }

    //
    // Set Configuration Descriptor
    //

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_SET_CONFIG_DESCRIPTOR,
                              configDesc,
                              size,
                              NULL,
                              0,
                              &nBytes,
                              NULL);

    if (success)
    {
        printf("Reconfigured device\n");
    }

    GlobalFree(configDesc);

    CloseHandle(devHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\exe\rw\rw.c ===
/*++

Module Name:

    RW.C

Abstract:

    This source file contains routines for exercising reads and writes
    to a USB device through the I82930.SYS test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <stdlib.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy, memcmp)


//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define NOISY(_x_) printf _x_ ;

#define RW_SUCCESS      0
#define RW_FAILED       1
#define RW_ABORTED      2
#define RW_NODEVICE     3
#define RW_BADARGS      4

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// G L O B A L S
//*****************************************************************************

ULONG   DevInstance = 1;        // set with -#  option

ULONG   InPipeNum   = 0;        // set with -i  option
ULONG   OutPipeNum  = 1;        // set with -o  option

BOOL    TestMode    = 0;        // set with -t  option
ULONG   Count       = 1;        // set with -c  option

ULONG   WriteLen    = 0;        // set with -w  option
LONG    WriteOffset = 0;        // set with -wo option
BOOL    WriteReset  = 0;        // set with -W  option
BOOL    WriteZero   = 0;

ULONG   ReadLen     = 0;        // set with -r  option
LONG    ReadOffset  = 0;        // set with -ro option
BOOL    ReadReset   = 0;        // set with -R  option
BOOL    ReadZero    = 0;

BOOL    DumpFlag    = 0;        // set with -d  option
BOOL    Verbose     = 0;        // set with -v  option

DWORD   Offset      = 0;        // set with -f  option
DWORD   OffsetHigh  = 0;        //

BOOL    StallIn     = 0;        // set with -S  option
BOOL    StallOut    = 0;        // set with -S  option

BOOL    SelectAlt   = FALSE;    // set with -A  option
UCHAR   Alternate   = 0;

BOOL    Reset       = FALSE;    // set with -Z  option

BOOL    Abort       = FALSE;    // set by CtrlHandlerRoutine
BOOL    Cancel      = FALSE;    // set by CtrlHandlerRoutine


//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

ULONG
DoReadWriteTest (
    PUCHAR  pinBuf,
    HANDLE  hRead,
    PUCHAR  poutBuf,
    HANDLE  hWrite
);

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
);

PDEVICENODE
EnumDevices (
    LPGUID  Guid
);

HANDLE
OpenDevice (
    PDEVICENODE DeviceNode
);

HANDLE
OpenDevicePipe (
    PDEVICENODE DeviceNode,
    ULONG       PipeNum
);

BOOL
CompareBuffs (
    PUCHAR  buff1,
    PUCHAR  buff2,
    ULONG   length
);

VOID
DumpBuff (
   PUCHAR   b,
   ULONG    len
);

BOOL
ResetPipe (
    HANDLE  hPipe
);

BOOL
StallPipe(
    HANDLE hPipe
);

BOOL
AbortPipe(
    HANDLE hPipe
);

BOOL
SelectAlternate(
    HANDLE hDevice,
    UCHAR  AlternateSetting
);

BOOL
ResetDevice(
    HANDLE hDevice
);

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD   dwCtrlType
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int     argc,
    char   *argv[]
)
{
    PDEVICENODE deviceNode;
    PUCHAR      pinBuf  = NULL;
    PUCHAR      poutBuf = NULL;
    HANDLE      hDevice = INVALID_HANDLE_VALUE;
    HANDLE      hRead   = INVALID_HANDLE_VALUE;
    HANDLE      hWrite  = INVALID_HANDLE_VALUE;
    ULONG       fail    = 0;
    BOOL        success;

    // Parse the command line args
    //
    if (!ParseArgs(argc, argv))
    {
        return RW_BADARGS;
    }

    // Find devices
    //
    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    if (deviceNode == NULL)
    {
        printf("No devices found!\n");
        return RW_NODEVICE;
    }

    while (deviceNode && --DevInstance)
    {
        deviceNode = deviceNode->Next;
    }

    if (deviceNode == NULL)
    {
        printf("Devices instance not found!\n");
        return RW_NODEVICE;
    }

    // Reset the device if desired
    //
    if (Reset || SelectAlt)
    {
        hDevice = OpenDevice(deviceNode);

        if (hDevice != INVALID_HANDLE_VALUE)
        {
            if (Reset)
            {
                success = ResetDevice(hDevice);

                if (!success)
                {
                    printf("Reset device failed\n");
                    fail++;
                }
            }

            if (SelectAlt)
            {
                success = SelectAlternate(hDevice, Alternate);

                if (!success)
                {
                    printf("Select Alternate Interface failed\n");
                    fail++;
                }
            }
        }
    }

    // Set a CTRL-C / CTRL-BREAK handler
    //
    SetConsoleCtrlHandler(CtrlHandlerRoutine, TRUE);

    // Allocate a page aligned write buffer if we're going to do a write.
    //
    if (WriteLen)
    {
        poutBuf = VirtualAlloc(NULL,
                               WriteLen + WriteOffset,
                               MEM_COMMIT,
                               PAGE_READWRITE);
    }

    // Allocate a page aligned read buffer if we're going to do a read.
    //
    if (ReadLen)
    {
        pinBuf = VirtualAlloc(NULL,
                              ReadLen + ReadOffset,
                              MEM_COMMIT,
                              PAGE_READWRITE);
    }

    // Open the output pipe if we're going to do a write or a reset.
    //
    if (poutBuf || WriteReset || WriteZero || StallOut)
    {
        hWrite = OpenDevicePipe(deviceNode, OutPipeNum);

        // STALL the output pipe if desired
        //
        if ((hWrite != INVALID_HANDLE_VALUE) && StallOut)
        {
            success = StallPipe(hWrite);

            if (!success)
            {
                printf("Output pipe STALL failed\n");
                fail++;
            }
        }

        // Reset the output pipe if desired
        //
        if ((hWrite != INVALID_HANDLE_VALUE) && WriteReset)
        {
            success = ResetPipe(hWrite);

            if (!success)
            {
                printf("Output pipe ResetPipe failed\n");
                fail++;
            }
        }
    }

    // Open the input pipe if we're going to do a read or a reset.
    //
    if (pinBuf || ReadReset || ReadZero || StallIn)
    {
        hRead = OpenDevicePipe(deviceNode, InPipeNum);

        // STALL the input pipe if desired
        //
        if ((hRead != INVALID_HANDLE_VALUE) && StallIn)
        {
            success = StallPipe(hRead);

            if (!success)
            {
                printf("Input pipe STALL failed\n");
                fail++;
            }
        }

        // Reset the input pipe if desired
        //
        if ((hRead != INVALID_HANDLE_VALUE) && ReadReset)
        {
            success = ResetPipe(hRead);

            if (!success)
            {
                printf("Input pipe ResetPipe failed\n");
                fail++;
            }
        }
    }

    if (WriteLen && (!poutBuf || (hWrite == INVALID_HANDLE_VALUE)))
    {
        printf("Failed allocating write buffer and/or opening write pipe\n");
        fail++;
    }

    if (ReadLen  && (!pinBuf  || (hRead  == INVALID_HANDLE_VALUE)))
    {
        printf("Failed allocating read buffer and/or opening read pipe\n");
        fail++;
    }

    //
    // NOW DO THE REAL WRITE/READ TEST
    //
    if (!fail)
    {
        fail = DoReadWriteTest(pinBuf + ReadOffset,
                               hRead,
                               poutBuf + WriteOffset,
                               hWrite);
    }

    if (TestMode)
    {
        if (fail)
        {
            printf("Test failed\n");
        }
        else
        {
            printf("Test passed\n");
        }
    }

    // Close devices if needed
    //
    if (hDevice != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hDevice);
        hRead = INVALID_HANDLE_VALUE;
    }

    if (hRead != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hRead);
        hRead = INVALID_HANDLE_VALUE;
    }

    if (hWrite != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWrite);
        hWrite = INVALID_HANDLE_VALUE;
    }

    // Free read/write buffers if needed
    //
    if (pinBuf)
    {
        VirtualFree(pinBuf,
                    0,
                    MEM_RELEASE);
    }

    if (poutBuf)
    {
        VirtualFree(poutBuf,
                    0,
                    MEM_RELEASE);
    }

    if (Abort)
    {
        return RW_ABORTED;
    }
    else if (fail)
    {
        return RW_FAILED;
    }
    else
    {
        return RW_SUCCESS;
    }
}

//*****************************************************************************
//
// DoReadWriteTest()
//
// pinBuf  - Buffer to read data into from input pipe
//
// hRead   - Handle of input pipe
//
// poutBuf - Buffer to write data from to output pipe
//
// hWrite  - Handle of output pipe
//
// return value - zero if success, non-zero if failure
//
//*****************************************************************************

ULONG
DoReadWriteTest (
    PUCHAR  pinBuf,
    HANDLE  hRead,
    PUCHAR  poutBuf,
    HANDLE  hWrite
)
{
    ULONG       nBytesRead;
    ULONG       nBytesWrite;
    ULONG       i;
    ULONG       nBytes;
    BOOL        ok;
    BOOL        success;
    ULONG       fail = 0;
    HANDLE      hConsole;
    HANDLE      hEvent;
    HANDLE      waitHandles[2];
    OVERLAPPED  overlapped;
    DWORD       dwRet;
    DWORD       lastError;

    // Create an event for the overlapped struct
    //
    hEvent = CreateEvent(
                 NULL,  // pEventAttributes
                 FALSE, // bManualReset
                 FALSE, // bInitialState
                 NULL   // lpName
                 );

    overlapped.hEvent = hEvent;

    // Set the command line specified or default offset in the
    // overlapped struct
    //
    overlapped.Offset = Offset;
    overlapped.OffsetHigh = OffsetHigh;

    // The handles that we'll wait on during the overlapped I/O
    //
    hConsole = GetStdHandle(STD_INPUT_HANDLE);
    waitHandles[0] = hConsole;
    waitHandles[1] = hEvent;

    if (poutBuf)
    {
        // Put some data in the output buffer
        //
        //
        for (i=0; i<WriteLen/sizeof(USHORT); i++)
        {
            ((PUSHORT)poutBuf)[i] = (USHORT)i;
        }
    }

    // Start of main Write/Read loop
    //
    for (i=0; i<Count && !Abort && !fail; i++)
    {
        // Write to the output pipe if we have an output buffer
        // and we've opened the output pipe.
        //
        if ((poutBuf || WriteZero) && hWrite != INVALID_HANDLE_VALUE)
        {
            //
            // send the write
            //
            success = WriteFile(hWrite,
                                poutBuf,
                                WriteLen,
                                &nBytesWrite,
                                &overlapped);

            if (!success)
            {
                lastError = GetLastError();

                if (lastError != ERROR_IO_PENDING)
                {
                    printf("WriteFile failed, LastError 0x%08X\n",
                           lastError);
                    fail++;
                    break;
                }
            }

            // Wait for either the write to complete or a cancel by the user
            //
            while (TRUE)
            {
                dwRet = WaitForMultipleObjects(
                            2,
                            waitHandles,
                            FALSE,
                            INFINITE
                            );

                if (dwRet == WAIT_OBJECT_0)
                {
                    FlushConsoleInputBuffer(hConsole);
                    if (Abort)
                    {
                        if (Cancel)
                        {
                            printf("Cancelling Write!\n");
                            success = CancelIo(hWrite);
                            break;
                        }
                        else
                        {
                            printf("Aborting Write!\n");
                            success = AbortPipe(hWrite);
                            break;
                        }
                    }
                }
                else
                {
                    break;  // Write is complete
                }
            }

            success = GetOverlappedResult(hWrite,
                                          &overlapped,
                                          &nBytesWrite,
                                          FALSE);

            // Do screen I/O if we aren't in perf mode
            //
            if (!TestMode)
            {
                printf("<PIPE%02d> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                       OutPipeNum, i, WriteLen, nBytesWrite);
            }
        }

        // Read from the input pipe if we have an input buffer
        // and we've opened the input pipe.
        //
        if ((pinBuf || ReadZero) && hRead != INVALID_HANDLE_VALUE)
        {
            success = ReadFile(hRead,
                               pinBuf,
                               ReadLen,
                               &nBytesRead,
                               &overlapped);

            if (!success)
            {
                lastError = GetLastError();

                if (lastError != ERROR_IO_PENDING)
                {
                    printf("ReadFile failed, LastError 0x%08X\n",
                           lastError);
                    fail++;
                    break;
                }
            }

            // Wait for either the read to complete or a cancel by the user
            //
            while (TRUE)
            {
                dwRet = WaitForMultipleObjects(
                            2,
                            waitHandles,
                            FALSE,
                            INFINITE
                            );

                if (dwRet == WAIT_OBJECT_0)
                {
                    FlushConsoleInputBuffer(hConsole);
                    if (Abort)
                    {
                        if (Cancel)
                        {
                            printf("Cancelling Read!\n");
                            success = CancelIo(hRead);
                            break;
                        }
                        else
                        {
                            printf("Aborting Read!\n");
                            success = AbortPipe(hRead);
                            break;
                        }
                    }
                }
                else
                {
                    break;  // Read is complete
                }
            }

            success = GetOverlappedResult(hRead,
                                          &overlapped,
                                          &nBytesRead,
                                          FALSE);

            // Do screen I/O if we aren't in perf mode
            //
            if (!TestMode)
            {
                printf("<PIPE%02d> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                       InPipeNum, i, ReadLen, nBytesRead);
            }

            // Dump the read data if desired
            //
            if (DumpFlag)
            {
                DumpBuff(pinBuf, nBytesRead);
            }

            if (poutBuf)
            {
                //
                // validate the input buffer against what
                // we sent to the 82930 (loopback test)
                //
                ok = CompareBuffs(pinBuf, poutBuf,  nBytesRead);

                if (ok != 1)
                {
                    fail++;
                }
            }
        }
    }
    //
    // End of main Write/Read loop

    return fail;
}

//*****************************************************************************
//
// Usage()
//
//*****************************************************************************

void
Usage ()
{
    printf("RW.EXE\n");
    printf("usage:\n");
    printf("-#  [n] where n is the device instance to open\n");
    printf("-r  [n] where n is number of bytes to read\n");
    printf("-ro [n] where n is offset from page boundary for read buffer\n");
    printf("-R  reset the input pipe\n");
    printf("-w  [n] where n is number of bytes to write\n");
    printf("-wo [n] where n is offset from page boundary for write buffer\n");
    printf("-W  reset the output pipe\n");
    printf("-c  [n] where n is number of iterations (default = 1)\n");
    printf("-f  [n] where n is offset from current ISO frame\n");
    printf("-i  [s] where s is the input pipe  (default PIPE00)\n");
    printf("-o  [s] where s is the output pipe (default PIPE01)\n");
    printf("-t  test mode - less screen I/O with pass/fail at end of test\n");
    printf("-d  dump read data\n");
    printf("-S  STALL pipe(s) specified by -i and/or -o\n");
    printf("-A  [n] Select Alternate Interface");
    printf("-Z  Reset Device");
}

//*****************************************************************************
//
// ParseArgs()
//
//*****************************************************************************

BOOL
ParseArgs (
    int     argc,
    char   *argv[]
)
{
    int i, j;
    BOOL in, out, stall;

    in      = FALSE;
    out     = FALSE;
    stall   = FALSE;

    if (argc < 2)
    {
        Usage();
        return FALSE;
    }

    for (i=1; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case '#':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    DevInstance = atoi(argv[i]);
                }
                break;
            case 'R':
                ReadReset = TRUE;
                break;
            case 'r':
                if (i+1 == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    switch(argv[i][2])
                    {
                        case 0:
                            ReadLen = atoi(argv[++i]);
                            if (!ReadLen)
                            {
                                ReadZero = TRUE;
                            }
                            break;
                        case 'o':
                            ReadOffset = atoi(argv[++i]) & 0x00000FFF;
                            break;
                        default:
                            Usage();
                            return FALSE;
                    }
                }
                break;
            case 'W':
                WriteReset = TRUE;
                break;
            case 'w':
                if (i+1 == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    switch(argv[i][2])
                    {
                        case 0:
                            WriteLen = atoi(argv[++i]);
                            if (!WriteLen) {
                                WriteZero = TRUE;
                            }
                            break;
                        case 'o':
                            WriteOffset = atoi(argv[++i]) & 0x00000FFF;
                            break;
                        default:
                            Usage();
                            return FALSE;
                    }
                }
                break;
            case 'c':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    Count = atoi(argv[i]);
                }
                break;
            case 'f':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    Offset = atoi(argv[i]);
                    OffsetHigh = 1;
                }
                break;
            case 't':
                TestMode = TRUE;
                break;
            case 'i':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    for (j=0; argv[i][j] && !isdigit(argv[i][j]); j++) {
                    }
                    if (argv[i][j])
                    {
                        InPipeNum = atoi(&argv[i][j]);
                        in = TRUE;
                    }
                }
                break;
            case 'o':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    for (j=0; argv[i][j] && !isdigit(argv[i][j]); j++) {
                    }
                    if (argv[i][j])
                    {
                        OutPipeNum = atoi(&argv[i][j]);
                        out = TRUE;
                    }
                }
                break;
            case 'd':
                DumpFlag = TRUE;
                break;
            case 'S':
                stall = TRUE;
                break;
            case 'A':
                if (++i == argc) {
                    Usage();
                    return FALSE;
                }
                else {
                    SelectAlt = TRUE;
                    Alternate = (UCHAR)atoi(argv[i]);
                }
                break;
            case 'Z':
                Reset = TRUE;
                break;
            case 'v':
                Verbose = TRUE;
                break;
            default:
                Usage();
                return FALSE;
            }
        }
    }

    if (ReadZero) {
        ReadOffset = 0;
    }

    if (WriteZero) {
        WriteOffset = 0;
    }

    if (stall && in) {
        StallIn = TRUE;
    }

    if (stall && out) {
        StallOut = TRUE;
    }

    // Dump parsed args if desired for debug
    //
    if (Verbose)
    {
        printf("DevInstance: %d\n", DevInstance);

        printf("TestMode:    %d\n", TestMode);

        printf("inPipe:      PIPE%02d\n", InPipeNum);
        printf("outPipe:     PIPE%02d\n", OutPipeNum);

        printf("TestMode:    %d\n", TestMode);
        printf("Count:       %d\n", Count);

        printf("WriteLen:    %d\n", WriteLen);
        printf("WriteOffset: %d\n", WriteOffset);
        printf("WriteReset:  %d\n", WriteReset);
        printf("WriteZero:   %d\n", WriteZero);

        printf("ReadLen:     %d\n", ReadLen);
        printf("ReadOffset:  %d\n", ReadOffset);
        printf("ReadReset:   %d\n", ReadReset);
        printf("ReadZero:    %d\n", ReadZero);

        printf("DumpFlag:    %d\n", DumpFlag);
        printf("Verbose:     %d\n", Verbose);

        printf("Offset:      %d\n", Offset);
        printf("OffsetHigh:  %d\n", OffsetHigh);

        printf("StallIn:     %d\n", StallIn);
        printf("StallOut:    %d\n", StallOut);

    }

    return TRUE;
}


//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// OpenDevice()
//
//*****************************************************************************

HANDLE
OpenDevice (
    PDEVICENODE DeviceNode
)
{
    HANDLE  devHandle;

    devHandle = INVALID_HANDLE_VALUE;

    devHandle = CreateFile(DeviceNode->DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        NOISY(("Failed to open (%s) = %d\n",
               DeviceNode->DevicePath, GetLastError()));
    }

    return devHandle;
}

//*****************************************************************************
//
// OpenDevicePipe()
//
//*****************************************************************************

HANDLE
OpenDevicePipe (
    PDEVICENODE DeviceNode,
    ULONG       PipeNum
)
{
    PCHAR   devName;
    HANDLE  devHandle;

    devHandle = INVALID_HANDLE_VALUE;

    if (PipeNum <= 99)
    {
        devName = GlobalAlloc(GPTR,
                              strlen(DeviceNode->DevicePath)+sizeof("\\00"));

        if (devName)
        {
            sprintf(devName, "%s\\%02d", DeviceNode->DevicePath, PipeNum);

            if (!TestMode)
            {
                printf("DevicePath = (%s)\n", devName);
            }

            devHandle = CreateFile(devName,
                                   GENERIC_WRITE | GENERIC_READ,
                                   FILE_SHARE_WRITE | FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_FLAG_OVERLAPPED,
                                   NULL);

            if (devHandle == INVALID_HANDLE_VALUE)
            {
                NOISY(("Failed to open (%s) = %d\n",
                       devName, GetLastError()));
            }
            else
            {
                if (!TestMode)
                {
                    NOISY(("Opened successfully.\n"));
                }
            }

            GlobalFree(devName);
        }
    }

    return devHandle;
}

//*****************************************************************************
//
// CompareBuffs()
//
//*****************************************************************************

BOOL
CompareBuffs (
    PUCHAR  buff1,
    PUCHAR  buff2,
    ULONG   length
)
{
    BOOL ok = TRUE;

    if (memcmp(buff1, buff2, length))
    {
        ok = FALSE;
    }

    return ok;
}

//*****************************************************************************
//
// DumpBuff()
//
//*****************************************************************************

void
DumpBuff (
   PUCHAR   b,
   ULONG    len
)
{
    ULONG i;

    for (i=0; i<len; i++) {
        printf("%02X ", *b++);
        if (i % 16 == 15) {
            printf("\n");
        }
    }
    if (i % 16 != 0) {
        printf("\n");
    }
}

//*****************************************************************************
//
// ResetPipe()
//
//*****************************************************************************

BOOL
ResetPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_RESET_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// StallPipe()
//
//*****************************************************************************

BOOL
StallPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_STALL_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// AbortPipe()
//
//*****************************************************************************

BOOL
AbortPipe(
    HANDLE hPipe
)
{
    int nBytes;

    return DeviceIoControl(hPipe,
                           IOCTL_I82930_ABORT_PIPE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// SelectAlternate()
//
//*****************************************************************************

BOOL
SelectAlternate(
    HANDLE hDevice,
    UCHAR  AlternateSetting
)
{
    int nBytes;

    return DeviceIoControl(hDevice,
                           IOCTL_I82930_SELECT_ALTERNATE_INTERFACE,
                           &AlternateSetting,
                           sizeof(UCHAR),
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// ResetDevice()
//
//*****************************************************************************

BOOL
ResetDevice(
    HANDLE hDevice
)
{
    int nBytes;

    return DeviceIoControl(hDevice,
                           IOCTL_I82930_RESET_DEVICE,
                           NULL,
                           0,
                           NULL,
                           0,
                           &nBytes,
                           NULL);
}

//*****************************************************************************
//
// CtrlHandlerRoutine()
//
//*****************************************************************************

BOOL WINAPI
CtrlHandlerRoutine (
    DWORD dwCtrlType
    )
{
    BOOL handled;

    switch (dwCtrlType)
    {
        case CTRL_C_EVENT:
            Cancel = TRUE;
        case CTRL_BREAK_EVENT:
            Abort = TRUE;
            handled = TRUE;
            break;

        default:
            handled = FALSE;
            break;
    }

    return handled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\exe\config\config.c ===
/*++

Module Name:

    CONFIG.C

Abstract:

    This source file contains routines for exercising the I82930.SYS
    test driver.

Environment:

    user mode

Copyright (c) 1996-1998 Microsoft Corporation.  All Rights Reserved.

    THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
    KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
    PURPOSE.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <windows.h>
#include <basetyps.h>
#include <setupapi.h>
#include <stdio.h>
#include <devioctl.h>
#include <string.h>
#include <initguid.h>
#include <usb100.h>

#include "ioctl.h"

#pragma intrinsic(strlen, strcpy)

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _DEVICENODE
{
    struct _DEVICENODE *Next;
    CHAR                DevicePath[0];
} DEVICENODE, *PDEVICENODE;

//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
);

VOID ShowDeviceInfo (
    PCHAR DevicePath
);

VOID
ShowDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
ShowConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
ShowConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
ShowInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
ShowEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

//*****************************************************************************
//
// main()
//
//*****************************************************************************

int _cdecl
main(
    int argc,
    char *argv[]
)
{
    PDEVICENODE deviceNode;
    PDEVICENODE deviceNodeNext;

    deviceNode = EnumDevices((LPGUID)&GUID_CLASS_I82930);

    while (deviceNode)
    {
        ShowDeviceInfo(deviceNode->DevicePath);

        deviceNodeNext = deviceNode->Next;
        GlobalFree(deviceNode);
        deviceNode = deviceNodeNext;
    }

    return 0;
}

//*****************************************************************************
//
// EnumDevices()
//
//*****************************************************************************

PDEVICENODE
EnumDevices (
    LPGUID Guid
)
{
    HDEVINFO                         deviceInfo;
    SP_DEVICE_INTERFACE_DATA         deviceInfoData;
    PSP_DEVICE_INTERFACE_DETAIL_DATA deviceDetailData;
    ULONG                            index;
    ULONG                            requiredLength;
    PDEVICENODE                      deviceNode;
    PDEVICENODE                      deviceNodeHead;

    deviceNodeHead = NULL;

    deviceInfo = SetupDiGetClassDevs(Guid,
                                     NULL,
                                     NULL,
                                     (DIGCF_PRESENT | DIGCF_DEVICEINTERFACE));

    deviceInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);

    for (index=0;
         SetupDiEnumDeviceInterfaces(deviceInfo,
                                     0,
                                     Guid,
                                     index,
                                     &deviceInfoData);
         index++)
    {
        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        NULL,
                                        0,
                                        &requiredLength,
                                        NULL);

        deviceDetailData = GlobalAlloc(GPTR, requiredLength);

        deviceDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);

        SetupDiGetDeviceInterfaceDetail(deviceInfo,
                                        &deviceInfoData,
                                        deviceDetailData,
                                        requiredLength,
                                        &requiredLength,
                                        NULL);

        requiredLength = sizeof(DEVICENODE) +
                         strlen(deviceDetailData->DevicePath) + 1;

        deviceNode = GlobalAlloc(GPTR, requiredLength);

        strcpy(deviceNode->DevicePath, deviceDetailData->DevicePath);
        deviceNode->Next = deviceNodeHead;
        deviceNodeHead = deviceNode;

        GlobalFree(deviceDetailData);
    }

    SetupDiDestroyDeviceInfoList(deviceInfo);

    return deviceNodeHead;
}

//*****************************************************************************
//
// ShowDeviceInfo()
//
//*****************************************************************************

VOID ShowDeviceInfo (
    PCHAR DevicePath
)
{
    HANDLE  devHandle;
    BOOL    success;
    int     size;
    int     nBytes;
    USB_DEVICE_DESCRIPTOR           deviceDesc;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;

    devHandle = CreateFile(DevicePath,
                           GENERIC_WRITE | GENERIC_READ,
                           FILE_SHARE_WRITE | FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

    if (devHandle == INVALID_HANDLE_VALUE)
    {
        printf("Unable to open device:%s\n", DevicePath);
        return;
    }
    else
    {
        printf("Device: %s\n", DevicePath);
    }

    //
    // Get Device Descriptor
    //

    size = sizeof(USB_DEVICE_DESCRIPTOR);
    
    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_DEVICE_DESCRIPTOR,
                              NULL,
                              0,
                              &deviceDesc,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        //
        // Show Device Descriptor
        //

        ShowDeviceDesc(&deviceDesc);
    }

    //
    // Get Configuration Descriptor (just the Configuration Descriptor)
    //

    size = sizeof(USB_CONFIGURATION_DESCRIPTOR);

    configDesc = GlobalAlloc(GPTR, size);

    success = DeviceIoControl(devHandle,
                              IOCTL_I82930_GET_CONFIG_DESCRIPTOR,
                              NULL,
                              0,
                              configDesc,
                              size,
                              &nBytes,
                              NULL);

    if (success)
    {
        //
        // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
        //
        
        size = configDesc->wTotalLength;

        configDesc =  GlobalReAlloc(configDesc,
                                    size,
                                    GMEM_MOVEABLE | GMEM_ZEROINIT);

        success = DeviceIoControl(devHandle,
                                  IOCTL_I82930_GET_CONFIG_DESCRIPTOR,
                                  NULL,
                                  0,
                                  configDesc,
                                  size,
                                  &nBytes,
                                  NULL);
        if (success)
        {
            //
            // Show Configuration Descriptor
            //

            ShowConfigDesc(configDesc);
        }
    }

    printf("\n");

    GlobalFree(configDesc);

    CloseHandle(devHandle);
}

//*****************************************************************************
//
// ShowDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
ShowDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    printf("------------------\n");
    printf("Device Descriptor:\n");

    printf("bcdUSB:             0x%04X\n",
           DeviceDesc->bcdUSB);

    printf("bDeviceClass:         0x%02X\n",
           DeviceDesc->bDeviceClass);

    printf("bDeviceSubClass:      0x%02X\n",
           DeviceDesc->bDeviceSubClass);

    printf("bDeviceProtocol:      0x%02X\n",
           DeviceDesc->bDeviceProtocol);

    printf("bMaxPacketSize0:      0x%02X (%d)\n",
           DeviceDesc->bMaxPacketSize0,
           DeviceDesc->bMaxPacketSize0);

    printf("idVendor:           0x%04X\n",
           DeviceDesc->idVendor);

    printf("idProduct:          0x%04X\n",
           DeviceDesc->idProduct);

    printf("bcdDevice:          0x%04X\n",
           DeviceDesc->bcdDevice);

    printf("iManufacturer:        0x%02X\n",
           DeviceDesc->iManufacturer);

    printf("iProduct:             0x%02X\n",
           DeviceDesc->iProduct);

    printf("iSerialNumber:        0x%02X\n",
           DeviceDesc->iSerialNumber);

    printf("bNumConfigurations:   0x%02X\n",
           DeviceDesc->bNumConfigurations);

}

//*****************************************************************************
//
// ShowConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
ShowConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 ShowUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        ShowUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    ShowUnknown = TRUE;
                    break;
                }
                ShowEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                ShowUnknown = TRUE;
                break;
        }

        if (ShowUnknown)
        {
            // ShowUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// ShowConfigurationDescriptor()
//
//*****************************************************************************

VOID
ShowConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    printf("-------------------------\n");
    printf("Configuration Descriptor:\n");

    printf("wTotalLength:       0x%04X\n",
           ConfigDesc->wTotalLength);

    printf("bNumInterfaces:       0x%02X\n",
           ConfigDesc->bNumInterfaces);

    printf("bConfigurationValue:  0x%02X\n",
           ConfigDesc->bConfigurationValue);

    printf("iConfiguration:       0x%02X\n",
           ConfigDesc->iConfiguration);

    printf("bmAttributes:         0x%02X\n",
           ConfigDesc->bmAttributes);

    if (ConfigDesc->bmAttributes & 0x80)
    {
        printf("  Bus Powered\n");
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        printf("  Self Powered\n");
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        printf("  Remote Wakeup\n");
    }

    printf("MaxPower:             0x%02X (%d Ma)\n",
           ConfigDesc->MaxPower,
           ConfigDesc->MaxPower * 2);

}

//*****************************************************************************
//
// ShowInterfaceDescriptor()
//
//*****************************************************************************

VOID
ShowInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    printf("---------------------\n");
    printf("Interface Descriptor:\n");

    printf("bInterfaceNumber:     0x%02X\n",
           InterfaceDesc->bInterfaceNumber);

    printf("bAlternateSetting:    0x%02X\n",
           InterfaceDesc->bAlternateSetting);

    printf("bNumEndpoints:        0x%02X\n",
           InterfaceDesc->bNumEndpoints);

    printf("bInterfaceClass:      0x%02X\n",
           InterfaceDesc->bInterfaceClass);

    printf("bInterfaceSubClass:   0x%02X\n",
           InterfaceDesc->bInterfaceSubClass);

    printf("bInterfaceProtocol:   0x%02X\n",
           InterfaceDesc->bInterfaceProtocol);

    printf("iInterface:           0x%02X\n",
           InterfaceDesc->iInterface);

}

//*****************************************************************************
//
// ShowEndpointDescriptor()
//
//*****************************************************************************

VOID
ShowEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    printf("--------------------\n");
    printf("Endpoint Descriptor:\n");

    printf("bEndpointAddress:     0x%02X\n",
           EndpointDesc->bEndpointAddress);

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            printf("Transfer Type:     Control\n");
            break;

        case 0x01:
            printf("Transfer Type: Isochronous\n");
            break;

        case 0x02:
            printf("Transfer Type:        Bulk\n");
            break;

        case 0x03:
            printf("Transfer Type:   Interrupt\n");
            break;
    }

    printf("wMaxPacketSize:     0x%04X (%d)\n",
           EndpointDesc->wMaxPacketSize,
           EndpointDesc->wMaxPacketSize);

    printf("bInterval:            0x%02X\n",
           EndpointDesc->bInterval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\dbg.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    I82930 driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"

#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text(PAGE, I82930_QueryGlobalParams)
#endif
#if DEBUG_LOG
#pragma alloc_text(PAGE, I82930_LogInit)
#pragma alloc_text(PAGE, I82930_LogUnInit)
#endif
#if DBG
#pragma alloc_text(PAGE, DumpDeviceDesc)
#pragma alloc_text(PAGE, DumpConfigDesc)
#pragma alloc_text(PAGE, DumpConfigurationDescriptor)
#pragma alloc_text(PAGE, DumpInterfaceDescriptor)
#pragma alloc_text(PAGE, DumpEndpointDescriptor)
#endif
#endif


//******************************************************************************
//
// G L O B A L S
//
//******************************************************************************

#if DBG || DEBUG_LOG

DRIVERGLOBALS I82930_DriverGlobals =
{
#if DBG
    0,      // DebugFlags
    0,      // DebugLevel
#endif
    0,      // LogStart
    0,      // LogPtr
    0,      // LogEnd
    0       // LogSpinLock
};

#endif

#if DBG

//******************************************************************************
//
// I82930_QueryGlobalParams()
//
//******************************************************************************

VOID
I82930_QueryGlobalParams (
    )
{
    RTL_QUERY_REGISTRY_TABLE paramTable[3];
    ULONG zero;

    DBGPRINT(2, ("enter: I82930_QueryGlobalParams\n"));

    zero = 0;   // default value

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"DebugFlags";
    paramTable[0].EntryContext  = &I82930_DriverGlobals.DebugFlags;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &zero;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &I82930_DriverGlobals.DebugLevel;
    paramTable[1].DefaultType   = REG_BINARY;
    paramTable[1].DefaultData   = &zero;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"I82930",
                           &paramTable[0],
                           NULL,           // Context
                           NULL);          // Environment

    DBGPRINT(2, ("exit:  I82930_QueryGlobalParams\n"));
}

#endif

#if DBG || DEBUG_LOG

//*****************************************************************************
//
// I82930_LogInit()
//
//*****************************************************************************

VOID
I82930_LogInit (
)
{
    KeInitializeSpinLock(&I82930_DriverGlobals.LogSpinLock);

    I82930_DriverGlobals.LogStart = ExAllocatePool(NonPagedPool, LOGSIZE);

    if (I82930_DriverGlobals.LogStart != NULL)
    {
        I82930_DriverGlobals.LogEnd = I82930_DriverGlobals.LogStart +
                                      LOGSIZE / sizeof(I82930_LOG_ENTRY);

        I82930_DriverGlobals.LogPtr = I82930_DriverGlobals.LogEnd - 1;
    }

    DbgPrint("I82930: LogStart @ %08X, LogPtr @ %08X, LogEnd @ %08X\n",
             &I82930_DriverGlobals.LogStart,
             &I82930_DriverGlobals.LogPtr,
             &I82930_DriverGlobals.LogEnd);
}

//*****************************************************************************
//
// I82930_LogUnInit()
//
//*****************************************************************************

VOID
I82930_LogUnInit (
)
{
    PI82930_LOG_ENTRY logStart;

    logStart = I82930_DriverGlobals.LogStart;

    I82930_DriverGlobals.LogStart = 0;

    ExFreePool(logStart);
}

//*****************************************************************************
//
// I82930_LogEntry()
//
//*****************************************************************************

VOID
I82930_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
)
{
    KIRQL irql;

    if (I82930_DriverGlobals.LogStart == NULL)
    {
        return;
    }

    KeAcquireSpinLock(&I82930_DriverGlobals.LogSpinLock, &irql);

    if (I82930_DriverGlobals.LogPtr > I82930_DriverGlobals.LogStart)
    {
        I82930_DriverGlobals.LogPtr--;
    }
    else
    {
        I82930_DriverGlobals.LogPtr = I82930_DriverGlobals.LogEnd - 1;
    }

    I82930_DriverGlobals.LogPtr->le_tag     = Tag;
    I82930_DriverGlobals.LogPtr->le_info1   = Info1;
    I82930_DriverGlobals.LogPtr->le_info2   = Info2;
    I82930_DriverGlobals.LogPtr->le_info3   = Info3;

    KeReleaseSpinLock(&I82930_DriverGlobals.LogSpinLock, irql);
}

#endif

#if DBG

//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerMinorFunctionString()
//
// MinorFunction - The IRP_MJ_POWER minor function
//
//*****************************************************************************

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerDeviceStateString()
//
// State - The DEVICE_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
)
{
    switch (State)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

//*****************************************************************************
//
// PowerSystemStateString()
//
// State - The SYSTEM_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
)
{
    switch (State)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

//*****************************************************************************
//
// DumpDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    DBGPRINT(3, ("------------------\n"));
    DBGPRINT(3, ("Device Descriptor:\n"));

    DBGPRINT(3, ("bcdUSB:             0x%04X\n",
                 DeviceDesc->bcdUSB));

    DBGPRINT(3, ("bDeviceClass:         0x%02X\n",
                 DeviceDesc->bDeviceClass));

    DBGPRINT(3, ("bDeviceSubClass:      0x%02X\n",
                 DeviceDesc->bDeviceSubClass));

    DBGPRINT(3, ("bDeviceProtocol:      0x%02X\n",
                 DeviceDesc->bDeviceProtocol));

    DBGPRINT(3, ("bMaxPacketSize0:      0x%02X (%d)\n",
                 DeviceDesc->bMaxPacketSize0,
                 DeviceDesc->bMaxPacketSize0));

    DBGPRINT(3, ("idVendor:           0x%04X\n",
                 DeviceDesc->idVendor));

    DBGPRINT(3, ("idProduct:          0x%04X\n",
                 DeviceDesc->idProduct));

    DBGPRINT(3, ("bcdDevice:          0x%04X\n",
                 DeviceDesc->bcdDevice));

    DBGPRINT(3, ("iManufacturer:        0x%02X\n",
                 DeviceDesc->iManufacturer));

    DBGPRINT(3, ("iProduct:             0x%02X\n",
                 DeviceDesc->iProduct));

    DBGPRINT(3, ("iSerialNumber:        0x%02X\n",
                 DeviceDesc->iSerialNumber));

    DBGPRINT(3, ("bNumConfigurations:   0x%02X\n",
                 DeviceDesc->bNumConfigurations));

}

//*****************************************************************************
//
// DumpConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 dumpUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        dumpUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                dumpUnknown = TRUE;
                break;
        }

        if (dumpUnknown)
        {
            // DumpUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// DumpConfigurationDescriptor()
//
//*****************************************************************************

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    DBGPRINT(3, ("-------------------------\n"));
    DBGPRINT(3, ("Configuration Descriptor:\n"));

    DBGPRINT(3, ("wTotalLength:       0x%04X\n",
                 ConfigDesc->wTotalLength));

    DBGPRINT(3, ("bNumInterfaces:       0x%02X\n",
                 ConfigDesc->bNumInterfaces));

    DBGPRINT(3, ("bConfigurationValue:  0x%02X\n",
                 ConfigDesc->bConfigurationValue));

    DBGPRINT(3, ("iConfiguration:       0x%02X\n",
                 ConfigDesc->iConfiguration));

    DBGPRINT(3, ("bmAttributes:         0x%02X\n",
                 ConfigDesc->bmAttributes));

    if (ConfigDesc->bmAttributes & 0x80)
    {
        DBGPRINT(3, ("  Bus Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        DBGPRINT(3, ("  Self Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        DBGPRINT(3, ("  Remote Wakeup\n"));
    }

    DBGPRINT(3, ("MaxPower:             0x%02X (%d Ma)\n",
                 ConfigDesc->MaxPower,
                 ConfigDesc->MaxPower * 2));

}

//*****************************************************************************
//
// DumpInterfaceDescriptor()
//
//*****************************************************************************

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    DBGPRINT(3, ("---------------------\n"));
    DBGPRINT(3, ("Interface Descriptor:\n"));

    DBGPRINT(3, ("bInterfaceNumber:     0x%02X\n",
                 InterfaceDesc->bInterfaceNumber));

    DBGPRINT(3, ("bAlternateSetting:    0x%02X\n",
                 InterfaceDesc->bAlternateSetting));

    DBGPRINT(3, ("bNumEndpoints:        0x%02X\n",
                 InterfaceDesc->bNumEndpoints));

    DBGPRINT(3, ("bInterfaceClass:      0x%02X\n",
                 InterfaceDesc->bInterfaceClass));

    DBGPRINT(3, ("bInterfaceSubClass:   0x%02X\n",
                 InterfaceDesc->bInterfaceSubClass));

    DBGPRINT(3, ("bInterfaceProtocol:   0x%02X\n",
                 InterfaceDesc->bInterfaceProtocol));

    DBGPRINT(3, ("iInterface:           0x%02X\n",
                 InterfaceDesc->iInterface));

}

//*****************************************************************************
//
// DumpEndpointDescriptor()
//
//*****************************************************************************

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    DBGPRINT(3, ("--------------------\n"));
    DBGPRINT(3, ("Endpoint Descriptor:\n"));

    DBGPRINT(3, ("bEndpointAddress:     0x%02X\n",
                 EndpointDesc->bEndpointAddress));

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            DBGPRINT(3, ("Transfer Type:     Control\n"));
            break;

        case 0x01:
            DBGPRINT(3, ("Transfer Type: Isochronous\n"));
            break;

        case 0x02:
            DBGPRINT(3, ("Transfer Type:        Bulk\n"));
            break;

        case 0x03:
            DBGPRINT(3, ("Transfer Type:   Interrupt\n"));
            break;
    }

    DBGPRINT(3, ("wMaxPacketSize:     0x%04X (%d)\n",
                 EndpointDesc->wMaxPacketSize,
                 EndpointDesc->wMaxPacketSize));

    DBGPRINT(3, ("bInterval:            0x%02X\n",
                 EndpointDesc->bInterval));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\ioctl.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    IOCTL.C

Abstract:

    This source file contains the dispatch routine which handles:

    IRP_MJ_DEVICE_CONTROL

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"
#include "ioctl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I82930_DeviceControl)
#pragma alloc_text(PAGE, I82930_IoctlGetDeviceDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlGetConfigDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlSetConfigDescriptor)
#pragma alloc_text(PAGE, I82930_ValidateConfigurationDescriptor)
#pragma alloc_text(PAGE, I82930_IoctlGetPipeInformation)
#pragma alloc_text(PAGE, I82930_IoctlResetPipe)
#endif


//******************************************************************************
//
// I82930_DeviceControl()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL
//
//******************************************************************************

NTSTATUS
I82930_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    ULONG               ioControlCode;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_DeviceControl\n"));

    LOGENTRY('IOCT', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_IOCTL);

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->AcceptingRequests)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode)
        {
            case IOCTL_I82930_GET_DEVICE_DESCRIPTOR:
                ntStatus = I82930_IoctlGetDeviceDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_GET_CONFIG_DESCRIPTOR:
                ntStatus = I82930_IoctlGetConfigDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_SET_CONFIG_DESCRIPTOR:
                ntStatus = I82930_IoctlSetConfigDescriptor(DeviceObject,
                                                           Irp);
                break;

            case IOCTL_I82930_GET_PIPE_INFORMATION:
                ntStatus = I82930_IoctlGetPipeInformation(DeviceObject,
                                                          Irp);
                break;

            case IOCTL_I82930_RESET_PIPE:
                ntStatus = I82930_IoctlResetPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_STALL_PIPE:
                ntStatus = I82930_IoctlStallPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_ABORT_PIPE:
                ntStatus = I82930_IoctlAbortPipe(DeviceObject,
                                                 Irp);
                break;

            case IOCTL_I82930_RESET_DEVICE:
                ntStatus = I82930_IoctlResetDevice(DeviceObject,
                                                   Irp);
                break;

            case IOCTL_I82930_SELECT_ALTERNATE_INTERFACE:
                ntStatus = I82930_IoctlSelectAlternateInterface(DeviceObject,
                                                                Irp);
                break;

            default:
                ntStatus = STATUS_INVALID_PARAMETER;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }
    else
    {
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  I82930_DeviceControl %08X\n", ntStatus));

    LOGENTRY('ioct', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlGetDeviceDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_DEVICE_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetDeviceDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetDeviceDescriptor\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    dest        = Irp->AssociatedIrp.SystemBuffer;
    destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    src         = deviceExtension->DeviceDescriptor;
    srcLength   = sizeof(USB_DEVICE_DESCRIPTOR);

    copyLength  = (destLength < srcLength) ? destLength : srcLength;

    RtlCopyMemory(dest, src, copyLength);

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetDeviceDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlGetConfigDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_CONFIG_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetConfigDescriptor\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    dest        = Irp->AssociatedIrp.SystemBuffer;
    destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    src         = deviceExtension->ConfigurationDescriptor;
    srcLength   = deviceExtension->ConfigurationDescriptor->wTotalLength;

    copyLength  = (destLength < srcLength) ? destLength : srcLength;

    RtlCopyMemory(dest, src, copyLength);

    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetConfigDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlSetConfigDescriptor()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_SET_CONFIG_DESCRIPTOR
//
//******************************************************************************

NTSTATUS
I82930_IoctlSetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION               deviceExtension;
    PIO_STACK_LOCATION              irpStack;
    PUSB_CONFIGURATION_DESCRIPTOR   configDesc;
    PUSB_CONFIGURATION_DESCRIPTOR   configDescCopy;
    ULONG                           length;
    NTSTATUS                        ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlSetConfigDescriptor\n"));

    ntStatus    = STATUS_SUCCESS;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    configDesc  = (PUSB_CONFIGURATION_DESCRIPTOR)Irp->AssociatedIrp.SystemBuffer;
    length      = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    if (!I82930_ValidateConfigurationDescriptor(configDesc, length))
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    if (NT_SUCCESS(ntStatus))
    {
        configDescCopy = ExAllocatePool(NonPagedPool, length);

        if (configDescCopy != NULL)
        {
            RtlCopyMemory(configDescCopy, configDesc, length);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (NT_SUCCESS(ntStatus))
    {
        ntStatus = I82930_UnConfigure(DeviceObject);
    }

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(deviceExtension->ConfigurationDescriptor != NULL);

        ExFreePool(deviceExtension->ConfigurationDescriptor);

        deviceExtension->ConfigurationDescriptor = configDescCopy;

        ntStatus = I82930_SelectConfiguration(DeviceObject);
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlSetConfigDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_ValidateConfigurationDescriptor()
//
// This routine verifies that a Configuration Descriptor is valid.
//
//******************************************************************************

BOOLEAN
I82930_ValidateConfigurationDescriptor (
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    IN  ULONG                           Length
    )
{
    PUCHAR                      descEnd;
    PUSB_COMMON_DESCRIPTOR      commonDesc;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDesc;
    UCHAR                       numInterfaces;
    UCHAR                       numEndpoints;

    PAGED_CODE();

    //
    // Validate the Configuration Descriptor header
    //

    if (Length < sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad Length\n"));

        return FALSE;
    }

    if (ConfigDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bLength\n"));

        return FALSE;
    }

    if (ConfigDesc->bDescriptorType != USB_CONFIGURATION_DESCRIPTOR_TYPE)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bDescriptorType\n"));

        return FALSE;
    }

    if (ConfigDesc->wTotalLength != Length)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: wTotalLength != Length\n"));

        return FALSE;
    }

    //
    // End of descriptor pointer, one byte past the last valid byte.
    //
    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    //
    // Start at first descriptor past the Configuration Descriptor header
    //
    commonDesc = (PUSB_COMMON_DESCRIPTOR)((PUCHAR)ConfigDesc +
                                          sizeof(USB_CONFIGURATION_DESCRIPTOR));

    interfaceDesc = NULL;
    numInterfaces = 0;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        // Is this an Interface Descriptor?
        //
        if ((commonDesc->bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE) &&
            (commonDesc->bLength         == sizeof(USB_INTERFACE_DESCRIPTOR)))
        {
            if ((interfaceDesc == NULL) ||
                (interfaceDesc->bInterfaceNumber !=
                 ((PUSB_INTERFACE_DESCRIPTOR)commonDesc)->bInterfaceNumber))
            {
                // One more Interface Descriptor for this Configuration Descriptor
                //
                numInterfaces++;
            }

            // If there was a previous Interface Descriptor, verify that there
            // were the correct number of Endpoint Descriptors
            //
            if ((interfaceDesc != NULL) &&
                (numEndpoints != interfaceDesc->bNumEndpoints))
            {
                DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumEndpoints\n"));

                return FALSE;
            }

            // Remember the current Interface Descriptor
            //
            interfaceDesc = (PUSB_INTERFACE_DESCRIPTOR)commonDesc;

            // Reset the Endpoint Descriptor count for this Interface Descriptor
            //
            numEndpoints = 0;
        }
        // Is this an Endpoint Descriptor?
        //
        else if ((commonDesc->bDescriptorType == USB_ENDPOINT_DESCRIPTOR_TYPE) &&
                 (commonDesc->bLength         == sizeof(USB_ENDPOINT_DESCRIPTOR)))
        {
            // One more Endpoint Descriptor for this Interface Descriptor
            //
            numEndpoints++;
        }
        else
        {
            DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bDescriptorType and/or bLength\n"));

            return FALSE;
        }

        // Advance past this descriptor
        //
        (PUCHAR)commonDesc += commonDesc->bLength;
    }

    if ((PUCHAR)commonDesc != descEnd)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad final descriptor\n"));

        return FALSE;
    }

    if (numInterfaces != ConfigDesc->bNumInterfaces)
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumInterfaces and/or bLength\n"));
    }

    // If there was a previous Interface Descriptor, verify that there
    // were the correct number of Endpoint Descriptors
    //
    if ((interfaceDesc != NULL) &&
        (numEndpoints != interfaceDesc->bNumEndpoints))
    {
        DBGPRINT(0, ("I82930_ValidateConfigurationDescriptor: Bad bNumEndpoints\n"));

        return FALSE;
    }

    return TRUE;
}

//******************************************************************************
//
// I82930_IoctlGetPipeInformation()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_GET_PIPE_INFORMATION
//
//******************************************************************************

NTSTATUS
I82930_IoctlGetPipeInformation (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PVOID               dest;
    ULONG               destLength;
    PVOID               src;
    ULONG               srcLength;
    ULONG               copyLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlGetPipeInformation\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->InterfaceInfo != NULL)
    {
        irpStack    = IoGetCurrentIrpStackLocation(Irp);

        dest        = Irp->AssociatedIrp.SystemBuffer;
        destLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

        src         = deviceExtension->InterfaceInfo;
        srcLength   = deviceExtension->InterfaceInfo->Length;

        copyLength  = (destLength < srcLength) ? destLength : srcLength;

        RtlCopyMemory(dest, src, copyLength);

        ntStatus = STATUS_SUCCESS;
    }
    else
    {
        copyLength = 0;

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = copyLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlGetPipeInformation %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlResetPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_RESET_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlResetPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Reset pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        ntStatus = I82930_ResetPipe(DeviceObject,
                                    pipe,
                                    TRUE);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlResetPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlStallPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_STALL_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlStallPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    PURB                urb;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlStallPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Stall pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        // Allocate URB for CONTROL_FEATURE request
        //
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

        if (urb != NULL)
        {
            // Initialize CONTROL_FEATURE request URB
            //
            urb->UrbHeader.Length   = sizeof (struct _URB_CONTROL_FEATURE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
            urb->UrbControlFeatureRequest.UrbLink = NULL;
            urb->UrbControlFeatureRequest.FeatureSelector = USB_FEATURE_ENDPOINT_STALL;
            urb->UrbControlFeatureRequest.Index = pipe->PipeInfo->EndpointAddress;

            // Submit CONTROL_FEATURE request URB
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

            // Done with URB for CONTROL_FEATURE request, free it
            //
            ExFreePool(urb);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlStallPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlAbortPipe()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_ABORT_PIPE
//
//******************************************************************************

NTSTATUS
I82930_IoctlAbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlAbortPipe\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Abort pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        ntStatus = I82930_AbortPipe(DeviceObject,
                                    pipe);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlAbortPipe %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlResetDevice()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_RESET_DEVICE
//
//******************************************************************************

NTSTATUS
I82930_IoctlResetDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlResetDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      FALSE);

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlResetDevice %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_IoctlSelectAlternateInterface()
//
// This routine handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_I82930_SELECT_ALTERNATE_INTERFACE
//
//******************************************************************************

NTSTATUS
I82930_IoctlSelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    UCHAR               alternateSetting;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_IoctlSelectAlternateInterface\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack    = IoGetCurrentIrpStackLocation(Irp);

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength == sizeof(UCHAR))
    {
        alternateSetting = *(PUCHAR)Irp->AssociatedIrp.SystemBuffer;

        DBGPRINT(2, ("Select AlternateInterface %d\n",
                     alternateSetting));


        ntStatus = I82930_SelectAlternateInterface(DeviceObject,
                                                   alternateSetting);
    }
    else
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_IoctlSelectAlternateInterface %08X\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\i82930.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    I82930.H

Abstract:

    Header file for I82930 driver

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include "dbg.h"

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define USB_RECIPIENT_DEVICE    0
#define USB_RECIPIENT_INTERFACE 1
#define USB_RECIPIENT_ENDPOINT  2
#define USB_RECIPIENT_OTHER     3

// Endpoint numbers are 0-15.  Endpoint number 0 is the standard control
// endpoint which is not explicitly listed in the Configuration Descriptor.
// There can be an IN endpoint and an OUT endpoint at endpoint numbers
// 1-15 so there can be a maximum of 30 endpoints per device configuration.
//
#define I82930_MAX_PIPES        30

#define POOL_TAG                '039I'

#define INCREMENT_OPEN_COUNT(deviceExtension) \
    InterlockedIncrement(&(((PDEVICE_EXTENSION)(deviceExtension))->OpenCount))

#define DECREMENT_OPEN_COUNT(deviceExtension) do { \
    if (InterlockedDecrement(&(((PDEVICE_EXTENSION)(deviceExtension))->OpenCount)) == 0) { \
        KeSetEvent(&((deviceExtension)->RemoveEvent), \
                   IO_NO_INCREMENT, \
                   0); \
    } \
} while (0)


//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef struct _I82930_PIPE {

    // Pointer into PDEVICE_EXTENSION->InterfaceInfo.Pipes[]
    //
    PUSBD_PIPE_INFORMATION  PipeInfo;

    // Index into PDEVICE_EXTENSION->PipeList[]
    //
    UCHAR                   PipeIndex;

    // TRUE if pipe is currently open
    //
    BOOLEAN                 Opened;

    UCHAR                   Pad[2];

} I82930_PIPE, *PI82930_PIPE;


typedef struct _DEVICE_EXTENSION
{
    // PDO passed to I82930_AddDevice
    //
    PDEVICE_OBJECT                  PhysicalDeviceObject;

    // Our FDO is attached to this device object
    //
    PDEVICE_OBJECT                  StackDeviceObject;

    // Device Descriptor retrieved from the device
    //
    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // Configuration Descriptor retrieved from the device
    //
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigurationDescriptor;

    // ConfigurationHandle returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    // Interface info returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    PUSBD_INTERFACE_INFORMATION     InterfaceInfo;

    // Name of our symbolic link
    //
    UNICODE_STRING                  SymbolicLinkName;

    // Initialized to one in AddDevice.
    // Incremented by one for every open.
    // Decremented by one for every close.
    // Decremented by one in REMOVE_DEVICE.
    //
    ULONG                           OpenCount;

    // Set when OpenCount is decremented to zero
    //
    KEVENT                          RemoveEvent;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by I82930_FdoSetPower(), used by
    // I82930_FdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    // Inialized to FALSE in AddDevice.
    // Set to TRUE in START_DEVICE.
    // Set to FALSE in STOP_DEVICE and REMOVE_DEVICE.
    //
    BOOLEAN                         AcceptingRequests;

    UCHAR                           Pad[3];

    // Array of info about each pipe in the current device configuration
    //
    I82930_PIPE                     PipeList[I82930_MAX_PIPES];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// I82930.C
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
I82930_Unload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
I82930_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

NTSTATUS
I82930_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
I82930_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
I82930_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_QueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    );

NTSTATUS
I82930_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
I82930_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    );

NTSTATUS
I82930_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    );

NTSTATUS
I82930_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
I82930_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
I82930_SelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            AlternateSetting
    );

//
// OCRW.C
//

NTSTATUS
I82930_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ReadWrite_Complete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

PURB
I82930_BuildAsyncUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    );

PURB
I82930_BuildIsoUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    );

ULONG
I82930_GetCurrentFrame (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe,
    IN BOOLEAN          IsoClearStall
    );

NTSTATUS
I82930_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe
    );

//
// IOCTL.C
//

NTSTATUS
I82930_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlGetDeviceDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlGetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlSetConfigDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

BOOLEAN
I82930_ValidateConfigurationDescriptor (
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    IN  ULONG                           Length
    );

NTSTATUS
I82930_IoctlGetPipeInformation (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlStallPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlAbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlResetDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
I82930_IoctlSelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\ioctl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

        

Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef   __IOCTL_H__
#define   __IOCTL_H__

#define GET_ERROR_DEADMAN_TIMEOUT     10000     //timeout in mS

#define ISOPERF_IOCTL_INDEX  0x0000


#define IOCTL_ISOPERF_START_ISO_IN_TEST          CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  ISOPERF_IOCTL_INDEX,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_ISOPERF_STOP_ISO_IN_TEST           CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  ISOPERF_IOCTL_INDEX+1,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_ISOPERF_GET_ISO_IN_STATS           CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  ISOPERF_IOCTL_INDEX+2,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_ISOPERF_WAIT_FOR_ERROR              CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  ISOPERF_IOCTL_INDEX+3,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_ISOPERF_SET_DRIVER_CONFIG           CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  ISOPERF_IOCTL_INDEX+4,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

/*
// Test device types
*/
typedef enum _device_type {
    Iso_In_With_Pattern,
    Iso_Out_With_Interrupt_Feedback,
    Iso_Out_Without_Feedback,
    Unknown_Device_Type,
    Max_Device_Type
} dtDeviceType, *pdtDeviceType;

typedef enum _erErrorType_ {
    NoError,
    DataCompareFailed,
    UsbdErrorInCompletion,
    ErrorInPostingUrb,
    Max_Error_Type
}erErrorType, *perErrorType;

typedef struct _config_and_stat_info_ {
    // Config Info (read at start of tests)
    ULONG ulNumberOfFrames;
    ULONG ulMax_Urbs_Per_Pipe;
	ULONG ulDoInOutTest;
	ULONG ulFrameOffset;            // 0 => start ASAP
    ULONG ulFrameOffsetMate;        // For the mate device (Iso OUT)
    
    // Info on frame numbers for Iso test app to look at
	ULONG ulStartingFrameNumber;    //Frame number we started our transfers on...
    ULONG ulFrameNumberAtStart;     //Frame number that the bus was on when we posted the Irp...

    //Stat counters
    ULONG ulSuccessfulIrps;
    ULONG ulUnSuccessfulIrps;
    ULONG ulBytesTransferredIn;
    ULONG ulBytesTransferredOut;
    ULONG ulUpperClockCount;
    ULONG ulLowerClockCount;
    ULONG ulUrbDeltaClockCount;
    
    // Misc info about this device
    ULONG ulCountDownToStop;
    USHORT ulMaxPacketSize_IN;
    USHORT Padding1;
    USHORT ulMaxPacketSize_OUT;
    USHORT Padding2;
    dtDeviceType DeviceType;
    
    //these are kept globally for now...but are copied into this structure when passed to user mode app
    ULONG ulBytesAllocated; 
    ULONG ulBytesFreed;

    // Error indicators
    erErrorType erError;        //Error type -- indicates device hit an error (0=no error)
    ULONG bStopped;             //Stopped flag -- indicates device is stopped due to an error
    ULONG UrbStatusCode;        //If error flag indicates UsbdError or ErrorInPostingUrb, this is the last usbd URB status code
    ULONG UsbdPacketStatCode;   //If error flag indicates UsbdError or ErrorInPostingUrb, this is the last usbd PACKET status code
    ULONG bDeviceRunning;       //Data transfers are happening on this device
    
} Config_Stat_Info, * pConfig_Stat_Info ;

#endif   // __IOCTL_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\dbg.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    Header file for I82930 driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#if DBG
  #if defined(DEBUG_LOG)
    #undef DEBUG_LOG
  #endif
  #define DEBUG_LOG 1
#else
  #if !defined(DEBUG_LOG)
    #define DEBUG_LOG 0
  #endif
#endif


#if !DBG

#define DBGFBRK(flag)
#define DBGPRINT(level, _x_)

#else

#define DBGF_BRK_DRIVERENTRY            0x00000001
#define DBGF_BRK_UNLOAD                 0x00000002
#define DBGF_BRK_ADDDEVICE              0x00000004
#define DBGF_BRK_REMOVEDEVICE           0x00000008
#define DBGF_BRK_STARTDEVICE            0x00000010
#define DBGF_BRK_STOPDEVICE             0x00000020
#define DBGF_BRK_QUERYSTOPDEVICE        0x00000040
#define DBGF_BRK_CANCELSTOPDEVICE       0x00000080
#define DBGF_BRK_CREATE                 0x00010000
#define DBGF_BRK_CLOSE                  0x00020000
#define DBGF_BRK_READWRITE              0x00040000
#define DBGF_BRK_IOCTL                  0x00080000

#define DBGFBRK(flag) do { \
    if (I82930_DriverGlobals.DebugFlags & flag) { \
        DbgBreakPoint(); \
    } \
} while (0)

#define DBGPRINT(level, _x_) do { \
    if (level <= I82930_DriverGlobals.DebugLevel) { \
        KdPrint(("I82930: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

#if !DEBUG_LOG

#define LOGINIT()
#define LOGUNINIT()
#define LOGENTRY(tag, info1, info2, info3)

#else

#define LOGSIZE 4096

#define LOGINIT() I82930_LogInit()

#define LOGUNINIT() I82930_LogUnInit()

#define LOGENTRY(tag, info1, info2, info3) \
    I82930_LogEntry(((((tag) >> 24) & 0x000000FF) | \
                     (((tag) >>  8) & 0x0000FF00) | \
                     (((tag) <<  8) & 0x00FF0000) | \
                     (((tag) << 24) & 0xFF000000)), \
                    ((ULONG_PTR)info1),             \
                    ((ULONG_PTR)info2),             \
                    ((ULONG_PTR)info3))

#endif

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#if DEBUG_LOG

typedef struct _I82930_LOG_ENTRY {
    ULONG       le_tag;
    ULONG_PTR   le_info1;
    ULONG_PTR   le_info2;
    ULONG_PTR   le_info3;
} I82930_LOG_ENTRY, *PI82930_LOG_ENTRY;

#endif

#if DBG || DEBUG_LOG

typedef struct _DRIVERGLOBALS
{
#if DBG
    ULONG               DebugFlags;     // DBGF_* Flags
    LONG                DebugLevel;     // Level of debug output
#endif
    PI82930_LOG_ENTRY   LogStart;       // Start of log buffer (older entries)
    PI82930_LOG_ENTRY   LogPtr;         // Current entry in log buffer
    PI82930_LOG_ENTRY   LogEnd;         // End of log buffer (newer entries)
    KSPIN_LOCK          LogSpinLock;    // Protects LogPtr

} DRIVERGLOBALS;

#endif

//*****************************************************************************
//
// G L O B A L S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG || DEBUG_LOG

DRIVERGLOBALS I82930_DriverGlobals;

#endif


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG

VOID
I82930_QueryGlobalParams (
    );

#endif

#if DEBUG_LOG

VOID
I82930_LogInit (
);

VOID
I82930_LogUnInit (
);

VOID
I82930_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
);

#endif

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
);

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
);

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\ioctl.c ===
/*++

Module Name:

   ioctl.c

Abstract:

   Handle ioctl for the isoperf driver

Environment:

    kernel mode only

Revision History:

    5-4-96 : created

--*/

#define DRIVER
 
#pragma warning(disable:4214) //  bitfield nonstd
#include "wdm.h"
#pragma warning(default:4214) 

#include "stdarg.h"
#include "stdio.h"
#include "devioctl.h"

#pragma warning(disable:4200) //non std struct used
#include "usbdi.h"
#pragma warning(default:4200)

#include "usbdlib.h"
#include "usb.h"

#include "ioctl.h"
#include "isoperf.h"
#include "iso.h"

NTSTATUS
ISOPERF_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this instance of the 82930
                    devcice.
                    

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    ULONG ioControlCode;
    NTSTATUS ntStatus = STATUS_SUCCESS;
        
    ISOPERF_KdPrint_MAXDEBUG (("In ISOPERF_ProcessIoctl (DObj: %x, Irp: %x)\n",DeviceObject, Irp));
    
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    // Get a pointer to the device extension
    deviceExtension = DeviceObject->DeviceExtension;

    ISO_ASSERT (deviceExtension != NULL);
    
    ioBuffer            = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength   = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength  = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    ioControlCode       = irpStack->Parameters.DeviceIoControl.IoControlCode;
    

    ISOPERF_KdPrint_MAXDEBUG (("IRP_MJ_DEVICE_CONTROL\n"));
    ISOPERF_KdPrint_MAXDEBUG (("DeviceObj: %X | DeviceExt: %X\n",DeviceObject, DeviceObject->DeviceExtension));
    ISOPERF_KdPrint_MAXDEBUG (("IOControlCode: %X\n", ioControlCode));
    ISOPERF_KdPrint_MAXDEBUG (("ioBuffer: %x\n",ioBuffer));
    ISOPERF_KdPrint_MAXDEBUG (("inputBufferLength: %x\n",inputBufferLength));
    ISOPERF_KdPrint_MAXDEBUG (("outputBufferLength: %x\n",outputBufferLength));


    // 
    // Handle Ioctls from User mode
    //

    switch (ioControlCode) {

        case IOCTL_ISOPERF_START_ISO_IN_TEST:
                ISOPERF_KdPrint_MAXDEBUG(("ISOPERF_START_ISO_IN_TEST\n"));

        if (deviceExtension->Stopped == FALSE) {

                //Iso test routine will set the .information field in the irp
                //Iso test routine will not complete the Irp, so this should do it
                ntStatus = ISOPERF_StartIsoInTest (DeviceObject, Irp);  

            // We stomp on the status so the Irp that is doing the Ioctl succeeds.  
            // NOTE (kjaff) we may want to put some status here to tell app if ioctl 
            //                didn't start the test properly.
            Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Information = 0;

        }//if device is not stopped
        
                break;

        case IOCTL_ISOPERF_STOP_ISO_IN_TEST:
                ISOPERF_KdPrint_MAXDEBUG(("ISOPERF_STOP_ISO_IN_TEST\n"));

                ntStatus = ISOPERF_StopIsoInTest (DeviceObject, Irp);  

        // We stomp on the status so the Irp that is doing the Ioctl succeeds.  
        // NOTE (kjaff) we may want to put some status here to tell app if ioctl 
        //                didn't start the test properly.
            Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;
        
                break;

        case IOCTL_ISOPERF_GET_ISO_IN_STATS:

        if ((ioBuffer!=NULL) && (outputBufferLength>0)) {

            // GetStats function fills in the Irp Information field (nbr of bytes to copy)
                ntStatus = ISOPERF_GetStats (DeviceObject, Irp, ioBuffer, outputBufferLength);  
                Irp->IoStatus.Status = ntStatus;

        }else{
            Irp->IoStatus.Status = ntStatus = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;          
        }
                break;

        case IOCTL_ISOPERF_SET_DRIVER_CONFIG:

                ISOPERF_KdPrint_MAXDEBUG(("IOCTL_ISOPERF_SET_DRIVER_CONFIG\n"));
                
        if ((ioBuffer!=NULL) && (inputBufferLength>0)) {

            // SetDriverConfig function fills in the Irp Information field (nbr of bytes to copy)
                ntStatus = ISOPERF_SetDriverConfig (DeviceObject, Irp, ioBuffer, inputBufferLength);  
                Irp->IoStatus.Status = ntStatus;

        }else{
            Irp->IoStatus.Status = ntStatus = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;          
        }
                break;

        case IOCTL_ISOPERF_WAIT_FOR_ERROR:
        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;              
            break;

        default:                        
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;                        
    }  

        ntStatus = Irp->IoStatus.Status;

    ISOPERF_KdPrint_MAXDEBUG (("Compltng Irp w/ IoStatus.Status=%X | .Inf = %X | ntSt=%X\n",
                        Irp->IoStatus.Status, Irp->IoStatus.Information, ntStatus));

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    return ntStatus;                       
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\iso.c ===
/***************************************************************************

Copyright (c) 1995  Microsoft Corporation

Module Name:

        iso.c

Abstract:


Environment:

        kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

****************************************************************************/

#define DRIVER

#pragma warning(disable:4214) //  bitfield nonstd
#include "wdm.h"
#pragma warning(default:4214) 

#include "stdarg.h"
#include "stdio.h"

#pragma warning(disable:4200) //non std struct used
#include "usbdi.h"
#pragma warning(default:4200)

#include "usbdlib.h"
#include "usb.h"

#include "ioctl.h"
#include "isoperf.h"
#include "iso.h"

#define MAX_URBS_PER_PIPE 16 

UCHAR ucIsoInterface        = 0;

// Memory Leak detection global counters
ULONG gulBytesAllocated             = 0;
ULONG gulBytesFreed                 = 0;

NTSTATUS
ISOPERF_RefreshIsoUrb(
    PURB urb,
    USHORT packetSize,
    USBD_PIPE_HANDLE pipeHandle,
    PVOID pvDataBuffer,
    ULONG ulDataBufferLen
    )
/*++
Routine Description:
    Refreshes an Iso Usb Request Block in prep for resubmission to USB stack.
                
Arguments:
        urb         - pointer to urb to refresh
        packetsize  - max packet size for the endpoint for which this urb is intended
        pipeHandle  - Usbd pipe handle for the Urb
        pvDataBuff  - pointer to a data buffer that will contain data or will receive data
        ulDataBufLen- length of data buffer
        
Return Value:
    NT status code:
        STATUS_SUCCESS indicates Urb successfully refreshed
        Other status codes indicate error (most likely is a bad parameter passed in, which
        would result in STATUS_INVALID_PARAMETER to be returned)

--*/
{
    NTSTATUS ntStatus   = STATUS_SUCCESS;
    ULONG siz           = 0;
    ULONG i             = 0;
    ULONG numPackets    = 0;
    
    // Calculate the number of packets in this buffer
    numPackets = ulDataBufferLen/packetSize;

    // Adjust num packets by one if data buffer can accommodate it
    if (numPackets*packetSize < ulDataBufferLen) {
        numPackets++;
    }
    
    //
    // Use macro from provided by stack to figure out Urb length for given size of packets.  This is
    // necessary since Urb for iso transfers depends on the number of packets in the data buffer
    // since per-packet information is passed on the usbd interface
    //
    siz = GET_ISO_URB_SIZE(numPackets);

    // Clear out any garbage that may have gotten put in the urb by the last transfer
    RtlZeroMemory(urb, siz);

    // Now fill in the Urb
    urb->UrbIsochronousTransfer.Length               = (USHORT) siz;
    urb->UrbIsochronousTransfer.Function             = URB_FUNCTION_ISOCH_TRANSFER;
    urb->UrbIsochronousTransfer.PipeHandle           = pipeHandle;
    urb->UrbIsochronousTransfer.TransferFlags        = USBD_TRANSFER_DIRECTION_IN;
    urb->UrbIsochronousTransfer.TransferBufferMDL    = NULL;
    urb->UrbIsochronousTransfer.TransferBuffer       = pvDataBuffer;
    urb->UrbIsochronousTransfer.TransferBufferLength = numPackets * packetSize;

    ASSERT (ulDataBufferLen >= numPackets*packetSize);
    
    // This flag tells the stack to start sending/receiving right away
    urb->UrbIsochronousTransfer.TransferFlags       |= USBD_START_ISO_TRANSFER_ASAP;
    urb->UrbIsochronousTransfer.StartFrame           = 0;

    urb->UrbIsochronousTransfer.NumberOfPackets      = numPackets;
    urb->UrbIsochronousTransfer.ReservedMBZ          = 0;

    for (i=0; i< urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
        urb->UrbIsochronousTransfer.IsoPacket[i].Offset
                    = i * packetSize;
    }//for

    return ntStatus;

}//ISOPERF_RefreshIsoUrb


NTSTATUS
ISOPERF_IsoInCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:
    This is the completion routine that is called at the end of an iso Irp/Urb.  It is
    called when the Usb stack completes the Irp.

    NOTE: IoCompletion routine always runs at IRQL DISPATCH_LEVEL. 
    
Arguments:
    DeviceObject - pointer to the device object that represents this USB iso test device
                   DeviceObject is obtained from context due to old, old bug
                   in initial WDM implemenations
    Irp          - pointer to the Irp that was completed by the usb stack
    Context      - caller-supplied context that is passed in for use by this completion routine

    
Return Value:

    NT status code

--*/
{
    PIsoTxterContext                pIsoContext     = Context;
    PDEVICE_OBJECT                  myDeviceObject  = pIsoContext->DeviceObject;
    PDEVICE_EXTENSION               deviceExtension = myDeviceObject->DeviceExtension;
    pConfig_Stat_Info               pStatInfo       = deviceExtension->pConfig_Stat_Information;
    PIO_STACK_LOCATION              nextStack       = NULL;
    PURB                            urb             = pIsoContext->urb;
    PISOPERF_WORKITEM               isoperfWorkItem = NULL;
    PDEVICE_EXTENSION               MateDeviceExtension = NULL;
    ULONG                                                       unew,lnew,uold,lold;
    char *                          pcWork          = NULL; //a worker pointer
    ULONG                           i               = 0;
    char                            tempStr[32];
    
    ISO_ASSERT (pIsoContext != NULL);
    ISO_ASSERT (pStatInfo != NULL);
    ISO_ASSERT (deviceExtension != NULL);
    
    ISOPERF_KdPrint_MAXDEBUG (("In IsoInCompletionRoutine %x %x %x\n",
                                DeviceObject, Irp, Context));

                                
    // Check the USBD status code and only proceed in resubmission if the Urb was successful
    // or if the device extension flag that indicates the device is gone is FALSE
    if ( (USBD_SUCCESS(urb->UrbHeader.Status))  && ((deviceExtension->StopTransfers) == FALSE) ) {

                ISOPERF_GetUrbTimeStamp (urb, &lold, &uold);    //Get the Urb's timestamp
                
                GET_PENTIUM_CLOCK_COUNT(unew,lnew);                             //Get the time now

                pStatInfo->ulUrbDeltaClockCount = lnew-lold;    //Compute & store the delta
                
        // Check that data is incrementing from last data pattern received on this pipe
        if ((ISOPERF_IsDataGood(pIsoContext))== TRUE) {

                        // Data was good
            pStatInfo->ulSuccessfulIrps++;
            pStatInfo->ulBytesTransferredIn += pIsoContext->ulBufferLen;
            
        } else {

            // An error occured, so stop the test by setting the flag to stop the test 
            deviceExtension->bStopIsoTest = TRUE;
            deviceExtension->ulCountDownToStop = 0;

                        // Put this information in the status area for the device so the app can see it when it asks
            pStatInfo->erError = DataCompareFailed;
            pStatInfo->bStopped = 1;
         
        }//else data was bad
        
        if ( (deviceExtension->bStopIsoTest == TRUE) && (deviceExtension->ulCountDownToStop > 0) ) {

            // User has requested a stop to the Iso Test so, decrement the countdown value
            (deviceExtension->ulCountDownToStop)--;
        
        }//if user requested a stop
       
        // If device extension says to keep going on this test then continue on        
        if ((deviceExtension->ulCountDownToStop) > 0) {
        
            // Refresh this Urb before we resubmit it to the stack
            ISOPERF_RefreshIsoUrb (pIsoContext->urb,
                                   pIsoContext->PipeInfo->MaximumPacketSize,
                                   pIsoContext->PipeInfo->PipeHandle,
                                   pIsoContext->pvBuffer,
                                   pIsoContext->ulBufferLen
                                  );

            // If this iso in device has a mate, then start a thread to have it use this data buffer
            if (deviceExtension->MateDeviceObject) {

                MateDeviceExtension = deviceExtension->MateDeviceObject->DeviceExtension;

                // Check if the mate device is up and running
                if ( (MateDeviceExtension->Stopped == FALSE) && (MateDeviceExtension->StopTransfers == FALSE) ) {

                    //start a Work Item to use this buffer which will only do so when the buffer has arrived
                    isoperfWorkItem = ISOPERF_ExAllocatePool(NonPagedPool, sizeof(ISOPERF_WORKITEM),&gulBytesAllocated);

                    isoperfWorkItem->DeviceObject = deviceExtension->MateDeviceObject;
                    isoperfWorkItem->pvBuffer     = pIsoContext->pvBuffer;
                    isoperfWorkItem->ulBufferLen  = pIsoContext->ulBufferLen;
                    isoperfWorkItem->bFirstUrb    = pIsoContext->bFirstUrb;
                    isoperfWorkItem->InMaxPacket  = pIsoContext->PipeInfo->MaximumPacketSize;
                    isoperfWorkItem->ulNumberOfFrames = urb->UrbIsochronousTransfer.NumberOfPackets;

                                        // Call the OUT pipe transfer routine
                    ISOPERF_StartIsoOutTest (isoperfWorkItem);

                    // Since the firstUrb flag is used to tell the outpipe whether it's a virgin or not, 
                    // and since this Urb can be recycled through here again, we have to de-virginize the 
                    // flag so this Urb doesn't always cause the outpipe to think it's dealing with a virgin Urb.
                    if (pIsoContext->bFirstUrb == TRUE) {
                        pIsoContext->bFirstUrb = FALSE;
                    }//if this was the first Urb
                    
                }//if mate device is ok

            }//if there is a mate device in the system (that this driver runs)

            // Get the next lower driver's stack
            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);

            //
            // Set up the next lower driver's stack parameters which is where that
            // driver will go to get its parameters for this internal IOCTL Irp
            //
            nextStack->Parameters.Others.Argument1  = urb;
            nextStack->MajorFunction                = IRP_MJ_INTERNAL_DEVICE_CONTROL;
            nextStack->Parameters.DeviceIoControl.IoControlCode =
                IOCTL_INTERNAL_USB_SUBMIT_URB;

            IoSetCompletionRoutine(Irp,
                    ISOPERF_IsoInCompletion,
                    pIsoContext,
                    TRUE,
                    TRUE,
                    FALSE); //INVOKE ON CANCEL

                        // Time stamp the Urb before we send it down the stack
                        ISOPERF_TimeStampUrb (urb, &unew, &lnew);
                        
            // Call the driver
            IoCallDriver (deviceExtension->StackDeviceObject,
                          Irp);
                          
            // Tell the IO Manager that we want to handle this Irp from here on...
            return (STATUS_MORE_PROCESSING_REQUIRED);

        } else {

            ISOPERF_KdPrint (("Stopped Iso test (did not resubmit Irp/Urb due to device extension flag)\n"));

        }/* else the tests should be stopped */
        
    }//if Urb status was successful

    // Otherwise, the Urb was unsuccessful
    else {
        pStatInfo->erError = UsbdErrorInCompletion;
        pStatInfo->ulUnSuccessfulIrps++;

        FIRE_OFF_CATC;

        if (!(USBD_SUCCESS(urb->UrbHeader.Status))) {
            ISOPERF_KdPrint (("Urb unsuccessful (status: %#x)\n",urb->UrbHeader.Status));

            // Dump out the status for the packets
            for (i=0; i< urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
                ISOPERF_KdPrint (("Packet %d: Status: [%#X]\n",
                                    i,
                                    urb->UrbIsochronousTransfer.IsoPacket[i].Status));
                                    
                // Put the last known bad packet status code into this space in the stat area
                if (!USBD_SUCCESS(urb->UrbIsochronousTransfer.IsoPacket[i].Status)) {
                    pStatInfo->UsbdPacketStatCode = urb->UrbIsochronousTransfer.IsoPacket[i].Status;
                }//if hit a fail code                 
                sprintf (tempStr, "Data: %x",  *((PULONG)(urb->UrbIsochronousTransfer.TransferBuffer)));
                ISOPERF_KdPrint (("First data in buffer: %s\n",tempStr));
                
            }//for all the packets
                
        }else {
            ISOPERF_KdPrint (("Urb successful, but StopTransfers flag is set (%d)\n",deviceExtension->StopTransfers));
        }
        
            
    }//Urb was unsuccessful, so don't repost it and fall thru to cleanup code

    // Clean up section.  This only executes if:
    //  --Urb (bus transfer) was unsuccessful (stop the test)
    //  --Buffer didn't look right (a hiccup was detected, etc.)
    //  --User requested tests to stop
    ISOPERF_KdPrint (("Stopping Iso In Stream and Cleaning Up...U:%x|C:%x|B:%x\n", 
                                        urb,
                                        pIsoContext,
                                        pIsoContext->pvBuffer));    
                                        
    // Free up the memory created for this transfer that we are retiring
    if (urb) {
        // We can't free the Urb itself, since it has some junk before it, so we have to roll back the 
        // pointer to get to the beginning of the block that we originally allocated, and then try to free it.
        pcWork = (char*)urb;                        //get the urb
        urb = (PURB) (pcWork - (2*sizeof(ULONG)));  //the original pointer is 2 DWORDs behind the Urb
        ISOPERF_KdPrint (("Freeing urb %x\n",urb)); 
        ISOPERF_ExFreePool (urb, &gulBytesFreed);   //Free that buffer
    }//if
    
    if (pIsoContext) {

        // Free the data buffer
        if (pIsoContext->pvBuffer) {
            ISOPERF_KdPrint (("Freeing databuff %x\n",pIsoContext->pvBuffer));
            ISOPERF_ExFreePool (pIsoContext->pvBuffer, &gulBytesFreed);
        }
            
        // Free the Iso Context
        ISOPERF_KdPrint (("Freeing pIsoContext %x\n",pIsoContext));
        ISOPERF_ExFreePool (pIsoContext, &gulBytesFreed);
        
    }//if valid Iso Context

    //Decrement the number of outstanding Irps since this one is being retired
    (deviceExtension->ulNumberOfOutstandingIrps)--;
    
    // If this is the last Irp we are retiring, then the device should be marked as not busy
    if (deviceExtension->ulNumberOfOutstandingIrps == 0) {
        deviceExtension->DeviceIsBusy = FALSE;
        pStatInfo->bDeviceRunning = FALSE;
    }//if not irps left outstanding on this device

    //Free the IoStatus block that we allocated for  this Irp
    if (Irp->UserIosb) {
        ISOPERF_KdPrint (("Freeing My IoStatusBlock %x\n",Irp->UserIosb));
        ISOPERF_ExFreePool(Irp->UserIosb, &gulBytesFreed);
    } else {
        //Bad thing...no IoStatus block pointer??
        ISOPERF_KdPrint (("ERROR: Irp's IoStatus block is apparently NULL!\n"));
        TRAP();
    }//else bad iostatus pointer
    
        //Free the Irp here and return STATUS_MORE_PROCESSING_REQUIRED instead of SUCCESS
    ISOPERF_KdPrint (("Freeing Irp %x\n",Irp));
        IoFreeIrp(Irp);
        
    // Tell the IO Manager that we want to handle this Irp from here on...
    ISOPERF_KdPrint (("Returning STATUS_MORE_PROCESSING_REQUIRED from IsoInCompletion\n"));
    return (STATUS_MORE_PROCESSING_REQUIRED);

}//ISOPERF_IsoInCompletion


PURB
ISOPERF_BuildIsoRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION pPipeInfo,
    IN BOOLEAN Read,
    IN ULONG length,
    IN ULONG ulFrameNumber,
    IN PVOID pvTransferBuffer,
    IN PMDL pMDL
    )
/*++
Routine Description:
    Allocates and initializes most of a URB.  The caller must initialize the FLAGS field 
    with any further flags they desire after this function is called.

Arguments:
    DeviceObject - pointer to the device extension for this instance of the device
    pPipeInfo    -   ptr to pipe descr for which to build the iso request (urb)
    Read         -   if TRUE, it's a read, FALSE it's a write
    length       -   length of the data buffer or MDL, used for packetizing the buffer for iso txfer
    ulframeNumber- if non-zero, use this frame number to build in the urb and don't set flags
    pvTransferBuffer -  Non-NULL: this is the TB ;  NULL: an MDL is specified
    ulTransferBufferLength -  len of buffer specified in pvTransferBuffer
    pMDL        - if an MDL is being used, this is a ptr to it
    
Return Value:
    Almost initialized iso urb.  Caller must fill in the flags after this fn is called.
    
--*/
{
    ULONG siz;
    ULONG packetSize,numPackets, i;
    PURB urb = NULL;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
        char * pcWork = NULL;
    ISO_ASSERT(pPipeInfo!=NULL)

    packetSize = pPipeInfo->MaximumPacketSize;

    numPackets = length/packetSize;
    if (numPackets*packetSize < length) {
        numPackets++;
    }

    siz = GET_ISO_URB_SIZE(numPackets);

    //Add room for a URB time stamp at the beginning of the Urb by allocating more than
    //siz by 4 DWORDs.  The pentium clock count macro can then be used by the caller of 
    //this routine to fill in the clock count stamp.  We allocate an extra 2 DWORDs more than
    //we need to allow some room for stuff to put at the end of the URB in the future.
    pcWork = ISOPERF_ExAllocatePool(NonPagedPool, (siz+(4*sizeof(ULONG))), &gulBytesAllocated);

    urb = (PURB) (pcWork + (2*sizeof(ULONG)));          //Push pass the clock count area to the urb area

    if (urb) {
        RtlZeroMemory(urb, siz);

        urb->UrbIsochronousTransfer.Length =                (USHORT) siz;
        urb->UrbIsochronousTransfer.Function =              URB_FUNCTION_ISOCH_TRANSFER;
        urb->UrbIsochronousTransfer.PipeHandle =            pPipeInfo->PipeHandle;
        urb->UrbIsochronousTransfer.TransferFlags =         Read ? USBD_TRANSFER_DIRECTION_IN : 0;

        urb->UrbIsochronousTransfer.TransferBufferMDL =     pMDL;  
        urb->UrbIsochronousTransfer.TransferBuffer =        pvTransferBuffer;
        urb->UrbIsochronousTransfer.TransferBufferLength =  length;
        urb->UrbIsochronousTransfer.Function =              URB_FUNCTION_ISOCH_TRANSFER;

        if (ulFrameNumber==0) {
            //No frame number specified, just start asap
            urb->UrbIsochronousTransfer.TransferFlags |= USBD_START_ISO_TRANSFER_ASAP;
        }else{
            //use specific starting framenumber & don't set (unset) the asap flag
            urb->UrbIsochronousTransfer.StartFrame = ulFrameNumber;
            urb->UrbIsochronousTransfer.TransferFlags &= ~USBD_START_ISO_TRANSFER_ASAP;
        }//if framenumber was specified

        urb->UrbIsochronousTransfer.NumberOfPackets = numPackets;
        urb->UrbIsochronousTransfer.ReservedMBZ = 0;

                // Fill in the packet size array
        for (i=0; i< urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
            urb->UrbIsochronousTransfer.IsoPacket[i].Offset
                        = i * packetSize;
        } //for

    }//if urb

    return urb;
}

    
PVOID 
ISOPERF_GetBuff (
                PDEVICE_OBJECT DeviceObject,
                ULONG          ulPipeNumber,
                ULONG          ulInterfaceNumber,
                ULONG          ulNumberOfFrames,
                PULONG         pulBufferSize
                )
/*++
ISOPERF_GetBuff

Routine Description:
    Creates a buffer as specified by input params.   If the input params specify a buffer
    that is too big to be submitted to this pipe, then this request will fail.
    
Arguments:
    DeviceObject - pointer to the device extension for this instance of the device

Return Value:
        Returns a pointer to the allocated data buffer
    
--*/
{
    PDEVICE_EXTENSION deviceExtension = NULL;
    ULONG             ulMaxPacketSize = 0;
    ULONG             ulBufferSize    = 0;
    ULONG             ulMaxTxferSize  = 0;    
    PVOID             pvBuffer        = NULL;
    
    deviceExtension = DeviceObject->DeviceExtension;
    ulMaxPacketSize = deviceExtension->Interface[ulInterfaceNumber]->Pipes[ulPipeNumber].MaximumPacketSize;
    ulMaxTxferSize  = deviceExtension->Interface[ulInterfaceNumber]->Pipes[ulPipeNumber].MaximumTransferSize;

    ulBufferSize    = *pulBufferSize = ulMaxPacketSize * ulNumberOfFrames;

    // Check if this buffer is too big to submit on this pipe (per its initial setup)
    if (ulBufferSize > ulMaxTxferSize) {
        *pulBufferSize = 0;
        return (NULL);
    } else {
        return ( ISOPERF_ExAllocatePool (NonPagedPool, ulBufferSize, &gulBytesAllocated) );
    }

}//ISOPERF_GetBuff

ULONG
ISOPERF_StartIsoInTest (
                PDEVICE_OBJECT DeviceObject,
                PIRP           pIrp
               )
/*++
ISOPERF_StartIsoInTest

Routine Description:
    Starts the Iso In Test
    
Arguments:
    DeviceObject - pointer to the device extension for this instance of the device
    pIrp         - pointer to the Irp from the Ioctl
    
Return Value:
    
--*/


{
    NTSTATUS                    ntStatus                = STATUS_INVALID_PARAMETER;
    PDEVICE_EXTENSION           deviceExtension         = NULL;
    PURB                        urb                 = NULL;
    ULONG                       ulFrameNumber           = 0;
    ULONG                       UrbNumber               = 0;
    ULONG                       NumberOfFrames          = 0;
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo          = NULL;
    PUSBD_PIPE_INFORMATION      pUsbdPipeInfo           = NULL;
    PUSBD_INTERFACE_INFORMATION pMateInterfaceInfo  = NULL;
    PUSBD_PIPE_INFORMATION      pMateUsbdPipeInfo   = NULL;
    ULONG                       ulBufferSize            = 0;
    IsoTxferContext *           pIsoContext             = NULL;
    PVOID                       pvBuff                  = NULL;
    BOOLEAN                     bFirstUrb               = FALSE;
    BOOLEAN                     bHaveMate               = FALSE;
    ULONG                       Upper, Lower;
    pConfig_Stat_Info           configStatInfo          = NULL;
    ULONG                       Max_Urbs_Per_Pipe   = 0; 
    PDEVICE_OBJECT              mateDeviceObject    = NULL;
    PDEVICE_EXTENSION           mateDeviceExtension = NULL;
    pConfig_Stat_Info           mateConfigStatInfo  = NULL;
        char *                                          pcWork                      = NULL;

    ISOPERF_KdPrint (("Enter ISOPERF_StartIsoInTest (%x) (%x)\n",DeviceObject, pIrp));
    
    deviceExtension     = DeviceObject->DeviceExtension;
    pInterfaceInfo      = deviceExtension->Interface[ucIsoInterface];
    ISO_ASSERT (pInterfaceInfo!=NULL)
    
    //make sure this is an IN Iso device
    if (deviceExtension->dtTestDeviceType != Iso_In_With_Pattern) {
        ISOPERF_KdPrint (("Error: not an Iso IN device! (%d)\n",deviceExtension->dtTestDeviceType));
        TRAP();
        return (ULONG)STATUS_INVALID_PARAMETER;
    }//if it's NOT an ISO IN then bounce it back

        // Get the config info for the In Iso Device
    configStatInfo = deviceExtension->pConfig_Stat_Information;
    ASSERT (configStatInfo != NULL);

    // Check out the offset provided to make sure it's not too big
    if (configStatInfo->ulFrameOffset >= USBD_ISO_START_FRAME_RANGE) {
        ISOPERF_KdPrint (("Error: Detected a FrameOffset Larger than allowed! (%d)\n",configStatInfo->ulFrameOffset));
        TRAP();
        return (ULONG)STATUS_INVALID_PARAMETER;
    }//if bad frame offset

    if (configStatInfo) {
        Max_Urbs_Per_Pipe = configStatInfo->ulMax_Urbs_Per_Pipe;
        NumberOfFrames    = configStatInfo->ulNumberOfFrames;
    }//if configstatinfo is not null
        
        // Only set up the output device if the config info indicates a desire to do the In->Out test
        if (configStatInfo->ulDoInOutTest) {
            //If there is an OUT Iso device, and we are trying to do a IN->OUT test, then set that device object up
            ntStatus = ISOPERF_FindMateDevice (DeviceObject);

            if (ntStatus == STATUS_SUCCESS) {
                bHaveMate = TRUE;
                mateDeviceObject = deviceExtension->MateDeviceObject;
                mateDeviceExtension = mateDeviceObject->DeviceExtension;
                pMateInterfaceInfo = mateDeviceExtension->Interface[ucIsoInterface];
                mateConfigStatInfo = mateDeviceExtension->pConfig_Stat_Information;
                mateConfigStatInfo->ulFrameOffset = configStatInfo->ulFrameOffsetMate;
                
            }//if status success        

            // Reset the pipe on the mate device if it's also here
            // NOTE: we only reset the first pipe on the mate device here
            if (bHaveMate == TRUE) {
                ASSERT (pMateInterfaceInfo!=NULL);
                pMateUsbdPipeInfo = &(pMateInterfaceInfo->Pipes[0]);
                ASSERT (pMateUsbdPipeInfo != NULL);
                ISOPERF_ResetPipe(deviceExtension->MateDeviceObject,pMateUsbdPipeInfo);
            }// if mate
        } else {
                // Set the mate dev obj to NULL so completion routine knows not to use it
                deviceExtension->MateDeviceObject = NULL;
        }//if In->Out test is not being requested
        
    // Reset the first pipe on the IN device
    pUsbdPipeInfo= &(pInterfaceInfo->Pipes[0]);
    ISOPERF_ResetPipe(DeviceObject, pUsbdPipeInfo);

    // Untrigger the CATC so if we trigger it later it will go off
    RESTART_CATC;

    // Get the current frame number 
    ulFrameNumber = ISOPERF_GetCurrentFrame(DeviceObject);

    //Save away the current frame number so the app can peek at it
    configStatInfo->ulFrameNumberAtStart = ulFrameNumber;

    // See what the user wants to do wrt starting frame number by looking at the config info
    if (configStatInfo->ulFrameOffset == 0) {
        // This means start ASAP
        ulFrameNumber = 0;
    }else {
        //Add the offset that the User wants to add to this frame number (it better be less than 1024!)
        ulFrameNumber += configStatInfo->ulFrameOffset;
    } //else

    //Save away the starting frame number so the app can peek at it
    configStatInfo->ulStartingFrameNumber = ulFrameNumber;

    // Set flag to indicate first Urb
    bFirstUrb = TRUE;
    
    // Get the pipe info for the first pipe
    pUsbdPipeInfo= &(pInterfaceInfo->Pipes[0]);

    // Build all the urbs for each pipe (note we send multiple Urbs down the stack)
    for (UrbNumber=0;UrbNumber<Max_Urbs_Per_Pipe;UrbNumber++) {

        //
        // Calculate the buffer size required and get a pointer to the buffer
        // Note:  this buffer needs to be freed when the StopIsoInTest ioctl is 
        //        received.  The completion routine will free the buffer when it 
        //        sees that it is time to stop the iso in test (the pointer is grabbed
        //        from the irp).
        //
        pvBuff = ISOPERF_GetBuff (DeviceObject,
                                  0,                    // pipe number
                                  0,                    // interface number
                                  NumberOfFrames,    // Nbr of mS worth of data to post
                                  &ulBufferSize);

  
        ISO_ASSERT (pvBuff!=NULL);
 
        //
        // Create the context for this transfer out of the nonpaged pool since it survives
        // this routine and is used in the completion routine
        //
        pIsoContext = ISOPERF_ExAllocatePool (NonPagedPool, sizeof (IsoTxferContext), &gulBytesAllocated);

        //build the urb
        urb =    ISOPERF_BuildIsoRequest(DeviceObject,
                                         pUsbdPipeInfo,     //Pipe info struct
                                         TRUE,              //READ
                                         ulBufferSize,      //Data buffer size
                                         bFirstUrb ? ulFrameNumber : 0, //Frame Nbr
                                         pvBuff,            //Data buffer
                                         NULL               //no MDL used
                                        );
        if (urb) {

            // Fill in the iso context
            pIsoContext->urb           = urb;
            pIsoContext->DeviceObject  = DeviceObject;
            pIsoContext->PipeInfo      = pUsbdPipeInfo;
            pIsoContext->irp           = pIrp;
            pIsoContext->pvBuffer      = pvBuff;
            pIsoContext->ulBufferLen   = ulBufferSize;
            pIsoContext->PipeNumber    = UrbNumber;
            pIsoContext->NumPackets    = urb->UrbIsochronousTransfer.NumberOfPackets;
            pIsoContext->bFirstUrb     = bFirstUrb;
            
            ISOPERF_KdPrint_MAXDEBUG (("Urb %d pvBuff %x ulBuffSz %d NumPackts %d pIsoCont %x  Urb: %x\n",
                                        UrbNumber,pvBuff,ulBufferSize,pIsoContext->NumPackets,pIsoContext,urb));

                        // Time stamp the Urb before we send it down the stack
                        ISOPERF_TimeStampUrb(urb, &Lower, &Upper);

            //Create our own Irp for the device and call the usb stack w/ our urb/irp
            ntStatus = ISOPERF_CallUSBDEx ( DeviceObject, 
                                            urb, 
                                            FALSE,                   //Don't block
                                            ISOPERF_IsoInCompletion, //Completion routine
                                            pIsoContext,             //pvContext
                                            FALSE);                  //don't want timeout 


            // Set the busy flag if the Urb/Irp succeed
            if (NT_SUCCESS(ntStatus)) {
                deviceExtension->DeviceIsBusy = TRUE;
                //Set to some huge value; ioctl to stop the test will set this to a smaller value
                deviceExtension->ulCountDownToStop = 0xFFFF; 
                deviceExtension->bStopIsoTest = FALSE;
                deviceExtension->StopTransfers = FALSE;

                configStatInfo->erError         = NoError;
                configStatInfo->bDeviceRunning  = TRUE;
                
            } else {

                deviceExtension->DeviceIsBusy = FALSE;
                deviceExtension->bStopIsoTest = TRUE;
                deviceExtension->StopTransfers = TRUE;

                configStatInfo->erError         = ErrorInPostingUrb;
                configStatInfo->UrbStatusCode   = urb->UrbHeader.Status;
                
                if (bFirstUrb) {
                    //since this is the first Urb,  we know for sure the device isn't running
                    configStatInfo->bDeviceRunning  = FALSE;
                    configStatInfo->bStopped        = TRUE;                      
                }//if first Urb
                
            } //else FAILED calling USB stack
                
        }//if urb[UrbNumber] exists

        // Reset the flag that indicates it's the first Urb
        bFirstUrb = FALSE;
        
    }//for all the urbs per pipe (UrbNumber)


    ISOPERF_KdPrint (("Exit ISOPERF_StartIsoInTest (%x)\n",ntStatus));

    return ntStatus;
    
}//StartIsoInTest


NTSTATUS
ISOPERF_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN USBD_PIPE_INFORMATION * pPipeInfo
    )
/*++

Routine Description:
    Resets the given Pipe by calling a USBD function
    
Arguments:
    DeviceObject - pointer to dev obj for this instance of usb device
    pPipeInfo    - pointer to usbd pipe info struct
    
Return Value:

--*/
{
    NTSTATUS ntStatus;
    PURB urb;
    PDEVICE_EXTENSION DeviceExtension = DeviceObject->DeviceExtension;
    
    ISO_ASSERT (pPipeInfo!=NULL)
    
    urb = ISOPERF_ExAllocatePool(NonPagedPool,((sizeof(struct _URB_PIPE_REQUEST))+64), &gulBytesAllocated);

    if (urb) {

    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
    urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
    urb->UrbPipeRequest.PipeHandle = pPipeInfo->PipeHandle;

    ntStatus = ISOPERF_CallUSBD   ( DeviceObject,
                                    urb);

    } else {
            ntStatus = STATUS_NO_MEMORY;
    }

    ISOPERF_KdPrint (("Freeing urb in RESET_PIPE: %x\n",urb));
    
    // Free the urb we created since we blocked on this function
    if (urb) {
        ISOPERF_ExFreePool (urb, &gulBytesFreed);
    }//if urb
    
    return ntStatus;
}


ULONG
ISOPERF_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
ISOPERF_GetCurrentFrame

Arguments:
    DeviceExtension - pointer to the device extension for this instance 

Return Value:
        Current Frame Number
--*/
{
    NTSTATUS ntStatus;
        PURB urb;
        ULONG currentUSBFrame = 0;

    ISOPERF_KdPrint_MAXDEBUG (("In ISOPERF_GetCurrentFrame: (%x)\n",DeviceObject));
    
        urb = ISOPERF_ExAllocatePool(NonPagedPool,sizeof(struct _URB_GET_CURRENT_FRAME_NUMBER), &gulBytesAllocated);
                                                 
        if (urb) {

                urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_GET_CURRENT_FRAME_NUMBER);
                urb->UrbHeader.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;

                ntStatus = ISOPERF_CallUSBD   ( DeviceObject, 
                                                urb
                                                );

                if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(URB_STATUS(urb))) {
                        currentUSBFrame = urb->UrbGetCurrentFrameNumber.FrameNumber;

            // Since a ZERO for the USBFrameNumber indicates an error, and if it really is zero by chance, then just bump it by one
                        if (currentUSBFrame==0) {
                            currentUSBFrame++;
                        }
            }

                ISOPERF_ExFreePool(urb, &gulBytesFreed);
                
        } else {
                ntStatus = STATUS_NO_MEMORY;            
    }           

    ISOPERF_KdPrint_MAXDEBUG (("Exit ISOPERF_GetCurrentFrame: (%x)\n",currentUSBFrame));

        return currentUSBFrame;                 
}       


NTSTATUS 
ISOPERF_StopIsoInTest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
Routine Description:
        Stops the Iso IN test by setting fields in the device extension so that the completion
        routine no longer does checks and resubmits Irps to keep the iso stream running.

        This call causes no USB stack calls nor USB bus traffic.
        
Arguments:
    DeviceObject - pointer to the device extension for this instance of the device
        Irp                      - pointer to the Irp created in the Ioctl
        
Return Value:
        Always returns NT status of STATUS_SUCCESS
        
--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    ULONG Upper, Lower;

    GET_PENTIUM_CLOCK_COUNT(Upper,Lower);
    
    ISOPERF_KdPrint (("Enter StopIsoInTest\n"));
    ISOPERF_KdPrint (("Upper:Lower -- %ld : %ld\n",Upper,Lower));
    
    ISO_ASSERT (deviceExtension != NULL);

    deviceExtension->bStopIsoTest = TRUE;
    deviceExtension->ulCountDownToStop = 100;
    
    ISOPERF_KdPrint (("Stopped: %d\n",          deviceExtension->Stopped));
    ISOPERF_KdPrint (("StopTransfers: %d\n",    deviceExtension->StopTransfers));
    ISOPERF_KdPrint (("DeviceIsBusy: %d\n",     deviceExtension->DeviceIsBusy));
    ISOPERF_KdPrint (("NeedCleanup: %d\n",      deviceExtension->NeedCleanup));
    ISOPERF_KdPrint (("bStopIsoTest: %d\n",     deviceExtension->bStopIsoTest));
    ISOPERF_KdPrint (("ulNumberOfOutstandingIrps: %d\n", deviceExtension->ulNumberOfOutstandingIrps));
    ISOPERF_KdPrint (("ulCountDownToStop: %d\n", deviceExtension->ulCountDownToStop));
   
    
    ISOPERF_KdPrint (("Exit StopIsoInTest\n"));
    
    return (STATUS_SUCCESS);    
}//ISOPERF_StopIsoInTest


BOOLEAN
ISOPERF_IsDataGood(PIsoTxterContext pIsoContext
)
/*++

Routine Description:
    Checks the data in the buffer for an incrementing pattern in every "maxpacketsize" granule
    of bytes.
    
Arguments:
    pIsoContext - pointer to the Iso context that contains what this routine needs to process the buffer
    
Return Value:
    TRUE - indicates buffer looks good
    FALSE - buffer has an error
    
--*/
{
    PUCHAR pchWork, pchEnd;
    UCHAR cCurrentValue, cNextValue;
    ULONG ulMaxPacketSize;
    
    pchWork = pIsoContext->pvBuffer;
    ulMaxPacketSize = pIsoContext->PipeInfo->MaximumPacketSize;
    
    if (pchWork==NULL) {
        ISOPERF_KdPrint (("Bad pchWork in IsDataGood (%x)\n",pchWork));
        return (FALSE);
    }

    if (ulMaxPacketSize >= 1024) {
        ISOPERF_KdPrint (("Bad MaxPacketSize in IsDataGood (%x)\n",ulMaxPacketSize));
        return (FALSE);
    }
        
    pchEnd = pchWork + ((pIsoContext->ulBufferLen) - ulMaxPacketSize);

    if (pchEnd > (pchWork + ((pIsoContext->NumPackets)*(ulMaxPacketSize)))) {
        ISOPERF_KdPrint (("Buffer Problem in IsDataGood: Base: %x | End: %x | NumPackts: %d | MaxPacktSz: %d\n",
                            pchWork, pchEnd, pIsoContext->NumPackets, ulMaxPacketSize));
    }
    
    ASSERT (pchEnd <= (pchWork + ((pIsoContext->NumPackets)*ulMaxPacketSize)));

    cCurrentValue = *pchWork;

    while (pchWork < pchEnd) {

        // Get the next frame's byte value
        cNextValue = *(pchWork + ulMaxPacketSize);
        
        if (cNextValue == (cCurrentValue + 1)) {
            //Success, go on to next packet
            pchWork+=ulMaxPacketSize; 
            cCurrentValue = *pchWork;
        }else{

            // Maybe this is the rollover case, so check for it and don't fail it if it is
            if (cNextValue==0) {
                if (cCurrentValue==0xFF) {
                    //Success, go on to next packet
                    pchWork+=ulMaxPacketSize; 
                    cCurrentValue = *pchWork;
                    continue;
                }
            }
                    
            ISOPERF_KdPrint (("Fail data compare: pchWork: %x | cNextValue: %x | *pchWork: %x | Base: %x\n",
                                pchWork, cNextValue, *pchWork, pIsoContext->pvBuffer));    
            FIRE_OFF_CATC;
            RESTART_CATC;
            return (FALSE);
        }
        
    } //while
        
    return (TRUE);
    
}//ISOPERF_IsDataGood



NTSTATUS
ISOPERF_GetStats (
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN OUT  pConfig_Stat_Info   pStatInfoOut,
    IN      ULONG               ulBufferLen
    )
/*++
Routine Description:
    Copies the existing Iso traffic counter values into buffer supplied by caller.  The 
    values of the counter variables are defined in IOCTL.H in the pIsoStats structure.
    
Arguments:
    DeviceObject - pointer to the device extension for this instance of the device
        Irp                      - pointer to the Irp created in the Ioctl
    pIsoStats    - pointer to buffer where stats will go
    ulBufferLen  - len of above output buffer
    
Return Value:
        NT status of STATUS_SUCCESS means copy was successful
        NT status of STATUS_INVALID_PARAMETER means a param (usually a pointer) was bad

--*/
{

    ULONG Upper, Lower;
    pConfig_Stat_Info pStatInfo       = NULL;
    NTSTATUS          ntStatus        = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    ISOPERF_KdPrint_MAXDEBUG (("In GetStats (%x) (%x) (%x) (%d)\n",
                       DeviceObject,Irp,pStatInfoOut,ulBufferLen));
                       
    ASSERT (deviceExtension != NULL);

    if (deviceExtension) {
        pStatInfo = deviceExtension->pConfig_Stat_Information;
    }

    ASSERT (pStatInfo!= NULL);

    GET_PENTIUM_CLOCK_COUNT(Upper,Lower);

    if ( (pStatInfoOut) && (ulBufferLen >= sizeof(Config_Stat_Info)) ) {

        // Only copy the stat info from the dev ext area if it exists
        if (pStatInfo) {
            memcpy (pStatInfoOut, pStatInfo, sizeof (Config_Stat_Info));
        }/* if dev ext's stat/config info exists */

        // Get the global mem alloc/free info
        pStatInfoOut->ulBytesAllocated = gulBytesAllocated; 
        pStatInfoOut->ulBytesFreed     = gulBytesFreed;

        // Get the current countdown value
        pStatInfoOut->ulCountDownToStop= deviceExtension->ulCountDownToStop;
        
        // Get the Pentium counter values
        pStatInfoOut->ulUpperClockCount=Upper;
        pStatInfoOut->ulLowerClockCount=Lower;

        // Get the device type
        pStatInfoOut->DeviceType = deviceExtension->dtTestDeviceType;

            Irp->IoStatus.Information       = sizeof (Config_Stat_Info);    

    } else {

        ntStatus = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;    
            
        }/* else */

        return (ntStatus);
        
}//ISOPERF_GetStats

NTSTATUS
ISOPERF_SetDriverConfig (
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN OUT  pConfig_Stat_Info   pConfInfoIn,
    IN      ULONG               ulBufferLen
    )
/*++
Routine Description:
    Sets the driver's test parameters.  These are only checked by this driver when the 
    Iso tests are started.  So, if a user mode app tries to set these after a test has started
    they will take effect on the next "start" of the test.    

Arguments:
    DeviceObject - pointer to the device extension for this instance of the device
        Irp                      - pointer to the Irp created in the Ioctl
    pIsoStats    - pointer to buffer where config info is located
    ulBufferLen  - len of above input buffer
    
Return Value:
        NT status of STATUS_SUCCESS means setting of params was successful
        NT status of STATUS_INVALID_PARAMETER means a param (usually a pointer) was bad

--*/
{
    pConfig_Stat_Info pDriverConfigInfo       = NULL;
    NTSTATUS          ntStatus        = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    
    ASSERT (deviceExtension != NULL);

    if (deviceExtension) {
        pDriverConfigInfo = deviceExtension->pConfig_Stat_Information;
    }else{
        ntStatus = STATUS_INVALID_PARAMETER;
    }//else bad dev ext
    
    ASSERT (pDriverConfigInfo!= NULL);

    if ( (pConfInfoIn) && (ulBufferLen >= sizeof(Config_Stat_Info)) ) {

        // Only copy the stat info from the dev ext area if it exists
        if (pDriverConfigInfo) {

            //Set the config info in the driver's config/stat area
            pDriverConfigInfo->ulNumberOfFrames     = pConfInfoIn->ulNumberOfFrames;
            pDriverConfigInfo->ulMax_Urbs_Per_Pipe  = pConfInfoIn->ulMax_Urbs_Per_Pipe;
                        pDriverConfigInfo->ulDoInOutTest                = pConfInfoIn->ulDoInOutTest;
            pDriverConfigInfo->ulFrameOffset        = pConfInfoIn->ulFrameOffset;
            pDriverConfigInfo->ulFrameOffsetMate    = pConfInfoIn->ulFrameOffsetMate;
                    
            ISOPERF_KdPrint (("Setting Driver Config-Number of Frames: %d | MaxUrbsPerPipe: %d | DoInOut: %d | FrameOffset %d | MateOffset %d\n",
                              pDriverConfigInfo->ulNumberOfFrames,
                              pDriverConfigInfo->ulMax_Urbs_Per_Pipe,
                              pDriverConfigInfo->ulDoInOutTest,
                              pDriverConfigInfo->ulFrameOffset,
                              pDriverConfigInfo->ulFrameOffsetMate));
                              
        }/* if dev ext's stat/config info exists */
        else {
            ntStatus = STATUS_INVALID_PARAMETER;
        }//else bad dev extension
        
            Irp->IoStatus.Information       = 0;    

    } else {

        ntStatus = STATUS_INVALID_PARAMETER;
            Irp->IoStatus.Information = 0;    
            
        }/* else bad buffer passed in (pointer was bad, or length was not correct) */

        return (ntStatus);
        
}//ISOPERF_SetDriverConfig

NTSTATUS
ISOPERF_FindMateDevice (
    PDEVICE_OBJECT DeviceObject
    )
/*++
    Searches the linked list of device objects looking for the long lost mate device for the
    given device object.  By practicing safe device mating rituals (ie., checking that the device
    object is a known type, etc.) it then puts the mate's device object pointer into the device extension
    of the given device object.  

    If no mate is found, sadly, then this routine puts a NULL in the mate deviceobject field in the dev extension, 
    and returns a STATUS_NOT_FOUND result code

++*/
{
    NTSTATUS         ntStatus               = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension       = DeviceObject->DeviceExtension;
    PDRIVER_OBJECT    driverObject          = DeviceObject->DriverObject;
    PDEVICE_OBJECT    NextDeviceObject      = DeviceObject->NextDevice;
    PDEVICE_EXTENSION NextDeviceExtension   = NULL;
    dtDeviceType      dtMateTestDeviceTypeA = Unknown_Device_Type;
    dtDeviceType      dtMateTestDeviceTypeB = Unknown_Device_Type;

    ASSERT (DeviceObject != NULL);
    ASSERT (deviceExtension!=NULL);

    if (NextDeviceObject == NULL) {
        ISOPERF_KdPrint(("FindMateDevice: No Next Device\n"));

        // NOTE: (old code)
        // WDM appears to be loading an entirely separate driver image for the same venid/prodid.  
        // This makes the approach where we look at the device chain to find the next device in the
        // chain not feasible, so as a shortterm fix we'll put the Device Object for a Output Iso device
        // in a global variable (which does seem to persist across dd loads) and we'll see if that is a 
        // mate.  kjaff 12/24/96
        if (gMyOutputDevice!=NULL) {
            ISOPERF_KdPrint(("There is a global device us to check...(%x)\n",gMyOutputDevice));
            NextDeviceObject = gMyOutputDevice;
            NextDeviceExtension = NextDeviceObject->DeviceExtension;
        } else {        
            ISOPERF_KdPrint (("No global device found either...exiting...\n"));
            return STATUS_NOT_FOUND;
        }//else no global either

    }else{
        NextDeviceExtension = NextDeviceObject->DeviceExtension;
        ISOPERF_KdPrint(("Found a NextDevice: %x\n",NextDeviceObject));
    }//else there is a next device
    
    // The Mate for the device is dependent on the device type
    switch (deviceExtension->dtTestDeviceType) {
        case Iso_In_With_Pattern:
            //This dev can have 2 mate types
            ISOPERF_KdPrint (("Looking for a mate for Iso_In_With_Pattern %d\n",deviceExtension->dtTestDeviceType));
            dtMateTestDeviceTypeA = Iso_Out_With_Interrupt_Feedback;
            dtMateTestDeviceTypeB = Iso_Out_Without_Feedback;
            break;

        case Iso_Out_With_Interrupt_Feedback:
            break;
            
        case Iso_Out_Without_Feedback:
            break;

        case Unknown_Device_Type:
            break;

        default:
            break;
    }//switch on device type

    ntStatus = STATUS_NOT_FOUND; //assume we haven't found the mate
    
    while (NextDeviceObject != NULL) {

        NextDeviceExtension = NextDeviceObject->DeviceExtension;
        
        // Is this the mate?
        if ( (NextDeviceExtension->dtTestDeviceType == dtMateTestDeviceTypeA) ||
             (NextDeviceExtension->dtTestDeviceType == dtMateTestDeviceTypeB) ) {

             ISOPERF_KdPrint (("Found a mate for Dev %X : %X\n",DeviceObject, NextDeviceObject));
             
             //Found a mate, so fill in this dev object into the given dev obj's ext
             deviceExtension->MateDeviceObject = NextDeviceObject;
             ntStatus = STATUS_SUCCESS;
             break; //drop out of the while

        } else {

            ISOPERF_KdPrint (("%x is not a mate for Dev %X (type:%d\n",
                                NextDeviceObject,
                                DeviceObject,
                                NextDeviceExtension->dtTestDeviceType));

            // Get the next device object
            NextDeviceObject = NextDeviceObject->NextDevice;
            
        }//else go on to next device object
        
    }//while next dev obj

    ISOPERF_KdPrint (("FindMateDevice exiting...\n"));
    
    return ntStatus;
    
}//ISOPERF_FindMateDevice


VOID 
ISOPERF_StartIsoOutTest (
   IN PISOPERF_WORKITEM IsoperfWorkItem
   )
/*++

    Queues an Irp to the USB stack on the given device object.

  Inputs:
        IsoperfWorkItem - This routine is designed to be fired offf either directly or via a Work Item.  The
                                          work item structure only allows for one parameter to be passed to the work item
                                          routine, hence this single workitem parameter.

   Return Value:
        None
        
++*/
{
    PDEVICE_OBJECT              deviceObject    = NULL;
    PDEVICE_EXTENSION           deviceExtension = NULL;
    PUSBD_INTERFACE_INFORMATION pInterfaceInfo  = NULL;
    PUSBD_PIPE_INFORMATION      pUsbdPipeInfo   = NULL;
    pConfig_Stat_Info           configStatInfo  = NULL;
    PVOID                       pvBuff          = NULL;
    PURB                        urb             = NULL;
    ULONG                       ulBufferSize    = 0;
    NTSTATUS                    ntStatus        = STATUS_SUCCESS;
    IsoTxferContext *           pIsoContext     = NULL;
    ULONG                       ulFrameNumber   = 0;
    ULONG                       NumberOfFrames  = 0;
    ULONG                       i               = 0;
    
    deviceObject        = IsoperfWorkItem->DeviceObject;
    pvBuff              = IsoperfWorkItem->pvBuffer;
    ulBufferSize        = IsoperfWorkItem->ulBufferLen;

    deviceExtension     = deviceObject->DeviceExtension;
    pInterfaceInfo      = deviceExtension->Interface[ucIsoInterface];
    configStatInfo              = deviceExtension->pConfig_Stat_Information;

    ASSERT (pInterfaceInfo!=NULL);
    ASSERT (configStatInfo != NULL);
    ASSERT (deviceObject != NULL);
    
    if ( (configStatInfo==NULL) || (pInterfaceInfo==NULL) || (deviceObject==NULL) ) {
        ISOPERF_KdPrint (("Bad Parameter Received: configInf: %x | InterfInfo: %x | DevObj: %x\n",
                           configStatInfo, pInterfaceInfo, deviceObject));
        TRAP();
        return;
    }//if any params are bad

    // Check out the offset provided to make sure it's not too big
    if (configStatInfo->ulFrameOffset >= USBD_ISO_START_FRAME_RANGE) {
        ISOPERF_KdPrint (("ISOOUT: Error-Detected a FrameOffset Larger than allowed! (%d)\n",configStatInfo->ulFrameOffset));
        TRAP();
        return;
    }//if bad frame offset

    if (IsoperfWorkItem->bFirstUrb) {

        // We have to match the endpoint maxpacket sizes for this to work (we can't assume that this is the
        // case since the Out device sometimes seems to have a larger maxpacket than the In device
        // DESIGNDESIGN This may be OK if we later on want to do some rate-matching emulation here.
        if ( (deviceExtension->Interface[0]->Pipes[0].MaximumPacketSize) >= IsoperfWorkItem->InMaxPacket ) {
            deviceExtension->Interface[0]->Pipes[0].MaximumPacketSize = IsoperfWorkItem->InMaxPacket;
        } else {
            //if the OUT device's maxpacket is smaller than the IN device's this seems incorrect so do nothing
            return;
        }//else the endpoint sizes seem out of whack

//#if 0
        // Since this is the first Urb, we need the frame number, so get it
        ulFrameNumber = ISOPERF_GetCurrentFrame(deviceObject);

        ISOPERF_KdPrint (("StartISOOut got Frame Number: %x | Offset: %d\n",ulFrameNumber,configStatInfo->ulFrameOffset));

        if (ulFrameNumber==0) {
            ISOPERF_KdPrint (("Got Bad Frame Number (%x) ...exiting...\n",ulFrameNumber));
            deviceExtension->StopTransfers = TRUE; //set flag so further transfers stop
            return;
        }//if bad frame #
        
        //Save away the current frame number so the app can peek at it
        configStatInfo->ulFrameNumberAtStart = ulFrameNumber;

        // See what the user wants to do wrt starting frame number by looking at the config info
        if (configStatInfo->ulFrameOffset == 0) {
            // This means start ASAP
            ulFrameNumber = 0;
        }else {
            //Add the offset that the User wants to add to this frame number (it better be less than 1024!)
            ulFrameNumber += configStatInfo->ulFrameOffset;
        } //else

        //Save away the starting frame number so the app can peek at it
        configStatInfo->ulStartingFrameNumber = ulFrameNumber;

        ISOPERF_KdPrint (("StartISOOut using Frame Number: %x\n",ulFrameNumber));

//#endif

    }//if this is the first Urb
    else 
    {
        ISOPERF_KdPrint (("StartISOOut _NOT_ the First URB!\n"));
    }//else not first Urb


    // Get the pipe info for the first pipe
    pUsbdPipeInfo= &(pInterfaceInfo->Pipes[0]);
        ASSERT(pUsbdPipeInfo != NULL);
        
    if (deviceExtension->StopTransfers != TRUE) {

                //We get the Urbs to submit and the Nbr of frames from the workitem because we want to
                //make sure this is the same as the setting for the In device (this is filled in by InComplRoutine)
        NumberOfFrames    = IsoperfWorkItem->ulNumberOfFrames;

                ASSERT (NumberOfFrames > 0);

            //We get our own buffer for now...in the future this will be passed in if we decide to reuse the
        //input device's buffer
        pvBuff = ISOPERF_GetBuff (deviceObject,
                                  0,//pipe number
                                  0,//interfacenumber
                                  NumberOfFrames,
                                  &ulBufferSize
                                 );
                                  
        if (pvBuff==NULL){
            return;
        }else{ 
                        //Copy the input buffer into our output buffer (they should be the same size)
                        ASSERT (IsoperfWorkItem->ulBufferLen == ulBufferSize);
            RtlCopyMemory (pvBuff, IsoperfWorkItem->pvBuffer, ulBufferSize);  
        }//if pvbuff
        //...to here

        //build the urb
        urb =    ISOPERF_BuildIsoRequest(deviceObject,
                                         pUsbdPipeInfo,     //Pipe info struct
                                         FALSE,             //WRITE
                                         ulBufferSize,      //Data buffer size
                                         IsoperfWorkItem->bFirstUrb ? ulFrameNumber : 0,
                                         pvBuff,            //Data buffer
                                         NULL               //no MDL used
                                        );
        ISOPERF_KdPrint_MAXDEBUG (("OUT Urb: %x\n",urb));
        
        pIsoContext = ISOPERF_ExAllocatePool (NonPagedPool, sizeof (IsoTxferContext), &gulBytesAllocated);

        // Fill in the iso context
        pIsoContext->urb           = urb;
        pIsoContext->DeviceObject  = deviceObject;
        pIsoContext->PipeInfo      = pUsbdPipeInfo;
        pIsoContext->pvBuffer      = pvBuff;  //NOTE: set this to NULL if you're using the IN device's buffer
        pIsoContext->ulBufferLen   = ulBufferSize;
        pIsoContext->PipeNumber    = 0;
        pIsoContext->NumPackets    = urb->UrbIsochronousTransfer.NumberOfPackets;
        pIsoContext->bFirstUrb     = IsoperfWorkItem->bFirstUrb;
        
        //Create our own Irp for the device and call the usb stack w/ our urb/irp
        ntStatus = ISOPERF_CallUSBDEx ( deviceObject, 
                                        urb, 
                                        FALSE,                   //Don't block
                                        ISOPERF_IsoOutCompletion,//Completion routine
                                        pIsoContext,             //pvContext
                                        FALSE);                  //don't want timeout 

        if (NT_SUCCESS(ntStatus)) {

            deviceExtension->DeviceIsBusy   = TRUE;
            deviceExtension->bStopIsoTest   = FALSE;
            deviceExtension->StopTransfers  = FALSE;
            configStatInfo->erError         = NoError;
            configStatInfo->bDeviceRunning  = 1;

        } else {

            // An error occurred, so stop things and report it thru config/stat info
            deviceExtension->DeviceIsBusy   = FALSE;
            deviceExtension->bStopIsoTest   = TRUE;
            deviceExtension->StopTransfers  = TRUE;
            configStatInfo->erError         = ErrorInPostingUrb;
            configStatInfo->bDeviceRunning  = 0;

            // If the URB status code got filled in then extract the info returned
            if (!(USBD_SUCCESS(urb->UrbHeader.Status))) {
                ISOPERF_KdPrint (("StartIsoOut -- Urb unsuccessful (status: %#x)\n",urb->UrbHeader.Status));

                configStatInfo->UrbStatusCode = urb->UrbHeader.Status;
                
                // Dump out the status for the packets
                for (i=0; i< urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
                    ISOPERF_KdPrint (("Packet %d: Status: [%#X]\n",
                                        i,
                                        urb->UrbIsochronousTransfer.IsoPacket[i].Status));
                                        
                    // Put the last known bad packet status code into this space in the stat area
                    if (!USBD_SUCCESS(urb->UrbIsochronousTransfer.IsoPacket[i].Status)) {
                        configStatInfo->UsbdPacketStatCode = urb->UrbIsochronousTransfer.IsoPacket[i].Status;
                    }//if hit a fail code                 
                    
                }//for all the packets
            }// if bad Urb status code

        }//else there was an error

    }else{
        ISOPERF_KdPrint_MAXDEBUG (("IsoOut not submitting Urbs because StopTransfers is asserted!\n"));
    }//else we are being asked to stoptransfers
    
    //Free the work item junk
    ISOPERF_ExFreePool (IsoperfWorkItem, &gulBytesFreed);

    ISOPERF_KdPrint_MAXDEBUG (("Exit StartIsoOut\n"));

    return;
    
}//ISOPERF_StartIsoOutTest


NTSTATUS
ISOPERF_IsoOutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++
    This is the completion routine for the Iso OUT transfer
    
  Inputs:
        Device Object - the device object 
        Irp                       - The Irp we posted that is being completed
        Context           - pointer to our defined context which has our DeviceObject since it comes back as NULL here
                            DeviceObject is obtained from context due to old, old bug
                            in initial WDM implemenations

   Return Value:
        ntStatus
        
++*/
{
    PIsoTxterContext                pIsoContext;
    PDEVICE_OBJECT                  myDeviceObject;
    PDEVICE_EXTENSION               deviceExtension;
    PURB                            urb;
    pConfig_Stat_Info               pStatInfo;
    char *                          pcWork          = NULL; //a worker pointer
    ULONG                           i               = 0;    
    
    ISOPERF_KdPrint_MAXDEBUG (("In IsoOUTCompletion\n"));
    
    TRAP();

    pIsoContext     = Context;
    myDeviceObject  = pIsoContext->DeviceObject;
    deviceExtension = myDeviceObject->DeviceExtension;
    urb             = pIsoContext->urb;
    pStatInfo       = deviceExtension->pConfig_Stat_Information;
    
    // Check the USBD status code and only proceed in resubmission if the Urb was successful
    // or if the device extension flag that indicates the device is gone is FALSE
    if (!(USBD_SUCCESS(urb->UrbHeader.Status))) {
        ISOPERF_KdPrint (("IsoOUT Urb %x unsuccessful (status: %x)\n",urb,(urb->UrbHeader.Status)));

        // Don't let it go on w/ the tests
        deviceExtension->StopTransfers = TRUE;

        // Fill in stat info
        if (pStatInfo) {
            pStatInfo->erError = UsbdErrorInCompletion;
            pStatInfo->bStopped = 1;
            pStatInfo->UrbStatusCode = urb->UrbHeader.Status;
            
        }//if pStatInfo        

        // Dump out the status for the packets
        for (i=0; i< urb->UrbIsochronousTransfer.NumberOfPackets; i++) {
            ISOPERF_KdPrint (("Packet %d: Status: [%#X]\n",
                                i,
                                urb->UrbIsochronousTransfer.IsoPacket[i].Status));
                                
            // Put the last known bad packet status code into this space in the stat area
            if (!USBD_SUCCESS(urb->UrbIsochronousTransfer.IsoPacket[i].Status)) {

                pStatInfo->UsbdPacketStatCode = urb->UrbIsochronousTransfer.IsoPacket[i].Status;

            }//if hit a fail code                 
            
        }//for all the packets

    }//if failure detected

    // Free up the URB memory created for this transfer that we are retiring
    if (urb) {

        
        // We can't free the Urb itself, since it has some junk before it, so we have to roll back the 
        // pointer to get to the beginning of the block that we originally allocated, and then try to free it.
        pcWork = (char*)urb;                        //get the urb
        urb = (PURB) (pcWork - (2*sizeof(ULONG)));  //the original pointer is 2 DWORDs behind the Urb

        ISOPERF_KdPrint_MAXDEBUG (("Freeing Urb: %x\n",urb));
        ISOPERF_ExFreePool (urb, &gulBytesFreed);
        
    }//if
    
    if (pIsoContext) {

        // Free the data buffer
        // NOTE: This only can be done if we own this data buffer.  If the same data buffer that
        //       the IN device is using is being used here, then we don't want to free this buffer.
        //       The presence of a pointer to the data buffer will tell us that
        if (pIsoContext->pvBuffer) {
            ISOPERF_KdPrint_MAXDEBUG (("Freeing pvBuffer: %x\n",pIsoContext->pvBuffer));
            ISOPERF_ExFreePool(pIsoContext->pvBuffer, &gulBytesFreed);
        }//if pvbuffer
        
        // Free the Iso Context
        ISOPERF_KdPrint_MAXDEBUG (("Freeing pIsoContext: %x\n",pIsoContext));
        ISOPERF_ExFreePool (pIsoContext, &gulBytesFreed);

    }//if valid Iso Context

    //Free the IoStatus block
    if (Irp->UserIosb) {
        ISOPERF_KdPrint_MAXDEBUG (("Freeing My IoStatus Block: %x\n",Irp->UserIosb));
        ISOPERF_ExFreePool(Irp->UserIosb, &gulBytesFreed);
    } else {
        //Bad thing...no IoStatus block pointer??
        ISOPERF_KdPrint (("ERROR: Irp's IoStatus block is apparently NULL!\n"));
        TRAP();
    }//else bad iostatus pointer

        // Free the Irp we created
    ISOPERF_KdPrint (("Freeing Irp %x\n",Irp));
    IoFreeIrp(Irp);

    ISOPERF_KdPrint_MAXDEBUG (("Exit IsoOUTCompletion\n"));
   
    return (STATUS_MORE_PROCESSING_REQUIRED); //Leave the Irp alone, IOS, since we're the top level driver
    
}//ISOPERF_IsoOutCompletion


NTSTATUS
ISOPERF_TimeStampUrb (  PVOID urb,
                                PULONG pulLower,
                                PULONG pulUpper
)
/*++

        Routine Description:
                Puts a Pentium Clock count time stamp 2 DWORDS before the given pointer (usually a urb,
                hence the name of the function).

                This function can also be used to simply get the Pentium clock count, although there 
                is already a Macro to do that.
                
        Inputs:
                PVOID urb       - pointer to a chunk of memory that ususally contains a Urb
                PULONG puLower - pointer to a ULONG that gets the current upper CPU clock count (eax)
                PULONG puUpper - same as lower, but the upper ULONG value (edx)

        Return Value:
                ntStatus indiciating success/fail

--*/
{
        char * pcWork;
        ULONG u,l;

        GET_PENTIUM_CLOCK_COUNT (u,l);
        
        // Time stamp the Urb before we send it down the stack
        pcWork  = (char*) (urb);

        //Backup 2 DWORDS
        pcWork  -= (2*sizeof(ULONG));

        //First DWORD is the Upper value (edx)
    *((PULONG)pcWork) = u;

    //Goto next DWORD
    pcWork += sizeof(ULONG);

    //Second DWORD is the Lower value (eax)
    *((PULONG)pcWork) = l;

        // Copy the values to the caller's supplied area
        *pulUpper = u;
        *pulLower = l;
        
    return STATUS_SUCCESS;
    
}

NTSTATUS
ISOPERF_GetUrbTimeStamp (       PVOID urb,
                                                        PULONG pulLower,
                                                        PULONG pulUpper
)
/* ++
        Routine Description:
                Gets the Pentium Clock count time stamp 2 DWORDS before the given pointer (usually a urb,
                hence the name of the function).

        Inputs:
                PVOID urb       - pointer to a chunk of memory that ususally contains a Urb
                PULONG puLower - pointer to a ULONG that gets the upper CPU clock count from the timestamp area(eax)
                PULONG puUpper - same as lower, but the upper ULONG value (edx)

        Return Value:
                ntStatus indiciating success/fail
--*/
{

        char * pcWork;

        //Get the Urb's pointer
        pcWork  =  (char *) urb;                        

        //The first DW before the Urb is the lower DW of the clk cnt...
        pcWork  -= (sizeof(ULONG));     

        //...when the Urb was posted to the Usb stack
        *pulLower       =  *((ULONG*)pcWork);   

        //NOTE: we don't care about the upper value right now...
        *pulUpper   = 0;
        
        return STATUS_SUCCESS;
        
}//ISOPERF_GetUrbTimeStamp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\i82930.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    I82930.C

Abstract:

    This source file contains the DriverEntry() and AddDevice() entry points
    for the I82930 driver and the dispatch routines which handle:

    IRP_MJ_POWER
    IRP_MJ_SYSTEM_CONTROL
    IRP_MJ_PNP

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include <initguid.h>

#include "i82930.h"
#include "ioctl.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, I82930_Unload)
#pragma alloc_text(PAGE, I82930_AddDevice)
#pragma alloc_text(PAGE, I82930_Power)
#pragma alloc_text(PAGE, I82930_SystemControl)
#pragma alloc_text(PAGE, I82930_Pnp)
#pragma alloc_text(PAGE, I82930_StartDevice)
#pragma alloc_text(PAGE, I82930_StopDevice)
#pragma alloc_text(PAGE, I82930_RemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_CancelStopRemoveDevice)
#pragma alloc_text(PAGE, I82930_QueryCapabilities)
#pragma alloc_text(PAGE, I82930_SyncPassDownIrp)
#pragma alloc_text(PAGE, I82930_SyncSendUsbRequest)
#pragma alloc_text(PAGE, I82930_GetDescriptor)
#pragma alloc_text(PAGE, I82930_SelectConfiguration)
#pragma alloc_text(PAGE, I82930_UnConfigure)
#endif

//******************************************************************************
//
// DriverEntry()
//
//******************************************************************************

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    )
{
#if DBG
    // Query the registry for global parameters
    //
    I82930_QueryGlobalParams();
#endif

    DBGPRINT(2, ("enter: DriverEntry\n"));

    DBGFBRK(DBGF_BRK_DRIVERENTRY);

    LOGINIT();

    //
    // Initialize the Driver Object with the driver's entry points
    //

    //
    // I82930.C
    //
    DriverObject->DriverUnload                          = I82930_Unload;
    DriverObject->DriverExtension->AddDevice            = I82930_AddDevice;

    //
    // OCRW.C
    //
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = I82930_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = I82930_Close;
    DriverObject->MajorFunction[IRP_MJ_READ]            = I82930_ReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = I82930_ReadWrite;

    //
    // IOCTL.C
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = I82930_DeviceControl;

    //
    // I82930.C
    //
    DriverObject->MajorFunction[IRP_MJ_POWER]           = I82930_Power;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = I82930_SystemControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = I82930_Pnp;

    DBGPRINT(2, ("exit:  DriverEntry\n"));

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// I82930_Unload()
//
//******************************************************************************

VOID
I82930_Unload (
    IN PDRIVER_OBJECT   DriverObject
    )
{
    DBGPRINT(2, ("enter: I82930_Unload\n"));

    LOGENTRY('UNLD', DriverObject, 0, 0);

    DBGFBRK(DBGF_BRK_UNLOAD);

    LOGUNINIT();

    DBGPRINT(2, ("exit:  I82930_Unload\n"));
}

//******************************************************************************
//
// I82930_AddDevice()
//
//******************************************************************************

NTSTATUS
I82930_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_OBJECT      deviceObject;
    PDEVICE_EXTENSION   deviceExtension;

    DBGPRINT(2, ("enter: I82930_AddDevice\n"));

    LOGENTRY('ADDD', DriverObject, PhysicalDeviceObject, 0);

    DBGFBRK(DBGF_BRK_ADDDEVICE);

    // Create the FDO
    //
    ntStatus = IoCreateDevice(DriverObject,
                              sizeof(DEVICE_EXTENSION),
                              NULL,
                              FILE_DEVICE_UNKNOWN,
                              FILE_AUTOGENERATED_DEVICE_NAME,
                              FALSE,
                              &deviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        return ntStatus;
    }

    // Initialize the DeviceExtension
    //
    deviceExtension = deviceObject->DeviceExtension;

    // Set all DeviceExtension pointers to NULL and all variable to zero
    //
    RtlZeroMemory(deviceExtension, sizeof(DEVICE_EXTENSION));

    // Remember our PDO
    //
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // Attach the FDO we created to the top of the PDO stack
    //
    deviceExtension->StackDeviceObject = IoAttachDeviceToDeviceStack(
                                             deviceObject,
                                             PhysicalDeviceObject);

    // Initialize to one in AddDevice, decrement by one in REMOVE_DEVICE
    //
    deviceExtension->OpenCount = 1;

    // Initialize the event which is set when OpenCount is decremented to zero.
    //
    KeInitializeEvent(&deviceExtension->RemoveEvent,
                      SynchronizationEvent,
                      FALSE);

    // Set the initial system and device power states
    //
    deviceExtension->SystemPowerState = PowerSystemWorking;
    deviceExtension->DevicePowerState = PowerDeviceD0;

    deviceObject->Flags |=  DO_DIRECT_IO;
    deviceObject->Flags |=  DO_POWER_PAGABLE;
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    DBGPRINT(2, ("exit:  I82930_AddDevice\n"));

    LOGENTRY('addd', deviceObject, deviceExtension, deviceExtension->StackDeviceObject);

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// I82930_Power()
//
// Dispatch routine which handles IRP_MJ_POWER
//
//******************************************************************************

NTSTATUS
I82930_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Power %08X %s\n",
                 DeviceObject,
                 PowerMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('POWR', DeviceObject, Irp, irpStack->MinorFunction);

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        DBGPRINT(2, ("IRP_MN_SET_POWER %s\n",
                     (irpStack->Parameters.Power.Type == SystemPowerState) ?
                     PowerSystemStateString(irpStack->Parameters.Power.State.SystemState) :
                     PowerDeviceStateString(irpStack->Parameters.Power.State.DeviceState)));
    }

    if (irpStack->MinorFunction == IRP_MN_SET_POWER)
    {
        // Handle powering the FDO down and up...
        //
        ntStatus = I82930_FdoSetPower(DeviceObject,
                                      Irp);
    }
    else
    {
        // No special processing for IRP_MN_QUERY_POWER, IRP_MN_WAIT_WAKE,
        // or IRP_MN_POWER_SEQUENCE at this time.  Just pass the request
        // down to the next lower driver now.
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_Power %08X\n", ntStatus));

    LOGENTRY('powr', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_FdoSetPower()
//
// Dispatch routine which handles IRP_MJ_POWER, IRP_MN_SET_POWER for the FDO
//
//******************************************************************************

NTSTATUS
I82930_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      irpStack;
    POWER_STATE_TYPE        powerType;
    POWER_STATE             powerState;
    POWER_STATE             newState;
    BOOLEAN                 passRequest;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    deviceExtension = DeviceObject->DeviceExtension;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    powerType = irpStack->Parameters.Power.Type;

    powerState = irpStack->Parameters.Power.State;

    DBGPRINT(2, ("enter: I82930_FdoSetPower %08X %s\n",
                 DeviceObject,
                 (powerType == SystemPowerState) ?
                 PowerSystemStateString(powerState.SystemState) :
                 PowerDeviceStateString(powerState.DeviceState)));

    LOGENTRY('FDSP', DeviceObject, Irp, irpStack->MinorFunction);

    // Pass the request down here, unless we request a device state power
    // Irp, in which case we pass the request down in our completion routine.
    //
    passRequest = TRUE;

    if (powerType == SystemPowerState)
    {
        // Remember the current system state.
        //
        deviceExtension->SystemPowerState = powerState.SystemState;

        // Map the new system state to a new device state
        //
        if (powerState.SystemState != PowerSystemWorking)
        {
            newState.DeviceState = PowerDeviceD3;
        }
        else
        {
            newState.DeviceState = PowerDeviceD0;
        }

        // If the new device state is different than the current device
        // state, request a device state power Irp.
        //
        if (deviceExtension->DevicePowerState != newState.DeviceState)
        {
            DBGPRINT(2, ("Requesting power Irp %08X %08X from %s to %s\n",
                         DeviceObject, Irp,
                         PowerDeviceStateString(deviceExtension->DevicePowerState),
                         PowerDeviceStateString(newState.DeviceState)));

            ASSERT(deviceExtension->CurrentPowerIrp == NULL);

            deviceExtension->CurrentPowerIrp = Irp;

            ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                         IRP_MN_SET_POWER,
                                         newState,
                                         I82930_FdoSetPowerCompletion,
                                         DeviceObject,
                                         NULL);

            passRequest = FALSE;
        }
    }
    else if (powerType == DevicePowerState)
    {
        POWER_STATE oldState;

        DBGPRINT(2, ("Received power Irp %08X %08X from %s to %s\n",
                     DeviceObject, Irp,
                     PowerDeviceStateString(deviceExtension->DevicePowerState),
                     PowerDeviceStateString(powerState.DeviceState)));

        // Update the current device state.
        //
        oldState.DeviceState = deviceExtension->DevicePowerState;
        deviceExtension->DevicePowerState = powerState.DeviceState;

        if (oldState.DeviceState == PowerDeviceD0 &&
            powerState.DeviceState > PowerDeviceD0)
        {
            // Powering down.

            DBGPRINT(2, ("FDO Powering Down\n"));

            LOGENTRY('PWRD', DeviceObject, Irp, 0);
        }
        else if (oldState.DeviceState > PowerDeviceD0 &&
                 powerState.DeviceState == PowerDeviceD0)
        {
            DBGPRINT(2, ("PDO Powering Up\n"));

            LOGENTRY('PWRU', DeviceObject, Irp, 0);
        }
    }

    if (passRequest)
    {
        //
        // Pass the request down to the next lower driver
        //
        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    DBGPRINT(2, ("exit:  I82930_FdoSetPower %08X\n", ntStatus));

    LOGENTRY('fdsp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_FdoSetPowerCompletion()
//
// Completion routine for PoRequestPowerIrp() in I82930_FdoSetPower.
//
// The purpose of this routine is to block passing down the SystemPowerState
// Irp until the requested DevicePowerState Irp completes.
//
//******************************************************************************

VOID
I82930_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   PdoDeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PDEVICE_OBJECT          fdoDeviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIRP                    irp;
    NTSTATUS                ntStatus;

    fdoDeviceObject = (PDEVICE_OBJECT)Context;

    deviceExtension = fdoDeviceObject->DeviceExtension;

    ASSERT(deviceExtension->CurrentPowerIrp != NULL);

    irp = deviceExtension->CurrentPowerIrp;

    deviceExtension->CurrentPowerIrp = NULL;

#if DBG
    {
        PIO_STACK_LOCATION  irpStack;
        SYSTEM_POWER_STATE  systemState;

        irpStack = IoGetCurrentIrpStackLocation(irp);

        systemState = irpStack->Parameters.Power.State.SystemState;

        ntStatus = IoStatus->Status;

        DBGPRINT(2, ("I82930_FdoSetPowerCompletion %08X %08X %s %08X\n",
                     fdoDeviceObject, irp,
                     PowerSystemStateString(systemState),
                     ntStatus));

        LOGENTRY('fspc', fdoDeviceObject, systemState, ntStatus);
    }
#endif

    // The requested DevicePowerState Irp has completed.
    // Now pass down the SystemPowerState Irp which requested the
    // DevicePowerState Irp.

    PoStartNextPowerIrp(irp);

    IoSkipCurrentIrpStackLocation(irp);

    ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                            irp);
}

//******************************************************************************
//
// I82930_SystemControl()
//
// Dispatch routine which handles IRP_MJ_SYSTEM_CONTROL
//
//******************************************************************************

NTSTATUS
I82930_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_SystemControl %2X\n", irpStack->MinorFunction));

    LOGENTRY('SYSC', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        //
        // XXXXX Need to handle any of these?
        //

        default:
            //
            // Pass the request down to the next lower driver
            //
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_SystemControl %08X\n", ntStatus));

    LOGENTRY('sysc', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_Pnp()
//
// Dispatch routine which handles IRP_MJ_PNP
//
//******************************************************************************

NTSTATUS
I82930_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    DBGPRINT(2, ("enter: I82930_Pnp %s\n",
                 PnPMinorFunctionString(irpStack->MinorFunction)));

    LOGENTRY('PNP ', DeviceObject, Irp, irpStack->MinorFunction);

    switch (irpStack->MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            ntStatus = I82930_StartDevice(DeviceObject, Irp);
            break;

        case IRP_MN_STOP_DEVICE:
            ntStatus = I82930_StopDevice(DeviceObject, Irp);
            break;

        case IRP_MN_REMOVE_DEVICE:
            ntStatus = I82930_RemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            ntStatus = I82930_QueryStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            ntStatus = I82930_CancelStopRemoveDevice(DeviceObject, Irp);
            break;

        case IRP_MN_QUERY_CAPABILITIES:
            ntStatus = I82930_QueryCapabilities(DeviceObject, Irp);
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            // nothing special yet, just fall through to default

        default:
            //
            // Pass the request down to the next lower driver
            //
            IoSkipCurrentIrpStackLocation(Irp);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);
            break;
    }

    DBGPRINT(2, ("exit:  I82930_Pnp %08X\n", ntStatus));

    LOGENTRY('pnp ', ntStatus, 0, 0);

    return ntStatus;
}


//******************************************************************************
//
// I82930_StartDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_START_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
// Device specific actions:
//     Retrieve the Device Descriptor from device (first time only)
//     Retrieve the Configuration Descriptor from device (first time only)
//     Configure the device (every time)
//     Create the SymbolicLink name (first time only)
//     Enable the SymbolicLink name (every time)
//
//******************************************************************************

NTSTATUS
I82930_StartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PUCHAR              descriptor;
    ULONG               descriptorLength;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StartDevice\n"));

    DBGFBRK(DBGF_BRK_STARTDEVICE);

    LOGENTRY('STRT', DeviceObject, Irp, 0);

    deviceExtension = DeviceObject->DeviceExtension;

    // Pass IRP_MN_START_DEVICE Irp down the stack first before we do anything.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_START_DEVICE\n"));
        goto I82930_StartDeviceDone;
    }

    //
    // If this is the first time the device as been started, retrieve the
    // Device and Configuration Descriptors from the device.
    //
    if (deviceExtension->DeviceDescriptor == NULL)
    {
        //
        // Get Device Descriptor
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_DEVICE_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        sizeof(USB_DEVICE_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Device Descriptor failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->DeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)descriptor;

        //
        // Get Configuration Descriptor (just the Configuration Descriptor)
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        sizeof(USB_CONFIGURATION_DESCRIPTOR),
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (1)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        descriptorLength = ((PUSB_CONFIGURATION_DESCRIPTOR)descriptor)->wTotalLength;

        ExFreePool(descriptor);

        if (descriptorLength < sizeof(USB_CONFIGURATION_DESCRIPTOR))
        {
            ntStatus = STATUS_DEVICE_DATA_ERROR;
            DBGPRINT(1, ("Get Configuration Descriptor failed (2)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        //
        // Get Configuration Descriptor (and Interface and Endpoint Descriptors)
        //
        ntStatus = I82930_GetDescriptor(DeviceObject,
                                        USB_RECIPIENT_DEVICE,
                                        USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                        0,  // Index
                                        0,  // LanguageId
                                        2,  // RetryCount
                                        descriptorLength,
                                        &descriptor);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("Get Configuration Descriptor failed (3)\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }

        deviceExtension->ConfigurationDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)descriptor;

#if DBG
        DumpDeviceDesc(deviceExtension->DeviceDescriptor);
        DumpConfigDesc(deviceExtension->ConfigurationDescriptor);
#endif
    }

    // Now configure the device
    //
    ntStatus = I82930_SelectConfiguration(DeviceObject);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Configure device failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

    // Create the SymbolicLink name if necessary
    //
    if (deviceExtension->SymbolicLinkName.Buffer == NULL)
    {
        ntStatus = IoRegisterDeviceInterface(
                       deviceExtension->PhysicalDeviceObject,
                       (LPGUID)&GUID_CLASS_I82930,
                       NULL,
                       &deviceExtension->SymbolicLinkName);

        if (!NT_SUCCESS(ntStatus))
        {
            DBGPRINT(1, ("IoRegisterDeviceInterface failed\n"));
            Irp->IoStatus.Status = ntStatus;
            goto I82930_StartDeviceDone;
        }
    }

    // All set for user requests at this point
    //
    deviceExtension->AcceptingRequests = TRUE;

    // Enable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_StartDeviceDone;
    }

I82930_StartDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_StartDevice %08X\n", ntStatus));

    LOGENTRY('strt', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_StopDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_STOP_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// The PnP Manager only sends this IRP if a prior IRP_MN_QUERY_STOP_DEVICE
// completed successfully.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  A driver must
// not fail this IRP.  If a driver cannot release the device's hardware
// resources, it can fail a query-stop IRP, but once it succeeds the query-stop
// request it must succeed the stop request.
//
//******************************************************************************

NTSTATUS
I82930_StopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_StopDevice\n"));

    LOGENTRY('STOP', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_STOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Release the device resources allocated during IRP_MN_START_DEVICE
    //

    // Unconfigure the device
    //
    ntStatus = I82930_UnConfigure(DeviceObject);

    // Pass the IRP_MN_STOP_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(2, ("exit:  I82930_StopDevice %08X\n", ntStatus));

    LOGENTRY('stop', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_RemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_REMOVE_DEVICE
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
// A driver must set Irp->IoStatus.Status to STATUS_SUCCESS.  Drivers must not
// fail this IRP.
//
//******************************************************************************

NTSTATUS
I82930_RemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_RemoveDevice\n"));

    LOGENTRY('REMV', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_REMOVEDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Disable and free the SymbolicLink name if necessary
    //
    if (deviceExtension->SymbolicLinkName.Buffer != NULL)
    {
        ntStatus = IoSetDeviceInterfaceState(
                       &deviceExtension->SymbolicLinkName,
                       FALSE);

        RtlFreeUnicodeString(&deviceExtension->SymbolicLinkName);
    }

    // No more user requests at this point
    //
    deviceExtension->AcceptingRequests = FALSE;

    // Abort any requests that may be lingering on any of the endpoints.
    //
    if (deviceExtension->InterfaceInfo != NULL)
    {
        ULONG   pipeIndex;
        ULONG   numPipes;

        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
        {
            I82930_AbortPipe(DeviceObject,
                             &deviceExtension->PipeList[pipeIndex]);
        }
    }

    // Decrement by one to match the initial one in AddDevice
    //
    DECREMENT_OPEN_COUNT(deviceExtension);

    LOGENTRY('rem1', DeviceObject, 0, 0);

    // Wait for all pending requests to complete
    //
    KeWaitForSingleObject(&deviceExtension->RemoveEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    LOGENTRY('rem2', DeviceObject, 0, 0);

    // Free everything that was allocated during IRP_MN_START_DEVICE
    //

    if (deviceExtension->DeviceDescriptor != NULL)
    {
        ExFreePool(deviceExtension->DeviceDescriptor);
    }

    if (deviceExtension->ConfigurationDescriptor != NULL)
    {
        ExFreePool(deviceExtension->ConfigurationDescriptor);
    }

    if (deviceExtension->InterfaceInfo != NULL)
    {
        ExFreePool(deviceExtension->InterfaceInfo);
    }

    // The documentation says to set the status before passing the Irp down
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    // Pass the IRP_MN_REMOVE_DEVICE Irp down the stack.
    //
    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    LOGENTRY('rem3', DeviceObject, 0, 0);

    // Free everything that was allocated during AddDevice
    //
    IoDetachDevice(deviceExtension->StackDeviceObject);

    IoDeleteDevice(DeviceObject);

    DBGPRINT(2, ("exit:  I82930_RemoveDevice %08X\n", ntStatus));

    LOGENTRY('remv', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_QueryStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_STOP_DEVICE and
// IRP_MN_QUERY_REMOVE_DEVICE.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP is handled first by the driver at the top of the device stack and
// then by each lower driver in the attachment chain.
//
//******************************************************************************

NTSTATUS
I82930_QueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_QueryStopRemoveDevice\n"));

    LOGENTRY('QSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_QUERYSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Disable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   FALSE);

    // No more user requests at this point
    //
    deviceExtension->AcceptingRequests = FALSE;

    // If there are no opens, OK to STOP or REMOVE
    //
    if (deviceExtension->OpenCount == 1)
    {
        LOGENTRY('qsr1', 0, 0, 0);

        // The documentation says to set the status before passing the Irp down
        //
        Irp->IoStatus.Status = STATUS_SUCCESS;

        // Pass the IRP_MN_QUERY_STOP/REMOVE_DEVICE Irp down the stack.
        //
        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);

    }
    else
    {
        LOGENTRY('qsr2', deviceExtension->OpenCount, 0, 0);

        ntStatus = STATUS_DEVICE_BUSY;

        Irp->IoStatus.Status = ntStatus;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  I82930_QueryStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('qsrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_CancelStopRemoveDevice()
//
// This routine handles IRP_MJ_PNP, IRP_MN_CANCEL_STOP_DEVICE and
// IRP_MN_CANCEL_REMOVE_DEVICE.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// system thread.
//
// This IRP must be handled first by the underlying bus driver for a device
// and then by each higher driver in the device stack.
//
//******************************************************************************

NTSTATUS
I82930_CancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_CancelStopRemoveDevice\n"));

    LOGENTRY('CSRD', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CANCELSTOPDEVICE);

    deviceExtension = DeviceObject->DeviceExtension;

    // Pass the IRP_MN_CANCEL_STOP/REMOVE_DEVICE Irp down the stack first.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_CANCEL_STOP/REMOVE_DEVICE\n"));
        goto I82930_CancelStopRemoveDeviceDone;
    }

    // All set for user requests at this point
    //
    deviceExtension->AcceptingRequests = TRUE;

    // Enable the SymbolicLink name
    //
    ntStatus = IoSetDeviceInterfaceState(
                   &deviceExtension->SymbolicLinkName,
                   TRUE);

    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("IoSetDeviceInterfaceState failed\n"));
        Irp->IoStatus.Status = ntStatus;
        goto I82930_CancelStopRemoveDeviceDone;
    }

I82930_CancelStopRemoveDeviceDone:

    // Must complete request since completion routine returned
    // STATUS_MORE_PROCESSING_REQUIRED
    //
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_CancelStopRemoveDevice %08X\n", ntStatus));

    LOGENTRY('csrd', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_QueryCapabilities()
//
// This routine handles IRP_MJ_PNP, IRP_MN_QUERY_CAPABILITIES.
//
// The PnP Manager sends this IRP at IRQL PASSIVE_LEVEL in the context of a
// an arbitrary thread.
//
//******************************************************************************

NTSTATUS
I82930_QueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PDEVICE_CAPABILITIES    deviceCapabilities;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: I82930_QueryCapabilities\n"));

    LOGENTRY('FQCP', DeviceObject, Irp, 0);

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    deviceCapabilities = irpStack->Parameters.DeviceCapabilities.Capabilities;

    // Pass IRP_MN_QUERY_CAPABILITIES Irp down the stack first before we do
    // anything.
    //
    ntStatus = I82930_SyncPassDownIrp(DeviceObject,
                                      Irp,
                                      TRUE);
    if (!NT_SUCCESS(ntStatus))
    {
        DBGPRINT(1, ("Lower driver failed IRP_MN_QUERY_CAPABILITIES\n"));
    }
    else
    {
        deviceCapabilities->SurpriseRemovalOK = TRUE;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_QueryCapabilities %08X\n", ntStatus));

    LOGENTRY('fqcp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_SyncPassDownIrp()
//
//******************************************************************************

NTSTATUS
I82930_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN BOOLEAN          CopyToNext
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    KEVENT              localevent;

    DBGPRINT(2, ("enter: I82930_SyncPassDownIrp\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    if (CopyToNext)
    {
        // Next Stack Location not set up, copy Current Stack Location
        // to the Next Stack Location.
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);
    }

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(Irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    DBGPRINT(2, ("exit:  I82930_SyncPassDownIrp %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_SyncCompletionRoutine()
//
// Completion routine used by I82930_SyncPassDownIrp and
// I82930_SyncSendUsbRequest
//
// If the Irp is one we allocated ourself, DeviceObject is NULL unless we
// allocated a stack location for ourself and initialized the DeviceObject
// pointer in our stack location.
//
//******************************************************************************

NTSTATUS
I82930_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    LOGENTRY('SCR ', DeviceObject, Irp, Irp->IoStatus.Status);

    kevent = (PKEVENT)Context;

    KeSetEvent(kevent,
               IO_NO_INCREMENT,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// I82930_SyncSendUsbRequest()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    KEVENT              localevent;
    PIRP                irp;
    PIO_STACK_LOCATION  nextStack;
    NTSTATUS            ntStatus;

    DBGPRINT(3, ("enter: I82930_SyncSendUsbRequest\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Allocate the Irp
    //
    irp = IoAllocateIrp(deviceExtension->StackDeviceObject->StackSize, FALSE);

    LOGENTRY('SSUR', DeviceObject, irp, Urb);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = Urb;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(irp,
                           I82930_SyncCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel



    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        LARGE_INTEGER timeout;

        // Specify a timeout of 5 seconds to wait for this call to complete.
        //
        timeout.QuadPart = -10000 * 5000;

        ntStatus = KeWaitForSingleObject(&localevent,
                                         Executive,
                                         KernelMode,
                                         FALSE,
                                         &timeout);

        if (ntStatus == STATUS_TIMEOUT)
        {
            ntStatus = STATUS_IO_TIMEOUT;

            // Cancel the Irp we just sent.
            //
            IoCancelIrp(irp);

            // And wait until the cancel completes
            //
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
        else
        {
            ntStatus = irp->IoStatus.Status;
        }
    }

    // Done with the Irp, now free it.
    //
    IoFreeIrp(irp);

    LOGENTRY('ssur', ntStatus, Urb, Urb->UrbHeader.Status);

    DBGPRINT(3, ("exit:  I82930_SyncSendUsbRequest %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_GetDescriptor()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    )
{
    USHORT      function;
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_GetDescriptor\n"));

    // Set the URB function based on Recipient {Device, Interface, Endpoint}
    //
    switch (Recipient)
    {
        case USB_RECIPIENT_DEVICE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE;
            break;
        case USB_RECIPIENT_INTERFACE:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_INTERFACE;
            break;
        case USB_RECIPIENT_ENDPOINT:
            function = URB_FUNCTION_GET_DESCRIPTOR_FROM_ENDPOINT;
            break;
        default:
            *Descriptor = NULL;
            return STATUS_INVALID_PARAMETER;
    }

    // Allocate a descriptor buffer
    //
    *Descriptor = ExAllocatePoolWithTag(NonPagedPool,
                                        DescriptorLength,
                                        POOL_TAG);

    if (*Descriptor != NULL)
    {
        // Allocate a URB for the Get Descriptor request
        //
        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                    POOL_TAG);

        if (urb != NULL)
        {
            do
            {
                // Initialize the URB
                //
                urb->UrbHeader.Function = function;
                urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST);
                urb->UrbControlDescriptorRequest.TransferBufferLength = DescriptorLength;
                urb->UrbControlDescriptorRequest.TransferBuffer = *Descriptor;
                urb->UrbControlDescriptorRequest.TransferBufferMDL = NULL;
                urb->UrbControlDescriptorRequest.UrbLink = NULL;
                urb->UrbControlDescriptorRequest.DescriptorType = DescriptorType;
                urb->UrbControlDescriptorRequest.Index = Index;
                urb->UrbControlDescriptorRequest.LanguageId = LanguageId;

                // Send the URB down the stack
                //
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // No error, make sure the length and type are correct
                    //
                    if ((DescriptorLength ==
                         urb->UrbControlDescriptorRequest.TransferBufferLength) &&
                        (DescriptorType ==
                         ((PUSB_COMMON_DESCRIPTOR)*Descriptor)->bDescriptorType))
                    {
                        // The length and type are correct, all done
                        //
                        break;
                    }
                    else
                    {
                        // No error, but the length or type is incorrect
                        //
                        ntStatus = STATUS_DEVICE_DATA_ERROR;
                    }
                }

            } while (RetryCount-- > 0);

            ExFreePool(urb);
        }
        else
        {
            // Failed to allocate the URB
            //
            ExFreePool(*Descriptor);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Failed to allocate the descriptor buffer
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(ntStatus))
    {
        *Descriptor = NULL;
    }

    DBGPRINT(2, ("exit:  I82930_GetDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// I82930_SelectConfiguration()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    NTSTATUS    ntStatus;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY      interfaceList;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectConfiguration\n"));

    LOGENTRY('SCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;


    // Allocate storage for an Inteface List to use as an input/output
    // parameter to USBD_CreateConfigurationRequestEx().
    //
    interfaceList = ExAllocatePool(
                        PagedPool,
                        sizeof(USBD_INTERFACE_LIST_ENTRY) * 2
                        );

    if (interfaceList)
    {
        // Parse the ConfigurationDescriptor (including all Interface and
        // Endpoint Descriptors) and locate a Interface Descriptor which
        // matches the InterfaceNumber, AlternateSetting, InterfaceClass,
        // InterfaceSubClass, and InterfaceProtocol parameters.  In our case
        // we just grab the first Interface Descriptor from the Configuration
        // Descriptor.
        //
        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                  configurationDescriptor,
                                  configurationDescriptor,
                                  -1, // InterfaceNumber, don't care
                                  -1, // AlternateSetting, don't care
                                  -1, // InterfaceClass, don't care
                                  -1, // InterfaceSubClass, don't care
                                  -1  // InterfaceProtocol, don't care
                                  );

        if (interfaceDescriptor)
        {
            // Add the single Interface Descriptor we care about to the
            // interface list, then terminate the list.
            //
            interfaceList[0].InterfaceDescriptor = interfaceDescriptor;
            interfaceList[1].InterfaceDescriptor = NULL;

            // Create a SELECT_CONFIGURATION URB, turning the Interface
            // Descriptors in the interfaceList into USBD_INTERFACE_INFORMATION
            // structures in the URB.
            //
            urb = USBD_CreateConfigurationRequestEx(
                      configurationDescriptor,
                      interfaceList
                      );

            if (urb)
            {
                interfaceInfo = &urb->UrbSelectConfiguration.Interface;

                // Override the USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
                // for all pipes.
                //
                for (i = 0; i < interfaceInfo->NumberOfPipes; i++)
                {
                    interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
                }

                // Now issue the USB request to set the Configuration
                //
                ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                     urb);

                if (NT_SUCCESS(ntStatus))
                {
                    // Save the configuration handle for this device in
                    // the Device Extension.
                    //
                    deviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                    // Save a copy of the interface information returned
                    // by the SELECT_CONFIGURATION request in the Device
                    // Extension.  This gives us a list of PIPE_INFORMATION
                    // structures for each pipe opened in this configuration.
                    //
                    ASSERT(deviceExtension->InterfaceInfo == NULL);

                    deviceExtension->InterfaceInfo = ExAllocatePool(
                                                         PagedPool,
                                                         interfaceInfo->Length
                                                     );

                    if (deviceExtension->InterfaceInfo)
                    {
                        ULONG   pipeIndex;
                        ULONG   numPipes;

                        RtlCopyMemory(
                            deviceExtension->InterfaceInfo,
                            interfaceInfo,
                            interfaceInfo->Length
                            );

                        // Initialize the PipeList array pointers back into the
                        // InterfaceInfo.
                        //
                        numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                        for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                        {
                            deviceExtension->PipeList[pipeIndex].PipeIndex =
                                (UCHAR)pipeIndex;

                            deviceExtension->PipeList[pipeIndex].PipeInfo  =
                                &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                        }
                    }
                    else
                    {
                        // Could not allocate a copy of interface information
                        //
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                }

                // Done with the URB
                //
                ExFreePool(urb);
            }
            else
            {
                // Could not allocate urb
                //
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else
        {
            // Did not parse an Interface Descriptor out of the Configuration
            // Descriptor, the Configuration Descriptor must be bad.
            //
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Done with the interface list
        //
        ExFreePool(interfaceList);
    }
    else
    {
        // Could not allocate Interface List
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_SelectConfiguration %08X\n", ntStatus));

    LOGENTRY('scon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_UnConfigure()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    NTSTATUS            ntStatus;
    PURB                urb;
    ULONG               ulSize;

    DBGPRINT(2, ("enter: I82930_UnConfigure\n"));

    LOGENTRY('UCON', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;

    // Allocate a URB for the SELECT_CONFIGURATION request.  As we are
    // unconfiguring the device, the request needs no pipe and interface
    // information structures.
    //
    ulSize = sizeof(struct _URB_SELECT_CONFIGURATION) -
             sizeof(USBD_INTERFACE_INFORMATION);

    urb = ExAllocatePool(
              NonPagedPool,
              ulSize
              );

    if (urb)
    {
        // Initialize the URB.  A NULL Configuration Descriptor indicates
        // that the device should be unconfigured.
        //
        UsbBuildSelectConfigurationRequest(
            urb,
            (USHORT)ulSize,
            NULL
            );

        // Now issue the USB request to set the Configuration
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                             urb);

        // Done with the URB now.
        //
        ExFreePool(urb);

        // The device is no longer configured.
        //
        deviceExtension->ConfigurationHandle = 0;

        if (deviceExtension->InterfaceInfo != NULL)
        {
            ExFreePool(deviceExtension->InterfaceInfo);

            deviceExtension->InterfaceInfo = NULL;
        }
    }
    else
    {
        // Could not allocate the URB.
        //
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_UnConfigure %08X\n", ntStatus));

    LOGENTRY('ucon', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_SelectAlternateInterface()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_SelectAlternateInterface (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            AlternateSetting
    )
{
    NTSTATUS    ntStatus;
    USHORT      urbSize;
    PURB        urb;
    ULONG       i;
    PDEVICE_EXTENSION               deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor;
    PUSB_INTERFACE_DESCRIPTOR       interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION     interfaceInfo;

    DBGPRINT(2, ("enter: I82930_SelectAlternateInterface\n"));

    LOGENTRY('SALT', DeviceObject, 0, 0);

    deviceExtension = DeviceObject->DeviceExtension;
    configurationDescriptor = deviceExtension->ConfigurationDescriptor;

    interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                              configurationDescriptor,
                              configurationDescriptor,
                              -1, // InterfaceNumber, don't care
                              AlternateSetting,
                              -1, // InterfaceClass, don't care
                              -1, // InterfaceSubClass, don't care
                              -1  // InterfaceProtocol, don't care
                              );

    if (interfaceDescriptor != NULL)
    {
        urbSize = GET_SELECT_INTERFACE_REQUEST_SIZE(interfaceDescriptor->bNumEndpoints);

        urb = ExAllocatePoolWithTag(NonPagedPool,
                                    urbSize,
                                    POOL_TAG);

        if (urb != NULL)
        {
            RtlZeroMemory(urb, urbSize);

            urb->UrbHeader.Length   = urbSize;

            urb->UrbHeader.Function = URB_FUNCTION_SELECT_INTERFACE;

            urb->UrbSelectInterface.ConfigurationHandle =
                deviceExtension->ConfigurationHandle;

            interfaceInfo = &urb->UrbSelectInterface.Interface;

            interfaceInfo->Length = GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

            interfaceInfo->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;

            interfaceInfo->AlternateSetting = AlternateSetting;

            for (i = 0; i < interfaceDescriptor->bNumEndpoints; i++)
            {
                interfaceInfo->Pipes[i].MaximumTransferSize = 0x10000;
            }

            // Now issue the USB request to select the alternate interface
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject,
                                                 urb);

            if (NT_SUCCESS(ntStatus))
            {
                if (deviceExtension->InterfaceInfo != NULL)
                {
                    ExFreePool(deviceExtension->InterfaceInfo);

                    deviceExtension->InterfaceInfo = NULL;
                }

                // Save a copy of the interface information returned
                // by the SELECT_INTERFACE request in the Device
                // Extension.  This gives us a list of PIPE_INFORMATION
                // structures for each pipe opened in this configuration.
                //
                deviceExtension->InterfaceInfo = ExAllocatePool(
                                                     PagedPool,
                                                     interfaceInfo->Length
                                                     );

                if (deviceExtension->InterfaceInfo)
                {
                    ULONG   pipeIndex;
                    ULONG   numPipes;

                    RtlCopyMemory(deviceExtension->InterfaceInfo,
                                  interfaceInfo,
                                  interfaceInfo->Length
                                  );

                    // Initialize the PipeList array pointers back into the
                    // InterfaceInfo.
                    //
                    numPipes = deviceExtension->InterfaceInfo->NumberOfPipes;

                    for (pipeIndex = 0; pipeIndex < numPipes; pipeIndex++)
                    {
                        deviceExtension->PipeList[pipeIndex].PipeIndex =
                            (UCHAR)pipeIndex;

                        deviceExtension->PipeList[pipeIndex].PipeInfo  =
                            &deviceExtension->InterfaceInfo->Pipes[pipeIndex];
                    }
                }
                else
                {
                    // Could not allocate a copy of interface information
                    //
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            // Done with the URB
            //
            ExFreePool(urb);
        }
        else
        {
            // Could not allocate urb
            //
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        // Bad AlternateSetting
        //
        ntStatus = STATUS_INVALID_PARAMETER;

    }

    DBGPRINT(2, ("exit:  I82930_SelectAlternateInterface %08X\n", ntStatus));

    LOGENTRY('salt', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\i82930\sys\ocrw.c ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    OCRW.C

Abstract:

    This source file contains the dispatch routines which handle
    opening, closing, reading, and writing to the device, i.e.:

    IRP_MJ_CREATE
    IRP_MJ_CLOSE
    IRP_MJ_READ
    IRP_MJ_WRITE

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "i82930.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, I82930_Create)
#pragma alloc_text(PAGE, I82930_Close)
#pragma alloc_text(PAGE, I82930_ReadWrite)
#pragma alloc_text(PAGE, I82930_BuildAsyncUrb)
#pragma alloc_text(PAGE, I82930_BuildIsoUrb)
#pragma alloc_text(PAGE, I82930_GetCurrentFrame)
#pragma alloc_text(PAGE, I82930_ResetPipe)
#pragma alloc_text(PAGE, I82930_AbortPipe)
#endif

//******************************************************************************
//
// I82930_Create()
//
// Dispatch routine which handles IRP_MJ_CREATE
//
//******************************************************************************

NTSTATUS
I82930_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    UCHAR               pipeIndex;
    PI82930_PIPE        pipe;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_Create\n"));

    LOGENTRY('CREA', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CREATE);

    deviceExtension = DeviceObject->DeviceExtension;

    INCREMENT_OPEN_COUNT(deviceExtension);

    if (deviceExtension->AcceptingRequests)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        fileObject = irpStack->FileObject;

        if (fileObject->FileName.Length != 0)
        {
            if ((fileObject->FileName.Length ==  3*sizeof(WCHAR)) &&
                (fileObject->FileName.Buffer[0] == '\\') &&
                (fileObject->FileName.Buffer[1] >= '0' ) &&
                (fileObject->FileName.Buffer[1] <= '9' ) &&
                (fileObject->FileName.Buffer[2] >= '0' ) &&
                (fileObject->FileName.Buffer[2] <= '9' ))
            {
                pipeIndex = ((fileObject->FileName.Buffer[1] - '0') * 10 +
                             (fileObject->FileName.Buffer[2] - '0'));

                if (pipeIndex < deviceExtension->InterfaceInfo->NumberOfPipes)
                {
                    pipe = &deviceExtension->PipeList[pipeIndex];

#if 0
                    if (pipe->Opened)
                    {
                        // Pipe already open
                        //
                        DBGPRINT(2, ("Pipe already open\n"));
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    }
                    else
#endif
                    {
                        // Good to open the pipe
                        //
                        DBGPRINT(2, ("Opened pipe %2d %08X\n",
                                     pipeIndex, pipe));

                        pipe->Opened    = TRUE;

                        fileObject->FsContext = pipe;

                        ntStatus = STATUS_SUCCESS;
                    }
                }
                else
                {
                    // Pipe index too big
                    //
                    DBGPRINT(2, ("Pipe index too big\n"));
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            }
            else
            {
                // Pipe name bad format
                //
                DBGPRINT(2, ("Pipe name bad format\n"));
                ntStatus = STATUS_NO_SUCH_DEVICE;
            }
        }
        else
        {
            // Open entire device, not an individual pipe
            //
            DBGPRINT(2, ("Opened device\n"));
            fileObject->FsContext = NULL;
            ntStatus = STATUS_SUCCESS;
        }
    }
    else
    {
        ntStatus = STATUS_DELETE_PENDING;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_Create %08X\n", ntStatus));

    LOGENTRY('crea', ntStatus, 0, 0);

    if (ntStatus != STATUS_SUCCESS)
    {
        DECREMENT_OPEN_COUNT(deviceExtension);
    }

    return ntStatus;
}


//******************************************************************************
//
// I82930_Close()
//
// Dispatch routine which handles IRP_MJ_CLOSE
//
//******************************************************************************

NTSTATUS
I82930_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;

    DBGPRINT(2, ("enter: I82930_Close\n"));

    LOGENTRY('CLOS', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CLOSE);

    deviceExtension = DeviceObject->DeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    if (pipe != NULL)
    {
        DBGPRINT(2, ("Closed pipe %2d %08X\n",
                     pipe->PipeIndex, pipe));

        pipe->Opened = FALSE;
    }
    else
    {
        DBGPRINT(2, ("Closed device\n"));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  I82930_Close\n"));

    LOGENTRY('clos', 0, 0, 0);

    DECREMENT_OPEN_COUNT(deviceExtension);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// I82930_ReadWrite()
//
// Dispatch routine which handles IRP_MJ_READ and IRP_MJ_WRITE
//
//******************************************************************************

NTSTATUS
I82930_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    PIO_STACK_LOCATION  nextStack;
    PFILE_OBJECT        fileObject;
    PI82930_PIPE        pipe;
    PURB                urb;
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: I82930_ReadWrite\n"));

    LOGENTRY('RW  ', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_READWRITE);

    deviceExtension = DeviceObject->DeviceExtension;

    if (!deviceExtension->AcceptingRequests)
    {
        ntStatus = STATUS_DELETE_PENDING;
        goto I82930_ReadWrite_Reject;
    }

    irpStack  = IoGetCurrentIrpStackLocation(Irp);
    nextStack = IoGetNextIrpStackLocation(Irp);

    fileObject = irpStack->FileObject;

    pipe = fileObject->FsContext;

    // Only allow Reads and Writes on individual pipes, not the entire device
    //
    if (pipe == NULL)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Only allow Reads on IN endpoints and Writes on OUT endpoints
    //
    if ((USB_ENDPOINT_DIRECTION_OUT(pipe->PipeInfo->EndpointAddress) &&
         irpStack->MajorFunction != IRP_MJ_WRITE) ||
        (USB_ENDPOINT_DIRECTION_IN(pipe->PipeInfo->EndpointAddress) &&
         irpStack->MajorFunction != IRP_MJ_READ))
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Don't allow a Read or Write on a zero bandwidth endpoint
    //
    if (pipe->PipeInfo->MaximumPacketSize == 0)
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        goto I82930_ReadWrite_Reject;
    }

    // Build either a URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
    // or a URB_FUNCTION_ISOCH_TRANSFER based on the PipeType
    //
    switch (pipe->PipeInfo->PipeType)
    {
        case UsbdPipeTypeBulk:
        case UsbdPipeTypeInterrupt:
            urb = I82930_BuildAsyncUrb(DeviceObject,
                                       Irp,
                                       pipe);
            break;

        case UsbdPipeTypeIsochronous:
            urb = I82930_BuildIsoUrb(DeviceObject,
                                     Irp,
                                     pipe);
            break;

        default:
            ntStatus = STATUS_INVALID_PARAMETER;
            goto I82930_ReadWrite_Reject;
    }

    if (urb == NULL)
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto I82930_ReadWrite_Reject;
    }

    // Initialize the Irp stack parameters for the next lower driver
    // to submit the URB
    //
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = urb;

    // Set a completion routine which will update the Irp->IoStatus.Information
    // with the URB TransferBufferLength and then free the URB.
    //
    IoSetCompletionRoutine(Irp,
                           I82930_ReadWrite_Complete,
                           urb,
                           TRUE,
                           TRUE,
                           TRUE);

    // Submit the URB to the next lower driver
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    goto I82930_Read_Done;

I82930_ReadWrite_Reject:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

I82930_Read_Done:

    DBGPRINT(2, ("exit:  I82930_ReadWrite %08X\n", ntStatus));

    LOGENTRY('rw  ', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_ReadWrite_Complete()
//
//******************************************************************************

NTSTATUS
I82930_ReadWrite_Complete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PURB    urb;

    urb = (PURB)Context;

    LOGENTRY('RWC1', DeviceObject, Irp, urb);
    LOGENTRY('RWC2', urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
             urb->UrbHeader.Status, 0);

    DBGPRINT(3, ("ReadWrite_Complete: Length 0x%08X, Urb Status 0x%08X, Irp Status 0x%08X\n",
                 urb->UrbBulkOrInterruptTransfer.TransferBufferLength,
                 urb->UrbHeader.Status,
                 Irp->IoStatus.Status));

    // Propagate the pending flag back up the Irp stack
    //
    if (Irp->PendingReturned)
    {
        IoMarkIrpPending(Irp);
    }

    Irp->IoStatus.Information =
        urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

    ExFreePool(urb);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// I82930_BuildAsyncUrb()
//
// Allocates and initializes a URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
// request URB
//
//******************************************************************************

PURB
I82930_BuildAsyncUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    )
{
    PIO_STACK_LOCATION  irpStack;
    LARGE_INTEGER       byteOffset;
    ULONG               transferLength;
    USHORT              urbSize;
    PURB                urb;

    DBGPRINT(2, ("enter: I82930_BuildAsyncUrb\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // We will use the ByteOffset to control the USBD_SHORT_TRANSFER_OK flag
    //
    byteOffset = irpStack->Parameters.Read.ByteOffset;

    // Get the transfer length from the MDL
    //
    if (Irp->MdlAddress)
    {
        transferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }
    else
    {
        transferLength = 0;
    }

    urbSize = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

    urb = ExAllocatePool(NonPagedPool, urbSize);

    if (urb)
    {
        RtlZeroMemory(urb, urbSize);

        urb->UrbHeader.Length   = urbSize;
        urb->UrbHeader.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

        urb->UrbBulkOrInterruptTransfer.PipeHandle =
            Pipe->PipeInfo->PipeHandle;

        if (!byteOffset.HighPart)
        {
            urb->UrbBulkOrInterruptTransfer.TransferFlags =
                USBD_SHORT_TRANSFER_OK;
        }

        urb->UrbBulkOrInterruptTransfer.TransferBufferLength =
            transferLength;

        urb->UrbBulkOrInterruptTransfer.TransferBuffer =
            NULL;

        urb->UrbBulkOrInterruptTransfer.TransferBufferMDL =
            Irp->MdlAddress;

        urb->UrbBulkOrInterruptTransfer.UrbLink =
            NULL;
    }

    DBGPRINT(2, ("exit:  I82930_BuildAsyncUrb %08X\n", urb));

    return urb;
}

//******************************************************************************
//
// I82930_BuildIsoUrb()
//
// Allocates and initializes a URB_FUNCTION_ISOCH_TRANSFER request URB
//
//******************************************************************************

PURB
I82930_BuildIsoUrb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PI82930_PIPE     Pipe
    )
{
    PIO_STACK_LOCATION  irpStack;
    LARGE_INTEGER       byteOffset;
    ULONG               transferLength;
    ULONG               packetSize;
    ULONG               numPackets;
    ULONG               packetIndex;
    ULONG               urbSize;
    PURB                urb;

    DBGPRINT(2, ("enter: I82930_BuildIsoUrb\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // We will use the ByteOffset for +/- offset to current frame
    //
    byteOffset = irpStack->Parameters.Read.ByteOffset;

    // Get the transfer length from the MDL
    //
    if (Irp->MdlAddress)
    {
        transferLength = MmGetMdlByteCount(Irp->MdlAddress);
    }
    else
    {
        transferLength = 0;
    }

    // Calculate the number of Iso packets based on the transfer length
    // and the endpoint MaxPacketSize
    //
    packetSize = Pipe->PipeInfo->MaximumPacketSize;

    numPackets = transferLength / packetSize;

    if (numPackets * packetSize < transferLength)
    {
        numPackets++;
    }

    urbSize = GET_ISO_URB_SIZE(numPackets);

    urb = ExAllocatePool(NonPagedPool, urbSize);

    if (urb)
    {
        RtlZeroMemory(urb, urbSize);

        urb->UrbHeader.Length   = (USHORT)urbSize;
        urb->UrbHeader.Function = URB_FUNCTION_ISOCH_TRANSFER;

        urb->UrbBulkOrInterruptTransfer.PipeHandle =
            Pipe->PipeInfo->PipeHandle;

        urb->UrbIsochronousTransfer.TransferFlags =
            0;

        urb->UrbIsochronousTransfer.TransferBufferLength =
            transferLength;

        urb->UrbIsochronousTransfer.TransferBuffer =
            NULL;

        urb->UrbIsochronousTransfer.TransferBufferMDL =
            Irp->MdlAddress;

        urb->UrbIsochronousTransfer.UrbLink =
            NULL;

        // Use the ByteOffset for +/- offset to current frame
        //
        if (byteOffset.HighPart)
        {
            urb->UrbIsochronousTransfer.StartFrame =
                I82930_GetCurrentFrame(DeviceObject, Irp) +
                byteOffset.LowPart;
        }
        else
        {
            urb->UrbIsochronousTransfer.StartFrame =
                0;

            urb->UrbIsochronousTransfer.TransferFlags |=
                USBD_START_ISO_TRANSFER_ASAP;
        }

        urb->UrbIsochronousTransfer.NumberOfPackets =
            numPackets;

        for (packetIndex = 0; packetIndex < numPackets; packetIndex++)
        {
            urb->UrbIsochronousTransfer.IsoPacket[packetIndex].Offset
                    = packetIndex * packetSize;
        }
    }

    DBGPRINT(2, ("exit:  I82930_BuildIsoUrb %08X\n", urb));

    return urb;
}

//******************************************************************************
//
// I82930_CompletionStop()
//
// Completion Routine which just stops further completion of the Irp
//
//******************************************************************************

NTSTATUS
I82930_CompletionStop (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    return STATUS_MORE_PROCESSING_REQUIRED;
}

//******************************************************************************
//
// I82930_GetCurrentFrame()
//
// Returns the current frame on the bus to which the device is attached.
//
// The next stack frame of the Irp is used, but the Irp is not completed.
//
//******************************************************************************

ULONG
I82930_GetCurrentFrame (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          nextStack;
    NTSTATUS                    ntStatus;
    struct _URB_GET_CURRENT_FRAME_NUMBER urb;

    deviceExtension = DeviceObject->DeviceExtension;

    // Initialize the URB
    //
    urb.Hdr.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
    urb.Hdr.Length   = sizeof(urb);
    urb.FrameNumber = (ULONG)-1;

    // Set the IRP parameters to pass the URB down the stack
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->Parameters.Others.Argument1 = &urb;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    // Since this Irp is borrowed for URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
    // before it is passed down later for the real URB request after this
    // routine returns, set a completion routine which stop further completion
    // of the Irp.
    //
    IoSetCompletionRoutine(
        Irp,
        I82930_CompletionStop,
        NULL,   // Context
        TRUE,   // InvokeOnSuccess
        TRUE,   // InvokeOnError
        TRUE    // InvokeOnCancel
        );

    // Now pass the Irp down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            Irp);

    ASSERT(ntStatus != STATUS_PENDING);

    // Don't need to wait for completion because JD guarantees that
    // URB_FUNCTION_GET_CURRENT_FRAME_NUMBER will never return STATUS_PENDING

    return urb.FrameNumber;
}

//******************************************************************************
//
// I82930_ResetPipe()
//
// This will reset the host pipe to Data0 and should also reset the device
// endpoint to Data0 for Bulk and Interrupt pipes by issuing a Clear_Feature
// Endpoint_Stall to the device endpoint.
//
// For Iso pipes this will set the virgin state of pipe so that ASAP
// transfers begin with the current bus frame instead of the next frame
// after the last transfer occurred.
//
// Iso endpoints do not use the data toggle (all Iso packets are Data0).
// However, it may be useful to issue a Clear_Feature Endpoint_Stall to a
// device Iso endpoint.
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe,
    IN BOOLEAN          IsoClearStall
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_ResetPipe\n"));

    LOGENTRY('RESP', DeviceObject, Pipe, IsoClearStall);

    // Allocate URB for RESET_PIPE request
    //
    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb != NULL)
    {
        // Initialize RESET_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe->PipeInfo->PipeHandle;

        // Submit RESET_PIPE request URB
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for RESET_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    // Issue Clear_Feature Endpoint_Stall request for Iso pipe, if desired
    //
    if (NT_SUCCESS(ntStatus) &&
        IsoClearStall &&
        (Pipe->PipeInfo->PipeType == UsbdPipeTypeIsochronous))
    {
        // Allocate URB for CONTROL_FEATURE request
        //
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

        if (urb != NULL)
        {
            // Initialize CONTROL_FEATURE request URB
            //
            urb->UrbHeader.Length   = sizeof (struct _URB_CONTROL_FEATURE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
            urb->UrbControlFeatureRequest.UrbLink = NULL;
            urb->UrbControlFeatureRequest.FeatureSelector = USB_FEATURE_ENDPOINT_STALL;
            urb->UrbControlFeatureRequest.Index = Pipe->PipeInfo->EndpointAddress;

            // Submit CONTROL_FEATURE request URB
            //
            ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

            // Done with URB for CONTROL_FEATURE request, free it
            //
            ExFreePool(urb);
        }
        else
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    DBGPRINT(2, ("exit:  I82930_ResetPipe %08X\n", ntStatus));

    LOGENTRY('resp', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// I82930_AbortPipe()
//
// Must be called at IRQL <= DISPATCH_LEVEL
//
//******************************************************************************

NTSTATUS
I82930_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PI82930_PIPE     Pipe
    )
{
    PURB        urb;
    NTSTATUS    ntStatus;

    DBGPRINT(2, ("enter: I82930_AbortPipe\n"));

    LOGENTRY('ABRT', DeviceObject, Pipe, 0);

    // Allocate URB for ABORT_PIPE request
    //
    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb != NULL)
    {
        // Initialize ABORT_PIPE request URB
        //
        urb->UrbHeader.Length   = sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
        urb->UrbPipeRequest.PipeHandle = Pipe->PipeInfo->PipeHandle;

        // Submit ABORT_PIPE request URB
        //
        ntStatus = I82930_SyncSendUsbRequest(DeviceObject, urb);

        // Done with URB for ABORT_PIPE request, free it
        //
        ExFreePool(urb);
    }
    else
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    DBGPRINT(2, ("exit:  I82930_AbortPipe %08X\n", ntStatus));

    LOGENTRY('abrt', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\isoperf.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1996  Intel Corporation

Module Name:

    ISOPERF.h

Abstract:
        Header file for the ISOPERF USB Device Driver


Environment:

    Kernel & user mode

Revision History:

        8-15-96 : created by Kosar Jaff


--*/

#ifdef DRIVER

extern ULONG gIsoPerfMaxDebug;
extern PDEVICE_OBJECT gMyOutputDevice; 

#define ISOPERF_NAME_MAX  64

#define USB_CLASS_CODE_TEST_CLASS_DEVICE 0xdc

#define USB_SUBCLASS_CODE_TEST_CLASS_ISO 0x50

#define USB_PROTOCOL_CODE_TEST_CLASS_INPATTERN_ALT 0x00 //In ISO w/ Pattern coming back (sof #) -original setting
#define USB_PROTOCOL_CODE_TEST_CLASS_INPATTERN 0x10 //In ISO w/ Pattern coming back (sof #)
#define USB_PROTOCOL_CODE_TEST_CLASS_OUTINTERR 0x80 //Out with interrupt coming back
#define USB_PROTOCOL_CODE_TEST_CLASS_OUTNOCHEK 0x90 //Out with no checks for hiccups

//modes
#define ISOPERF_MODE_USE_POOL    0
#define ISOPERF_MODE_USE_MDL     1

//options
#define ISOPERF_OPT_NONE         0


/*
// This is an unused structure in this driver, but is provided here
// so when you extend the driver to deal with USB pipes, you may wish
// to use this structure as an example or model.
*/
typedef struct _ISOPERF_PIPE {
    ULONG Mode;
    ULONG Option;
    ULONG Param1;
    ULONG Param2;
    PUSBD_PIPE_INFORMATION PipeInfo;
} ISOPERF_PIPE, *PISOPERF_PIPE;

// Work Item structure used to start worker threads in this driver
typedef struct _ISOPERF_WORKITEM {
    PDEVICE_OBJECT  DeviceObject;
    PVOID           pvBuffer;
    ULONG           ulBufferLen;
        ULONG                   ulNumberOfFrames;
    USHORT          InMaxPacket;
    USHORT          Padding;
    BOOLEAN         bFirstUrb;
} ISOPERF_WORKITEM, *PISOPERF_WORKITEM;

/*
// The interface number on this device that this driver expects to use
// This would be in the bInterfaceNumber field of the Interface Descriptor, hence
// this device driver would need to know this value.
*/
#define SAMPLE_INTERFACE_NBR 0x00

#define MAX_INTERFACE 0x04

//
// A structure representing the instance information associated with
// this particular device.
//
typedef struct _DEVICE_EXTENSION {

    // physical device object
    PDEVICE_OBJECT PhysicalDeviceObject;        

    // Device object we call when submitting Urbs/Irps to the USB stack
    PDEVICE_OBJECT              StackDeviceObject;              

    //Test Device Type (enum defined above)
    dtDeviceType        dtTestDeviceType;

    //Device object that mates with this one for the Iso In->Out tests
    PDEVICE_OBJECT      MateDeviceObject;
    
    // Indicates that we have recieved a STOP message
    ULONG Stopped;

    // Indicates that the device has been removed or disabled and we need to stop submitting transfers on it
    ULONG StopTransfers;

    // Indicates if outstanding transfers exist on this device
    ULONG DeviceIsBusy;
    
    // Indicates the device needs to be cleaned up (ie., some configuration
    // has occurred and needs to be torn down).
    ULONG NeedCleanup;

    // Indicates that a user request is requesting the Iso test to stop
    ULONG bStopIsoTest;

    // A counter that is decremented by the driver once the bStopIsoTest flag is set, until this
    // reaches zero, at which time the iso tests are stopped
    // NOTE: (kosar) this is done to work around a reentrancy problem
    ULONG ulCountDownToStop;

    ULONG ulNumberOfOutstandingIrps;

    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // Number of Interfaces on this device
    ULONG NumberOfInterfaces;
    
    // Pointers to interface info structs
        PUSBD_INTERFACE_INFORMATION       Interface[MAX_INTERFACE];

    // Pointer to the configuration and status information structure (allocated at device attach)
    pConfig_Stat_Info            pConfig_Stat_Information;
    
    // Timer stuff for timeout / watchdog code
        KTIMER                                            TimeoutTimer;
        KDPC                                              TimeoutDpc;

    // Name buffer for our named Functional device object link
    WCHAR DeviceLinkNameBuffer[ISOPERF_NAME_MAX];

    
    
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#if DBG
#define ISOPERF_KdPrint(_x_) DbgPrint("IPERF: "); \
                             DbgPrint _x_ ;
#define TRAP() DbgBreakPoint()

#define ISOPERF_KdPrint_MAXDEBUG(_x_) \
if (gIsoPerfMaxDebug==TRUE){ \
ISOPERF_KdPrint(_x_)  \
} \

#else
#define ISOPERF_KdPrint(_x_)
#define ISOPERF_KdPrint_MAXDEBUG(_x_)
#define TRAP()
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

NTSTATUS
ISOPERF_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
ISOPERF_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
ISOPERF_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ISOPERF_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ISOPERF_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ISOPERF_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

NTSTATUS
ISOPERF_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ISOPERF_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    );

NTSTATUS
ISOPERF_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ISOPERF_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ISOPERF_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ISOPERF_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ISOPERF_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ISOPERF_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface
    );

VOID
ISOPERF_Cleanup(
    PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ISOPERF_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ISOPERF_CallUSBDEx (
        IN PDEVICE_OBJECT DeviceObject,
        IN PURB Urb,
    IN BOOLEAN fBlock,
    PIO_COMPLETION_ROUTINE CompletionRoutine,
    PVOID pvContext,
    BOOLEAN fWantTimeOut
    );

VOID
ISOPERF_SyncTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

ULONG 
ISOPERF_Internal_GetNumberOfPipes (
    PUSB_CONFIGURATION_DESCRIPTOR pCD
    );

PVOID
ISOPERF_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes,
    IN PULONG pTallyOfBytesAllocated
    );

VOID
ISOPERF_ExFreePool(
    IN PVOID P,
    IN PULONG pTallyBytesFreed
    );
    
#endif      //DRIVER section
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isoperf.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\iso.h ===
extern ULONG gulBytesAllocated;
extern ULONG gulBytesFreed;

#define GET_PENTIUM_CLOCK_COUNT(u,l)\
{ \
_asm push eax \
_asm push ebx \
_asm _emit 0x0f \
_asm _emit 0x31 \
_asm mov l,eax \
_asm mov u,edx \
_asm pop ebx \
_asm pop eax \
} 

#define FIRE_OFF_CATC outp (0x378, 00) 
#define RESTART_CATC outp (0x378, 0xFF)

// My own Assert where I don't want to continue if I hit this error condition
// DON'T append a semicolon to this.
#define ISO_ASSERT( exp ) \
    if (!(exp)) { \
        RtlAssert( #exp, __FILE__, __LINE__, NULL ); \
        return (0); \
    }

#define PIPEINFO_FROM_DEVOBJ(D,I,P) (&(D->Interface[I]->Pipes[P]));

typedef struct __IsoTransferContext__ {
    PURB                    urb;
    PDEVICE_OBJECT          DeviceObject;
    PUSBD_PIPE_INFORMATION  PipeInfo;
    PIRP                    irp;
    PVOID                   pvBuffer;
    ULONG                   ulBufferLen;
    ULONG                   NumPackets;
    ULONG                   PipeNumber;
    ULONG                   ulLastData;
    BOOLEAN                 bFirstUrb;
    KTIMER                  Timer;
    KDPC                    Dpc;
}IsoTxferContext, *PIsoTxterContext;


NTSTATUS 
ISOPERF_StartIsoTest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
ISOPERF_RefreshIsoUrb(
    PURB urb,
    USHORT packetSize,
    USBD_PIPE_HANDLE pipeHandle,
    PVOID pvDataBuffer,
    ULONG ulDataBufferLen
    );

NTSTATUS
ISOPERF_IsoInCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

PURB
ISOPERF_BuildIsoRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION pPipeDesc,
    IN BOOLEAN Read,
    IN ULONG length,
    IN ULONG ulFrameNumber,
    IN PVOID pvTransferBuffer,
    IN PMDL pMDL
    );


ULONG
ISOPERF_StartIsoInTest (
                PDEVICE_OBJECT DeviceObject,
                PIRP           pIrp
               );

PVOID 
ISOPERF_GetBuff (
                PDEVICE_OBJECT DeviceObject,
                ULONG          ulPipeNumber,
                ULONG          ulInterfaceNumber,
                ULONG          ulNumberOfFrames,
                PULONG         pulBufferSize
                );

NTSTATUS
ISOPERF_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN USBD_PIPE_INFORMATION * pPipeInfo
    );
                
ULONG
ISOPERF_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject
    );
    
    
NTSTATUS 
ISOPERF_StopIsoInTest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );    
    

BOOLEAN
ISOPERF_IsDataGood(PIsoTxterContext pIsoContext);

NTSTATUS
ISOPERF_GetStats (
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN OUT  pConfig_Stat_Info   pStatInfo,
    IN      ULONG               ulBufferLen
    );

NTSTATUS
ISOPERF_SetDriverConfig (
    IN      PDEVICE_OBJECT      DeviceObject,
    IN      PIRP                Irp,
    IN OUT  pConfig_Stat_Info   pConfInfoIn,
    IN      ULONG               ulBufferLen
    );

NTSTATUS
ISOPERF_FindMateDevice (
    PDEVICE_OBJECT DeviceObject
    );

VOID 
ISOPERF_StartIsoOutTest (
   IN PISOPERF_WORKITEM IsoperfWorkItem
   );

NTSTATUS
ISOPERF_IsoOutCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ISOPERF_TimeStampUrb ( 	PVOID urb,
						PULONG pulLower,
						PULONG pulUpper
						);

NTSTATUS
ISOPERF_GetUrbTimeStamp ( 	PVOID urb,
							PULONG pulLower,
							PULONG pulUpper
							);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\isoperf.c ===
/*++

Copyright (c) 1996  Microsoft Corporation
Copyright (c) 1996  Intel Corporation

Module Name:
    ISOPERF.c

Abstract:
    USB device driver for ISOPERF USB Device

Environment:
    kernel mode only

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
  Copyright (c) 1996  Intel Corporation  All Rights Reserved.

Revision History:

  8-15-96:  Version 1.0   Kosar Jaff


--*/

#define DRIVER

#define DEADMAN_TIMEOUT     5000     //timeout in ms
                                     //use a 5 second timeout

/*
// Include files needed for WDM driver support
*/
#pragma warning(disable:4214) //  bitfield nonstd
#include "wdm.h"
#pragma warning(default:4214) 

#include "stdarg.h"
#include "stdio.h"

/*
// Include files needed for USB support
*/

#pragma warning(disable:4200) //non std struct used
#include "usbdi.h"
#pragma warning(default:4200)

#include "usbdlib.h"
#include "usb.h"

/*
// Include file for the ISOPERF Device
*/
#include "ioctl.h"
#include "ISOPERF.h"
#include "iso.h"

ULONG gulInstanceNumber = 0;
ULONG gIsoPerfMaxDebug = TRUE;

// NOTE (old code) (kjaff)
// due to WDM loading separate images for the same ven/prod device, we can't rely on a device
// chain, so...if we find an iso out dev obj we put it here as a short term fix
//
PDEVICE_OBJECT gMyOutputDevice = NULL; 

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Installable driver initialization entry point.
        This is where the driver is called when the driver is being loaded
        by the I/O system.  This entry point is called directly by the I/O system.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;

    ISOPERF_KdPrint (("entering (ISOPERF) DriverEntry (build time/date: %s/%s\n",__TIME__,__DATE__));

    DriverObject->MajorFunction[IRP_MJ_CREATE] = ISOPERF_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = ISOPERF_Close;
    DriverObject->DriverUnload = ISOPERF_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ISOPERF_ProcessIOCTL;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = ISOPERF_Write;
    DriverObject->MajorFunction[IRP_MJ_READ] = ISOPERF_Read;

    DriverObject->MajorFunction[IRP_MJ_PNP] = ISOPERF_Dispatch;
    DriverObject->DriverExtension->AddDevice = ISOPERF_PnPAddDevice;

    ISOPERF_KdPrint (("exiting (ISOPERF) DriverEntry (%x)\n", ntStatus));

    ISOPERF_KdPrint (("sizeof IsoStats: %d\n",sizeof(Config_Stat_Info)));

    return ntStatus;
}


NTSTATUS
ISOPERF_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    /*
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    */
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    deviceExtension = DeviceObject->DeviceExtension;

    switch (irpStack->MajorFunction) {

        case IRP_MJ_PNP:

            /*
            //
            // This IRP is for Plug and Play and Power Management messages for your device.
            //
            // When your device is first installed, the port on the hub to which it
            // is attached is powered on and the USB software subsystem does some
            // minimal querying of the device.  After the USB subsystem is done with that
            // basic communication, (the device ID has been determined, and the device
            // has been given a unique USB bus address), it is considered "powered" by
            // the system.  The IRP's minor code gives more information about the power event.
            //
            // Similarly, when the USB device is being removed from the system, the Plug
            // and Play subsystem and the USB software stack interact to notify the
            // appropriate driver using this same IRP code, although in this case the
            // minor code gives more information about the exact power event.
            //
            */

            ISOPERF_KdPrint (("IRP_MJ_PNP\n"));

            switch (irpStack->MinorFunction) {
                case IRP_MN_START_DEVICE:

                    ISOPERF_KdPrint (("IRP_MN_START_DEVICE\n"));

                    /*
                    // We pass the Irp down to the underlying PDO first since that driver
                    // may have some configuration work to do before we can control the device
                    */
                    nextStack = IoGetNextIrpStackLocation(Irp);
                    ASSERT(nextStack != NULL);
                    RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

                    ISOPERF_KdPrint (("Passing START_DEVICE Irp down\n"));

                    // This will be deviceExtension->StackDeviceObject in future revisions of this driver
                    ntStatus = IoCallDriver(deviceExtension->PhysicalDeviceObject, Irp);

                    ISOPERF_KdPrint (("Back from passing START_DEVICE Irp down; status: %#X\n", ntStatus));

                    // Now we can begin our configuration actions on the device
                    ntStatus = ISOPERF_StartDevice(DeviceObject);

                    break; //IRP_MN_START_DEVICE

                case IRP_MN_STOP_DEVICE:

                    ISOPERF_KdPrint (("IRP_MN_STOP_DEVICE\n"));

                    ISOPERF_Cleanup (DeviceObject);

                    ntStatus = ISOPERF_StopDevice(DeviceObject);

                    break; //IRP_MN_STOP_DEVICE

                case IRP_MN_REMOVE_DEVICE:

                    /*
                    // Note:  This IRP handler will change slightly in future revisions of this
                    //        sample driver.  Please watch this space for updates.
                    */
                    ISOPERF_KdPrint (("IRP_MN_REMOVE_DEVICE\n"))

                    ISOPERF_Cleanup (DeviceObject);

                    ntStatus = ISOPERF_RemoveDevice(DeviceObject);

                    break; //IRP_MN_REMOVE_DEVICE

                case IRP_MN_QUERY_STOP_DEVICE:
                    ISOPERF_KdPrint (("IRP_MN_QUERY_STOP_DEVICE\n"));
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    ISOPERF_KdPrint (("IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    ISOPERF_KdPrint (("IRP_MN_CANCEL_STOP_DEVICE\n"));
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    ISOPERF_KdPrint (("IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    break;

                default:
                    // A PnP Minor Function was not handled
                    ISOPERF_KdPrint (("PnP IOCTL not handled\n"));

            } /* switch MinorFunction*/


            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

            /*
            // All PNP_POWER messages get passed to the PhysicalDeviceObject
            // (which in future revisions of this driver will be the StackDeviceObject)
            // we were given in PnPAddDevice.
                    //
                    // This physical device object is managed by the USB software subsystem,
                    // and so this IRP must be propagated to the owning device driver for
                    // that physical device object, so that driver in turn can perform any
                    // device state management (e.g., remove its device object, etc.).
            */

            ISOPERF_KdPrint (("Passing PnP Irp down, status = %x\n", ntStatus));

            // This will be deviceExtension->StackDeviceObject in future revisions of this driver
            ntStatus =
                IoCallDriver(deviceExtension->PhysicalDeviceObject, Irp);

            /*
            // If lower layer driver marked the Irp as pending then reflect that by
            // calling IoMarkIrpPending.
            */
            if (ntStatus == STATUS_PENDING) {
                IoMarkIrpPending(Irp);
                ISOPERF_KdPrint (("PnP Irp came back with STATUS_PENDING (%x)\n", ntStatus));
            } else {
                ISOPERF_KdPrint (("PnP Irp came back, status = %x\n", ntStatus));
            } // if ntStatus

            goto ISOPERF_Dispatch_Done;
            
            break; //IRP_MJ_PNP

        case IRP_MJ_POWER:

            /*
            //
            // This IRP is for Plug and Play and Power Management messages for your device.
            //
            // When your device is first installed, the port on the hub to which it
            // is attached is powered on and the USB software subsystem does some
            // minimal querying of the device.  After the USB subsystem is done with that
            // basic communication, (the device ID has been determined, and the device
            // has been given a unique USB bus address), it is considered "powered" by
            // the system.  The IRP's minor code gives more information about the power event.
            //
            // Similarly, when the USB device is being removed from the system, the Plug
            // and Play subsystem and the USB software stack interact to notify the
            // appropriate driver using this same IRP code, although in this case the
            // minor code gives more information about the exact power event.
            //
            */

            ISOPERF_KdPrint (("IRP_MJ_POWER\n"));

            switch (irpStack->MinorFunction) {

                case IRP_MN_SET_POWER:

                    switch (irpStack->Parameters.Power.Type) {
                        case SystemPowerState:
                            break; //SystemPowerState

                        case DevicePowerState:
                            switch (irpStack->Parameters.Power.State.DeviceState) {
                                case PowerDeviceD3:
                                    ISOPERF_KdPrint (("IRP_MN_SET_D3\n"));
                                    break;
                                case PowerDeviceD2:
                                    ISOPERF_KdPrint (("IRP_MN_SET_D2\n"));
                                    break;
                                case PowerDeviceD1:
                                    ISOPERF_KdPrint (("IRP_MN_SET_D1\n"));
                                    break;
                                case PowerDeviceD0:
                                    ISOPERF_KdPrint (("IRP_MN_SET_D0\n"));
                                    break;
                            } // switch on Power.State.DeviceState

                            break; //DevicePowerState

                    }// switch on Power.Type

                    break;  //IRP_MN_SET_POWER

                 case IRP_MN_QUERY_POWER:

                    // Look at what type of power query this is
                    
                    switch (irpStack->Parameters.Power.Type) {
                        case SystemPowerState:
                            break; //SystemPowerState

                        case DevicePowerState:
                            switch (irpStack->Parameters.Power.State.DeviceState) {
                                case PowerDeviceD2:
                                    ISOPERF_KdPrint (("IRP_MN_QUERY_D2\n"));
                                    break;
                                case PowerDeviceD1:
                                    ISOPERF_KdPrint (("IRP_MN_QUERY_D1\n"));
                                    break;
                                case PowerDeviceD3:
                                    ISOPERF_KdPrint (("IRP_MN_QUERY_D3\n"));
                                    break;
                            } //switch on Power.State.DeviceState

                            break; //DevicePowerState
                            
                    }//switch on Power.Type

                    break; //IRP_MN_QUERY_POWER

                default:
                    // A Power Minor Function was not handled
                    ISOPERF_KdPrint (("Power IOCTL not handled\n"));

            } /* switch MinorFunction*/


            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

            /*
            // All PNP_POWER messages get passed to the PhysicalDeviceObject
            // (which in future revisions of this driver will be the StackDeviceObject)
            // we were given in PnPAddDevice.
                    //
                    // This physical device object is managed by the USB software subsystem,
                    // and so this IRP must be propagated to the owning device driver for
                    // that physical device object, so that driver in turn can perform any
                    // device state management (e.g., remove its device object, etc.).
            */

            ISOPERF_KdPrint (("Passing power down, status = %x\n", ntStatus));

            // This will be deviceExtension->StackDeviceObject in future revisions of this driver
            ntStatus =
                IoCallDriver(deviceExtension->PhysicalDeviceObject, Irp);

            /*
            // If lower layer driver marked the Irp as pending then reflect that by
            // calling IoMarkIrpPending.
            */
            if (ntStatus == STATUS_PENDING) {
                IoMarkIrpPending(Irp);
                ISOPERF_KdPrint (("PnP Irp came back with STATUS_PENDING (%x)\n", ntStatus));
            } else {
                ISOPERF_KdPrint (("PnP Irp came back, status = %x\n", ntStatus));
            } // if ntStatus

            goto ISOPERF_Dispatch_Done;
            
            break; //IRP_MJ_POWER

        default:
            ISOPERF_KdPrint (("A MAJOR IOCTL Code was not handled: %#X\n",
                              irpStack->MajorFunction));

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

        } /* switch MajorFunction */


    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

ISOPERF_Dispatch_Done:

    ISOPERF_KdPrint (("Exit ISOPERF_Dispatch %x\n", ntStatus));

    return ntStatus;

}//ISOPERF_Dispatch


VOID
ISOPERF_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.
    TODO: This is a placeholder for driver writer to add code on unload

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    ISOPERF_KdPrint (("enter ISOPERF_Unload\n"));
    /*
    // TODO: Free any global resources allocated in DriverEntry
    */
    ISOPERF_KdPrint (("exit ISOPERF_Unload\n"));
}


NTSTATUS
ISOPERF_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Initializes a given instance of the ISOPERF Device on the USB.

    TODO:  Perform any device initialization and querying here.  For example,
           this routine queries the device's descriptors.  Your device can
                   be queried in a similar fashion with more specific requests that are
                   tailored to your device's functionality.

Arguments:
    DeviceObject - pointer to the device object for this instance of a
                    ISOPERF Device

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb;
    ULONG siz;

    ISOPERF_KdPrint (("enter ISOPERF_StartDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    deviceExtension->NeedCleanup = TRUE;

    /*
    // Get some memory from then non paged pool (fixed, locked system memory)
    // for use by the USB Request Block (urb) for the specific USB Request we
    // will be performing below (a USB device request).
    */
    urb = ISOPERF_ExAllocatePool(NonPagedPool,
                     sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                     &gulBytesAllocated);

    if (urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);

        // Get some non paged memory for the device descriptor contents
        deviceDescriptor = ISOPERF_ExAllocatePool(NonPagedPool,
                                  siz,
                                  &gulBytesAllocated);

        if (deviceDescriptor) {

            // Use a macro in the standard USB header files to build the URB
            UsbBuildGetDescriptorRequest(urb,
                             (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                             USB_DEVICE_DESCRIPTOR_TYPE,
                             0,
                             0,
                             deviceDescriptor,
                             NULL,
                             siz,
                             NULL);

            // Get the device descriptor
            ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

            // Dump out the descriptor info to the debugger
            if (NT_SUCCESS(ntStatus)) {
                ISOPERF_KdPrint (("Device Descriptor = %x, len %x\n",
                                deviceDescriptor,
                                urb->UrbControlDescriptorRequest.TransferBufferLength));

                ISOPERF_KdPrint (("ISOPERF Device Descriptor:\n"));
                ISOPERF_KdPrint (("-------------------------\n"));
                ISOPERF_KdPrint (("bLength %d\n", deviceDescriptor->bLength));
                ISOPERF_KdPrint (("bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                ISOPERF_KdPrint (("bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                ISOPERF_KdPrint (("bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                ISOPERF_KdPrint (("bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                ISOPERF_KdPrint (("bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                ISOPERF_KdPrint (("bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                ISOPERF_KdPrint (("idVendor 0x%x\n", deviceDescriptor->idVendor));
                ISOPERF_KdPrint (("idProduct 0x%x\n", deviceDescriptor->idProduct));
                ISOPERF_KdPrint (("bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                ISOPERF_KdPrint (("iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                ISOPERF_KdPrint (("iProduct 0x%x\n", deviceDescriptor->iProduct));
                ISOPERF_KdPrint (("iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                ISOPERF_KdPrint (("bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
            }
        } else {
            ntStatus = STATUS_NO_MEMORY;
        }

        if (NT_SUCCESS(ntStatus)) {
            /*
            // Put a ptr to the device descriptor in the device extension for easy
            // access (like a "cached" copy).  We will free this memory when the
            // device is removed.  See the "ISOPERF_RemoveDevice" code.
            */
            deviceExtension->DeviceDescriptor = deviceDescriptor;
            deviceExtension->Stopped = FALSE;
        } 

        if (urb) {
            ISOPERF_ExFreePool(urb, &gulBytesFreed);
        }/* if urb */

    } else {
        ntStatus = STATUS_NO_MEMORY;
    }

        // If the Get_Descriptor call was successful, then configure the device.
        if (NT_SUCCESS(ntStatus)) {
        ntStatus = ISOPERF_ConfigureDevice(DeviceObject);
    }

    ISOPERF_KdPrint (("exit ISOPERF_StartDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
ISOPERF_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Removes a given instance of a ISOPERF Device device on the USB.

Arguments:
    DeviceObject - pointer to the device object for this instance of a ISOPERF Device

Return Value:
    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    int nInterfaceNumber;
    
    ISOPERF_KdPrint (("enter ISOPERF_RemoveDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // After all the outstanding transfers are done, the test routines will clear the DeviceIsBusy flag
    if (deviceExtension->DeviceIsBusy) {
        ISOPERF_KdPrint (("RemoveDevice: Device is still busy\n"));

        //Tell test routines to stop submitting txfers
        deviceExtension->StopTransfers = TRUE; 

        ntStatus = STATUS_DEVICE_BUSY;

    }else{        

        ISOPERF_KdPrint (("Freeing up Device Descriptor in DevExtension (%X)\n",deviceExtension->DeviceDescriptor));
        
        if (deviceExtension->DeviceDescriptor) {
            ISOPERF_ExFreePool(deviceExtension->DeviceDescriptor,
                                &gulBytesFreed);
        }
    
        // Free up any interface structures in our device extension


        for (nInterfaceNumber=0;nInterfaceNumber < MAX_INTERFACE; nInterfaceNumber++) {

            ISOPERF_KdPrint (("Freeing USBD Interfce Objs %d in DevExt: (%X)\n",
                                nInterfaceNumber,
                                deviceExtension->Interface[nInterfaceNumber]));

            if ((deviceExtension->Interface[nInterfaceNumber]) != NULL) {
                ISOPERF_ExFreePool(deviceExtension->Interface[nInterfaceNumber], &gulBytesFreed);
            }//if

        }/* for all the interfaces */

        // Free up the device's config and stat memory
        if ((deviceExtension->pConfig_Stat_Information)!=NULL) {
            ISOPERF_ExFreePool (deviceExtension->pConfig_Stat_Information, &gulBytesFreed);
        }/* if valid device config/stat space */
        
        /* 
        // If someone has a symbolic link open, then just indicate in the dev ext that the device is stopped
        // since it's possible that the device object will stick around
        */
        deviceExtension->Stopped = TRUE;
        
        /*
        // Delete the link to the Stack Device Object, and delete the
        // Functional Device Object we created
        */
        IoDetachDevice(deviceExtension->StackDeviceObject);

        IoDeleteDevice (DeviceObject);

    }/*else it's ok to free up parts of the device object */
    
    ISOPERF_KdPrint (("exit ISOPERF_RemoveDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
ISOPERF_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
    Stops a given instance of a ISOPERF Device device on the USB.

Arguments:
    DeviceObject - pointer to the device object for this instance of a ISOPERF Device

Return Value:
    NT status code

  --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz;

    ISOPERF_KdPrint (("enter ISOPERF_StopDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    /*
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    */

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);

    urb = ISOPERF_ExAllocatePool(NonPagedPool,
                         siz,
                         &gulBytesAllocated);

    if (urb) {
        NTSTATUS status;

        UsbBuildSelectConfigurationRequest(urb,
                                          (USHORT) siz,
                                          NULL);

        status = ISOPERF_CallUSBD(DeviceObject, urb);

        ISOPERF_KdPrint (("Device Configuration Closed status = %x usb status = %x.\n",
                        status, urb->UrbHeader.Status));

        ISOPERF_ExFreePool(urb, &gulBytesFreed);
    } else {
        ntStatus = STATUS_NO_MEMORY;
    }

    ISOPERF_KdPrint (("exit ISOPERF_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
ISOPERF_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of ISOPERF
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;

    ISOPERF_KdPrint(("enter ISOPERF_PnPAddDevice\n"));

    // create our funtional device object (FDO)
    ntStatus =
        ISOPERF_CreateDeviceObject(DriverObject, &deviceObject, gulInstanceNumber);

    if (NT_SUCCESS(ntStatus)) {
        deviceExtension = deviceObject->DeviceExtension;

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
        // Add more flags here if your driver supports other specific
        // behavior.  For example, if your IRP_MJ_READ and IRP_MJ_WRITE
        // handlers support DIRECT_IO, you would set that flag here.
        //
        // Also, store away the Physical device Object
        */
        deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

        //
        // Attach to the StackDeviceObject.  This is the device object that what we 
        // use to send Irps and Urbs down the USB software stack
        //
        deviceExtension->StackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        ASSERT (deviceExtension->StackDeviceObject != NULL);
        
    }

    gulInstanceNumber++;
    
    ISOPERF_KdPrint(("exit ISOPERF_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
ISOPERF_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    )
/*++

Routine Description:
    Creates a Functional DeviceObject

Arguments:
    DriverObject - pointer to the driver object for device
    DeviceObject - pointer to DeviceObject pointer to return
                   created device object.
    Instance - instnace of the device create.

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise
--*/
{
    NTSTATUS ntStatus;
    WCHAR deviceLinkBuffer[]  = L"\\DosDevices\\ISOPERF-0";
    UNICODE_STRING deviceLinkUnicodeString;
    WCHAR deviceNameBuffer[]  = L"\\Device\\ISOPERF-0";
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_EXTENSION deviceExtension;
    int i;

    ISOPERF_KdPrint(("enter ISOPERF_CreateDeviceObject instance = %d\n", Instance));

    /*
    // fix up device names based on Instance
    //
    // NOTE:  Watch this space for potential changes to this approach in future revisions
    //        of this sample driver.
    */

    deviceLinkBuffer[19] = (USHORT) ('0' + Instance);
    deviceNameBuffer[15] = (USHORT) ('0' + Instance);

    ISOPERF_KdPrint(("Create Device name (%ws)\n", deviceNameBuffer));

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);

    ntStatus = IoCreateDevice (DriverObject,
                               sizeof (DEVICE_EXTENSION),
                               &deviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               DeviceObject);


    if (NT_SUCCESS(ntStatus)) {
        RtlInitUnicodeString (&deviceLinkUnicodeString,
                              deviceLinkBuffer);

        ISOPERF_KdPrint(("Create DosDevice name (%ws)\n", deviceLinkBuffer));

        ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString,
                                         &deviceNameUnicodeString);

        // Initialize our device extension
        deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

        RtlCopyMemory(deviceExtension->DeviceLinkNameBuffer,
                      deviceLinkBuffer,
                      sizeof(deviceLinkBuffer));

        deviceExtension->ConfigurationHandle    = NULL;
        deviceExtension->DeviceDescriptor       = NULL;
        deviceExtension->NeedCleanup            = TRUE;
        deviceExtension->Stopped                = FALSE;


        //init to some huge number; this doesn't get decremented by this driver unless
        //the user has requested a stop (in the app)
        deviceExtension->ulCountDownToStop = 0xFFFFFFFF;                                     

        // Initialize our interface
        for (i=0;i<MAX_INTERFACE;i++) {
            deviceExtension->Interface[i] = NULL;
        }//for

    }

    ISOPERF_KdPrint(("exit ISOPERF_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}

VOID
ISOPERF_Cleanup(
    PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
        Cleans up certain elements of the device object.  This is called when the device
        is being removed from the system

Arguments:
        DeviceObject - pointer to DeviceObject

Return Value:
    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING deviceLinkUnicodeString;

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->NeedCleanup) {

        deviceExtension->NeedCleanup    = FALSE;
        deviceExtension->StopTransfers  = TRUE; //Let test thread know it should stop transfers
        deviceExtension->Stopped        = TRUE; //Let everyone know this device is not working
        
        RtlInitUnicodeString (&deviceLinkUnicodeString,
                              deviceExtension->DeviceLinkNameBuffer);

        IoDeleteSymbolicLink(&deviceLinkUnicodeString);
    }
}


NTSTATUS
ISOPERF_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    )
/*++

Routine Description:
    Passes a Usb Request Block (URB) to the USB class driver (USBD)

    Note that we create our own IRP here and use it to send the request to
        the USB software subsystem.  This means that this routine is essentially
        independent of the IRP that caused this driver to be called in the first
        place.  The IRP for this transfer is created, used, and then destroyed
        in this routine.

    However, note that this routine uses the Usb Request Block (urb) passed
        in by the caller as the request block for the USB software stack.

    Implementation of this routine may be changed depending on the specific
        requirements of your driver.  For example, while this routine issues a
        synchronous request to the USB stack, you may wish to implement this as an
        asynchronous request in which you set an IoCompletionRoutine to be called
        when the request is complete.

Arguments:
    DeviceObject - pointer to the device object for this instance of an ISOPERF Device
    Urb          - pointer to Urb request block

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    ISOPERF_KdPrint (("enter ISOPERF_CallUSBD\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // issue a synchronous request (see notes above)
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                deviceExtension->StackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    // Prepare for calling the USB driver stack
    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    // Set up the URB ptr to pass to the USB driver stack
    nextStack->Parameters.Others.Argument1 = Urb;

    ISOPERF_KdPrint (("Calling USB Driver Stack\n"));

    /*
    // Call the USB class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    */
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);

    ISOPERF_KdPrint (("return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) {
        ISOPERF_KdPrint (("Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        ISOPERF_KdPrint (("Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;
    }

    ISOPERF_KdPrint (("URB status = %x status = %x irp status %x\n",
        Urb->UrbHeader.Status, status, ioStatus.Status));

    ntStatus = ioStatus.Status;

    ISOPERF_KdPrint(("exit ISOPERF_CallUSBD (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
ISOPERF_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
    Configures the USB device via USB-specific device requests and interaction
        with the USB software subsystem.

Arguments:
    DeviceObject - pointer to the device object for this instance of the ISOPERF Device

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;

    ISOPERF_KdPrint (("enter ISOPERF_ConfigureDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // Get the config descriptor from the device
    
    // Get memory for the USB Request Block (urb) for the Getconfigdesc request.
    urb = ISOPERF_ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                         &gulBytesAllocated);

    if (urb != NULL) {

        /*
        // Set size of the data buffer.  Note we add padding to cover hardware faults
        // that may cause the device to go past the end of the data buffer
        */
        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 16;

        // Get the nonpaged pool memory for the data buffer
        configurationDescriptor = ISOPERF_ExAllocatePool(NonPagedPool,
                                         siz,
                                         &gulBytesAllocated);

        if (configurationDescriptor != NULL) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         sizeof (USB_CONFIGURATION_DESCRIPTOR),/* Get only the configuration descriptor */
                                         NULL);

            ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus))
            {
                ISOPERF_KdPrint (("Configuration Descriptor is at %x, bytes txferred: %d\n\
                                  Configuration Descriptor Actual Length: %d\n",
                                  configurationDescriptor,
                                  urb->UrbControlDescriptorRequest.TransferBufferLength,
                                  configurationDescriptor->wTotalLength));
            }//if

        } else {
            ntStatus = STATUS_NO_MEMORY;
            goto Exit_ISOPERFConfigureDevice;
        }//if-else

        // Determine how much data is in the entire configuration descriptor
        // and add extra room to protect against accidental overrun
        siz = configurationDescriptor->wTotalLength + 16;

        if (configurationDescriptor) {
            //  Free up the data buffer memory just used
            ISOPERF_ExFreePool(configurationDescriptor, &gulBytesFreed);
        }
        
        configurationDescriptor = NULL;

        // Get nonpaged pool memory for the data buffer
        configurationDescriptor = ISOPERF_ExAllocatePool(NonPagedPool,
                                                 siz,
                                                 &gulBytesAllocated);

        // Now get the entire Configuration Descriptor
        if (configurationDescriptor != NULL) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,  // Get all the descriptor data
                                         NULL);

            ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus)) {
                ISOPERF_KdPrint (("Entire Configuration Descriptor is at %x, bytes txferred: %d\n",
                                  configurationDescriptor,
                                  urb->UrbControlDescriptorRequest.TransferBufferLength));
            } else {
                //Error in getting configuration descriptor
                goto Exit_ISOPERFConfigureDevice;
            }//else

        } else {
            // Failed getting data buffer (configurationDescriptor) memory
            ntStatus = STATUS_NO_MEMORY;
            goto Exit_ISOPERFConfigureDevice;
        }//if-else

    } else {
        // failed getting urb memory
        ntStatus = STATUS_NO_MEMORY;
        goto Exit_ISOPERFConfigureDevice;
    }//if-else

    /*
    // We have the configuration descriptor for the configuration
    // we want.
    //
    // Now we issue the SelectConfiguration command to get
    // the  pipes associated with this configuration.
    */
    if (configurationDescriptor) {
        // Get our pipes
        ntStatus = ISOPERF_SelectInterfaces(DeviceObject,
                                           configurationDescriptor,
                                           NULL // Device not yet configured
                                           );
    } //if

Exit_ISOPERFConfigureDevice:

    // Clean up and exit this routine
    if (urb != NULL) {
        ISOPERF_ExFreePool(urb, &gulBytesFreed);                    // Free urb memory
    }//if

    if (configurationDescriptor != NULL) {
        ISOPERF_ExFreePool(configurationDescriptor,&gulBytesFreed);// Free data buffer
    }//if

    ISOPERF_KdPrint (("exit ISOPERF_ConfigureDevice (%x)\n", ntStatus));
    return ntStatus;
}//ISOPERF_ConfigureDevice


NTSTATUS
ISOPERF_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface
    )
/*++

Routine Description:
    Initializes an ISOPERF Device with multiple interfaces

    Note: This routine initializes some memory for the Interface objects in the Device Extension
    that must be freed when the device is torn down.  So, we do NOT free that memory here, but rather
    we free it in the RemoveDevice code path.  This note is intended to help anyone who is maintaining
    this code.  --kjaff 12/20/96

Arguments:
    DeviceObject            - pointer to the device object for this instance of the ISOPERF Device
    ConfigurationDescriptor - pointer to the USB configuration descriptor containing the interface and endpoint
                              descriptors.
    Interface               - pointer to a USBD Interface Information Object
                            - If this is NULL, then this driver must choose its interface based on driver-specific
                              criteria, and the driver must also CONFIGURE the device.
                            - If it is NOT NULL, then the driver has already been given an interface and
                              the device has already been configured by the parent of this device driver.

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL; 
    ULONG siz, numberOfInterfaces, j, nInterfaceNumber, numberOfPipes;
    UCHAR alternateSetting, MyInterfaceNumber;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceObject;

    ISOPERF_KdPrint (("enter ISOPERF_SelectInterfaces\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    MyInterfaceNumber = SAMPLE_INTERFACE_NBR;

    if (Interface == NULL) {

        /*
        // This example driver only supports one interface.  This can be extended
        // to be a dynamically allocated array by your driver.
        */
        numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
                ISOPERF_KdPrint (("Device has %d Interfaces\n",numberOfInterfaces));

        numberOfPipes = 0;          // Initialize to zero

        /*
        // We use alternate interface setting 0 for all interfaces
        */
        alternateSetting = 0;

        /*
        // Call a USBD helper function that returns a ptr to a USB Interface Descriptor given
        // a USB Configuration Descriptor, an Inteface Number, and an Alternate Setting for that Interface
        */
        interfaceDescriptor =
            USBD_ParseConfigurationDescriptor(ConfigurationDescriptor,
                                              MyInterfaceNumber, //interface number (this is bInterfaceNumber from interface descr)
                                              alternateSetting);

        ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor != NULL)
        {
            ISOPERF_KdPrint (("Device has %d Interface(s) | MyInterface (%d) is at: (%#X)\n",
                            numberOfInterfaces, MyInterfaceNumber, interfaceDescriptor));

        } /* if there was a valid interfacedesc */

        numberOfPipes = ISOPERF_Internal_GetNumberOfPipes(ConfigurationDescriptor);

        ISOPERF_KdPrint (("config has %d pipes total on all the interfaces\n",numberOfPipes));
        
        /*
        // Now that we have looked at the interface, we configure the device so that the remainder
        // of the USBD objects will come into existence (ie., pipes, etc.) as a result of the configuration,
        // thus completing the configuration process for the USB device.
        //
        // Allocate a URB big enough for this Select Configuration request
        //
        // NOTE:  The new service USBD_CreateConfigurationRequest will replace some of the
        //        code below.  Future releases of this driver will demonstrate how to use
        //        that service.
        //
        */
        siz = GET_SELECT_CONFIGURATION_REQUEST_SIZE(numberOfInterfaces, numberOfPipes);

        ISOPERF_KdPrint (("size of config request Urb = %d for %d interfaces & %d pipes\n", 
                            siz, 
                            numberOfInterfaces, 
                            numberOfPipes));

        urb = ISOPERF_ExAllocatePool(NonPagedPool,
                             siz,
                             &gulBytesAllocated);

        if (urb) {
            interfaceObject = (PUSBD_INTERFACE_INFORMATION) (&(urb->UrbSelectConfiguration.Interface));

            // set up the input parameters in our interface request structure.
            interfaceObject->Length =
                 GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

            ISOPERF_KdPrint (("size of interface request = %d\n", interfaceObject->Length));
            ISOPERF_KdPrint (("Selecting interface Number: %d Alternate Setting: %d NumEndpoints %d\n", 
                                interfaceDescriptor->bInterfaceNumber,
                                interfaceDescriptor->bAlternateSetting,
                                interfaceDescriptor->bNumEndpoints));

            interfaceObject->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;
            interfaceObject->AlternateSetting = interfaceDescriptor->bAlternateSetting;
            interfaceObject->NumberOfPipes = interfaceDescriptor->bNumEndpoints;

            /*
            // We set up a default max transfer size for the endpoints.  Your driver will
            // need to change this to reflect the capabilities of your device's endpoints.
            */
            for (j=0; j<interfaceDescriptor->bNumEndpoints; j++) {
                interfaceObject->Pipes[j].MaximumTransferSize =
                    USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
            } /* for */

            ISOPERF_KdPrint (("InterfaceObj Inteface Nbr: %d | InterfaceObj AltSett: %d |NbrPip: %d\n",
                                             interfaceObject->InterfaceNumber,
                                             interfaceObject->AlternateSetting,
                                             interfaceObject->NumberOfPipes));

            UsbBuildSelectConfigurationRequest(urb,
                                              (USHORT) siz,
                                              ConfigurationDescriptor);

            ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(urb->UrbSelectConfiguration.Status)) {

                // Get mem for the config and stat space (initialize it later; we need it now since some
                // of the info in this struct depends on the endpoint number and we walk thru the ep nbrs below)
                deviceExtension->pConfig_Stat_Information= 
                    ISOPERF_ExAllocatePool(  NonPagedPool,
                                             sizeof (Config_Stat_Info),
                                             &gulBytesAllocated);

                deviceExtension->dtTestDeviceType = Unknown_Device_Type;
                ISOPERF_KdPrint (("Trying to figure out what type of device (%x) this is...\n", DeviceObject));
                
                // Figure out what type of device this is based on the class/subclass/protocol codes and store that
                // in the device extension variable that holds that information
                if (interfaceDescriptor->bInterfaceClass == USB_CLASS_CODE_TEST_CLASS_DEVICE) {
                    ISOPERF_KdPrint (("This is a Test Class Device\n"));
                    ISOPERF_KdPrint (("Checking Subclass Code (%#X)\n",interfaceDescriptor->bInterfaceSubClass));
                   
                    if (interfaceDescriptor->bInterfaceSubClass == USB_SUBCLASS_CODE_TEST_CLASS_ISO) {
                        ISOPERF_KdPrint (("This is an ISO Test SubClass Device\n"));
                        ISOPERF_KdPrint (("Checking Protocol Code (%#X)\n",interfaceDescriptor->bInterfaceProtocol));

                        switch (interfaceDescriptor->bInterfaceProtocol) {
                            case USB_PROTOCOL_CODE_TEST_CLASS_INPATTERN: 
                            case USB_PROTOCOL_CODE_TEST_CLASS_INPATTERN_ALT: 
                                ISOPERF_KdPrint (("This is an Iso_In_With_Pattern device\n"));
                                deviceExtension->dtTestDeviceType = Iso_In_With_Pattern;
                                break;
                            case USB_PROTOCOL_CODE_TEST_CLASS_OUTINTERR:
                                deviceExtension->dtTestDeviceType = Iso_Out_With_Interrupt_Feedback;
                                ISOPERF_KdPrint (("This is an Iso_Out_With_Interrupt_Feedback device\n"));
                                gMyOutputDevice = DeviceObject; //SHORT term workaround for wdm loading issue
                                break;
                            case USB_PROTOCOL_CODE_TEST_CLASS_OUTNOCHEK:
                                deviceExtension->dtTestDeviceType = Iso_Out_Without_Feedback;
                                ISOPERF_KdPrint (("This is an Iso_Out_WithOut_Feedback device\n"));
                                gMyOutputDevice = DeviceObject; //SHORT term workaround for wdm loading issue
                                break;                                                
                            default:
                                deviceExtension->dtTestDeviceType = Unknown_Device_Type;
                                ISOPERF_KdPrint (("This is an Unknown Protocol Iso test class device type\n"));
                                break;
                        }//switch on protocol code

                    } else {
                        ISOPERF_KdPrint (("This is not a Iso Test SubClass Device\n"));
                    }//else not a test iso dev sub class code
                    
                }else{
                    ISOPERF_KdPrint(("This is not a test class device\n"));
                }//else not a test class dev                                
                        
                // For each of the interfaces on this device, save away the interface information structure
                // that USBD returned on the SelectConfiguration request
                for (nInterfaceNumber=0; nInterfaceNumber < numberOfInterfaces; nInterfaceNumber++) {

                    // Save the configuration handle for this device
                    deviceExtension->ConfigurationHandle =
                        urb->UrbSelectConfiguration.ConfigurationHandle;

                    deviceExtension->Interface[nInterfaceNumber] = ISOPERF_ExAllocatePool(NonPagedPool,
                                                                   interfaceObject->Length,
                                                                   &gulBytesAllocated);

                    if (deviceExtension->Interface[nInterfaceNumber]) {

                        // save a copy of the interfaceObject information returned
                        RtlCopyMemory(deviceExtension->Interface[nInterfaceNumber], interfaceObject, interfaceObject->Length);

                        // Dump the interfaceObject to the debugger
                        ISOPERF_KdPrint (("---------\n"));
                        ISOPERF_KdPrint (("NumberOfPipes 0x%x\n", deviceExtension->Interface[nInterfaceNumber]->NumberOfPipes));
                        ISOPERF_KdPrint (("Length 0x%x\n", deviceExtension->Interface[nInterfaceNumber]->Length));
                        ISOPERF_KdPrint (("Alt Setting 0x%x\n", deviceExtension->Interface[nInterfaceNumber]->AlternateSetting));
                        ISOPERF_KdPrint (("Interface Number 0x%x\n", deviceExtension->Interface[nInterfaceNumber]->InterfaceNumber));

                        // Dump the pipe info
                        for (j=0; j<interfaceObject->NumberOfPipes; j++) {
                            PUSBD_PIPE_INFORMATION pipeInformation;

                            pipeInformation = &deviceExtension->Interface[nInterfaceNumber]->Pipes[j];

                            ISOPERF_KdPrint (("---------\n"));
                            ISOPERF_KdPrint (("PipeType 0x%x\n", pipeInformation->PipeType));
                            ISOPERF_KdPrint (("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                            ISOPERF_KdPrint (("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                            ISOPERF_KdPrint (("Interval 0x%x\n", pipeInformation->Interval));
                            ISOPERF_KdPrint (("Handle 0x%x\n", pipeInformation->PipeHandle));
                            ISOPERF_KdPrint (("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));

                            //NOTE: we only care about the first 2 endpoints on these devices (they must be the first 2 endpoints!)  
                            if ((USB_ENDPOINT_DIRECTION_IN(pipeInformation->EndpointAddress)) && (j<2)) {
                                deviceExtension->pConfig_Stat_Information->ulMaxPacketSize_IN   =pipeInformation->MaximumPacketSize;
                                deviceExtension->pConfig_Stat_Information->ulMaxPacketSize_OUT  =0;
                                ISOPERF_KdPrint (("Endpoint %d is IN\n", j+1));
                            }
                            else if ((USB_ENDPOINT_DIRECTION_OUT(pipeInformation->EndpointAddress)) && (j<2)) {
                                deviceExtension->pConfig_Stat_Information->ulMaxPacketSize_OUT =pipeInformation->MaximumPacketSize;
                                deviceExtension->pConfig_Stat_Information->ulMaxPacketSize_IN  =0;
                                ISOPERF_KdPrint (("Endpoint %d is OUT\n", j+1));
                            }//else it is an OUT endpoint

                        }/* for all the pipes in this interface */

                        ISOPERF_KdPrint (("---------\n"));

                    } /*If ExAllocate passed */

                }/* for all the interfaces on this device */


                // Init the rest of the config and stat space
                deviceExtension->pConfig_Stat_Information->ulNumberOfFrames         =10;
                deviceExtension->pConfig_Stat_Information->ulMax_Urbs_Per_Pipe      =4;
                deviceExtension->pConfig_Stat_Information->ulSuccessfulIrps         =0;
                deviceExtension->pConfig_Stat_Information->ulUnSuccessfulIrps       =0;
                deviceExtension->pConfig_Stat_Information->ulBytesTransferredIn     =0;
                deviceExtension->pConfig_Stat_Information->ulBytesTransferredOut    =0;
                deviceExtension->pConfig_Stat_Information->erError                  =NoError;
                deviceExtension->pConfig_Stat_Information->bStopped                 =0;
                deviceExtension->pConfig_Stat_Information->ulFrameOffset            =200;
                deviceExtension->pConfig_Stat_Information->ulStartingFrameNumber    =0;
                deviceExtension->pConfig_Stat_Information->ulFrameNumberAtStart     =0;
                deviceExtension->pConfig_Stat_Information->UsbdPacketStatCode       =0;
                deviceExtension->pConfig_Stat_Information->UrbStatusCode            =0;
                deviceExtension->pConfig_Stat_Information->ulFrameOffsetMate        =0;
                deviceExtension->pConfig_Stat_Information->bDeviceRunning           =0;
               
            }/* if selectconfiguration request was successful */
                        else {
                                ISOPERF_KdPrint (("Select Configuration Request Failed (urb status: %x)\n",
                                                                urb->UrbSelectConfiguration.Status));
                                                                
                        }/* else selectconfiguration request failed */
        } else {

            ntStatus = STATUS_NO_MEMORY;

        }/* if urb alloc passed  */

       
    }//if Interface was not NULL

    // Clean up
    if (urb != NULL) {
        ISOPERF_ExFreePool (urb, &gulBytesFreed);
    }/* if valid Urb */

    ISOPERF_KdPrint (("exit ISOPERF_SelectInterfaces (%x)\n", ntStatus));

    return ntStatus;

}/* ISOPERF_SelectInterfaces */


NTSTATUS
ISOPERF_CallUSBDEx (
        IN PDEVICE_OBJECT DeviceObject,
        IN PURB Urb,
    IN BOOLEAN fBlock,
    PIO_COMPLETION_ROUTINE CompletionRoutine,
    PVOID pvContext,
    BOOLEAN fWantTimeOut
    )
/**************************************************************************

Routine Description:

        Passes a URB to the USBD class driver

    NOTE:  Creates an IRP to do this.  Doesn't use the IRP that is passed down from user
        mode app (it's not passed to this routine at all).

Arguments:

        DeviceObject - pointer to the device object for this instance of a UTB 

        Urb - pointer to Urb request block

    fBlock - bool indicating if this fn should wait for IRP to return from USBD

    CompletionRoutine - fn to set as the completionroutine for this transfer ONLY IF
                        the fBlock is set to FALSE, indicating that the caller wants
                        to handle completion on their own and this fn should not 
                        block

    pvContext         - Context to be set in setting up the completion routine for the
                        Irp created in this function.  This is passed in by caller and is
                        just a pass-thru to the IoSetCompletionRoutine call.  If this is NULL
                        but there is a CompletionRoutine specified, then the Irp that is created
                        in this app is used as the context.

        fWantTimeOut      - If caller wants this function to use a deadman timeout and cancel
                                                the Irp after the timeout expires.  TRUE means this function will
                                                use the timeout mechanism, and FALSE means this function will block
                                                indefinitely and wait for the Irp/Urb to return from the USB stack.
                                        
Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

**************************************************************************/
{
        NTSTATUS ntStatus, status;
        PDEVICE_EXTENSION deviceExtension;
        PIRP irp;
        KEVENT event;
        PIO_STATUS_BLOCK ioStatus;
        PIO_STACK_LOCATION nextStack;
        BOOLEAN haveTimer=FALSE;
        LARGE_INTEGER dueTime;
    
        ISOPERF_KdPrint_MAXDEBUG (("enter ISOPERF_CallUSBDEx\n"));      

        /*
        {
                KIRQL irql;
                irql = KeGetCurrentIrql();
                ASSERT(irql <= PASSIVE_LEVEL);
        }
        */

        deviceExtension = DeviceObject->DeviceExtension;

        ASSERT (deviceExtension != NULL);
    ASSERT ((deviceExtension->StackDeviceObject) != NULL);

    if ((deviceExtension) && (deviceExtension->StackDeviceObject))
    {
        if (fBlock) {
                // issue a synchronous request to read the USB Device Ctrl pipe
                KeInitializeEvent(&event, NotificationEvent, FALSE);
        }/* if block requested */
        
        // Create the memory for the Io Status Block
        ioStatus = ISOPERF_ExAllocatePool (NonPagedPool, sizeof (IO_STATUS_BLOCK), &gulBytesAllocated);

        // Create the IRP that we'll use to submit this URB to the USB stack
        irp = IoBuildDeviceIoControlRequest(
                        IOCTL_INTERNAL_USB_SUBMIT_URB,
                    deviceExtension->StackDeviceObject,
                    NULL,
                            0,
                    NULL,
                            0,
                    TRUE, /* INTERNAL */
                            fBlock ? &event : NULL,
                    ioStatus); //the status codes in NT IRPs go here

                // remove this Irp from the current thread's list
                RemoveEntryList(&irp->ThreadListEntry);

        // Call the class driver to perform the operation.  If the returned status
        // is PENDING, wait for the request to complete.
        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack != NULL);

        // pass the URB to the USBD 'class driver'
        nextStack->Parameters.Others.Argument1 = Urb;

        // If caller doesn't want this fn to block, then set the iocompletion routine up 
        // for them
        if (fBlock == FALSE) {
            ASSERT (CompletionRoutine != NULL);
            ISOPERF_KdPrint_MAXDEBUG (("Setting compl routine\n"));

            // If the user didn't supply a context, then we'll use the irp as the context
            if (pvContext==NULL) {
                ISOPERF_KdPrint (("No context supplied...setting Irp as context\n"));
                pvContext = (PVOID)irp;
            }
                
            IoSetCompletionRoutine(irp,
                           CompletionRoutine,
                           pvContext,
                           TRUE,        //InvokeOnSuccess
                           TRUE,        //InvokeOnError,
                           FALSE);       //InvokeOnCancel
        }//if

        ISOPERF_KdPrint_MAXDEBUG (("calling USBD\n"));

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                irp);

        // Register that another Irp was put into the stack by incrementing a counter in the dev extension
        if (ntStatus == STATUS_PENDING)
            (deviceExtension->ulNumberOfOutstandingIrps)++;

        // If the Irp came back w/ SUCCESS, then it finished synchronously, so free the IoStatus Block
        if ((ntStatus == STATUS_SUCCESS) && (fBlock == FALSE)) {

            //Free the IoStatus block that we created for this call
                if (irp->UserIosb) {
                    ISOPERF_ExFreePool (irp->UserIosb, &gulBytesFreed);
                }else{
                    //Bogus iostatus pointer.  Bad.
                ISOPERF_KdPrint (("ERROR: Irp's IoStatus block is apparently NULL!\n"));
                    TRAP();
            }//else bad iostatus pointer
            
        }//if successful (sync) Irp
                
        ISOPERF_KdPrint_MAXDEBUG (("return from IoCallDriver USBD in ISOPERF_CallUSBDEx %x\n", ntStatus));

        // After calling USBD only block if the caller requested a block
        if ((ntStatus == STATUS_PENDING) && (fBlock == TRUE))
        {

                if (fWantTimeOut == TRUE) {
                        // Setup timer stuff so we can timeout commands to unresponsive devices
                    KeInitializeTimer(&(deviceExtension->TimeoutTimer));  //build the timer object
                        KeInitializeDpc(&(deviceExtension->TimeoutDpc),       //set up the DPC call based
                                    ISOPERF_SyncTimeoutDPC,             //DPC func
                                    irp);                               //context ptr to pass into DPC func

                    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

                        //NOTE: (kjaff) KeSetTimer returns FALSE for unknown reason so we will hack for now
                        //               and pretend we were successful in setting the timer up
                    KeSetTimer(&(deviceExtension->TimeoutTimer),        //Set the timer params up
                               dueTime,                                 //This is how long to wait
                               &(deviceExtension->TimeoutDpc));         //This is the DPC object we created

                        haveTimer = TRUE;                               //our own local var to finger out if we
                } // if fWantTimeOut == TRUE
                
                ISOPERF_KdPrint_MAXDEBUG (("Waiting for single object\n"));

            status = KeWaitForSingleObject(
                                   &event,
                                   Suspended,
                           KernelMode,
                                   FALSE,
                                   NULL);       

            // Since we waited on the Irp we can safely say it's not outstanding anymore if the Wait completes
            (deviceExtension -> ulNumberOfOutstandingIrps)--;
            
                ISOPERF_KdPrint_MAXDEBUG (("Wait for single object, returned %x\n", status));

                // Now free the IoStatus block since we're done with this Irp (we blocked)
                if (irp->UserIosb) {
                    ISOPERF_ExFreePool (irp->UserIosb, &gulBytesFreed);
                }else{
                    //Bogus iostatus pointer.  Bad.
                ISOPERF_KdPrint (("ERROR: Irp's IoStatus block is apparently NULL!\n"));
                    TRAP();
            }//else bad iostatus pointer

        } //if pending and we want to block
        else 
        {
                
            ISOPERF_KdPrint_MAXDEBUG (("Didn't block calling usbd\n"));         
            ioStatus->Status = ntStatus;                

        }//else we didn't want to block or we didn't get a status pending (it completed)

        ISOPERF_KdPrint_MAXDEBUG (("URB status = %x status = %x irp status %x\n", 
        Urb->UrbHeader.Status, status, ioStatus->Status));

        // USBD maps the error code for us
        ntStatus = ioStatus->Status;
        
        ISOPERF_KdPrint_MAXDEBUG(("URB TransferBufferLength OUT is: %d\n",Urb->UrbControlDescriptorRequest.TransferBufferLength));

        if ((haveTimer==TRUE) && (ntStatus!=STATUS_CANCELLED)) {
            ISOPERF_KdPrint_MAXDEBUG (("Irp wasn't cancelled, so cancelling Timer (%x)\n", (&(deviceExtension->TimeoutTimer))));
            KeCancelTimer(&(deviceExtension->TimeoutTimer));
            ISOPERF_KdPrint_MAXDEBUG (("Done cancelling timer\n"));
        }//if
        
    }//if valid deviceExtension and StackDevObjects 
    else 
    {
        // Invalid extension or stackdevobj received
        ntStatus = STATUS_INVALID_PARAMETER;
        ISOPERF_KdPrint_MAXDEBUG (("Invalid deviceExtension or StackDeviceObject\n"));
    } //else invalid devExt or stackdevobj
    
    ISOPERF_KdPrint_MAXDEBUG(("exiting ISOPERF_CallUSBDEx w/ URB/ntStatus: %x\n", ntStatus));

        return ntStatus;

}//ISOPERF_CallUSBDEx



VOID
ISOPERF_SyncTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
Routine Description:
    This routine runs at DISPATCH_LEVEL IRQL. 
Arguments:
    Dpc                         - Pointer to the DPC object.
    DeferredContext - passed in to IOS by caller as context (we use it as pIrp)
    SystemArgument1 - not used.
    SystemArgument2 - not used.
Return Value:
    None.
--*/
{
    BOOLEAN status;
        PIRP    irp             = DeferredContext; 

        TRAP();
        // The cancel Irp call below will return immediately, but that doesn't mean things are all 
        // cleaned up in the USB stack.  The only way to be assured of that is when the
        // WaitForSingleObject that blocked in the first place returns (due to the USB stack
        // completing the Irp, either due to normal completion or due to this cancel Irp call.
        status = IoCancelIrp(irp);

        //NOTE: (kosar) We don't do anything if the cancel fails, and we probably should.
        //                               (like maybe reschedule or something)

        return;
}

ULONG 
ISOPERF_Internal_GetNumberOfPipes(
    PUSB_CONFIGURATION_DESCRIPTOR pCD
    )
/*++

Routine Description:
    Tallies up the total number of pipes in a given configuration descriptor
    
Arguments:
    Pointer to a Configuration Descriptor

Return Value:
    Non-zero number indicating total number of pipes in the given configuration.
    A value of FFFFFFFF indicates an invalid Configuration Descriptor was received.
    
--*/
{

    int                         nInterfaceNumber    = 0;
    char *                      pcWorkerPtr         = NULL;
    ULONG                       ulNumberOfPipes     = 0;
    PUSB_INTERFACE_DESCRIPTOR   pID                 = NULL;
    
    ISOPERF_KdPrint (("Enter GetNumberOfPipes (%X)\n",pCD));

    //Check if the given descriptor is a valid config descriptor
    if (pCD->bDescriptorType != USB_CONFIGURATION_DESCRIPTOR_TYPE) {

        ISOPERF_KdPrint (("GetNumberOfPipes got a bogus ConfDesc: (%X) (type=%d)\n",pCD,pCD->bDescriptorType));
        return (0xFFFFFFFF);

    }//if bad config descriptor
    
    //Point to the interface descriptor
    pID = (PUSB_INTERFACE_DESCRIPTOR) ((((char*)pCD) + pCD->bLength));

    for (nInterfaceNumber = 0; nInterfaceNumber < pCD->bNumInterfaces; nInterfaceNumber++)
    {

        //Check if this an Interface Descriptor
        if ((pID->bDescriptorType) != USB_INTERFACE_DESCRIPTOR_TYPE) {
            //NOTE right now we just give out and return an error.  This should be fixed
            //to look for a class specific descriptor and try to step over it and go on to find
            //the interface descriptor, but since our 82930 boards will not have class descriptors
            //embedded in there for now, we'll just abort to safeguard against bogus descriptors.

            ISOPERF_KdPrint (("GetNumberOfPipes got a bogus InterfDesc: (%X) (type=%d)\n",pID,pID->bDescriptorType));
   
            return (0xFFFFFFFF);
            
        }//if not an interface descriptor
        
        //Add to tally of number of pipes for this interface
        ulNumberOfPipes += pID->bNumEndpoints;

        //Go to next interface
        pcWorkerPtr = (char*)pID;
        
        pcWorkerPtr +=  (pID->bLength) + 
                        (pID->bNumEndpoints * sizeof (USB_ENDPOINT_DESCRIPTOR));

        // Now you should be pointing to the next interface descriptor
        pID = (PUSB_INTERFACE_DESCRIPTOR) pcWorkerPtr;

      
    }// for all the interfaces on this config


   ISOPERF_KdPrint (("Exit GetNumberOfPipes: (%d)\n",ulNumberOfPipes));

   return (ulNumberOfPipes);
   
}//ISOPERF_Internal_GetNumberOfPipes

#ifndef TOM_MEM

PVOID
ISOPERF_ExAllocatePool(
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes,
    IN PULONG       pTallyOfBytesAllocated
    )
{
    PUCHAR pch;
    PULONG length;

    NumberOfBytes += sizeof(ULONG);

    if (pTallyOfBytesAllocated)
        *pTallyOfBytesAllocated += NumberOfBytes;
    
    pch = ExAllocatePool(PoolType, NumberOfBytes);
    if (pch) {
        length = (PULONG) pch;
        *length = NumberOfBytes;
        ISOPERF_KdPrint_MAXDEBUG (("Allocated %d bytes at %x | TotBytesAlloc: %d\n",NumberOfBytes, pch, *pTallyOfBytesAllocated));
        return (pch+(sizeof(ULONG)));
    } else {
        return NULL;
    }
    
}

VOID
ISOPERF_ExFreePool(
    IN PVOID    P,
    IN PULONG   pTallyOfBytesFreed
    )
{
    PUCHAR pch;
    ULONG length;

    pch = P;
    pch = pch-sizeof(ULONG);
    length = *(PULONG)(pch);

    if (pTallyOfBytesFreed)
        *pTallyOfBytesFreed += (length);

    ISOPERF_KdPrint_MAXDEBUG (("Freeing %d bytes at %x | TotBytesFreed %d\n",length, pch, *pTallyOfBytesFreed));;

    memset(pch, 0xff, length); 
    ExFreePool(pch);
}
#endif

#ifdef TOM_MEM
#define MEM_SIGNATURE                   ((ULONG) 'CLLA')
#define MEM_FREED_SIGNATURE             ((ULONG) 'EERF')


PVOID
ISOPERF_ExAllocatePool(
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes,
    IN PULONG       pTallyOfBytesAllocated
    )
{
        PULONG  pMem;

        // allocate memory plus a little extra for our own use
        pMem = ExAllocatePool(PoolType, NumberOfBytes + (2 * sizeof(ULONG)));

        // see if we actually allocated any memory
        if(pMem)
        {
                // keep track of how much we allocated
                *pTallyOfBytesAllocated += NumberOfBytes;

                // store number of bytes allocated at start of memory allocated
                *pMem++ = NumberOfBytes;

                // now we are pointing at the memory allocated for caller
                // put signature word at end

                // get new pointer that points to end of buffer - ULONG
                pMem = (PULONG) (((PUCHAR) pMem) + NumberOfBytes);

                // write signature
                *pMem = MEM_SIGNATURE;

                // get back pointer to return to caller
                pMem = (PULONG) (((PUCHAR) pMem) - NumberOfBytes);
        }

    //debug only
    ISOPERF_KdPrint_MAXDEBUG (("Allocated %d bytes | returning pv = %x\n",NumberOfBytes,pMem));
    //end debug only
    
        return (PVOID) pMem;    
}

VOID
ISOPERF_ExFreePool(
    IN PVOID    P,
    IN PULONG   pTallyOfBytesFreed
    )
{
        PULONG  pTmp = (PULONG) P;
        ULONG   buffSize;
        PULONG  pSav=pTmp;
        
        // point at size ULONG at start of buffer, and address to free
        pTmp--;

        // get the size of memory allocated by caller
        buffSize = *pTmp;

        // point at signature and make sure it's O.K.
        ((PCHAR) P) += buffSize;

        if(*((PULONG) P) == MEM_SIGNATURE)
        {
                // let's go ahead and get rid of signature in case we get called
                // with this pointer again and memory is still paged in
                *((PULONG) P) = MEM_FREED_SIGNATURE;
                
                // adjust amount of memory allocated
                *pTallyOfBytesFreed += buffSize;
                // free real pointer
                ExFreePool(pTmp);

        ISOPERF_KdPrint_MAXDEBUG (("Freed %d bytes at %x (pvBuff: %x)\n",buffSize, pTmp, (((PUCHAR)pTmp)+sizeof(buffSize)) ));
                
        }
        else {
//debug only
        ISOPERF_KdPrint (("ISOPERF_ExFreePool found incorrect mem signature: %x at %x (orig buff Ptr: %x)\n",*((PULONG)P), P, pSav));
        ISOPERF_KdPrint (("BufferSize: %d\n",buffSize));
//end debug only

                TRAP();
    }//else
    
}

#endif

NTSTATUS
ISOPERF_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
     This is the Entry point for CreateFile calls from user mode apps (apps may open "\\.\ISOPERF-x\yyzz"
     where yy is the interface number and zz is the endpoint address).

         Here is where you would add code to create symbolic links between endpoints
         (i.e., pipes in USB software terminology) and User Mode file names.  You are
         free to use any convention you wish to create these links, although the above
         convention offers a way to identify resources on a device by familiar file and
         directory structure nomenclature.

Arguments:
    DeviceObject - pointer to the device object for this instance of the ISOPERF device

Return Value:
    NT status code
--*/
{
    NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    ISOPERF_KdPrint_MAXDEBUG (("In ISOPERF_Create\n"));
    
    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    ISOPERF_KdPrint_MAXDEBUG (("Exit ISOPERF_Create (%x)\n", ntStatus));

    return ntStatus;

}//ISOPERF_Create


NTSTATUS
ISOPERF_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
    Entry point for CloseHandle calls from user mode apps to close handles they have opened

Arguments:
    DeviceObject - pointer to the device object for this instance of the ISOPERF device
        Irp                      - pointer to an irp

Return Value:
    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    ISOPERF_KdPrint_MAXDEBUG (("In ISOPERF_Close\n"));
    
    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    ISOPERF_KdPrint_MAXDEBUG (("Exit ISOPERF_Close (%x)\n", ntStatus));

    return ntStatus;

}//ISOPERF_Close


NTSTATUS
ISOPERF_Read(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
    This function is called for a IRP_MJ_READ.

    TODO:  Add functionality here for your device driver if it handles that IRP code.

Arguments:

    DeviceObject - pointer to the device object for this instance of the ISOPERF device.
    Irp                  - pointer to IRP

Return Value:

    NT status code
--*/
{
        NTSTATUS ntStatus = STATUS_SUCCESS;

        return (ntStatus);

}


NTSTATUS
ISOPERF_Write(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
    This function is called for a IRP_MJ_WRITE.
    TODO:  Add functionality here for your device driver if it handles that IRP code.

Arguments:
    DeviceObject - pointer to the device object for this instance of the ISOPERF device.
    Irp                  - pointer to IRP

Return Value:
    NT status code
--*/
{

        NTSTATUS ntStatus = STATUS_SUCCESS;

        return (ntStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\app\main.h ===
//main.h

#define VER_MAJ 1
#define VER_MIN_HIGH 1
#define VER_MIN_LOW  0

#define MAX_DRIVER_NAME 128
#define DEVICE_DESCRIPTOR_SIZE 32 /* bigger than we need */
#define MAX_ITEMS_IN_LB 256
#define DUMMY_BUFFER_SIZE 128

#define DRIVER_MAXIMUM_TRANSFER_SIZE 4096
#define MAX_URBS_PER_PIPE 16 //ARBITRARY limit!  also set in the driver this way...

// Clear out the first entry in the output box if the box has too many entries
#define MAINTAIN_OUTPUT_BOX(hO, nI) \
    nI = SendMessage (hO, LB_GETCOUNT, 0, 0); \
    while (nI >= MAX_ITEMS_IN_LB) { \
        SendMessage (hO, LB_DELETESTRING, 0, 0); \
        nI = SendMessage (hO, LB_GETCOUNT, 0, 0); \
    }

#define GET_CONFIG_DESCRIPTOR_LENGTH(pv) \
    ((pUsb_Configuration_Descriptor)pv)->wTotalLength

typedef struct __usb_Dev_Descriptor__ {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
    USHORT idVendor;
    USHORT idProduct;
    USHORT bcdDevice;
    UCHAR iManufacturer;
    UCHAR iProduct;
    UCHAR iSerialNumber;
    UCHAR bNumConfigurations;
} Usb_Device_Descriptor, *pUsb_Device_Descriptor;

typedef struct __usb_Config_Descriptor__ {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT wTotalLength;
    UCHAR bNumInterfaces;
    UCHAR bConfigurationValue;
    UCHAR iConfiguration;
    UCHAR bmAttributes;
    UCHAR MaxPower;
} Usb_Configuration_Descriptor, *pUsb_Configuration_Descriptor;

typedef struct _USB_INTERFACE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bInterfaceNumber;
    UCHAR bAlternateSetting;
    UCHAR bNumEndpoints;
    UCHAR bInterfaceClass;
    UCHAR bInterfaceSubClass;
    UCHAR bInterfaceProtocol;
    UCHAR iInterface;
} Usb_Interface_Descriptor, *pUsb_Interface_Descriptor;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
} Usb_Endpoint_Descriptor, *pUsb_Endpoint_Descriptor;

BOOLEAN
bOpenDriver (HANDLE * phDeviceHandle, HWND hWnd);

void
ParseDeviceDescriptor(PVOID pvBuffer, HWND hOutputBox);

void
ParseConfigurationDescriptor(PVOID pvBuffer, HWND hOutputBox);

BOOLEAN
bCalibrateClockCount(ULONG  ulCurrentUpperClockCount,
                     ULONG  ulLastUpperClockCount,
                     ULONG  ulCurrentLowerClockCount,
                     ULONG  ulLastLowerClockCount,
                     ULONG  ulPeriodInMs,
                     PULONG pulSpeed,
                     PULONG pulOrdinalSpeed);

void CleanUpRegistry(void);

BOOLEAN bGetDriverConfig (HWND hDlg, 
                  HANDLE hDriver,
                  BOOLEAN bFromDriver, 
                  pConfig_Stat_Info pIsoStats);

BOOLEAN
bSetDriverConfig (HWND hDlg,
                  HANDLE hDriver,
                  pConfig_Stat_Info pConfigData);

BOOLEAN
bPrintDeviceType (HWND hDlg, 
                  Config_Stat_Info * pDriverInfo);

void
GetAllStats (HWND hDlg,
             HANDLE hDriver,
             BOOLEAN bUpdateUI,
             UINT    uiPeriodInMs
            );

BOOL
bShutDownIsoTests (HWND hDlg,
					HANDLE hDriver
				   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\app\main.c ===
/*++

Copyright (c) 1996  Intel Corporation

Module Name:
    Main.c

Abstract:
    Iso performance driver app

Environment:
    user mode only

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996  Intel Corporation  All Rights Reserved.

Revision History:

--*/

#include <windows.h>
#include <assert.h>
#include <process.h>
#include <stdio.h>

#include "resource.h"
#include "ioctl.h"
#include "main.h"
#include "devioctl.h"

HINSTANCE hGInstance = NULL;
HANDLE    ghDevice   = INVALID_HANDLE_VALUE;
BYTE gpcDriverName[MAX_DRIVER_NAME] = "ISOPERF00"; //default name

BOOL CALLBACK bMainDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK bGetDriverNameDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

/*******************************
*WinMain: Windows Entry point  *
********************************/
int PASCAL WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpCmdLine,
                   int       nCmdShow)
{
    hGInstance=hInstance;

    LoadIcon (hInstance, MAKEINTRESOURCE(IDI_APP_ICON));

    if(DialogBox(hInstance,"DRIVER_NAME_DIALOG",NULL,(DLGPROC)bGetDriverNameDlgProc)==-1) {
          MessageBox(NULL,"Unable to create dialog!","DialogBox failure",MB_ICONSTOP);
      return 0;
    }//if
        
    if(DialogBoxParam(hInstance,"MAIN_DIALOG",NULL,(DLGPROC)bMainDlgProc,(LPARAM)gpcDriverName)==-1) {
          MessageBox(NULL,"Unable to create root dialog!","DialogBox failure",MB_ICONSTOP);
    }//if

    return 0;
}


BOOL CALLBACK bGetDriverNameDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL status;
    BYTE pcDriverName[MAX_DRIVER_NAME]; 
    char pcTempDriverName[MAX_DRIVER_NAME]; 
    DWORD dwDisposition, dwType, dwBufferSize;  
    HKEY  hkDriverKey = NULL;
    UINT nInstance;

    dwBufferSize = MAX_DRIVER_NAME;
    
    switch(message)
    {
        case WM_INITDIALOG:
            
            RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                            "SOFTWARE\\INTEL\\IAL\\USB\\ISOPERF",
                            0, //reserved
                            "USB Test Devices", //class
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL, //security
                            &hkDriverKey,
                            &dwDisposition);

            if (hkDriverKey) {
                RegQueryValueEx (hkDriverKey,
                                 "LastOpenedDriverName",
                                 0, //reserved
                                 &dwType,
                                 &(pcDriverName[0]),
                                 &dwBufferSize);
                // Close Key
                RegCloseKey(hkDriverKey);

            }//if valid hkey

            // If some data came back then someone is probably loaded
            if ( dwBufferSize>0 ) {

                nInstance = 0;

                strcpy (pcTempDriverName, (const char *)gpcDriverName);

                // Look for a match in the driver name that's loaded in case there's bogus data in the value
                while ( ((strcmp ((const char *)pcDriverName, (const char *)pcTempDriverName))!=0) && (nInstance<=9)) {
                    nInstance++;
                    pcTempDriverName[7]++;
                }//while

                // If the instance number is >9 then we didn't find a name we recognize
                if (nInstance>=9) {
                    // Go back to the default name
                    strcpy ((char*)pcDriverName, (const char *)gpcDriverName);
                } else {
                    // Found a match, now go to next driver name and store that in what we show in dialog box
                    pcTempDriverName[7]++;
                    strcpy ((char*)pcDriverName, (const char *)pcTempDriverName);
                }
            
                SetDlgItemText (hDlg, IDC_DD_NAME, (const char *)pcDriverName);

            } else {
                // If didn't find a match, then use the default name
                SetDlgItemText (hDlg, IDC_DD_NAME, (const char *)gpcDriverName);
            }

          
            SetFocus (hDlg);

            break;

        case WM_COMMAND:
                    switch(LOWORD(wParam))
            {
             
                case IDOK:
                    // Get the text in the driver name edit box
                    GetDlgItemText (hDlg, IDC_DD_NAME, (char *)pcDriverName, MAX_DRIVER_NAME);
                    strcpy ((char*)gpcDriverName,(const char*)pcDriverName);
                    status = TRUE;
                    EndDialog(hDlg,0);
                    break;

                case IDCANCEL:
                    strcpy ((char*)gpcDriverName, "ISOPERF00");
                    EndDialog(hDlg,-1);
                    break;

                default:
                    break;


            }//switch loword of wParam

        default:
            status = FALSE;
    
    }//switch message

    return status;

}//bGetDriverNameDlgProc

#define TIMER_STATS             1
#define TIMER_STATS_TIMEOUT_VALUE 5000

/**************************************************
 * Main Dialog proc                               *
 **************************************************/

BOOL CALLBACK bMainDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hOutputBox                      = INVALID_HANDLE_VALUE;
    BYTE    pcDriverName[MAX_DRIVER_NAME]   = "";
    BOOL        bResult                         = FALSE;
    ULONG       nBytes                          = 0;
    int     nItems                          = 0;
    HFONT   hFont                           = NULL;
    ULONG   ulLength                        = 0;
    DWORD   dwThreadID                      = 0;
    char    dummyBuff[DUMMY_BUFFER_SIZE];

    switch(message)
    {
        case WM_INITDIALOG:
            // Get a handle to the output box
            hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

            // Setup the std system font
            hFont = GetStockObject(SYSTEM_FONT);
            SendMessage (hOutputBox, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE,0));

            // Send out the version info
                        wsprintf (dummyBuff, "IsoPerf App Version %d.%d%d (Built %s | %s)", VER_MAJ, VER_MIN_HIGH, VER_MIN_LOW,__TIME__, __DATE__);
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)dummyBuff);
       
            // Setup the default symbolic name for the device driver by getting it from the global
            SetDlgItemText (hDlg, IDC_DRIVER_NAME, (const char*)gpcDriverName);

            // Get the text in the driver name edit box
            GetDlgItemText (hDlg, IDC_DRIVER_NAME, (char*)pcDriverName, MAX_DRIVER_NAME);

            // Try to open the driver
            if (bOpenDriver (&ghDevice, hDlg) == TRUE) {
                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
            } else {
                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                ghDevice = INVALID_HANDLE_VALUE;
            }/* else */

            SetDlgItemInt (hDlg, IDC_STAT_SAMPLING_PERIOD, 1000, FALSE);
           
            // Get the current driver configuration
            {
                Config_Stat_Info DriverConfigInfo = {0};
                BOOLEAN result;

                result = 
                    bGetDriverConfig (hDlg, 
                                     ghDevice,
                                     TRUE, //get it from the driver
                                     &DriverConfigInfo);


                if (result) {

                    // Write out the config data to the user interface (as a confirmation)
                    SetDlgItemInt (hDlg,IDC_NUMBER_OF_USB_FRAMES_PER_IRP, DriverConfigInfo.ulNumberOfFrames, FALSE);
                    SetDlgItemInt (hDlg,IDC_OUTSTANDING_IRPS_PER_PIPE,DriverConfigInfo.ulMax_Urbs_Per_Pipe, FALSE);
                    SetDlgItemInt (hDlg,IDC_URB_FRAME_OFFSET,DriverConfigInfo.ulFrameOffset, FALSE);
                    SetDlgItemInt (hDlg,IDC_URB_FRAME_OFFSET_OUT,DriverConfigInfo.ulFrameOffsetMate, FALSE);
                    SetDlgItemInt (hDlg,IDC_STARTING_FRAME_NUMBER,DriverConfigInfo.ulStartingFrameNumber, FALSE);
                    SetDlgItemInt (hDlg,IDC_FRAME_NUMBER_AT_IRP_POST,DriverConfigInfo.ulFrameNumberAtStart, FALSE);

                    bPrintDeviceType (hDlg, &DriverConfigInfo);
                }
            }

            // setup a timer to get stats
                        SetTimer(hDlg, TIMER_STATS, TIMER_STATS_TIMEOUT_VALUE, NULL);

            // set the window title
            wsprintf (dummyBuff, "IsoPerf Test App Ver %d.%d%d",VER_MAJ, VER_MIN_HIGH, VER_MIN_LOW);
            SetWindowText (hDlg, (LPCSTR)dummyBuff);

            break; /*end WM_INITDIALOG case*/

        // field timer messages here
                case WM_TIMER:
                        switch(wParam)
                        {
                        // this timer gets stats periodically
                        case TIMER_STATS:
                {
                    Config_Stat_Info IsoStats = {0};

                    UINT uiPeriod = 0;

                    // Get a handle to the output box
                    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

                    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                    uiPeriod = GetDlgItemInt (hDlg, IDC_STAT_SAMPLING_PERIOD, NULL, FALSE);
                        
                    if (ghDevice==INVALID_HANDLE_VALUE) {
 
                        if (bOpenDriver (&ghDevice, hDlg) != TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                            ghDevice = INVALID_HANDLE_VALUE;
                            break;
                        }/* else */
                    }
                        
                   if (ghDevice) {
                        GetAllStats (hDlg, ghDevice,TRUE,uiPeriod);
                   }
                            
                }
                                break;
                        default:
                                break;
                        }
                        break;

            case WM_COMMAND:
                    switch(LOWORD(wParam))
                    {

                case IDC_ABOUT:
                                        wsprintf (dummyBuff, "IsoPerf Ver %d.%d%d (%s | %s)\nProblems to Kosar_Jaff@ccm.jf.intel.com\nCopyright (C) 1996 Intel/Microsoft", VER_MAJ, VER_MIN_HIGH, VER_MIN_LOW,__TIME__, __DATE__);
                                        MessageBox (hDlg,dummyBuff, "IsoPerf Application", MB_ICONINFORMATION);
                    break;

                case IDOK:
                case IDCANCEL:
                    if (ghDevice != INVALID_HANDLE_VALUE) {
                        
                                                // Shut down the Iso Tests
                                                if (bShutDownIsoTests (hDlg, ghDevice) != TRUE) {
                                                        MessageBox(NULL,"WARNING: Iso Tests could not be shut down!\nYour system may become unstable!","bShutDownIsoTests failure",MB_ICONSTOP);
                                                }//if

                                                CloseHandle (ghDevice);
                    }
                    CleanUpRegistry();

                    // kill the statistics timer
                                        KillTimer(hDlg, TIMER_STATS);

                    EndDialog(hDlg,0);

        
                    break;

                case IDC_START_ISO_IN_TEST:

                    // Get a handle to the output box
                    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

                    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                    if (ghDevice==INVALID_HANDLE_VALUE) {
                        if (bOpenDriver (&ghDevice, hDlg) == TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                        } else {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                            ghDevice = INVALID_HANDLE_VALUE;
                            break;
                         }/* else */
                    }/* if no valid device driver handle found */


                    // Get the config info from the user and then set it in the driver
                    {
                        Config_Stat_Info DriverConfigInfo = {0};

                        if (ghDevice != INVALID_HANDLE_VALUE) {

                            bResult =   bGetDriverConfig (hDlg, 
                                                          ghDevice,
                                                          TRUE, //get it from the driver
                                                          &DriverConfigInfo);

                            // Now see if the user has any changes to the config (overwrites what the driver
                            // reports, but then we tell the driver to take on that configuration)
                            bResult =   bGetDriverConfig (hDlg, 
                                                          INVALID_HANDLE_VALUE,
                                                          FALSE, //get it from the user
                                                          &DriverConfigInfo);

                            if (bResult==TRUE) {
                                // Debug only
                                wsprintf (dummyBuff, "#Frms/Irp: %d # Irps/Pipe: %d MaxPktIN: %d MaxPktOUT %d",
                                            DriverConfigInfo.ulNumberOfFrames,
                                            DriverConfigInfo.ulMax_Urbs_Per_Pipe,
                                            DriverConfigInfo.ulMaxPacketSize_IN,
                                            DriverConfigInfo.ulMaxPacketSize_OUT
                                          );
                                                
                                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)dummyBuff);
                                //end Debug only
                                
                                bResult = bSetDriverConfig (hDlg, ghDevice, &DriverConfigInfo);

                                if (bResult==TRUE) {
                                    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Successfully Configured Driver");
                                }//if successful driver config
                            }else{
                                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to get driver config info...");
                                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Sticking w/ current driver config values...");
                            }//else didn't get the user info or user gave us bad params
                        }//if ghDevice

                    } //end of block to get and set config info

                    // Start the Iso In Test
                    if (ghDevice != INVALID_HANDLE_VALUE) {

                        // Perform the IOCTL
                        bResult = DeviceIoControl (ghDevice,
                                                   IOCTL_ISOPERF_START_ISO_IN_TEST,
                                                   dummyBuff,
                                                   DUMMY_BUFFER_SIZE,
                                                   dummyBuff,
                                                   DUMMY_BUFFER_SIZE,
                                                   &nBytes,
                                                   NULL);


                        if (bResult==TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Started ISO In Test");
 
                            // Get the stats and update the UI so the user knows something has started
                            MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                            if (ghDevice) {
                                UINT uiPeriod = 0;
                                uiPeriod = GetDlgItemInt (hDlg, IDC_STAT_SAMPLING_PERIOD, NULL, FALSE);
                                GetAllStats (hDlg, ghDevice,TRUE,uiPeriod);
                            }

                        } else {
                            // bResult was FALSE so IOCTL somehow failed
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to start iso test Failed");
                        }

                        
                    }/* if valid driver handle */


                    break;

                case IDC_STOP_ISO_IN_TEST:

                    // Get a handle to the output box
                    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);
                    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Stopping continuous reporting of stats...");

                    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Trying to stop ISO In Test...");

                    if (ghDevice==INVALID_HANDLE_VALUE) {
                        if (bOpenDriver (&ghDevice, hDlg) == TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                        } else {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                            ghDevice = INVALID_HANDLE_VALUE;
                        }/* else */
                    }/* if no valid device driver handle found */

                    if (ghDevice != INVALID_HANDLE_VALUE) {

                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Communicating with Driver...");

                        // Perform the IOCTL
                        bResult = DeviceIoControl (ghDevice,
                                                   IOCTL_ISOPERF_STOP_ISO_IN_TEST,
                                                   dummyBuff,
                                                   DUMMY_BUFFER_SIZE,
                                                   dummyBuff,
                                                   DUMMY_BUFFER_SIZE,
                                                   &nBytes,
                                                   NULL);

                        if (bResult==TRUE)
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Stopped ISO Test");
                        else
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to stop ISO test failed");

                    }/* if valid driver handle */


                    break;

                case IDC_GET_ISO_STATS:
                    {
                        Config_Stat_Info IsoStats = {0};

                        UINT uiPeriod = 0;

                        // Get a handle to the output box
                        hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

                        MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                        uiPeriod = GetDlgItemInt (hDlg, IDC_STAT_SAMPLING_PERIOD, NULL, FALSE);
                        
                        if (ghDevice==INVALID_HANDLE_VALUE) {
 
                            if (bOpenDriver (&ghDevice, hDlg) == TRUE) {
                                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                            } else {
                                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                                ghDevice = INVALID_HANDLE_VALUE;
                                break;
                            }/* else */
                        }
                        
                        if (ghDevice) {
                            GetAllStats (hDlg, ghDevice,TRUE,uiPeriod);
                        }
                            
                    }

                    break;

                    } /*end switch wParam*/
                
            break;


    } /*end switch message*/

    return FALSE;

} /*end MainDlgProc*/


BOOLEAN
bOpenDriver (HANDLE * phDeviceHandle, HWND hDlg)
/*++
 **************************************************
 * bOpenDriver proc                               *
 *                                                *
 * Purpose:                                       *  
 *      Opens the device driver using symbolic    *
 *      name provided                             *
 *                                                *
 * Input:                                         *
 *      phDeviceHandle:                           *
 *          Pointer to Device Driver handle where *
 *          the file handle is placed.            *
 *      devname:                                  *
 *          Null terminated string containing the *
 *          device name                           *
 *                                                *
 * Return Value:                                  *
 *      Boolean that indicates if the driver was  *
 *      successfully opened or not.               *
 *                                                *
 **************************************************
 --*/
{
    char completeDeviceName[64] = "";
    char pcMsg[64] = "";
    BYTE pcDriverName[MAX_DRIVER_NAME];
    HKEY    hkDriverKey                     = NULL;
    DWORD   dwDisposition                   = 0;        

    // Get the text in the driver name edit box
    GetDlgItemText (hDlg, IDC_DRIVER_NAME, (char*)pcDriverName, MAX_DRIVER_NAME);

    strcat (completeDeviceName,
            "\\\\.\\"
            );

    strcat (completeDeviceName,
                    (const char*)pcDriverName
                    );

    *phDeviceHandle = CreateFile(   completeDeviceName,
                                            GENERIC_WRITE | GENERIC_READ,
                                            FILE_SHARE_WRITE | FILE_SHARE_READ,
                                            NULL,
                                            OPEN_EXISTING,
                                            0,
                                            NULL);

    if (*phDeviceHandle == INVALID_HANDLE_VALUE) {
        return (FALSE);
    } else {

        // Poke the name of the driver into the registry
        RegCreateKeyEx (HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\INTEL\\IAL\\USB\\ISOPERF",
                        0, //reserved
                        "USB Test Devices", //class
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL, //security
                        &hkDriverKey,
                        &dwDisposition);

        if (hkDriverKey) {

        //store away the value of the driver we just opened                
        RegSetValueEx (hkDriverKey,
                       "LastOpenedDriverName",
                       0, //reserved
                       REG_SZ,
                       &(pcDriverName[0]),
                       (strlen ((const char *)gpcDriverName) + 1) );

        RegCloseKey (hkDriverKey);

        }//if valid driver key

    
        return (TRUE);
    } /*else*/


}//OpenDevice


BOOLEAN
bCalibrateClockCount(ULONG  ulCurrentUpperClockCount,
                     ULONG  ulLastUpperClockCount,
                     ULONG  ulCurrentLowerClockCount,
                     ULONG  ulLastLowerClockCount,
                     ULONG  ulPeriodInMs,
                     PULONG pulSpeed,
                     PULONG pulOrdinalSpeed)
/*++
**************************************************
* bCalibrateClockCount proc                      *
*                                                *
* Purpose:                                       *
*       This routine calibrates the Pentium          *
*       Clock count based on the period specified,   *
*   and the Clock Counts given.                  *
*                                                *
* TODO: Add more on how it does it here          *
*                                                *
*
* Return Value:                                  *
*      Boolean that indicates if the Clock was   *
*      successfully calibrated or not.           *
**************************************************
--*/
{
    ULONG ulDelta, ulNormalizedDelta, ulOrdinalSpeed;
    ULONG ulSpeed = 0;

        ulLastUpperClockCount                   = 0; //we don't use this for now (avoids compiler warning)
        ulCurrentUpperClockCount                = 0; // we don't use this for now (avoids compiler warning)

    // We know if the last sample was zero (lower dword) then this must be the first one, so 
    // bong this back and let another cycle happen before attempting to calibrate
    if (ulLastLowerClockCount == 0)  {
        return FALSE;
    }//if last sampl was the first one

    if (ulPeriodInMs == 0) {
        return FALSE;
    }//if bad period

    // Get how many CPU clocks elapsed since last sample
    ulDelta = ulCurrentLowerClockCount - ulLastLowerClockCount;

    // Normalize the period given
    ulNormalizedDelta = ulDelta * (1000/ulPeriodInMs);

    // Strip off the zeros
    ulOrdinalSpeed = ulNormalizedDelta / 1000000;

    // 100 MHz
    if ((ulOrdinalSpeed<=110) && (ulOrdinalSpeed>=90)) {
        ulSpeed = 100;
    }//if 100 MHz

    // 120 MHz
    else if ((ulOrdinalSpeed<=125) && (ulOrdinalSpeed>110)) {
        ulSpeed = 120;
    }//if 120 MHz

    // 133 MHz
    else if ((ulOrdinalSpeed<=145) && (ulOrdinalSpeed>125)) {
        ulSpeed = 133;
    }//if 133 MHz

    // 150 MHz
    else if ((ulOrdinalSpeed<=165) && (ulOrdinalSpeed>145)) {
        ulSpeed = 150;
    }//if 150 MHz

    // 200 MHz
    else if ((ulOrdinalSpeed<210) && (ulOrdinalSpeed>185)) {
        ulSpeed = 200;
    }//if 200 MHz
    
    // Return the raw value
    else {
        ulSpeed = ulOrdinalSpeed;
    }

    //set results    
    *pulSpeed = ulSpeed; 
    *pulOrdinalSpeed = ulOrdinalSpeed;

    return (TRUE);

}//bCalibrateClockCount

void
CleanUpRegistry(void)
/*++
**************************************************
* CleanUpRegistry proc                           *
*                                                *
* Purpose:                                       *
*   Cleans up the driver name in the registry,   *
*   if the current entry is this app's name      *
*   If not, then it leaves it alone.             *

* Return Value:                                  *
*      None                                      *
**************************************************
--*/
{
    BYTE pcDriverName[MAX_DRIVER_NAME]; 
    DWORD dwType, dwBufferSize;         
    HKEY  hkDriverKey = NULL;
    
    dwBufferSize = MAX_DRIVER_NAME;
    
    RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    "SOFTWARE\\INTEL\\IAL\\USB\\ISOPERF",
                    0,
                    KEY_ALL_ACCESS,
                    &hkDriverKey);

    if (hkDriverKey) {
        RegQueryValueEx (hkDriverKey,
                         "LastOpenedDriverName",
                         0, //reserved
                         &dwType,
                         &(pcDriverName[0]),
                         &dwBufferSize);
    }//if valid driver key

    if ((strcmp ((const char *)pcDriverName,(const char*)gpcDriverName)) == 0) {
        //found a match, so put a null string in the value
        RegSetValueEx (hkDriverKey,
                       "LastOpenedDriverName",
                       0, //reserved
                       REG_SZ,
                       (const unsigned char*)"",
                       1);
    }

    RegCloseKey (hkDriverKey);

}// CleanUpRegistry


BOOLEAN
bGetDriverConfig (HWND hDlg, 
                  HANDLE hDriver,
                  BOOLEAN bFromDriver, 
                  pConfig_Stat_Info pConfigData)
/*++
**************************************************
* bGetDriverConfig proc                          *
*                                                *
* Purpose:                                       *
*   Gets the driver configuration from the       *
*   driver (if bFromDriver = TRUE) or gets it    *
*   from the user edit boxes                     *
*                                                *
* Inputs:                                        *
*   hDlg                                         *
*   hDriver                                      *
*   bFromDriver (TRUE=Do Ioctl | FALSE=From UI)  *
*   pConfigData                                  *  
*                                                *
* Return Value:                                  *
*   Returns the values in the IsoStats struct    *
*   provided by caller, and a BOOLEAN return     *
*   code indicating if the desired operation was * 
*   successful.                                  *
**************************************************
--*/
{
    ULONG nBytes = 0;
    BOOL bResult = FALSE;
    HWND hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX); 
    char temp[64];

    if ( bFromDriver == TRUE ) {

        if (hDriver != INVALID_HANDLE_VALUE)  {
        
            // Perform the IOCTL
            bResult = DeviceIoControl (hDriver,
                                       IOCTL_ISOPERF_GET_ISO_IN_STATS,
                                       pConfigData,
                                       sizeof (Config_Stat_Info),
                                       pConfigData,
                                       sizeof (Config_Stat_Info),
                                       &nBytes,
                                       NULL);

            if (bResult==TRUE) {
                wsprintf (temp,"Got %d bytes of Driver Config data (size: %d)",nBytes, sizeof(Config_Stat_Info));
                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);
                                return TRUE;
            } /* if good Ioctl */
            else {
                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to GetDriver Config Failed!");
                return FALSE;
            }//else Ioctl failed

        } else {
            return FALSE;
        } /* else bad driver handle detected */

    } else {
        
        // bFromDriver is FALSE, so get the config info from the user interface        
        if (hDlg) {
            pConfigData->ulNumberOfFrames     = GetDlgItemInt (hDlg, IDC_NUMBER_OF_USB_FRAMES_PER_IRP, NULL, FALSE);
            pConfigData->ulMax_Urbs_Per_Pipe  = GetDlgItemInt (hDlg, IDC_OUTSTANDING_IRPS_PER_PIPE, NULL, FALSE);    
            pConfigData->ulFrameOffset        = GetDlgItemInt (hDlg, IDC_URB_FRAME_OFFSET, NULL, FALSE);    
            pConfigData->ulFrameOffsetMate    = GetDlgItemInt (hDlg, IDC_URB_FRAME_OFFSET_OUT, NULL, FALSE);    

            return TRUE;
        }// if hDlg

        // If you get here then the hDlg was bad, so the only thing left to do is return a failure code
        return FALSE;

    }//else not from Driver, so get it from user input
    

}//bGetDriverConfig

BOOLEAN
bSetDriverConfig (HWND hDlg,
                  HANDLE hDriver,
                  pConfig_Stat_Info pConfigData)
/*++
**************************************************
* bSetDriverConfig proc                          *
*                                                *
* Purpose:                                       *
*   Sets the driver configuration in the driver  *
*                                                *
* Inputs:                                        *
*   hDlg                                         *
*   hDriver                                      *
*   pConfigData                                  *  
*                                                *
* Return Value:                                  *
*      Boolean that indicates if the SetConfig   *
*      was successful or not.                    *
**************************************************
//
// NOTE (old code) This interface has no way of specifying if the pConfigData is
//       valid.  Change this interface to include a length or something.
//          (kjaff) 1-14-97
//
--*/
{
    ULONG nBytes = 0;
    BOOL bResult = FALSE;
    HWND hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX); 
    HWND hDoInOutCheckBox = GetDlgItem (hDlg,IDC_CHECK_DO_IN_OUT);
    char tempStr[64];
    USHORT ulMaxPacketSize = 0;

    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"In SetDriverConfig");

    // Set up the max packet size based on the type of device (direction) it is
    switch (pConfigData->DeviceType) {
        case Iso_In_With_Pattern:
            ulMaxPacketSize = pConfigData->ulMaxPacketSize_IN;
            break;

        case Iso_Out_With_Interrupt_Feedback:
        case Iso_Out_Without_Feedback:
            ulMaxPacketSize = pConfigData->ulMaxPacketSize_OUT;
            break;

        case Unknown_Device_Type:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"WARNING: Unknown Device Type detected!");    
            break;
        
        default:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"WARNING: Invalid Enum Value for Device Type detected!");    
            break;
        }//switch on dev type    

    // Validate the values the user is specifying
    if ((pConfigData->ulNumberOfFrames * pConfigData->ulMaxPacketSize_IN) > DRIVER_MAXIMUM_TRANSFER_SIZE) {
        wsprintf (tempStr, "Cannot Configure: Buffer will be too big (%d)!", pConfigData->ulNumberOfFrames * 8);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
        return FALSE;
    }//if buffer size will be too big w/ there params

    if ((pConfigData->ulNumberOfFrames * ulMaxPacketSize) == 0) {
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Cannot Configure: Detected ZERO buffer size!");
        wsprintf (tempStr, "NumberOfFrames: %d | MaxPktSizeIN %d | MaxPktSizeOUT %d",
                            pConfigData->ulNumberOfFrames,
                            pConfigData->ulMaxPacketSize_IN,
                            pConfigData->ulMaxPacketSize_OUT
                 );

        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
        return FALSE;
    }//if zero for data buffer size

    if (pConfigData->ulMax_Urbs_Per_Pipe >= MAX_URBS_PER_PIPE) {
        wsprintf (tempStr, "Cannot Configure: Can't queue that many Irps at once (%d)! (max: %d)",
            pConfigData->ulMax_Urbs_Per_Pipe,
            MAX_URBS_PER_PIPE);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
        return FALSE;
    }

    // If button is checked, then user wants to do the In->Out test
    if ((SendMessage (hDoInOutCheckBox, BM_GETCHECK, 0, 0)) == BST_CHECKED) {
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"In->Out Test Requested...");
        pConfigData->ulDoInOutTest = 1;
    }
    

    if (hDriver != INVALID_HANDLE_VALUE)  {
    
        // Perform the IOCTL
        bResult = DeviceIoControl (hDriver,
                                   IOCTL_ISOPERF_SET_DRIVER_CONFIG,
                                   pConfigData,
                                   sizeof (Config_Stat_Info),
                                   pConfigData,
                                   sizeof (Config_Stat_Info),
                                   &nBytes,
                                   NULL);

        if (bResult==TRUE) {
            // Update the UI w/ what we wrote to the driver
            if (hDlg) {
                SetDlgItemInt (hDlg,IDC_NUMBER_OF_USB_FRAMES_PER_IRP, pConfigData->ulNumberOfFrames, FALSE);
                SetDlgItemInt (hDlg,IDC_OUTSTANDING_IRPS_PER_PIPE,pConfigData->ulMax_Urbs_Per_Pipe, FALSE);
            }
            return TRUE;
        } /* if good Ioctl */
        else {
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to SetDriver Config Failed!");
        }//else Ioctl failed

    } /* if valid driver handle */
    
    return FALSE;

}//bSetDriverConfig

BOOLEAN
bPrintDeviceType (HWND hDlg, 
                  Config_Stat_Info * pDriverInfo)
/*++
**************************************************
* bPrintDeviceType proc                          *
*                                                *
* Purpose:                                       *
*   Determines the Iso Test Device Type from the *
*   given data in the DriverInfo structure, and  *
*   and then prints that out to the UI.          *
*                                                *
* Inputs:                                        *
*   hDlg                                         *
*   pDriverInfo                                  *  
*                                                *
* Return Value:                                  *
*      Boolean that indicates if the SetConfig   *
*      was successful or not.                    *
**************************************************
//
// NOTE (old code) This interface has no way of specifying if the pDriverInfo is
//       valid.  Change this interface to include a length or something.
//          (kjaff) 1-14-97
//
--*/
{
    char tempStr[64];
    HWND hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX); 
    BOOLEAN status = TRUE;

    switch (pDriverInfo->DeviceType) {
        case   Iso_In_With_Pattern:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Device is Iso_In_With_Pattern");
            wsprintf (tempStr,"In Endpoint's MaxPacketSize: %d",pDriverInfo->ulMaxPacketSize_IN);
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
            break;

        case   Iso_Out_With_Interrupt_Feedback:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Device is Iso_Out_With_Interrupt_Feedback");
            wsprintf (tempStr,"Out Endpoint's MaxPacketSize: %d",pDriverInfo->ulMaxPacketSize_OUT);
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
            break;

        case   Iso_Out_Without_Feedback:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Device is Iso_Out_Without_Feedback");
            wsprintf (tempStr,"Out Endpoint's MaxPacketSize: %d",pDriverInfo->ulMaxPacketSize_OUT);
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
            break;

        case   Unknown_Device_Type:
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Device is Unknown_Device_Type");
            break;

        default:
            wsprintf (tempStr,"Device has bad Enum value (unknown) (%d)",pDriverInfo->DeviceType);
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)tempStr);
            status = FALSE;
            break;
    }//switch



    return status;
}//bPrintDeviceType 

void
GetAllStats (HWND hDlg,
             HANDLE hDriver,
             BOOLEAN bUpdateUI,
             UINT    uiPeriodInMs
            )
/*++
**************************************************
* GetAllStats proc                               *
*                                                *
* Purpose:                                       *
*   Gets all the statistics for a particular     *
*   device and updates UI if so directed.        *
*                                                *
* Inputs:                                        *
*   hDlg                                         *
*   hDriver                                      *
*   bUpdateUI                                    *  
*   uiPeriodInMs                                 *
*                                                *
* Return Value:                                  *
*      None                                      *
**************************************************
--*/
{
    Config_Stat_Info IsoStats = {0};
    ULONG ulLastSample = 0;
    ULONG ulCPUSpeed = 0;
    HWND hOutputBox = NULL;
    BOOL bResult=FALSE;
    ULONG nBytes = 0;
    ULONG ulLastUpperClockCount = 0;
    ULONG ulLastLowerClockCount = 0;
    ULONG ulOrdSp=0;
    FLOAT   flTimeInSeconds;
    char    tempStr[64];

    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

    assert (hOutputBox != NULL);
    
    if (hDriver != INVALID_HANDLE_VALUE) {

        // Perform the IOCTL to get the first sample
        bResult = DeviceIoControl (hDriver,
                                   IOCTL_ISOPERF_GET_ISO_IN_STATS,
                                   &IsoStats,
                                   sizeof (IsoStats),
                                   &IsoStats,
                                   sizeof (IsoStats),
                                   &nBytes,
                                   NULL);
        if (bResult!=TRUE) {
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to GetDriver Config Failed!");
            return;
        }//else Ioctl failed

        ulLastSample            = IsoStats.ulBytesTransferredIn;
        ulLastUpperClockCount   = IsoStats.ulUpperClockCount;
        ulLastLowerClockCount   = IsoStats.ulLowerClockCount;
    
        memset (&IsoStats, 0, sizeof (IsoStats));

        Sleep (uiPeriodInMs);

        if (bUpdateUI==TRUE) {

            // Perform the IOCTL again since we need to get a delta 
            bResult = DeviceIoControl (ghDevice,
                                       IOCTL_ISOPERF_GET_ISO_IN_STATS,
                                       &IsoStats,
                                       sizeof (IsoStats),
                                       &IsoStats,
                                       sizeof (IsoStats),
                                       &nBytes,
                                       NULL);

            if (bResult!=TRUE) {
                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to GetDriver Config Failed!");
                return;
            }//else Ioctl failed

            SetDlgItemInt (hDlg, IDC_BYTES_PER_SEC, ((IsoStats.ulBytesTransferredIn - ulLastSample)*(1000/uiPeriodInMs)), FALSE);
            SetDlgItemInt (hDlg, IDC_BYTES_ALLOC, IsoStats.ulBytesAllocated, FALSE);
            SetDlgItemInt (hDlg, IDC_BYTES_FREED, IsoStats.ulBytesFreed, FALSE);
            SetDlgItemInt (hDlg,IDC_URB_FRAME_OFFSET,IsoStats.ulFrameOffset, FALSE);

            // Strip off the upper bits of the frame nbrs
            IsoStats.ulStartingFrameNumber &= 0x7FF;
            IsoStats.ulFrameNumberAtStart  &= 0x7FF;

            wsprintf (tempStr, "%x", IsoStats.ulStartingFrameNumber);
            SetDlgItemText (hDlg,IDC_STARTING_FRAME_NUMBER,(LPCTSTR)tempStr);

            wsprintf (tempStr, "%x", IsoStats.ulFrameNumberAtStart);
            SetDlgItemText (hDlg,IDC_FRAME_NUMBER_AT_IRP_POST,(LPCTSTR)tempStr);

            IsoStats.bDeviceRunning ? SetDlgItemText (hDlg,IDC_DEVICE_RUNNING,(LPCTSTR)"Running") : \
            SetDlgItemText (hDlg,IDC_DEVICE_RUNNING,(LPCTSTR)"Stopped"); 
                
            // See if an error has occurred    
            if (IsoStats.erError!=NoError) {

                wsprintf (tempStr, "%x", IsoStats.UsbdPacketStatCode);
                SetDlgItemText (hDlg,IDC_USBD_PACKET_ERROR_CODE,(LPCTSTR)tempStr);

                wsprintf (tempStr, "%x", IsoStats.UrbStatusCode);
                SetDlgItemText (hDlg,IDC_USBD_URB_ERROR,(LPCTSTR)tempStr);

                switch (IsoStats.erError) {
                    case DataCompareFailed:
                        SetDlgItemText (hDlg,IDC_DEVICE_HAD_ERROR,(LPCTSTR)"DataCompareFail");
                        break;

                    case UsbdErrorInCompletion:
                        SetDlgItemText (hDlg,IDC_DEVICE_HAD_ERROR,(LPCTSTR)"ErrorInCompletion");
                        break;

                    case ErrorInPostingUrb:
                        SetDlgItemText (hDlg,IDC_DEVICE_HAD_ERROR,(LPCTSTR)"ErrorInPostingUrb");
                        break;

                    default:
                        SetDlgItemText (hDlg,IDC_DEVICE_HAD_ERROR,(LPCTSTR)"UNKNOWN");
                        break;
                    
                }//switch

            }else {
                SetDlgItemText (hDlg,IDC_DEVICE_HAD_ERROR,(LPCTSTR)"OK");
                SetDlgItemInt (hDlg, IDC_USBD_PACKET_ERROR_CODE, 0, FALSE);
                SetDlgItemInt (hDlg, IDC_USBD_URB_ERROR, 0, FALSE);
            }//Device had no error

            bCalibrateClockCount(IsoStats.ulUpperClockCount,ulLastUpperClockCount,
                                    IsoStats.ulLowerClockCount,ulLastLowerClockCount,
                                    uiPeriodInMs,
                                    &ulCPUSpeed,
                                    &ulOrdSp);

            // Figure out how much time elapsed per the CPU counters
            if (ulCPUSpeed) {
                // Print out the time in seconds since the last sample we got
                flTimeInSeconds = (FLOAT)((FLOAT)(IsoStats.ulLowerClockCount - ulLastLowerClockCount)/(FLOAT)(ulCPUSpeed*1000000));
                sprintf (tempStr, "%6.4f",flTimeInSeconds);
                SetDlgItemText (hDlg,IDC_CPU_TIME,(LPCTSTR)tempStr); 

                // Print out the time in seconds it is taking to process a Urb
                flTimeInSeconds = (FLOAT)((FLOAT)(IsoStats.ulUrbDeltaClockCount)/(FLOAT)(ulCPUSpeed*1000000));
                sprintf (tempStr, "%6.6f",flTimeInSeconds);
                SetDlgItemText (hDlg,IDC_URB_PROC_TIME, tempStr);

                SetDlgItemInt  (hDlg,IDC_CPU_COUNTER_LOW,IsoStats.ulLowerClockCount - ulLastLowerClockCount,FALSE);

            } else {
                sprintf (tempStr, "%s","Err: CPUSpd=0");
                SetDlgItemText (hDlg,IDC_CPU_TIME,(LPCTSTR)tempStr); 
            }
        
        }//if UI is to be updated

    }//if hDriver valid

}//GetAllStats


BOOL
bShutDownIsoTests (HWND hDlg,
                                        HANDLE hDriver
                                   )
/*++
**************************************************
* bShutDownIsoTests proc                         *
*                                                *
* Purpose:                                       *
*   Sends IOCTL to driver to stop the Iso IN Test*
*                                                *
* Inputs:                                        *
*   hDlg                                         *
*   hDriver                                      *
*                                                *
* Return Value:                                  *
*      Returns TRUE if Ioctl was successful,     *
*      otherwise FALSE.                          *
**************************************************
--*/
{
        HWND hOutputBox = NULL;
    char    dummyBuff[DUMMY_BUFFER_SIZE];
        ULONG   nBytes;
        BOOL    bResult;

        // Get a handle to the output box
        hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);
        
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Trying to stop ISO In Test...");

        if (hDriver != INVALID_HANDLE_VALUE) {

                SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Communicating with Driver...");

                // Perform the IOCTL
                bResult = DeviceIoControl (ghDevice,
                                                                   IOCTL_ISOPERF_STOP_ISO_IN_TEST,
                                                                   dummyBuff,
                                                                   DUMMY_BUFFER_SIZE,
                                                                   dummyBuff,
                                                                   DUMMY_BUFFER_SIZE,
                                                                   &nBytes,
                                                                   NULL);

                if (bResult==TRUE)
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Stopped ISO Test");
                else
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Ioctl to stop ISO test failed");

        }/* if valid driver handle */

        return (bResult);

}//bShutDownIsoTests
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\exe\rwiso.c ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    RwIso.c

Abstract:

    Console test app for IsoUsb.sys driver

Environment:

    user mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1997-1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        11/17/97: created

--*/

#include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>

#include "devioctl.h"

#include <setupapi.h>
#include <basetyps.h>

#include "IsoUsr.h"

#include "usbdi.h"

#define NOISY(_x_) printf _x_ ;

char inPipe[32] = "PIPE04";     // pipe name for iso input pipe on our test board
char outPipe[32] = "PIPE05";    // pipe name for iso output pipe on our test board
char completeDeviceName[256] = "";  //generated from the GUID registered by the driver itself

BOOL fDumpUsbConfig = FALSE;    // flags set in response to console command line switches
BOOL fDumpReadData = FALSE;
BOOL fRead = FALSE;
BOOL fWrite = FALSE;

PVOID gpStreamObj;
char gbuf[256];


BOOL fIsoStreamStarted = FALSE;
HANDLE ghStreamDev = NULL;
int gMS = 10000; // default to 10 secs stream test

int gDebugLevel = 1;      // higher == more verbose, default is 1, 0 turns off all

ULONG IterationCount = 1; // count of iterations of the test we are to perform
int WriteLen = 0;         // #bytes to write
int ReadLen = 0;          // #bytes to read

void StartIsoStream( void );

void StopIsoStream( void );

// functions


HANDLE
OpenOneDevice (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_DEVICE_INTERFACE_DATA   DeviceInfoData,
        IN               char *devName
    )
/*++
Routine Description:

    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific usb device,
    open that device and fill in all the relevant information in the given
    USB_DEVICE_DESCRIPTOR structure.

Arguments:

    HardwareDeviceInfo:  handle to info obtained from Pnp mgr via SetupDiGetClassDevs()
    DeviceInfoData:      ptr to info obtained via SetupDiEnumDeviceInterfaces()

Return Value:

    return HANDLE if the open and initialization was successfull,
        else INVLAID_HANDLE_VALUE.

--*/
{
    PSP_DEVICE_INTERFACE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
        HANDLE                                                           hOut = INVALID_HANDLE_VALUE;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetDeviceInterfaceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_DEVICE_INTERFACE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetDeviceInterfaceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
                free( functionClassDeviceData );
        return INVALID_HANDLE_VALUE;
    }

        strcpy( devName,functionClassDeviceData->DevicePath) ;
        printf( "Attempting to open %s\n", devName );

    hOut = CreateFile (
                  functionClassDeviceData->DevicePath,
                  GENERIC_READ | GENERIC_WRITE,
                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                  NULL, // no SECURITY_ATTRIBUTES structure
                  OPEN_EXISTING, // No special create flags
                  0, // No special attributes
                  NULL); // No template file

    if (INVALID_HANDLE_VALUE == hOut) {
                printf( "FAILED to open %s\n", devName );
    }
        free( functionClassDeviceData );
        return hOut;
}


HANDLE
OpenUsbDevice( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

   Do the required PnP things in order to find
   the next available proper device in the system at this time.

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated name for this device

Return Value:

    return HANDLE if the open and initialization was successful,
        else INVLAID_HANDLE_VALUE.
--*/
{
   ULONG NumberDevices;
   HANDLE hOut = INVALID_HANDLE_VALUE;
   HDEVINFO                 hardwareDeviceInfo;
   SP_DEVICE_INTERFACE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PUSB_DEVICE_DESCRIPTOR   usbDeviceInst;
   PUSB_DEVICE_DESCRIPTOR       *UsbDevices = &usbDeviceInst;

   *UsbDevices = NULL;
   NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   // SetupDiGetClassDevs() returns a device information set that contains info on all
   // installed devices of a specified class.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           pGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_DEVICEINTERFACE)); // Function class devices.

   //
   // Take a wild guess at the number of devices we have;
   // Be prepared to realloc and retry if there are more than we guessed
   //
   NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_DEVICE_INTERFACE_DATA);

   i=0;
   while (!done) {
      NumberDevices *= 2;

      if (*UsbDevices) {
         *UsbDevices =
               realloc (*UsbDevices, (NumberDevices * sizeof (USB_DEVICE_DESCRIPTOR)));
      } else {
         *UsbDevices = calloc (NumberDevices, sizeof (USB_DEVICE_DESCRIPTOR));
      }

      if (NULL == *UsbDevices) {

         // SetupDiDestroyDeviceInfoList destroys a device information set
         // and frees all associated memory.

         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return INVALID_HANDLE_VALUE;
      }

      usbDeviceInst = *UsbDevices + i;

      for (; i < NumberDevices; i++) {

         // SetupDiEnumDeviceInterfaces() returns information about device interfaces
         // exposed by one or more devices. Each call returns information about one interface;
         // the routine can be called repeatedly to get information about several interfaces
         // exposed by one or more devices.

         if (SetupDiEnumDeviceInterfaces (hardwareDeviceInfo,
                                         0, // We don't care about specific PDOs
                                                                                 pGuid,
                                         i,
                                         &deviceInfoData)) {

            hOut = OpenOneDevice (hardwareDeviceInfo, &deviceInfoData, outNameBuf);
                        if ( hOut != INVALID_HANDLE_VALUE ) {
               done = TRUE;
               break;
                        }
         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   NumberDevices = i;

   // SetupDiDestroyDeviceInfoList() destroys a device information set
   // and frees all associated memory.

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   free ( *UsbDevices );
   return hOut;
}




BOOL
GetUsbDeviceFileName( LPGUID  pGuid, char *outNameBuf)
/*++
Routine Description:

    Given a ptr to a driver-registered GUID, give us a string with the device name
    that can be used in a CreateFile() call.
    Actually briefly opens and closes the device and sets outBuf if successfull;
    returns FALSE if not

Arguments:

    pGuid:      ptr to GUID registered by the driver itself
    outNameBuf: the generated zero-terminated name for this device

Return Value:

    TRUE on success else FALSE

--*/
{
        HANDLE hDev = OpenUsbDevice( pGuid, outNameBuf );
        if ( hDev != INVALID_HANDLE_VALUE )
        {
                CloseHandle( hDev );
                return TRUE;
        }
        return FALSE;

}

HANDLE
open_dev()
/*++
Routine Description:

    Called by dumpUsbConfig() to open an instance of our device

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        HANDLE hDEV = OpenUsbDevice( (LPGUID)&GUID_CLASS_I82930_ISO, completeDeviceName);


        if (hDEV == INVALID_HANDLE_VALUE) {
                printf("Failed to open (%s) = %d", completeDeviceName, GetLastError());
        } else {
                printf("DeviceName = (%s)\n", completeDeviceName);
    }           

        return hDEV;
}


HANDLE
open_file( char *filename)
/*++
Routine Description:

    Called by main() to open an instance of our device after obtaining its name

Arguments:

    None

Return Value:

    Device handle on success else NULL

--*/
{

        int success = 1;
        HANDLE h;

        if ( !GetUsbDeviceFileName(
                (LPGUID) &GUID_CLASS_I82930_ISO,
                completeDeviceName) )
        {
                NOISY(("Failed to GetUsbDeviceFileName\n", GetLastError()));
                return  INVALID_HANDLE_VALUE;
        }

    strcat (completeDeviceName,
                        "\\"
                        );                      

    strcat (completeDeviceName,
                        filename
                        );                                      

        printf("completeDeviceName = (%s)\n", completeDeviceName);

        h = CreateFile(completeDeviceName,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_WRITE | FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);

        if (h == INVALID_HANDLE_VALUE) {
                NOISY(("Failed to open (%s) = %d", completeDeviceName, GetLastError()));
                success = 0;
        } else {
                        NOISY(("Opened successfully.\n"));
    }           

        return h;
}

void
usage()
/*++
Routine Description:

    Called by main() to dump usage info to the console when
    the app is called with no parms or with an invalid parm

Arguments:

    None

Return Value:

    None

--*/
{
    printf("Usage for Read/Write test:\n");
    printf("-r [n] where n is number of bytes to read\n");
    printf("-w [n] where n is number of bytes to write\n");
    printf("-c [n] where n is number of iterations (default = 1)\n");
    printf("-i [s] where s is the input pipe\n");
    printf("-o [s] where s is the output pipe\n");
    printf("-v verbose -- dumps read data\n");

    printf("\nUsage for USB and Endpoint info:\n");
    printf("-u to dump USB configuration and pipe info \n");
    printf("-g [s] Run Isochronous test stream for 's' seconds \n");

}


void
parse(
    int argc,
    char *argv[] )
/*++
Routine Description:

    Called by main() to parse command line parms

Arguments:

    argc and argv that was passed to main()

Return Value:

    Sets global flags as per user function request

--*/
{
    int i;

        if ( argc < 2 ) // give usage if invoked with no parms
                usage();

    for (i=0; i<argc; i++) {
        if (argv[i][0] == '-' ||
            argv[i][0] == '/') {
            switch(argv[i][1]) {
            case 'r':
            case 'R':
                ReadLen = atoi(&argv[i+1][0]);
                                fRead = TRUE;
                i++;
                break;
            case 'w':
            case 'W':
                WriteLen = atoi(&argv[i+1][0]);
                                fWrite = TRUE;
                i++;
                break;
            case 'c':
            case 'C':
                IterationCount = atoi(&argv[i+1][0]);
                i++;
                break;
            case 'i':
            case 'I':
                strcpy(inPipe, &argv[i+1][0]);
                i++;
                break;
            case 'u':
            case 'U':
                fDumpUsbConfig = TRUE;
                                i++;
                break;
            case 'v':
            case 'V':
                fDumpReadData = TRUE;
                                i++;
                break;
                         case 'o':
             case 'O':
                strcpy(outPipe, &argv[i+1][0]);
                i++;
                break;
                         case 'g':
             case 'G':
                 gMS = 1000 * atoi(&argv[i+1][0]);
                                 StartIsoStream();
                break;
                         case 'x':
             case 'X':
                                 StopIsoStream();
                break;
            default:
                usage();
            }
        }
    }
}

BOOL
compare_buffs(char *buff1, char *buff2, int length)
/*++
Routine Description:

    Called to verify read and write buffers match for loopback test

Arguments:

    buffers to compare and length

Return Value:

    TRUE if buffers match, else FALSE

--*/
{
    int ok = 1;

        if (memcmp(buff1, buff2, length )) {

                // Edi, and Esi point to the mismatching char and ecx indicates the
                // remaining length.
                ok = 0;
        }


    return ok;
}

#define NPERLN 8

void
dump(
   UCHAR *b,
   int len
)
/*++
Routine Description:

    Called to do formatted ascii dump to console of the io buffer

Arguments:

    buffer and length

Return Value:

    none

--*/
{
    ULONG i;
        ULONG longLen = (ULONG)len / sizeof( ULONG );
        PULONG pBuf = (PULONG) b;

        // dump an ordinal ULONG for each sizeof(ULONG)'th byte
    printf("\n****** BEGIN DUMP LEN decimal %d, 0x%x\n", len,len);
    for (i=0; i<longLen; i++) {
        printf("%04X ", *pBuf++);
        if (i % NPERLN == (NPERLN - 1)) {
            printf("\n");
        }
    }
    if (i % NPERLN != 0) {
        printf("\n");
    }
    printf("\n****** END DUMP LEN decimal %d, 0x%x\n", len,len);
}

// Begin, routines for USB configuration dump (Cmdline "rwiso -u" )


char
*usbDescriptorTypeString(UCHAR bDescriptorType )
/*++
Routine Description:

    Called to get ascii string of USB descriptor

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bDescriptorType or
        PUSB_DEVICE_DESCRIPTOR->bDescriptorType or
        PUSB_INTERFACE_DESCRIPTOR->bDescriptorType or
        PUSB_STRING_DESCRIPTOR->bDescriptorType or
        PUSB_POWER_DESCRIPTOR->bDescriptorType or
        PUSB_CONFIGURATION_DESCRIPTOR->bDescriptorType

Return Value:

    ptr to string

--*/{

        switch(bDescriptorType) {

        case USB_DEVICE_DESCRIPTOR_TYPE:
                return "USB_DEVICE_DESCRIPTOR_TYPE";

        case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                return "USB_CONFIGURATION_DESCRIPTOR_TYPE";
                

        case USB_STRING_DESCRIPTOR_TYPE:
                return "USB_STRING_DESCRIPTOR_TYPE";
                

        case USB_INTERFACE_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_DESCRIPTOR_TYPE";
                

        case USB_ENDPOINT_DESCRIPTOR_TYPE:
                return "USB_ENDPOINT_DESCRIPTOR_TYPE";
                

#ifdef USB_POWER_DESCRIPTOR_TYPE // this is the older definintion which is actually obsolete
    // workaround for temporary bug in 98ddk, older USB100.h file
        case USB_POWER_DESCRIPTOR_TYPE:
                return "USB_POWER_DESCRIPTOR_TYPE";
#endif
                
#ifdef USB_RESERVED_DESCRIPTOR_TYPE  // this is the current version of USB100.h as in NT5DDK

        case USB_RESERVED_DESCRIPTOR_TYPE:
                return "USB_RESERVED_DESCRIPTOR_TYPE";

        case USB_CONFIG_POWER_DESCRIPTOR_TYPE:
                return "USB_CONFIG_POWER_DESCRIPTOR_TYPE";

        case USB_INTERFACE_POWER_DESCRIPTOR_TYPE:
                return "USB_INTERFACE_POWER_DESCRIPTOR_TYPE";
#endif // for current nt5ddk version of USB100.h
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbEndPointTypeString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of endpt descriptor type

Arguments:

        PUSB_ENDPOINT_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_ENDPOINT_TYPE_MASK;


        switch( typ) {
        case USB_ENDPOINT_TYPE_INTERRUPT:
                return "USB_ENDPOINT_TYPE_INTERRUPT";

        case USB_ENDPOINT_TYPE_BULK:
                return "USB_ENDPOINT_TYPE_BULK";        

        case USB_ENDPOINT_TYPE_ISOCHRONOUS:
                return "USB_ENDPOINT_TYPE_ISOCHRONOUS"; 
                
        case USB_ENDPOINT_TYPE_CONTROL:
                return "USB_ENDPOINT_TYPE_CONTROL";     
                
        default:
                return "??? UNKNOWN!!"; 
        }
}


char
*usbConfigAttributesString(UCHAR bmAttributes)
/*++
Routine Description:

    Called to get ascii string of USB_CONFIGURATION_DESCRIPTOR attributes

Arguments:

        PUSB_CONFIGURATION_DESCRIPTOR->bmAttributes

Return Value:

    ptr to string

--*/
{
        UINT typ = bmAttributes & USB_CONFIG_POWERED_MASK;


        switch( typ) {

        case USB_CONFIG_BUS_POWERED:
                return "USB_CONFIG_BUS_POWERED";

        case USB_CONFIG_SELF_POWERED:
                return "USB_CONFIG_SELF_POWERED";
                
        case USB_CONFIG_REMOTE_WAKEUP:
                return "USB_CONFIG_REMOTE_WAKEUP";

                
        default:
                return "??? UNKNOWN!!"; 
        }
}


void
print_USB_CONFIGURATION_DESCRIPTOR(PUSB_CONFIGURATION_DESCRIPTOR cd)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB config descriptor

Arguments:

    ptr to USB configuration descriptor

Return Value:

    none

--*/
{
    printf("\n===================\nUSB_CONFIGURATION_DESCRIPTOR\n");

    printf(
    "bLength = 0x%x, decimal %d\n", cd->bLength, cd->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", cd->bDescriptorType, usbDescriptorTypeString( cd->bDescriptorType )
    );

    printf(
    "wTotalLength = 0x%x, decimal %d\n", cd->wTotalLength, cd->wTotalLength
    );

    printf(
    "bNumInterfaces = 0x%x, decimal %d\n", cd->bNumInterfaces, cd->bNumInterfaces
    );

    printf(
    "bConfigurationValue = 0x%x, decimal %d\n", cd->bConfigurationValue, cd->bConfigurationValue
    );

    printf(
    "iConfiguration = 0x%x, decimal %d\n", cd->iConfiguration, cd->iConfiguration
    );

    printf(
    "bmAttributes = 0x%x ( %s )\n", cd->bmAttributes, usbConfigAttributesString( cd->bmAttributes )
    );

    printf(
    "MaxPower = 0x%x, decimal %d\n", cd->MaxPower, cd->MaxPower
    );
}


void
print_USB_INTERFACE_DESCRIPTOR(PUSB_INTERFACE_DESCRIPTOR id, UINT ix)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB interface descriptor

Arguments:

    ptr to USB interface descriptor

Return Value:

    none

--*/
{
    printf("\n-----------------------------\nUSB_INTERFACE_DESCRIPTOR #%d\n", ix);


    printf(
    "bLength = 0x%x\n", id->bLength
    );


    printf(
    "bDescriptorType = 0x%x ( %s )\n", id->bDescriptorType, usbDescriptorTypeString( id->bDescriptorType )
    );


    printf(
    "bInterfaceNumber = 0x%x\n", id->bInterfaceNumber
    );
    printf(
    "bAlternateSetting = 0x%x\n", id->bAlternateSetting
    );
    printf(
    "bNumEndpoints = 0x%x\n", id->bNumEndpoints
    );
    printf(
    "bInterfaceClass = 0x%x\n", id->bInterfaceClass
    );
    printf(
    "bInterfaceSubClass = 0x%x\n", id->bInterfaceSubClass
    );
    printf(
    "bInterfaceProtocol = 0x%x\n", id->bInterfaceProtocol
    );
    printf(
    "bInterface = 0x%x\n", id->iInterface
    );
}


void
print_USB_ENDPOINT_DESCRIPTOR(PUSB_ENDPOINT_DESCRIPTOR ed, int i)
/*++
Routine Description:

    Called to do formatted ascii dump to console of a USB endpoint descriptor

Arguments:

    ptr to USB endpoint descriptor,
        index of this endpt in interface desc

Return Value:

    none

--*/
{
    printf(
        "------------------------------\nUSB_ENDPOINT_DESCRIPTOR for Pipe%02d\n", i
        );

    printf(
    "bLength = 0x%x\n", ed->bLength
    );

    printf(
    "bDescriptorType = 0x%x ( %s )\n", ed->bDescriptorType, usbDescriptorTypeString( ed->bDescriptorType )
    );


        if ( USB_ENDPOINT_DIRECTION_IN( ed->bEndpointAddress ) ) {
                printf(
                "bEndpointAddress= 0x%x ( INPUT )\n", ed->bEndpointAddress
                );
        } else {
                printf(
                "bEndpointAddress= 0x%x ( OUTPUT )\n", ed->bEndpointAddress
                );
        }

    printf(
    "bmAttributes= 0x%x ( %s )\n", ed->bmAttributes, usbEndPointTypeString ( ed->bmAttributes )
    );


    printf(
    "wMaxPacketSize= 0x%x, decimal %d\n", ed->wMaxPacketSize, ed->wMaxPacketSize
    );
    printf(
    "bInterval = 0x%x, decimal %d\n", ed->bInterval, ed->bInterval
    );
}

void
rw_dev( HANDLE hDEV )
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwiso -u" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        ULONG success;
        int siz, nBytes;
        char buf[256];
    PUSB_CONFIGURATION_DESCRIPTOR cd;
    PUSB_INTERFACE_DESCRIPTOR id;
    PUSB_ENDPOINT_DESCRIPTOR ed;

        siz = sizeof(buf);

        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        
        success = DeviceIoControl(hDEV,
                        IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR,
                        buf,
                        siz,
                        buf,
                        siz,
                        &nBytes,
                        NULL);

        NOISY(("request complete, success = %d nBytes = %d\n", success, nBytes));
        
        if (success) {
        ULONG i;
                UINT  j, n;
        char *pch;

        pch = buf;
                n = 0;

        cd = (PUSB_CONFIGURATION_DESCRIPTOR) pch;

        print_USB_CONFIGURATION_DESCRIPTOR( cd );

        pch += cd->bLength;

        do {

            id = (PUSB_INTERFACE_DESCRIPTOR) pch;

            print_USB_INTERFACE_DESCRIPTOR(id, n++);

            pch += id->bLength;
            for (j=0; j<id->bNumEndpoints; j++) {

                ed = (PUSB_ENDPOINT_DESCRIPTOR) pch;

                print_USB_ENDPOINT_DESCRIPTOR(ed,j);

                pch += ed->bLength;
            }
            i = (ULONG)(pch - buf);
        } while (i<cd->wTotalLength);

        }
        
        return;

}


int  dumpUsbConfig()
/*++
Routine Description:

    Called to do formatted ascii dump to console of  USB
    configuration, interface, and endpoint descriptors
    (Cmdline "rwiso -u" )

Arguments:

    none

Return Value:

    none

--*/
{

        HANDLE hDEV = open_dev();

        if ( hDEV )
        {
                rw_dev( hDEV );
                CloseHandle(hDEV);
        }

        return 0;
}
//  End, routines for USB configuration and pipe info dump  (Cmdline "rwiso -u" )

// Begin, routines for Iso Streaming



void
IsoStream( HANDLE hDEV, BOOL fStop )
/*++
Routine Description:

    Called to start or stop an iso stream
    (Cmdline "RwIso -g" )

Arguments:

    handle to device

Return Value:

    none

--*/
{
        ULONG success;
        int nBytes;
        DWORD ioctl;
        char i;

        if ( fStop )
        {
                ioctl = IOCTL_ISOUSB_STOP_ISO_STREAM;
                
                for ( i = 0; i < sizeof( gbuf ); i ++ )
                        gbuf[ i ] = 0; // init outbuf to 0's to make sure read was good

                success = DeviceIoControl(hDEV,
                                ioctl,
                                &gpStreamObj, //pointer to stream object initted when stream was started
                                sizeof( PVOID),
                                gbuf, // output buffer gets back from kernel mode
                                sizeof(gbuf),
                                &nBytes,
                                NULL);

                NOISY(("DeviceIoControl STOP_ISO_STREAM complete, success = %d\n", success));
        }
        else
        {
                ioctl = IOCTL_ISOUSB_START_ISO_STREAM;
                //input is our 256-byte buffer, binary char 0-255
                for ( i = 0; i < sizeof( gbuf ); i ++ )
                        gbuf[ i ] = i;

                success = DeviceIoControl(hDEV,
                                ioctl,
                                gbuf,
                                sizeof(gbuf),
                                &gpStreamObj, // will receive pointer to stream object
                                sizeof( PVOID),
                                &nBytes,
                                NULL);

                NOISY(("DeviceIoControl START_ISO_STREAM complete, success = %d\n", success));
        }



        if (hDEV == INVALID_HANDLE_VALUE) {
                NOISY(("DEV not open"));
                return;
        }
        

        

}

void StartIsoStream( void )
{
        if ( !ghStreamDev ) {

                ghStreamDev = open_dev();

                if ( ghStreamDev != INVALID_HANDLE_VALUE ) {
                        IsoStream(  ghStreamDev , FALSE );

                        Sleep( gMS );

                        StopIsoStream();
                }
        }
}

void StopIsoStream( void )
{
        if ( ghStreamDev ) {
                IsoStream(  ghStreamDev , TRUE );
                ghStreamDev = NULL;
        }
}

// End, routines for Iso Streaming

int _cdecl main(
    int argc,
        char *argv[])
/*++
Routine Description:

    Entry point to RwIso.exe
    Parses cmdline, performs user-requested tests

Arguments:

    argc, argv  standard console  'c' app arguments

Return Value:

    Zero

--*/

{
    char *pinBuf = NULL, *poutBuf = NULL;
    ULONG nBytesRead, nBytesWrite, nBytes;
        ULONG i, j;
    int ok;
    ULONG success;
    HANDLE hRead = INVALID_HANDLE_VALUE, hWrite = INVALID_HANDLE_VALUE;
        char buf[1024];
        clock_t start, finish;
        ULONG totalBytes = 0L;
        double seconds;
        ULONG fail = 0L;

    parse(argc, argv );

        // dump USB configuation and pipe info
        if( fDumpUsbConfig ) {
                dumpUsbConfig();
        }


        // doing a read, write, or both test
        if ((fRead) || (fWrite)) {

            if (fRead) {
            //
            // open the output file
            //
                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( ReadLen % sizeof( ULONG ) )
                                                ReadLen++;
                        }

            hRead = open_file( inPipe);
        
                pinBuf = malloc(ReadLen);

            }

            if (fWrite) {

                        if ( fDumpReadData ) { // round size to sizeof ULONG for readable dumping
                                while( WriteLen % sizeof( ULONG ) )
                                                WriteLen++;
                        }

                hWrite = open_file( outPipe);
                poutBuf = malloc(WriteLen);
            }


        for (i=0; i<IterationCount; i++) {

            if (fWrite && poutBuf && hWrite != INVALID_HANDLE_VALUE) {

                                PULONG pOut = (PULONG) poutBuf;
                                ULONG  numLongs = WriteLen / sizeof( ULONG );
                //
                // put some data in the output buffer
                //

                for (j=0; j<numLongs; j++) {
                    *(pOut+j) = j;
                }

                //
                // send the write
                //

                    WriteFile(hWrite,
                              poutBuf,
                              WriteLen,
                              &nBytesWrite,
                              NULL);

                    printf("<%s> W (%04.4d) : request %06.6d bytes -- %06.6d bytes written\n",
                            outPipe, i, WriteLen, nBytesWrite);
                assert(nBytesWrite == WriteLen);
                }

                if (fRead && pinBuf) {

                    success = ReadFile(hRead,
                                  pinBuf,
                              ReadLen,
                                  &nBytesRead,
                                  NULL);

                    printf("<%s> R (%04.4d) : request %06.6d bytes -- %06.6d bytes read\n",
                        inPipe, i, ReadLen, nBytesRead);

                if (fWrite) {

                    //
                    // validate the input buffer against what
                    // we sent to the 82930 (loopback test)
                    //

                    ok = compare_buffs(pinBuf, poutBuf,  nBytesRead);

                                        if( fDumpReadData ) {
                                                printf("Dumping read buffer\n");
                                                dump( pinBuf, nBytesRead );     
                                                printf("Dumping write buffer\n");
                                                dump( poutBuf, nBytesRead );

                                        }

                    assert(ok);

                                        if(ok != 1)
                                                fail++;

                    assert(ReadLen == WriteLen);
                    assert(nBytesRead == ReadLen);
                    assert(nBytesWrite == WriteLen);
                }
                }
        
        }


        if (pinBuf) {
            free(pinBuf);
        }

        if (poutBuf) {
            free(poutBuf);
        }


                // close devices if needed
                if(hRead != INVALID_HANDLE_VALUE)
                        CloseHandle(hRead);
                if(hWrite != INVALID_HANDLE_VALUE)
                        CloseHandle(hWrite);

    }
        
        StopIsoStream(); // stop iso stream if we started one

        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isoperf\app\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sampapp.rc
//
#define IDI_APP_ICON                    105
#define IDC_ABOUT                       1000
#define IDC_GETDEVICEDESCRIPTOR         1001
#define IDC_START_ISO_IN_TEST           1001
#define IDC_EDIT1                       1002
#define IDC_STOP_ISO_IN_TEST            1002
#define IDC_DD_NAME                     1002
#define IDC_GETCONFIGDESCRIPTOR         1003
#define IDC_GET_ISO_STATS               1003
#define IDC_DRIVER_NAME                 1004
#define IDC_OUTPUT_BOX                  1005
#define IDC_WRITE_BULK_DATA             1006
#define IDC_GET_DEV_EXT                 1006
#define IDC_START_ISO_OUT_TEST          1006
#define IDC_READ_BULK_DATA              1007
#define IDC_BYTES_PER_SEC               1007
#define IDC_CHECK_STOP_BPS              1008
#define IDC_BYTES_ALLOC                 1009
#define IDC_BYTES_FREED                 1010
#define IDC_STOP_ISO_OUT_TEST           1011
#define IDC_CHECK_DO_IN_OUT             1011
#define IDC_CPU_TIME                    1012
#define IDC_COUNTDOWN_TO_STOP           1013
#define IDC_STAT_SAMPLING_PERIOD        1014
#define IDC_CPU_COUNTER_LOW             1015
#define IDC_URB_PROC_TIME               1016
#define IDC_DEVICE_HAD_ERROR            1017
#define IDC_USBD_PACKET_ERROR_CODE      1018
#define IDC_NUMBER_OF_USB_FRAMES_PER_IRP 1019
#define IDC_OUTSTANDING_IRPS_PER_PIPE   1020
#define IDC_URB_FRAME_OFFSET            1021
#define IDC_STARTING_FRAME_NUMBER       1022
#define IDC_FRAME_NUMBER_AT_IRP_POST    1023
#define IDC_URB_FRAME_OFFSET_OUT        1024
#define IDC_USBD_URB_ERROR              1025
#define IDC_DEVICE_RUNNING              1026
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1031
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isopnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopnp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_PNP_H
#define _ISOUSB_PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
IsoUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
GetBusInterfaceVersion(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
IsoUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
IsoUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
IsoUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isodev.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isodev.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_DEV_H
#define _ISOUSB_DEV_H

typedef struct _FILE_OBJECT_CONTENT {

    PVOID PipeInformation;
    PVOID StreamInformation;

}FILE_OBJECT_CONTENT, *PFILE_OBJECT_CONTENT;

NTSTATUS
IsoUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

LONG
IsoUsb_ParseStringForPipeNumber(
    IN PUNICODE_STRING PipeName
    );

NTSTATUS
IsoUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    );

NTSTATUS
IsoUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IsoUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PULONG PortStatus
    );

NTSTATUS
IsoUsb_ResetParentPort(
    IN IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isopnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopnp.c

Abstract:

    Isoch USB device driver for Intel 82930 USB test board
    Plug and Play module

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("///////////////////////////////////////////\n"));
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::"));
    IsoUsb_IoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {
            
            CancelSelectSuspend(deviceExtension);
        }
    }

    IsoUsb_DbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //
        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = CanRemoveDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {
        
            ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::default::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;

    } // switch

//
// complete request 
//

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

//
// decrement count
//
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPnP::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    IsoUsb_DbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    deviceExtension->UsbConfigurationDescriptor = NULL;
    deviceExtension->UsbInterface = NULL;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake outstanding flag to false.
    // and issue a wait wake.
    
    deviceExtension->FlagWWOutstanding = 0;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->WaitWakeIrp = NULL;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer for selective suspend requests.
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    if((Win2kOrBetter == deviceExtension->WdmVersion) ||
       (WinXpOrBetter == deviceExtension->WdmVersion)) {

        deviceExtension->IsDeviceHighSpeed = 0;
        GetBusInterfaceVersion(DeviceObject);
    }

    IsoUsb_DbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
                            
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to allocate memory for deviceDescriptor"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for urb"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;



    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                IsoUsb_DbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                IsoUsb_DbgPrint(1,("Failed to read configuration descriptor"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        //
        // save a copy of configurationDescriptor in deviceExtension
        // remember to free it later.
        //
        deviceExtension->UsbConfigurationDescriptor = configurationDescriptor;

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }
    else {

        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION Interface;

    //
    // initialize the variables
    //

    urb = NULL;
    Interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        IsoUsb_DbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        Interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<Interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            Interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(NT_SUCCESS(ntStatus)) {

            //
            // save a copy of interface information in the device extension.
            //
            deviceExtension->UsbInterface = ExAllocatePool(NonPagedPool,
                                                           Interface->Length);

            if(deviceExtension->UsbInterface) {
                
                RtlCopyMemory(deviceExtension->UsbInterface,
                              Interface,
                              Interface->Length);
            }
            else {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                IsoUsb_DbgPrint(1, ("memory alloc for UsbInterface failed\n"));
            }

            //
            // Dump the interface to the debugger
            //

            Interface = &urb->UrbSelectConfiguration.Interface;

            IsoUsb_DbgPrint(3, ("---------\n"));
            IsoUsb_DbgPrint(3, ("NumberOfPipes 0x%x\n", 
                                 Interface->NumberOfPipes));
            IsoUsb_DbgPrint(3, ("Length 0x%x\n", 
                                 Interface->Length));
            IsoUsb_DbgPrint(3, ("Alt Setting 0x%x\n", 
                                 Interface->AlternateSetting));
            IsoUsb_DbgPrint(3, ("Interface Number 0x%x\n", 
                                 Interface->InterfaceNumber));
            IsoUsb_DbgPrint(3, ("Class, subclass, protocol 0x%x 0x%x 0x%x\n",
                                 Interface->Class,
                                 Interface->SubClass,
                                 Interface->Protocol));

            for(i=0; i<Interface->NumberOfPipes; i++) {

                IsoUsb_DbgPrint(3, ("---------\n"));
                IsoUsb_DbgPrint(3, ("PipeType 0x%x\n", 
                                     Interface->Pipes[i].PipeType));
                IsoUsb_DbgPrint(3, ("EndpointAddress 0x%x\n", 
                                     Interface->Pipes[i].EndpointAddress));
                IsoUsb_DbgPrint(3, ("MaxPacketSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumPacketSize));
                IsoUsb_DbgPrint(3, ("Interval 0x%x\n", 
                                     Interface->Pipes[i].Interval));
                IsoUsb_DbgPrint(3, ("Handle 0x%x\n", 
                                     Interface->Pipes[i].PipeHandle));
                IsoUsb_DbgPrint(3, ("MaximumTransferSize 0x%x\n", 
                                    Interface->Pipes[i].MaximumTransferSize));
            }

            IsoUsb_DbgPrint(3, ("---------\n"));
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        IsoUsb_DbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

    NT status value

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        IsoUsb_DbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    IsoUsb_DbgPrint(3, ("CallUSBD::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    IsoUsb_DbgPrint(3, ("CallUSBD::"));
    IsoUsb_IoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice::"));
    IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {
            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //
            KeCancelTimer(&deviceExtension->Timer);
            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // when we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }
    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //

    ReleaseMemory(DeviceObject);
    
    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice::"));
    IsoUsb_IoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        if(deviceExtension->SSEnable) {
            
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;
            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    IsoUsb_AbortPipes(DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {
                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }

        IsoUsb_AbortPipes(DeviceObject);


    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    IsoUsb_WmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = IsoUsb_IoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    IsoUsb_DbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    IsoUsb_DbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        IsoUsb_DbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Set some values in deviceCapabilities here...
    //
    //.............................................
    //
    //
    // Prepare to pass the IRP down
    //

    //
    // Add in the SurpriseRemovalOK bit before passing it down.
    //
    pdc->SurpriseRemovalOK = TRUE;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;
    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    IsoUsb_DbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    IsoUsb_DbgPrint(3, ("DpcRoutine - begins\n"));

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        IsoUsb_DbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            IsoUsb_DbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        IsoUsb_DbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    IsoUsb_DbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    IsoUsb_DbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        IsoUsb_DbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        IsoUsb_DbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    IsoUsb_DbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    IsoUsb_DbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                IsoUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                IsoUsb_IoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                IsoUsb_DbgPrint(3, ("ProcessQueuedRequests::"));
                IsoUsb_IoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    IsoUsb_DbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}

VOID
GetBusInterfaceVersion(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine queries the bus interface version

Arguments:

    DeviceExtension

Return Value:

    VOID

--*/
{
    PIRP                       irp;
    KEVENT                     event;
    NTSTATUS                   ntStatus;
    PDEVICE_EXTENSION          deviceExtension;
    PIO_STACK_LOCATION         nextStack;
    USB_BUS_INTERFACE_USBDI_V1 busInterfaceVer1;

    //
    // initialize vars
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion - begins\n"));

    irp = IoAllocateIrp(deviceExtension->TopOfStackDeviceObject->StackSize,
                        FALSE);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("Failed to alloc irp in GetBusInterfaceVersion\n"));
        return;
    }

    //
    // All pnp Irp's need the status field initialized to
    // STATUS_NOT_SUPPORTED
    //
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE) IrpCompletionRoutine,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack);
    nextStack->MajorFunction = IRP_MJ_PNP;
    nextStack->MinorFunction = IRP_MN_QUERY_INTERFACE;

    //
    // Allocate memory for an interface of type
    // USB_BUS_INTERFACE_USBDI_V0 and have the IRP point to it:
    //
    nextStack->Parameters.QueryInterface.Interface = 
                                (PINTERFACE) &busInterfaceVer1;

    //
    // Assign the InterfaceSpecificData member of the IRP to be NULL
    //
    nextStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Set the interface type to the appropriate GUID
    //
    nextStack->Parameters.QueryInterface.InterfaceType = 
                                        &USB_BUS_INTERFACE_USBDI_GUID;

    //
    // Set the size and version of interface in the IRP
    // Currently, there is only one valid version of 
    // this interface available to clients.
    //
    nextStack->Parameters.QueryInterface.Size = 
                                    sizeof(USB_BUS_INTERFACE_USBDI_V1);

    nextStack->Parameters.QueryInterface.Version = USB_BUSIF_USBDI_VERSION_1;
    
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(DeviceObject,
                            irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->IsDeviceHighSpeed = 
                busInterfaceVer1.IsDeviceHighSpeed(
                                       busInterfaceVer1.BusContext);

        IsoUsb_DbgPrint(1, ("IsDeviceHighSpeed = %x\n", 
                            deviceExtension->IsDeviceHighSpeed));
    }

    IoFreeIrp(irp);

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("GetBusInterfaceVersion - ends\n"));
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
IsoUsb_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    IsoUsb_DbgPrint(3, ("IsoUsb_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
IsoUsb_AbortPipes(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine sends an irp/urb pair with
    URB_FUNCTION_ABORT_PIPE request down the stack

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB                        urb;
    ULONG                       i;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSBD_PIPE_INFORMATION      pipeInformation;
    PUSBD_INTERFACE_INFORMATION interfaceInfo;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    interfaceInfo = deviceExtension->UsbInterface;
    
    IsoUsb_DbgPrint(3, ("IsoUsb_AbortPipes - begins\n"));
    
    if(interfaceInfo == NULL) {

        return STATUS_SUCCESS;
    }

    for(i = 0; i < interfaceInfo->NumberOfPipes; i++) {

        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_PIPE_REQUEST));

        if(urb) {

            urb->UrbHeader.Length = sizeof(struct _URB_PIPE_REQUEST);
            urb->UrbHeader.Function = URB_FUNCTION_ABORT_PIPE;
            urb->UrbPipeRequest.PipeHandle = 
                            interfaceInfo->Pipes[i].PipeHandle;

            ntStatus = CallUSBD(DeviceObject, urb);

            ExFreePool(urb);
        }
        else {

            IsoUsb_DbgPrint(1, ("Failed to alloc memory for urb for input pipe\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            return ntStatus;
        }
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_AbortPipes - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION     deviceExtension;
    KIRQL                 oldIrql;
    LIST_ENTRY            cleanupList;
    PLIST_ENTRY           thisEntry, 
                          nextEntry, 
                          listHead;
    PIRP                  pendingIrp;
    PIO_STACK_LOCATION    pendingIrpStack, 
                          irpStack;
    NTSTATUS              ntStatus;
    PFILE_OBJECT          fileObject;
    PFILE_OBJECT_CONTENT  fileObjectContent;
    PISOUSB_STREAM_OBJECT tempStreamObject;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClean::"));
    IsoUsb_IoIncrement(deviceExtension);

    //
    // check if any stream objects need to be cleaned
    //

    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT)
                            fileObject->FsContext;

        if(fileObjectContent->StreamInformation) {

            tempStreamObject = (PISOUSB_STREAM_OBJECT)
                               InterlockedExchangePointer(
                                    &fileObjectContent->StreamInformation,
                                    NULL);
        
            if(tempStreamObject && 
               (tempStreamObject->DeviceObject == DeviceObject)) {
        
                IsoUsb_DbgPrint(3, ("clean dispatch routine"
                                    " found a stream object match\n"));
                IsoUsb_StreamObjectCleanup(tempStreamObject, deviceExtension);
            }
        }
    }

    InitializeListHead(&cleanupList);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClean::"));
    IsoUsb_IoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    IsoUsb_DbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

LONG
IsoUsb_IoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_IoIncrement::%d\n", result));

    return result;
}

LONG
IsoUsb_IoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_IoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
    //
    // Disconnect from the interrupt and unmap any I/O ports
    //
    
    PDEVICE_EXTENSION deviceExtension;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(deviceExtension->UsbConfigurationDescriptor) {

        ExFreePool(deviceExtension->UsbConfigurationDescriptor);
        deviceExtension->UsbConfigurationDescriptor = NULL;
    }

    if(deviceExtension->UsbInterface) {
        
        ExFreePool(deviceExtension->UsbInterface);
        deviceExtension->UsbInterface = NULL;
    }

    return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isopwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isopwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_POWER_H
#define _ISOUSB_POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
IsoUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isopwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    isopwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPower::"));
    IsoUsb_IoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //
        // Mark the Irp as pending and return STATUS_PENDING if we change the 
        // nature of the irp in the completion routine (asynchroniticity).
        // In such cases, do not return the status returned by the lower driver.
        // returning STATUS_MORE_PROCESSING_REQUIRED in the completion routine 
        // transforms the nature of the irp to asynchronous irp.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        }

        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        IsoUsb_DbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        IsoUsb_IoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed this Irp\n"));
        }
        
        IsoUsb_DbgPrint(3, ("IsoUsb_DispatchPower::"));
        IsoUsb_IoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    IsoUsb_DbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IsoUsb_DbgPrint(3, ("Query for system power state S%X\n"
                        "Current system power state S%X\n",
                        systemState - 1,
                        deviceExtension->SysPower - 1));

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    if((deviceExtension->WaitWakeEnable) &&
       (systemState > deviceExtension->DeviceCapabilities.SystemWake)) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("HandleSystemQueryPower::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;
    }

    //
    // if querying for a lower S-state, issue a wait-wake
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    IsoUsb_DbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    IsoUsb_DbgPrint(3, ("Set request for system power state S%X\n"
                        "Current system power state S%X\n",
                        systemState - 1,
                        deviceExtension->SysPower - 1));

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    IsoUsb_DbgPrint(3, ("Query for device power state D%X\n"
                        "Current device power state D%X\n",
                        deviceState - 1,
                        deviceExtension->DevPower - 1));

    if(deviceExtension->WaitWakeEnable &&
       deviceState > deviceExtension->DeviceCapabilities.DeviceWake) {

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
        IsoUsb_IoDecrement(deviceExtension);

        return ntStatus;
    }

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine::"));
        IsoUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    IsoUsb_DbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("SendDeviceIrp::"));
        IsoUsb_IoDecrement(deviceExtension);

    }

    IsoUsb_DbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);

    ExFreePool(powerContext);

    IsoUsb_DbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    IsoUsb_DbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    IsoUsb_DbgPrint(3, ("Set request for device power state D%X\n"
                        "Current device power state D%X\n",
                        newDevState - 1,
                        deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        IsoUsb_DbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        IsoUsb_DbgPrint(3, ("Removing power or SetD0\n"));

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //
            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                IsoUsb_DbgPrint(3, ("HandleDeviceSetPower::"));
                IsoUsb_IoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }

        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    IsoUsb_DbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp::"));
        IsoUsb_IoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    IsoUsb_DbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional::"));
    IsoUsb_IoDecrement(DeviceExtension);

    IsoUsb_DbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        IsoUsb_DbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp::"));
    IsoUsb_IoDecrement(DeviceExtension);

    IsoUsb_DbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            IsoUsb_DbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    IsoUsb_DbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke IsoUsb_IoDecrement twice: once each for the S-Irp and D-Irp.
    //
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoIncrement(deviceExtension);
    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    IsoUsb_IoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    IsoUsb_DbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    IsoUsb_DbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    IsoUsb_DbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    IsoUsb_DbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    IsoUsb_DbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    IsoUsb_DbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    IsoUsb_DbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    IsoUsb_DbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    IsoUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    IsoUsb_DbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        IsoUsb_DbgPrint(3, ("device already powered up...\n"));

        return;
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCallback::"));
    IsoUsb_IoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {
    
        IssueWaitWake(deviceExtension);
    }

    IsoUsb_DbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isorwr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isorwr.c

Abstract:

    This file has dispatch routines for read and write.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine does some validation and 
    invokes appropriate function to perform
    Isoch transfer

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG                  totalLength;
    ULONG                  packetSize;
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PFILE_OBJECT_CONTENT   fileObjectContent;
    PUSBD_PIPE_INFORMATION pipeInformation;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    totalLength = 0;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite - begins\n"));

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite::"));
    IsoUsb_IoIncrement(deviceExtension);

    if(deviceExtension->DeviceState != Working) {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // make sure that the selective suspend request has been completed.
    //
    if(deviceExtension->SSEnable) {

        //
        // It is true that the client driver cancelled the selective suspend
        // request in the dispatch routine for create Irps.
        // But there is no guarantee that it has indeed completed.
        // so wait on the NoIdleReqPendEvent and proceed only if this event
        // is signalled.
        //
        IsoUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));

        
        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    //
    // obtain the pipe information for read 
    // and write from the fileobject.
    //
    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;

        pipeInformation = (PUSBD_PIPE_INFORMATION)
                          fileObjectContent->PipeInformation;
    }
    else {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    if((pipeInformation == NULL) ||
       (UsbdPipeTypeIsochronous != pipeInformation->PipeType)) {

        IsoUsb_DbgPrint(1, ("Incorrect pipe\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    if(Irp->MdlAddress) {

        totalLength = MmGetMdlByteCount(Irp->MdlAddress);
    }

    if(totalLength == 0) {

        IsoUsb_DbgPrint(1, ("Transfer data length = 0\n"));

        ntStatus = STATUS_SUCCESS;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // each packet can hold this much info
    //
    packetSize = pipeInformation->MaximumPacketSize;

    if(packetSize == 0) {

        IsoUsb_DbgPrint(1, ("Invalid parameter\n"));

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    //
    // atleast packet worth of data to be transferred.
    //
    if(totalLength < packetSize) {

        IsoUsb_DbgPrint(1, ("Atleast packet worth of data..\n"));

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchReadWrite_Exit;
    }

    // perform reset. if there are some active transfers queued up
    // for this endpoint then the reset pipe will fail.
    //
    IsoUsb_ResetPipe(DeviceObject, pipeInformation);

    if(deviceExtension->IsDeviceHighSpeed) {

        ntStatus = PerformHighSpeedIsochTransfer(DeviceObject,
                                                 pipeInformation,
                                                 Irp,
                                                 totalLength);

    }
    else {

        ntStatus = PerformFullSpeedIsochTransfer(DeviceObject,
                                                 pipeInformation,
                                                 Irp,
                                                 totalLength);

    }

    return ntStatus;

IsoUsb_DispatchReadWrite_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchReadWrite::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
PerformHighSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    )
/*++
 
Routine Description:

    High Speed Isoch Transfer requires packets in multiples of 8.
    (Argument: 8 micro-frames per ms frame)
    Another restriction is that each Irp/Urb pair can be associated
    with a max of 1024 packets.

    Here is one of the ways of creating Irp/Urb pairs.
    Depending on the characteristics of real-world device,
    the algorithm may be different

    This algorithm will distribute data evenly among all the packets.

    Input:
    TotalLength - no. of bytes to be transferred.

    Other parameters:
    packetSize - max size of each packet for this pipe.

    Implementation Details:
    
    Step 1:
    ASSERT(TotalLength >= 8)

    Step 2: 
    Find the exact number of packets required to transfer all of this data

    numberOfPackets = (TotalLength + packetSize - 1) / packetSize

    Step 3: 
    Number of packets in multiples of 8.

    if(0 == (numberOfPackets % 8)) {
        
        actualPackets = numberOfPackets;
    }
    else {

        actualPackets = numberOfPackets + 
                        (8 - (numberOfPackets % 8));
    }
    
    Step 4:
    Determine the min. data in each packet.

    minDataInEachPacket = TotalLength / actualPackets;

    Step 5:
    After placing min data in each packet, 
    determine how much data is left to be distributed. 
    
    dataLeftToBeDistributed = TotalLength - 
                              (minDataInEachPacket * actualPackets);

    Step 6:
    Start placing the left over data in the packets 
    (above the min data already placed)

    numberOfPacketsFilledToBrim = dataLeftToBeDistributed / 
                                  (packetSize - minDataInEachPacket);

    Step 7:
    determine if there is any more data left.

    dataLeftToBeDistributed -= (numberOfPacketsFilledToBrim * 
                                (packetSize - minDataInEachPacket));

    Step 8:
    The "dataLeftToBeDistributed" is placed in the packet at index
    "numberOfPacketsFilledToBrim"

    Algorithm at play:

    TotalLength  = 8193
    packetSize   = 8
    Step 1

    Step 2
    numberOfPackets = (8193 + 8 - 1) / 8 = 1025
    
    Step 3
    actualPackets = 1025 + 7 = 1032

    Step 4
    minDataInEachPacket = 8193 / 1032 = 7 bytes

    Step 5
    dataLeftToBeDistributed = 8193 - (7 * 1032) = 969.

    Step 6
    numberOfPacketsFilledToBrim = 969 / (8 - 7) = 969.
  
    Step 7
    dataLeftToBeDistributed = 969 - (969 * 1) = 0.
    
    Step 8
    Done :)

    Another algorithm
    Completely fill up (as far as possible) the early packets.
    Place 1 byte each in the rest of them.
    Ensure that the total number of packets is multiple of 8.

    This routine then
    1. creates a ISOUSB_RW_CONTEXT for each
       read/write to be performed.
    2. creates SUB_CONTEXT for each irp/urb pair.
       (Each irp/urb pair can transfer a max of 1024 packets.)
    3. All the irp/urb pairs are initialized
    4. The subsidiary irps (of the irp/urb pair) are passed 
       down the stack at once.
    5. The main Read/Write irp is pending

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              i;
    ULONG              j;
    ULONG              numIrps;
    ULONG              stageSize;
    ULONG              contextSize;
    ULONG              packetSize;
    ULONG              numberOfPackets;
    ULONG              actualPackets;
    ULONG              minDataInEachPacket;
    ULONG              dataLeftToBeDistributed;
    ULONG              numberOfPacketsFilledToBrim;
    CCHAR              stackSize;
    KIRQL              oldIrql;
    PUCHAR             virtualAddress;
    BOOLEAN            read;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_STACK_LOCATION nextStack;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(TotalLength < 8) {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    //
    // each packet can hold this much info
    //
    packetSize = PipeInformation->MaximumPacketSize;

    numberOfPackets = (TotalLength + packetSize - 1) / packetSize;

    if(0 == (numberOfPackets % 8)) {

        actualPackets = numberOfPackets;
    }
    else {

        //
        // we need multiple of 8 packets only.
        //
        actualPackets = numberOfPackets +
                        (8 - (numberOfPackets % 8));
    }

    minDataInEachPacket = TotalLength / actualPackets;

    if(minDataInEachPacket == packetSize) {

        numberOfPacketsFilledToBrim = actualPackets;
        dataLeftToBeDistributed     = 0;

        IsoUsb_DbgPrint(1, ("TotalLength = %d\n", TotalLength));
        IsoUsb_DbgPrint(1, ("PacketSize  = %d\n", packetSize));
        IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n", 
                            numberOfPacketsFilledToBrim,
                            packetSize));
    }
    else {

        dataLeftToBeDistributed = TotalLength - 
                              (minDataInEachPacket * actualPackets);

        numberOfPacketsFilledToBrim = dataLeftToBeDistributed /
                                  (packetSize - minDataInEachPacket);

        dataLeftToBeDistributed -= (numberOfPacketsFilledToBrim *
                                (packetSize - minDataInEachPacket));
    

        IsoUsb_DbgPrint(1, ("TotalLength = %d\n", TotalLength));
        IsoUsb_DbgPrint(1, ("PacketSize  = %d\n", packetSize));
        IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n", 
                            numberOfPacketsFilledToBrim,
                            packetSize));
        if(dataLeftToBeDistributed) {

            IsoUsb_DbgPrint(1, ("One packet has %d bytes\n",
                                minDataInEachPacket + dataLeftToBeDistributed));
            IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n",
                                actualPackets - (numberOfPacketsFilledToBrim + 1),
                                minDataInEachPacket));
        }
        else {
            IsoUsb_DbgPrint(1, ("Each of %d packets has %d bytes\n",
                                actualPackets - numberOfPacketsFilledToBrim,
                                minDataInEachPacket));
        }
    }

    //
    // determine how many stages of transfer needs to be done.
    // in other words, how many irp/urb pairs required. 
    // this irp/urb pair is also called the subsidiary irp/urb pair
    //
    numIrps = (actualPackets + 1023) / 1024;

    IsoUsb_DbgPrint(1, ("PeformHighSpeedIsochTransfer::numIrps = %d\n", numIrps));

    //
    // for every read/write transfer
    // we create an ISOUSB_RW_CONTEXT
    //
    // initialize the read/write context
    //
    
    contextSize = sizeof(ISOUSB_RW_CONTEXT);

    rwContext = (PISOUSB_RW_CONTEXT) ExAllocatePool(NonPagedPool,
                                                    contextSize);

    if(rwContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext, contextSize);

    //
    // allocate memory for every stage context - 
    // subcontext has state information for every irp/urb pair.
    //
    rwContext->SubContext = (PSUB_CONTEXT) 
                            ExAllocatePool(NonPagedPool, 
                                           numIrps * sizeof(SUB_CONTEXT));

    if(rwContext->SubContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for SubContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool(rwContext);
        goto PerformHighSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext->SubContext, numIrps * sizeof(SUB_CONTEXT));

    rwContext->RWIrp = Irp;
    rwContext->Lock = 2;
    rwContext->NumIrps = numIrps;
    rwContext->IrpsPending = numIrps;
    rwContext->DeviceExtension = deviceExtension;
    KeInitializeSpinLock(&rwContext->SpinLock);
    //
    // save the rwContext pointer in the tail union.
    //
    Irp->Tail.Overlay.DriverContext[0] = (PVOID) rwContext;

    stackSize = deviceExtension->TopOfStackDeviceObject->StackSize + 1;
    virtualAddress = (PUCHAR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    for(i = 0; i < numIrps; i++) {
    
        PIRP  subIrp;
        PURB  subUrb;
        PMDL  subMdl;
        ULONG nPackets;
        ULONG siz;
        ULONG offset;

        //
        // for every stage of transfer we need to do the following
        // tasks
        // 1. allocate an irp
        // 2. allocate an urb
        // 3. allocate a mdl.
        //
        // create a subsidiary irp
        //
        subIrp = IoAllocateIrp(stackSize, FALSE);

        if(subIrp == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context irp\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubIrp = subIrp;

        if(actualPackets <= 1024) {
            
            nPackets = actualPackets;
            actualPackets = 0;
        }
        else {

            nPackets = 1024;
            actualPackets -= 1024;
        }

        IsoUsb_DbgPrint(1, ("nPackets = %d for Irp/URB pair %d\n", nPackets, i));

        ASSERT(nPackets <= 1024);

        siz = GET_ISO_URB_SIZE(nPackets);

        //
        // create a subsidiary urb.
        //

        subUrb = (PURB) ExAllocatePool(NonPagedPool, siz);

        if(subUrb == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context urb\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubUrb = subUrb;

        if(nPackets > numberOfPacketsFilledToBrim) {
            
            stageSize =  packetSize * numberOfPacketsFilledToBrim;
            stageSize += (minDataInEachPacket * 
                          (nPackets - numberOfPacketsFilledToBrim));
            stageSize += dataLeftToBeDistributed;
        }
        else {

            stageSize = packetSize * nPackets;
        }

        //
        // allocate a mdl.
        //
        subMdl = IoAllocateMdl((PVOID) virtualAddress, 
                               stageSize,
                               FALSE,
                               FALSE,
                               NULL);

        if(subMdl == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context mdl\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformHighSpeedIsochTransfer_Free;
        }

        IoBuildPartialMdl(Irp->MdlAddress,
                          subMdl,
                          (PVOID) virtualAddress,
                          stageSize);

        rwContext->SubContext[i].SubMdl = subMdl;

        virtualAddress += stageSize;
        TotalLength -= stageSize;

        //
        // Initialize the subsidiary urb
        //
        RtlZeroMemory(subUrb, siz);

        subUrb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
        subUrb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
        subUrb->UrbIsochronousTransfer.PipeHandle = PipeInformation->PipeHandle;

        if(read) {

            IsoUsb_DbgPrint(1, ("read\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags = 
                                                     USBD_TRANSFER_DIRECTION_IN;
        }
        else {

            IsoUsb_DbgPrint(1, ("write\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags =
                                                     USBD_TRANSFER_DIRECTION_OUT;
        }

        subUrb->UrbIsochronousTransfer.TransferBufferLength = stageSize;
        subUrb->UrbIsochronousTransfer.TransferBufferMDL = subMdl;
/*
        This is a way to set the start frame and NOT specify ASAP flag.

        subUrb->UrbIsochronousTransfer.StartFrame = 
                        IsoUsb_GetCurrentFrame(DeviceObject, Irp) + 
                        SOME_LATENCY;
*/
        subUrb->UrbIsochronousTransfer.TransferFlags |=
                                        USBD_START_ISO_TRANSFER_ASAP;

        subUrb->UrbIsochronousTransfer.NumberOfPackets = nPackets;
        subUrb->UrbIsochronousTransfer.UrbLink = NULL;

        //
        // set the offsets for every packet for reads/writes
        //
        if(read) {
            
            offset = 0;

            for(j = 0; j < nPackets; j++) {
            
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 0;

                if(numberOfPacketsFilledToBrim) {

                    offset += packetSize;
                    numberOfPacketsFilledToBrim--;
                    stageSize -= packetSize;
                }
                else if(dataLeftToBeDistributed) {

                    offset += (minDataInEachPacket + dataLeftToBeDistributed);
                    stageSize -= (minDataInEachPacket + dataLeftToBeDistributed);
                    dataLeftToBeDistributed = 0;                    
                }
                else {

                    offset += minDataInEachPacket;
                    stageSize -= minDataInEachPacket;
                }
            }

            ASSERT(stageSize == 0);
        }
        else {

            offset = 0;

            for(j = 0; j < nPackets; j++) {

                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;

                if(numberOfPacketsFilledToBrim) {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = packetSize;
                    offset += packetSize;
                    numberOfPacketsFilledToBrim--;
                    stageSize -= packetSize;
                }
                else if(dataLeftToBeDistributed) {
                    
                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 
                                        minDataInEachPacket + dataLeftToBeDistributed;
                    offset += (minDataInEachPacket + dataLeftToBeDistributed);
                    stageSize -= (minDataInEachPacket + dataLeftToBeDistributed);
                    dataLeftToBeDistributed = 0;
                    
                }
                else {
                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = minDataInEachPacket;
                    offset += minDataInEachPacket;
                    stageSize -= minDataInEachPacket;
                }
            }

            ASSERT(stageSize == 0);
        }

        IoSetNextIrpStackLocation(subIrp);
        nextStack = IoGetCurrentIrpStackLocation(subIrp);

        nextStack->DeviceObject = DeviceObject;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.Others.Argument2 = (PVOID) subMdl;

        nextStack = IoGetNextIrpStackLocation(subIrp);
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

        IoSetCompletionRoutine(subIrp,
                               (PIO_COMPLETION_ROUTINE) IsoUsb_SinglePairComplete,
                               (PVOID) rwContext,
                               TRUE,
                               TRUE,
                               TRUE);       
    }

    //
    // while we were busy create subsidiary irp/urb pairs..
    // the main read/write irp may have been cancelled !!
    //

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    IoSetCancelRoutine(Irp, IsoUsb_CancelReadWrite);

    if(Irp->Cancel) {

        //
        // The Cancel flag for the Irp has been set. 
        //
        IsoUsb_DbgPrint(3, ("Cancel flag set\n"));

        ntStatus = STATUS_CANCELLED;

        if(IoSetCancelRoutine(Irp, NULL)) {

            //
            // But the I/O manager did not call our cancel routine.
            // we need to free the 1) irp, 2) urb and 3) mdl for every 
            // stage and complete the main Irp after releasing the lock
            //

            IsoUsb_DbgPrint(3, ("cancellation routine NOT run\n"));

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            goto PerformHighSpeedIsochTransfer_Free;
        }
        else {
            
            //
            // The cancel routine will resume the moment we release the lock.
            //
            for(j = 0; j < numIrps; j++) {

                if(rwContext->SubContext[j].SubUrb) {

                    ExFreePool(rwContext->SubContext[j].SubUrb);
                    rwContext->SubContext[j].SubUrb = NULL;
                }

                if(rwContext->SubContext[j].SubMdl) {

                    IoFreeMdl(rwContext->SubContext[j].SubMdl);
                    rwContext->SubContext[j].SubMdl = NULL;
                }
            }

            IoMarkIrpPending(Irp);

            //
            // it is the job of the cancellation routine to free
            // sub-context irps, release rwContext and complete 
            // the main readwrite irp
            //
            InterlockedDecrement(&rwContext->Lock);

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            return STATUS_PENDING;
        }
    }
    else {

        //
        // normal processing
        //

        IsoUsb_DbgPrint(3, ("normal processing\n"));

        IoMarkIrpPending(Irp);

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        for(j = 0; j < numIrps; j++) {

            IsoUsb_DbgPrint(3, ("PerformHighSpeedIsochTransfer::"));
            IsoUsb_IoIncrement(deviceExtension);
            
            IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                         rwContext->SubContext[j].SubIrp);
        }
        return STATUS_PENDING;
    }

PerformHighSpeedIsochTransfer_Free:

    for(j = 0; j < numIrps; j++) {

        if(rwContext->SubContext[j].SubIrp) {

            IoFreeIrp(rwContext->SubContext[j].SubIrp);
            rwContext->SubContext[j].SubIrp = NULL;
        }

        if(rwContext->SubContext[j].SubUrb) {

            ExFreePool(rwContext->SubContext[j].SubUrb);
            rwContext->SubContext[j].SubUrb = NULL;
        }

        if(rwContext->SubContext[j].SubMdl) {

            IoFreeMdl(rwContext->SubContext[j].SubMdl);
            rwContext->SubContext[j].SubMdl = NULL;
        }
    }

    ExFreePool(rwContext->SubContext);
    ExFreePool(rwContext);

PerformHighSpeedIsochTransfer_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("PerformHighSpeedIsochTransfer::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
PerformFullSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    )
/*++
 
Routine Description:

    This routine 
    1. creates a ISOUSB_RW_CONTEXT for every
       read/write to be performed.
    2. creates SUB_CONTEXT for each irp/urb pair.
       (Each irp/urb pair can transfer only 255 packets.)
    3. All the irp/urb pairs are initialized
    4. The subsidiary irps (of the irp/urb pair) are passed 
       down the stack at once.
    5. The main Read/Write irp is pending

Arguments:

    DeviceObject - pointer to device object
    PipeInformation - USBD_PIPE_INFORMATION
    Irp - I/O request packet
    TotalLength - no. of bytes to be transferred

Return Value:

    NT status value

--*/
{
    ULONG              i;
    ULONG              j;
    ULONG              packetSize;
    ULONG              numIrps;
    ULONG              stageSize;
    ULONG              contextSize;
    CCHAR              stackSize;
    KIRQL              oldIrql;
    PUCHAR             virtualAddress;
    BOOLEAN            read;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    PIO_STACK_LOCATION nextStack;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    read = (irpStack->MajorFunction == IRP_MJ_READ) ? TRUE : FALSE;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer - begins\n"));
/*
    if(read) {

        pipeInformation = &deviceExtension->UsbInterface->Pipes[ISOCH_IN_PIPE_INDEX];
    }
    else {

        pipeInformation = &deviceExtension->UsbInterface->Pipes[ISOCH_OUT_PIPE_INDEX];
    }
*/

    //
    // each packet can hold this much info
    //
    packetSize = PipeInformation->MaximumPacketSize;

    IsoUsb_DbgPrint(3, ("totalLength = %d\n", TotalLength));
    IsoUsb_DbgPrint(3, ("packetSize = %d\n", packetSize));

    //
    // there is an inherent limit on the number of packets
    // that can be passed down the stack with each 
    // irp/urb pair (255)
    // if the number of required packets is > 255,
    // we shall create "required-packets / 255 + 1" number 
    // of irp/urb pairs. 
    // Each irp/urb pair transfer is also called a stage transfer.
    //
    if(TotalLength > (packetSize * 255)) {

        stageSize = packetSize * 255;
    }
    else {

        stageSize = TotalLength;
    }

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::stageSize = %d\n", stageSize));

    //
    // determine how many stages of transfer needs to be done.
    // in other words, how many irp/urb pairs required. 
    // this irp/urb pair is also called the subsidiary irp/urb pair
    //
    numIrps = (TotalLength + stageSize - 1) / stageSize;

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::numIrps = %d\n", numIrps));

    //
    // for every read/write transfer
    // we create an ISOUSB_RW_CONTEXT
    //
    // initialize the read/write context
    //
    
    contextSize = sizeof(ISOUSB_RW_CONTEXT);

    rwContext = (PISOUSB_RW_CONTEXT) ExAllocatePool(NonPagedPool,
                                                    contextSize);

    if(rwContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for rwContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto PerformFullSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext, contextSize);

    //
    // allocate memory for every stage context - 
    // subcontext has state information for every irp/urb pair.
    //
    rwContext->SubContext = (PSUB_CONTEXT) 
                            ExAllocatePool(NonPagedPool, 
                                           numIrps * sizeof(SUB_CONTEXT));

    if(rwContext->SubContext == NULL) {

        IsoUsb_DbgPrint(1, ("Failed to alloc mem for SubContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        ExFreePool(rwContext);
        goto PerformFullSpeedIsochTransfer_Exit;
    }

    RtlZeroMemory(rwContext->SubContext, numIrps * sizeof(SUB_CONTEXT));

    rwContext->RWIrp = Irp;
    rwContext->Lock = 2;
    rwContext->NumIrps = numIrps;
    rwContext->IrpsPending = numIrps;
    rwContext->DeviceExtension = deviceExtension;
    KeInitializeSpinLock(&rwContext->SpinLock);
    //
    // save the rwContext pointer in the tail union.
    //
    Irp->Tail.Overlay.DriverContext[0] = (PVOID) rwContext;

    stackSize = deviceExtension->TopOfStackDeviceObject->StackSize + 1;
    virtualAddress = (PUCHAR) MmGetMdlVirtualAddress(Irp->MdlAddress);

    for(i = 0; i < numIrps; i++) {
    
        PIRP  subIrp;
        PURB  subUrb;
        PMDL  subMdl;
        ULONG nPackets;
        ULONG siz;
        ULONG offset;

        //
        // for every stage of transfer we need to do the following
        // tasks
        // 1. allocate an irp
        // 2. allocate an urb
        // 3. allocate a mdl.
        //
        // create a subsidiary irp
        //
        subIrp = IoAllocateIrp(stackSize, FALSE);

        if(subIrp == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context irp\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubIrp = subIrp;

        nPackets = (stageSize + packetSize - 1) / packetSize;

        IsoUsb_DbgPrint(3, ("nPackets = %d for Irp/URB pair %d\n", nPackets, i));

        ASSERT(nPackets <= 255);

        siz = GET_ISO_URB_SIZE(nPackets);

        //
        // create a subsidiary urb.
        //

        subUrb = (PURB) ExAllocatePool(NonPagedPool, siz);

        if(subUrb == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context urb\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        rwContext->SubContext[i].SubUrb = subUrb;

        //
        // allocate a mdl.
        //
        subMdl = IoAllocateMdl((PVOID) virtualAddress, 
                            stageSize,
                            FALSE,
                            FALSE,
                            NULL);

        if(subMdl == NULL) {

            IsoUsb_DbgPrint(1, ("failed to alloc mem for sub context mdl\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto PerformFullSpeedIsochTransfer_Free;
        }

        IoBuildPartialMdl(Irp->MdlAddress,
                          subMdl,
                          (PVOID) virtualAddress,
                          stageSize);

        rwContext->SubContext[i].SubMdl = subMdl;

        virtualAddress += stageSize;
        TotalLength -= stageSize;

        //
        // Initialize the subsidiary urb
        //
        RtlZeroMemory(subUrb, siz);

        subUrb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
        subUrb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
        subUrb->UrbIsochronousTransfer.PipeHandle = PipeInformation->PipeHandle;
        if(read) {

            IsoUsb_DbgPrint(3, ("read\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags = 
                                                     USBD_TRANSFER_DIRECTION_IN;
        }
        else {

            IsoUsb_DbgPrint(3, ("write\n"));
            subUrb->UrbIsochronousTransfer.TransferFlags =
                                                     USBD_TRANSFER_DIRECTION_OUT;
        }

        subUrb->UrbIsochronousTransfer.TransferBufferLength = stageSize;
        subUrb->UrbIsochronousTransfer.TransferBufferMDL = subMdl;

/*
        This is a way to set the start frame and NOT specify ASAP flag.

        subUrb->UrbIsochronousTransfer.StartFrame = 
                        IsoUsb_GetCurrentFrame(DeviceObject, Irp) + 
                        SOME_LATENCY;
*/
        // 
        // when the client driver sets the ASAP flag, it basically
        // guarantees that it will make data available to the HC
        // and that the HC should transfer it in the next transfer frame 
        // for the endpoint.(The HC maintains a next transfer frame
        // state variable for each endpoint). By resetting the pipe,
        // we make the pipe as virgin. If the data does not get to the HC
        // fast enough, the USBD_ISO_PACKET_DESCRIPTOR - Status is 
        // USBD_STATUS_BAD_START_FRAME on uhci. On ohci it is 0xC000000E.
        //

        subUrb->UrbIsochronousTransfer.TransferFlags |=
                                    USBD_START_ISO_TRANSFER_ASAP;

        subUrb->UrbIsochronousTransfer.NumberOfPackets = nPackets;
        subUrb->UrbIsochronousTransfer.UrbLink = NULL;

        //
        // set the offsets for every packet for reads/writes
        //
        if(read) {
            
            offset = 0;

            for(j = 0; j < nPackets; j++) {
            
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;
                subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = 0;

                if(stageSize > packetSize) {

                    offset += packetSize;
                    stageSize -= packetSize;
                }
                else {

                    offset += stageSize;
                    stageSize = 0;
                }
            }
        }
        else {

            offset = 0;

            for(j = 0; j < nPackets; j++) {

                subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset = offset;

                if(stageSize > packetSize) {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = packetSize;
                    offset += packetSize;
                    stageSize -= packetSize;
                }
                else {

                    subUrb->UrbIsochronousTransfer.IsoPacket[j].Length = stageSize;
                    offset += stageSize;
                    stageSize = 0;
                    ASSERT(offset == (subUrb->UrbIsochronousTransfer.IsoPacket[j].Length + 
                                      subUrb->UrbIsochronousTransfer.IsoPacket[j].Offset));
                }
            }
        }

        IoSetNextIrpStackLocation(subIrp);
        nextStack = IoGetCurrentIrpStackLocation(subIrp);

        nextStack->DeviceObject = DeviceObject;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.Others.Argument2 = (PVOID) subMdl;

        nextStack = IoGetNextIrpStackLocation(subIrp);
        nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;
        nextStack->Parameters.Others.Argument1 = (PVOID) subUrb;
        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                             IOCTL_INTERNAL_USB_SUBMIT_URB;

        IoSetCompletionRoutine(subIrp,
                               (PIO_COMPLETION_ROUTINE) IsoUsb_SinglePairComplete,
                               (PVOID) rwContext,
                               TRUE,
                               TRUE,
                               TRUE);

        if(TotalLength > (packetSize * 255)) {

            stageSize = packetSize * 255;
        }
        else {

            stageSize = TotalLength;
        }
    }

    //
    // while we were busy create subsidiary irp/urb pairs..
    // the main read/write irp may have been cancelled !!
    //

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    IoSetCancelRoutine(Irp, IsoUsb_CancelReadWrite);

    if(Irp->Cancel) {

        //
        // The Cancel flag for the Irp has been set. 
        //
        IsoUsb_DbgPrint(3, ("Cancel flag set\n"));

        ntStatus = STATUS_CANCELLED;

        if(IoSetCancelRoutine(Irp, NULL)) {

            //
            // But the I/O manager did not call our cancel routine.
            // we need to free the 1) irp, 2) urb and 3) mdl for every 
            // stage and complete the main Irp after releasing the lock
            //

            IsoUsb_DbgPrint(3, ("cancellation routine NOT run\n"));

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            goto PerformFullSpeedIsochTransfer_Free;
        }
        else {
            
            //
            // The cancel routine will resume the moment we release the lock.
            //
            for(j = 0; j < numIrps; j++) {

                if(rwContext->SubContext[j].SubUrb) {

                    ExFreePool(rwContext->SubContext[j].SubUrb);
                    rwContext->SubContext[j].SubUrb = NULL;
                }

                if(rwContext->SubContext[j].SubMdl) {

                    IoFreeMdl(rwContext->SubContext[j].SubMdl);
                    rwContext->SubContext[j].SubMdl = NULL;
                }
            }

            IoMarkIrpPending(Irp);

            //
            // it is the job of the cancellation routine to free
            // sub-context irps, release rwContext and complete 
            // the main readwrite irp
            //
            InterlockedDecrement(&rwContext->Lock);

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            return STATUS_PENDING;
        }
    }
    else {

        //
        // normal processing
        //

        IsoUsb_DbgPrint(3, ("normal processing\n"));

        IoMarkIrpPending(Irp);

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        for(j = 0; j < numIrps; j++) {

            IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::"));
            IsoUsb_IoIncrement(deviceExtension);
            
            IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                         rwContext->SubContext[j].SubIrp);
        }
        return STATUS_PENDING;
    }

PerformFullSpeedIsochTransfer_Free:

    for(j = 0; j < numIrps; j++) {

        if(rwContext->SubContext[j].SubIrp) {

            IoFreeIrp(rwContext->SubContext[j].SubIrp);
            rwContext->SubContext[j].SubIrp = NULL;
        }

        if(rwContext->SubContext[j].SubUrb) {

            ExFreePool(rwContext->SubContext[j].SubUrb);
            rwContext->SubContext[j].SubUrb = NULL;
        }

        if(rwContext->SubContext[j].SubMdl) {

            IoFreeMdl(rwContext->SubContext[j].SubMdl);
            rwContext->SubContext[j].SubMdl = NULL;
        }
    }

    ExFreePool(rwContext->SubContext);
    ExFreePool(rwContext);


PerformFullSpeedIsochTransfer_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("PerformFullSpeedIsochTransfer::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("-------------------------------\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_SinglePairComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for the subsidiary irp.

    For every irp/urb pair, we have allocated
    1. an irp
    2. an urb
    3. a mdl.

    Case 1:
    we do NOT free the irp on its completion
    we do free the urb and the mdl.

    Case 1 is executed in Block 3.

    Case 2:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If not, we free all the irps, release
    the subcontext and the context and complete the
    main Irp.we also free the urb and mdl for this
    stage.

    Case 2 is executed in Block 2.

    Case 3:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If yes, we atomically decrement the
    rwContext->Lock field. (the completion routine
    is in race with Cancel routine). If the count is 1, 
    the cancel routine will free all the resources.
    we do free the urb and mdl.

    it is expected of the cancellation routine to free 
    all the irps, free the subcontext and the context 
    and complete the main irp

    Case 3 is executed in Block 1b.

    Case 4:
    when we complete the last of the subsidiary irp,
    we check if the cancel routine for the main Irp
    has run. If yes, we atomically decrement the 
    rwContext->Lock field. (the completion routine
    is in race with Cancel routine). If the count is 0,
    we free the irp, subcontext and the context and
    complete the main irp. we also free the urb and
    the mdl for this particular stage.

    the reason we do not free the subsidiary irp at its
    completion is because the cancellation routine can
    run any time.

    Case 4 is executed in Block 1a.
    

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context for the completion routine

Return Value:

    NT status value

--*/
{
    PURB               urb;
    PMDL               mdl;
    PIRP               mainIrp;
    KIRQL              oldIrql;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PISOUSB_RW_CONTEXT rwContext;
    PIO_STACK_LOCATION irpStack;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    urb = (PURB) irpStack->Parameters.Others.Argument1;
    mdl = (PMDL) irpStack->Parameters.Others.Argument2;
    info = 0;
    ntStatus = Irp->IoStatus.Status;
    rwContext = (PISOUSB_RW_CONTEXT) Context;
    deviceExtension = rwContext->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete - begins\n"));

    ASSERT(rwContext);
    
    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    if(NT_SUCCESS(ntStatus) &&
       USBD_SUCCESS(urb->UrbHeader.Status)) {

        rwContext->NumXfer += 
                urb->UrbIsochronousTransfer.TransferBufferLength;

        IsoUsb_DbgPrint(1, ("rwContext->NumXfer = %d\n", rwContext->NumXfer));
    }
    else {
        
        ULONG i;

        IsoUsb_DbgPrint(1, ("read-write irp failed with status %X\n", ntStatus));
        IsoUsb_DbgPrint(1, ("urb header status %X\n", urb->UrbHeader.Status));

        for(i = 0; i < urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

            IsoUsb_DbgPrint(2, ("IsoPacket[%d].Length = %X IsoPacket[%d].Status = %X\n",
                                i,
                                urb->UrbIsochronousTransfer.IsoPacket[i].Length,
                                i,
                                urb->UrbIsochronousTransfer.IsoPacket[i].Status));
        }
    }

    if(InterlockedDecrement(&rwContext->IrpsPending) == 0) {

        IsoUsb_DbgPrint(3, ("no more irps pending\n"));

        if(NT_SUCCESS(ntStatus)) {
            
            ULONG i;
        
            IsoUsb_DbgPrint(1, ("urb start frame %X\n", 
                                urb->UrbIsochronousTransfer.StartFrame));

            for(i = 0; i < urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

                if(urb->UrbIsochronousTransfer.IsoPacket[i].Length == 0) {

                    IsoUsb_DbgPrint(2, ("IsoPacket[%d].Status = %X\n",
                                        i,
                                        urb->UrbIsochronousTransfer.IsoPacket[i].Status));
                }
            }
        }

        mainIrp = (PIRP) InterlockedExchangePointer(&rwContext->RWIrp, NULL);

        ASSERT(mainIrp);

        if(IoSetCancelRoutine(mainIrp, NULL) == NULL) {
            
            //
            // cancel routine has begun the race
            //
            // Block 1a.
            //
            IsoUsb_DbgPrint(3, ("cancel routine has begun the race\n"));

            if(InterlockedDecrement(&rwContext->Lock) == 0) {

                ULONG i;

                //
                // do the cleanup job ourselves
                //
                IsoUsb_DbgPrint(3, ("losers do the cleanup\n"));

                for(i = 0; i < rwContext->NumIrps; i++) {

                    IoFreeIrp(rwContext->SubContext[i].SubIrp);
                    rwContext->SubContext[i].SubIrp = NULL;
                }

                info = rwContext->NumXfer;

                KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

                ExFreePool(rwContext->SubContext);
                ExFreePool(rwContext);

                //
                // if we transferred some data, main Irp completes with success
                //

                IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

                IsoUsb_DbgPrint(1, ("***\n"));
                
                mainIrp->IoStatus.Status = STATUS_SUCCESS; // ntStatus;
                mainIrp->IoStatus.Information = info;
        
                IoCompleteRequest(mainIrp, IO_NO_INCREMENT);

                IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
                IsoUsb_IoDecrement(deviceExtension);

                IsoUsb_DbgPrint(3, ("-------------------------------\n"));

                goto IsoUsb_SinglePairComplete_Exit;
            }
            else {

                //
                // Block 1b.
                //

                IsoUsb_DbgPrint(3, ("cancel routine performs the cleanup\n"));
            }
        }
        else {

            //
            // Block 2.
            //

            ULONG i;

            IsoUsb_DbgPrint(3, ("cancel routine has NOT run\n"));

            for(i = 0; i < rwContext->NumIrps; i++) {

                IoFreeIrp(rwContext->SubContext[i].SubIrp);
                rwContext->SubContext[i].SubIrp = NULL;
            }

            info = rwContext->NumXfer;

            KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

            ExFreePool(rwContext->SubContext);
            ExFreePool(rwContext);

            //
            // if we transferred some data, main Irp completes with success
            //
            IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

            IsoUsb_DbgPrint(1, ("***\n"));
            
            mainIrp->IoStatus.Status = STATUS_SUCCESS; // ntStatus;
            mainIrp->IoStatus.Information = info;
        
            IoCompleteRequest(mainIrp, IO_NO_INCREMENT);

            IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
            IsoUsb_IoDecrement(deviceExtension);

            IsoUsb_DbgPrint(3, ("-------------------------------\n"));

            goto IsoUsb_SinglePairComplete_Exit;
        }
    }

    KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

IsoUsb_SinglePairComplete_Exit:

    //
    // Block 3.
    //

    ExFreePool(urb);
    IoFreeMdl(mdl);

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_SinglePairComplete - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
IsoUsb_CancelReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This is the cancellation routine for the main read/write Irp.
    The policy is as follows:

    If the cancellation routine is the last to decrement
    rwContext->Lock, then free the irps, subcontext and
    the context. Complete the main irp
    
    Otherwise, call IoCancelIrp on each of the subsidiary irp.
    It is valid to call IoCancelIrp on irps for which the 
    completion routine has executed, because, we do not free the
    irps in the completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None

--*/
{
    PIRP               mainIrp;
    KIRQL              oldIrql;
    ULONG              i;
    ULONG              info;
    PDEVICE_EXTENSION  deviceExtension;
    PISOUSB_RW_CONTEXT rwContext;

    //
    // initialize vars
    //
    info = 0;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite - begins\n"));

    rwContext = (PISOUSB_RW_CONTEXT) Irp->Tail.Overlay.DriverContext[0];
    ASSERT(rwContext);
    deviceExtension = rwContext->DeviceExtension;

    KeAcquireSpinLock(&rwContext->SpinLock, &oldIrql);

    if(InterlockedDecrement(&rwContext->Lock)) {

        IsoUsb_DbgPrint(3, ("about to cancel sub context irps..\n"));

        for(i = 0; i < rwContext->NumIrps; i++) {

            if(rwContext->SubContext[i].SubIrp) {

                IoCancelIrp(rwContext->SubContext[i].SubIrp);
            }
        }

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite - ends\n"));

        return;
    }
    else {

        ULONG i;

        for(i = 0; i < rwContext->NumIrps; i++) {

            IoFreeIrp(rwContext->SubContext[i].SubIrp);
            rwContext->SubContext[i].SubIrp = NULL;
        }

        mainIrp = (PIRP) InterlockedExchangePointer(&rwContext->RWIrp, NULL);

        info = rwContext->NumXfer;

        KeReleaseSpinLock(&rwContext->SpinLock, oldIrql);

        ExFreePool(rwContext->SubContext);
        ExFreePool(rwContext);

        //
        // if we transferred some data, main Irp completes with success
        //

        IsoUsb_DbgPrint(1, ("Total data transferred = %X\n", info));

        IsoUsb_DbgPrint(1, ("***\n"));

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Status = info;
/*        
        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;
*/
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IsoUsb_DbgPrint(3, ("IsoUsb_CancelReadWrite::"));
        IsoUsb_IoDecrement(deviceExtension);

        IsoUsb_DbgPrint(3, ("-------------------------------\n"));

        return;
    }
}

ULONG
IsoUsb_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine send an irp/urb pair with
    function code URB_FUNCTION_GET_CURRENT_FRAME_NUMBER
    to fetch the current frame

Arguments:

    DeviceObject - pointer to device object
    PIRP - I/O request packet

Return Value:

    Current frame

--*/
{
    KEVENT                               event;
    PDEVICE_EXTENSION                    deviceExtension;
    PIO_STACK_LOCATION                   nextStack;
    struct _URB_GET_CURRENT_FRAME_NUMBER urb;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // initialize the urb
    //

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame - begins\n"));

    urb.Hdr.Function = URB_FUNCTION_GET_CURRENT_FRAME_NUMBER;
    urb.Hdr.Length = sizeof(urb);
    urb.FrameNumber = (ULONG) -1;

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = (PVOID) &urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine(Irp,
                           IsoUsb_StopCompletion,
                           &event,
                           TRUE,
                           TRUE,
                           TRUE);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame::"));
    IsoUsb_IoIncrement(deviceExtension);

    IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                 Irp);

    KeWaitForSingleObject((PVOID) &event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_GetCurrentFrame - ends\n"));

    return urb.FrameNumber;
}

NTSTATUS
IsoUsb_StopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine for request to retrieve the frame number

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - context passed to the completion routine

Return Value:

    NT status value

--*/
{
    PKEVENT event;

    IsoUsb_DbgPrint(3, ("IsoUsb_StopCompletion - begins\n"));

    event = (PKEVENT) Context;

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    IsoUsb_DbgPrint(3, ("IsoUsb_StopCompletion - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isodev.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isodev.c

Abstract:

    This file contains dispatch routines 
    for create and close. This file also 
    contains routines to selectively suspend 
    the device. The selective suspend feature
    is usb specific and not hardware specific.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isousr.h"
#include "isowmi.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{

    LONG                        i;
    NTSTATUS                    ntStatus;
    PFILE_OBJECT                fileObject;
    PDEVICE_EXTENSION           deviceExtension;
    PIO_STACK_LOCATION          irpStack;
    PFILE_OBJECT_CONTENT        fileObjectContent;
    PUSBD_INTERFACE_INFORMATION interface;


    i = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchCreate - begins\n"));

    if(deviceExtension->DeviceState != Working) {

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchCreate_Exit;
    }

    if(deviceExtension->UsbInterface) {
    
        interface = deviceExtension->UsbInterface;    
    }
    else {

        IsoUsb_DbgPrint(1, ("UsbInterface not found\n"));

        ntStatus = STATUS_INVALID_DEVICE_STATE;
        goto IsoUsb_DispatchCreate_Exit;
    }

    if(fileObject) {
        
        fileObject->FsContext = NULL;
    }
    else {

        ntStatus = STATUS_INVALID_PARAMETER;
        goto IsoUsb_DispatchCreate_Exit;
    }

    fileObject->FsContext = ExAllocatePool(NonPagedPool,
                                           sizeof(FILE_OBJECT_CONTENT));

    if(NULL == fileObject->FsContext) {

        IsoUsb_DbgPrint(1, ("failed to alloc memory for FILE_OBJECT_CONTENT\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto IsoUsb_DispatchCreate_Exit;
    }

    fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;
    fileObjectContent->PipeInformation = NULL;
    fileObjectContent->StreamInformation = NULL;

    if(0 != fileObject->FileName.Length) {

        i = IsoUsb_ParseStringForPipeNumber(&fileObject->FileName);

        IsoUsb_DbgPrint(3, ("create request for pipe # %X\n", i));

        if((i < 0) || 
           (i >= (LONG)(deviceExtension->UsbInterface->NumberOfPipes))) {
    
            ntStatus = STATUS_INVALID_PARAMETER;

            IsoUsb_DbgPrint(1, ("invalid pipe number\n"));
            ExFreePool(fileObject->FsContext);
            fileObject->FsContext = NULL;
            goto IsoUsb_DispatchCreate_Exit;
        }

        fileObjectContent->PipeInformation = (PVOID) &interface->Pipes[i];
    }

    ntStatus = STATUS_SUCCESS;

    InterlockedIncrement(&deviceExtension->OpenHandleCount);
        
    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since we just received an open handle request, cancel idle req.
    //
    if(deviceExtension->SSEnable) {
    
        CancelSelectSuspend(deviceExtension);
    }

IsoUsb_DispatchCreate_Exit:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
IsoUsb_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS             ntStatus;
    PFILE_OBJECT         fileObject;
    PDEVICE_EXTENSION    deviceExtension;
    PIO_STACK_LOCATION   irpStack;
    PFILE_OBJECT_CONTENT fileObjectContent;
    
    PAGED_CODE();

    //
    // initialize variables
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    
    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClose - begins\n"));

    if(fileObject && fileObject->FsContext) {

        fileObjectContent = (PFILE_OBJECT_CONTENT) fileObject->FsContext;

        ASSERT(NULL == fileObjectContent->StreamInformation);

        ExFreePool(fileObjectContent);

        fileObject->FsContext = NULL;
    }

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PFILE_OBJECT       fileObject;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if(deviceExtension->DeviceState != Working) {

        IsoUsb_DbgPrint(1, ("Invalid device state\n"));

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = info;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchDevCtrl::"));
    IsoUsb_IoIncrement(deviceExtension);

    //
    // make sure that the selective suspend request has been completed.
    //
    if(deviceExtension->SSEnable) {

        //
        // It is true that the client driver cancelled the selective suspend
        // request in the dispatch routine for create.
        // But there is no guarantee that it has indeed been completed.
        // so wait on the NoIdleReqPendEvent and proceed only if this event
        // is signalled.
        //
        IsoUsb_DbgPrint(3, ("Waiting on the IdleReqPendEvent\n"));
        
        KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
    }

    switch(code) {

    case IOCTL_ISOUSB_RESET_PIPE:
    {
        PUSBD_PIPE_INFORMATION pipe;

        pipe = NULL;

        if(fileObject && fileObject->FsContext) {
            
            pipe = (PUSBD_PIPE_INFORMATION)
                   ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->PipeInformation;
        }

        if(pipe == NULL) {

            ntStatus = STATUS_INVALID_PARAMETER;
        }
        else {
            
            ntStatus = IsoUsb_ResetPipe(DeviceObject, pipe);
        }

        break;
    }

    case IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR:
    {
        ULONG length;

        if(deviceExtension->UsbConfigurationDescriptor) {

            length = deviceExtension->UsbConfigurationDescriptor->wTotalLength;

            if(outputBufferLength >= length) {

                RtlCopyMemory(ioBuffer,
                              deviceExtension->UsbConfigurationDescriptor,
                              length);

                info = length;

                ntStatus = STATUS_SUCCESS;
            }
            else {
                
                ntStatus = STATUS_INVALID_BUFFER_SIZE;
            }
        }
        else {
            
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    case IOCTL_ISOUSB_RESET_DEVICE:
        
        ntStatus = IsoUsb_ResetDevice(DeviceObject);

        break;

    case IOCTL_ISOUSB_START_ISO_STREAM:

        ntStatus = IsoUsb_StartIsoStream(DeviceObject, Irp);

        return STATUS_SUCCESS;

    case IOCTL_ISOUSB_STOP_ISO_STREAM:
    {
           
        PFILE_OBJECT_CONTENT fileObjectContent;
        
        if(fileObject && fileObject->FsContext) {

            fileObjectContent = (PFILE_OBJECT_CONTENT)
                                fileObject->FsContext;

            ntStatus = IsoUsb_StopIsoStream(
                            DeviceObject,
                            InterlockedExchangePointer(
                                &fileObjectContent->StreamInformation,
                                NULL),
                            Irp);
        }
        else {

            ntStatus = STATUS_UNSUCCESSFUL;
        }

        break;
    }

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchDevCtrl::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

LONG
IsoUsb_ParseStringForPipeNumber(
    IN PUNICODE_STRING PipeName
    )
/*++
 
Routine Description:

    This routine parses the PipeName for the Pipe#

Arguments:

    PipeName - Unicode string for the pipe name

Return Value:

    Pipe number

--*/
{
    LONG  bufferIndex;
    ULONG uval;
    ULONG umultiplier;

    if(PipeName->Length == 0) {

        return -1;
    }

    bufferIndex = (PipeName->Length / sizeof(WCHAR)) - 1;

    while((bufferIndex > -1) && 
          ((PipeName->Buffer[bufferIndex] < (WCHAR) '0')  ||
           (PipeName->Buffer[bufferIndex] > (WCHAR) '9')))           {
        
        bufferIndex--;
    }

    if(bufferIndex > -1) {

        uval = 0;
        umultiplier = 1;

        while((bufferIndex > -1) &&
              (PipeName->Buffer[bufferIndex] >= (WCHAR) '0') &&
              (PipeName->Buffer[bufferIndex] <= (WCHAR) '9'))        {

            uval += (umultiplier *
                     (ULONG) (PipeName->Buffer[bufferIndex] - (WCHAR) '0'));
            bufferIndex--;
            umultiplier *= 10;
        }

        return uval;
    }

    return -1;
}

NTSTATUS
IsoUsb_ResetPipe(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInfo
    )
/*++
 
Routine Description:

    This routine submits an irp/urb pair synchronously
    with function code URB_FUNCTION_RESET_PIPE to reset
    the pipe

Arguments:

    DeviceObject - pointer to device object
    PipeInfo - pointer to USBD_PIPE_INFORMATION

Return Value:

    NT status value

--*/
{
    PURB              urb;
    NTSTATUS          ntStatus;
    USBD_STATUS       usbdStatus;
    PDEVICE_EXTENSION deviceExtension;

    //
    // initialize variables
    //

    urb = NULL;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;


    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_PIPE_REQUEST));

    if(urb) {

        urb->UrbHeader.Length = (USHORT) sizeof(struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle = PipeInfo->PipeHandle;

        ntStatus = CallUSBD(DeviceObject, urb);

        usbdStatus = urb->UrbHeader.Status;

        ExFreePool(urb);
    }
    else {

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(NT_SUCCESS(ntStatus) &&
       USBD_SUCCESS(usbdStatus)) {
    
        IsoUsb_DbgPrint(3, ("IsoUsb_ResetPipe - success\n"));
        ntStatus = STATUS_SUCCESS;
    }
    else {

        IsoUsb_DbgPrint(1, ("IsoUsb_ResetPipe - failed with "
                            "Irp status = %X and Urb status = %X\n",
                            ntStatus,
                            usbdStatus));
    }

    return ntStatus;
}

NTSTATUS
IsoUsb_ResetDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine resets the device

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS ntStatus;
    ULONG    portStatus;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetDevice - begins\n"));

    ntStatus = IsoUsb_GetPortStatus(DeviceObject, &portStatus);

    if((NT_SUCCESS(ntStatus))                 &&
       (!(portStatus & USBD_PORT_ENABLED))    &&
       (portStatus & USBD_PORT_CONNECTED)) {

        ntStatus = IsoUsb_ResetParentPort(DeviceObject);
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_GetPortStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PULONG     PortStatus
    )
/*++
 
Routine Description:

    This routine fetches the port status value

Arguments:

    DeviceObject - pointer to device object
    PortStatus - pointer to ULONG to contain the status value

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    *PortStatus = 0;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_GET_PORT_STATUS,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    nextStack->Parameters.Others.Argument1 = PortStatus;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus::"));
    IsoUsb_IoDecrement(deviceExtension);

    ntStatus = ioStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_GetPortStatus - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine will submit an IOCTL_INTERNAL_USB_RESET_PORT,
    down the stack

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    KEVENT             event;
    PIRP               irp;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort - begins\n"));

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_RESET_PORT,
                    deviceExtension->TopOfStackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE,
                    &event,
                    &ioStatus);

    if(NULL == irp) {

        IsoUsb_DbgPrint(1, ("memory alloc for irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);

    ASSERT(nextStack != NULL);

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(STATUS_PENDING == ntStatus) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }
    else {

        ioStatus.Status = ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort"));
    IsoUsb_IoDecrement(deviceExtension);

    ntStatus = ioStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_ResetParentPort - ends\n"));

    return ntStatus;
}


NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    IsoUsb_DbgPrint(3, ("SubmitIdleRequest - begins\n"));

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;
        goto SubmitIdleRequestIrp_Exit;
    }

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        IsoUsb_DbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;
        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            IsoUsb_DbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;
        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // device cannot suspend - abort.
            // also irps created using IoAllocateIrp 
            // needs to be deallocated.
            //
     
            IsoUsb_DbgPrint(1, ("Device is not idle\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //

            if(irp) {
            
                IoFreeIrp(irp);
            }

            goto SubmitIdleRequestIrp_Exit;
        }

        IsoUsb_DbgPrint(3, ("Cancel the timers\n"));

        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            IsoUsb_DbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        IsoUsb_DbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    IsoUsb_DbgPrint(3, ("SubmitIdleRequest - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    IsoUsb_DbgPrint(3, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        IsoUsb_DbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        IsoUsb_DbgPrint(3, ("IdleNotificationCallback::"));
        IsoUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        if(STATUS_PENDING == ntStatus) {

            IsoUsb_DbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }
    
    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    IsoUsb_DbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    PIRP                    idleIrp;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    IsoUsb_DbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //

    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        IsoUsb_DbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            IsoUsb_DbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            IsoUsb_DbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            IsoUsb_DbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            IsoUsb_DbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            IsoUsb_DbgPrint(1, ("default\n"));

            break;
        }

        //
        // if in error, issue a SetD0
        //

        IsoUsb_DbgPrint(3, ("IdleNotificationRequestComplete::"));
        IsoUsb_IoIncrement(DeviceExtension);

        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                          DeviceExtension, 
                          NULL);

        if(!NT_SUCCESS(ntStatus)) {
    
            IsoUsb_DbgPrint(1, ("PoRequestPowerIrp failed\n"));
        }

    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                        &DeviceExtension->PendingIdleIrp,
                                        NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since we allocated the irp, we need to free it.
    // return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not touch it.
    //

    if(idleIrp) {

        IsoUsb_DbgPrint(3, ("completion routine has a valid irp and frees it\n"));

        IoFreeIrp(Irp);

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            IsoUsb_DbgPrint(3, ("completion routine frees the irp\n"));
            
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        IsoUsb_DbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        IsoUsb_DbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    IsoUsb_DbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        IsoUsb_DbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //
    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        
        if(IoCancelIrp(irp)) {

            IsoUsb_DbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            IsoUsb_DbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //

        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            IsoUsb_DbgPrint(3, ("CancelSelectSuspend frees the irp\n"));
            
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    IsoUsb_DbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        IsoUsb_DbgPrint(3, ("PoIrpCompletionFunc::"));
        IsoUsb_IoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

  Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    IsoUsb_DbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    IsoUsb_IoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    IsoUsb_DbgPrint(3, ("WWIrpCompletionFunc::"));
    IsoUsb_IoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isorwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isorwr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_RWR_H
#define _ISOUSB_RWR_H

typedef struct _SUB_CONTEXT {

    PIRP SubIrp;
    PURB SubUrb;
    PMDL SubMdl;

} SUB_CONTEXT, *PSUB_CONTEXT;

typedef struct _ISOUSB_RW_CONTEXT {

    PIRP              RWIrp;
    ULONG             Lock;
    ULONG             NumXfer;
    ULONG             NumIrps;
    ULONG             IrpsPending;
    KSPIN_LOCK        SpinLock;
    PDEVICE_EXTENSION DeviceExtension;
    PSUB_CONTEXT      SubContext;

} ISOUSB_RW_CONTEXT, * PISOUSB_RW_CONTEXT;

NTSTATUS
IsoUsb_SinglePairComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

VOID
IsoUsb_CancelReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

ULONG
IsoUsb_GetCurrentFrame(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_StopCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_DispatchReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
PerformFullSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    );

NTSTATUS
PerformHighSpeedIsochTransfer(
    IN PDEVICE_OBJECT         DeviceObject,
    IN PUSBD_PIPE_INFORMATION PipeInformation,
    IN PIRP                   Irp,
    IN ULONG                  TotalLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isostrm.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isostrm.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_STRM_H
#define _ISOUSB_STRM_H

#define ISOUSB_MAX_IRP                  2
#define ISOCH_IN_PIPE_INDEX             4
#define ISOCH_OUT_PIPE_INDEX            5

typedef struct _ISOUSB_STREAM_OBJECT {

    // number of pending irps for this stream
    ULONG PendingIrps;

    // event signaled when no irps pending
    KEVENT NoPendingIrpEvent;
    
    PDEVICE_OBJECT DeviceObject;

    PUSBD_PIPE_INFORMATION PipeInformation;

    struct _ISOUSB_TRANSFER_OBJECT *TransferObjectList[ISOUSB_MAX_IRP];

} ISOUSB_STREAM_OBJECT, *PISOUSB_STREAM_OBJECT;

typedef struct _ISOUSB_TRANSFER_OBJECT {

    PIRP Irp;

    PURB Urb;

    PUCHAR DataBuffer;

    //
    // statistics.
    //
    ULONG TimesRecycled;

    ULONG TotalPacketsProcessed;

    ULONG TotalBytesProcessed;

    ULONG ErrorPacketCount;

    PISOUSB_STREAM_OBJECT StreamObject;

} ISOUSB_TRANSFER_OBJECT, *PISOUSB_TRANSFER_OBJECT;


NTSTATUS
IsoUsb_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_StartTransfer(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN ULONG                 Index
    );

NTSTATUS
IsoUsb_InitializeStreamUrb(
    IN PDEVICE_OBJECT          DeviceObject,
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    );

NTSTATUS
IsoUsb_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
IsoUsb_ProcessTransfer(
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    );

NTSTATUS
IsoUsb_StopIsoStream(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PIRP                  Irp
    );

NTSTATUS
IsoUsb_StreamObjectCleanup(
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PDEVICE_EXTENSION     DeviceExtension
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isousr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_USER_H
#define _ISOUSB_USER_H

#include <initguid.h>

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_CLASS_I82930_ISO, 
0xa1155b78, 0xa32c, 0x11d1, 0x9a, 0xed, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x8);


#define ISOUSB_IOCTL_INDEX              0x0000


#define IOCTL_ISOUSB_GET_CONFIG_DESCRIPTOR  CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX,      \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)
                                                   
#define IOCTL_ISOUSB_RESET_DEVICE           CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 1,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_RESET_PIPE             CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 2,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_STOP_ISO_STREAM        CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 3,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#define IOCTL_ISOUSB_START_ISO_STREAM       CTL_CODE(FILE_DEVICE_UNKNOWN,     \
                                                     ISOUSB_IOCTL_INDEX + 4,  \
                                                     METHOD_BUFFERED,         \
                                                     FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isostrm.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isostrm.c

Abstract:

    This file has routines for stream transfers.
    Stream transfers are initiated and stopped using
    the IOCTLs exposed by this driver.
    The stream transfer information is contained in 
    ISOUSB_STREAM_OBJECT structure which is securely
    placed in the FileObject. The ISOUSB_STREAM_OBJECT 
    structure has links to ISOUSB_TRANSFER_OBJECT 
    (each TRANSFER_OBJECT corresponds to the number of 
    irp/urb pair circulating).
    So if the user-mode app simply crashes or aborts or 
    does not terminate, we can cleanly abort the stream
    transfers.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isousr.h"
#include "isowmi.h"
#include "isorwr.h"
#include "isostrm.h"

NTSTATUS
IsoUsb_StartIsoStream(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine create a single stream object and
    invokes StartTransfer for ISOUSB_MAX_IRP number of 
    times.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG                  i;
    ULONG                  info;
    ULONG                  inputBufferLength;
    ULONG                  outputBufferLength;
    NTSTATUS               ntStatus;
    PFILE_OBJECT           fileObject;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_STACK_LOCATION     irpStack;
    PISOUSB_STREAM_OBJECT  streamObject;
    PUSBD_PIPE_INFORMATION pipeInformation;

    info = 0;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    fileObject = irpStack->FileObject;
    streamObject = NULL;
    pipeInformation = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    inputBufferLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream - begins\n"));

    streamObject = ExAllocatePool(NonPagedPool, 
                                  sizeof(struct _ISOUSB_STREAM_OBJECT));

    if(streamObject == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for streamObject\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto IsoUsb_StartIsoStream_Exit;
    }

    RtlZeroMemory(streamObject, sizeof(ISOUSB_STREAM_OBJECT));

    //
    // The Isoch IN pipe for the board is the 5th pipe
    //
    pipeInformation = &(deviceExtension->UsbInterface->Pipes[ISOCH_IN_PIPE_INDEX]);

    // reset the pipe
    //
    IsoUsb_ResetPipe(DeviceObject, pipeInformation);
    
    streamObject->DeviceObject = DeviceObject;
    streamObject->PipeInformation = pipeInformation;

    KeInitializeEvent(&streamObject->NoPendingIrpEvent,
                      NotificationEvent,
                      FALSE);

    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        ntStatus = IsoUsb_StartTransfer(DeviceObject,
                                        streamObject,
                                        i);

        if(!NT_SUCCESS(ntStatus)) {
         
            //
            // we continue sending transfer object irps..
            //
            
            IsoUsb_DbgPrint(1, ("IsoUsb_StartTransfer [%d] - failed\n", i));

            if(ntStatus == STATUS_INSUFFICIENT_RESOURCES) {
                
                ASSERT(streamObject->TransferObjectList[i] == NULL);
            }
        }
    }

    if(fileObject && fileObject->FsContext) {
        
        if(streamObject->PendingIrps) {

            ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->StreamInformation 
                                                                = streamObject;
        }
        else {

            IsoUsb_DbgPrint(1, ("no transfer object irp sent..abort..\n"));
            ExFreePool(streamObject);
            ((PFILE_OBJECT_CONTENT)fileObject->FsContext)->StreamInformation = NULL;
        }
    }

IsoUsb_StartIsoStream_Exit:

    Irp->IoStatus.Information = info;
    Irp->IoStatus.Status = ntStatus;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream::"));
    IsoUsb_IoDecrement(deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartIsoStream - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_StartTransfer(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN ULONG                 Index
    )
/*++
 
Routine Description:

    This routine creates a transfer object for each irp/urb pair.
    After initializing the pair, it sends the irp down the stack.

Arguments:

    DeviceObject - pointer to device object.
    StreamObject - pointer to stream object
    Index - index into the transfer object table in stream object

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    CCHAR                   stackSize;
    ULONG                   packetSize;
    ULONG                   maxXferSize;
    ULONG                   numPackets;
    NTSTATUS                ntStatus;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      nextStack;
    PISOUSB_TRANSFER_OBJECT transferObject;

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    maxXferSize = StreamObject->PipeInformation->MaximumTransferSize;
    packetSize = StreamObject->PipeInformation->MaximumPacketSize;
    numPackets = maxXferSize / packetSize;

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer - begins\n"));

    transferObject = ExAllocatePool(NonPagedPool,
                                    sizeof(struct _ISOUSB_TRANSFER_OBJECT));

    if(transferObject == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for transferObject\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(transferObject,
                  sizeof(struct _ISOUSB_TRANSFER_OBJECT));


    transferObject->StreamObject = StreamObject;
    
    stackSize = (CCHAR) (deviceExtension->TopOfStackDeviceObject->StackSize + 1);

    irp = IoAllocateIrp(stackSize, FALSE);

    if(irp == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for irp\n"));

        ExFreePool(transferObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    transferObject->Irp = irp;

    transferObject->DataBuffer = ExAllocatePool(NonPagedPool,
                                                maxXferSize);

    if(transferObject->DataBuffer == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for DataBuffer\n"));

        ExFreePool(transferObject);
        IoFreeIrp(irp);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    transferObject->Urb = ExAllocatePool(NonPagedPool,
                                         GET_ISO_URB_SIZE(numPackets));

    if(transferObject->Urb == NULL) {

        IsoUsb_DbgPrint(1, ("failed to alloc mem for Urb\n"));

        ExFreePool(transferObject->DataBuffer);
        IoFreeIrp(irp);
        ExFreePool(transferObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IsoUsb_InitializeStreamUrb(DeviceObject, transferObject);

    StreamObject->TransferObjectList[Index] = transferObject;
    InterlockedIncrement(&StreamObject->PendingIrps);

    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->Parameters.Others.Argument1 = transferObject->Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                   IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(irp, 
                           IsoUsb_IsoIrp_Complete,
                           transferObject,
                           TRUE,
                           TRUE,
                           TRUE);

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            irp);

    if(NT_SUCCESS(ntStatus)) {

        ntStatus = STATUS_SUCCESS;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_StartTransfer - ends\n"));

    return ntStatus;
}


NTSTATUS
IsoUsb_InitializeStreamUrb(
    IN PDEVICE_OBJECT          DeviceObject,
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    )
/*++
 
Routine Description:

    This routine initializes the irp/urb pair in the transfer object.

Arguments:

    DeviceObject - pointer to device object
    TransferObject - pointer to transfer object

Return Value:

    NT status value

--*/
{
    PURB                  urb;
    ULONG                 i;
    ULONG                 siz;
    ULONG                 packetSize;
    ULONG                 numPackets;
    ULONG                 maxXferSize;
    PISOUSB_STREAM_OBJECT streamObject;

    urb = TransferObject->Urb;
    streamObject = TransferObject->StreamObject;
    maxXferSize = streamObject->PipeInformation->MaximumTransferSize;
    packetSize = streamObject->PipeInformation->MaximumPacketSize;
    numPackets = maxXferSize / packetSize;

    IsoUsb_DbgPrint(3, ("IsoUsb_InitializeStreamUrb - begins\n"));

    if(numPackets > 255) {

        numPackets = 255;
        maxXferSize = packetSize * numPackets;
    }

    siz = GET_ISO_URB_SIZE(numPackets);

    RtlZeroMemory(urb, siz);

    urb->UrbIsochronousTransfer.Hdr.Length = (USHORT) siz;
    urb->UrbIsochronousTransfer.Hdr.Function = URB_FUNCTION_ISOCH_TRANSFER;
    urb->UrbIsochronousTransfer.PipeHandle =
                                streamObject->PipeInformation->PipeHandle;

    urb->UrbIsochronousTransfer.TransferFlags = USBD_TRANSFER_DIRECTION_IN;

    urb->UrbIsochronousTransfer.TransferBufferMDL = NULL;
    urb->UrbIsochronousTransfer.TransferBuffer = TransferObject->DataBuffer;
    urb->UrbIsochronousTransfer.TransferBufferLength = numPackets * packetSize;

    urb->UrbIsochronousTransfer.TransferFlags |= USBD_START_ISO_TRANSFER_ASAP;

    urb->UrbIsochronousTransfer.NumberOfPackets = numPackets;
    urb->UrbIsochronousTransfer.UrbLink = NULL;

    for(i=0; i<urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        urb->UrbIsochronousTransfer.IsoPacket[i].Offset = i * packetSize;

        //
        // For input operation, length is set to whatever the device supplies.
        //
        urb->UrbIsochronousTransfer.IsoPacket[i].Length = 0;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_InitializeStreamUrb - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_IsoIrp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the completion routine of the irp in the irp/urb pair
    passed down the stack for stream transfers.

    If the transfer was cancelled or the device yanked out, then we
    release resources, dump the statistics and return 
    STATUS_MORE_PROCESSING_REQUIRED, so that the cleanup module can
    free the irp.

    otherwise, we reinitialize the transfers and continue recirculaiton 
    of the irps.

Arguments:

    DeviceObject - pointer to device object below us.
    Irp - I/O completion routine.
    Context - context passed to the completion routine

Return Value:

--*/
{
    NTSTATUS                ntStatus;
    PDEVICE_OBJECT          deviceObject;
    PDEVICE_EXTENSION       deviceExtension;
    PIO_STACK_LOCATION      nextStack;
    PISOUSB_STREAM_OBJECT   streamObject;
    PISOUSB_TRANSFER_OBJECT transferObject;

    transferObject = (PISOUSB_TRANSFER_OBJECT) Context;
    streamObject = transferObject->StreamObject;
    deviceObject = streamObject->DeviceObject;
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - begins\n"));

    ntStatus = IsoUsb_ProcessTransfer(transferObject);

    if((ntStatus == STATUS_CANCELLED) ||
       (ntStatus == STATUS_DEVICE_NOT_CONNECTED)) {
    
        IsoUsb_DbgPrint(3, ("Isoch irp cancelled/device removed\n"));

        //
        // this is the last irp to complete with this erroneous value
        // signal an event and return STATUS_MORE_PROCESSING_REQUIRED
        //
        if(InterlockedDecrement(&streamObject->PendingIrps) == 0) {

            KeSetEvent(&streamObject->NoPendingIrpEvent,
                       1,
                       FALSE);

            IsoUsb_DbgPrint(3, ("-----------------------------\n"));
        }

        IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete::"));
        IsoUsb_IoDecrement(deviceExtension);

        transferObject->Irp = NULL;
        IoFreeIrp(Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // otherwise circulate the irps.
    //

    IsoUsb_InitializeStreamUrb(deviceObject, transferObject);

    nextStack = IoGetNextIrpStackLocation(Irp);
    nextStack->Parameters.Others.Argument1 = transferObject->Urb;
    nextStack->Parameters.DeviceIoControl.IoControlCode = 
                                                IOCTL_INTERNAL_USB_SUBMIT_URB;
    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    IoSetCompletionRoutine(Irp,
                           IsoUsb_IsoIrp_Complete,
                           transferObject,
                           TRUE,
                           TRUE,
                           TRUE);

    transferObject->TimesRecycled++;

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject,
                            Irp);

    IsoUsb_DbgPrint(3, ("IsoUsb_IsoIrp_Complete - ends\n"));
    IsoUsb_DbgPrint(3, ("-----------------------------\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
IsoUsb_ProcessTransfer(
    IN PISOUSB_TRANSFER_OBJECT TransferObject
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine to check the status
    of the irp, urb and the isochronous packets.

    updates statistics

Arguments:

    TranferObject - pointer to transfer object for the irp/urb pair which completed.

Return Value:

    NT status value

--*/
{
    PIRP        irp;
    PURB        urb;
    ULONG       i;
    NTSTATUS    ntStatus;
    USBD_STATUS usbdStatus;

    irp = TransferObject->Irp;
    urb = TransferObject->Urb;
    ntStatus = irp->IoStatus.Status;

    IsoUsb_DbgPrint(3, ("IsoUsb_ProcessTransfer - begins\n"));

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(3, ("Isoch irp failed with status = %X\n", ntStatus));
    }

    usbdStatus = urb->UrbHeader.Status;

    if(!USBD_SUCCESS(usbdStatus)) {

        IsoUsb_DbgPrint(3, ("urb failed with status = %X\n", usbdStatus));
    }

    //
    // check each of the urb packets
    //
    for(i = 0; i < urb->UrbIsochronousTransfer.NumberOfPackets; i++) {

        TransferObject->TotalPacketsProcessed++;

        usbdStatus = urb->UrbIsochronousTransfer.IsoPacket[i].Status;

        if(!USBD_SUCCESS(usbdStatus)) {

//            IsoUsb_DbgPrint(3, ("Iso packet %d failed with status = %X\n", i, usbdStatus));
            
            TransferObject->ErrorPacketCount++;
        }
        else {
            
            TransferObject->TotalBytesProcessed += urb->UrbIsochronousTransfer.IsoPacket[i].Length;
        }
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_ProcessTransfer - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_StopIsoStream(
    IN PDEVICE_OBJECT        DeviceObject,
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PIRP                  Irp
    )
/*++
 
Routine Description:

    This routine is invoked from the IOCTL to stop the stream transfers.

Arguments:

    DeviceObject - pointer to device object
    StreamObject - pointer to stream object
    Irp - pointer to Irp

Return Value:

    NT status value

--*/
{
    ULONG              i;
    KIRQL              oldIrql;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize vars
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, ("IsoUsb_StopIsoStream - begins\n"));

    if((StreamObject == NULL) ||
       (StreamObject->DeviceObject != DeviceObject)) {

        IsoUsb_DbgPrint(1, ("invalid streamObject\n"));
        return STATUS_INVALID_PARAMETER;
    }

    IsoUsb_StreamObjectCleanup(StreamObject, deviceExtension);

    IsoUsb_DbgPrint(3, ("IsoUsb_StopIsoStream - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_StreamObjectCleanup(
    IN PISOUSB_STREAM_OBJECT StreamObject,
    IN PDEVICE_EXTENSION     DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked either when the user-mode app passes an IOCTL to
    abort stream transfers or when the the cleanup dispatch routine is run.
    It is guaranteed to run only once for every stream transfer.

Arguments:

    StreamObject - StreamObject corresponding to stream transfer which
    needs to be aborted.

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    ULONG                   i;
    ULONG                   timesRecycled;
    ULONG                   totalPacketsProcessed;
    ULONG                   totalBytesProcessed;
    ULONG                   errorPacketCount;
    PISOUSB_TRANSFER_OBJECT xferObject;

    //
    // initialize the variables
    //
    timesRecycled = 0;
    totalPacketsProcessed = 0;
    totalBytesProcessed = 0;
    errorPacketCount = 0;

    //
    // cancel transferobject irps/urb pair
    // safe to touch these irps because the 
    // completion routine always returns 
    // STATUS_MORE_PRCESSING_REQUIRED
    // 
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        if(StreamObject->TransferObjectList[i] &&
           StreamObject->TransferObjectList[i]->Irp) {
        
            IoCancelIrp(StreamObject->TransferObjectList[i]->Irp);
        }
    }

    //
    // wait for the transfer objects irps to complete.
    //
    KeWaitForSingleObject(&StreamObject->NoPendingIrpEvent,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // dump the statistics
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {

        xferObject = StreamObject->TransferObjectList[i];

        if(xferObject) {

            timesRecycled += xferObject->TimesRecycled;
            totalPacketsProcessed += xferObject->TotalPacketsProcessed;
            totalBytesProcessed += xferObject->TotalBytesProcessed;
            errorPacketCount += xferObject->ErrorPacketCount;
        }
    }

    IsoUsb_DbgPrint(3, ("TimesRecycled = %d\n", timesRecycled));
    IsoUsb_DbgPrint(3, ("TotalPacketsProcessed = %d\n", totalPacketsProcessed));
    IsoUsb_DbgPrint(3, ("TotalBytesProcessed = %d\n", totalBytesProcessed));
    IsoUsb_DbgPrint(3, ("ErrorPacketCount = %d\n", errorPacketCount));


    //
    // free all the buffers, urbs and transfer objects 
    // associated with stream object
    //
    for(i = 0; i < ISOUSB_MAX_IRP; i++) {
        
        xferObject = StreamObject->TransferObjectList[i];

        if(xferObject) { 
            
            if(xferObject->Urb) {

                ExFreePool(xferObject->Urb);
                xferObject->Urb = NULL;
            }

            if(xferObject->DataBuffer) {
    
                ExFreePool(xferObject->DataBuffer);
                xferObject->DataBuffer = NULL;
            }

            ExFreePool(xferObject);
            StreamObject->TransferObjectList[i] = NULL;
        }
    }

    ExFreePool(StreamObject);

//    IsoUsb_ResetParentPort(DeviceObject);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isousb.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousb.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <wmilib.h>
#include "usbdi.h"
#include "usbdlib.h"
#include "usbbusif.h"

#ifndef _ISOUSB_H
#define _ISOUSB_H

#define ISOTAG (ULONG) 'OsI'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, ISOTAG);

#if DBG

#define IsoUsb_DbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }
#else

#define IsoUsb_DbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING IsoUsb_RegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

#define ISOUSB_MAX_TRANSFER_SIZE    256
#define ISOUSB_TEST_BOARD_TRANSFER_BUFFER_SIZE (64 * 1024)

//
// registry path used for parameters 
// global to all instances of the driver
//

#define ISOUSB_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\ISOUSB\\Parameters"


//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    // Bus drivers set the appropriate values in this structure in response
    // to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    // alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // Configuration Descriptor
    PUSB_CONFIGURATION_DESCRIPTOR UsbConfigurationDescriptor;

    // Interface Information structure
    PUSBD_INTERFACE_INFORMATION UsbInterface;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

    // High speed
    ULONG IsDeviceHighSpeed;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern ULONG DebugLevel;
extern GLOBALS Globals;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isousb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isousb.c

Abstract:

    Isoch USB device driver for Intel 82930 USB test board
	Main module

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

//
// Globals
//

ULONG   DebugLevel = 1;
GLOBALS Globals;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
IsoUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IsoUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, IsoUsb_DriverUnload)
#pragma alloc_text(PAGE, IsoUsb_DispatchCreate)
#pragma alloc_text(PAGE, IsoUsb_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status value
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //
    registryPath = &Globals.IsoUsb_RegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //
    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        IsoUsb_DbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = IsoUsb_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = IsoUsb_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = IsoUsb_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = IsoUsb_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = IsoUsb_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = IsoUsb_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_READ]           =
    DriverObject->MajorFunction[IRP_MJ_WRITE]          = IsoUsb_DispatchReadWrite;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = IsoUsb_DispatchSysCtrl;
    DriverObject->DriverUnload                         = IsoUsb_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         IsoUsb_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
IsoUsb_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    IsoUsb_DbgPrint(3, ("IsoUsb_DriverUnload - begins\n"));

    registryPath = &Globals.IsoUsb_RegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DriverUnload - ends\n"));

    return;
}

NTSTATUS
IsoUsb_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    IsoUsb_DbgPrint(3, ("IsoUsb_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //                
        IsoUsb_DbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //
    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // initialize the device state lock and set the device state
    //
    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //
    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //
    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = IsoUsb_WmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_DbgPrint(1, ("IsoUsb_WmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 

    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        IsoUsb_WmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_CLASS_I82930_ISO, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        IsoUsb_WmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // Win XP only
    // check the registry flag -
    // whether the device should selectively
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        IsoUsb_GetRegistryDword(ISOUSB_REGISTRY_PARAMETERS_PATH,
                                 L"IsoUsbEnable",
                                 &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {

            //
            // initialize DPC
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize timer
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    IsoUsb_DbgPrint(3, ("IsoUsb_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isowmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    isowmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "isousb.h"
#include "isopnp.h"
#include "isopwr.h"
#include "isodev.h"
#include "isowmi.h"
#include "isousr.h"
#include "isorwr.h"
#include "isostrm.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_ISOUSB_DRIVER_INFORMATION 0

DEFINE_GUID (ISOUSB_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO IsoWmiGuidList[1] = { {

        &ISOUSB_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
IsoUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (IsoWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = IsoWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = IsoUsb_QueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = IsoUsb_QueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = IsoUsb_SetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = IsoUsb_SetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
IsoUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
IsoUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    IsoUsb_DbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchSysCtrl::"));
    IsoUsb_IoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    IsoUsb_DbgPrint(3, ("IsoUsb_DispatchSysCtrl::"));
    IsoUsb_IoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
IsoUsb_QueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.IsoUsb_RegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
IsoUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_ISOUSB_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            IsoUsb_DbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_INVALID_BUFFER_SIZE;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_QueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
IsoUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_ISOUSB_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
IsoUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_ISOUSB_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    IsoUsb_DbgPrint(3, ("IsoUsb_SetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\isowmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    isowmi.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _ISOUSB_WMI_H
#define _ISOUSB_WMI_H

NTSTATUS
IsoUsb_WmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_WmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IsoUsb_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
IsoUsb_QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
IsoUsb_SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
IsoUsb_SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
IsoUsb_QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\isousb\sys\makefile.inc ===
mofcomp: isousb.bmf

isousb.bmf: isousb.mof
        mofcomp -B:isousb.bmf isousb.mof
        wmimofck isousb.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\makefile.inc ===
mofcomp: selSusp.bmf

selSusp.bmf: selSusp.mof
        mofcomp -B:selSusp.bmf selSusp.mof
        wmimofck selSusp.bmf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\sample\app\main.h ===
//main.h

#define MAX_DRIVER_NAME 64
#define DEVICE_DESCRIPTOR_SIZE 32 /* bigger than we need */
#define MAX_ITEMS_IN_LB 256
#define MAX_BUFFER_SIZE 512

// Clear out the first entry in the output box if the box has too many entries
#define MAINTAIN_OUTPUT_BOX(hO, nI) \
    nI = SendMessage (hO, LB_GETCOUNT, 0, 0); \
    while (nI >= MAX_ITEMS_IN_LB) { \
        SendMessage (hO, LB_DELETESTRING, 0, 0); \
        nI = SendMessage (hO, LB_GETCOUNT, 0, 0); \
    }

#define GET_CONFIG_DESCRIPTOR_LENGTH(pv) \
    ((pUsb_Configuration_Descriptor)pv)->wTotalLength

typedef struct __usb_Dev_Descriptor__ {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
    USHORT idVendor;
    USHORT idProduct;
    USHORT bcdDevice;
    UCHAR iManufacturer;
    UCHAR iProduct;
    UCHAR iSerialNumber;
    UCHAR bNumConfigurations;
} Usb_Device_Descriptor, *pUsb_Device_Descriptor;

typedef struct __usb_Config_Descriptor__ {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT wTotalLength;
    UCHAR bNumInterfaces;
    UCHAR bConfigurationValue;
    UCHAR iConfiguration;
    UCHAR bmAttributes;
    UCHAR MaxPower;
} Usb_Configuration_Descriptor, *pUsb_Configuration_Descriptor;

typedef struct _USB_INTERFACE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bInterfaceNumber;
    UCHAR bAlternateSetting;
    UCHAR bNumEndpoints;
    UCHAR bInterfaceClass;
    UCHAR bInterfaceSubClass;
    UCHAR bInterfaceProtocol;
    UCHAR iInterface;
} Usb_Interface_Descriptor, *pUsb_Interface_Descriptor;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
} Usb_Endpoint_Descriptor, *pUsb_Endpoint_Descriptor;

BOOLEAN
bOpenDriver (HANDLE * phDeviceHandle, PCHAR devname);

void
ParseDeviceDescriptor(PVOID pvBuffer, HWND hOutputBox);

void
ParseConfigurationDescriptor(PVOID pvBuffer, HWND hOutputBox);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\sample\sample.c ===
/*++

Copyright (c) 1996  Microsoft Corporation
Copyright (c) 1996  Intel Corporation

Module Name:
    Sample.c

Abstract:
    USB device driver for Sample USB Device

Environment:
    kernel mode only

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
  Copyright (c) 1996  Intel Corporation  All Rights Reserved.

Revision History:

  8-15-96:  Version 1.0   Kosar Jaff
            Created
  10-20-96: Version 1.1   Kosar Jaff
            Added changes to support new PnP IOCTLs
  11-29-96: Version 1.2   Kosar Jaff
            Added support for IOCTLs from companion Sample Application
  12-10-96: Version 1.3   Kosar Jaff
            Added Bulk Write/Read functions and corresponding IOCTLs
            Cleaned up device removal code
  01-08-97: Version 1.4   Kosar Jaff
            Changed IoAttachDeviceByPointer (obsolete) to IoAttachDeviceToDeviceStack
            Cleaned up comments
--*/

#define DRIVER

/*
// Include files needed for WDM driver support
*/
#include <wdm.h>
#include "stdarg.h"
#include "stdio.h"

/*
// Include files needed for USB support
*/
#include "usbdi.h"
#include "usbdlib.h"
#include "usb.h"

/*
// Include file for the Sample Device
*/
#include "Sample.h"

#define DEADMAN_TIMEOUT     5000     //timeout in ms; we use a 5 second timeout

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:
    Installable driver initialization entry point.
        This is where the driver is called when the driver is being loaded
        by the I/O system.  This entry point is called directly by the I/O system.

Arguments:
    DriverObject - pointer to the driver object
    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT deviceObject = NULL;

    Sample_KdPrint (("entering (Sample) DriverEntry (Build: %s/%s\n",__DATE__,__TIME__));

    /*
    // Create dispatch points for the various events handled by this
    // driver.  For example, device I/O control calls (e.g., when a Win32
    // application calls the DeviceIoControl function) will be dispatched to
    // routine specified below in the IRP_MJ_DEVICE_CONTROL case.
    //
    // For more information about the IRP_XX_YYYY codes, please consult the
    // Windows NT DDK documentation.
    //
    */
    DriverObject->MajorFunction[IRP_MJ_CREATE] = Sample_Create;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = Sample_Create;
    DriverObject->DriverUnload = Sample_Unload;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Sample_ProcessIOCTL;

    DriverObject->MajorFunction[IRP_MJ_PNP] = Sample_Dispatch;
    DriverObject->MajorFunction[IRP_MJ_POWER] = Sample_Dispatch;
    DriverObject->DriverExtension->AddDevice = Sample_PnPAddDevice;

    Sample_KdPrint (("exiting (Sample) DriverEntry (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
Sample_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
Routine Description:
    Process the IRPs sent to this device.

Arguments:
    DeviceObject - pointer to a device object
    Irp          - pointer to an I/O Request Packet

Return Value:
    NTSTATUS
--*/
{
    PIO_STACK_LOCATION irpStack, nextStack;
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    /*
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    */
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    /*
    // Get a pointer to the device extension
    */
    deviceExtension = DeviceObject->DeviceExtension;

    switch (irpStack->MajorFunction) {

        case IRP_MJ_PNP:

            /*
            //
            // This IRP is for Plug and Play and Power Management messages for your device.
            //
            // When your device is first installed, the port on the hub to which it
            // is attached is powered on and the USB software subsystem does some
            // minimal querying of the device.  After the USB subsystem is done with that
            // basic communication, (the device ID has been determined, and the device
            // has been given a unique USB bus address), it is considered "powered" by
            // the system.  The IRP's minor code gives more information about the power event.
            //
            // Similarly, when the USB device is being removed from the system, the Plug
            // and Play subsystem and the USB software stack interact to notify the
            // appropriate driver using this same IRP code, although in this case the
            // minor code gives more information about the exact power event.
            //
            */

            Sample_KdPrint (("IRP_MJ_PNP\n"));

            switch (irpStack->MinorFunction) {
                case IRP_MN_START_DEVICE:

                    Sample_KdPrint (("IRP_MN_START_DEVICE\n"));

                    /*
                    // We pass the Irp down to the underlying PDO first since that driver
                    // may have some configuration work to do before we can control the device
                    */
                    nextStack = IoGetNextIrpStackLocation(Irp);
                    ASSERT(nextStack != NULL);
                    RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

                    Sample_KdPrint (("Passing START_DEVICE Irp down\n"));

                    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

                    Sample_KdPrint (("Back from passing START_DEVICE Irp down; status: %#X\n", ntStatus));

                    // Now we can begin our configuration actions on the device
                    ntStatus = Sample_StartDevice(DeviceObject);

                    break; //IRP_MN_START_DEVICE

                case IRP_MN_STOP_DEVICE:

                    Sample_KdPrint (("IRP_MN_STOP_DEVICE\n"));

                    Sample_Cleanup (DeviceObject);

                    ntStatus = Sample_StopDevice(DeviceObject);

                    break; //IRP_MN_STOP_DEVICE

                case IRP_MN_REMOVE_DEVICE:

                    /*
                    // Note:  This IRP handler will change slightly in future revisions of this
                    //        sample driver.  Please watch this space for updates.
                    */
                    Sample_KdPrint (("IRP_MN_REMOVE_DEVICE\n"))

                    Sample_Cleanup (DeviceObject);

                    ntStatus = Sample_RemoveDevice(DeviceObject);

                    /*
                    // Delete the link to the Stack Device Object, and delete the
                    // Functional Device Object we created
                    */
                    IoDetachDevice(deviceExtension->StackDeviceObject);

                    IoDeleteDevice (DeviceObject);

                    break; //IRP_MN_REMOVE_DEVICE

                case IRP_MN_QUERY_STOP_DEVICE:
                    Sample_KdPrint (("IRP_MN_QUERY_STOP_DEVICE\n"));
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    Sample_KdPrint (("IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    Sample_KdPrint (("IRP_MN_CANCEL_STOP_DEVICE\n"));
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    Sample_KdPrint (("IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    break;

                default:
                    // A PnP Minor Function was not handled
                    Sample_KdPrint (("PnP IOCTL not handled\n"));

            } /* switch MinorFunction*/


            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

            /*
            // All PNP_POWER messages get passed to the StackDeviceObject that
            // we were given in PnPAddDevice.
            //
            // This stack device object is managed by the USB software subsystem,
            // and so this IRP must be propagated to the owning device driver for
            // that stack device object, so that driver in turn can perform any
            // device state management (e.g., remove its device object, etc.).
            */
            Sample_KdPrint (("Passing PnP Irp down, status = %x\n", ntStatus));

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

            /*
            // If lower layer driver marked the Irp as pending then reflect that by
            // calling IoMarkIrpPending.
            */
            if (ntStatus == STATUS_PENDING) {
                IoMarkIrpPending(Irp);
                Sample_KdPrint (("PnP Irp came back with STATUS_PENDING (%x)\n", ntStatus));
            } else {
                Sample_KdPrint (("PnP Irp came back, status = %x\n", ntStatus));
            } // if ntStatus is PENDING

            goto Sample_Dispatch_Done;
            
            break; //IRP_MJ_PNP_POWER

        case IRP_MJ_POWER:

            /*
            //
            // This IRP is for Plug and Play and Power Management messages for your device.
            //
            // When your device is first installed, the port on the hub to which it
            // is attached is powered on and the USB software subsystem does some
            // minimal querying of the device.  After the USB subsystem is done with that
            // basic communication, (the device ID has been determined, and the device
            // has been given a unique USB bus address), it is considered "powered" by
            // the system.  The IRP's minor code gives more information about the power event.
            //
            // Similarly, when the USB device is being removed from the system, the Plug
            // and Play subsystem and the USB software stack interact to notify the
            // appropriate driver using this same IRP code, although in this case the
            // minor code gives more information about the exact power event.
            //
            */

            Sample_KdPrint (("IRP_MJ_POWER\n"));

            switch (irpStack->MinorFunction) {

                case IRP_MN_SET_POWER:

                    switch (irpStack->Parameters.Power.Type) {
                        case SystemPowerState:
                            break; //SystemPowerState

                        case DevicePowerState:
                            switch (irpStack->Parameters.Power.State.DeviceState) {
                                case PowerDeviceD3:
                                    Sample_KdPrint (("IRP_MN_SET_D3\n"));
                                    break;
                                case PowerDeviceD2:
                                    Sample_KdPrint (("IRP_MN_SET_D2\n"));
                                    break;
                                case PowerDeviceD1:
                                    Sample_KdPrint (("IRP_MN_SET_D1\n"));
                                    break;
                                case PowerDeviceD0:
                                    Sample_KdPrint (("IRP_MN_SET_D0\n"));
                                    break;
                            } // switch on Power.State.DeviceState

                            break; //DevicePowerState

                    }// switch on Power.Type

                    break;  //IRP_MN_SET_POWER

                 case IRP_MN_QUERY_POWER:

                    // Look at what type of power query this is
                    
                    switch (irpStack->Parameters.Power.Type) {
                        case SystemPowerState:
                            break; //SystemPowerState

                        case DevicePowerState:
                            switch (irpStack->Parameters.Power.State.DeviceState) {
                                case PowerDeviceD2:
                                    Sample_KdPrint (("IRP_MN_QUERY_D2\n"));
                                    break;
                                case PowerDeviceD1:
                                    Sample_KdPrint (("IRP_MN_QUERY_D1\n"));
                                    break;
                                case PowerDeviceD3:
                                    Sample_KdPrint (("IRP_MN_QUERY_D3\n"));
                                    break;
                            } //switch on Power.State.DeviceState

                            break; //DevicePowerState
                            
                    }//switch on Power.Type

                    break; //IRP_MN_QUERY_POWER

                default:
                    // A PnP Minor Function was not handled
                    Sample_KdPrint (("Power IOCTL not handled\n"));

            } /* switch MinorFunction*/


            nextStack = IoGetNextIrpStackLocation(Irp);
            ASSERT(nextStack != NULL);
            RtlCopyMemory(nextStack, irpStack, sizeof(IO_STACK_LOCATION));

            /*
            // All PNP_POWER messages get passed to the StackDeviceObject that
            // we were given in PnPAddDevice.
            //
            // This stack device object is managed by the USB software subsystem,
            // and so this IRP must be propagated to the owning device driver for
            // that stack device object, so that driver in turn can perform any
            // device state management (e.g., remove its device object, etc.).
            */
            Sample_KdPrint (("Passing Power Irp down, status = %x\n", ntStatus));

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

            /*
            // If lower layer driver marked the Irp as pending then reflect that by
            // calling IoMarkIrpPending.
            */
            if (ntStatus == STATUS_PENDING) {
                IoMarkIrpPending(Irp);
                Sample_KdPrint (("Power Irp came back with STATUS_PENDING (%x)\n", ntStatus));
            } else {
                Sample_KdPrint (("Power Irp came back, status = %x\n", ntStatus));
            } // if ntStatus is PENDING

            goto Sample_Dispatch_Done;
            
            break; //IRP_MJ_POWER

        default:
            Sample_KdPrint (("A MAJOR IOCTL Code was not handled: %#X\n",
                              irpStack->MajorFunction));

            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

        } /* switch MajorFunction */

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );
Sample_Dispatch_Done:
    Sample_KdPrint (("Exit Sample_Dispatch %x\n", ntStatus));
    return ntStatus;

}//Sample_Dispatch


VOID
Sample_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++
Routine Description:
    Free all the allocated resources, etc.
    TODO: This is a placeholder for driver writer to add code on unload

Arguments:
    DriverObject - pointer to a driver object

Return Value:
    None
--*/
{
    Sample_KdPrint (("enter Sample_Unload\n"));
    /*
    // TODO: Free any global resources allocated in DriverEntry
    */
    Sample_KdPrint (("exit Sample_Unload\n"));
}


NTSTATUS
Sample_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Initializes a given instance of the Sample Device on the USB.

    TODO:  Perform any device initialization and querying here.  For example,
           this routine queries the device's descriptors.  Your device can
           be queried in a similar fashion with more specific requests that are
           tailored to your device's functionality.

Arguments:
    DeviceObject - pointer to the device object for this instance of a
                   Sample Device

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb;
    ULONG siz;

    Sample_KdPrint (("enter Sample_StartDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;
    deviceExtension->NeedCleanup = TRUE;

    /*
    // Get some memory from then non paged pool (fixed, locked system memory)
    // for use by the USB Request Block (urb) for the specific USB Request we
    // will be performing below (a USB device request).
    */
    urb = ExAllocatePool( NonPagedPool,
                          sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);

        // Get some non paged memory for the device descriptor contents
        deviceDescriptor = ExAllocatePool(NonPagedPool,
                                          siz);

        if (deviceDescriptor) {

            // Use a macro in the standard USB header files to build the URB
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         deviceDescriptor,
                                         NULL,
                                         siz,
                                         NULL);

            // Get the device descriptor
            ntStatus = Sample_CallUSBD(DeviceObject, urb);

            // Dump out the descriptor info to the debugger
            if (NT_SUCCESS(ntStatus)) {
                Sample_KdPrint (("Device Descriptor = %x, len %x\n",
                                deviceDescriptor,
                                urb->UrbControlDescriptorRequest.TransferBufferLength));

                Sample_KdPrint (("Sample Device Descriptor:\n"));
                Sample_KdPrint (("-------------------------\n"));
                Sample_KdPrint (("bLength %d\n", deviceDescriptor->bLength));
                Sample_KdPrint (("bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                Sample_KdPrint (("bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                Sample_KdPrint (("bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                Sample_KdPrint (("bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                Sample_KdPrint (("bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                Sample_KdPrint (("bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                Sample_KdPrint (("idVendor 0x%x\n", deviceDescriptor->idVendor));
                Sample_KdPrint (("idProduct 0x%x\n", deviceDescriptor->idProduct));
                Sample_KdPrint (("bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                Sample_KdPrint (("iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                Sample_KdPrint (("iProduct 0x%x\n", deviceDescriptor->iProduct));
                Sample_KdPrint (("iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                Sample_KdPrint (("bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
            }
        } else {
            ntStatus = STATUS_NO_MEMORY;
        }

        if (NT_SUCCESS(ntStatus)) {
            /*
            // Put a ptr to the device descriptor in the device extension for easy
            // access (like a "cached" copy).  We will free this memory when the
            // device is removed.  See the "Sample_RemoveDevice" code.
            */
            deviceExtension->DeviceDescriptor = deviceDescriptor;
            deviceExtension->Stopped = FALSE;
        } else if (deviceDescriptor) {
            /*
            // If the bus transaction failed, then free up the memory created to hold
            // the device descriptor, since the device is probably non-functional
            */
            ExFreePool(deviceDescriptor);
            deviceExtension->DeviceDescriptor = NULL;
        }

        ExFreePool(urb);

    } else {
        // Failed getting memory for the Urb 
        ntStatus = STATUS_NO_MEMORY;
    }

    // If the Get_Descriptor call was successful, then configure the device.
    if (NT_SUCCESS(ntStatus)) {
        ntStatus = Sample_ConfigureDevice(DeviceObject);
    }

    Sample_KdPrint (("exit Sample_StartDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
Sample_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:
    Removes a given instance of a Sample Device device on the USB.

Arguments:
    DeviceObject - pointer to the device object for this instance of a Sample Device

Return Value:
    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;

    Sample_KdPrint (("enter Sample_RemoveDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->DeviceDescriptor) {
        ExFreePool(deviceExtension->DeviceDescriptor);
    }

    /*
    // Free up any interface structures in our device extension
    */
    if (deviceExtension->Interface != NULL) {
        ExFreePool(deviceExtension->Interface);
    }//if

    Sample_KdPrint (("exit Sample_RemoveDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
Sample_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
    Stops a given instance of a Sample Device device on USB.

Arguments:
    DeviceObject - pointer to the device object for this instance of a Sample Device

Return Value:
    NT status code

  --*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz;

    Sample_KdPrint (("enter Sample_StopDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    /*
    // Send the select configuration urb with a NULL pointer for the configuration
    // handle, this closes the configuration and puts the device in the 'unconfigured'
    // state.
    */

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);

    urb = ExAllocatePool(NonPagedPool,
                         siz);

    if (urb) {
        NTSTATUS status;

        UsbBuildSelectConfigurationRequest(urb,
                                          (USHORT) siz,
                                          NULL);

        status = Sample_CallUSBD(DeviceObject, urb);

        Sample_KdPrint (("Device Configuration Closed status = %x usb status = %x.\n",
                        status, urb->UrbHeader.Status));

        ExFreePool(urb);
    } else {
        ntStatus = STATUS_NO_MEMORY;
    }

    Sample_KdPrint (("exit Sample_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}

NTSTATUS
Sample_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++
Routine Description:
    This routine is called to create a new instance of the device

Arguments:
    DriverObject - pointer to the driver object for this instance of Sample
    PhysicalDeviceObject - pointer to a device object created by the bus

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension;

    Sample_KdPrint(("enter Sample_PnPAddDevice\n"));

    // create our functional device object (FDO)
    ntStatus = Sample_CreateDeviceObject(DriverObject, &deviceObject, 0);

    if (NT_SUCCESS(ntStatus)) {
        deviceExtension = deviceObject->DeviceExtension;

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
        // Add more flags here if your driver supports other specific
        // behavior.  For example, if your IRP_MJ_READ and IRP_MJ_WRITE
        // handlers support DIRECT_IO, you would set that flag here.
        //
        // Also, store away the Physical device Object
        */
        deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

        //
        // Attach to the StackDeviceObject.  This is the device object that what we 
        // use to send Irps and Urbs down the USB software stack
        //
        deviceExtension->StackDeviceObject =
            IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

        ASSERT (deviceExtension->StackDeviceObject != NULL);
        
    }

    Sample_KdPrint(("exit Sample_PnPAddDevice (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
Sample_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    )
/*++

Routine Description:
    Creates a Functional DeviceObject

Arguments:
    DriverObject - pointer to the driver object for device
    DeviceObject - pointer to DeviceObject pointer to return
                   created device object.
    Instance - instnace of the device create.

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise
--*/
{
    NTSTATUS ntStatus;
    WCHAR deviceLinkBuffer[]  = L"\\DosDevices\\Sample-0";
    UNICODE_STRING deviceLinkUnicodeString;
    WCHAR deviceNameBuffer[]  = L"\\Device\\Sample-0";
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_EXTENSION deviceExtension;
    STRING deviceName;

    Sample_KdPrint(("enter Sample_CreateDeviceObject instance = %d\n", Instance));

    /*
    // fix up device names based on Instance
    //
    // NOTE:  Watch this space for potential changes to this approach in future revisions
    //        of this sample driver.
    */

    deviceLinkBuffer[19] = (USHORT) ('0' + Instance);
    deviceNameBuffer[15] = (USHORT) ('0' + Instance);

    Sample_KdPrint(("Create Device name (%ws)\n", deviceNameBuffer));

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);

    /*
    //Print out the unicode string
    //NOTE:  We must first convert the string to Unicode due to a bug in the Debugger that does not allow
    //       Unicode Strings to be printed to the debug device.
    */
    deviceName.Buffer = NULL;

    ntStatus = RtlUnicodeStringToAnsiString (&deviceName,
                                             &deviceNameUnicodeString, 
                                             TRUE);


    if (NT_SUCCESS(ntStatus)) {
        Sample_KdPrint(("Create Device Name (%s)\n", deviceName.Buffer));
        RtlFreeAnsiString (&deviceName);
    } else {
        Sample_KdPrint(("Unicode to Ansi str failed w/ ntStatus: 0x%x\n",ntStatus));
    }

    ntStatus = IoCreateDevice (DriverObject,
                               sizeof (DEVICE_EXTENSION),
                               &deviceNameUnicodeString,
                               FILE_DEVICE_UNKNOWN,
                               0,
                               FALSE,
                               DeviceObject);


    if (NT_SUCCESS(ntStatus)) {
        RtlInitUnicodeString (&deviceLinkUnicodeString,
                              deviceLinkBuffer);

        Sample_KdPrint(("Create DosDevice name (%ws)\n", deviceLinkBuffer));

        ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString,
                                         &deviceNameUnicodeString);

        // Initialize our device extension
        deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

        RtlCopyMemory(deviceExtension->DeviceLinkNameBuffer,
                      deviceLinkBuffer,
                      sizeof(deviceLinkBuffer));

        deviceExtension->ConfigurationHandle = NULL;
        deviceExtension->DeviceDescriptor = NULL;
        deviceExtension->NeedCleanup = FALSE;

        // Initialize our interface
        deviceExtension->Interface = NULL;

    }

    Sample_KdPrint(("exit Sample_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}

VOID
Sample_Cleanup(
    PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
        Cleans up certain elements of the device object.  This is called when the device
        is being removed from the system

Arguments:
        DeviceObject - pointer to DeviceObject

Return Value:
        None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING deviceLinkUnicodeString;

    deviceExtension = DeviceObject->DeviceExtension;

    if (deviceExtension->NeedCleanup) {

        deviceExtension->NeedCleanup = FALSE;

        RtlInitUnicodeString (&deviceLinkUnicodeString,
                              deviceExtension->DeviceLinkNameBuffer);

        IoDeleteSymbolicLink(&deviceLinkUnicodeString);
    }
}


NTSTATUS
Sample_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    )
/*++

Routine Description:
    Passes a Usb Request Block (URB) to the USB class driver (USBD)

    Note that we create our own IRP here and use it to send the request to
        the USB software subsystem.  This means that this routine is essentially
        independent of the IRP that caused this driver to be called in the first
        place.  The IRP for this transfer is created, used, and then destroyed
        in this routine.

    However, note that this routine uses the Usb Request Block (urb) passed
        in by the caller as the request block for the USB software stack.

    Implementation of this routine may be changed depending on the specific
        requirements of your driver.  For example, while this routine issues a
        synchronous request to the USB stack, you may wish to implement this as an
        asynchronous request in which you set an IoCompletionRoutine to be called
        when the request is complete.

Arguments:
    DeviceObject - pointer to the device object for this instance of an Sample Device
    Urb          - pointer to Urb request block

Return Value:
    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    Sample_KdPrint (("enter Sample_CallUSBD\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    // issue a synchronous request (see notes above)
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                deviceExtension->StackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    // Prepare for calling the USB driver stack
    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    // Set up the URB ptr to pass to the USB driver stack
    nextStack->Parameters.Others.Argument1 = Urb;

    Sample_KdPrint (("Calling USB Driver Stack\n"));

    /*
    // Call the USB class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    */
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);

    Sample_KdPrint (("return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING)
	{
       	LARGE_INTEGER dueTime;

        Sample_KdPrint (("Wait for single object\n"));

	    dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

        ntStatus = KeWaitForSingleObject(
          		           &event,
                		   Suspended,
    	                   KernelMode,
        		           FALSE,
                		   &dueTime);

        Sample_KdPrint (("Wait for single object, returned %x\n", status));
					
		if(ntStatus == STATUS_TIMEOUT)
		{
           	ioStatus.Status = ntStatus = STATUS_IO_TIMEOUT;		
			ioStatus.Information = 0;

			// We've waited long enough and we're not going to take
			// it anymore...cancel it
			IoCancelIrp(irp);

			// Wait for the stack to signal the _real_ completion of the cancel
			// Note we wait forever here, so we depend on the USB stack to signal this
			// event when it completes the cancelled Irp.  Gosh, I hope this works. (kjaff 4-16-97)
            ntStatus = KeWaitForSingleObject(
           		           &event,
                		   Suspended,
    	                   KernelMode,
        		           FALSE,
						   NULL);
					
	        Sample_KdPrint (("Wait for single object, returned %x\n", status));
		}

    } else
	{
        ioStatus.Status = ntStatus;
    }

    Sample_KdPrint (("URB status = %x status = %x irp status %x\n",
        Urb->UrbHeader.Status, status, ioStatus.Status));

    /*
    // USBD maps the error code for us.  USBD uses error codes in its URB
    // structure that are more insightful into USB behavior. In order to
    // match the NT Status codes, USBD maps its error codes into more general NT
    // error categories so higher level drivers can decipher the error codes
    // based on standard NT error code definitions.  To allow more insight into
    // the specific USB error that occurred, your driver may wish to examine the
    // URB's status code (Urb->UrbHeader.Status) as well.
    */
    ntStatus = ioStatus.Status;

    Sample_KdPrint(("exit Sample_CallUSBD (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
Sample_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++
Routine Description:
    Configures the USB device via USB-specific device requests and interaction
    with the USB software subsystem.

Arguments:
    DeviceObject - pointer to the device object for this instance of the Sample Device

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;

    Sample_KdPrint (("enter Sample_ConfigureDevice\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    /*
    // Get memory for the USB Request Block (urb).
    */
    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb != NULL) {

        /*
        // Set size of the data buffer.  Note we add padding to cover hardware faults
        // that may cause the device to go past the end of the data buffer
        */
        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 16;

        // Get the nonpaged pool memory for the data buffer
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if (configurationDescriptor != NULL) {

            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         sizeof (USB_CONFIGURATION_DESCRIPTOR),/* Get only the configuration descriptor */
                                         NULL);

            ntStatus = Sample_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus)) {
                Sample_KdPrint (("Configuration Descriptor is at %x, bytes txferred: %d\n\
                                  Configuration Descriptor Actual Length: %d\n",
                                  configurationDescriptor,
                                  urb->UrbControlDescriptorRequest.TransferBufferLength,
                                  configurationDescriptor->wTotalLength));
            }//if

        } else {
            ntStatus = STATUS_NO_MEMORY;
            goto Exit_SampleConfigureDevice;
        }//if-else

        // Determine how much data is in the entire configuration descriptor
        // and add extra room to protect against accidental overrun
        siz = configurationDescriptor->wTotalLength + 16;

        //  Free up the data buffer memory just used
        ExFreePool(configurationDescriptor);
        configurationDescriptor = NULL;

        // Get nonpaged pool memory for the data buffer
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        // Now get the entire Configuration Descriptor
        if (configurationDescriptor != NULL) {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         configurationDescriptor,
                                         NULL,
                                         siz,  // Get all the descriptor data
                                         NULL);

            ntStatus = Sample_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus)) {
                Sample_KdPrint (("Entire Configuration Descriptor is at %x, bytes txferred: %d\n",
                                  configurationDescriptor,
                                  urb->UrbControlDescriptorRequest.TransferBufferLength));
            } else {
                //Error in getting configuration descriptor
                goto Exit_SampleConfigureDevice;
            }//else

        } else {
            // Failed getting data buffer (configurationDescriptor) memory
            ntStatus = STATUS_NO_MEMORY;
            goto Exit_SampleConfigureDevice;
        }//if-else

    } else {
        // failed getting urb memory
        ntStatus = STATUS_NO_MEMORY;
        goto Exit_SampleConfigureDevice;
    }//if-else

    /*
    // We have the configuration descriptor for the configuration
    // we want.
    //
    // Now we issue the SelectConfiguration command to get
    // the  pipes associated with this configuration.
    */
    if (configurationDescriptor) {
        // Get our pipes
        ntStatus = Sample_SelectInterfaces(DeviceObject,
                                           configurationDescriptor,
                                           NULL // Device not yet configured
                                           );
    } //if

Exit_SampleConfigureDevice:

    // Clean up and exit this routine
    if (urb != NULL) {
        ExFreePool(urb);                    // Free urb memory
    }//if

    if (configurationDescriptor != NULL) {
        ExFreePool(configurationDescriptor);// Free data buffer
    }//if

    Sample_KdPrint (("exit Sample_ConfigureDevice (%x)\n", ntStatus));
    return ntStatus;
}//Sample_ConfigureDevice


NTSTATUS
Sample_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface
    )
/*++

Routine Description:
    Initializes an Sample Device with multiple interfaces

Arguments:
    DeviceObject            - pointer to the device object for this instance of the Sample Device
    ConfigurationDescriptor - pointer to the USB configuration descriptor containing the interface and endpoint
                              descriptors.
    Interface               - pointer to a USBD Interface Information Object
                            - If this is NULL, then this driver must choose its interface based on driver-specific
                              criteria, and the driver must also CONFIGURE the device.
                            - If it is NOT NULL, then the driver has already been given an interface and
                              the device has already been configured by the parent of this device driver.

Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb;
    ULONG siz, numberOfInterfaces, j;
    UCHAR numberOfPipes, alternateSetting, MyInterfaceNumber;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceObject;

    Sample_KdPrint (("enter Sample_SelectInterfaces\n"));

    deviceExtension = DeviceObject->DeviceExtension;
        MyInterfaceNumber = SAMPLE_INTERFACE_NBR;

    if (Interface == NULL) {

        /*
        // This example driver only supports one interface.  This can be extended
        // to be a dynamically allocated array by your driver.
        */
        numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
        Sample_KdPrint (("Device has %d Interfaces\n",numberOfInterfaces));

        numberOfInterfaces =1;      // Fixed for this sample driver in this revision
        numberOfPipes = 0;          // Initialize to zero

        /*
        // We use alternate interface setting 0 for all interfaces
        // NOTE: This is a simplification and is due to change in future releases of this driver.  If
        //       your driver supports alternate settings, you will have to do more work to switch between
        //       alternate settings.
        */
        alternateSetting = 0;

        /*
        // Call a USBD helper function that returns a ptr to a USB Interface Descriptor given
        // a USB Configuration Descriptor, an Interface Number, and an Alternate Setting for that Interface
        */
        interfaceDescriptor =
        USBD_ParseConfigurationDescriptor(ConfigurationDescriptor,
                                          MyInterfaceNumber, //interface number (this is bInterfaceNumber from interface descr)
                                          alternateSetting);

        ASSERT(interfaceDescriptor != NULL);

        if (interfaceDescriptor != NULL) {
            Sample_KdPrint (("Device has %d Interface(s) | MyInterface (%d) is at: (%#X)\n",
                            numberOfInterfaces, MyInterfaceNumber, interfaceDescriptor));
        } /* if there was a valid interfacedesc */

        /* Add to the tally of pipes in this configuration */
        numberOfPipes += interfaceDescriptor->bNumEndpoints;

        Sample_KdPrint (("Interface has %d endpoints\n",
                          interfaceDescriptor->bNumEndpoints));

        /*
        // Now that we have looked at the interface, we configure the device so that the remainder
        // of the USBD objects will come into existence (ie., pipes, etc.) as a result of the configuration,
        // thus completing the configuration process for the USB device.
        //
        // Allocate a URB big enough for this Select Configuration request
        // This example driver supports only 1 interface
        //
        // NOTE:  The new service USBD_CreateConfigurationRequest will replace some of the
        //        code below.  Future releases of this driver will demonstrate how to use
        //        that service.
        //
        */
        siz = GET_SELECT_CONFIGURATION_REQUEST_SIZE(numberOfInterfaces, numberOfPipes);

        Sample_KdPrint (("size of config request Urb = %d\n", siz));

        urb = ExAllocatePool(NonPagedPool,
                             siz);

        if (urb) {
            interfaceObject = (PUSBD_INTERFACE_INFORMATION) (&(urb->UrbSelectConfiguration.Interface));
            Sample_KdPrint (("urb.Interface=%#X\n", &(urb->UrbSelectConfiguration.Interface)));

            // set up the input parameters in our interface request structure.
            interfaceObject->Length = GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

            Sample_KdPrint (("size of interface request = %d\n", interfaceObject->Length));

            interfaceObject->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;
            interfaceObject->AlternateSetting = interfaceDescriptor->bAlternateSetting;
            interfaceObject->NumberOfPipes = interfaceDescriptor->bNumEndpoints;

            /*
            // We set up a default max transfer size for the endpoints.  Your driver will
            // need to change this to reflect the capabilities of your device's endpoints.
            */
            for (j=0; j<interfaceDescriptor->bNumEndpoints; j++) {
                interfaceObject->Pipes[j].MaximumTransferSize =
                    USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
            } /* for */

            Sample_KdPrint (("InterfaceObj Inteface Nbr: %d | InterfaceObj AltSett: %d |NbrPip: %d\n",
                                             interfaceObject->InterfaceNumber,
                                             interfaceObject->AlternateSetting,
                                             interfaceObject->NumberOfPipes));

            UsbBuildSelectConfigurationRequest(urb,
                                              (USHORT) siz,
                                              ConfigurationDescriptor);

            ntStatus = Sample_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(urb->UrbSelectConfiguration.Status)) {

                // Save the configuration handle for this device
                deviceExtension->ConfigurationHandle =
                    urb->UrbSelectConfiguration.ConfigurationHandle;

                deviceExtension->Interface = ExAllocatePool(NonPagedPool,
                                                            interfaceObject->Length);

                if (deviceExtension->Interface) {

                    // save a copy of the interfaceObject information returned
                    RtlCopyMemory(deviceExtension->Interface, interfaceObject, interfaceObject->Length);

                    // Dump the interfaceObject to the debugger
                    Sample_KdPrint (("---------\n"));
                    Sample_KdPrint (("NumberOfPipes 0x%x\n", deviceExtension->Interface->NumberOfPipes));
                    Sample_KdPrint (("Length 0x%x\n", deviceExtension->Interface->Length));
                    Sample_KdPrint (("Alt Setting 0x%x\n", deviceExtension->Interface->AlternateSetting));
                    Sample_KdPrint (("Interface Number 0x%x\n", deviceExtension->Interface->InterfaceNumber));

                    // Dump the pipe info
                    for (j=0; j<interfaceObject->NumberOfPipes; j++) {
                        PUSBD_PIPE_INFORMATION pipeInformation;

                        pipeInformation = &deviceExtension->Interface->Pipes[j];

                        Sample_KdPrint (("---------\n"));
                        Sample_KdPrint (("PipeType 0x%x\n", pipeInformation->PipeType));
                        Sample_KdPrint (("EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                        Sample_KdPrint (("MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                        Sample_KdPrint (("Interval 0x%x\n", pipeInformation->Interval));
                        Sample_KdPrint (("Handle 0x%x\n", pipeInformation->PipeHandle));
                        Sample_KdPrint (("MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));
                    }/* for all the pipes in this interface */

                    Sample_KdPrint (("---------\n"));

                } /*If ExAllocate passed */

            }/* if selectconfiguration request was successful */

        } else {

            ntStatus = STATUS_NO_MEMORY;

        }/* if urb alloc passed  */

    }//if Interface was not NULL

    Sample_KdPrint (("exit Sample_SelectInterfaces (%x)\n", ntStatus));

    return ntStatus;

}/* Sample_SelectInterfaces */

NTSTATUS
Sample_Read_Write(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIRP Irp,
    IN  BOOLEAN Read
    )
/*++
Routine Description:
    This function is called for IOCTLs to Read or Write bulk or interrupt endpoints.  
    By agreement between the driver and application, the endpoint on which the READ or WRITE 
    is to be performed is supplied by the caller (the User-Mode application that performed
    the IOCTL puts this value in the buffer supplied in the DeviceIoControl call).  This 
    number is an INDEX into an array of pipes, which are ordered exactly like the order of the
    endpoints as they appear in the device's configuration descriptor.  

    The endpoint list is ordered as the endpoint descriptors appear in the device.  The list
    is a zero-index based ordered list.  That is, when the application specifies:
        Endpoint index 0      =  the endpoint described by the FIRST endpoint descriptor
                                 in the configuration descriptor
        Endpoint index 1      =  the endpoint described by the SECOND endpoint descriptor
                                 in the configuration descriptor
          etc.

    Also by agreement between this driver and the application, this INDEX is specified in
    the first DWORD (32-bits) of the input buffer.  Note that more sophisticated structures
    can be passed between the application and the driver to communicate the desired operation.
          
    For READs, this data received from the device is put into the SystemBuffer. This routine
    sets the "information" field in the Irp to tell the IOS to how many bytes to copy back
    to user space (in the user's lpOutputBuffer).  The actual bytes copied back is reflected in
    the lpBytesReturned field in the DeviceIoControl() call, which the application can examine.

    For WRITEs, the data is retrieved from the SystemBuffer and sent to the device.
    
Arguments:
    DeviceObject - pointer to the device object for this instance of the Sample device.
    Irp          - pointer to IRP
    Read         - if TRUE this is a Device-to-Host (Read from device) transfer
                   if FALSE this is a Host-to-Device (Write to device) transfer

Return Value:
    NT status code
        STATUS_SUCCESS:                 Read was done successfully
        STATUS_INVALID_PARAMETER_3:     The Endpoint Index does not specify an IN pipe 
        STATUS_NO_MEMORY:               Insufficient data memory was supplied to perform the READ

    This routine fills the status code into the Irp
    
--*/
{
    USBD_INTERFACE_INFORMATION *    pInterfaceInfo;
    USBD_PIPE_INFORMATION *         pPipeInfo;        	
    PIO_STACK_LOCATION              irpStack;
    PDEVICE_EXTENSION               deviceExtension;     
    NTSTATUS                        ntStatus;
    PVOID                           ioBuffer;
    PCHAR                           pcTempBuffer;
    ULONG                           length;
    PULONG                          pPipeNum;
    ULONG                           inputBufferLength;
    ULONG                           outputBufferLength;
    ULONG                           siz;
    PURB                            urb;
    
	Sample_KdPrint(("enter READ\n"));

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    ASSERT (irpStack != NULL);
    
    deviceExtension = DeviceObject->DeviceExtension;
    ASSERT (deviceExtension != NULL);

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //DEBUG ONLY
    if ((ioBuffer == NULL) || (inputBufferLength == 0) || (outputBufferLength==0)) {
        Sample_KdPrint (("ERROR ioBuffer %X | inBufLen: %d | outBufLen %d\n",
                          ioBuffer, inputBufferLength, outputBufferLength));
        
        Irp->IoStatus.Information = 0;
        return (STATUS_NO_MEMORY);
        
    } //DEBUG ONLY
        
    pInterfaceInfo  = deviceExtension->Interface;
    ASSERT (pInterfaceInfo != NULL);

    pPipeNum = (PULONG) ioBuffer;
    ASSERT (*pPipeNum <= pInterfaceInfo->NumberOfPipes);
    
    pPipeInfo = &(pInterfaceInfo->Pipes[*pPipeNum]);
    ASSERT (pPipeInfo != NULL);
    ASSERT ((pPipeInfo->PipeHandle) != NULL);
    
    Sample_KdPrint (("PipeNum: %d | ioBuffer %X | inBufLen: %d | outBufLen %d\n",
                      *pPipeNum, ioBuffer, inputBufferLength, outputBufferLength));
                      
    siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

	// allocate urb
	urb = ExAllocatePool(NonPagedPool, siz);

    // By convention, the first dword of the buffer is reserved for the pipe index, so
    // skip over the first dword when specifying the transferbuffer
    pcTempBuffer = (((char*)ioBuffer) + sizeof (ULONG));

    if (Read==TRUE) {
        // A READ operation implies that the data is placed in the User's Output Data Buffer
        length = outputBufferLength - sizeof(ULONG);
    } else {
        // A WRITE operation implies that the data is gotten from the User's Input Data Buffer
        length = inputBufferLength - sizeof(ULONG);
    }/* else */
    
   	// set up urb
	UsbBuildInterruptOrBulkTransferRequest(urb,         //ptr to urb
							   (USHORT) siz,            //siz of urb
							   pPipeInfo->PipeHandle,	//usbd pipe handle
							   pcTempBuffer,            //TransferBuffer
							   NULL,                    //mdl (unused)
							   length,
                                                        //bufferlength
							   USBD_SHORT_TRANSFER_OK,  //flags
							   NULL);                   //link

	// call the usb stack
	ntStatus = Sample_CallUSBD(DeviceObject, urb);

	// The Information field tells IOM how much to copy back into the
    // usermode buffer in the BUFFERED method
    if (NT_SUCCESS(ntStatus) && Read==TRUE) {

        Sample_KdPrint (("Sucessfully Transferred %d Bytes\n", urb->UrbBulkOrInterruptTransfer.TransferBufferLength));

        // We fill in the actual length transferred in the first DWORD (this overwrites the pipe number)
        *((PULONG)ioBuffer) = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

        // Tell the IOS to copy whatever the device returned, as well as the first DWORD that was skipped over
        Irp->IoStatus.Information = (urb->UrbBulkOrInterruptTransfer.TransferBufferLength + sizeof(ULONG));
        ASSERT (Irp->IoStatus.Information <= outputBufferLength);

    }else if (NT_SUCCESS(ntStatus) && Read==FALSE) {

        // We fill in the actual length transferred in the first DWORD (this overwrites the pipe number)
        *((PULONG)ioBuffer) = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

        // Tell the IOS to copy whatever the device returned, as well as the first DWORD that was skipped over
        Irp->IoStatus.Information = sizeof (ULONG);
        ASSERT (Irp->IoStatus.Information <= outputBufferLength);

    }/* else */
    
	Irp->IoStatus.Status = ntStatus;

	// free allocated urb
	ExFreePool(urb);

	Sample_KdPrint(("exit READ\n"));

    return (ntStatus);
}


NTSTATUS
Sample_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
     This is the Entry point for CreateFile calls from user mode apps (apps may open "\\.\Sample-x\yyzz"
     where yy is the interface number and zz is the endpoint address).

     Here is where you would add code to create symbolic links between endpoints
     (i.e., pipes in USB software terminology) and User Mode file names.  You are
     free to use any convention you wish to create these links, although the above
     convention offers a way to identify resources on a device by familiar file and
     directory structure nomenclature.

Arguments:
    DeviceObject - pointer to the device object for this instance of the Sample device

Return Value:
    NT status code
--*/
{
    NTSTATUS ntStatus;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    // Create all the symbolic links here
    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    return ntStatus;

}//Sample_Create


NTSTATUS
Sample_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
Routine Description:
    Entry point for CloseHandle calls from user mode apps to close handles they have opened

Arguments:
    DeviceObject - pointer to the device object for this instance of the Sample device
    Irp          - pointer to an irp

Return Value:
    NT status code

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    return ntStatus;
}//Sample_Close


NTSTATUS
Sample_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:
    This where all the DeviceIoControl codes are handled.  You can add more code
    here to handle IOCTL codes that are specific to your device driver.

Arguments:
    DeviceObject - pointer to the device object for this instance of the Sample device.

Return Value:
    NT status code
--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    ULONG ioControlCode;
    NTSTATUS ntStatus;
    ULONG length;
    PUCHAR pch;

    Sample_KdPrint (("IRP_MJ_DEVICE_CONTROL\n"));

    /*
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    */
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    /*
    // Get a pointer to the device extension
    */
    deviceExtension = DeviceObject->DeviceExtension;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    /*
    // Handle Ioctls from User mode
    */
    switch (ioControlCode) {

    case IOCTL_Sample_GET_PIPE_INFO:
        /*
        // inputs  - none
        // outputs - we copy the interface information structure that we have
        //           stored in our device extension area to the output buffer which
        //           will be reflected to the user mode application by the IOS.
        */
        length = 0;
        pch = (PUCHAR) ioBuffer;

        if (deviceExtension->Interface) {
            RtlCopyMemory(pch+length,
                          (PUCHAR) deviceExtension->Interface,
                          deviceExtension->Interface->Length);

            length += deviceExtension->Interface->Length;
        } /* if */


        Irp->IoStatus.Information = length;
        Irp->IoStatus.Status = STATUS_SUCCESS;

        break;

    case IOCTL_Sample_GET_DEVICE_DESCRIPTOR:
        /*
        // inputs  - pointer to a buffer in which to place descriptor data
        // outputs - we put the device descriptor data, if any is returned by the device
        //           in the system buffer and then we set the length inthe Information field
        //           in the Irp, which will then cause the system to copy the buffer back
        //           to the user's buffer
        */
        length = Sample_GetDeviceDescriptor (DeviceObject, ioBuffer);

        Sample_KdPrint(("Get Device Descriptor returned %d bytes\n", length));
        
        Irp->IoStatus.Information = length;
        Irp->IoStatus.Status = STATUS_SUCCESS;
      
        break;

    case IOCTL_Sample_GET_CONFIGURATION_DESCRIPTOR:
        /*
        // inputs  - pointer to a buffer in which to place descriptor data
        // outputs - we put the configuration descriptor data, if any is returned by the device
        //           in the system buffer and then we set the length in the Information field
        //           in the Irp, which will then cause the system to copy the buffer back
        //           to the user's buffer
        */
        length = Sample_GetConfigDescriptor (DeviceObject, ioBuffer, outputBufferLength);

        Sample_KdPrint(("Get Config Descriptor returned %d bytes\n", length));
        
        Irp->IoStatus.Information = length;
        Irp->IoStatus.Status = STATUS_SUCCESS;
      
        break;

    case IOCTL_Sample_BULK_OR_INTERRUPT_WRITE:
        /*
        // inputs  - pointer to the parameter block for this IOCTL.
        //           
        // outputs - A status field is filled in the header of the parameter block.
        //
        // assumptions:
        //          When we configured the device, we made a list of pipes to represent the endpoints
        //          on the device, in the order that the endpoint descriptors appeared in the configuration
        //          descriptor.  In this IOCTL, the application specifies the offset into that list of 
        //          pipes (this is an array, so it's zero-based indexing) and that is the pipe we will
        //          use for this transfer.  So, if the device has an OUTPUT endpoint as the second endpoint
        //          descriptor (ie., offset = 1 in the array) the app would specify a "1" in the pipe offset
        //          parameter for this IOCTL.
        //
        //  NOTE: It is currently ILLEGAL to perform interrupt OUT transfers on USB.  This IOCTL is named as it is
        //        just for symmetry with its IN counterpart's name.
        */
        
        if ((ioBuffer) && (inputBufferLength>=0) && (outputBufferLength>=0)) {
            Sample_KdPrint (("IOCTL_Sample_BULK_OR_INTERRUPT_WRITE\n"));
            Sample_Read_Write (DeviceObject, Irp, FALSE);
        }else {
            Sample_KdPrint (("IOCTL_Sample_BULK_OR_INTERRUPT_WRITE got INVALID buffer(s)!\n"));
            Sample_KdPrint (("ioBuffer: %x | inputBufferLength: %d | outputBufferLength: %d\n",
                              ioBuffer, inputBufferLength, outputBufferLength));
        }/*else bad pointer(s) received */
        
        break;

    case IOCTL_Sample_BULK_OR_INTERRUPT_READ:
        /*
        // inputs  - pointer to the parameter block for this IOCTL.
        //           
        // outputs - A status field is filled in the header of the parameter block.  The data
        //           returned from the device is copied into the data buffer section of the parameter block.
        //
        // assumptions:
        //          When we configured the device, we made a list of pipes to represent the endpoints
        //          on the device, in the order that the endpoint descriptors appeared in the configuration
        //          descriptor.  In this IOCTL, the application specifies the offset into that list of 
        //          pipes (this is an array, so it's zero-based indexing) and that is the pipe we will
        //          use for this transfer.  So, if the device has an INPUT endpoint as the first endpoint
        //          descriptor (ie., offset = 0 in the array) the app would specify a "0" in the pipe offset
        //          parameter for this IOCTL.
        */
        
        if ((ioBuffer) && (inputBufferLength>=0) && (outputBufferLength>=0)) {
            Sample_KdPrint (("IOCTL_Sample_BULK_OR_INTERRUPT_READ\n"));
            Sample_Read_Write (DeviceObject, Irp, TRUE);
        }else {
            Sample_KdPrint (("IOCTL_Sample_BULK_OR_INTERRUPT_READ got INVALID buffer(s)!\n"));
            Sample_KdPrint (("ioBuffer: %x | inputBufferLength: %d | outputBufferLength: %d\n",
                              ioBuffer, inputBufferLength, outputBufferLength));
        }/*else bad pointer(s) received */

        break;
        
    default:

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }/* switch on ioControlCode */

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp,
                       IO_NO_INCREMENT
                       );

    return ntStatus;

}


ULONG
Sample_GetDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID             pvOutputBuffer
    )
/*++
Routine Description:
    Gets a device descriptor from the given device object
    
Arguments:
    DeviceObject - pointer to the sample device object

Return Value:
    Number of valid bytes in data buffer  

--*/
{
    PDEVICE_EXTENSION   deviceExtension = NULL;
    NTSTATUS            ntStatus        = STATUS_SUCCESS;
    PURB                urb             = NULL;
    ULONG               length          = 0;
    
    Sample_KdPrint (("Enter Sample_GetDeviceDescriptor\n"));    

    deviceExtension = DeviceObject->DeviceExtension;
    
    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                         
    if (urb) {
        
        if (pvOutputBuffer) {    
        
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,    //descriptor type
                                         0,                             //index
                                         0,                             //language ID
                                         pvOutputBuffer,                //transfer buffer
                                         NULL,                          //MDL
                                         sizeof(USB_DEVICE_DESCRIPTOR), //buffer length
                                         NULL);                         //link
                                                                  
            ntStatus = Sample_CallUSBD(DeviceObject, urb);

        } else {
            ntStatus = STATUS_NO_MEMORY;
        }    

        // Get the length from the Urb
        length = urb->UrbControlDescriptorRequest.TransferBufferLength;

        Sample_KdPrint (("%d bytes of dev descriptor received\n",length));
        
        ExFreePool(urb);
        
    } else {
        ntStatus = STATUS_NO_MEMORY;        
    }        
    
    Sample_KdPrint (("Leaving Sample_GetDeviceDescriptor\n"));    

    return length;
}    

ULONG
Sample_GetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID             pvOutputBuffer,
    ULONG             ulLength
    )
/*++

Routine Description:
    Gets a configuration descriptor from the given device object
    
Arguments:
    DeviceObject    - pointer to the sample device object
    pvOutputBuffer  - pointer to the buffer where the data is to be placed
    ulLength        - length of the buffer

Return Value:
    Number of valid bytes in data buffer  

--*/
{
    PDEVICE_EXTENSION   deviceExtension = NULL;
    NTSTATUS            ntStatus        = STATUS_SUCCESS;
    PURB                urb             = NULL;
    ULONG               length          = 0;
    
    Sample_KdPrint (("Enter Sample_GetConfigurationDescriptor\n"));    

    deviceExtension = DeviceObject->DeviceExtension;
    
    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                         
    if (urb) {
        
        if (pvOutputBuffer) {    
        
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE, //descriptor type
                                         0,                             //index
                                         0,                             //language ID
                                         pvOutputBuffer,                //transfer buffer
                                         NULL,                          //MDL
                                         ulLength,                      //buffer length
                                         NULL);                         //link
                                                                  
            ntStatus = Sample_CallUSBD(DeviceObject, urb);

        } else {
            ntStatus = STATUS_NO_MEMORY;
        }    

        // Get the length from the Urb
        length = urb->UrbControlDescriptorRequest.TransferBufferLength;

        Sample_KdPrint (("%d bytes of cfg descriptor received\n",length));
        
        ExFreePool(urb);
        
    } else {
        ntStatus = STATUS_NO_MEMORY;        
    }        
    
    Sample_KdPrint (("Leaving Sample_GetConfigurationDescriptor\n"));    

    return length;
}    


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\sample\app\main.c ===
/*++

Copyright (c) 1996  Intel Corporation

Module Name:
    Main.c

Abstract:
    Sample Application to drive USB SAMPLE Device Driver

Environment:
    user mode only

Notes:
  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996  Intel Corporation  All Rights Reserved.

Revision History:

    10-30-96:  Version 1.0   Kosar Jaff  --  Intel Architecture Labs
        Initial Revision

    11-26-96:  Version 1.2   Kosar Jaff  --  Intel Architecture Labs
        Added support for Configuration Descriptor parsing
        Added skeleton support for Write/Read buttons (no code yet).


--*/

#include <windows.h>
#include <assert.h>

#include "resource.h"
#include "main.h"

#include "devioctl.h"
#include "sample.h"

HINSTANCE hGInstance = NULL;

BOOL CALLBACK bMainDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


/*******************************
*WinMain: Windows Entry point  *
********************************/
int PASCAL WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpCmdLine,
                   int       nCmdShow)
{
    hGInstance=hInstance;

    if(DialogBox(hInstance,"MAIN_DIALOG",NULL,(DLGPROC)bMainDlgProc)==-1)
	  MessageBox(NULL,"Unable to create root dialog!","DialogBox failure",MB_ICONSTOP);

	return 0;
}


/**************************************************
 * Main Dialog proc                               *
 **************************************************/

BOOL CALLBACK bMainDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    HWND    hOutputBox                      = NULL;
    HANDLE  hDevice                         = NULL;
    char    pcDriverName[MAX_DRIVER_NAME]   = "";
    BOOLEAN bResult                         = FALSE;
    int     nBytes                          = 0;
    PVOID   pvBuffer                        = 0;
    int     nItems                          = 0;
    HFONT   hFont                           = NULL;
    ULONG   ulLength                        = 0;

    switch(message)
    {
        case WM_INITDIALOG:
            // Get a handle to the output box
            hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);
            
            // Setup the std system font
            hFont = GetStockObject(SYSTEM_FONT);
            SendMessage (hOutputBox, WM_SETFONT, (WPARAM)hFont, MAKELPARAM(TRUE,0));
            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Sample App Version 1.2");
       
            // Setup the default symbolic name for the device driver           
            SetDlgItemText (hDlg, IDC_DRIVER_NAME, "Sample-0");

            // Setup the default Out/In Endpoint Indices
            // Note:  The order of the endpoints is dependenton the order of the endpoint descriptors
            //        in the device's configuration descriptor, and is arbitrary.
            SetDlgItemInt (hDlg, IDC_EDIT_OUT_EP_INDEX, 1, FALSE); 
            SetDlgItemInt (hDlg, IDC_EDIT_IN_EP_INDEX, 0, FALSE); 

            break; /*end WM_INITDIALOG case*/

	    case WM_COMMAND:
		    switch(LOWORD(wParam))
		    {

                case IDC_ABOUT:
                    MessageBox(hDlg,"Sample App 1.2 by Intel Corporation\nAuthor:  Kosar Jaff - IAL\nCopyright (C) 1996\nAll Rights Reserved","About Sample App",MB_ICONINFORMATION);
                    break;

                case IDOK:
                case IDCANCEL:
			        EndDialog(hDlg,0);
                    break;

                case IDC_GETDEVICEDESCRIPTOR:

                 
                    // Get some memory, plus some guardband area
                    pvBuffer = malloc (sizeof (Usb_Device_Descriptor) + 128);

                    // Get a handle to the output box
                    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

                    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                    // Get the text in the driver name edit box
                    GetDlgItemText (hDlg, IDC_DRIVER_NAME, pcDriverName, MAX_DRIVER_NAME);

                    // Open the driver
                    if (bOpenDriver (&hDevice, pcDriverName) == TRUE) {
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                    } else {
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                        hDevice = NULL;
                    }/* else */


                    if (hDevice != NULL) {

                        // Perform the Get-Descriptor IOCTL
                        bResult = DeviceIoControl (hDevice,
                                                   IOCTL_Sample_GET_DEVICE_DESCRIPTOR,
                                                   pvBuffer,
                                                   sizeof (Usb_Device_Descriptor),
                                                   pvBuffer,
                                                   sizeof (Usb_Device_Descriptor),
                                                   &nBytes,
                                                   NULL);

                    }/* if valid driver handle */

                    if (bResult==TRUE)
                        ParseDeviceDescriptor(pvBuffer, hOutputBox);
                    else
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Get Device Descriptor Failed");

                    // Close the handle
                    CloseHandle (hDevice);

                    // Free the memory
                    free (pvBuffer);

                    break;

                case IDC_GETCONFIGDESCRIPTOR:
                    
                    //
                    // The configuration descriptor is obtained using two separate calls.  The
                    // first call is done to determine the size of the entire configuration descriptor,
                    // and the second call is done with that total size specified.  For more information,
                    // please refer to the USB Specification, Chapter 9.
                    //

                    // Get some memory, plus some guardband area
                    pvBuffer = malloc (sizeof (Usb_Configuration_Descriptor) + 128);

                    // Get a handle to the output box
                    hOutputBox = GetDlgItem (hDlg, IDC_OUTPUT_BOX);

                    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                    // Get the text in the driver name edit box
                    GetDlgItemText (hDlg, IDC_DRIVER_NAME, pcDriverName, MAX_DRIVER_NAME);

                    // Open the driver
                    if (bOpenDriver (&hDevice, pcDriverName) == TRUE) {
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                    } else {
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                        hDevice = NULL;
                    }/* else */

                    //
                    // Get the first bytes of the configuration descriptor to determine the size of
                    // the entire configuration descriptor.
                    //
                    if (hDevice != NULL) {

                        // Perform the Get-Descriptor IOCTL
                        bResult = DeviceIoControl (hDevice,
                                                   IOCTL_Sample_GET_CONFIGURATION_DESCRIPTOR,
                                                   pvBuffer,
                                                   sizeof (Usb_Configuration_Descriptor),
                                                   pvBuffer,
                                                   sizeof (Usb_Configuration_Descriptor),
                                                   &nBytes,
                                                   NULL);

                    }/* if valid driver handle */

                    if (bResult!=TRUE) {
                        // Inform user of that something bad happened 
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Get Configuration Descriptor Failed");
                        
                        // Clean up and exit
                        CloseHandle (hDevice);
                        free (pvBuffer);
                        break;
                    }/* if */

                    ulLength = GET_CONFIG_DESCRIPTOR_LENGTH(pvBuffer);

                    assert (ulLength >= 0);

                    // Now get the entire configuration descriptor
                    pvBuffer = realloc (pvBuffer, ulLength);

                    if (pvBuffer) {
                        MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                        // Perform the Get-Descriptor IOCTL
                        bResult = DeviceIoControl (hDevice,
                                                   IOCTL_Sample_GET_CONFIGURATION_DESCRIPTOR,
                                                   pvBuffer,
                                                   ulLength,
                                                   pvBuffer,
                                                   ulLength,
                                                   &nBytes,
                                                   NULL);

                        if (bResult==TRUE) {
                            ParseConfigurationDescriptor(pvBuffer, hOutputBox);
                        } else {
                            // Inform user that the Ioctl failed
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"GetConfigDescriptor Ioctl failed");
                        }/* else */
                    
                    } else {
                        // Inform user that mem alloc failed
                        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Memory Allocation failed in GetConfigDescriptor");
                    }/* else */

                    // Close the handle
                    CloseHandle (hDevice);

                    // Free the memory
                    free (pvBuffer);
                    
                    break;

                case IDC_WRITE_BULK_DATA:
                    {
                        UINT    uiData = 0;
                        UINT    uiLength = 0;
                        char *  pcIoBuffer = NULL;
                        char    temp [32];
                        ULONG   ulWriteEndpoint = 1 ;

                        uiData = GetDlgItemInt (hDlg, IDC_EDIT_WRITE_DATA_VALUE, NULL, FALSE);
                        uiLength = GetDlgItemInt (hDlg, IDC_EDIT_WRITE_DATA_LENGTH, NULL, FALSE);
                        
                        if (uiLength <= MAX_BUFFER_SIZE) {
                            pcIoBuffer = malloc (uiLength + sizeof (ULONG));
                        }else{ 
                            MessageBox (hDlg, "Buffer size is too big!", "Sample App Error", MB_ICONEXCLAMATION);
                            break;
                        }/* else error in buffer size*/

                        memset (pcIoBuffer + sizeof(ULONG), uiData, uiLength);

                        // Get the User Input for the Endpoint Index
						ulWriteEndpoint = GetDlgItemInt (hDlg,IDC_EDIT_OUT_EP_INDEX, NULL, FALSE);

                        // First DWORD indicates the endpoint index
                        *(PULONG)pcIoBuffer = ulWriteEndpoint;

                        MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                        // Get the text in the driver name edit box
                        GetDlgItemText (hDlg, IDC_DRIVER_NAME, pcDriverName, MAX_DRIVER_NAME);

                        // Open the driver
                        if (bOpenDriver (&hDevice, pcDriverName) == TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                        } else {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                            hDevice = NULL;
                        }/* else */

                        if (hDevice != NULL) {
                            bResult = DeviceIoControl (hDevice,
                                                       IOCTL_Sample_BULK_OR_INTERRUPT_WRITE, 
                                                       pcIoBuffer,
                                                       uiLength + sizeof (ULONG),
                                                       pcIoBuffer,
                                                       uiLength + sizeof (ULONG),
                                                       &nBytes,
                                                       NULL);

                            if (bResult == TRUE) {
                                SendMessage (hOutputBox, LB_ADDSTRING, 0 , (LPARAM)"Write IOCTL passed");
                                wsprintf (temp, "Wrote %d bytes", *(PULONG)pcIoBuffer);
                            } else {
                                SendMessage (hOutputBox, LB_ADDSTRING, 0 , (LPARAM)"Write IOCTL failed");
                            }/* else ioctl failed */

                        }// if valid hDevice

                    }
                    break;

                case IDC_READ_BULK_DATA:
                    {
                        UINT    uiLength = 0;
                        char *  pcIoBuffer = NULL;
                        char    temp [32];
                        ULONG   ulReadEndpoint = 0 ;

                        // Get the User Input for the Endpoint Index
						ulReadEndpoint = GetDlgItemInt (hDlg,IDC_EDIT_IN_EP_INDEX, NULL, FALSE);

						// Get the length of data the user wants to read from the device
                        uiLength = GetDlgItemInt (hDlg, IDC_EDIT_READ_DATA_LENGTH, NULL, FALSE);
                        
                        if (uiLength <= MAX_BUFFER_SIZE) {
                            pcIoBuffer = malloc (uiLength + sizeof (ULONG));
                        }else{ 
                            MessageBox (hDlg, "Buffer size is too big!", "Sample App Error", MB_ICONEXCLAMATION);
                            break;
                        }/* else error in buffer size*/

                        // First DWORD indicates the endpoint index
                        *(PULONG)pcIoBuffer = ulReadEndpoint;

                        MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

                        // Get the text in the driver name edit box
                        GetDlgItemText (hDlg, IDC_DRIVER_NAME, pcDriverName, MAX_DRIVER_NAME);

                        // Open the driver
                        if (bOpenDriver (&hDevice, pcDriverName) == TRUE) {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Opened Driver Successfully");
                        } else {
                            SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)"Failed to Open Driver");
                            hDevice = NULL;
                        }/* else */

                        if (hDevice != NULL) {
                            bResult = DeviceIoControl (hDevice,
                                                       IOCTL_Sample_BULK_OR_INTERRUPT_READ, 
                                                       pcIoBuffer,
                                                       uiLength + sizeof (ULONG),
                                                       pcIoBuffer,
                                                       uiLength + sizeof (ULONG),
                                                       &nBytes,
                                                       NULL);

                            if (bResult == TRUE) {
                                wsprintf (temp, "Read %d bytes",*(PULONG)pcIoBuffer);
                                SendMessage (hOutputBox, LB_ADDSTRING, 0 , (LPARAM)temp);
                             } else {
                                SendMessage (hOutputBox, LB_ADDSTRING, 0 , (LPARAM)"READ IOCTL failed");
                            }/* else ioctl failed */

                        }// if valid hDevice

                    }
                    break;

		    } /*end switch wParam*/
		
	    break;


    } /*end switch message*/

    return FALSE;

} /*end MainDlgProc*/

/**************************************************
 * bOpenDriver proc                               *
 *                                                *
 * Purpose:                                       *  
 *      Opens the device driver using symbolic    *
 *      name provided                             *
 *                                                *
 * Input:                                         *
 *      phDeviceHandle:                           *
 *          Pointer to Device Driver handle where *
 *          the file handle is placed.            *
 *      devname:                                  *
 *          Null terminated string containing the *
 *          device name                           *
 *                                                *
 * Return Value:                                  *
 *      Boolean that indicates if the driver was  *
 *      successfully opened or not.               *
 *                                                *
 **************************************************/

BOOLEAN
bOpenDriver (HANDLE * phDeviceHandle, PCHAR devname)
{
    char completeDeviceName[64] = "";
    char pcMsg[64] = "";

    strcat (completeDeviceName,
            "\\\\.\\"
            );

    strcat (completeDeviceName,
		    devname
		    );

    *phDeviceHandle = CreateFile(   completeDeviceName,
		                            GENERIC_WRITE,
		                            FILE_SHARE_WRITE,
		                            NULL,
		                            OPEN_EXISTING,
		                            0,
		                            NULL);

    if (*phDeviceHandle == INVALID_HANDLE_VALUE) {
        return (FALSE);
    } else {
        return (TRUE);
    } /*else*/


}//OpenDevice


/**************************************************
 * ParseDeviceDescriptor proc                     *
 *                                                *
 * Purpose:                                       *  
 *      Parses the device descriptor data and     *
 *      displays the interpretation to the        *
 *      windows specified                         *
 *                                                * 
 * Input:                                         *
 *      pvBuffer:                                 * 
 *          Pointer to a buffer that contains the *
 *          raw device descriptor data.           *
 *      hOutputBox:                               *
 *          Handle to the window where the        *
 *          resultant interpreted data is to go.  *
 *                                                *
 * Return Value:                                  *
 *          None                                  *
 **************************************************/
void
ParseDeviceDescriptor(PVOID pvBuffer, HWND hOutputBox)
{
    pUsb_Device_Descriptor pDevDescr = (pUsb_Device_Descriptor) pvBuffer;
    int                    nItems    = 0;
    char                   temp[64]  = "";

    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);
    
    wsprintf (temp, "Device Descriptor:  ");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bLength:  %d", pDevDescr->bLength);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDescriptorType:  %d", pDevDescr->bDescriptorType);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bcdUSB:  %d", pDevDescr->bcdUSB);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDeviceClass:  %#x", pDevDescr->bDeviceClass);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDeviceSubClass:  %#x", pDevDescr->bDeviceSubClass);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDeviceProtocol:  %#x", pDevDescr->bDeviceProtocol);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bMaxPacketSize0:  %#x", pDevDescr->bMaxPacketSize0);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "idVendor:  %#x", pDevDescr->idVendor);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "idProduct:  %#x", pDevDescr->idProduct);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bcdDevice:  %#x", pDevDescr->bcdDevice);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "iManufacturer:  %#x", pDevDescr->iManufacturer);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "iProduct:  %#x", pDevDescr->iProduct);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "iSerialNumber:  %#x", pDevDescr->iSerialNumber);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bNumConfigurations:  %#x", pDevDescr->bNumConfigurations);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

}/* ParseDeviceDescriptor */ 


/**************************************************
 * ParseConfigurationDescriptor proc              *
 *                                                *
 * Purpose:                                       *  
 *      Parses the config descriptor data and     *
 *      displays the interpretation to the        *
 *      windows specified                         *
 *                                                * 
 * Input:                                         *
 *      pvBuffer:                                 * 
 *          Pointer to a buffer that contains the *
 *          raw device descriptor data.           *
 *      hOutputBox:                               *
 *          Handle to the window where the        *
 *          resultant interpreted data is to go.  *
 *                                                *
 * Return Value:                                  *
 *          None                                  *
 **************************************************/
 
void
ParseConfigurationDescriptor(PVOID pvBuffer, HWND hOutputBox)
{
    pUsb_Configuration_Descriptor pCD = (pUsb_Configuration_Descriptor) pvBuffer;
    pUsb_Interface_Descriptor     pID = NULL; 
    pUsb_Endpoint_Descriptor      pED = NULL;
    
    int                    nItems    = 0;
    char                   temp[64]  = "";
    int                    i         = 0;

    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);
    
    wsprintf (temp, "Config Descriptor:  ");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bLength: 0x%x", pCD->bLength);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDescriptorType:  %d", pCD->bDescriptorType);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "wTotalLength:  %d (0x%x)", pCD->wTotalLength, pCD->wTotalLength);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bNumInterfaces:  %d", pCD->bNumInterfaces);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bConfigurationValue:  %d", pCD->bConfigurationValue);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "iConfiguration:  %d", pCD->iConfiguration);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bmAttributes: 0x%x", pCD->bmAttributes);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "MaxPower:  %d", pCD->MaxPower);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "*********************************");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    // Interface Descriptor
    pID = (pUsb_Interface_Descriptor) (((char*)pCD) + pCD->bLength);

    MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);

    wsprintf (temp, "Interface Descriptor:  ");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "--------------------------------");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);
    
    wsprintf (temp, "bLength:  0x%x", pID->bLength);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bDescriptorType:  %d", pID->bDescriptorType);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bInterfaceNumber:  %d", pID->bInterfaceNumber);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bAlternateSetting:  %d", pID->bAlternateSetting);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bNumEndpoints:  %d", pID->bNumEndpoints);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bInterfaceClass:  %d (0x%x)", pID->bInterfaceClass, pID->bInterfaceClass);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bInterfaceSubClass:  %d (0x%x)", pID->bInterfaceSubClass, pID->bInterfaceSubClass);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "bInterfaceProtocol:  %d (0x%x)", pID->bInterfaceProtocol, pID->bInterfaceProtocol);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "iInterface:  %d", pID->iInterface);
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    wsprintf (temp, "*********************************");
    SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

    // Endpoint Descriptor
    pED = (pUsb_Endpoint_Descriptor) (((char*)pID) + pID->bLength);

    for (i=0;i<pID->bNumEndpoints;i++) {

        MAINTAIN_OUTPUT_BOX (hOutputBox, nItems);
		
		pED = (pUsb_Endpoint_Descriptor) (((char*)pED) + i*(pED->bLength));

        wsprintf (temp, "Endpoint Descriptor %d  ", i);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "--------------------------------");
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "bLength:  0x%x", pED->bLength);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "bDescriptorType:  %d", pED->bDescriptorType);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "bEndpointAddress:  0x%x", pED->bEndpointAddress);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);
    
        wsprintf (temp, "bmAttributes:  0x%x", pED->bmAttributes);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "wMaxPacketSize:  %d", pED->wMaxPacketSize);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);

        wsprintf (temp, "bInterval:  %d", pED->bInterval);
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);
    
        wsprintf (temp, "*********************************");
        SendMessage (hOutputBox, LB_ADDSTRING, 0, (LPARAM)temp);
   
    }/* for */

}/* ParseConfigurationDescriptor */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\sample\sample.h ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1996  Intel Corporation

Module Name:

    Sample.h

Abstract:
        Header file for the Sample USB Device Driver


Environment:

    Kernel & user mode

Revision History:

        8-15-96 : created by Kosar Jaff


--*/

#ifdef DRIVER

#define Sample_NAME_MAX  64


//modes
#define Sample_MODE_USE_POOL    0
#define Sample_MODE_USE_MDL     1

//options
#define Sample_OPT_NONE         0

/*
// This is an unused structure in this driver, but is provided here
// so when you extend the driver to deal with USB pipes, you may wish
// to use this structure as an example or model.
*/
typedef struct _Sample_PIPE {
    ULONG Mode;
    ULONG Option;
    ULONG Param1;
    ULONG Param2;
    PUSBD_PIPE_INFORMATION PipeInfo;
} Sample_PIPE, *PSample_PIPE;


/*
// The interface number on this device that this driver expects to use
// This would be in the bInterfaceNumber field of the Interface Descriptor, hence
// this device driver would need to know this value.
*/
#define SAMPLE_INTERFACE_NBR 0x00

// This driver supports only interface
#define MAX_INTERFACE 0x01

//
// A structure representing the instance information associated with
// this particular device.
//
typedef struct _DEVICE_EXTENSION {

    // physical device object
    PDEVICE_OBJECT PhysicalDeviceObject;        

    // Device object we call when submitting Urbs/Irps to the USB stack
    PDEVICE_OBJECT		StackDeviceObject;		

    // Indicates that we have recieved a STOP message
    BOOLEAN Stopped;

        // Indicates the device needs to be cleaned up (ie., some configuration
        // has occurred and needs to be torn down).
        BOOLEAN NeedCleanup;

    // configuration handle for the configuration the
    // device is currently in
    USBD_CONFIGURATION_HANDLE ConfigurationHandle;

    // ptr to the USB device descriptor
    // for this device
    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor;

    // we support up to one interface
    PUSBD_INTERFACE_INFORMATION Interface;

    // Name buffer for our named Functional device object link
    WCHAR DeviceLinkNameBuffer[Sample_NAME_MAX];

        UCHAR pad[3];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#if DBG

#define Sample_KdPrint(_x_) DbgPrint("Sample.SYS: "); \
                             DbgPrint _x_ ;
#define TRAP() DbgBreakPoint()
#else
#define Sample_KdPrint(_x_)
#define TRAP()
#endif

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

NTSTATUS
Sample_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
Sample_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
Sample_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Sample_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Sample_RemoveDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Sample_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

NTSTATUS
Sample_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
Sample_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    LONG Instance
    );

NTSTATUS
Sample_ConfigureDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
Sample_Create(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sample_Close(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sample_Read_Write (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN  BOOLEAN Read
    );

NTSTATUS
Sample_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
Sample_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface
    );

//PUSB_CONFIGURATION_DESCRIPTOR
//Sample_GetConfigDescriptor(
//    IN PDEVICE_OBJECT DeviceObject
//    );


VOID
Sample_Cleanup(
    PDEVICE_OBJECT DeviceObject
    );

ULONG
Sample_GetDeviceDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID             pvOutputBuffer
    );

ULONG
Sample_GetConfigDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    PVOID             pvOutputBuffer,
    ULONG             ulLength
    );

#endif      //DRIVER section


/*
///////////////////////////////////////////////////////
//
//              IOCTL Definitions
//
// User mode applications wishing to send IOCTLs to a kernel mode driver
// must use this file to set up the correct type of IOCTL code permissions.
//
// Note: this file depends on the file DEVIOCTL.H which contains the macro
// definition for "CTL_CODE" below.  Include that file before  you include
// this one in your source code.
//
///////////////////////////////////////////////////////
*/

/*
// Set the base of the IOCTL control codes.  This is somewhat of an
// arbitrary base number, so you can change this if you want unique
// IOCTL codes.  You should consult the Windows NT DDK for valid ranges
// of IOCTL index codes before you choose a base index number.
*/

#define Sample_IOCTL_INDEX  0x0800


#define IOCTL_Sample_GET_PIPE_INFO     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   Sample_IOCTL_INDEX+0,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_Sample_GET_DEVICE_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   Sample_IOCTL_INDEX+1,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_Sample_GET_CONFIGURATION_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   Sample_IOCTL_INDEX+2,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_Sample_BULK_OR_INTERRUPT_WRITE     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   Sample_IOCTL_INDEX+3,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

#define IOCTL_Sample_BULK_OR_INTERRUPT_READ      CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                   Sample_IOCTL_INDEX+4,\
                                                   METHOD_BUFFERED,  \
                                                   FILE_ANY_ACCESS)

/*
// To add more IOCTLs, make sure you add a different offset to the
// Sample_IOCTL_INDEX value in the CTL_CODE macro.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\selsusp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.c

Abstract:

    This module contains code for a generic client driver that can be loaded 
    for all USB devices/child interfaces.

Author:

Environment:

    kernel mode only

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSUsr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"

//
// Globals
//

GLOBALS Globals;
ULONG   DebugLevel = 1;

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    );

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SS_DriverUnload)
#pragma alloc_text(PAGE, SS_DispatchCreate)
#pragma alloc_text(PAGE, SS_DispatchClose)
#endif
#endif

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING UniRegistryPath
    )
/*++ 

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.    

Arguments:
    
    DriverObject - pointer to driver object 

    RegistryPath - pointer to a unicode string representing the path to driver 
                   specific key in the registry.

Return Values:

    NT status code
    
--*/
{

    NTSTATUS        ntStatus;
    PUNICODE_STRING registryPath;
    
    //
    // initialization of variables
    //

    registryPath = &Globals.SSRegistryPath;

    //
    // Allocate pool to hold a null-terminated copy of the path.
    // Safe in paged pool since all registry routines execute at
    // PASSIVE_LEVEL.
    //

    registryPath->MaximumLength = UniRegistryPath->Length + sizeof(UNICODE_NULL);
    registryPath->Length        = UniRegistryPath->Length;
    registryPath->Buffer        = ExAllocatePool(PagedPool,
                                                 registryPath->MaximumLength);

    if (!registryPath->Buffer) {

        SSDbgPrint(1, ("Failed to allocate memory for registryPath\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto DriverEntry_Exit;
    } 


    RtlZeroMemory (registryPath->Buffer, 
                   registryPath->MaximumLength);
    RtlMoveMemory (registryPath->Buffer, 
                   UniRegistryPath->Buffer, 
                   UniRegistryPath->Length);

    ntStatus = STATUS_SUCCESS;

    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = SS_DispatchDevCtrl;
    DriverObject->MajorFunction[IRP_MJ_POWER]          = SS_DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]            = SS_DispatchPnP;
    DriverObject->MajorFunction[IRP_MJ_CREATE]         = SS_DispatchCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]          = SS_DispatchClose;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP]        = SS_DispatchClean;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = SS_DispatchSysCtrl;
    DriverObject->DriverUnload                         = SS_DriverUnload;
    DriverObject->DriverExtension->AddDevice           = (PDRIVER_ADD_DEVICE)
                                                         SS_AddDevice;
DriverEntry_Exit:

    return ntStatus;
}

VOID
SS_DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Description:

    This function will free the memory allocations in DriverEntry.

Arguments:

    DriverObject - pointer to driver object 

Return:
	
    None

--*/
{
    PUNICODE_STRING registryPath;

    SSDbgPrint(3, ("SS_DriverUnload - begins\n"));

    registryPath = &Globals.SSRegistryPath;

    if(registryPath->Buffer) {

        ExFreePool(registryPath->Buffer);
        registryPath->Buffer = NULL;
    }

    SSDbgPrint(3, ("SS_DriverUnload - ends\n"));

    return;
}

NTSTATUS
SS_AddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Description:

Arguments:

    DriverObject - Store the pointer to the object representing us.

    PhysicalDeviceObject - Pointer to the device object created by the
                           undelying bus driver.

Return:
	
    STATUS_SUCCESS - if successful 
    STATUS_UNSUCCESSFUL - otherwise

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    POWER_STATE       state;
    KIRQL             oldIrql;

    SSDbgPrint(3, ("SS_AddDevice - begins\n"));

    deviceObject = NULL;

    ntStatus = IoCreateDevice(
                    DriverObject,                   // our driver object
                    sizeof(DEVICE_EXTENSION),       // extension size for us
                    NULL,                           // name for this device
                    FILE_DEVICE_UNKNOWN,
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                          // Not exclusive
                    &deviceObject);                 // Our device object

    if(!NT_SUCCESS(ntStatus)) {
        //
        // returning failure here prevents the entire stack from functioning,
        // but most likely the rest of the stack will not be able to create
        // device objects either, so it is still OK.
        //        
        SSDbgPrint(1, ("Failed to create device object\n"));
        return ntStatus;
    }

    //
    // Initialize the device extension
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FunctionalDeviceObject = deviceObject;
    deviceExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    deviceObject->Flags |= DO_BUFFERED_IO;

    //
    // initialize the device state lock and set the device state
    //

    KeInitializeSpinLock(&deviceExtension->DevStateLock);
    INITIALIZE_PNP_STATE(deviceExtension);

    //
    //initialize OpenHandleCount
    //
    deviceExtension->OpenHandleCount = 0;

    //
    // Initialize the selective suspend variables
    //
    KeInitializeSpinLock(&deviceExtension->IdleReqStateLock);
    deviceExtension->IdleReqPend = 0;
    deviceExtension->PendingIdleIrp = NULL;

    //
    // Hold requests until the device is started
    //

    deviceExtension->QueueState = HoldRequests;

    //
    // Initialize the queue and the queue spin lock
    //

    InitializeListHead(&deviceExtension->NewRequestsQueue);
    KeInitializeSpinLock(&deviceExtension->QueueLock);

    //
    // Initialize the remove event to not-signaled.
    //

    KeInitializeEvent(&deviceExtension->RemoveEvent, 
                      SynchronizationEvent, 
                      FALSE);

    //
    // Initialize the stop event to signaled.
    // This event is signaled when the OutstandingIO becomes 1
    //

    KeInitializeEvent(&deviceExtension->StopEvent, 
                      SynchronizationEvent, 
                      TRUE);

    //
    // OutstandingIo count biased to 1.
    // Transition to 0 during remove device means IO is finished.
    // Transition to 1 means the device can be stopped
    //

    deviceExtension->OutStandingIO = 1;
    KeInitializeSpinLock(&deviceExtension->IOCountLock);

    //
    // Delegating to WMILIB
    //
    ntStatus = SSWmiRegistration(deviceExtension);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("SSWmiRegistration failed with %X\n", ntStatus));
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    //
    // set the flags as underlying PDO
    //

    if(PhysicalDeviceObject->Flags & DO_POWER_PAGABLE) {

        deviceObject->Flags |= DO_POWER_PAGABLE;
    }

    //
    // Typically, the function driver for a device is its 
    // power policy owner, although for some devices another 
    // driver or system component may assume this role. 
    // Set the initial power state of the device, if known, by calling 
    // PoSetPowerState.
    // 
    deviceExtension->DevPower = PowerDeviceD0;
    deviceExtension->SysPower = PowerSystemWorking;

    state.DeviceState = PowerDeviceD0;
    PoSetPowerState(deviceObject, DevicePowerState, state);

    //
    // attach our driver to device stack
    // The return value of IoAttachDeviceToDeviceStack is the top of the
    // attachment chain.  This is where all the IRPs should be routed.
    //
    deviceExtension->TopOfStackDeviceObject = 
                IoAttachDeviceToDeviceStack(deviceObject,
                                            PhysicalDeviceObject);

    if(NULL == deviceExtension->TopOfStackDeviceObject) {

        SSWmiDeRegistration(deviceExtension);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }
        
    //
    // Register device interfaces
    //

    ntStatus = IoRegisterDeviceInterface(deviceExtension->PhysicalDeviceObject, 
                                         &GUID_GENERIC_SELECTIVE_SUSPEND, 
                                         NULL, 
                                         &deviceExtension->InterfaceName);

    if(!NT_SUCCESS(ntStatus)) {

        SSWmiDeRegistration(deviceExtension);
        IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
        IoDeleteDevice(deviceObject);
        return ntStatus;
    }

    if(IoIsWdmVersionAvailable(1, 0x20)) {

        deviceExtension->WdmVersion = WinXpOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x10)) {

        deviceExtension->WdmVersion = Win2kOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x5)) {

        deviceExtension->WdmVersion = WinMeOrBetter;
    }
    else if(IoIsWdmVersionAvailable(1, 0x0)) {

        deviceExtension->WdmVersion = Win98OrBetter;
    }

    deviceExtension->SSRegistryEnable = 0;
    deviceExtension->SSEnable = 0;

    //
    // Win XP only
    // check the registry flag -  
    // whether the device should selectively 
    // suspend when idle
    //

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        SS_GetRegistryDword(SELSUSP_REGISTRY_PARAMETERS_PATH,
                            L"SelectSuspendEnable",
                            &deviceExtension->SSRegistryEnable);

        if(deviceExtension->SSRegistryEnable) {
    
            //
            // initialize the DPC 
            //
            KeInitializeDpc(&deviceExtension->DeferredProcCall, 
                            DpcRoutine, 
                            deviceObject);

            //
            // initialize the timer.
            // the DPC and the timer in conjunction, 
            // monitor the state of the device to 
            // selectively suspend the device.
            //
            KeInitializeTimerEx(&deviceExtension->Timer,
                                NotificationTimer);

            //
            // Initialize the NoDpcWorkItemPendingEvent to signaled state.
            // This event is cleared when a Dpc is fired and signaled
            // on completion of the work-item.
            //
            KeInitializeEvent(&deviceExtension->NoDpcWorkItemPendingEvent, 
                              NotificationEvent, 
                              TRUE);

            //  
            // Initialize the NoIdleReqPendEvent to ensure that the idle request
            // is indeed complete before we unload the drivers.
            //
            KeInitializeEvent(&deviceExtension->NoIdleReqPendEvent,
                              NotificationEvent,
                              TRUE);
        }
    }

    //
    // Clear the DO_DEVICE_INITIALIZING flag.
    // Note: Do not clear this flag until the driver has set the
    // device power state and the power DO flags. 
    //
    deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    SSDbgPrint(3, ("SS_AddDevice - ends\n"));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\sample\app\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sampapp.rc
//
#define IDC_ABOUT                       1000
#define IDC_GETDEVICEDESCRIPTOR         1001
#define IDC_EDIT1                       1002
#define IDC_EDIT_WRITE_DATA_VALUE       1002
#define IDC_GETCONFIGDESCRIPTOR         1003
#define IDC_DRIVER_NAME                 1004
#define IDC_OUTPUT_BOX                  1005
#define IDC_WRITE_BULK_DATA             1006
#define IDC_READ_BULK_DATA              1007
#define IDC_EDIT_WRITE_DATA_LENGTH      1008
#define IDC_EDIT_OUT_EP_INDEX           1009
#define IDC_EDIT_READ_DATA_LENGTH       1010
#define IDC_EDIT_IN_EP_INDEX            1011
#define IDC_STATIC						-1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sspwr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPwr.h

Abstract:

Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __POWER_H
#define __POWER_H

typedef struct _POWER_COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           SIrp;
} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;

typedef struct _WORKER_THREAD_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP           Irp;
    PIO_WORKITEM   WorkItem;
} WORKER_THREAD_CONTEXT, *PWORKER_THREAD_CONTEXT;

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    );

NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject, 
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP                  Irp
    );

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\ssusr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSUsr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef _SEL_SUSPEND_USER_H
#define _SEL_SUSPEND_USER_H

// {6068EB61-98E7-4c98-9E20-1F068295909A}
DEFINE_GUID(GUID_GENERIC_SELECTIVE_SUSPEND, 
0x6068eb61, 0x98e7, 0x4c98, 0x9e, 0x20, 0x1f, 0x6, 0x82, 0x95, 0x90, 0x9a);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\ssdevctr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.c

Abstract:

    This file contains dispatch routines 
    for create and close. This file also 
    contains routines to selectively suspend 
    the device. The selective suspend feature
    is usb specific and not hardware specific.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSUsr.h"
#include "sSWmi.h"

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for create.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchCreate - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    //
    // increment OpenHandleCounts
    //
    InterlockedIncrement(&deviceExtension->OpenHandleCount);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // the device is idle if it has no open handles or pending PnP Irps
    // since this is create request, cancel idle req. if any
    //
    if(deviceExtension->SSEnable) {
    
        CancelSelectSuspend(deviceExtension);
    }

    SSDbgPrint(3, ("SS_DispatchCreate - ends\n"));
    
    return ntStatus;
}

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for close.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    PAGED_CODE();

    SSDbgPrint(3, ("SS_DispatchClose - begins\n"));
    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // set ntStatus to STATUS_SUCCESS 
    //
    ntStatus = STATUS_SUCCESS;

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    InterlockedDecrement(&deviceExtension->OpenHandleCount);

    SSDbgPrint(3, ("SS_DispatchClose - ends\n"));

    return ntStatus;
}

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    ULONG              code;
    PVOID              ioBuffer;
    ULONG              inputBufferLength;
    ULONG              outputBufferLength;
    ULONG              info;
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    code = irpStack->Parameters.DeviceIoControl.IoControlCode;
    info = 0;

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
	
    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoIncrement(deviceExtension);

    switch(code) {

    default :

        ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = info;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchDevCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine builds an idle request irp with an associated callback routine
    and a completion routine in the driver and passes the irp down the stack.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    PIRP                    irp;
    NTSTATUS                ntStatus;
    KIRQL                   oldIrql;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;
    PIO_STACK_LOCATION      nextStack;

    //
    // initialize variables
    //
    
    irp = NULL;
    idleCallbackInfo = NULL;

    SSDbgPrint(3, ("SubmitIdleRequestIrp - begins\n"));

    //
    // if the device is not in a D0 power state,
    // budge out..
    //
    if(PowerDeviceD0 != DeviceExtension->DevPower) {

        ntStatus = STATUS_POWER_STATE_INVALID;

        goto SubmitIdleRequestIrp_Exit;
    }

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(InterlockedExchange(&DeviceExtension->IdleReqPend, 1)) {

        SSDbgPrint(1, ("Idle request pending..\n"));

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_DEVICE_BUSY;

        goto SubmitIdleRequestIrp_Exit;
    }

    //
    // clear the NoIdleReqPendEvent because we are about 
    // to submit an idle request. Since we are so early
    // to clear this event, make sure that if we fail this
    // request we set back the event.
    //
    KeClearEvent(&DeviceExtension->NoIdleReqPendEvent);

    idleCallbackInfo = ExAllocatePool(NonPagedPool, 
                                      sizeof(struct _USB_IDLE_CALLBACK_INFO));

    if(idleCallbackInfo) {

        idleCallbackInfo->IdleCallback = IdleNotificationCallback;

        idleCallbackInfo->IdleContext = (PVOID)DeviceExtension;

        ASSERT(DeviceExtension->IdleCallbackInfo == NULL);

        DeviceExtension->IdleCallbackInfo = idleCallbackInfo;

        //
        // we use IoAllocateIrp to create an irp to selectively suspend the 
        // device. This irp lies pending with the hub driver. When appropriate
        // the hub driver will invoked callback, where we power down. The completion
        // routine is invoked when we power back.
        //
        irp = IoAllocateIrp(DeviceExtension->TopOfStackDeviceObject->StackSize,
                            FALSE);

        if(irp == NULL) {

            SSDbgPrint(1, ("cannot build idle request irp\n"));

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            ExFreePool(idleCallbackInfo);

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            goto SubmitIdleRequestIrp_Exit;
        }

        nextStack = IoGetNextIrpStackLocation(irp);

        nextStack->MajorFunction = 
                    IRP_MJ_INTERNAL_DEVICE_CONTROL;

        nextStack->Parameters.DeviceIoControl.IoControlCode = 
                    IOCTL_INTERNAL_USB_SUBMIT_IDLE_NOTIFICATION;

        nextStack->Parameters.DeviceIoControl.Type3InputBuffer =
                    idleCallbackInfo;

        nextStack->Parameters.DeviceIoControl.InputBufferLength =
                    sizeof(struct _USB_IDLE_CALLBACK_INFO);


        IoSetCompletionRoutine(irp, 
                               IdleNotificationRequestComplete,
                               DeviceExtension, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        DeviceExtension->PendingIdleIrp = irp;

        //
        // we initialize the count to 2.
        // The reason is, if the CancelSelectSuspend routine manages
        // to grab the irp from the device extension, then the last of the
        // CancelSelectSuspend routine/IdleNotificationRequestComplete routine 
        // to execute will free this irp. We need to have this schema so that
        // 1. completion routine does not attempt to touch the irp freed by 
        //    CancelSelectSuspend routine.
        // 2. CancelSelectSuspend routine doesnt wait for ever for the completion
        //    routine to complete!
        //
        DeviceExtension->FreeIdleIrpCount = 2;

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        //
        // check if the device is idle.
        // A check here ensures that a race condition did not 
        // completely reverse the call sequence of SubmitIdleRequestIrp
        // and CancelSelectiveSuspend
        //

        if(!CanDeviceSuspend(DeviceExtension) ||
           PowerDeviceD0 != DeviceExtension->DevPower) {

            //
            // device cannot suspend - abort.
            // also irps created using IoAllocateIrp 
            // needs to be deallocated.
            //
     
            SSDbgPrint(1, ("Device cannot selectively suspend - abort\n"));

            KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

            DeviceExtension->IdleCallbackInfo = NULL;

            DeviceExtension->PendingIdleIrp = NULL;

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);

            InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

            KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

            if(idleCallbackInfo) {

                ExFreePool(idleCallbackInfo);
            }

            //
            // it is still safe to touch the local variable "irp" here.
            // the irp has not been passed down the stack, the irp has
            // no cancellation routine. The worse position is that the
            // CancelSelectSuspend has run after we released the spin 
            // lock above. It is still essential to free the irp.
            //
            if(irp) {

                IoFreeIrp(irp);
            }

            goto SubmitIdleRequestIrp_Exit;
        }

        SSDbgPrint(3, ("Cancelling the timer...\n"));

        //
        // Cancel the timer so that the DPCs are no longer fired.
        // Thus, we are making judicious usage of our resources.
        // we do not need DPCs because we already have an idle irp pending.
        // The timers are re-initialized in the completion routine.
        //
        KeCancelTimer(&DeviceExtension->Timer);

        SSDbgPrint(3, ("Submit an idle request at power state PowerDeviceD%X\n",
                       DeviceExtension->DevPower - 1))

        ntStatus = IoCallDriver(DeviceExtension->TopOfStackDeviceObject, irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoCallDriver failed\n"));

            goto SubmitIdleRequestIrp_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Memory allocation for idleCallbackInfo failed\n"));

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

        KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

SubmitIdleRequestIrp_Exit:

    SSDbgPrint(3, ("SubmitIdleRequestIrp - ends\n"));

    return ntStatus;
}


VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  "A pointer to a callback function in your driver is passed down the stack with
   this IOCTL, and it is this callback function that is called by USBHUB when it
   safe for your device to power down."

  "When the callback in your driver is called, all you really need to do is to
   to first ensure that a WaitWake Irp has been submitted for your device, if 
   remote wake is possible for your device and then request a SetD2 (or DeviceWake)"

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KEVENT                  irpCompletionEvent;
    PIRP_COMPLETION_CONTEXT irpContext;

    SSDbgPrint(1, ("IdleNotificationCallback - begins\n"));

    //
    // Dont idle, if the device was just disconnected or being stopped
    // i.e. return for the following DeviceState(s)
    // NotStarted, Stopped, PendingStop, PendingRemove, SurpriseRemoved, Removed
    //

    if(DeviceExtension->DeviceState != Working) {

        return;
    }

    //
    // If there is not already a WW IRP pending, submit one now
    //
    if(DeviceExtension->WaitWakeEnable) {

        IssueWaitWake(DeviceExtension);
    }


    //
    // power down the device
    //

    irpContext = (PIRP_COMPLETION_CONTEXT) 
                 ExAllocatePool(NonPagedPool,
                                sizeof(IRP_COMPLETION_CONTEXT));

    if(!irpContext) {

        SSDbgPrint(1, ("Failed to alloc memory for irpContext\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        //
        // increment the count. In the HoldIoRequestWorkerRoutine, the
        // count is decremented twice (one for the system Irp and the 
        // other for the device Irp. An increment here compensates for 
        // the sytem irp..The decrement corresponding to this increment 
        // is in the completion function
        //

        SSDbgPrint(3, ("IdleNotificationCallback::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = DeviceExtension->PowerDownLevel;

        KeInitializeEvent(&irpCompletionEvent, NotificationEvent, FALSE);

        irpContext->DeviceExtension = DeviceExtension;
        irpContext->Event = &irpCompletionEvent;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpCompletionFunc,
                          irpContext, 
                          NULL);

        //
        // if PoRequestPowerIrp returns a failure, we will release memory below
        //

        if(STATUS_PENDING == ntStatus) {

            SSDbgPrint(3, ("IdleNotificationCallback::"
                           "waiting for the power irp to complete\n"));

            KeWaitForSingleObject(&irpCompletionEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(irpContext) {

            ExFreePool(irpContext);
        }
    }

    SSDbgPrint(3, ("IdleNotificationCallback - ends\n"));
}


NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

  Completion routine for idle notification irp

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS                ntStatus;
    POWER_STATE             powerState;
    KIRQL                   oldIrql;
    PIRP                    idleIrp;
    LARGE_INTEGER           dueTime;
    PUSB_IDLE_CALLBACK_INFO idleCallbackInfo;

    SSDbgPrint(3, ("IdleNotificationRequestCompete - begins\n"));

    idleIrp = NULL;

    //
    // check the Irp status
    //
    ntStatus = Irp->IoStatus.Status;

    if(!NT_SUCCESS(ntStatus) && ntStatus != STATUS_NOT_SUPPORTED) {

        SSDbgPrint(1, ("Idle irp completes with error::"));

        switch(ntStatus) {
            
        case STATUS_INVALID_DEVICE_REQUEST:

            SSDbgPrint(1, ("STATUS_INVALID_DEVICE_REQUEST\n"));

            break;

        case STATUS_CANCELLED:

            SSDbgPrint(1, ("STATUS_CANCELLED\n"));

            break;

        case STATUS_POWER_STATE_INVALID:

            SSDbgPrint(1, ("STATUS_POWER_STATE_INVALID\n"));

            goto IdleNotificationRequestComplete_Exit;

        case STATUS_DEVICE_BUSY:

            SSDbgPrint(1, ("STATUS_DEVICE_BUSY\n"));

            break;

        default:

            SSDbgPrint(1, ("default: %X\n", ntStatus));

            break;
        }

        //
        // if the irp completes in error, request for a SetD0
        //

        SSDbgPrint(3, ("IdleNotificationRequestComplete::"));
        SSIoIncrement(DeviceExtension);

        powerState.DeviceState = PowerDeviceD0;

        ntStatus = PoRequestPowerIrp(
                          DeviceExtension->PhysicalDeviceObject, 
                          IRP_MN_SET_POWER, 
                          powerState, 
                          (PREQUEST_POWER_COMPLETE) PoIrpAsyncCompletionFunc, 
                          DeviceExtension, 
                          NULL);

        if(!NT_SUCCESS(ntStatus)) {
    
            SSDbgPrint(1, ("PoRequestPowerIrp failed\n"));
        }

    }

IdleNotificationRequestComplete_Exit:

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    idleCallbackInfo = DeviceExtension->IdleCallbackInfo;

    DeviceExtension->IdleCallbackInfo = NULL;

    idleIrp = (PIRP) InterlockedExchangePointer(
                                         &DeviceExtension->PendingIdleIrp,
                                         NULL);

    InterlockedExchange(&DeviceExtension->IdleReqPend, 0);

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    if(idleCallbackInfo) {

        ExFreePool(idleCallbackInfo);
    }

    //
    // since the irp was created using IoAllocateIrp, 
    // the Irp needs to be freed using IoFreeIrp.
    // Also return STATUS_MORE_PROCESSING_REQUIRED so that 
    // the kernel does not reference this in the near future.
    //

    if(idleIrp) {
        
        SSDbgPrint(3, ("the completion routine has a valid pointer to idleIrp - "
                       "free the irp\n"));

        IoFreeIrp(Irp);

        KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }
    else {

        //
        // The CancelSelectiveSuspend routine has grabbed the Irp from the device 
        // extension. Now the last one to decrement the FreeIdleIrpCount should
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            SSDbgPrint(3, ("FreeIdleIrpCount is 0 - "
                           "free the irp\n"));
            IoFreeIrp(Irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    if(DeviceExtension->SSEnable) {

        SSDbgPrint(3, ("Set the timer to fire DPCs\n"));

        dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

        SSDbgPrint(3, ("Setting the timer...\n"));
        KeSetTimerEx(&DeviceExtension->Timer, 
                     dueTime,
                     IDLE_INTERVAL,                              // 5000 ms
                     &DeviceExtension->DeferredProcCall);

        SSDbgPrint(3, ("IdleNotificationRequestCompete - ends\n"));
    }

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is invoked to cancel selective suspend request.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None.

--*/
{
    PIRP  irp;
    KIRQL oldIrql;

    irp = NULL;

    SSDbgPrint(3, ("CancelSelectSuspend - begins\n"));

    KeAcquireSpinLock(&DeviceExtension->IdleReqStateLock, &oldIrql);

    if(!CanDeviceSuspend(DeviceExtension))
    {
        SSDbgPrint(3, ("Device is not idle\n"));
    
        irp = (PIRP) InterlockedExchangePointer(
                            &DeviceExtension->PendingIdleIrp, 
                            NULL);
    }

    KeReleaseSpinLock(&DeviceExtension->IdleReqStateLock, oldIrql);

    //
    // since we have a valid Irp ptr,
    // we can call IoCancelIrp on it,
    // without the fear of the irp 
    // being freed underneath us.
    //

    if(irp) {

        //
        // This routine has the irp pointer.
        // It is safe to call IoCancelIrp because we know that
        // the compleiton routine will not free this irp unless...
        // 
        //
        if(IoCancelIrp(irp)) {

            SSDbgPrint(3, ("IoCancelIrp returns TRUE\n"));
        }
        else {
            SSDbgPrint(3, ("IoCancelIrp returns FALSE\n"));
        }

        //
        // ....we decrement the FreeIdleIrpCount from 2 to 1.
        // if completion routine runs ahead of us, then this routine 
        // decrements the FreeIdleIrpCount from 1 to 0 and hence shall
        // free the irp.
        //
        if(0 == InterlockedDecrement(&DeviceExtension->FreeIdleIrpCount)) {

            SSDbgPrint(3, ("FreeIdleIrpCount is 0 - "
                           "free the irp\n"));
            IoFreeIrp(irp);

            KeSetEvent(&DeviceExtension->NoIdleReqPendEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }

    SSDbgPrint(3, ("CancelSelectSuspend - ends\n"));

    return;
}

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in 
    IdleNotificationCallback.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PIRP_COMPLETION_CONTEXT irpContext;
    
    //
    // initialize variables
    //
    irpContext = NULL;

    if(Context) {

        irpContext = (PIRP_COMPLETION_CONTEXT) Context;
    }

    //
    // all we do is set the event and decrement the count
    //

    if(irpContext) {

        KeSetEvent(irpContext->Event, 0, FALSE);

        SSDbgPrint(3, ("PoIrpCompletionFunc::"));
        SSIoDecrement(irpContext->DeviceExtension);

        ExFreePool(irpContext);
    }

    return;
}

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for power irp PoRequested in IdleNotification
    RequestComplete routine.

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("PoIrpAsyncCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    Completion routine for PoRequest wait wake irp

Arguments:

    DeviceObject - pointer to device object
    MinorFunciton - minor function for the irp.
    PowerState - irp power state
    Context - context passed to the completion function
    IoStatus - status block.    

Return Value:

    None

--*/
{
    PDEVICE_EXTENSION DeviceExtension;
    
    //
    // initialize variables
    //
    DeviceExtension = (PDEVICE_EXTENSION) Context;

    //
    // all we do is decrement the count
    //
    
    SSDbgPrint(3, ("WWIrpCompletionFunc::"));
    SSIoDecrement(DeviceExtension);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sspnp.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.c

Abstract:

    This file contains code to handle the pnp irps.
    This is not USB specific but is essential for 
    every WDM driver.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPnP.h"
#include "sSPwr.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include "sSUsr.h"

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    The plug and play dispatch routines.
    Most of these requests the driver will completely ignore.
    In all cases it must pass on the IRP to the lower driver.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    KEVENT             startDeviceEvent;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // since the device is removed, fail the Irp.
    //

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("///////////////////////////////////////////\n"));
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoIncrement(deviceExtension);

    if(irpStack->MinorFunction == IRP_MN_START_DEVICE) {

        ASSERT(deviceExtension->IdleReqPend == 0);
    }
    else {

        if(deviceExtension->SSEnable) {
        
            CancelSelectSuspend(deviceExtension);
        }
    }

    SSDbgPrint(2, (PnPMinorFunctionString(irpStack->MinorFunction)));

    switch(irpStack->MinorFunction) {

    case IRP_MN_START_DEVICE:

        ntStatus = HandleStartDevice(DeviceObject, Irp);

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        //
        // if we cannot stop the device, we fail the query stop irp
        //
        ntStatus = CanStopDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {

            ntStatus = HandleQueryStopDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        ntStatus = HandleCancelStopDevice(DeviceObject, Irp);

        break;
     
    case IRP_MN_STOP_DEVICE:

        ntStatus = HandleStopDevice(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_STOP_DEVICE::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        //
        // if we cannot remove the device, we fail the query remove irp
        //
        ntStatus = CanRemoveDevice(DeviceObject, Irp);

        if(NT_SUCCESS(ntStatus)) {
            
            ntStatus = HandleQueryRemoveDevice(DeviceObject, Irp);

            return ntStatus;
        }
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        ntStatus = HandleCancelRemoveDevice(DeviceObject, Irp);

        break;

    case IRP_MN_SURPRISE_REMOVAL:

        ntStatus = HandleSurpriseRemoval(DeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::IRP_MN_SURPRISE_REMOVAL::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    case IRP_MN_REMOVE_DEVICE:

        ntStatus = HandleRemoveDevice(DeviceObject, Irp);

        return ntStatus;

    case IRP_MN_QUERY_CAPABILITIES:

        ntStatus = HandleQueryCapabilities(DeviceObject, Irp);

        break;

    default:

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        SSDbgPrint(3, ("SS_DispatchPnP::default::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;

    } // switch

    //
    // complete request 
    //
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // decrement count
    //
    SSDbgPrint(3, ("SS_DispatchPnP::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP              Irp
    )
/*++
 
Routine Description:

    This is the dispatch routine for IRP_MN_START_DEVICE

Arguments:

    DeviceObject - pointer to a device object.

    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            startDeviceEvent;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    LARGE_INTEGER     dueTime;

    SSDbgPrint(3, ("HandleStartDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We cannot touch the device (send it any non pnp irps) until a
    // start device has been passed down to the lower drivers.
    // first pass the Irp down
    //

    KeInitializeEvent(&startDeviceEvent, NotificationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&startDeviceEvent, 
                           TRUE, 
                           TRUE, 
                           TRUE);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&startDeviceEvent, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower drivers failed this Irp\n"));
        return ntStatus;
    }

    //
    // Read the device descriptor, configuration descriptor 
    // and select the interface descriptors
    //

    ntStatus = ReadandSelectDescriptors(DeviceObject);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("ReadandSelectDescriptors failed\n"));
        return ntStatus;
    }

    //
    // enable the symbolic links for system components to open
    // handles to the device
    //

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         TRUE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState:enable:failed\n"));
        return ntStatus;
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Working);
    deviceExtension->QueueState = AllowRequests;

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // initialize wait wake variables
    // and issue a wait wake.
    
    deviceExtension->WaitWakeIrp = NULL;
    deviceExtension->FlagWWCancel = 0;
    deviceExtension->FlagWWOutstanding = 0;

    if(deviceExtension->WaitWakeEnable) {

        IssueWaitWake(deviceExtension);
    }

    ProcessQueuedRequests(deviceExtension);

    if(WinXpOrBetter == deviceExtension->WdmVersion) {

        deviceExtension->SSEnable = deviceExtension->SSRegistryEnable;

        //
        // set timer for selective suspend requests.
        //

        if(deviceExtension->SSEnable) {

            dueTime.QuadPart = -10000 * IDLE_INTERVAL;               // 5000 ms

            SSDbgPrint(3, ("Setting the timer...\n"));
            KeSetTimerEx(&deviceExtension->Timer, 
                         dueTime,
                         IDLE_INTERVAL,                              // 5000 ms
                         &deviceExtension->DeferredProcCall);

            deviceExtension->FreeIdleIrpCount = 0;
        }
    }

    SSDbgPrint(3, ("HandleStartDevice - ends\n"));

    return ntStatus;
}


NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine configures the USB device.
    In this routines we get the device descriptor, 
    the configuration descriptor and select the
    configuration descriptor.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value.

--*/
{
    PURB                   urb;
    ULONG                  siz;
    NTSTATUS               ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor;
    
    //
    // initialize variables
    //

    urb = NULL;
    deviceDescriptor = NULL;

    //
    // 1. Read the device descriptor
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(deviceDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_DEVICE_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    deviceDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(NT_SUCCESS(ntStatus)) {

                ASSERT(deviceDescriptor->bNumConfigurations);
                ntStatus = ConfigureDevice(DeviceObject);    
            }
            			    
            ExFreePool(urb);                
            ExFreePool(deviceDescriptor);
        }
        else {

            SSDbgPrint(1, ("Failed to allocate memory for deviceDescriptor"));

            ExFreePool(urb);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This helper routine reads the configuration descriptor
    for the device in couple of steps.

Arguments:

    DeviceObject - pointer to a device object

Return Value:

    NTSTATUS - NT status value

--*/
{
    PURB                          urb;
    ULONG                         siz;
    NTSTATUS                      ntStatus;
    PDEVICE_EXTENSION             deviceExtension;
    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor;

    //
    // initialize the variables
    //

    urb = NULL;
    configurationDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;

    //
    // Read the first configuration descriptor
    // This requires two steps:
    // 1. Read the fixed sized configuration desciptor (CD)
    // 2. Read the CD with all embedded interface and endpoint descriptors
    //

    urb = ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if(urb) {

        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR);
        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT) sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE, 
                    0, 
                    0, 
                    configurationDescriptor,
                    NULL, 
                    sizeof(USB_CONFIGURATION_DESCRIPTOR), 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1, ("UsbBuildGetDescriptorRequest failed\n"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to allocate mem for config Descriptor\n"));

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }

        siz = configurationDescriptor->wTotalLength;

        ExFreePool(configurationDescriptor);

        configurationDescriptor = ExAllocatePool(NonPagedPool, siz);

        if(configurationDescriptor) {

            UsbBuildGetDescriptorRequest(
                    urb, 
                    (USHORT)sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                    USB_CONFIGURATION_DESCRIPTOR_TYPE,
                    0, 
                    0, 
                    configurationDescriptor, 
                    NULL, 
                    siz, 
                    NULL);

            ntStatus = CallUSBD(DeviceObject, urb);

            if(!NT_SUCCESS(ntStatus)) {

                SSDbgPrint(1,("Failed to read configuration descriptor"));
                goto ConfigureDevice_Exit;
            }
        }
        else {

            SSDbgPrint(1, ("Failed to alloc mem for config Descriptor\n"));
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto ConfigureDevice_Exit;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to allocate memory for urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto ConfigureDevice_Exit;
    }

    if(configurationDescriptor) {

        if(configurationDescriptor->bmAttributes & REMOTE_WAKEUP_MASK)
        {
            //
            // this configuration supports remote wakeup
            //
            deviceExtension->WaitWakeEnable = 1;
        }
        else
        {
            deviceExtension->WaitWakeEnable = 0;
        }

        ntStatus = SelectInterfaces(DeviceObject, configurationDescriptor);
    }

ConfigureDevice_Exit:

    if(urb) {

        ExFreePool(urb);
    }

    if(configurationDescriptor) {

        ExFreePool(configurationDescriptor);
    }

    return ntStatus;
}

NTSTATUS
SelectInterfaces(
    IN PDEVICE_OBJECT                DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    )
/*++
 
Routine Description:

    This helper routine selects the configuration

Arguments:

    DeviceObject - pointer to device object
    ConfigurationDescriptor - pointer to the configuration
    descriptor for the device

Return Value:

    NT status value

--*/
{
    LONG                        numberOfInterfaces, 
                                interfaceNumber, 
                                interfaceindex;
    ULONG                       i;
    PURB                        urb;
    PUCHAR                      pInf;
    NTSTATUS                    ntStatus;
    PDEVICE_EXTENSION           deviceExtension;
    PUSB_INTERFACE_DESCRIPTOR   interfaceDescriptor;
    PUSBD_INTERFACE_LIST_ENTRY  interfaceList, 
                                tmp;
    PUSBD_INTERFACE_INFORMATION interface;

    //
    // initialize the variables
    //

    urb = NULL;
    interface = NULL;
    interfaceDescriptor = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces;
    interfaceindex = interfaceNumber = 0;

    //
    // Parse the configuration descriptor for the interface;
    //

    tmp = interfaceList =
        ExAllocatePool(
               NonPagedPool, 
               sizeof(USBD_INTERFACE_LIST_ENTRY) * (numberOfInterfaces + 1));

    if(!tmp) {

        SSDbgPrint(1, ("Failed to allocate mem for interfaceList\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    while(interfaceNumber < numberOfInterfaces) {

        interfaceDescriptor = USBD_ParseConfigurationDescriptorEx(
                                            ConfigurationDescriptor, 
                                            ConfigurationDescriptor,
                                            interfaceindex,
                                            0, -1, -1, -1);

        if(interfaceDescriptor) {

            interfaceList->InterfaceDescriptor = interfaceDescriptor;
            interfaceList->Interface = NULL;
            interfaceList++;
            interfaceNumber++;
        }

        interfaceindex++;
    }

    interfaceList->InterfaceDescriptor = NULL;
    interfaceList->Interface = NULL;
    urb = USBD_CreateConfigurationRequestEx(ConfigurationDescriptor, tmp);

    if(urb) {

        interface = &urb->UrbSelectConfiguration.Interface;

        for(i=0; i<interface->NumberOfPipes; i++) {

            //
            // perform pipe initialization here
            // set the transfer size and any pipe flags we use
            // USBD sets the rest of the Interface struct members
            //

            interface->Pipes[i].MaximumTransferSize = 
                                USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE;
        }

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Failed to select an interface\n"));
        }
    }
    else {
        
        SSDbgPrint(1, ("USBD_CreateConfigurationRequestEx failed\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    if(tmp) {

        ExFreePool(tmp);
    }

    if(urb) {

        ExFreePool(urb);
    }

    return ntStatus;
}


NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine is invoked when the device is removed or stopped.
    This routine de-configures the usb device.

Arguments:

    DeviceObject - pointer to device object

Return Value:

    NT status value

--*/
{
    PURB     urb;
    ULONG    siz;
    NTSTATUS ntStatus;
    
    //
    // initialize variables
    //

    siz = sizeof(struct _URB_SELECT_CONFIGURATION);
    urb = ExAllocatePool(NonPagedPool, siz);

    if(urb) {

        UsbBuildSelectConfigurationRequest(urb, (USHORT)siz, NULL);

        ntStatus = CallUSBD(DeviceObject, urb);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(3, ("Failed to deconfigure device\n"));
        }

        ExFreePool(urb);
    }
    else {

        SSDbgPrint(1, ("Failed to allocate urb\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    return ntStatus;
}

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    )
/*++
 
Routine Description:

    This routine synchronously submits an urb down the stack.

Arguments:

    DeviceObject - pointer to device object
    Urb - USB request block

Return Value:

    NT status value

--*/
{
    PIRP               irp;
    KEVENT             event;
    NTSTATUS           ntStatus;
    IO_STATUS_BLOCK    ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION  deviceExtension;

    //
    // initialize the variables
    //

    irp = NULL;
    deviceExtension = DeviceObject->DeviceExtension;
    
    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_SUBMIT_URB, 
                                        deviceExtension->TopOfStackDeviceObject,
                                        NULL, 
                                        0, 
                                        NULL, 
                                        0, 
                                        TRUE, 
                                        &event, 
                                        &ioStatus);

    if(!irp) {

        SSDbgPrint(1, ("IoBuildDeviceIoControlRequest failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    SSDbgPrint(3, ("CallUSBD::"));
    SSIoIncrement(deviceExtension);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);

        ntStatus = ioStatus.Status;
    }
    
    SSDbgPrint(3, ("CallUSBD::"));
    SSIoDecrement(deviceExtension);
    return ntStatus;
}

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services the Irps of minor type IRP_MN_QUERY_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can stop the device, we need to set the QueueState to 
    // HoldRequests so further requests will be queued.
    //

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
    
    SET_NEW_PNP_STATE(deviceExtension, PendingStop);
    deviceExtension->QueueState = HoldRequests;
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // wait for the existing ones to be finished.
    // first, decrement this operation
    //

    SSDbgPrint(3, ("HandleQueryStopDevice::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    //
    // We must set Irp->IoStatus.Status to STATUS_SUCCESS before
    // passing it down.
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);

    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT value

--*/
{
    KIRQL             oldIrql;    
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelStopDevice - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // Send this IRP down and wait for it to come back.
    // Set the QueueState flag to AllowRequests, 
    // and process all the previously queued up IRPs.
    //
    // First check to see whether you have received cancel-stop
    // without first receiving a query-stop. This could happen if someone
    // above us fails a query-stop and passes down the subsequent
    // cancel-stop.
    //

    if(PendingStop == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);

        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);
            deviceExtension->QueueState = AllowRequests;
            ASSERT(deviceExtension->DeviceState == Working);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }

    }
    else {

        // spurious Irp
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelStopDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_STOP_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleStopDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if(WinXpOrBetter == deviceExtension->WdmVersion) {
    
        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // Thus, we are making judicious usage of our resources.
            // we do not need DPCs because the device is stopping.
            // The timers are re-initialized while handling the start
            // device irp.
            //
        
            SSDbgPrint(3, ("Cancelling the timer...\n"));
            KeCancelTimer(&deviceExtension->Timer);

            //
            // after the device is stopped, it can be surprise removed.
            // we set this to 0, so that we do not attempt to cancel
            // the timer while handling surprise remove or remove irps.
            // When we get the start device request, this flag will be
            // reinitialized.
            //
            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }
    
    //
    // after the stop Irp is sent to the lower driver object, 
    // the driver must not send any more Irps down that touch 
    // the device until another Start has occurred.
    //

    if(deviceExtension->WaitWakeEnable) {
        
        CancelWaitWake(deviceExtension);
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Stopped);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    //
    // This is the right place to actually give up all the resources used
    // This might include calls to IoDisconnectInterrupt, MmUnmapIoSpace, 
    // etc.
    //
    ReleaseMemory(DeviceObject);
    
    ntStatus = DeconfigureDevice(DeviceObject);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;
    
    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleStopDevice - ends\n"));
    
    return ntStatus;
}

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleQueryRemoveDevice - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // If we can allow removal of the device, we should set the QueueState
    // to HoldRequests so further requests will be queued. This is required
    // so that we can process queued up requests in cancel-remove just in 
    // case somebody else in the stack fails the query-remove. 
    // 

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = HoldRequests;
    SET_NEW_PNP_STATE(deviceExtension, PendingRemove);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    SSDbgPrint(3, ("HandleQueryRemoveDevice::"));
    SSIoDecrement(deviceExtension);

    //
    // wait for all the requests to be completed
    //

    KeWaitForSingleObject(&deviceExtension->StopEvent, 
                          Executive,
                          KernelMode, 
                          FALSE, 
                          NULL);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleQueryRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_CANCEL_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleCancelRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // We need to reset the QueueState flag to ProcessRequest, 
    // since the device resume its normal activities.
    //

    //
    // First check to see whether you have received cancel-remove
    // without first receiving a query-remove. This could happen if 
    // someone above us fails a query-remove and passes down the 
    // subsequent cancel-remove.
    //

    if(PendingRemove == deviceExtension->DeviceState) {

        KeInitializeEvent(&event, NotificationEvent, FALSE);

        IoCopyCurrentIrpStackLocationToNext(Irp);
        IoSetCompletionRoutine(Irp, 
                               (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                               (PVOID)&event, 
                               TRUE, 
                               TRUE, 
                               TRUE);
        ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(ntStatus == STATUS_PENDING) {

            KeWaitForSingleObject(&event, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            ntStatus = Irp->IoStatus.Status;
        }

        if(NT_SUCCESS(ntStatus)) {

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

            deviceExtension->QueueState = AllowRequests;
            RESTORE_PREVIOUS_PNP_STATE(deviceExtension);

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
            //
            // process the queued requests that arrive between 
            // QUERY_REMOVE and CANCEL_REMOVE
            //
            
            ProcessQueuedRequests(deviceExtension);
            
        }
    }
    else {

        // 
        // spurious cancel-remove
        //
        ntStatus = STATUS_SUCCESS;
    }

    SSDbgPrint(3, ("HandleCancelRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_SURPRISE_REMOVAL

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleSurpriseRemoval - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // 1. fail pending requests
    // 2. return device and memory resources
    // 3. disable interfaces
    //

    if(deviceExtension->WaitWakeEnable) {
    
        CancelWaitWake(deviceExtension);
    }

    if(WinXpOrBetter == deviceExtension->WdmVersion) {
        
        if(deviceExtension->SSEnable) {

            //
            // Cancel the timer so that the DPCs are no longer fired.
            // we do not need DPCs because the device has been surprise
            // removed
            //

            SSDbgPrint(3, ("Cancelling the timer...\n"));
            KeCancelTimer(&deviceExtension->Timer);

            deviceExtension->SSEnable = 0;

            //
            // make sure that if a DPC was fired before we called cancel timer,
            // then the DPC and work-time have run to their completion
            //
            KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);

            //
            // make sure that the selective suspend request has been completed.
            //
            KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                  Executive, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    deviceExtension->QueueState = FailRequests;
    SET_NEW_PNP_STATE(deviceExtension, SurpriseRemoved);

    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

    ProcessQueuedRequests(deviceExtension);

    ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                         FALSE);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSurpriseRemoval - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine services Irp of minor type IRP_MN_REMOVE_DEVICE

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value

--*/
{
    KIRQL             oldIrql;
    KEVENT            event;
    ULONG             requestCount;
    NTSTATUS          ntStatus;
    PDEVICE_EXTENSION deviceExtension;

    SSDbgPrint(3, ("HandleRemoveDevice - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    //
    // The Plug & Play system has dictated the removal of this device.  We
    // have no choice but to detach and delete the device object.
    // (If we wanted to express an interest in preventing this removal,
    // we should have failed the query remove IRP).
    //

    if(SurpriseRemoved != deviceExtension->DeviceState) {

        //
        // we are here after QUERY_REMOVE
        //

        KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

        deviceExtension->QueueState = FailRequests;
        
        KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

        if(deviceExtension->WaitWakeEnable) {
        
            CancelWaitWake(deviceExtension);
        }

        if(WinXpOrBetter == deviceExtension->WdmVersion) {

            if(deviceExtension->SSEnable) {

                //
                // Cancel the timer so that the DPCs are no longer fired.
                // we do not need DPCs because the device has been removed
                //

                SSDbgPrint(3, ("Cancelling the timer...\n"));
                KeCancelTimer(&deviceExtension->Timer);

                deviceExtension->SSEnable = 0;

                //
                // make sure that if a DPC was fired before we called cancel timer,
                // then the DPC and work-time have run to their completion
                //
                KeWaitForSingleObject(&deviceExtension->NoDpcWorkItemPendingEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);

                //
                // make sure that the selective suspend request has been completed.
                //
                KeWaitForSingleObject(&deviceExtension->NoIdleReqPendEvent, 
                                      Executive, 
                                      KernelMode, 
                                      FALSE, 
                                      NULL);
            }
        }

        ProcessQueuedRequests(deviceExtension);

        ntStatus = IoSetDeviceInterfaceState(&deviceExtension->InterfaceName, 
                                             FALSE);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("IoSetDeviceInterfaceState::disable:failed\n"));
        }
    }

    KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);

    SET_NEW_PNP_STATE(deviceExtension, Removed);
    
    KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);
    
    SSWmiDeRegistration(deviceExtension);

    //
    // need 2 decrements
    //

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    ASSERT(requestCount > 0);

    SSDbgPrint(3, ("HandleRemoveDevice::"));
    requestCount = SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->RemoveEvent, 
                          Executive, 
                          KernelMode, 
                          FALSE, 
                          NULL);

    ReleaseMemory(DeviceObject);

    //
    // We need to send the remove down the stack before we detach,
    // but we don't need to wait for the completion of this operation
    // (and to register a completion routine).
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoSkipCurrentIrpStackLocation(Irp);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    
    //
    // Detach the FDO from the device stack
    //
    IoDetachDevice(deviceExtension->TopOfStackDeviceObject);
    IoDeleteDevice(DeviceObject);

    SSDbgPrint(3, ("HandleRemoveDevice - ends\n"));

    return ntStatus;
}

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    This routine services Irp of minor type IRP_MN_QUERY_CAPABILITIES

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager.

Return Value:

    NT status value  

--*/
{
    ULONG                i;
    KEVENT               event;
    NTSTATUS             ntStatus;
    PDEVICE_EXTENSION    deviceExtension;
    PDEVICE_CAPABILITIES pdc;
    PIO_STACK_LOCATION   irpStack;

    SSDbgPrint(3, ("HandleQueryCapabilities - begins\n"));

    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    pdc = irpStack->Parameters.DeviceCapabilities.Capabilities;

    //
    // We will provide here an example of an IRP that is processed
    // both on its way down and on its way up: there might be no need for
    // a function driver process this Irp (the bus driver will do that).
    // The driver will wait for the lower drivers (the bus driver among 
    // them) to process this IRP, then it processes it again.
    //

    if(pdc->Version < 1 || pdc->Size < sizeof(DEVICE_CAPABILITIES)) {
        
        SSDbgPrint(1, ("HandleQueryCapabilities::request failed\n"));
        ntStatus = STATUS_UNSUCCESSFUL;
        return ntStatus;
    }

    //
    // Set some values in deviceCapabilities here...
    //
    //.............................................
    //
    //
    // Prepare to pass the IRP down
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);
        
    IoCopyCurrentIrpStackLocationToNext(Irp);
    IoSetCompletionRoutine(Irp, 
                           (PIO_COMPLETION_ROUTINE)IrpCompletionRoutine, 
                           (PVOID)&event, 
                           TRUE, 
                           TRUE, 
                           TRUE);
    ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    if(ntStatus == STATUS_PENDING) {

        KeWaitForSingleObject(&event, 
                              Executive, 
                              KernelMode, 
                              FALSE, 
                              NULL);
        ntStatus = Irp->IoStatus.Status;
    }

    //
    // initialize PowerDownLevel to disabled
    //

    deviceExtension->PowerDownLevel = PowerDeviceUnspecified;

    //
    // Lower drivers have finished their operation, so now
    // we can finish ours. 
    //

    if(NT_SUCCESS(ntStatus)) {

        deviceExtension->DeviceCapabilities = *pdc;
       
        for(i = PowerSystemSleeping1; i <= PowerSystemSleeping3; i++) {

            if(deviceExtension->DeviceCapabilities.DeviceState[i] < 
                                                            PowerDeviceD3) {

                deviceExtension->PowerDownLevel = 
                    deviceExtension->DeviceCapabilities.DeviceState[i];
            }
        }

        //
        // since its safe to surprise-remove this device, we shall
        // set the SurpriseRemoveOK flag to supress any dialog to 
        // user.
        //

        pdc->SurpriseRemovalOK = 1;

    }

    if(deviceExtension->PowerDownLevel == PowerDeviceUnspecified ||
       deviceExtension->PowerDownLevel <= PowerDeviceD0) {
    
        deviceExtension->PowerDownLevel = PowerDeviceD2;
    }

    SSDbgPrint(3, ("HandleQueryCapabilities - ends\n"));

    return ntStatus;
}


VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
 
Routine Description:

    DPC routine triggered by the timer to check the idle state
    of the device and submit an idle request for the device.

Arguments:

    DeferredContext - context for the dpc routine.
                      DeviceObject in our case.

Return Value:

    None

--*/
{
    NTSTATUS          ntStatus;
    PDEVICE_OBJECT    deviceObject;
    PDEVICE_EXTENSION deviceExtension;
    PIO_WORKITEM      item;

    deviceObject = (PDEVICE_OBJECT)DeferredContext;
    deviceExtension = (PDEVICE_EXTENSION)deviceObject->DeviceExtension;

    SSDbgPrint(3, ("DpcRoutine - begins\n"));

    //
    // Clear this event since a DPC has been fired!
    //
    KeClearEvent(&deviceExtension->NoDpcWorkItemPendingEvent);

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is Idle\n"));

        item = IoAllocateWorkItem(deviceObject);

        if(item) {

            IoQueueWorkItem(item, 
                            IdleRequestWorkerRoutine,
                            DelayedWorkQueue, 
                            item);

            ntStatus = STATUS_PENDING;

        }
        else {
        
            SSDbgPrint(3, ("Cannot alloc memory for work item\n"));
            
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            //
            // signal the NoDpcWorkItemPendingEvent.
            //
            KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                       IO_NO_INCREMENT,
                       FALSE);
        }
    }
    else {
        
        SSDbgPrint(3, ("Idle event not signaled\n"));

        //
        // signal the NoDpcWorkItemPendingEvent.
        //
        KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
                   IO_NO_INCREMENT,
                   FALSE);
    }

    SSDbgPrint(3, ("DpcRoutine - ends\n"));
}    


VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This is the work item fired from the DPC.
    This workitem checks the idle state of the device
    and submits an idle request.

Arguments:

    DeviceObject - pointer to device object
    Context - context for the work item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PIO_WORKITEM           workItem;

    SSDbgPrint(3, ("IdleRequestWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    workItem = (PIO_WORKITEM) Context;

    if(CanDeviceSuspend(deviceExtension)) {

        SSDbgPrint(3, ("Device is idle\n"));

        ntStatus = SubmitIdleRequestIrp(deviceExtension);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("SubmitIdleRequestIrp failed\n"));
        }
    }
    else {

        SSDbgPrint(3, ("Device is not idle\n"));
    }

    IoFreeWorkItem(workItem);

    //
    // signal the NoDpcWorkItemPendingEvent.
    //
    KeSetEvent(&deviceExtension->NoDpcWorkItemPendingEvent,
               IO_NO_INCREMENT,
               FALSE);

    SSDbgPrint(3, ("IdleRequestsWorkerRoutine - ends\n"));
}


VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    Remove and process the entries in the queue. If this routine is called
    when processing IRP_MN_CANCEL_STOP_DEVICE, IRP_MN_CANCEL_REMOVE_DEVICE
    or IRP_MN_START_DEVICE, the requests are passed to the next lower driver.
    If the routine is called when IRP_MN_REMOVE_DEVICE is received, the IRPs
    are complete with STATUS_DELETE_PENDING

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    None

--*/
{
    KIRQL       oldIrql;
    PIRP        nextIrp,
                cancelledIrp;
    PVOID       cancelRoutine;
    LIST_ENTRY  cancelledIrpList;
    PLIST_ENTRY listEntry;

    SSDbgPrint(3, ("ProcessQueuedRequests - begins\n"));

    //
    // initialize variables
    //

    cancelRoutine = NULL;
    InitializeListHead(&cancelledIrpList);

    //
    // 1.  dequeue the entries in the queue
    // 2.  reset the cancel routine
    // 3.  process them
    // 3a. if the device is active, send them down
    // 3b. else complete with STATUS_DELETE_PENDING
    //

    while(1) {

        KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

        if(IsListEmpty(&DeviceExtension->NewRequestsQueue)) {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
            break;
        }
    
        //
        // Remove a request from the queue
        //

        listEntry = RemoveHeadList(&DeviceExtension->NewRequestsQueue);
        nextIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        //
        // set the cancel routine to NULL
        //

        cancelRoutine = IoSetCancelRoutine(nextIrp, NULL);

        //
        // check if its already cancelled
        //

        if(nextIrp->Cancel) {
            if(cancelRoutine) {

                //
                // the cancel routine for this IRP hasnt been called yet
                // so queue the IRP in the cancelledIrp list and complete
                // after releasing the lock
                //
                
                InsertTailList(&cancelledIrpList, listEntry);
            }
            else {

                //
                // the cancel routine has run
                // it must be waiting to hold the queue lock
                // so initialize the IRPs listEntry
                //

                InitializeListHead(listEntry);
            }

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);
        }
        else {

            KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

            if(FailRequests == DeviceExtension->QueueState) {

                nextIrp->IoStatus.Information = 0;
                nextIrp->IoStatus.Status = STATUS_DELETE_PENDING;
                IoCompleteRequest(nextIrp, IO_NO_INCREMENT);
            }
            else {

                PIO_STACK_LOCATION irpStack;

                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoIncrement(DeviceExtension);

                IoSkipCurrentIrpStackLocation(nextIrp);
                IoCallDriver(DeviceExtension->TopOfStackDeviceObject, nextIrp);
               
                SSDbgPrint(3, ("ProcessQueuedRequests::"));
                SSIoDecrement(DeviceExtension);
            }
        }
    } // while loop

    //
    // walk through the cancelledIrp list and cancel them
    //

    while(!IsListEmpty(&cancelledIrpList)) {

        PLIST_ENTRY listEntry = RemoveHeadList(&cancelledIrpList);
        
        cancelledIrp = CONTAINING_RECORD(listEntry, IRP, Tail.Overlay.ListEntry);

        cancelledIrp->IoStatus.Status = STATUS_CANCELLED;
        cancelledIrp->IoStatus.Information = 0;

        IoCompleteRequest(cancelledIrp, IO_NO_INCREMENT);
    }

    SSDbgPrint(3, ("ProcessQueuedRequests - ends\n"));

    return;
}


NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    Dispatch routine for IRP_MJ_CLEANUP

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the pnp manager

Return Value:

    NT status value

--*/
{
    PDEVICE_EXTENSION  deviceExtension;
    KIRQL              oldIrql;
    LIST_ENTRY         cleanupList;
    PLIST_ENTRY        thisEntry, 
                       nextEntry, 
                       listHead;
    PIRP               pendingIrp;
    PIO_STACK_LOCATION pendingIrpStack, 
                       irpStack;
    NTSTATUS           ntStatus;

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    InitializeListHead(&cleanupList);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoIncrement(deviceExtension);

    //
    // acquire queue lock
    //
    KeAcquireSpinLock(&deviceExtension->QueueLock, &oldIrql);

    //
    // remove all Irp's that belong to input Irp's fileobject
    //

    listHead = &deviceExtension->NewRequestsQueue;

    for(thisEntry = listHead->Flink, nextEntry = thisEntry->Flink;
       thisEntry != listHead;
       thisEntry = nextEntry, nextEntry = thisEntry->Flink) {

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrpStack = IoGetCurrentIrpStackLocation(pendingIrp);

        if(irpStack->FileObject == pendingIrpStack->FileObject) {

            RemoveEntryList(thisEntry);

            //
            // set the cancel routine to NULL
            //
            if(NULL == IoSetCancelRoutine(pendingIrp, NULL)) {

                InitializeListHead(thisEntry);
            }
            else {

                InsertTailList(&cleanupList, thisEntry);
            }
        }
    }

    //
    // Release the spin lock
    //

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // walk thru the cleanup list and cancel all the Irps
    //

    while(!IsListEmpty(&cleanupList)) {

        //
        // complete the Irp
        //
        thisEntry = RemoveHeadList(&cleanupList);

        pendingIrp = CONTAINING_RECORD(thisEntry, IRP, Tail.Overlay.ListEntry);

        pendingIrp->IoStatus.Information = 0;
        pendingIrp->IoStatus.Status = STATUS_CANCELLED;

        IoCompleteRequest(pendingIrp, IO_NO_INCREMENT);
    }

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SS_DispatchClean::"));
    SSIoDecrement(deviceExtension);

    return STATUS_SUCCESS;
}

NTSTATUS
SS_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    )
/*++
 
Routine Description:

    This routine reads the specified reqistry value.

Arguments:

    RegPath - registry path
    ValueName - property to be fetched from the registry
    Value - corresponding value read from the registry.

Return Value:

    NT status value

--*/
{
    ULONG                    defaultData;
    WCHAR                    buffer[MAXIMUM_FILENAME_LENGTH];
    NTSTATUS                 ntStatus;
    UNICODE_STRING           regPath;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];

    SSDbgPrint(3, ("SS_GetRegistryDword - begins\n"));

    regPath.Length = 0;
    regPath.MaximumLength = MAXIMUM_FILENAME_LENGTH * sizeof(WCHAR);
    regPath.Buffer = buffer;

    RtlZeroMemory(regPath.Buffer, regPath.MaximumLength);
    RtlMoveMemory(regPath.Buffer,
                  RegPath,
                  wcslen(RegPath) * sizeof(WCHAR));

    RtlZeroMemory(paramTable, sizeof(paramTable));

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = ValueName;
    paramTable[0].EntryContext = Value;
    paramTable[0].DefaultType = REG_DWORD;
    paramTable[0].DefaultData = &defaultData;
    paramTable[0].DefaultLength = sizeof(ULONG);

    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE |
                                      RTL_REGISTRY_OPTIONAL,
                                      regPath.Buffer,
                                      paramTable,
                                      NULL,
                                      NULL);

    if(NT_SUCCESS(ntStatus)) {

        SSDbgPrint(3, ("success Value = %X\n", *Value));
        return STATUS_SUCCESS;
    }
    else {

        *Value = 0;
        return STATUS_UNSUCCESSFUL;
    }
}

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the routine where we check if the device
    can selectively suspend. 

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    TRUE - if the device can suspend
    FALSE - otherwise.

--*/
{
    SSDbgPrint(3, ("CanDeviceSuspend\n"));

    if((DeviceExtension->OpenHandleCount == 0) &&
        (DeviceExtension->OutStandingIO == 1)) {
        
        return TRUE;
    }
    else {

        return FALSE;
    }
}

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine is a completion routine.
    In this routine we set an event.

    Since the completion routine returns 
    STATUS_MORE_PROCESSING_REQUIRED, the Irps,
    which set this routine as the completion routine,
    should be marked pending.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    Context - 

Return Value:

    NT status value

--*/
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine bumps up the I/O count.
    This routine is typically invoked when any of the
    dispatch routines handle new irps for the driver.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedIncrement(&DeviceExtension->OutStandingIO);

    //
    // when OutStandingIO bumps from 1 to 2, clear the StopEvent
    //

    if(result == 2) {

        KeClearEvent(&DeviceExtension->StopEvent);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoIncrement::%d\n", result));

    return result;
}

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine decrements the outstanding I/O count
    This is typically invoked after the dispatch routine
    has finished processing the irp.

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    new value

--*/
{
    LONG  result = 0;
    KIRQL oldIrql;

    KeAcquireSpinLock(&DeviceExtension->IOCountLock, &oldIrql);

    result = InterlockedDecrement(&DeviceExtension->OutStandingIO);

    if(result == 1) {

        KeSetEvent(&DeviceExtension->StopEvent, IO_NO_INCREMENT, FALSE);
    }

    if(result == 0) {

        ASSERT(Removed == DeviceExtension->DeviceState);

        KeSetEvent(&DeviceExtension->RemoveEvent, IO_NO_INCREMENT, FALSE);
    }

    KeReleaseSpinLock(&DeviceExtension->IOCountLock, oldIrql);

    SSDbgPrint(3, ("SSIoDecrement::%d\n", result));

    return result;
}

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely stopped. In our 
    particular case, we'll assume we can always stop the device.
    A device might fail the request if it doesn't have a queue for the
    requests it might come or if it was notified that it is in the paging
    path. 
  
Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.

Return Value:

    STATUS_SUCCESS if the device can be safely stopped, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can stop the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine determines whether the device can be safely removed. In our 
    particular case, we'll assume we can always remove the device.
    A device shouldn't be removed if, for example, it has open handles or
    removing the device could result in losing data (plus the reasons 
    mentioned at CanStopDevice). The PnP manager on Windows 2000 fails 
    on its own any attempt to remove, if there any open handles to the device. 
    However on Win9x, the driver must keep count of open handles and fail 
    query_remove if there are any open handles.

Arguments:

    DeviceObject - pointer to the device object.
    
    Irp - pointer to the current IRP.
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // We assume we can remove the device
   //

   UNREFERENCED_PARAMETER(DeviceObject);
   UNREFERENCED_PARAMETER(Irp);

   return STATUS_SUCCESS;
}

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++
 
Routine Description:

    This routine returns all the memory allocations acquired during
    device startup. 
    
Arguments:

    DeviceObject - pointer to the device object.
        
    
Return Value:

    STATUS_SUCCESS if the device can be safely removed, an appropriate 
    NT Status if not.

--*/
{
   //
   // Disconnect from the interrupt and unmap any I/O ports
   //

   UNREFERENCED_PARAMETER(DeviceObject);

   return STATUS_SUCCESS;
}

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE\n";

        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE\n";

        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE\n";

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE\n";

        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE\n";

        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE\n";

        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE\n";

        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS\n";

        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE\n";

        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES\n";

        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES\n";

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT\n";

        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS\n";

        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG\n";

        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG\n";

        case IRP_MN_EJECT:
            return "IRP_MN_EJECT\n";

        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK\n";

        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID\n";

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE\n";

        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION\n";

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION\n";

        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sspnp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSPnP.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __PNP_H
#define __PNP_H

#define REMOTE_WAKEUP_MASK 0x20

NTSTATUS
SS_DispatchPnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleSurpriseRemoval(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleCancelStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
HandleQueryCapabilities(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReadandSelectDescriptors(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ConfigureDevice(
	IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
SelectInterfaces(
	IN PDEVICE_OBJECT                DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor
    );

NTSTATUS
DeconfigureDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB           Urb
    );

VOID
ProcessQueuedRequests(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchClean(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
DpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
IdleRequestWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    );

NTSTATUS
SS_GetRegistryDword(
    IN     PWCHAR RegPath,
    IN     PWCHAR ValueName,
    IN OUT PULONG Value
    );

NTSTATUS
IrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
CanStopDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
CanRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
ReleaseMemory(
    IN PDEVICE_OBJECT DeviceObject
    );

LONG
SSIoIncrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

LONG
SSIoDecrement(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

BOOLEAN
CanDeviceSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

PCHAR
PnPMinorFunctionString (
    IN UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\ssdevctr.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSDevCtr.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __DEV_CTRL_H
#define __DEV_CTRL_H

NTSTATUS
SS_DispatchCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SS_DispatchDevCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SubmitIdleRequestIrp(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
IdleNotificationCallback(
    IN PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
IdleNotificationRequestComplete(
    IN PDEVICE_OBJECT    DeviceObject,
    IN PIRP              Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
CancelSelectSuspend(
    IN PDEVICE_EXTENSION DeviceExtension
    );

VOID
PoIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
PoIrpAsyncCompletionFunc(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
WWIrpCompletionFunc(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\selsusp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    selSusp.h

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include <initguid.h>
#include <wdm.h>
#include <wmilib.h>
#include <wmistr.h>
#include "usbdi.h"
#include "usbdlib.h"

#ifndef _SUSPEND_LOCAL_H
#define _SUSPEND_LOCAL_H

#define SSTAG (ULONG) 'SleS'

#undef ExAllocatePool
#define ExAllocatePool(type, size) \
    ExAllocatePoolWithTag(type, size, SSTAG);

#if DBG

#define SSDbgPrint(level, _x_) \
            if((level) <= DebugLevel) { \
                DbgPrint _x_; \
            }
#else

#define SSDbgPrint(level, _x_)

#endif

typedef struct _GLOBALS {

    UNICODE_STRING SSRegistryPath;

} GLOBALS;

#define IDLE_INTERVAL 5000

typedef enum _DEVSTATE {

    NotStarted,         // not started
    Stopped,            // device stopped
    Working,            // started and working
    PendingStop,        // stop pending
    PendingRemove,      // remove pending
    SurpriseRemoved,    // removed by surprise
    Removed             // removed

} DEVSTATE;

typedef enum _QUEUE_STATE {

    HoldRequests,       // device is not started yet
    AllowRequests,      // device is ready to process
    FailRequests        // fail both existing and queued up requests

} QUEUE_STATE;

typedef enum _WDM_VERSION {

    WinXpOrBetter,
    Win2kOrBetter,
    WinMeOrBetter,
    Win98OrBetter

} WDM_VERSION;

#define INITIALIZE_PNP_STATE(_Data_)    \
        (_Data_)->DeviceState =  NotStarted;\
        (_Data_)->PrevDevState = NotStarted;

#define SET_NEW_PNP_STATE(_Data_, _state_) \
        (_Data_)->PrevDevState =  (_Data_)->DeviceState;\
        (_Data_)->DeviceState = (_state_);

#define RESTORE_PREVIOUS_PNP_STATE(_Data_)   \
        (_Data_)->DeviceState =   (_Data_)->PrevDevState;

//
// registry path used for parameters 
// global to all instances of the driver
//

#define SELSUSP_REGISTRY_PARAMETERS_PATH  \
	L"\\REGISTRY\\Machine\\System\\CurrentControlSet\\SERVICES\\SELSUSP\\Parameters"

//
// A structure representing the instance information associated with
// this particular device.
//

typedef struct _DEVICE_EXTENSION {

    // Functional Device Object
    PDEVICE_OBJECT FunctionalDeviceObject;

    // Device object we call when submitting Urbs
    PDEVICE_OBJECT TopOfStackDeviceObject;

    // The bus driver object
    PDEVICE_OBJECT PhysicalDeviceObject;

    // Name buffer for our named Functional device object link
    // The name is generated based on the driver's class GUID
    UNICODE_STRING InterfaceName;

    //Bus drivers set the appropriate values in this structure in response
    //to an IRP_MN_QUERY_CAPABILITIES IRP. Function and filter drivers might
    //alter the capabilities set by the bus driver.
    DEVICE_CAPABILITIES DeviceCapabilities;

    // current state of device
    DEVSTATE DeviceState;

    // state prior to removal query
    DEVSTATE PrevDevState;

    // obtain and hold this lock while changing the device state,
    // the queue state and while processing the queue.
    KSPIN_LOCK DevStateLock;

    // current system power state
    SYSTEM_POWER_STATE SysPower;

    // current device power state
    DEVICE_POWER_STATE DevPower;

    // Pending I/O queue state
    QUEUE_STATE QueueState;

    // Pending I/O queue
    LIST_ENTRY NewRequestsQueue;

    // I/O Queue Lock
    KSPIN_LOCK QueueLock;

    KEVENT RemoveEvent;

    KEVENT StopEvent;
    
    ULONG OutStandingIO;

    KSPIN_LOCK IOCountLock;

    // selective suspend variables

    LONG SSEnable;

    LONG SSRegistryEnable;

    PUSB_IDLE_CALLBACK_INFO IdleCallbackInfo;
	
    PIRP PendingIdleIrp;
	
    LONG IdleReqPend;

    LONG FreeIdleIrpCount;

    KSPIN_LOCK IdleReqStateLock;

    KEVENT NoIdleReqPendEvent;

    // default power state to power down to on self-susped
    ULONG PowerDownLevel;
    
    // remote wakeup variables
    PIRP WaitWakeIrp;

    LONG FlagWWCancel;

    LONG FlagWWOutstanding;

    LONG WaitWakeEnable;

    // open handle count
    LONG OpenHandleCount;

    // selective suspend model uses timers, dpcs and work item.
    KTIMER Timer;

    KDPC DeferredProcCall;

    // This event is cleared when a DPC/Work Item is queued.
    // and signaled when the work-item completes.
    // This is essential to prevent the driver from unloading
    // while we have DPC or work-item queued up.
    KEVENT NoDpcWorkItemPendingEvent;

    // WMI information
    WMILIB_CONTEXT WmiLibInfo;

    // WDM version
    WDM_VERSION WdmVersion;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

typedef struct _IRP_COMPLETION_CONTEXT {

    PDEVICE_EXTENSION DeviceExtension;

    PKEVENT Event;

} IRP_COMPLETION_CONTEXT, *PIRP_COMPLETION_CONTEXT;

extern GLOBALS Globals;
extern ULONG DebugLevel;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sspwr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSPwr.c

Abstract:

    The power management related processing.

    The Power Manager uses IRPs to direct drivers to change system
    and device power levels, to respond to system wake-up events,
    and to query drivers about their devices. All power IRPs have
    the major function code IRP_MJ_POWER.

    Most function and filter drivers perform some processing for
    each power IRP, then pass the IRP down to the next lower driver
    without completing it. Eventually the IRP reaches the bus driver,
    which physically changes the power state of the device and completes
    the IRP.

    When the IRP has been completed, the I/O Manager calls any
    IoCompletion routines set by drivers as the IRP traveled
    down the device stack. Whether a driver needs to set a completion
    routine depends upon the type of IRP and the driver's individual
    requirements.

    This code is not USB specific. It is essential for every WDM driver
    to handle power irps.

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSUsr.h"
#include "sSWmi.h"

NTSTATUS
SS_DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    The power dispatch routine.

Arguments:

    DeviceObject - pointer to a device object.

    Irp - pointer to an I/O Request Packet.

Return Value:

    NT status code

--*/
{
    NTSTATUS           ntStatus;
    PIO_STACK_LOCATION irpStack;
    PUNICODE_STRING    tagString;
    PDEVICE_EXTENSION  deviceExtension;
	
    //
    // initialize the variables
    //
	
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

    //
    // We don't queue power Irps, we'll only check if the
    // device was removed, otherwise we'll take appropriate
    // action and send it to the next lower driver. In general
    // drivers should not cause long delays while handling power
    // IRPs. If a driver cannot handle a power IRP in a brief time,
    // it should return STATUS_PENDING and queue all incoming
    // IRPs until the IRP completes.
    //

    if(Removed == deviceExtension->DeviceState) {

        //
        // Even if a driver fails the IRP, it must nevertheless call
        // PoStartNextPowerIrp to inform the Power Manager that it
        // is ready to handle another power IRP.
        //

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    if(NotStarted == deviceExtension->DeviceState) {

        //
        // if the device is not started yet, pass it down
        //

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        return PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("SS_DispatchPower::"));
    SSIoIncrement(deviceExtension);
    
    switch(irpStack->MinorFunction) {
    
    case IRP_MN_SET_POWER:

        //
        // The Power Manager sends this IRP for one of the
        // following reasons:
        // 1) To notify drivers of a change to the system power state.
        // 2) To change the power state of a device for which
        //    the Power Manager is performing idle detection.
        // A driver sends IRP_MN_SET_POWER to change the power
        // state of its device if it's a power policy owner for the
        // device.
        //

        //
        // Mark the Irp as pending and return STATUS_PENDING if we change the 
        // nature of the irp in the completion routine (asynchroniticity).
        // In such cases, do not return the status returned by the lower driver.
        // returning STATUS_MORE_PROCESSING_REQUIRED in the completion routine 
        // transforms the nature of the irp to asynchronous irp.
        //

        IoMarkIrpPending(Irp);

        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:

            HandleSystemSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceSetPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_QUERY_POWER:

        //
        // The Power Manager sends a power IRP with the minor
        // IRP code IRP_MN_QUERY_POWER to determine whether it
        // can safely change to the specified system power state
        // (S1-S5) and to allow drivers to prepare for such a change.
        // If a driver can put its device in the requested state,
        // it sets status to STATUS_SUCCESS and passes the IRP down.
        //

        IoMarkIrpPending(Irp);
    
        switch(irpStack->Parameters.Power.Type) {

        case SystemPowerState:
            
            HandleSystemQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;

        case DevicePowerState:

            HandleDeviceQueryPower(DeviceObject, Irp);

            ntStatus = STATUS_PENDING;

            break;
        }

        break;

    case IRP_MN_WAIT_WAKE:

        //
        // The minor power IRP code IRP_MN_WAIT_WAKE provides
        // for waking a device or waking the system. Drivers
        // of devices that can wake themselves or the system
        // send IRP_MN_WAIT_WAKE. The system sends IRP_MN_WAIT_WAKE
        // only to devices that always wake the system, such as
        // the power-on switch.
        //

        IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                        Irp,
                        (PIO_COMPLETION_ROUTINE)WaitWakeCompletionRoutine,
                        deviceExtension, 
                        TRUE, 
                        TRUE, 
                        TRUE);

        PoStartNextPowerIrp(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed the IRP_MN_WAIT_WAKE Irp"));
        }

        //
        // since we marked the Irp as pending; we should return STATUS_PENDING
        //
        ntStatus = STATUS_PENDING;

        //
        // push back the count HERE and NOT in completion routine
        // a pending Wait Wake Irp should not impede stopping the device
        //

        SSDbgPrint(3, ("IRP_MN_WAIT_WAKE::"));
        SSIoDecrement(deviceExtension);

        break;

    case IRP_MN_POWER_SEQUENCE:

        //
        // A driver sends this IRP as an optimization to determine
        // whether its device actually entered a specific power state.
        // This IRP is optional. Power Manager cannot send this IRP.
        //

    default:

        PoStartNextPowerIrp(Irp);

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed this Irp"));
        }
        
        SSDbgPrint(3, ("SS_DispatchPower::"));
        SSIoDecrement(deviceExtension);

        break;
    }

    return ntStatus;
}

NTSTATUS
HandleSystemQueryPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine handles the irp with minor function of type IRP_MN_QUERY_POWER
    for the system power states.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager.

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    //
    // Fail a query for a power state incompatible with waking up the system
    //

    SSDbgPrint(3, ("Query for a system power state S%X\n"
                   "Current system power state S%X\n",
                   systemState - 1,
                   deviceExtension->SysPower - 1));

    if((deviceExtension->WaitWakeEnable) &&
       (systemState > deviceExtension->DeviceCapabilities.SystemWake)) {

        SSDbgPrint(3, ("query for an incompatible power state\n"));

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleSystemQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    //
    // if querying for a lower S-state, issue a wait-wake
    // also, it is mandatory to have this Irp pending below
    // before we send any of the low power irps.
    //

    if((systemState > deviceExtension->SysPower) &&
       (deviceExtension->WaitWakeEnable)) {

        IssueWaitWake(deviceExtension);
    }

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemQueryPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleSystemSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the system power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    SYSTEM_POWER_STATE systemState;
    PIO_STACK_LOCATION irpStack;
    
    SSDbgPrint(3, ("HandleSystemSetPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    systemState = irpStack->Parameters.Power.State.SystemState;

    SSDbgPrint(3, ("Set request for a system power state S%X\n"
                   "Current system power state S%X\n", 
                   systemState - 1,
                   deviceExtension->SysPower - 1));

    //
    // pass the irp down the stack
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine(
            Irp, 
            (PIO_COMPLETION_ROUTINE)SysPoCompletionRoutine,
            deviceExtension, 
            TRUE, 
            TRUE, 
            TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

    SSDbgPrint(3, ("HandleSystemSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
HandleDeviceQueryPower(
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp
    )
/*++

Routine Description:

    This routine services irps of minor type IRP_MN_QUERY_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    PDEVICE_EXTENSION  deviceExtension;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE deviceState;

    SSDbgPrint(3, ("HandleDeviceQueryPower - begins\n"));

    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceState = irpStack->Parameters.Power.State.DeviceState;

    SSDbgPrint(3, ("Query for a device power state D%X\n"
                   "Current device power state D%X\n", 
                   deviceState - 1,
                   deviceExtension->DevPower - 1));

    if(deviceExtension->WaitWakeEnable &&
       deviceState > deviceExtension->DeviceCapabilities.DeviceWake) {

        SSDbgPrint(3, ("query for an incompatible power state\n"));

        PoStartNextPowerIrp(Irp);

        Irp->IoStatus.Status = ntStatus = STATUS_INVALID_DEVICE_STATE;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("HandleDeviceQueryPower::"));
        SSIoDecrement(deviceExtension);

        return ntStatus;
    }

    if(deviceState < deviceExtension->DevPower) {

        ntStatus = STATUS_SUCCESS;
    }
    else {

        ntStatus = HoldIoRequests(DeviceObject, Irp);

        if(STATUS_PENDING == ntStatus) {

            return ntStatus;
        }
    }

    //
    // on error complete the Irp.
    // on success pass it to the lower layers
    //

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    if(!NT_SUCCESS(ntStatus)) {

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else {

        IoSkipCurrentIrpStackLocation(Irp);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);
    }

    SSDbgPrint(3, ("HandleDeviceQueryPower::"));
    SSIoDecrement(deviceExtension);

    SSDbgPrint(3, ("HandleDeviceQueryPower - ends\n"));

    return ntStatus;
}


NTSTATUS
SysPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the completion routine for the system power irps of minor
    function types IRP_MN_QUERY_POWER and IRP_MN_SET_POWER.
    This completion routine sends the corresponding device power irp and
    returns STATUS_MORE_PROCESSING_REQUIRED. The system irp is passed as a
    context to the device power irp completion routine and is completed in
    the device power irp completion routine.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
 	PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);


    SSDbgPrint(3, ("SysPoCompletionRoutine - begins\n"));

    //
    // lower drivers failed this Irp
    //

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("SysPoCompletionRoutine::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    //
    // ..otherwise update the cached system power state (IRP_MN_SET_POWER)
    //

    if(irpStack->MinorFunction == IRP_MN_SET_POWER) {

        DeviceExtension->SysPower = irpStack->Parameters.Power.State.SystemState;
    }

    //
    // queue device irp and return STATUS_MORE_PROCESSING_REQUIRED
    //
	
    SendDeviceIrp(DeviceObject, Irp);

    SSDbgPrint(3, ("SysPoCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
SendDeviceIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP SIrp
    )
/*++
 
Routine Description:

    This routine is invoked from the completion routine of the system power
    irp. This routine will PoRequest a device power irp. The system irp is 
    passed as a context to the the device power irp.

Arguments:

    DeviceObject - pointer to device object
    SIrp - system power irp.

Return Value:

    None

--*/
{
    NTSTATUS                  ntStatus;
    POWER_STATE               powState;
    PDEVICE_EXTENSION         deviceExtension;
    PIO_STACK_LOCATION        irpStack;
    SYSTEM_POWER_STATE        systemState;
    DEVICE_POWER_STATE        devState;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    irpStack = IoGetCurrentIrpStackLocation(SIrp);
    systemState = irpStack->Parameters.Power.State.SystemState;
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("SendDeviceIrp - begins\n"));

    //
    // Read out the D-IRP out of the S->D mapping array captured in QueryCap's.
    // we can choose deeper sleep states than our mapping but never choose
    // lighter ones.
    //

    devState = deviceExtension->DeviceCapabilities.DeviceState[systemState];
    powState.DeviceState = devState;
    
    powerContext = (PPOWER_COMPLETION_CONTEXT) 
                   ExAllocatePool(NonPagedPool,
                                  sizeof(POWER_COMPLETION_CONTEXT));

    if(!powerContext) {

        SSDbgPrint(1, ("Failed to alloc memory for powerContext\n"));

        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else {

        powerContext->DeviceObject = DeviceObject;
        powerContext->SIrp = SIrp;
   
        //
        // in win2k PoRequestPowerIrp can take fdo or pdo.
        //

        ntStatus = PoRequestPowerIrp(
                            deviceExtension->PhysicalDeviceObject, 
                            irpStack->MinorFunction,
                            powState,
                            (PREQUEST_POWER_COMPLETE)DevPoCompletionRoutine,
                            powerContext, 
                            NULL);
    }

    if(!NT_SUCCESS(ntStatus)) {

        if(powerContext) {

            ExFreePool(powerContext);
        }

        PoStartNextPowerIrp(SIrp);

        SIrp->IoStatus.Status = ntStatus;
        SIrp->IoStatus.Information = 0;
        
        IoCompleteRequest(SIrp, IO_NO_INCREMENT);

        SSDbgPrint(3, ("SendDeviceIrp::"));
        SSIoDecrement(deviceExtension);

    }

    SSDbgPrint(3, ("SendDeviceIrp - ends\n"));
}


VOID
DevPoCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject, 
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest - completion routine for the device power irp.
    This routine is responsible for completing the system power irp, 
    received as a context.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - minor function of the irp.
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status of the device power irp.

Return Value:

    None

--*/
{
    PIRP                      sIrp;
    PDEVICE_EXTENSION         deviceExtension;
    PPOWER_COMPLETION_CONTEXT powerContext;
    
    //
    // initialize variables
    //

    powerContext = (PPOWER_COMPLETION_CONTEXT) Context;
    sIrp = powerContext->SIrp;
    deviceExtension = powerContext->DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("DevPoCompletionRoutine - begins\n"));

    //
    // copy the D-Irp status into S-Irp
    //

    sIrp->IoStatus.Status = IoStatus->Status;

    //
    // complete the system Irp
    //
    
    PoStartNextPowerIrp(sIrp);

    sIrp->IoStatus.Information = 0;

    IoCompleteRequest(sIrp, IO_NO_INCREMENT);

    //
    // cleanup
    //
    
    SSDbgPrint(3, ("DevPoCompletionRoutine::"));
    SSIoDecrement(deviceExtension);

    ExFreePool(powerContext);

    SSDbgPrint(3, ("DevPoCompletionRoutine - ends\n"));

}

NTSTATUS
HandleDeviceSetPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    This routine services irps of minor type IRP_MN_SET_POWER
    for the device power state

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet sent by the power manager

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;    
    PIO_STACK_LOCATION irpStack;
    PDEVICE_EXTENSION  deviceExtension;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    SSDbgPrint(3, ("HandleDeviceSetPower - begins\n"));
	
    //
    // initialize variables
    //

    deviceExtension = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    oldDevState = deviceExtension->DevPower;
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;

    SSDbgPrint(3, ("Set request for a device power state D%X\n"
                   "Current device power state D%X\n", 
                   newDevState - 1,
                   deviceExtension->DevPower - 1));

    if(newDevState < oldDevState) {

        //
        // adding power
        //
        SSDbgPrint(3, ("Adding power to the device\n"));

        //
        // send the power IRP to the next driver in the stack
        //
        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE)FinishDevPoUpIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

	}
    else {

        //
        // newDevState >= oldDevState 
        //
        // hold I/O if transition from D0 -> DX (X = 1, 2, 3)
        // if transition from D1 or D2 to deeper sleep states, 
        // I/O queue is already on hold.
        //

        if(PowerDeviceD0 == oldDevState && newDevState > oldDevState) {

            //
            // D0 -> DX transition
            //

            SSDbgPrint(3, ("Removing power from the device\n"))

            ntStatus = HoldIoRequests(DeviceObject, Irp);

            if(!NT_SUCCESS(ntStatus)) {

                PoStartNextPowerIrp(Irp);

                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                IoCompleteRequest(Irp, IO_NO_INCREMENT);

                SSDbgPrint(3, ("HandleDeviceSetPower::"));
                SSIoDecrement(deviceExtension);

                return ntStatus;
            }
            else {

                goto HandleDeviceSetPower_Exit;
            }
        }
        else if(PowerDeviceD0 == oldDevState && PowerDeviceD0 == newDevState) {

            //
            // D0 -> D0
            // unblock the queue which may have been blocked processing
            // query irp
            //
            
            SSDbgPrint(3, ("A SetD0 power request for the device\n"))

            KeAcquireSpinLock(&deviceExtension->DevStateLock, &oldIrql);
              
            deviceExtension->QueueState = AllowRequests;

            KeReleaseSpinLock(&deviceExtension->DevStateLock, oldIrql);

            ProcessQueuedRequests(deviceExtension);
        }   

        IoCopyCurrentIrpStackLocationToNext(Irp);

        IoSetCompletionRoutine(
                Irp, 
                (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                deviceExtension, 
                TRUE, 
                TRUE, 
                TRUE);

        ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, Irp);

        if(!NT_SUCCESS(ntStatus)) {

            SSDbgPrint(1, ("Lower drivers failed a power Irp\n"));
        }

    }

HandleDeviceSetPower_Exit:

    SSDbgPrint(3, ("HandleDeviceSetPower - ends\n"));

    return STATUS_PENDING;
}

NTSTATUS
FinishDevPoUpIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    completion routine for the device power UP irp with minor function
    IRP_MN_SET_POWER.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
                        
    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;

    SSDbgPrint(3, ("FinishDevPoUpIrp - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    if(!NT_SUCCESS(ntStatus)) {

        PoStartNextPowerIrp(Irp);

        SSDbgPrint(3, ("FinishDevPoUpIrp::"));
        SSIoDecrement(DeviceExtension);

        return STATUS_SUCCESS;
    }

    SetDeviceFunctional(DeviceObject, Irp, DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoUpIrp - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SetDeviceFunctional(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine processes queue of pending irps.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    KIRQL              oldIrql;
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;
    DEVICE_POWER_STATE newDevState,
                       oldDevState;

    //
    // initialize variables
    //

    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;
    newDevState = newState.DeviceState;
    oldDevState = DeviceExtension->DevPower;

    SSDbgPrint(3, ("SetDeviceFunctional - begins\n"));

    //
    // update the cached state
    //
    DeviceExtension->DevPower = newDevState;

    //
    // restore appropriate amount of state to our h/w
    // this driver does not implement partial context
    // save/restore.
    //

    PoSetPowerState(DeviceObject, DevicePowerState, newState);

    if(PowerDeviceD0 == newDevState) {

    //
    // empty existing queue of all pending irps.
    //

        KeAcquireSpinLock(&DeviceExtension->DevStateLock, &oldIrql);

        DeviceExtension->QueueState = AllowRequests;
        
        KeReleaseSpinLock(&DeviceExtension->DevStateLock, oldIrql);

        ProcessQueuedRequests(DeviceExtension);
    }

    PoStartNextPowerIrp(Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("SetDeviceFunctional::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("SetDeviceFunctional - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
FinishDevPoDnIrp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine is the completion routine for device power DOWN irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    NTSTATUS           ntStatus;
    POWER_STATE        newState;
    PIO_STACK_LOCATION irpStack;

    //
    // initialize variables
    //
    ntStatus = Irp->IoStatus.Status;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    newState = irpStack->Parameters.Power.State;

    SSDbgPrint(3, ("FinishDevPoDnIrp - begins\n"));

    if(NT_SUCCESS(ntStatus) && irpStack->MinorFunction == IRP_MN_SET_POWER) {

        //
        // update the cache;
        //

        SSDbgPrint(3, ("updating cache..\n"));

        DeviceExtension->DevPower = newState.DeviceState;

        PoSetPowerState(DeviceObject, DevicePowerState, newState);
    }

    PoStartNextPowerIrp(Irp);

    SSDbgPrint(3, ("FinishDevPoDnIrp::"));
    SSIoDecrement(DeviceExtension);

    SSDbgPrint(3, ("FinishDevPoDnIrp - ends\n"));

    return STATUS_SUCCESS;
}

NTSTATUS
HoldIoRequests(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine is called on query or set power DOWN irp for the device.
    This routine queues a workitem.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    NT status value

--*/
{
    NTSTATUS               ntStatus;
    PIO_WORKITEM           item;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, ("HoldIoRequests - begins\n"));

    deviceExtension->QueueState = HoldRequests;

    context = ExAllocatePool(NonPagedPool, sizeof(WORKER_THREAD_CONTEXT));

    if(context) {

        item = IoAllocateWorkItem(DeviceObject);

        context->Irp = Irp;
        context->DeviceObject = DeviceObject;
        context->WorkItem = item;

        if(item) {

            IoMarkIrpPending(Irp);
            
            IoQueueWorkItem(item, HoldIoRequestsWorkerRoutine,
                            DelayedWorkQueue, context);
            
            ntStatus = STATUS_PENDING;
        }
        else {

            SSDbgPrint(3, ("Failed to allocate memory for workitem\n"));
            ExFreePool(context);
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else {

        SSDbgPrint(1, ("Failed to alloc memory for worker thread context\n"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    SSDbgPrint(3, ("HoldIoRequests - ends\n"));

    return ntStatus;
}

VOID
HoldIoRequestsWorkerRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context
    )
/*++
 
Routine Description:

    This routine waits for the I/O in progress to finish and then
    sends the device power irp (query/set) down the stack.

Arguments:

    DeviceObject - pointer to device object
    Context - context passed to the work-item.

Return Value:

    None

--*/
{
    PIRP                   irp;
    NTSTATUS               ntStatus;
    PDEVICE_EXTENSION      deviceExtension;
    PWORKER_THREAD_CONTEXT context;

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - begins\n"));

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    context = (PWORKER_THREAD_CONTEXT) Context;
    irp = (PIRP) context->Irp;


    //
    // wait for I/O in progress to finish.
    // the stop event is signalled when the counter drops to 1.
    // invoke SSIoDecrement twice: once each for the S-Irp and D-Irp.
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoDecrement(deviceExtension);

    KeWaitForSingleObject(&deviceExtension->StopEvent, Executive,
                          KernelMode, FALSE, NULL);

    //
    // Increment twice to restore the count
    //
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);
    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine::"));
    SSIoIncrement(deviceExtension);

    // 
    // now send the Irp down
    //

    IoCopyCurrentIrpStackLocationToNext(irp);

    IoSetCompletionRoutine(irp, (PIO_COMPLETION_ROUTINE) FinishDevPoDnIrp,
                           deviceExtension, TRUE, TRUE, TRUE);

    ntStatus = PoCallDriver(deviceExtension->TopOfStackDeviceObject, irp);

    if(!NT_SUCCESS(ntStatus)) {

        SSDbgPrint(1, ("Lower driver fail a power Irp\n"));
    }

    IoFreeWorkItem(context->WorkItem);
    ExFreePool((PVOID)context);

    SSDbgPrint(3, ("HoldIoRequestsWorkerRoutine - ends\n"));

}

NTSTATUS
QueueRequest(
    IN OUT PDEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
 
Routine Description:

    Queue the Irp in the device queue

Arguments:

    DeviceExtension - pointer to device extension
    Irp - I/O request packet.

Return Value:

    NT status value

--*/
{
    KIRQL    oldIrql;
    NTSTATUS ntStatus;

    //
    // initialize variables
    //
    ntStatus = STATUS_PENDING;

    SSDbgPrint(3, ("QueueRequests - begins\n"));

    ASSERT(HoldRequests == DeviceExtension->QueueState);

    KeAcquireSpinLock(&DeviceExtension->QueueLock, &oldIrql);

    InsertTailList(&DeviceExtension->NewRequestsQueue, 
                   &Irp->Tail.Overlay.ListEntry);

    IoMarkIrpPending(Irp);

    //
    // Set the cancel routine
    //

    IoSetCancelRoutine(Irp, CancelQueued);

    KeReleaseSpinLock(&DeviceExtension->QueueLock, oldIrql);

    SSDbgPrint(3, ("QueueRequests - ends\n"));

    return ntStatus;
}

VOID
CancelQueued(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

    This routine removes the irp from the queue and completes it with
    STATUS_CANCELLED

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet

Return Value:

    None.

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    KIRQL             oldIrql;

    //
    // initialize variables
    //
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    oldIrql = Irp->CancelIrql;

    SSDbgPrint(3, ("CancelQueued - begins\n"));

    //
    // Release the cancel spin lock
    //

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    //
    // Acquire the queue lock
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->QueueLock);

    //
    // Remove the cancelled Irp from queue and release the lock
    //
    RemoveEntryList(&Irp->Tail.Overlay.ListEntry);

    KeReleaseSpinLock(&deviceExtension->QueueLock, oldIrql);

    //
    // complete with STATUS_CANCELLED
    //

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    SSDbgPrint(3, ("CancelQueued - ends\n"));

    return;
}

NTSTATUS
IssueWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine will PoRequest a WAIT WAKE irp for the device

Arguments:

    DeviceExtension - pointer to device extension

Return Value:

    NT status value.

--*/
{
    POWER_STATE poState;
    NTSTATUS    ntStatus;

    SSDbgPrint(3, ("IssueWaitWake - begins\n"));

    if(InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 1)) {

        SSDbgPrint(3, ("Outstanding wait wake Irp\n"));

        return STATUS_DEVICE_BUSY;
    }

    InterlockedExchange(&DeviceExtension->FlagWWCancel, 0);

    //
    // lowest state from which this Irp will wake the system
    //

    poState.SystemState = DeviceExtension->DeviceCapabilities.SystemWake;

    ntStatus = PoRequestPowerIrp(DeviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 poState, 
                                 (PREQUEST_POWER_COMPLETE) WaitWakeCallback,
                                 DeviceExtension, 
                                 &DeviceExtension->WaitWakeIrp);

    if(!NT_SUCCESS(ntStatus)) {

        InterlockedExchange(&DeviceExtension->FlagWWOutstanding, 0);
    }

    SSDbgPrint(3, ("IssueWaitWake - ends\n"));

    return ntStatus;
}

VOID
CancelWaitWake(
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This routine cancels the Wait Wake request.

Arguments:

    DeviceExtension - pointer to the device extension

Return Value:

    None.

--*/
{
    PIRP Irp;

    SSDbgPrint(3, ("CancelWaitWake - begins\n"));

    Irp = (PIRP) InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, 
                                            NULL);

    if(Irp) {

        IoCancelIrp(Irp);

        if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

            PoStartNextPowerIrp(Irp);

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;

            IoCompleteRequest(Irp, IO_NO_INCREMENT);
        }    
    }

    SSDbgPrint(3, ("CancelWaitWake - ends\n"));
}

NTSTATUS
WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_EXTENSION DeviceExtension
    )
/*++
 
Routine Description:

    This is the IoSet completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    Irp - I/O request packet
    DeviceExtension - pointer to device extension

Return Value:

    NT status value

--*/
{
    SSDbgPrint(3, ("WaitWakeCompletionRoutine - begins\n"));

    if(Irp->PendingReturned) {

        IoMarkIrpPending(Irp);
    }

    //
    // Nullify the WaitWakeIrp pointer-the Irp is released 
    // as part of the completion process. If it's already NULL, 
    // avoid race with the CancelWaitWake routine.
    //

    if(InterlockedExchangePointer(&DeviceExtension->WaitWakeIrp, NULL)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_SUCCESS;
    }

    //
    // CancelWaitWake has run. 
    // If FlagWWCancel != 0, complete the Irp.
    // If FlagWWCancel == 0, CancelWaitWake completes it.
    //
    if(InterlockedExchange(&DeviceExtension->FlagWWCancel, 1)) {

        PoStartNextPowerIrp(Irp);

        return STATUS_CANCELLED;
    }

    SSDbgPrint(3, ("WaitWakeCompletionRoutine - ends\n"));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

VOID
WaitWakeCallback( 
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
/*++
 
Routine Description:

    This is the PoRequest completion routine for the wait wake irp.

Arguments:

    DeviceObject - pointer to device object
    MinorFunction - irp minor function
    PowerState - power state of the irp.
    Context - context passed to the completion routine.
    IoStatus - status block.

Return Value:

    None

--*/
{
    NTSTATUS               ntStatus;
    POWER_STATE            powerState;
    PDEVICE_EXTENSION      deviceExtension;

    SSDbgPrint(3, ("WaitWakeCallback - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) Context;

    InterlockedExchange(&deviceExtension->FlagWWOutstanding, 0);

    if(!NT_SUCCESS(IoStatus->Status)) {

        return;
    }

    //
    // wake up the device
    //

    if(deviceExtension->DevPower == PowerDeviceD0) {

        SSDbgPrint(3, ("device already powered up...\n"));

        return;
    }

    SSDbgPrint(3, ("WaitWakeCallback::"));
    SSIoIncrement(deviceExtension);

    powerState.DeviceState = PowerDeviceD0;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER, 
                                 powerState, 
                                 (PREQUEST_POWER_COMPLETE) WWIrpCompletionFunc,
                                 deviceExtension, 
                                 NULL);

    if(deviceExtension->WaitWakeEnable) {
    
        IssueWaitWake(deviceExtension);
    }

    SSDbgPrint(3, ("WaitWakeCallback - ends\n"));

    return;
}


PCHAR
PowerMinorFunctionString (
    IN UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER\n";

        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER\n";

        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE\n";

        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sswmi.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sSWmi.h

Abstract:
    
Environment:

    Kernel mode

Notes:

  	Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#ifndef __WMI_H
#define __WMI_H

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    );

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
SSQueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo	    
    );

NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    );

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    );

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\selsusp\sys\sswmi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sSWmi.c

Abstract:

Environment:

    Kernel mode

Notes:

    Copyright (c) 2000 Microsoft Corporation.  
    All Rights Reserved.

--*/

#include "selSusp.h"
#include "sSPwr.h"
#include "sSPnP.h"
#include "sSDevCtr.h"
#include "sSWmi.h"
#include "sSUsr.h"

#define MOFRESOURCENAME L"MofResourceName"

#define WMI_SELECT_SUSPEND_DRIVER_INFORMATION 0

DEFINE_GUID (SELECT_SUSPEND_WMI_STD_DATA_GUID, 
0xBBA21300, 0x6DD3, 0x11d2, 0xB8, 0x44, 0x00, 0xC0, 0x4F, 0xAD, 0x51, 0x71);

WMIGUIDREGINFO SSWmiGuidList[1] = { {

        &SELECT_SUSPEND_WMI_STD_DATA_GUID, 1, 0 // driver information
    }
};

NTSTATUS
SSWmiRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    Registers with WMI as a data provider for this
    instance of the device

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    
    PAGED_CODE();

    DeviceExtension->WmiLibInfo.GuidCount = 
          sizeof (SSWmiGuidList) / sizeof (WMIGUIDREGINFO);

    DeviceExtension->WmiLibInfo.GuidList           = SSWmiGuidList;
    DeviceExtension->WmiLibInfo.QueryWmiRegInfo    = SSQueryWmiRegInfo;
    DeviceExtension->WmiLibInfo.QueryWmiDataBlock  = SSQueryWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataBlock    = SSSetWmiDataBlock;
    DeviceExtension->WmiLibInfo.SetWmiDataItem     = SSSetWmiDataItem;
    DeviceExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DeviceExtension->WmiLibInfo.WmiFunctionControl = NULL;

    //
    // Register with WMI
    //
    
    ntStatus = IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                        WMIREG_ACTION_REGISTER);

    return ntStatus;
    
}

NTSTATUS
SSWmiDeRegistration(
    IN OUT PDEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

     Inform WMI to remove this DeviceObject from its 
     list of providers. This function also 
     decrements the reference count of the deviceobject.

Arguments:

Return Value:

--*/
{

    PAGED_CODE();

    return IoWMIRegistrationControl(DeviceExtension->FunctionalDeviceObject,
                                    WMIREG_ACTION_DEREGISTER);

}

NTSTATUS
SS_DispatchSysCtrl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    PDEVICE_EXTENSION       deviceExtension;
    SYSCTL_IRP_DISPOSITION  disposition;
    NTSTATUS                ntStatus;
    PIO_STACK_LOCATION      irpStack;
    
    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    SSDbgPrint(3, (WMIMinorFunctionString(irpStack->MinorFunction)));

    if(Removed == deviceExtension->DeviceState) {

        ntStatus = STATUS_DELETE_PENDING;

        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        return ntStatus;
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoIncrement(deviceExtension);

    ntStatus = WmiSystemControl(&deviceExtension->WmiLibInfo, 
                                DeviceObject, 
                                Irp,
                                &disposition);

    switch(disposition) {

        case IrpProcessed: 
        {
            //
            // This irp has been processed and may be completed or pending.
            //

            break;
        }
        
        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now
            //

            IoCompleteRequest(Irp, IO_NO_INCREMENT);                

            break;
        }
        
        case IrpForward:
        case IrpNotWmi:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targeted
            // at a device lower in the stack.
            //

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                    Irp);

            break;
        }
                                    
        default:
        {
            //
            // We really should never get here, but if we do just forward....
            //

            ASSERT(FALSE);

            IoSkipCurrentIrpStackLocation (Irp);

            ntStatus = IoCallDriver(deviceExtension->TopOfStackDeviceObject, 
                                  Irp);
            break;
        }        
    }

    SSDbgPrint(3, ("SS_DispatchSysCtrl::"));
    SSIoDecrement(deviceExtension);

    return ntStatus;
}

NTSTATUS
SSQueryWmiRegInfo(
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT ULONG           *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT  *Pdo	    
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is returned in 
        *RegFlags.

Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiRegInfo - begins\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    *RegFlags     = WMIREG_FLAG_INSTANCE_PDO;
    *RegistryPath = &Globals.SSRegistryPath;
    *Pdo          = deviceExtension->PhysicalDeviceObject;
    RtlInitUnicodeString(MofResourceName, MOFRESOURCENAME);

    SSDbgPrint(3, ("SSQueryWmiRegInfo - ends\n"));
    
    return STATUS_SUCCESS;
}

NTSTATUS
SSQueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          InstanceCount,
    IN OUT PULONG     InstanceLengthArray,
    IN ULONG          OutBufferSize,
    OUT PUCHAR        Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instances expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fulfill the request
        so the irp should be completed with the buffer needed.        
            
    OutBufferSize has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             size;
    WCHAR             modelName[] = L"Aishverya\0\0";
    USHORT            modelNameLen;

    PAGED_CODE();

    SSDbgPrint(3, ("SSQueryWmiDataBlock - begins\n"));

    size = 0;
    modelNameLen = (wcslen(modelName) + 1) * sizeof(WCHAR);

    //
    // Only ever registers 1 instance per guid
    //

    ASSERT((InstanceIndex == 0) &&
           (InstanceCount == 1));
    
    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    switch (GuidIndex) {

    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        size = sizeof(ULONG) + modelNameLen + sizeof(USHORT);

        if (OutBufferSize < size ) {

            SSDbgPrint(3, ("OutBuffer too small\n"));

            ntStatus = STATUS_BUFFER_TOO_SMALL;

            break;
        }

        * (PULONG) Buffer = DebugLevel;

        Buffer += sizeof(ULONG);

        //
        // put length of string ahead of string
        //

        *((PUSHORT)Buffer) = modelNameLen;

        Buffer = (PUCHAR)Buffer + sizeof(USHORT);

        RtlCopyBytes((PVOID)Buffer, (PVOID)modelName, modelNameLen);

        *InstanceLengthArray = size ;

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                size,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSQueryWmiDataBlock - ends\n"));

    return ntStatus;
}


NTSTATUS
SSSetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          DataItemId,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;
    
    PAGED_CODE();

    SSDbgPrint(3, ("SSSetWmiDataItem - begins\n"));

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(DataItemId == 1) {

            if(BufferSize == sizeof(ULONG)) {

                DebugLevel = *((PULONG)Buffer);

                ntStatus = STATUS_SUCCESS;

                info = sizeof(ULONG);
            }
            else {

                ntStatus = STATUS_INFO_LENGTH_MISMATCH;
            }
        }
        else {

            ntStatus = STATUS_WMI_READ_ONLY;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataItem - ends\n"));

    return ntStatus;
}

NTSTATUS
SSSetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN ULONG          GuidIndex,
    IN ULONG          InstanceIndex,
    IN ULONG          BufferSize,
    IN PUCHAR         Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call WmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS          ntStatus;
    ULONG             info;

    PAGED_CODE();

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    info = 0;

    SSDbgPrint(3, ("SSSetWmiDataBlock - begins\n"));

    switch(GuidIndex) {
    
    case WMI_SELECT_SUSPEND_DRIVER_INFORMATION:

        if(BufferSize == sizeof(ULONG)) {

            DebugLevel = *(PULONG) Buffer;
                    
            ntStatus = STATUS_SUCCESS;

            info = sizeof(ULONG);
        }
        else {

            ntStatus = STATUS_INFO_LENGTH_MISMATCH;
        }

        break;

    default:

        ntStatus = STATUS_WMI_GUID_NOT_FOUND;
    }

    ntStatus = WmiCompleteRequest(DeviceObject,
                                Irp,
                                ntStatus,
                                info,
                                IO_NO_INCREMENT);

    SSDbgPrint(3, ("SSSetWmiDataBlock - ends\n"));

    return ntStatus;
}

PCHAR
WMIMinorFunctionString (
    UCHAR MinorFunction
    )
/*++
 
Routine Description:

Arguments:

Return Value:

--*/
{
    switch (MinorFunction) {

        case IRP_MN_CHANGE_SINGLE_INSTANCE:
            return "IRP_MN_CHANGE_SINGLE_INSTANCE\n";

        case IRP_MN_CHANGE_SINGLE_ITEM:
            return "IRP_MN_CHANGE_SINGLE_ITEM\n";

        case IRP_MN_DISABLE_COLLECTION:
            return "IRP_MN_DISABLE_COLLECTION\n";

        case IRP_MN_DISABLE_EVENTS:
            return "IRP_MN_DISABLE_EVENTS\n";

        case IRP_MN_ENABLE_COLLECTION:
            return "IRP_MN_ENABLE_COLLECTION\n";

        case IRP_MN_ENABLE_EVENTS:
            return "IRP_MN_ENABLE_EVENTS\n";

        case IRP_MN_EXECUTE_METHOD:
            return "IRP_MN_EXECUTE_METHOD\n";

        case IRP_MN_QUERY_ALL_DATA:
            return "IRP_MN_QUERY_ALL_DATA\n";

        case IRP_MN_QUERY_SINGLE_INSTANCE:
            return "IRP_MN_QUERY_SINGLE_INSTANCE\n";

        case IRP_MN_REGINFO:
            return "IRP_MN_REGINFO\n";

        default:
            return "IRP_MN_?????\n";
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\chap9drv.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   chap9drv.c

Abstract:

    USB device driver for Intel/Microsoft diagnostic apps 

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

    5-4-96 : created

--*/

#define DRIVER
#define USBDIAG_VERSION 0x0610
 
#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"


// Enable 1-byte alignment in structs
#pragma pack (push,1)
#include "usb100.h"
#include "usbdi.h"
#include "usbdlib.h"
#include "usbioctl.h"
#pragma pack (pop) //disable 1-byte alignment

#include "opaque.h"

// Enable 1-byte alignment in structs
#pragma pack (push,1)
#include "hidpddi.h"
#include "ioctl.h"
#include "chap9drv.h"
#include "USBDIAG.h"
#include "chap11.h"
#include "_m_usb.h"
#include "typedefs.h"
#pragma pack (pop) //disable 1-byte alignment


#define DEADMAN_TIMEOUT     5000     //timeout in ms; we use a 5 second timeout

#define RAWPACKET_DIRECTION_IN(bmReq) (((bmReq) & bmReqD2H)>>7)

extern USBD_VERSION_INFORMATION gVersionInformation;

/*  ------------------ local prototypes ---------------*/

typedef BYTE    *PBYTE;

VOID 
Ch9FillInReqStatus (
    IN      NTSTATUS                ntStatusCode,
    IN      ULONG                   ulUrbStatus,
    IN OUT  struct _REQ_HEADER *    pReqHeader
    );


PBYTE 
pAllocFromBuffer(
    PBYTE pBuffer,
    ULONG iSize,
    PULONG piOffset,
    PULONG piTotalUsed,
    ULONG iAmountRequested
    );

/*  ------------------ end local prototypes ---------------*/

NTSTATUS
USBDIAG_Chap9Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for the USBDIAG driver's device
                   object, which is not the actual physical device.  That ptr is not
                   used here since our PDO is in the REQ packet sent down from user app,
                   and that is in the IRP.
                    

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION      irpStack;
    PVOID                   ioBuffer = NULL;
    ULONG                   inputBufferLength = 0;
    ULONG                   outputBufferLength= 0;
    NTSTATUS                ntStatus = STATUS_SUCCESS;
   
    PURB                    urb = NULL;
    ULONG                   ulUrbStatus = USBD_STATUS_SUCCESS; 
    ULONG                   siz = 0;
    ULONG                   sizeToCopy;
    BOOLEAN                 bCompleteIrp = TRUE;

    PUSB_DEVICE_DESCRIPTOR          deviceDesc ;
    struct _REQ_HEADER  *           REQHeader;
    PDEVICE_LIST_ENTRY              devListEntry;
    PDEVICE_OBJECT                  actualdeviceObject = NULL;
    PDEVICE_EXTENSION               deviceExtension = NULL;

    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // Get the pointer to the input/output buffer and it's length
    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    
    // The REQHeader, which is the struct that the app fills in describing this REQuest is
    // referenced in the SystemBuffer since it is sent down in the InputBuffer field of the
    // DeviceIoControl call in User Mode.
    REQHeader = (struct _REQ_HEADER *)ioBuffer;
 
    // The DeviceHandle is a ptr to the list entry that USBDIAG manages for devices it is
    // testing.  This used to be a "USBD Device handle" in the old Chap9 method.  Now it's a
    // ptr to the list entry object that USBDIAG maintains for each device under test.  That
    // list entry contains the PDO and other junk about the device object

    devListEntry = (PDEVICE_LIST_ENTRY)(REQHeader->UsbdDeviceHandle);
    //USBDIAG_KdPrint(("USBDIAG.SYS: DevListEntry: %X\n",devListEntry));

    // Device object given is not the real DevObj that was created by PnPAddDevice, so
    // extract that DevObj with a handy macro before calling the lower level drivers (USB stk)
    // NOTE:  This extracted DevObj contains the deviceExtension that in turn contains
    //        the "StackDeviceObject" that is needed by the IoCallDriver function to pass
    //        Urbs down the stack.

    if(devListEntry) 
    {
        actualdeviceObject =  FDO_FROM_DEVICE_HANDLE(devListEntry);
        deviceExtension = actualdeviceObject->DeviceExtension;
        //USBDIAG_KdPrint(("USBDIAG.SYS: PDO for DUT: %X\n",actualdeviceObject));
    }
    
        // Find out which of the Chap9 functions is being sent down from app
    switch (REQHeader->Function)
    {
    case REQ_FUNCTION_RESET_PARENT_PORT:
        {
            ntStatus = USBDIAG_ResetParentPort(actualdeviceObject);
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
        }
        break;

    case REQ_FUNCTION_GET_CHAP9VERSION:
        {
            struct _REQ_GETCHAP9_VERSION * pGetVersion;
            pGetVersion = (struct _REQ_GETCHAP9_VERSION *)(ioBuffer); 
            pGetVersion->Version = USBDIAG_VERSION;
            ntStatus = Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof (struct _REQ_GETCHAP9_VERSION);
        }
        break;  

    case REQ_FUNCTION_GET_DESCRIPTOR:
        {
            /* Create an URB for the USBD call to get device descriptor. */

            struct _REQ_GETSET_DESCRIPTOR   *pGetSetDesc = (struct _REQ_GETSET_DESCRIPTOR *)(ioBuffer) ; 
            //USBDIAG_KdPrint(("***USBDIAG.SYS: In Get Descriptor 0x%x\n", pGetSetDesc->DescriptorType)) ;

            switch (pGetSetDesc->DescriptorType) 
            {
            case USB_DEVICE_DESCRIPTOR_TYPE:
                USBDIAG_KdPrint (("USBDIAG.SYS: DEVICE DESCRIPTOR requested\n"));
                break;
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                USBDIAG_KdPrint (("USBDIAG.SYS: CONFIG DESCRIPTOR requested\n"));
                break;
            case USB_STRING_DESCRIPTOR_TYPE:
                USBDIAG_KdPrint (("USBDIAG.SYS: STRING DESCRIPTOR requested\n"));
                break;
            default:
                USBDIAG_KdPrint (("USBDIAG.SYS: Error--Unknown Descriptor Type Requested!!\n"));
                TRAP();
                break;
            }//switch
            
            siz = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) ;
            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz ) ;

            if (urb) 
            {
                // Get the memory in Ke mode for this txfer, based on client's request
                siz = (pGetSetDesc->TransferBufferLength);
                deviceDesc = USBDIAG_ExAllocatePool(NonPagedPool, siz);

                if (deviceDesc)
                {
                    // NOTE:  We create the URB down in Ke mode.  
                    UsbBuildGetDescriptorRequest(
                        urb, 
                        (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                        (UCHAR)(pGetSetDesc->DescriptorType),
                        (UCHAR)(pGetSetDesc->Index),    // Descriptor Index 
                        pGetSetDesc->LanguageId,        //language ID
                        deviceDesc,                     //transfer buffer
                        NULL,                           // "        "     MDL
                        siz,                            //transfer buffer length
                        NULL);                          //link - not used
                                
                    ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, TRUE);

                    ulUrbStatus = urb->UrbHeader.Status; //capture the urb status for later
                    
                    if (!NT_SUCCESS(ntStatus)) 
                    {
                        USBDIAG_KdPrint (("USBDIAG.SYS: Error in Get device descriptor\n")) ;
                    }

                    if ( pGetSetDesc->DescriptorType == USB_DEVICE_DESCRIPTOR_TYPE )
                    {
                        //USBDIAG_KdPrint(("USBDIAG.SYS: A device descriptor was requested.  Got back \n"));
                        /*USBDIAG_KdPrint(("USBDIAG.SYS: \tDevDesc Length = %x, type %x MaxpacketSize %x\n", 
                                          deviceDesc->bLength, 
                                          deviceDesc->bDescriptorType,
                                          deviceDesc->bMaxPacketSize0));
                                          */
                    }

                    // copy the data directly into the User Mode buffer.  We can do this becauase
                    // we're still in the thread context of the calling User Mode app
                    if (( ioBuffer ) && (pGetSetDesc->TransferBuffer))
                    {
                        /*
                        USBDIAG_KdPrint(("USBDIAG.SYS: Device sent back %d bytes of descriptor data\n",
                        urb->UrbControlDescriptorRequest.TransferBufferLength));
                        //USBDIAG_KdPrint(("USBDIAG.SYS: Copying %d bytes to UserMode's buffer (at %X)\n",
                                          (pGetSetDesc->TransferBufferLength < urb->UrbControlDescriptorRequest.TransferBufferLength ) ? pGetSetDesc->TransferBufferLength : urb->UrbControlDescriptorRequest.TransferBufferLength,
                                          pGetSetDesc->TransferBuffer));

                        */
                        
                        sizeToCopy = pGetSetDesc->TransferBufferLength < urb->UrbControlDescriptorRequest.TransferBufferLength  
                                        ? pGetSetDesc->TransferBufferLength 
                                        : urb->UrbControlDescriptorRequest.TransferBufferLength;

                        __try 
                        {
                            ProbeForWrite(pGetSetDesc->TransferBuffer,
                                          sizeToCopy,
                                          TYPE_ALIGNMENT(HIDP_DEVICE_DESC));

                            RtlCopyMemory( pGetSetDesc->TransferBuffer, 
                                            deviceDesc, 
                                            sizeToCopy);

                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            ntStatus   = STATUS_INVALID_PARAMETER;
                            sizeToCopy = 0;

//                          USBDIAG_KdPrint(("USBDIAG.SYS: BAD POINTER RECEIVED! Bailing...\n"));
                        }
                    }
                    USBDIAG_ExFreePool(deviceDesc);                                                                                 
        
                    // The Information field tells IOM how much to copy back into the
                    // usermode buffer in the BUFFERED method
                    // In this case all we want the IOM to copy back is the REQ itself
                    // so things like the status field get updated
                    //

                    Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
                    Irp->IoStatus.Status      = ntStatus;

                    //
                    // Fill in the length in the REQ block with the number
                    //   of bytes copied back into the TransferBuffer.
                    //

                    pGetSetDesc->TransferBufferLength = sizeToCopy;
                }
                else
                {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                USBDIAG_ExFreePool(urb);                                                        
            }               // if urb                                       

        }       // REQ_FUNCTION_GET_DESCRIPTOR 

        break ;
        
    case REQ_FUNCTION_SET_DESCRIPTOR:
        {
            struct _REQ_GETSET_DESCRIPTOR   *pGetSetDesc = (struct _REQ_GETSET_DESCRIPTOR *)(ioBuffer) ; 

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Set Descriptor buf = 0x%x\n", *pGetSetDesc)) ;
                
            siz = sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST) ;

            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz ) ;

            if (urb) 
            {
                // Get nonpaged mem for this transfer and use len given by app
                siz = pGetSetDesc->TransferBufferLength ;
                deviceDesc = USBDIAG_ExAllocatePool(NonPagedPool, siz);

                if (deviceDesc)
                {
                    memcpy( deviceDesc, pGetSetDesc->TransferBuffer, siz);

                    //
                    // Unfortunately, there is no macro to build a 
                    // SetDescriptorRequest in the USBDI.H. Therefore,
                    // we will use our own.  
                    //
                    // NOTE: Should it every appear, the below statement
                    //       can be changed.
                    //

                    _m_UsbBuildSetDescriptorRequest(urb, 
                                                (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST), //len
                                                (UCHAR)(pGetSetDesc->DescriptorType),   //desc type
                                                (UCHAR)(pGetSetDesc->Index),            //index
                                                pGetSetDesc->LanguageId,                //language ID
                                                deviceDesc,                             //buffer
                                                NULL,                                   //MDL
                                                siz,                                    //buff len
                                                NULL);                                  //link
                                
                    ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, TRUE);

                    ulUrbStatus = urb->UrbHeader.Status; //capture the urb status for later

                    if ( ! NT_SUCCESS(ntStatus) ) 
                    {
                        //USBDIAG_KdPrint(("USBDIAG.SYS: Error in Set device descriptor\n")) ;
                    }

                    /*USBDIAG_KdPrint(("USBDIAG.SYS: Set Descriptor at %x, type %x len %x bytes\n", 
                                      deviceDesc, 
                                      pGetSetDesc->DescriptorType,
                                      urb->UrbControlDescriptorRequest.TransferBufferLength));

                    */
                    USBDIAG_ExFreePool(deviceDesc);                                                                                 
                } 
                else
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                // The Information field tells IOM how much to copy back into the
                // usermode buffer in the BUFFERED method
                // In this case all we want the IOM to copy back is the REQ itself
                // so things like the status field get updated
                Irp->IoStatus.Information = sizeof(*pGetSetDesc);
                Irp->IoStatus.Status = ntStatus;

                USBDIAG_ExFreePool(urb);                                                        
            } // if urb                                       

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Set Descriptor\n")) ;                                          

        } // End of REQ_FUNCTION_SET_DESCRIPTOR

        break ;

    case REQ_FUNCTION_SET_FEATURE:
    case REQ_FUNCTION_CLEAR_FEATURE:
        {                                                                                                                               
            struct _REQ_FEATURE *pSetClrFeature;

            pSetClrFeature = (struct _REQ_FEATURE *) ioBuffer; 

            // We check again here since the set_feat case drops thru here

            if (REQHeader->Function == REQ_FUNCTION_CLEAR_FEATURE)
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: In Clear Feature\n")) ;
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: In Set Feature\n")) ;
            }
                
            if ( pSetClrFeature == NULL ) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: NULL parameter passsed\n")) ;

                Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
                Irp->IoStatus.Status = ntStatus = STATUS_INVALID_PARAMETER;

                break ;
            }

            siz = sizeof(struct _URB_CONTROL_FEATURE_REQUEST) ;

            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz ) ;

            if (urb) 
            {
                /*
                // Set the function code for USBD to use.  NOte that the function code
                // differs depending on the recipient and so we do this for each of the
                // Set and Clear feature requests.
                */

                ntStatus = STATUS_SUCCESS;

                if ( REQHeader->Function == REQ_FUNCTION_CLEAR_FEATURE )
                {
                    //Oh, look it's a CLEAR_FEATURE
                    switch (pSetClrFeature->Recipient) 
                    {
                        case (RECIPIENT_DEVICE):
                            urb->UrbHeader.Function =  URB_FUNCTION_CLEAR_FEATURE_TO_DEVICE; 
                            break;

                        case (RECIPIENT_ENDPOINT):
                            urb->UrbHeader.Function =  URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT;
                            break;
                        
                        case (RECIPIENT_INTERFACE):
                            urb->UrbHeader.Function =  URB_FUNCTION_CLEAR_FEATURE_TO_INTERFACE;
                            break;

                        default:
                            ntStatus = STATUS_INVALID_PARAMETER;
                            break;
                    }//switch
                    
                }/*if it's a CLEAR_FEATURE */
                else
                {
                    // OK, it's a SET_FEATURE
                    switch (pSetClrFeature->Recipient) 
                    {
                        case (RECIPIENT_DEVICE):
                            urb->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_DEVICE; 
                            break;

                        case (RECIPIENT_ENDPOINT):
                            urb->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_ENDPOINT;
                            break;
                        
                        case (RECIPIENT_INTERFACE):
                            urb->UrbHeader.Function =  URB_FUNCTION_SET_FEATURE_TO_INTERFACE;
                            break;

                        default:
                            ntStatus = STATUS_INVALID_PARAMETER;
                            break;
                    }//switch
                    
                }/* else it's a SET_FEATURE */

                if (NT_SUCCESS(ntStatus))
                {
                    urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_CONTROL_FEATURE_REQUEST); 
                    urb->UrbControlFeatureRequest.UrbLink = NULL;
                    urb->UrbControlFeatureRequest.FeatureSelector = pSetClrFeature->FeatureSelector; 
                    urb->UrbControlFeatureRequest.Index = pSetClrFeature->Index;
                    
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Device Object = %x\n", REQHeader->UsbdDeviceHandle )) ;

                    ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, 
                                                   urb, 
                                                   TRUE, 
                                                   NULL, 
                                                   NULL, 
                                                   TRUE);

                    //
                    // Capture the urb status
                    //

                    ulUrbStatus = urb->UrbHeader.Status; 
                }

                if (!NT_SUCCESS(ntStatus)) 
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Error in Set/Clear feature\n")) ;
                }
                else
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Set/Clear feature\n")) ;
                }

                // The Information field tells IOM how much to copy back into the
                // usermode buffer in the BUFFERED method
                // In this case all we want the IOM to copy back is the REQ itself
                // so things like the status field get updated

                Irp->IoStatus.Information = sizeof(struct _REQ_FEATURE);
                Irp->IoStatus.Status = ntStatus;

                USBDIAG_ExFreePool(urb);                                                        
            } // if urb                                       

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Set/Clear feature\n")) ;

        }       // End of REQ_FUNCTION_CLEAR_FEATURE

        break ;

    case REQ_FUNCTION_GET_STATUS:
        {
            struct _REQ_GET_STATUS * pGetStatus = (struct _REQ_GET_STATUS *)(ioBuffer) ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: In GetStatus\n")) ;
                
            if (pGetStatus == NULL) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: NULL parameter passsed\n")) ;
                TRAP();
                break ;
            }

            siz = sizeof(struct _URB_CONTROL_GET_STATUS_REQUEST) ;

            //Create an URB for the USBD call to get status
            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz ) ;

            if (urb) 
            {
                USHORT function;
                USHORT * pStatus;
                                                                                
                switch (pGetStatus->Recipient)
                {
                case RECIPIENT_DEVICE :  
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Getting Status from DEVICE\n"))
                    function = URB_FUNCTION_GET_STATUS_FROM_DEVICE; 
                    break;
                case RECIPIENT_INTERFACE:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Getting Status from INTERFACE\n"))
                    function = URB_FUNCTION_GET_STATUS_FROM_INTERFACE; 
                    break;
                case RECIPIENT_ENDPOINT: 
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Getting Status from ENDPOINT\n"))                        
                    function = URB_FUNCTION_GET_STATUS_FROM_ENDPOINT; 
                    break;
                default: 
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Getting Status from OTHER (??)\n"))                        
                    function = URB_FUNCTION_GET_STATUS_FROM_OTHER; // ?
                } //switch

                // Fill in the URB
                urb->UrbHeader.Function =  function; 
                urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_CONTROL_GET_STATUS_REQUEST); 
                urb->UrbControlGetStatusRequest.UrbLink = NULL;

                //
                // Get a buffer for the status data to be put in 
                // Don't know why we have to get so much more data than we need?
                // Don't use siz again but I'm not about to investigate the
                //  effects of a change.
                //

                siz = GET_STATUS_DATA_LEN + 128;
                pStatus = USBDIAG_ExAllocatePool(NonPagedPool, siz); 

                if (pStatus == NULL) 
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Failed getting mem in GetStatus!\n"));                  
                    TRAP();
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                    goto GetStatus_FreeMem;
                }//if

                urb->UrbControlGetStatusRequest.TransferBufferLength = GET_STATUS_DATA_LEN;
                urb->UrbControlGetStatusRequest.TransferBuffer = pStatus;
                urb->UrbControlGetStatusRequest.TransferBufferMDL = NULL;
                urb->UrbControlGetStatusRequest.Index = pGetStatus->Index;
                        
                ntStatus = USBDIAG_Ch9CallUSBD (actualdeviceObject, urb, TRUE, NULL, NULL, TRUE);

                ulUrbStatus = urb->UrbHeader.Status; //capture the urb status for later

                if (NT_SUCCESS(ntStatus)) 
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Get Status\n")) ;
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Status value = %02x\n", *pStatus )) ;
                                        pGetStatus->Status = *pStatus ; 
                }
                else
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Get Status\n")) ;
                }

                USBDIAG_ExFreePool(pStatus) ;

GetStatus_FreeMem:

                // The Information field tells IOM how much to copy back into the
                // usermode buffer in the BUFFERED method
                // In this case all we want the IOM to copy back is the REQ itself
                // so things like the status field get updated
                Irp->IoStatus.Information = sizeof(struct _REQ_GET_STATUS);
                Irp->IoStatus.Status = ntStatus;

                USBDIAG_ExFreePool(urb);                                                        
            }// if urb                                      

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Get Status\n")) ;                                              

        }       // End of REQ_FUNCTION_GET_STATUS
        break ;

    case REQ_FUNCTION_SET_ADDRESS:
        {
            char SetUpPacket[8] ;
            struct _REQ_SET_ADDRESS * pSetAddr = (struct _REQ_SET_ADDRESS *)(ioBuffer) ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Set Address\n")) ;
                        
            // Set up the setup packet for SET_ADDRESS 
            SetUpPacket[0] = 0x0 ; 
            SetUpPacket[1] = USB_REQUEST_SET_ADDRESS ; 
            SetUpPacket[2] = LOBYTE(pSetAddr->DevAddr) ; 
            SetUpPacket[3] = HIBYTE(pSetAddr->DevAddr) ; 
            SetUpPacket[4] = 0x0 ; 
            SetUpPacket[5] = 0x0 ; 
            SetUpPacket[6] = 0x0 ; 
            SetUpPacket[7] = 0x0 ;
                        
            //USBDIAG_KdPrint(("USBDIAG.SYS: Set Address to %02x %02x\n", SetUpPacket[2], SetUpPacket[3] )) ;

            siz = 0;

            ntStatus = USBDIAG_SendPacket(actualdeviceObject,SetUpPacket, NULL, &siz, &ulUrbStatus) ;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Set Address\n")) ;
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Set Address\n")) ;
            }

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Set Address\n")) ;

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_SET_ADDRESS);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            pSetAddr->Hdr.Status = ntStatus;

        }       /* end case REQ_FUNCTION_SET_ADDRESS */

        break ;

    case REQ_FUNCTION_GET_CONFIGURATION:
        {
            struct _REQ_GETSET_CONFIGURATION * pGetConf = (struct _REQ_GETSET_CONFIGURATION *)(ioBuffer) ;
            UCHAR   SetUpPacket[8] ;
            char    *ConfigValue = NULL ; 

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Get Configuration\n")) ;

            siz = 1;
            ConfigValue = USBDIAG_ExAllocatePool(NonPagedPool, siz + 16) ; 

            // Set up the setup packet for GET_CONFIG
            SetUpPacket[0] = (bmReqD2H | bmReqSTANDARD | bmReqDEVICE) ; 
            SetUpPacket[1] = USB_REQUEST_GET_CONFIGURATION ; 
            SetUpPacket[2] = 0x0; 
            SetUpPacket[3] = 0x0; 
            SetUpPacket[4] = 0x0 ; 
            SetUpPacket[5] = 0x0 ; 
            SetUpPacket[6] = 0x01 ;  //Configuration value is 1 byte
            SetUpPacket[7] = 0x0;
                        
            ntStatus = USBDIAG_SendPacket( actualdeviceObject, (PCHAR)SetUpPacket, ConfigValue, &siz, &ulUrbStatus) ;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Get Configuration (%d bytes txferred)\n", siz)) ;
                //USBDIAG_KdPrint(("USBDIAG.SYS: Configuration value = %02x\n", *ConfigValue  )) ;
                                  pGetConf->ConfigValue = (USHORT)*ConfigValue ; 
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Get Configuration\n")) ;
            }

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_GETSET_CONFIGURATION);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            pGetConf->Hdr.Status = ntStatus;

            USBDIAG_ExFreePool(ConfigValue) ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Get Configuration\n")) ;                                               

        }       // End of case REQ_FUNCTION_GET_CONFIGURATION
        break ;
                        
    case REQ_FUNCTION_SET_CONFIGURATION:
        {
            struct _REQ_GETSET_CONFIGURATION * pGetConf = (struct _REQ_GETSET_CONFIGURATION *)(ioBuffer) ;
            char    SetUpPacket[8] ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Set Configuration\n")) ;
            siz=0;
                        
            // Set up the setup packet for SET_CONFIG 
            SetUpPacket[0] = (bmReqH2D | bmReqSTANDARD | bmReqDEVICE) ; 
            SetUpPacket[1] = USB_REQUEST_SET_CONFIGURATION ; 
            SetUpPacket[2] = LOBYTE(pGetConf->ConfigValue) ; 
            SetUpPacket[3] = HIBYTE(pGetConf->ConfigValue) ; 
            SetUpPacket[4] = 0x00 ; 
            SetUpPacket[5] = 0x00 ; 
            SetUpPacket[6] = 0x00 ; 
            SetUpPacket[7] = 0x00 ;
            
            ntStatus = USBDIAG_SendPacket(actualdeviceObject,SetUpPacket, NULL, &siz, &ulUrbStatus) ;
            
            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Set Configuration to %02x\n", pGetConf->ConfigValue)) ;                                                       
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Set Configuration\n")) ;
            }

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_GETSET_CONFIGURATION);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            pGetConf->Hdr.Status = ntStatus;

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Set Configuration\n")) ;                                               

        }       // End of REQ_FUNCTION_SET_CONFIGURATION

        break ;

    case REQ_FUNCTION_GET_INTERFACE:
        {
            struct _REQ_GETSET_INTERFACE * pGetInt = (struct _REQ_GETSET_INTERFACE *)(ioBuffer) ;
            UCHAR SetUpPacket[8] ;
            ULONG cbBytesToGet;                     
            char    *IntValue = NULL ; 

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Get Interfaces\n")) ;

            cbBytesToGet = siz = 1 ;
            IntValue = USBDIAG_ExAllocatePool(NonPagedPool, siz) ; 

            // Set up the setup packet for GET_INTERFACE
            SetUpPacket[0] = (bmReqD2H | bmReqSTANDARD | bmReqINTERFACE) ; 
            SetUpPacket[1] = USB_REQUEST_GET_INTERFACE ; 
            SetUpPacket[2] = 0 ; 
            SetUpPacket[3] = 0 ; 
            SetUpPacket[4] = LOBYTE(pGetInt->Index) ; 
            SetUpPacket[5] = HIBYTE(pGetInt->Index) ; 
            SetUpPacket[6] = LOBYTE(cbBytesToGet) ; 
            SetUpPacket[7] = HIBYTE(cbBytesToGet) ;
            
            ntStatus = USBDIAG_SendPacket(actualdeviceObject, (PCHAR)SetUpPacket, IntValue, &siz, &ulUrbStatus) ;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Get Interface (%d bytes txferred)\n", siz)) ;
                //USBDIAG_KdPrint(("USBDIAG.SYS: Interface  value = %02x\n", *IntValue  )) ;
                pGetInt->AltSetting = (USHORT)*IntValue ; 
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Get Interface\n")) ;
            }

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_GETSET_INTERFACE);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            pGetInt->Hdr.Status = ntStatus;

            USBDIAG_ExFreePool(IntValue) ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Get Interfaces\n")) ;                                          

        }       // End of REQ_FUNCTION_GET_INTERFACE
        break ;

    case REQ_FUNCTION_SET_INTERFACE:
        {
            struct _REQ_GETSET_INTERFACE * pGetInt = (struct _REQ_GETSET_INTERFACE *)(ioBuffer) ;
            char SetUpPacket[8] ;

            //USBDIAG_KdPrint(("USBDIAG.SYS: In Set Interfaces\n")) ;
            
            siz = 0;  

            // Set up the setup packet for SET_INTERF
            SetUpPacket[0] = (bmReqH2D | bmReqSTANDARD | bmReqINTERFACE) ; 
            SetUpPacket[1] = USB_REQUEST_SET_INTERFACE ; 
            SetUpPacket[2] = LOBYTE(pGetInt->AltSetting) ; 
            SetUpPacket[3] = HIBYTE(pGetInt->AltSetting) ; 
            SetUpPacket[4] = LOBYTE(pGetInt->Index) ; 
            SetUpPacket[5] = HIBYTE(pGetInt->Index) ; 
            SetUpPacket[6] = 0x00 ; 
            SetUpPacket[7] = 0x00 ;
            
            //USBDIAG_KdPrint(("USBDIAG.SYS: SetupPacket: %X\n",SetUpPacket)) ;

            ntStatus = USBDIAG_SendPacket(actualdeviceObject, SetUpPacket, NULL, &siz, &ulUrbStatus) ;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully did Set Interface\n")) ;
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Set Interface\n")) ;
            }

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_GETSET_INTERFACE);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            pGetInt->Hdr.Status = ntStatus;

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Set Interfaces\n")) ;                                          
            
        }               // End of REQ_FUNCTION_SET_INTERFACE
        break ;

    case REQ_FUNCTION_ORAW_PACKET:
        {
            struct _REQ_HEADER  *REQHeader = (struct _REQ_HEADER *)ioBuffer;
            struct _REQ_SEND_ORAWPACKET * pRawPkt = (struct _REQ_SEND_ORAWPACKET *)(Irp->UserBuffer) ;
            char    SetUpPacket[8] ;
            char    *buffer = NULL ;  
            UCHAR   bmRT=0;

            //USBDIAG_KdPrint(("USBDIAG.SYS: Entering Send Raw Packet\n")) ;
            //USBDIAG_KdPrint(("USBDIAG.SYS: SystemBuffer: %X\t|UserBuffer: %X\n", ioBuffer, Irp->UserBuffer)) ;        

            if ( pRawPkt == NULL )
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES ;
                //USBDIAG_KdPrint(("USBDIAG.SYS: Called with NULL Raw Packet\n")) ;
                break ;
            }

            bmRT = pRawPkt->bmRequestType; //save the bmReqType in case it gets stomped on (gets used later)
            
            siz = pRawPkt->wLength ; 
            //USBDIAG_KdPrint(("USBDIAG.SYS: Raw Packet siz = %d\n",siz));

            if ( siz )
            {
                buffer = USBDIAG_ExAllocatePool(NonPagedPool, siz) ; 

                if ( buffer == NULL ) 
                {       
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES ;
                                        break ;
                }//if couldn't get buffer
            }

            //USBDIAG_KdPrint(("USBDIAG.SYS: Raw Packet bmRequestType = %x bRequest = %x\n",pRawPkt->bmRequestType, pRawPkt->bRequest )) ;
            //USBDIAG_KdPrint(("USBDIAG.SYS:  wValue = %x wIndex = %x Length = %x\n", pRawPkt->wValue, pRawPkt->wIndex, pRawPkt->wLength  )) ;
            //USBDIAG_KdPrint(("USBDIAG.SYS: SetupPacket base: %x\n",SetUpPacket));

            SetUpPacket[0] = pRawPkt->bmRequestType ; 
            SetUpPacket[1] = pRawPkt->bRequest ; 
            SetUpPacket[2] = LOBYTE(pRawPkt->wValue) ; 
            SetUpPacket[3] = HIBYTE(pRawPkt->wValue) ; 
            SetUpPacket[4] = LOBYTE(pRawPkt->wIndex) ; 
            SetUpPacket[5] = HIBYTE(pRawPkt->wIndex) ; 
            SetUpPacket[6] = LOBYTE(pRawPkt->wLength) ; 
            SetUpPacket[7] = HIBYTE(pRawPkt->wLength) ;
    
            ntStatus = USBDIAG_SendPacket(actualdeviceObject, SetUpPacket, buffer, &siz, &ulUrbStatus) ;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successful Procssed RAWPKT; copying %d bytes to %X\n",
                                  // siz, pRawPkt->pvBuffer)) ;
            
                // Only copy the data back to user's buffer if user's wLength indicates
                // it and there are valid buffers from which to copy and the direction was 
                // Device to Host
                if ( (siz>0)                     && //some bytes to copy
                     (buffer != NULL)            && //source buffer valid
                     (pRawPkt->pvBuffer != NULL) && //dest buffer valid
                     (RAWPACKET_DIRECTION_IN(bmRT))) //dir was Dev2Host
                {
                    // copy data to user mode buffer
                    memcpy(pRawPkt->pvBuffer, buffer,siz) ; 
                        
                    //Fill in the length in the REQ block so user-mode knows how much data is in buffer
                    pRawPkt->wLength    =   LOWORD(siz);
                }//if ok to copy to user's buffer
                                
            }
            else
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed Processing RAW PKT : Status = %x\n", ntStatus)) ;
            }

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
            Irp->IoStatus.Status = ntStatus;

            // return the status
            REQHeader->Status = ntStatus;

            if (buffer != NULL) 
            {
                USBDIAG_ExFreePool(buffer) ;
            }// if buffer should be freed

            //USBDIAG_KdPrint(("USBDIAG.SYS: Exiting Send Raw Packet\n")) ;                                         

        }       // End switch REQ_FUNCTION_ORAW_PACKET
        
        break;

    case REQ_FUNCTION_READ_FROM_PIPE:
        {
            struct _REQ_READ_WRITE_PIPE *   pREQ_RWPipe;
            USBD_INTERFACE_INFORMATION *    pInterfaceInfo;
            USBD_PIPE_INFORMATION *         pPipeInfo;          
            ULONG                           ulPipeNum;
            PVOID                           pvBuffer;
            
            //USBDIAG_KdPrint(("USBDIAG.SYS: enter READ\n"));
                
            pREQ_RWPipe     = (struct _REQ_READ_WRITE_PIPE *) (ioBuffer);
            ulPipeNum       = pREQ_RWPipe->Contxt.PipeNum;

            ASSERT (deviceExtension != NULL);
            
            pInterfaceInfo  = deviceExtension->Interface[0];

            ASSERT (pInterfaceInfo != NULL);
            ASSERT (pREQ_RWPipe != NULL);
            ASSERT (ulPipeNum <= (pInterfaceInfo->NumberOfPipes));
            
            pPipeInfo       = &(deviceExtension->Interface[0]->Pipes[ulPipeNum]);

            ASSERT (pPipeInfo != NULL);
            ASSERT ((pPipeInfo->PipeHandle) != NULL);
            
            siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

            // allocate urb
            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz);

            // allocate data buffer
            pvBuffer = USBDIAG_ExAllocatePool (NonPagedPool, pREQ_RWPipe->ulLength);

            // set up urb
            UsbBuildInterruptOrBulkTransferRequest(urb,         //ptr to urb
                                                   (USHORT) siz,            //siz of urb
                                                   pPipeInfo->PipeHandle,       //usbd pipe handle
                                                   pvBuffer,                //transferbuffer
                                                   NULL,                    //mdl
                                                   pREQ_RWPipe->ulLength,   //bufferlength
                                                   USBD_SHORT_TRANSFER_OK,  //flags
                                                   NULL);                   //link

            // NOTE: We don't request a TIMEOUT in this call to Ch9CallUSBD
            ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, FALSE);

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_READ_WRITE_PIPE);
            Irp->IoStatus.Status = ntStatus;

            pREQ_RWPipe->Hdr.Status = ntStatus;

            if (!NT_SUCCESS(ntStatus))
            {
                USBDIAG_KdPrint(("'Read pipe failed!\n ntStatus = 0x%x\n urbStatus = 0x%x\n", 
                                 ntStatus,
                                 urb->UrbHeader.Status));
            }

            // The REQ coming from user mode gets its length field trampled on w/ the actual
            // length of this transfer, so user mode app should look there and not in 
            // the nBytes field of the DeviceIoControl call.
            pREQ_RWPipe->ulLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

            ulUrbStatus = urb->UrbHeader.Status; //capture the Urb status for later
            
            // Copy the data back to user mode buffer if successful transfer
            if (ulUrbStatus == USBD_STATUS_SUCCESS) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successful Read; Copying %d bytes to UserMode Buf (%X)",
                                   //pREQ_RWPipe->ulLength,
                                   //pREQ_RWPipe->pvBuffer));

                if (pREQ_RWPipe->pvBuffer) 
                {
                    memcpy ( (pREQ_RWPipe->pvBuffer) , pvBuffer, (pREQ_RWPipe->ulLength) );
                } // if pvBuffer is non NULL
                    
            }//if status is SUCCESS

            // free allocated urb
            USBDIAG_ExFreePool(urb);

            // free our non paged pool data buffer
            USBDIAG_ExFreePool (pvBuffer);
           
            //USBDIAG_KdPrint(("USBDIAG.SYS: exit READ\n"));

            break;
        }//REQ_FUNCTION_READ_FROM_PIPE
        break; //REQ_FUNCTION_READ_FROM_PIPE

    case REQ_FUNCTION_WRITE_TO_PIPE:
        {
            struct _REQ_READ_WRITE_PIPE *   pREQ_RWPipe;
            USBD_INTERFACE_INFORMATION *    pInterfaceInfo;
            USBD_PIPE_INFORMATION *         pPipeInfo;          
            ULONG                           ulPipeNum;
            PVOID                           pvBuffer;
            
            //USBDIAG_KdPrint(("USBDIAG.SYS: enter WRITE \n"));
                
            pREQ_RWPipe     = (struct _REQ_READ_WRITE_PIPE *) (ioBuffer);
            ulPipeNum       = pREQ_RWPipe->Contxt.PipeNum;

            ASSERT (deviceExtension != NULL);
            
            pInterfaceInfo  = deviceExtension->Interface[0];

            ASSERT (pInterfaceInfo != NULL);
            ASSERT (pREQ_RWPipe != NULL);
            ASSERT (ulPipeNum <= (pInterfaceInfo->NumberOfPipes));
            
            pPipeInfo = &(deviceExtension->Interface[0]->Pipes[ulPipeNum]);

            ASSERT (pPipeInfo != NULL);
            ASSERT ((pPipeInfo->PipeHandle) != NULL);
            
            siz = sizeof(struct _URB_BULK_OR_INTERRUPT_TRANSFER);

            // allocate urb
            urb = USBDIAG_ExAllocatePool(NonPagedPool, siz);

            // allocate data buffer
            pvBuffer = USBDIAG_ExAllocatePool (NonPagedPool, pREQ_RWPipe->ulLength);

            // COPY the data to write out into the nonpaged pool buffer
            RtlCopyMemory(pvBuffer, pREQ_RWPipe->pvBuffer, pREQ_RWPipe->ulLength);
                        
            // set up urb
            UsbBuildInterruptOrBulkTransferRequest(urb,         //ptr to urb
                                                   (USHORT) siz,            //siz of urb
                                                   pPipeInfo->PipeHandle,       //usbd pipe handle
                                                   pvBuffer,                //transferbuffer
                                                   NULL,                    //mdl
                                                   pREQ_RWPipe->ulLength,   //bufferlength
                                                   USBD_SHORT_TRANSFER_OK,  //flags
                                                   NULL);                   //link

            // NOTE: We don't request a TIMEOUT in this call to Ch9CallUSBD
            ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, FALSE);

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
            Irp->IoStatus.Status = ntStatus;

            // The REQ coming from user mode gets its length field trampled on w/ the actual
            // length of this transfer, so user mode app should look there and not in 
            // the nBytes field of the DeviceIoControl call.
            pREQ_RWPipe->ulLength = urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

            ulUrbStatus = urb->UrbHeader.Status; //capture the Urb status for later
            
            // Copy the data back to user mode buffer if successful transfer
            if (ulUrbStatus == USBD_STATUS_SUCCESS) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Successful Write; %d bytes Transferred",
                //pREQ_RWPipe->ulLength));

            }//if status is SUCCESS

            // free allocated urb
            USBDIAG_ExFreePool(urb);

            // free our non paged pool data buffer
            USBDIAG_ExFreePool (pvBuffer);
            
            //USBDIAG_KdPrint(("USBDIAG.SYS: exit WRITE \n"));

            // The Information field tells IOM how much to copy back into the
            // usermode buffer in the BUFFERED method
            // In this case all we want the IOM to copy back is the REQ itself
            // so things like the status field get updated
            Irp->IoStatus.Information = sizeof(struct _REQ_READ_WRITE_PIPE);
            Irp->IoStatus.Status = ntStatus;
        }
        break; //REQ_FUNCTION_WRITE_TO_PIPE


    case REQ_FUNCTION_CANCEL_TRANSFERS:
        {
            // Input:  a device on which any outstanding Irps should be cancelled
            //         We get the Irp ptr from the device extension.  For now, we
            //         only support one outstanding Irp on an entire device, even
            //         if that Irp is on one of the device's pipes.  This is a limitation
            //         that can be lifted if we keep a track of more Irps on the device.
            NTSTATUS ntStatus   = USBDIAG_CancelAllIrps(deviceExtension);
            BOOLEAN  status     = (BOOLEAN)NT_SUCCESS(ntStatus);
            
            ASSERT (deviceExtension != NULL);

            if (deviceExtension != NULL)
            {
                Ch9FillInReqStatus (status, status, REQHeader);
                Irp->IoStatus.Information = sizeof(struct _REQ_HEADER);
                Irp->IoStatus.Status = ntStatus;
                        
            }// if valid physdevice extension
                
        }//REQ_FUNCTION_CANCEL_TRANSFERS        
        break;

                
    case REQ_FUNCTION_SET_DEVICE_POWER_STATE:
        {
            /*******
            Suspends/resumes device under test

            Input: Device Handle
                        
            Output: Nothing yet

            ********/

            PDEVICE_OBJECT      stackDeviceObject;
            POWER_STATE         powerState;

            struct _REQ_GET_SET_DEVICE_POWER_STATE * pSetDevicePowerState = (struct _REQ_GET_SET_DEVICE_POWER_STATE *)ioBuffer;

            stackDeviceObject = deviceExtension->StackDeviceObject;

                // Set device to suspend
            powerState.DeviceState = pSetDevicePowerState->DevicePowerState;

            // cancel the pending irp if applicable

            if (powerState.DeviceState != PowerDeviceD0)
            {
                //USBDIAG_KdPrint(("Powering down - InterruptIrp = 0x%x\n", deviceExtension->InterruptIrp));

                if (deviceExtension->InterruptIrp)
                {
                    if (IoCancelIrp(deviceExtension->InterruptIrp))
                    {
                        USBDIAG_KdPrint(("'Powering down, so all pending interrupt irp cancelled\n"));
                    }
                    else
                    {
                        USBDIAG_KdPrint(("'Powering down, pending interrupt irp cancelled FAILED\n"));
                    }
                    deviceExtension->InterruptIrp = NULL;
                }
            }
                    ntStatus = USBDIAG_SetDevicePowerState(actualdeviceObject,
                                                                                               powerState.DeviceState);

            if (NT_SUCCESS(ntStatus))
            {
                //USBDIAG_KdPrint(("'USBDIAG.SYS: Set device power state 0x%x passed\n", powerState.DeviceState));
            }
            else
            {
                USBDIAG_KdPrint(("'USBDIAG.SYS: Set device power state 0x%x FAILED (0x%x)\n", powerState.DeviceState, ntStatus));
            }
      
        } //REQ_FUNCTION_CHAP11_SUSPEND_HUT
    
        break;

    case REQ_FUNCTION_GET_DEVICE_STATE:
        {
            struct _REQ_GET_SET_DEVICE_POWER_STATE * pREQ_GetDevPowerState =  (struct _REQ_GET_SET_DEVICE_POWER_STATE *)(ioBuffer);
            
            USBDIAG_KdPrint(("'USBDIAG.SYS: REQ_GET_DEV_POWER_STATE\n"));

            pREQ_GetDevPowerState->DevicePowerState = (ULONG)deviceExtension->CurrentDeviceState.DeviceState;

            ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(struct _REQ_GET_SET_DEVICE_POWER_STATE);
            Irp->IoStatus.Status = ntStatus;
        }
        break;
    
    case REQ_FUNCTION_ISSUE_WAIT_WAKE:
        USBDIAG_KdPrint(("'USBDIAG.SYS: REQ_FUNCTION_ISSUE_WAIT_WAKE\n"));

        if (deviceExtension->WaitWakeIrp)
        {
            return STATUS_DEVICE_BUSY;
        }
        else
        {
            USBDIAG_KdPrint(("'Generating IRP_MN_WAIT_WAKE Power Irp\n"));

            // Generate and save the power irp
            ntStatus = USBDIAG_IssueWaitWake(actualdeviceObject);

            if (ntStatus == STATUS_PENDING)
            {
                Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
                Irp->IoStatus.Information = 0;
            }

        }

        break;  

    case REQ_FUNCTION_WAIT_FOR_WAKEUP:
        {
            NTSTATUS ntStatus = USBDIAG_WaitForWakeup(deviceExtension);

            Irp->IoStatus.Status      = ntStatus;
            Irp->IoStatus.Information = 0;
        }
        break;

    case REQ_FUNCTION_CANCEL_WAIT_WAKE:
        {
            ntStatus = STATUS_UNSUCCESSFUL;

            if (deviceExtension->WaitWakeIrp)
            {
                BOOLEAN bCancelSuccess = IoCancelIrp(deviceExtension->WaitWakeIrp);
                if (bCancelSuccess)
                {
                    ntStatus = STATUS_SUCCESS;
                }
            }
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
        }
        break;

    case REQ_FUNCTION_CHAP11_CREATE_USBD_DEVICE:

        /*******
          Creates handle to device attatched to hub
                
          Input:  
                
          Output: Device handle, and device descriptor
        
        ********/
        {
            ntStatus = USBDIAG_CreateInitDownstreamDevice((PREQ_ENUMERATE_DOWNSTREAM_DEVICE)ioBuffer,
                                                          deviceExtension);

            ASSERT(NT_SUCCESS(ntStatus));
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = sizeof(struct _REQ_ENUMERATE_DOWNSTREAM_DEVICE);;
        }

        break;  


    case REQ_FUNCTION_CHAP11_INIT_USBD_DEVICE:

        /*******
          Initialize device attached to hub.
                
          Input: Device Handle

          Output: Nothing yet
        
        ********/
        if (gVersionInformation.USBDI_Version >= USBD_WIN98_SE_VERSION) // Win98 SE / Win2K & beyond
        {
            ntStatus = USBDIAG_SetCfgEnableRWu(deviceExtension, (PREQ_ENUMERATE_DOWNSTREAM_DEVICE)ioBuffer);
            
                        Irp->IoStatus.Status = ntStatus;
                        Irp->IoStatus.Information = sizeof(struct _REQ_ENUMERATE_DOWNSTREAM_DEVICE);
        }
        else
            ntStatus = STATUS_NOT_IMPLEMENTED;

        break;

    case REQ_FUNCTION_CHAP11_DESTROY_USBD_DEVICE:

        /*******
          Destroys device handle to device attached to hub.
                
          Input: Device Handle

          Output: Nothing yet
        
        ********/
        if (gVersionInformation.USBDI_Version >= USBD_WIN98_SE_VERSION) // Win98 SE / Win2K & beyond
        {
            PREQ_ENUMERATE_DOWNSTREAM_DEVICE pEnumerate = (PREQ_ENUMERATE_DOWNSTREAM_DEVICE)ioBuffer;
            UCHAR ucPortNumber = pEnumerate->ucPortNumber;
                        UCHAR flags = 0;

                        USBDIAG_KdPrint(("*************************************************\n"));
            USBDIAG_KdPrint(("USBDIAG.SYS: REQ_FUNCTION_DESTROY_USBD_DEVICE\n"));
                        USBDIAG_KdPrint(("Port: %d\n", ucPortNumber));

            if (deviceExtension->DeviceData[ucPortNumber] != NULL)
            {
                            ntStatus = USBD_RemoveDevice(deviceExtension->DeviceData[ucPortNumber],
                                                           deviceExtension->RootHubPdo,
                                                                               flags);
            }
            else
            {
                ntStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS(ntStatus))
                        {
                deviceExtension->DeviceData[ucPortNumber] = NULL;
                                Irp->IoStatus.Status = ntStatus;
                                Irp->IoStatus.Information = sizeof(struct _REQ_ENUMERATE_DOWNSTREAM_DEVICE);;
                        }
        }
        else
            ntStatus = STATUS_NOT_IMPLEMENTED;

        break;  
        case REQ_FUNCTION_CHAP11_SEND_PACKET_DOWNSTREAM:
                {
                        PREQ_SEND_PACKET_DOWNSTREAM pReqSendPacket = (PREQ_SEND_PACKET_DOWNSTREAM)ioBuffer;
                        UCHAR ucPortNumber = (UCHAR)pReqSendPacket->usPortNumber;
            PUSBD_DEVICE_DATA DeviceData = deviceExtension->DeviceData[ucPortNumber];
            //PDEVICE_OBJECT StackDeviceObject =deviceExtension->StackDeviceObject;

                    USBDIAG_KdPrint(("*************************************************\n"));
            USBDIAG_KdPrint(("USBDIAG.SYS: REQ_FUNCTION_CHAP11_SEND_PACKET_DOWNSTREAM\n"));
            //USBDIAG_KdPrint(("DeviceData: 0x%x\n", DeviceData));
            //USBDIAG_KdPrint(("DeviceObject: 0x%x\n", StackDeviceObject));
            USBDIAG_KdPrint(("PortNumber: %d\n", ucPortNumber));
            //USBDIAG_KdPrint(("DeviceData: 0x%x\n", deviceExtension->DeviceData[ucPortNumber]));
            //USBDIAG_KdPrint(("bLowSpeed:  0x%x\n", pReqSendPacket->bLowSpeed));
            //USBDIAG_KdPrint(("pucBuffer:  0x%x\n", pReqSendPacket->pucBuffer));
            USBDIAG_KdPrint(("SetupPacket:\n"));
            USBDIAG_KdPrint(("    wRequest: 0x%04x\n", pReqSendPacket->SetupPacket.wRequest));
            USBDIAG_KdPrint(("    wValue:   0x%04x\n", pReqSendPacket->SetupPacket.wValue));
            USBDIAG_KdPrint(("    wIndex:   0x%04x\n", pReqSendPacket->SetupPacket.wIndex));
            USBDIAG_KdPrint(("    wLength:  0x%04x\n", pReqSendPacket->SetupPacket.wLength));

            if (deviceExtension->DeviceData[ucPortNumber] != NULL)
                        {
                                ntStatus = USBDIAG_Chap11SendPacketDownstream(DeviceData,
                                                                                                                          deviceExtension->RootHubPdo,
                                                                                                                          pReqSendPacket);
                                if (NT_SUCCESS(ntStatus))
                                {
                                        Irp->IoStatus.Status = ntStatus;
                                        Irp->IoStatus.Information = sizeof(struct _REQ_SEND_PACKET_DOWNSTREAM);
                                }
                        }
                        else
                        {
                                ntStatus = STATUS_INVALID_PARAMETER;
                        }
            ASSERT(NT_SUCCESS(ntStatus));

            break;
                }
    case REQ_FUNCTION_CHAP11_GET_DOWNSTREAM_DESCRIPTOR:
        {
            PREQ_GET_DOWNSTREAM_DESCRIPTOR pGetDownstreamDescriptor = (PREQ_GET_DOWNSTREAM_DESCRIPTOR)ioBuffer;
            USHORT usPortNumber = pGetDownstreamDescriptor->usPortNumber;
            PUSBD_DEVICE_DATA DeviceData = deviceExtension->DeviceData[usPortNumber];
            USHORT usDescType = pGetDownstreamDescriptor->DescriptorType;

                        Irp->IoStatus.Information = sizeof(struct _REQ_GET_DOWNSTREAM_DESCRIPTOR);

            USBDIAG_KdPrint(("'REQ_FUNCTION_CHAP11_GET_DOWNSTREAM_DESCRIPTOR:\n"));
            USBDIAG_KdPrint(("'PortNumber %d\n", usPortNumber));
            USBDIAG_KdPrint(("'DeviceData 0x%x\n", DeviceData));
            USBDIAG_KdPrint(("'usDescType %d\n", usDescType));
            USBDIAG_KdPrint(("'pGetDownstreamDescriptor->TransferBufferLength %d\n", pGetDownstreamDescriptor->TransferBufferLength));
            USBDIAG_KdPrint(("'sizeof(USB_DEVICE_DESCRIPTOR) %d\n", sizeof(USB_DEVICE_DESCRIPTOR)));

            if (!DeviceData) goto BAD_REQ_CHAP11_GET_DOWNSTREAM_DESCRIPTOR;

            switch (usDescType)
            {
            case USB_DEVICE_DESCRIPTOR_TYPE:
                if (pGetDownstreamDescriptor->TransferBufferLength < sizeof(USB_DEVICE_DESCRIPTOR))
                    goto BAD_REQ_CHAP11_GET_DOWNSTREAM_DESCRIPTOR;

                RtlCopyMemory(pGetDownstreamDescriptor->TransferBuffer,
                              &DeviceData->DeviceDescriptor,
                              sizeof(USB_DEVICE_DESCRIPTOR));

                ntStatus = STATUS_SUCCESS;
                break;
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (pGetDownstreamDescriptor->TransferBufferLength < sizeof(USB_CONFIGURATION_DESCRIPTOR) || 
                    deviceExtension->DownstreamConfigDescriptor[usPortNumber] == NULL)
                    goto BAD_REQ_CHAP11_GET_DOWNSTREAM_DESCRIPTOR;

                RtlCopyMemory(pGetDownstreamDescriptor->TransferBuffer,
                              deviceExtension->DownstreamConfigDescriptor[usPortNumber],
                              sizeof(USB_CONFIGURATION_DESCRIPTOR));

                ntStatus = STATUS_SUCCESS;
                break;

            default: // currently all others are unsupported
                goto BAD_REQ_CHAP11_GET_DOWNSTREAM_DESCRIPTOR;
            }

            break;
BAD_REQ_CHAP11_GET_DOWNSTREAM_DESCRIPTOR:
            ntStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        break;

    case REQ_FUNCTION_DISABLE_ENABLING_REMOTE_WAKEUP:
    case REQ_FUNCTION_ENABLE_ENABLING_REMOTE_WAKEUP:
        {
            BOOLEAN bDisable = (BOOLEAN)(REQHeader->Function == REQ_FUNCTION_DISABLE_ENABLING_REMOTE_WAKEUP ? TRUE : FALSE);

            ntStatus = USBDIAG_DisableRemoteWakeupEnable(actualdeviceObject, bDisable);
        }
        break;

    default:                        
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;                        
    }               

    Ch9FillInReqStatus (ntStatus, ulUrbStatus, REQHeader);

    if (bCompleteIrp)
    {
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    
    //USBDIAG_KdPrint(("USBDIAG.SYS: Chap9Ctrl returning w/ ntStatus: %#X REQStatus: %#X\n",
                        //ntStatus,
                        //REQHeader->Status));
    
    return ntStatus;

}   //USBDIAG_Chap9Control


NTSTATUS
USBDIAG_Ch9CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb,
    IN BOOLEAN fBlock,                          // currently ignored
    PIO_COMPLETION_ROUTINE CompletionRoutine,   // just passed to generic completion routine
    PVOID pvContext,                            // just passed to generic completion routine
    BOOLEAN fWantTimeOut                        // currently ignored
)
/**************************************************************************

Routine Description:

        Passes a URB to the USBD class driver

    NOTE:  Creates an IRP to do this.  Doesn't use the IRP that is passed down from user
        mode app (it's not passed to this routine at all).

Arguments:

    DeviceObject - pointer to the device object for this instance of a UTB 

    Urb - pointer to Urb request block

    fBlock - bool indicating if this fn should wait for IRP to return from USBD

    CompletionRoutine - fn to set as the completionroutine for this transfer ONLY IF
                        the fBlock is set to FALSE, indicating that the caller wants
                        to handle completion on their own and this fn should not 
                        block

    pvContext         - Context to be set in setting up the completion routine for the
                        Irp created in this function.  This is passed in by caller and is
                        just a pass-thru to the IoSetCompletionRoutine call.

    fWantTimeOut      - If caller wants this function to use a deadman timeout and cancel
                        the Irp after the timeout expires.  TRUE means this function will
                        use the timeout mechanism, and FALSE means this function will block
                        indefinitely and wait for the Irp/Urb to return from the USB stack.
                                        
Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

**************************************************************************/
{
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PCOMPLETION_CONTEXT pGenericContext;

    USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_Ch9CallUSBD\n"));        
    {
            KIRQL irql;
            irql = KeGetCurrentIrql();
            ASSERT(irql <= PASSIVE_LEVEL);
    }

    pGenericContext = ExAllocatePool(NonPagedPool, sizeof(COMPLETION_CONTEXT));

    if (!pGenericContext)
        return STATUS_INSUFFICIENT_RESOURCES;

    deviceExtension = DeviceObject->DeviceExtension;

    ASSERT (deviceExtension != NULL);
    ASSERT ((deviceExtension->StackDeviceObject) != NULL);

    if ((deviceExtension) && (deviceExtension->StackDeviceObject))
    {
        // issue a synchronous request to read the USB Device Ctrl pipe
        KeInitializeEvent(&pGenericContext->DoneEvent, NotificationEvent, FALSE);

        // Create the IRP that we'll use to submit this URB to the USB stack
        irp = IoBuildDeviceIoControlRequest(
                    IOCTL_INTERNAL_USB_SUBMIT_URB,
                    deviceExtension->StackDeviceObject,
                    NULL,
                    0,
                    NULL,
                    0,
                    TRUE, /* INTERNAL */
                    //&event,
                    &pGenericContext->DoneEvent,
                    &ioStatus); //the status codes in NT IRPs go here

        pGenericContext->DeviceObject = DeviceObject;
        pGenericContext->Irp = irp;
        pGenericContext->CompletionRoutine = CompletionRoutine;
        pGenericContext->Context = pvContext;


        //NOTE: The status returned by USBD in the URB is more USB transfer-specific (e.g.,
        //      it indicates things like USB stall conditions, etc.).  The USBD status
        //      is contained in the URB's status field.  However, USBD maps those URB error
        //      codes to more generic NT_STATUS_XXX error codes when the IRP returns.  To
        //      get a more detailed and USB-specific reading of the error code, look at
        //      the URB's status field.

        // Call the class driver to perform the operation.  If the returned status
        // is PENDING, wait for the request to complete.
        nextStack = IoGetNextIrpStackLocation(irp);
        ASSERT(nextStack != NULL);

        // save a pointer to the Irp for our cancel routine
        ntStatus = USBDIAG_SaveIrp(deviceExtension, irp);

        USBDIAG_KdPrint (("USBDIAG.SYS: Urb header function 0x%x (0x%x)\n",
                          Urb->UrbHeader.Function,
                          URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER));
                          
        if (Urb->UrbHeader.Function == URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER)
        {
            USBDIAG_KdPrint(("Saving interrupt irp\n"));
            ASSERT(deviceExtension->InterruptIrp == NULL);
            deviceExtension->InterruptIrp = irp;
        }

        if (!NT_SUCCESS(ntStatus))
        {
            ExFreePool(pGenericContext);
            return ntStatus;
        }

        // pass the URB to the USBD 'class driver'
        nextStack->Parameters.Others.Argument1 = Urb;

        // set the generic routine
        IoSetCompletionRoutine(irp,
                               USBDIAG_IoGenericCompletionRoutine,
                               pGenericContext,
                               TRUE,        //InvokeOnSuccess
                               TRUE,        //InvokeOnError,
                               TRUE);       //InvokeOnCancel
        
        USBDIAG_KdPrint (("USBDIAG.SYS: calling USBD\n"));

        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, irp);

        USBDIAG_KdPrint (("USBDIAG.SYS: return from IoCallDriver USBD in USBDIAG_Ch9CallUSBD %x\n", ntStatus));

        if (ntStatus == STATUS_PENDING)
        {
            USBDIAG_KdPrint(("USBDIAG.SYS: Waiting for done signal\n"));
            KeWaitForSingleObject(&pGenericContext->DoneEvent,
                                  Suspended, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            ntStatus = Urb->UrbHeader.Status;
        }

        USBDIAG_KdPrint (("USBDIAG.SYS: Urb status = %x Irp status %x\n", 
                          Urb->UrbHeader.Status, 
                          irp->IoStatus.Status));

        ioStatus.Status = ntStatus;         
        //ioStatus.Information = 0;
        //USBD maps the error code for us
        
        USBDIAG_KdPrint(("USBDIAG.SYS: URB TransferBufferLength OUT is: %d\n",Urb->UrbControlDescriptorRequest.TransferBufferLength));
        
    }//if valid deviceExtension and StackDevObjects 
    else 
    {
        // Invalid extension or stackdevobj received
        ntStatus = STATUS_INVALID_PARAMETER;
        USBDIAG_KdPrint(("USBDIAG.SYS: Invalid deviceExtension or StackDeviceObject\n"));
    } //else invalid devExt or stackdevobj
    
    USBDIAG_KdPrint(("USBDIAG.SYS: exiting USBDIAG_Ch9CallUSBD w/ URB/ntStatus: %x\n", ntStatus));

    ExFreePool(pGenericContext);


    return ntStatus;
}//USBDIAG_Ch9CallUSBD


NTSTATUS
USBDIAG_SendPacket(
    IN PDEVICE_OBJECT DeviceObject, 
        IN CHAR SetUpPacket[], 
        PVOID   TxBuffer,
        ULONG * TxBufferLen, //see comments below!
        ULONG * pulUrbStatus 
        
    )
/*++

Routine Description:

Arguments:
      DeviceObject - pointer to the device object for this instance of the TESTDRV
                    devcice.
      SetupPacket  - formatted by caller to contain exactly the 8 bytes setup pkt
      TxBuffer     - if a data stage occurs, this is where data originates or ends up
      TxBufferLen  - incoming it's a ptr to the len of the TxBuffer
                   - outgoing we shove the actual len of the data in the buffer for INPUT bus transfers
      pulUrbStatus - Urb status is put here for more visibility into what happened on USB
                    
Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb;
//    PUSB_CONFIGURATION_DESCRIPTOR configurationDescriptor = NULL;
    int i = 0 ;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_SendPacket\n"));    

    deviceExtension = DeviceObject->DeviceExtension;

    urb = USBDIAG_ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_TRANSFER));

    // need to zero out this buffer, kludge to fix a language ID problem
    RtlZeroMemory(urb, sizeof(struct _URB_CONTROL_TRANSFER));

    if (urb) 
    {
        (urb)->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;
        (urb)->UrbHeader.Length = sizeof(struct _URB_CONTROL_TRANSFER);
        (urb)->UrbControlTransfer.PipeHandle = 0; // this will cause us to use the default pipe

         //USBDIAG_KdPrint(("USBDIAG.SYS: TxBufferLen=%d | TxBuffer = %x\n",*TxBufferLen, TxBuffer));    
        (urb)->UrbControlTransfer.TransferBufferLength = *TxBufferLen ; 
        (urb)->UrbControlTransfer.TransferBufferMDL = NULL ; 
        (urb)->UrbControlTransfer.TransferBuffer = TxBuffer ; 
        (urb)->UrbControlTransfer.UrbLink = NULL;
        (urb)->UrbControlTransfer.TransferFlags = ( (SetUpPacket[0] & bmReqD2H) ? (USBD_TRANSFER_DIRECTION_IN | USBD_SHORT_TRANSFER_OK) : 0 ) ; 
                //USBDIAG_KdPrint(("USBDIAG.SYS: Tx direction %x\n", (urb)->UrbControlTransfer.TransferFlags)) ;    

        (urb)->UrbControlTransfer.UrbLink = NULL;

        for ( i = 0 ; i < SETUP_PACKET_LEN ; i ++ )
        {
                (urb)->UrbControlTransfer.SetupPacket[i] = SetUpPacket[i] ; // 0x01;
        }
        
        //don't need to do this.  stack will yank it out of the PDO and use
        //the right usbdhandle for this txfer
        //  urb->UrbHeader.UsbdDeviceHandle = UsbdHandle ;  

        ntStatus = USBDIAG_Ch9CallUSBD(DeviceObject, urb, TRUE, NULL, NULL, TRUE);

        // Set the caller's urb status
        if (pulUrbStatus) 
            *pulUrbStatus = urb->UrbHeader.Status;

        //USBDIAG_KdPrint(("USBDIAG.SYS: SendPacket: UrbStatus = 0x%x\n",urb->UrbHeader.Status));
        
        if (NT_SUCCESS(ntStatus) && (TxBufferLen != NULL))
        {
            // Tell caller how much data was transferred (mostly valid on INs)
            // Don't know how interesting this is on OUTs but it's set anyway
            //

            *TxBufferLen = urb->UrbControlDescriptorRequest.TransferBufferLength;
            //USBDIAG_KdPrint(("USBDIAG.SYS: USBDIAG_SendPacket-TransferBufferLength: %d\n",
                              //*TxBufferLen));
        }//if
        
        USBDIAG_ExFreePool(urb);
        //USBDIAG_KdPrint(("USBDIAG.SYS: Inside the if before the else STATUS_INSUFFICIENT_RESOURCES\n"));

    } 
    else 
    {
        //USBDIAG_KdPrint(("USBDIAG.SYS: Inside the else STATUS_INSUFFICIENT_RESOURCES"));
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    
    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_SendPacket (%x)\n",ntStatus));
    return ntStatus;
}               /* End of USBDIAG_SendPacket() */


PBYTE
pAllocFromBuffer(
    PBYTE  pBuffer,
    ULONG  iSize,
    PULONG piOffset,
    PULONG piTotalUsed,
    ULONG  iRequested
    )
/*
    This function is used to sub-allocate memory from the buffer managed 
    by the ioctl call.  This allows complex structures to be build in a 
    single contigious buffer, which can be returned to ring 3. (The 
    routine is necessary because DeviceIoControl only provides for the
    movement of one buffer from ring 3 to ring 0 and back
*/
{
    PVOID   pReturn;

    //
    // CROBINS: This was buggy...Changed *piOffset+iRequested to 
    //          *piTtoalUsed+iRequested
    if (*piTotalUsed + iRequested > iSize)
    {
        pReturn=NULL;
    }
    else
    {
        pReturn = pBuffer + *piTotalUsed;

        *piOffset = *piTotalUsed;

        (*piTotalUsed)+=iRequested;
    } 
 
    return pReturn;
}



NTSTATUS
USBDIAG_HIDP_GetCollection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )    
/*++
History:
    This routine was added for support of the HID Test application's parsing
    capabilities.

        Kosar Jaff  8-14-96 (Intel Corp.)

Routine Description:
    Calls the Hid Parser driver with a raw report descriptor
        (see HidP_GetCollectionDescription in hidpddi.h for behavior)

    This function assumes that the caller will use an IOCTL with the
    METHOD_BUFFERED specified.  The function will place the result of
    the parse in the SystemBuffer and expect IOS to copy the result to the
    user's OutputBuffer specified in the DeviceIoControl call made in UserMode.

    The incoming buffer will be used as it appears in the SystemBuffer (locked by
    IOS on the way down) even though since this function is in the calling thread's
    context, we could have used UserBuffer directly. 

  Note:  This function will put the 

Arguments:

      DeviceObject - ptr to this driver's "Device" object
      Irp          - incoming IRP from user mode ioctl

 
Return Value:

    NT status code
    
--*/
{
    PIO_STACK_LOCATION      irpStack;
    HIDP_DEVICE_DESC        rCollectionsAndIDs;
    PVOID                   ioBuffer;
    ULONG                   inputBufferLength;
    ULONG                   outputBufferLength;
    NTSTATUS                ntStatus;
    PHIDP_COLLECTION_DESC   pHidPCollDesc       = NULL;
    //PHIDP_COLLECTION_DESC   pTempCollDesc       = NULL;
    PCHAR                   pCollBlock;
    ULONG                   ulBytInBuff;
    ULONG                   nCollectionDescElem = 0;
    ULONG                   i;
    //ULONG                   ulTotBytesCopied =0;
    BOOL                    bFailed = FALSE;
    ULONG                   iOffset=0;
    ULONG                   iTotalUsed=0;
    PBYTE                   pSubBuffer;
    PHIDP_DEVICE_DESC       pDeviceDesc;
    PHIDP_COLLECTION_DESC   pCollectionDesc;


    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    //USBDIAG_KdPrint(("USBDIAG.SYS: irpStk->Prm.DvIoC.InptLn: %x | OutptLen: %x | UsrBuff: %x\n",
                        //irpStack->Parameters.DeviceIoControl.InputBufferLength,
                        //irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                        //Irp->UserBuffer));

    // Get the pointer to the input/output buffer and it's length
    // the SystemBuffer contains the raw descriptor that is to be parsed
    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    //USBDIAG_KdPrint(("USBDIAG.SYS: RepDesc (ioBuffer): %X | RepDesc Len: %d\n",
                      //ioBuffer, 
                      //inputBufferLength));

    //call the parser function in HIDPARSE library
/*    ntStatus = 
    HidP_GetCollectionDescription (ioBuffer,
                                   inputBufferLength,
                                   NonPagedPool,
                                   &pHidPCollDesc,
                                   &nCollectionDescElem);
This is being changed to match a change to hidparse. JobyL
  */


    rCollectionsAndIDs.CollectionDesc=NULL;
    rCollectionsAndIDs.CollectionDescLength=0;
    //USBDIAG_KdPrint(("USBDIAG.SYS: Before the call to HidP_GetCollectionDescription\n"));

    ntStatus=HidP_GetCollectionDescription (ioBuffer,
                                   inputBufferLength,
                                   NonPagedPool,
                                   &rCollectionsAndIDs);

    //USBDIAG_KdPrint(("USBDIAG.SYS: After the call to HidP_GetCollectionDescription\n"));
    pHidPCollDesc=rCollectionsAndIDs.CollectionDesc;
    nCollectionDescElem=rCollectionsAndIDs.CollectionDescLength;

    //USBDIAG_KdPrint(("USBDIAG.SYS: HidCollDesc: %X | NbrCollElem: %d\n",
                      //pHidPCollDesc,
                      //nCollectionDescElem));

    if ( (nCollectionDescElem) && NT_SUCCESS(ntStatus) ) {

        /*
        // We put the collection descriptor into the "systembuffer" so that
        // IOS can copy from there to the user buffer when we complete the IRP.
        // Note the collection descriptors go in the buffer first, and then if
        // there is room left, the PreParsedData is appended to the end.
        //
        // Since the pointers in the structures passed back from HIDPARSE are all
        // Ke-Mode pointers, they won't be valid in User Mode, so we convert all 
        // those to relative pointers (offsets) and then let User Mode code re-convert
        // them back to pointers w.r.t. the User Mode base pointers.
        //
        // VERY IMPORTANT:  Note that the pointer to the Pre Parsed Data structure that 
        //                  gets patched by this routine is an OFFSET based on the base
        //                  of the collection descriptor blocks.  So, this means that the
        //                  pre parsed data blocks are referenced based on the first
        //                  collection description element, which also happens to be the
        //                  base of the entire output buffer.
        //                  
        //                  User mode code that is trying to reconstruct this buffer must
        //                  be aware of this organization.
        //
        */
        ASSERT (pHidPCollDesc != NULL);                     
        ulBytInBuff = outputBufferLength;
        
        // Early out--if not enough room for the fixed size blocks, don't continue
        if (ulBytInBuff < (nCollectionDescElem * sizeof(HIDP_COLLECTION_DESC))) {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            //USBDIAG_KdPrint(("USBDIAG.SYS: ERROR: Not enuf mem in outbuff to put collection descriptions!\n"));
            TRAP();
            goto DoneWithParse;
        }

        //set the base ptr of collection descriptions and PPD blocks
        pCollBlock = (PCHAR)ioBuffer;
        
        //USBDIAG_KdPrint(("USBDIAG.SYS: pCollBlock (base): %X  NbrCollDescElem: %d\n",
                           //pCollBlock,  nCollectionDescElem));


        pSubBuffer = pAllocFromBuffer((PBYTE) pCollBlock,
                                      outputBufferLength,
                                      &iOffset,
                                      &iTotalUsed,
                                      sizeof(HIDP_DEVICE_DESC));

        if (NULL == pSubBuffer)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            TRAP();
            goto DoneWithParse;
        }
        
        memcpy(pSubBuffer, &rCollectionsAndIDs, sizeof(HIDP_DEVICE_DESC));
        pDeviceDesc = (PHIDP_DEVICE_DESC) pSubBuffer;

        pSubBuffer = pAllocFromBuffer((PBYTE) pCollBlock,
                                      outputBufferLength,
                                      &iOffset,
                                      &iTotalUsed,
                                      sizeof(HIDP_REPORT_IDS)*(pDeviceDesc->ReportIDsLength));

        if (NULL == pSubBuffer)
        {
           ntStatus = STATUS_INSUFFICIENT_RESOURCES;
           TRAP();
           goto DoneWithParse;
        }
     
        memcpy(pSubBuffer,
               pDeviceDesc->ReportIDs,
               sizeof(HIDP_REPORT_IDS)*(pDeviceDesc->ReportIDsLength));

        //
        // patch pointer to make it relative       
        //

        pDeviceDesc->ReportIDs = (PHIDP_REPORT_IDS) UlongToPtr(iOffset);

        pSubBuffer = pAllocFromBuffer((PBYTE) pCollBlock,
                                      outputBufferLength,
                                      &iOffset,
                                      &iTotalUsed,
                                      sizeof(HIDP_COLLECTION_DESC)*(pDeviceDesc->CollectionDescLength));

        if (NULL == pSubBuffer)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            TRAP();
            goto DoneWithParse;
        }

        memcpy(pSubBuffer,
               pDeviceDesc->CollectionDesc,
               sizeof(HIDP_COLLECTION_DESC)*(pDeviceDesc->CollectionDescLength));

        //
        // patch pointer to make it relative       
        //

        pDeviceDesc->CollectionDesc = (PHIDP_COLLECTION_DESC) ULongToPtr(iOffset); 

        pCollectionDesc = (PHIDP_COLLECTION_DESC) pSubBuffer;
                 
        for (i=0; i < pDeviceDesc->CollectionDescLength; i++)
        {
            pSubBuffer = pAllocFromBuffer((PBYTE) pCollBlock,
                                          outputBufferLength,
                                          &iOffset,
                                          &iTotalUsed,
                                          pCollectionDesc->PreparsedDataLength);  

            if (NULL == pSubBuffer)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                TRAP();
                goto DoneWithParse;
            }

            memcpy(pSubBuffer,
                   pCollectionDesc->PreparsedData,
                   pCollectionDesc->PreparsedDataLength);

            //
            // patch pointer to make it relative       
            //

            pCollectionDesc->PreparsedData = (PHIDP_PREPARSED_DATA) ULongToPtr(iOffset); 
            pCollectionDesc++;
        } 

DoneWithParse:

        /*
        // Setting the Irp->IoStatus.Information field tells the IOS how many bytes to copy
        // back into the user buffer and hopefully will set the value in 
        // DeviceIoControl's "lpBytesReturned" field.
        */

        //
        // free up collection stuff that parser returned
        //

        HidP_FreeCollectionDescription(&rCollectionsAndIDs);

        Irp->IoStatus.Information =  iTotalUsed;

        //USBDIAG_KdPrint(("USBDIAG.SYS: TotalBytesCopied into systembuffer%d\n", iTotalUsed));            

    } else {
        // call to parser failed 
//        //USBDIAG_KdPrint(("USBDIAG.SYS: HidP_GetCollectionDescription failed w/ ntStatus: %X\n", ntStatus));
                memcpy(ioBuffer,&rCollectionsAndIDs,sizeof(HIDP_DEVICE_DESC));
//        Irp->IoStatus.Information = sizeof(HIDP_DEVICE_DESC);  //Copy just the DeviceDesc struct so that ring3 gets the debug struct
                  Irp->IoStatus.Information=sizeof(HIDP_DEVICE_DESC);
                  bFailed=TRUE;
    }//if
            
    // We always complete w/ success since the real status is in the REQ Header status field
    Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;

    // Complete the IRP here so we can free the buffer created by HIDPARSE when we called it
    // after the IOS copies stuff back to user space, etc.

    return ntStatus;
                
}//USBDIAG_HIDP_GetCollection


VOID
USBDIAG_SyncTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
Routine Description:
    This routine runs at DISPATCH_LEVEL IRQL. 
Arguments:
    Dpc                         - Pointer to the DPC object.
    DeferredContext - passed in to IOS by caller as context (we use it as pIrp)
    SystemArgument1 - not used.
    SystemArgument2 - not used.
Return Value:
    None.
--*/
{
    BOOLEAN status;
        PIRP    irp             = DeferredContext; 

//      TRAP();
        // The cancel Irp call below will return immediately, but that doesn't mean things are all 
        // cleaned up in the USB stack.  The only way to be assured of that is when the
        // WaitForSingleObject that blocked in the first place returns (due to the USB stack
        // completing the Irp, either due to normal completion or due to this cancel Irp call.
        status = IoCancelIrp(irp);

        //BUGBUG (kosar) We don't do anything if the cancel fails, and we probably should.
        //                               (like maybe reschedule or something)

        return;
}

NTSTATUS
USBDIAG_Configure_Device (
        IN PDEVICE_OBJECT DeviceObject, 
        IN PIRP Irp)
{

    PDEVICE_EXTENSION deviceExtension;
    NTSTATUS ntStatus;
    PURB urb = NULL;
    ULONG siz;
    PUSB_CONFIGURATION_DESCRIPTOR   configurationDescriptor = NULL;
    struct _REQ_HEADER *            REQHeader = NULL;
    struct _REQ_SET_DEVICE_CONFIG * REQSetDeviceConfig = NULL;
    PIO_STACK_LOCATION      irpStack = NULL;
    PVOID                   ioBuffer;
    ULONG                   inputBufferLength;
    ULONG                   outputBufferLength;
    PDEVICE_LIST_ENTRY      devListEntry;
    PDEVICE_OBJECT          actualdeviceObject;
    ULONG                   ulUrbStatus;
    
    
    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_ConfigureDevice\n"));    

    // Get a pointer to the current location in the Irp. This is where
        //     the function codes and parameters are located.
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    // Get the pointer to the input/output buffer and it's length
    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    
    // The REQHeader, which is the struct that the app fills in describing this REQuest is
    // referenced in the SystemBuffer since it is sent down in the InputBuffer field of the
    // DeviceIoControl call in User Mode.
    // The ReqSetDeviceConfig is where the results of this call will go (using a separate
    // var here just for convenience.
    REQHeader = (struct _REQ_HEADER *)ioBuffer;
    REQSetDeviceConfig = (struct _REQ_SET_DEVICE_CONFIG *) ioBuffer;
    
    // The DeviceHandle is a ptr to the list entry that USBDIAG manages for devices it is
    // testing.  This used to be a "USBD Device handle" in the old Chap9 method.  Now it's a
    // ptr to the list entry object that USBDIAG maintains for each device under test.  That
    // list entry contains the PDO and other junk about the device object
    devListEntry = (PDEVICE_LIST_ENTRY)(REQHeader->UsbdDeviceHandle);
    //USBDIAG_KdPrint(("USBDIAG.SYS: DevListEntry: %X\n",devListEntry));
    ASSERT (devListEntry != NULL);

    if (devListEntry == NULL) 
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        REQHeader->Status = CH9_STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information=sizeof (struct _REQ_HEADER); //return the status junk
        Irp->IoStatus.Information=ntStatus;
        goto Exit_USBDIAGConfigureDevice;  //Bail if things look bad
    } //if

    // Device object given is not the real PDO that is needed by the USB stack, so
    // extract that PDO with a handy macro before calling the lower level drivers (USB stk)
    actualdeviceObject =  FDO_FROM_DEVICE_HANDLE(devListEntry);
    //USBDIAG_KdPrint(("USBDIAG.SYS: PDO for DUT: %X\n",actualdeviceObject));
    ASSERT (actualdeviceObject != NULL);

    if (actualdeviceObject == NULL) 
    {
        ntStatus = STATUS_INVALID_PARAMETER;
        REQHeader->Status = CH9_STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information=sizeof (struct _REQ_HEADER); //return the status junk
        Irp->IoStatus.Information=ntStatus;
        goto Exit_USBDIAGConfigureDevice;  //Bail if things look bad
    }//if

    urb = USBDIAG_ExAllocatePool(NonPagedPool, sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));

    if (urb) 
    {
        /* 
        // Set size of the data buffer.  Note we add padding to cover hardware faults 
        // that may cause the device to go past the end of the data buffer
        */
        siz = sizeof(USB_CONFIGURATION_DESCRIPTOR) + 256;
     
        // Get the nonpaged pool memory for the data buffer
        configurationDescriptor = USBDIAG_ExAllocatePool(NonPagedPool, siz);

        //USBDIAG_KdPrint(("USBDIAG.SYS: Config Index Requested: %#X\n",
                          //REQSetDeviceConfig->iConfigurationDescIndex));
        
        if (configurationDescriptor) 
        {    
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         (UCHAR)(REQSetDeviceConfig->iConfigurationDescIndex),
                                         0, //LANGUAGE ID
                                         configurationDescriptor,
                                         NULL,
                                         siz, // sizeof (USB_CONFIGURATION_DESCRIPTOR),/* Get only the configuration descriptor */
                                         NULL);
                                                                  
            ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, TRUE);

            ulUrbStatus = urb->UrbHeader.Status;
            
            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Configuration Descriptor is at %x, bytes txferred: %d\n\
                                  //Configuration Descriptor Actual Length: %d\n", 
                                  //configurationDescriptor, 
                                  //urb->UrbControlDescriptorRequest.TransferBufferLength,
                                  //configurationDescriptor->wTotalLength));    
            }//if
            else
            {
                //Urb had a failure
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed getting partial Config Descr: UrbStatus: %#X\n",ulUrbStatus));
                Ch9FillInReqStatus (ntStatus, ulUrbStatus, REQHeader);
                Irp->IoStatus.Information = sizeof (struct _REQ_SET_DEVICE_CONFIG);
                Irp->IoStatus.Status      = ntStatus;
                goto Exit_USBDIAGConfigureDevice;
            }//else failed Urb

        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit_USBDIAGConfigureDevice;
        }//if-else    
        
        // Determine how much data is in the entire configuration descriptor
        // and add extra room to protect against accidental overrun
        siz = configurationDescriptor->wTotalLength + 16;

        //  Free up the data buffer memory just used 
        USBDIAG_ExFreePool(configurationDescriptor);
        configurationDescriptor = NULL;
        
        // Get nonpaged pool memory for the data buffer
                configurationDescriptor = USBDIAG_ExAllocatePool(NonPagedPool, 
                                                 siz);

        // Now get the entire Configuration Descriptor 
        if (configurationDescriptor) 
        {
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_CONFIGURATION_DESCRIPTOR_TYPE,
                                         (UCHAR)(REQSetDeviceConfig->iConfigurationDescIndex),
                                         0, //LANGUAGE ID
                                         configurationDescriptor,
                                         NULL,
                                         siz,  // Get all the descriptor data
                                         NULL);
                                                                  
                        //USBDIAG_KdPrint(("USBDIAG.SYS: Trying to get entire Config Descriptor (%d bytes)...\n",
                                                          //siz-16));
                                                          
            ntStatus = USBDIAG_Ch9CallUSBD(actualdeviceObject, urb, TRUE, NULL, NULL, TRUE);

            ulUrbStatus = urb->UrbHeader.Status;

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Entire Configuration Descriptor is at %x, bytes txferred: %d\n", 
                                  //configurationDescriptor, 
                                  //urb->UrbControlDescriptorRequest.TransferBufferLength));    
            } 
            else 
            {
                //Error in getting configuration descriptor
                //USBDIAG_KdPrint(("USBDIAG.SYS: Failed getting entire Config Descr: UrbStatus: %#X\n",ulUrbStatus));
                Ch9FillInReqStatus (ntStatus, ulUrbStatus, REQHeader);
                Irp->IoStatus.Information = sizeof (struct _REQ_HEADER);
                Irp->IoStatus.Status      = ntStatus;
                goto Exit_USBDIAGConfigureDevice;
            }//else failed getconfig descriptor
        } 
        else 
        {
            // Failed getting data buffer (configurationDescriptor) memory 
            ntStatus                  = STATUS_INSUFFICIENT_RESOURCES;
            REQHeader->Status         = CH9_STATUS_NO_MEMORY;
            Irp->IoStatus.Information = sizeof (struct _REQ_HEADER);
            Irp->IoStatus.Status      = ntStatus;
            goto Exit_USBDIAGConfigureDevice;
        }//if-else
    } 
    else 
    {
        // failed getting urb memory
        ntStatus                  = STATUS_INSUFFICIENT_RESOURCES;        
        REQHeader->Status         = CH9_STATUS_NO_MEMORY;
        Irp->IoStatus.Information = sizeof (struct _REQ_HEADER);
        Irp->IoStatus.Status      = ntStatus;
        goto Exit_USBDIAGConfigureDevice;
    }//if-else        
    
    /*
    // We have the configuration descriptor for the configuration
    // we want.
    //
    // Now we issue the SelectConfiguration command to get 
    // the  pipes associated with this configuration.
    */
    if (configurationDescriptor) 
    {
        // Get our pipes
        // NOTE: USBDIAG_SelectInterfaces will set the status field in the Chap9 REQHeader
        //       struct so we don't need to do it here, just set the length of the Irp based
        //       on the ntStatus code that SelectInterfaces returns.
        ntStatus = USBDIAG_SelectInterfaces(actualdeviceObject, 
                                           configurationDescriptor,
                                           NULL, // Device not yet configured
                                           REQSetDeviceConfig //Send the user's config context down
                                           );
        if (NT_SUCCESS(ntStatus)) 
        {
            //If success, then copy back all the data to user's buffer
            //USBDIAG_KdPrint(("USBDIAG.SYS: Successful SelectInterfaces \n"));
            Irp->IoStatus.Information= REQHeader->Length; //return everything if success
            Irp->IoStatus.Status     = ntStatus;          //fill in Irp code
        } //if success
        else
        {
           //if didn't succeed, only copy the header portion which has the status code
           //USBDIAG_KdPrint(("USBDIAG.SYS: Failed SelectInterfaces \n"));
           Irp->IoStatus.Information= sizeof (REQHeader); //return only header portion
           Irp->IoStatus.Status     = ntStatus;          //fill in Irp code
        }//else failure
       
    } //if

Exit_USBDIAGConfigureDevice:

    // Clean up and exit this routine
    if (urb) 
    {
        USBDIAG_ExFreePool(urb);                    // Free urb memory
    }//if
    
    if (configurationDescriptor) 
    {
        USBDIAG_ExFreePool(configurationDescriptor);// Free data buffer
    }//if

    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_ConfigureDevice (ntStat: %x)\n", ntStatus));
    return ntStatus;

}//USBDIAG_Configure_Device


NTSTATUS
USBDIAG_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT struct _REQ_SET_DEVICE_CONFIG * REQSetDeviceConfig
    )
/*++
Arguments:
    DeviceObject            - pointer to the device object for this instance of the USB Device
    ConfigurationDescriptor - pointer to the USB configuration descriptor containing the interface and endpoint
                              descriptors.
    Interface               - pointer to a USBD Interface Information Object
                            - If this is NULL, then this driver must choose its interface based on driver-specific
                              criteria, and the driver must also CONFIGURE the device.  
                            - If it is NOT NULL, then the driver has already been given an interface and
                              the device has already been configured by the parent of this device driver.
    REQSetDeviceConfig      - Where the results will go for this config request
Return Value:
    NT status code
--*/
{
    PDEVICE_EXTENSION deviceExtension  = DeviceObject->DeviceExtension;
    NTSTATUS          ntStatus = STATUS_SUCCESS;
    PURB urb;
    ULONG siz, numberOfInterfaces, j, numberOfPipes;
    PUSB_INTERFACE_DESCRIPTOR interfaceDescriptor;
    PUSBD_INTERFACE_INFORMATION interfaceObject;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_SelectInterfaces\n"));    

    if (Interface == NULL) 
    {
        // This driver only supports one interface.
        numberOfInterfaces = ConfigurationDescriptor->bNumInterfaces; 
                //USBDIAG_KdPrint(("USBDIAG.SYS: Device has %d Interfaces\n",numberOfInterfaces));                          

                numberOfInterfaces =1;      // Fixed for this sample driver in this revision
        numberOfPipes = 0;          // Initialize to zero

        // Call a USBD helper function that returns a ptr to a USB Interface Descriptor given
        // a USB Configuration Descriptor, an Inteface Number, and an Alternate Setting for that Interface
        interfaceDescriptor = 
            USBD_ParseConfigurationDescriptorEx(ConfigurationDescriptor,
                                                ConfigurationDescriptor,
                                                -1,  // InterfaceNumber
                                                -1,  // AlternateSetting
                                                -1,  // InterfaceClass
                                                -1,  // InterfaceSubClass
                                                -1); // InterfaceProtocol

        ASSERT(interfaceDescriptor != NULL);                                              

        if (interfaceDescriptor != NULL) 
        {
            //USBDIAG_KdPrint(("USBDIAG.SYS: Device has %d Interface(s) | Interface is at: (%#X)\n",
                            //numberOfInterfaces, interfaceDescriptor));

            // Check if caller gave us enough pipe contexts to put all the info in
            if ((REQSetDeviceConfig->nNumContexts) < (interfaceDescriptor->bNumEndpoints))
            {
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Not enough mem to configure device \n"));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Number of Contexts: %d | Number of Endpoints: %d",
                                                                        //REQSetDeviceConfig->nNumContexts,interfaceDescriptor->bNumEndpoints));
                return (STATUS_INSUFFICIENT_RESOURCES);
            }/* if size is ok */

            // Check if the number of pipes in this interface exceeds the maximum we can
            // support in the device extension area
            if ((interfaceDescriptor->bNumEndpoints) > USBDIAG_MAX_PIPES)
            {
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Number of Endpoints (%d) exceeds MAX_PIPES (%d)",
                                  //interfaceDescriptor->bNumEndpoints, USBDIAG_MAX_PIPES));
                                                                        
                return (STATUS_INSUFFICIENT_RESOURCES);
            }/* if dev ext has enough room */


                /* Add to the tally of pipes in this configuration */
                numberOfPipes += interfaceDescriptor->bNumEndpoints;

                //USBDIAG_KdPrint(("USBDIAG.SYS: Interface has %d endpoints\n",
                                  //interfaceDescriptor->bNumEndpoints));
              
                /*
                // Now that we have looked at the interface, we configure the device so that the remainder
                // of the USBD objects will come into existence (ie., pipes, etc.) as a result of the configuration,
                // thus completing the configuration process for the USB device.
                //
                // Allocate a URB big enough for this Select Configuration request
                        // This driver supports only 1 interface
                //
                // NOTE:  The new service USBD_CreateConfigurationRequest will replace some of the
                //        code below.  Future releases of this driver will demonstrate how to use
                //        that service.
                //
                        */
                siz = GET_SELECT_CONFIGURATION_REQUEST_SIZE(numberOfInterfaces, numberOfPipes);
            
                //USBDIAG_KdPrint(("USBDIAG.SYS: size of config request Urb = %d\n", siz));
            
                urb = USBDIAG_ExAllocatePool(NonPagedPool, 
                                     siz);

                if (urb) {
                    interfaceObject = (PUSBD_INTERFACE_INFORMATION) (&(urb->UrbSelectConfiguration.Interface));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: urb.Interface=%#X\n", &(urb->UrbSelectConfiguration.Interface)));

                    // set up the input parameters in our interface request structure.
                    interfaceObject->Length = (USHORT)GET_USBD_INTERFACE_SIZE(interfaceDescriptor->bNumEndpoints);

                    //USBDIAG_KdPrint(("USBDIAG.SYS: size of interface request = %d\n", interfaceObject->Length));

                    interfaceObject->InterfaceNumber = interfaceDescriptor->bInterfaceNumber;
                    interfaceObject->AlternateSetting = interfaceDescriptor->bAlternateSetting;  
                    interfaceObject->NumberOfPipes = interfaceDescriptor->bNumEndpoints;

                    /* 
                    // We set up a default max transfer size for the endpoints.  Your driver will
                    // need to change this to reflect the capabilities of your device's endpoints.
                    */
                    for (j=0; j<interfaceDescriptor->bNumEndpoints; j++) {
                        interfaceObject->Pipes[j].MaximumTransferSize = 
                            USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE; //Defaults to PAGE_SIZE (4k)
                        interfaceObject->Pipes[j].PipeFlags = 0;
                    } /* for */

                                //USBDIAG_KdPrint(("USBDIAG.SYS: InterfaceObj Inteface Nbr: %d | InterfaceObj AltSett: %d |NbrPip: %d\n",
                                                                 //interfaceObject->InterfaceNumber,
                                                                 //interfaceObject->AlternateSetting,
                                                                 //interfaceObject->NumberOfPipes));

                    UsbBuildSelectConfigurationRequest(urb,
                                                      (USHORT) siz,
                                                      ConfigurationDescriptor);
                                             
                    ntStatus = USBDIAG_Ch9CallUSBD(DeviceObject, urb, TRUE, NULL, NULL, TRUE);

                    if (NT_SUCCESS(ntStatus) && USBD_SUCCESS(urb->UrbSelectConfiguration.Hdr.Status)) {

                        // Save the configuration handle for this device
                        deviceExtension->ConfigurationHandle = 
                            urb->UrbSelectConfiguration.ConfigurationHandle;

                        deviceExtension->Interface[0] = USBDIAG_ExAllocatePool(NonPagedPool,
                                                                       interfaceObject->Length);

                        if (deviceExtension->Interface[0]) {
                            // Save a copy of the interfaceObject information returned
                            RtlCopyMemory(deviceExtension->Interface[0], interfaceObject, interfaceObject->Length);

                            // Dump the interfaceObject to the debugger
                            //USBDIAG_KdPrint(("USBDIAG.SYS: ---------\n")); 
                            //USBDIAG_KdPrint(("USBDIAG.SYS: NumberOfPipes 0x%x\n", deviceExtension->Interface[0]->NumberOfPipes));
                            //USBDIAG_KdPrint(("USBDIAG.SYS: Length 0x%x\n", deviceExtension->Interface[0]->Length));  
                            //USBDIAG_KdPrint(("USBDIAG.SYS: Alt Setting 0x%x\n", deviceExtension->Interface[0]->AlternateSetting));  
                            //USBDIAG_KdPrint(("USBDIAG.SYS: Interface Number 0x%x\n", deviceExtension->Interface[0]->InterfaceNumber)); 

                            // Dump the pipe info
                            for (j=0; j<interfaceObject->NumberOfPipes; j++) {
                                PUSBD_PIPE_INFORMATION pipeInformation;

                                pipeInformation = &(deviceExtension->Interface[0]->Pipes[j]);

                                //USBDIAG_KdPrint(("USBDIAG.SYS: ---------\n")); 
                                //USBDIAG_KdPrint(("USBDIAG.SYS: PipeType 0x%x\n", pipeInformation->PipeType));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: EndpointAddress 0x%x\n", pipeInformation->EndpointAddress));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: MaxPacketSize 0x%x\n", pipeInformation->MaximumPacketSize));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Interval 0x%x\n", pipeInformation->Interval));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Handle 0x%x\n", pipeInformation->PipeHandle));      
                                //USBDIAG_KdPrint(("USBDIAG.SYS: MaximumTransferSize 0x%x\n", pipeInformation->MaximumTransferSize));

                                // Set the user's pipe context information structure
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Setting PipeNum: %d\n",j));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: Setting PipeType: %d\n",pipeInformation->PipeType));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: &PipeNum: %#X\n", &(REQSetDeviceConfig->Contxt[j].PipeNum) ));
                                //USBDIAG_KdPrint(("USBDIAG.SYS: &PipeType: %#X\n",&(REQSetDeviceConfig->Contxt[j].PipeType) ));

                                REQSetDeviceConfig->Contxt[j].PipeNum   = j;
                                REQSetDeviceConfig->Contxt[j].PipeType  = pipeInformation->PipeType;
                                
                            }/* for all the pipes in this interface */

                            //USBDIAG_KdPrint(("USBDIAG.SYS: ---------\n"));                     
                        
                        } /*If ExAllocate passed */

                   
                    }/* if selectconfiguration request was successful */            

                            //Fill in the user mode app's status field
                            Ch9FillInReqStatus (ntStatus, urb->UrbSelectConfiguration.Hdr.Status, 
                                                ((struct _REQ_HEADER * ) REQSetDeviceConfig) );

                } /* if urb create successful */
                else 
                {

                        //USBDIAG_KdPrint(("USBDIAG.SYS: Sample_SelectInterfaces FAILED creating Urb for selecting interface\n"));

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;        

                }/* Failed creating mem for urb  */        

        } /* if there was a valid interfacedesc */
        else 
        {
                ntStatus = STATUS_INVALID_PARAMETER;
        }//else error in interfacedesc
        
    }//if Interface given to this func was NULL (ie., we are the configuring driver)

    //USBDIAG_KdPrint(("USBDIAG.SYS: exit Sample_SelectInterfaces (ntSt: %x)\n", ntStatus));

    return ntStatus;

}/* Sample_SelectInterfaces */



VOID 
Ch9FillInReqStatus (
    IN      NTSTATUS                ntStatusCode,
    IN      ULONG                   ulUrbStatus,
    IN OUT  struct _REQ_HEADER *    REQHeader //This should be the SystemBuffer (ioBuffer)
    )
{
    
    // Put the status code in the Chapter 9 structure so that the app can
    // finger out what happened
    switch (ntStatusCode) 
    {
        case (STATUS_SUCCESS): 
            //Success 
            //USBDIAG_KdPrint(("USBDIAG.SYS: Status Success received\n"));
            REQHeader->Status = CH9_STATUS_SUCCESS;
            break;

        case (STATUS_CANCELLED):
            //Irp was cancelled, and we assume it was due to a nonresponsive device
            //USBDIAG_KdPrint(("USBDIAG.SYS: Status Cancelled received\n"));
            REQHeader->Status = CH9_STATUS_DEVICE_NOT_RESPONDING;
            break; //Status_Cancelled

        default:
            // if you got here the irp was not successful, so look at the Urb status
            // that was saved and see if that can be mapped to something the app 
            // understands
            switch (ulUrbStatus | 0xC0000000) {
                case USBD_STATUS_CRC:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus CRC Failure\n"));
                    REQHeader->Status = CH9_STATUS_CRC_ERROR;
                    break;

                case USBD_STATUS_STALL_PID:
                case USBD_STATUS_ENDPOINT_HALTED:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus EP Stalled\n"));
                    REQHeader->Status = CH9_STATUS_ENDPOINT_STALLED;
                    break;

                case USBD_STATUS_BTSTUFF:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus USBD_STATUS_BTSTUFF\n"));
                    REQHeader->Status = CH9_STATUS_BITSTUFF_ERROR;
                    break;

                case USBD_STATUS_DATA_TOGGLE_MISMATCH:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus USBD_STATUS_DATA_TOGGLE_MISMATCH\n"));
                    REQHeader->Status = CH9_STATUS_DATA_TOGGLE_ERROR;
                    break;

                case USBD_STATUS_DEV_NOT_RESPONDING:
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus USBD_STATUS_DEV_NOT_RESPONDING\n"));
                    REQHeader->Status = CH9_STATUS_DEVICE_NOT_RESPONDING;
                    break;

                default:
                    REQHeader->Status = CH9_STATUS_DEVICE_ERROR; //put a generic one in here for now
                    //USBDIAG_KdPrint(("USBDIAG.SYS: UrbStatus Other Device Failure\n"));
                    break;
            }//switch ulUrbStatus

    }//switch ntStatus
    
    return;
    
}//FillInReqStatus


//#if 0
VOID
USBDIAG_IoCancelRoutine (
                PDEVICE_OBJECT DeviceObject,
                PIRP               Irp
)
/* ++
-- */
{
        //USBDIAG_KdPrint(("USBDIAG.SYS: In USBDIAG_IoCancelRoutine %x %x\n",DeviceObject,Irp));
        TRAP();
        return;
        
}//USBDIAG_IoCancelRoutine
//#endif

NTSTATUS
USBDIAG_IoGenericCompletionRoutine (
        PDEVICE_OBJECT DeviceObject,
        PIRP Irp,
        PVOID context
)
{
    PCOMPLETION_CONTEXT Context             = (PCOMPLETION_CONTEXT)context;
    PDEVICE_OBJECT      actualDeviceObject  = Context->DeviceObject;
    PDEVICE_EXTENSION   deviceExtension     = actualDeviceObject->DeviceExtension;
    PIRP                irp                 = Context->Irp;

    //USBDIAG_KdPrint(("USBDIAG.SYS: In USBDIAG_IoGenericCompletionRoutine %x %x\n",DeviceObject,Irp));
    //TRAP();

    // remove the irp from the irp list
    USBDIAG_ClearSavedIrp(deviceExtension, irp);

    if (irp->Cancel) // cancel all irps is the only one to set this bit
    {
        //USBDIAG_KdPrint(("CompletionRoutine: irp->Cancel bit set\n"));
        KeSetEvent(&deviceExtension->CancelEvent, 
                   1,       
                   FALSE); 
    }

    //USBDIAG_KdPrint(("USBDIAG.SYS: Setting DoneEvent\n"));

//    KeSetEvent(&Context->DoneEvent, 
//               1, 
//               FALSE); // ditto with the priority
                        
      return STATUS_SUCCESS;
//    return STATUS_MORE_PROCESSING_REQUIRED;
}




NTSTATUS
USBDIAG_WaitWakeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PCOMPLETION_CONTEXT CompletionContext = (PCOMPLETION_CONTEXT)Context;
    PDEVICE_OBJECT      deviceObject    = CompletionContext->DeviceObject;
    PDEVICE_EXTENSION   deviceExtension = deviceObject->DeviceExtension;

    POWER_STATE         powerState;
    POWER_STATE_TYPE    Type            = DevicePowerState;
    POWER_STATE         State;

    NTSTATUS            ntStatus        = STATUS_SUCCESS;

    USBDIAG_KdPrint(("'Entering USBDIAG_WaitWakeCompletionRoutine\n"));

    if (Irp->Cancel)
    {
        USBDIAG_KdPrint(("'Cancel Bit Set.  Calling USBDIAG_WaitWakeCancelRoutine\n"));
        USBDIAG_WaitWakeCancelRoutine(deviceObject, Irp);
        return STATUS_CANCELLED;
    }
    else
    {
        deviceExtension->WaitWakeIrp = NULL;

        State.DeviceState = PowerDeviceD0;

        powerState  = PoSetPowerState(deviceObject, Type, State);
        IoSetCancelRoutine(Irp, NULL);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        ntStatus = Irp->IoStatus.Status;
        KeSetEvent(&CompletionContext->DoneEvent, 1, FALSE);
    }
    return ntStatus;
}


VOID
USBDIAG_WaitWakeCancelRoutine
(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;

    USBDIAG_KdPrint(("'Entering USBDIAG_WaitWakeCancelRoutine\n"));

    IoSetCancelRoutine(Irp, NULL);
    IoReleaseCancelSpinLock(Irp->CancelIrql);
    // reset any relevant flags here
    deviceExtension->WaitWakeIrp = NULL;

    Irp->IoStatus.Status = STATUS_CANCELLED;
}




NTSTATUS
USBDIAG_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_OBJECT      deviceObject    = (PDEVICE_OBJECT)Context;
    PDEVICE_EXTENSION   deviceExtension = deviceObject->DeviceExtension;
    PIRP                irp             = deviceExtension->PowerIrp;
    NTSTATUS            ntStatus;

    ntStatus = IoStatus->Status;

    //USBDIAG_KdPrint(("***USBDIAG.SYS: USBDIAG_PoRequestCompletion\n"));

    IoCopyCurrentIrpStackLocationToNext(irp);      
    PoStartNextPowerIrp(irp);
    PoCallDriver(deviceExtension->PhysicalDeviceObject, irp);   

    return ntStatus;
}




NTSTATUS
USBDIAG_SaveIrp(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP Irp
    )
{
    PIRPNODE    pNode       = USBDIAG_ExAllocatePool(NonPagedPool, sizeof(IRPNODE));
    KIRQL       Irql        = KeGetCurrentIrql();
    NTSTATUS    ntStatus    = STATUS_SUCCESS;

    //USBDIAG_KdPrint(("USBDIAG_SaveIrp: Irql = 0x%x\n", Irql));

    if (!pNode)
        return STATUS_INSUFFICIENT_RESOURCES;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &Irql);

    pNode->Irp = Irp;
    InsertHeadList(&deviceExtension->ListHead, (PLIST_ENTRY)pNode);

    KeReleaseSpinLock(&deviceExtension->SpinLock, Irql);

    return ntStatus;
}

NTSTATUS
USBDIAG_ClearSavedIrp(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP Irp
    )
{
    NTSTATUS    ntStatus        = STATUS_UNSUCCESSFUL; // assume initially it won't be found
    PIRPNODE    pNode           = NULL;
    KIRQL       Irql            = KeGetCurrentIrql();
    BOOLEAN     fContinue       = TRUE;
    PIRPNODE    pFirstNodeSeen  = NULL;

    USBDIAG_KdPrint(("'USBDIAG_ClearSavedIrp: Searching for Irp 0x%x at Irql 0x%x...\n", 
                     Irp,
                     Irql));

    KeAcquireSpinLock(&deviceExtension->SpinLock, &Irql);

    if (IsListEmpty(&deviceExtension->ListHead))
    {
        ntStatus = STATUS_INVALID_PARAMETER;
    }
    else
    {
        while (fContinue)
        {
            pNode = (PIRPNODE)RemoveHeadList(&deviceExtension->ListHead);

            if (pNode == pFirstNodeSeen) // back at original head of list -> stop
            {
                fContinue = FALSE;
                InsertHeadList(&deviceExtension->ListHead, (PLIST_ENTRY)pNode);
            }
            else if (pNode->Irp == Irp)
            {
                if (Irp == deviceExtension->InterruptIrp)
                {
                    USBDIAG_KdPrint(("'Interrupt complete (0x%x) - clearing from list\n", Irp));
                    deviceExtension->InterruptIrp = NULL;
                }
                fContinue = FALSE;
                ntStatus = STATUS_SUCCESS;

                USBDIAG_ExFreePool(pNode);
            }
            else // not head, put at end of list
            {
                if (!pFirstNodeSeen)
                    pFirstNodeSeen = pNode;

                InsertTailList(&deviceExtension->ListHead, (PLIST_ENTRY)pNode);
            }
        }
    }
    KeReleaseSpinLock(&deviceExtension->SpinLock, Irql);

    return ntStatus;
}



NTSTATUS
USBDIAG_CancelAllIrps(
    PDEVICE_EXTENSION deviceExtension
    )
{
    NTSTATUS    ntStatus    = STATUS_SUCCESS;
    BOOLEAN     bCancelled  = FALSE;
    KIRQL       Irql        = KeGetCurrentIrql();
    //KIRQL       RaisedIrql  = DISPATCH_LEVEL;
    PIRPNODE    pNode       = NULL;
            
    ASSERT (deviceExtension);

    USBDIAG_KdPrint(("'USBDIAG_CancelAllIrps: Entering\n"));

    KeAcquireSpinLock(&deviceExtension->SpinLock, &Irql);

    while (!IsListEmpty(&deviceExtension->ListHead))
    {
        // get the head, cancel it, and put it back
        pNode = (PIRPNODE)RemoveHeadList(&deviceExtension->ListHead);
            bCancelled = IoCancelIrp(pNode->Irp);
        InsertHeadList(&deviceExtension->ListHead, (PLIST_ENTRY)pNode);

        KeReleaseSpinLock(&deviceExtension->SpinLock, Irql);

                if (!bCancelled) 
                {
                        USBDIAG_KdPrint(("USBDIAG.SYS: CancelIrp FAILED (Irp=%X | returned value=%X)\n", 
                              pNode->Irp,
                              bCancelled));
            // return this if not all irps were successfully cancelled
            ntStatus = STATUS_UNSUCCESSFUL; 
                }
        else
                {
                        //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully Cancelled Irp (%X)\n", pNode->Irp));

            // Sleep to let the irps clean themselves up
            USBDIAG_KdPrint(("'Going to sleep in cancel routine\n"));


            KeWaitForSingleObject(&deviceExtension->CancelEvent, 
                                  Suspended, 
                                  KernelMode, 
                                  FALSE, 
                                  NULL);
            USBDIAG_KdPrint(("'Waking up in cancel routine\n"));
                }
        KeAcquireSpinLock(&deviceExtension->SpinLock, &Irql);
    }
    KeReleaseSpinLock(&deviceExtension->SpinLock, Irql);

    USBDIAG_KdPrint(("'USBDIAG_CancelAllIrps: Exiting\n"));

    return ntStatus;
}



NTSTATUS
USBDIAG_IssueWaitWake(
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS ntStatus;
    POWER_STATE powerState;

    USBDIAG_KdPrint(("'*********************************\n"));
    USBDIAG_KdPrint(("'USBDIAG_IssueWaitWake: Entering\n"));
    USBDIAG_KdPrint(("'Issue Wait/Wake for Device Object 0x%x, extension 0x%x\n",
                     DeviceObject,
                     deviceExtension));
    if (deviceExtension->WaitWakeIrp != NULL) 
    {
        USBDIAG_KdPrint(("'Wait wake all ready active!\n"));
        return STATUS_INVALID_DEVICE_STATE;
    }
    powerState.SystemState = deviceExtension->DeviceCapabilities.DeviceWake;

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_WAIT_WAKE,
                                 powerState, 
                                 USBDIAG_RequestWaitWakeCompletion, 
                                 DeviceObject, 
                                 &deviceExtension->WaitWakeIrp);

    if (!deviceExtension->WaitWakeIrp)
    {
        USBDIAG_KdPrint(("'Wait wake is NULL!\n"));
        return STATUS_UNSUCCESSFUL;
    }

    USBDIAG_KdPrint(("'USBDIAG_IssueWaitWake: exiting with ntStatus 0x%x (wait wake is 0x%x)\n",
                    ntStatus, 
                    deviceExtension->WaitWakeIrp));
    return ntStatus;
}



// **************************************************************************
// Completion routine for irp generated by PoRequestPowerIrp in USBDIAG_IssueWaitWake
NTSTATUS
USBDIAG_RequestWaitWakeCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PDEVICE_OBJECT      deviceObject    = Context;
    PDEVICE_EXTENSION   deviceExtension = deviceObject->DeviceExtension;
    POWER_STATE         powerState;
    //POWER_STATE_TYPE    Type            = DevicePowerState;
    POWER_STATE         State;
    NTSTATUS            ntStatus        = STATUS_SUCCESS;

    USBDIAG_KdPrint(("'#########################################\n"));
    USBDIAG_KdPrint(("'### USBDIAG_RequestWaitWakeCompletion ###\n"));
    USBDIAG_KdPrint(("'#########################################\n"));
    USBDIAG_KdPrint(("'Received Wait/Wake completion for Device Object 0x%x (0x%x) extension 0x%x\n",
                      deviceObject,
                      DeviceObject,
                      deviceExtension));

    State.DeviceState = PowerDeviceD0;

    ntStatus = IoStatus->Status;
    deviceExtension->WaitWakeIrp = NULL;

    USBDIAG_KdPrint(("'USBDIAG_RequestWaitWakeCompletion: Wake irp completed status 0x%x\n", ntStatus));

    //DbgPrint("Wait/Wake completed with status 0x%x\n", ntStatus);

    switch (ntStatus) 
    {
    case STATUS_SUCCESS:
        USBDIAG_KdPrint(("'USBDIAG_RequestWaitWakeCompletion: Wake irp completed succefully.\n"));

        // There are 3 cases in which we will cancel the wait wake IRP
        // 1)  We are going to an S state where we can't wake the machine.  We will
        //     resend the irp when we transition back to S0
        // 2)  We get a stop.  We will resend the irp if we get another start
        // 3)  We get a remove.  We will not (obviously) send another wait wake
        ntStatus = USBDIAG_SetDevicePowerState(deviceObject, PowerDeviceD0);

        break;
    case STATUS_CANCELLED:
        USBDIAG_KdPrint(("'USBDIAG_RequestWaitWakeCompletion: Wake irp cancelled\n"));
//    case STATUS_ACPI_POWER_REQUEST_FAILED:
//    case STATUS_POWER_STATE_INVALID:
        break;
    default:
        break;
    }


    USBDIAG_KdPrint(("'Setting WaitWakeEvent\n"));
    KeSetEvent(&deviceExtension->WaitWakeEvent, IO_NO_INCREMENT, FALSE);
    
    return ntStatus;
}



NTSTATUS
USBDIAG_PoSelfRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PDEVICE_OBJECT deviceObject = Context;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    NTSTATUS ntStatus = IoStatus->Status;


    // We only need to set the event if we're powering up;
    // No caller waits on power down complete
    if (deviceExtension->CurrentDeviceState.DeviceState > PowerState.DeviceState)
    {
        // Trigger Self-requested power irp completed event;
        //  The caller is waiting for completion
        KeSetEvent(deviceExtension->SelfRequestedPowerIrpEvent, 1, FALSE);
    }
    USBDIAG_KdPrint(("'USBDIAG_PoSelfRequestCompletion:\n"));// Setting deviceExtension->PowerState.DeviceState\n"));
    //deviceExtension->PowerState.DeviceState = PowerState.DeviceState;


    USBDIAG_KdPrint(("'Exiting USBDIAG_PoSelfRequestCompletion\n"));
  
    return ntStatus;
}


NTSTATUS
USBDIAG_PowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    // Set the input event
    KeSetEvent(event,
               1,       // Priority increment  for waiting thread.
               FALSE);  // Flag this call is not immediately followed by wait.

    // This routine must return STATUS_MORE_PROCESSING_REQUIRED because we have not yet called
    // IoFreeIrp() on this IRP.
    return STATUS_MORE_PROCESSING_REQUIRED;
}


#define DRIVER

#pragma warning(disable:4214) //  bitfield nonstd
#include "wdm.h"
#pragma warning(default:4214) 

#include "stdarg.h"
#include "stdio.h"


#pragma warning(disable:4200) //non std struct used
#include "usbdi.h"
#pragma warning(default:4200)

#include "usbdlib.h"
#include "ioctl.h"
#include "USBDIAG.h"

UCHAR *SystemPowerStateString[] = {
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

UCHAR *DevicePowerStateString[] = {
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
};



NTSTATUS
USBDIAG_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
{
    PDEVICE_EXTENSION  deviceExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack        = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS ntStatus = STATUS_SUCCESS;
    BOOLEAN fGoingToD0 = FALSE;
    POWER_STATE sysPowerState, desiredDevicePowerState;
    KEVENT event;

    USBDIAG_KdPrint(("'=======================================================================\n"));
    USBDIAG_KdPrint(("'USBDIAG_Power() IRP_MJ_POWER\n"));

    switch (irpStack->MinorFunction) 
    {
    case IRP_MN_WAIT_WAKE:

        USBDIAG_KdPrint(("'==========================================\n"));
        USBDIAG_KdPrint(("'USBDIAG_Power() Enter IRP_MN_WAIT_WAKE --\n"));
        // The only way this comes through us is if we send it via PoRequestPowerIrp
        IoSkipCurrentIrpStackLocation(Irp);                  // not attaching a completion routine
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);
        break;

    case IRP_MN_SET_POWER:

                // The system power policy manager sends this IRP to set the system power state. 
                // A device power policy manager sends this IRP to set the device power state for a device.

        USBDIAG_KdPrint(("'==========================================\n"));
        USBDIAG_KdPrint(("'USBDIAG_Power() Enter IRP_MN_SET_POWER\n"));

        // Set Irp->IoStatus.Status to STATUS_SUCCESS to indicate that the device
        // has entered the requested state. Drivers cannot fail this IRP.

        switch (irpStack->Parameters.Power.Type) 
        {
        case SystemPowerState:

            // Get input system power state
            sysPowerState.SystemState = irpStack->Parameters.Power.State.SystemState;

            USBDIAG_KdPrint(("'USBDIAG_Power() Set Power, type SystemPowerState = %s\n",
                            SystemPowerStateString[sysPowerState.SystemState] ));

            // If system is in working state always set our device to D0
            //  regardless of the wait state or system-to-device state power map
            if ( sysPowerState.SystemState ==  PowerSystemWorking) 
            {
                desiredDevicePowerState.DeviceState = PowerDeviceD0;
                 USBDIAG_KdPrint(("'USBDIAG_Power() PowerSystemWorking, will set D0, not use state map\n"));
            } 
            else 
            {
                 // set to corresponding system state if IRP_MN_WAIT_WAKE pending
                if ( deviceExtension->WaitWakeIrp ) // got a WAIT_WAKE IRP pending?
                { 
                    // Find the device power state equivalent to the given system state.
                    // We get this info from the DEVICE_CAPABILITIES struct in our device
                    // extension (initialized in USBDIAG_PnPAddDevice() )
                    desiredDevicePowerState.DeviceState =
                        deviceExtension->DeviceCapabilities.DeviceState[ sysPowerState.SystemState ];

                    USBDIAG_KdPrint(("'USBDIAG_Power() IRP_MN_WAIT_WAKE pending, will use state map\n"));
                } 
                else 
                {  
                    // if no wait pending and the system's not in working state, just turn off
                    desiredDevicePowerState.DeviceState = PowerDeviceD3;

                    USBDIAG_KdPrint(("'USBDIAG_Power() Not EnabledForWakeup and the system's not in working state,\n  settting PowerDeviceD3 (off )\n"));
                }
            }
            //
            // We've determined the desired device state; are we already in this state?
            //
            USBDIAG_KdPrint(("'USBDIAG_Power() Set Power, desiredDevicePowerState = %s\n",
                DevicePowerStateString[desiredDevicePowerState.DeviceState]));

            if (desiredDevicePowerState.DeviceState != deviceExtension->CurrentDeviceState.DeviceState) 
            {
                // No, request that we be put into this state
                                // by requesting a new Power Irp from the Pnp manager
                deviceExtension->PowerIrp = Irp;
                ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject,
                                             IRP_MN_SET_POWER,
                                             desiredDevicePowerState,
                                             // completion routine will pass the Irp down to the PDO
                                             USBDIAG_PoRequestCompletion, 
                                             DeviceObject,
                                             NULL);
            } 
            else 
            {
                // Yes, just pass it on to PDO (Physical Device Object)
                IoCopyCurrentIrpStackLocationToNext(Irp);
                PoStartNextPowerIrp(Irp);
                ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);

                USBDIAG_KdPrint(("'USBDIAG_Power() Exit IRP_MN_SET_POWER\n"));
            }
            break;

        case DevicePowerState:

            USBDIAG_KdPrint(("'USBDIAG_Power() Set Power, type DevicePowerState = %s\n",
                DevicePowerStateString[irpStack->Parameters.Power.State.DeviceState]));

            // For requests to D1, D2, or D3 ( sleep or off states ),
                        // sets deviceExtension->CurrentDeviceState to DeviceState immediately.
                        // This enables any code checking state to consider us as sleeping or off
                        // already, as this will imminently become our state.

            // For requests to DeviceState D0 ( fully on ), sets fGoingToD0 flag TRUE
            // to flag that we must set a completion routine and update
                        // deviceExtension->CurrentDeviceState there.
                        // In the case of powering up to fully on, we really want to make sure
                        // the process is completed before updating our CurrentDeviceState,
                        // so no IO will be attempted or accepted before we're really ready.

            fGoingToD0 = (BOOLEAN)(irpStack->Parameters.Power.State.DeviceState == PowerDeviceD0);

            IoCopyCurrentIrpStackLocationToNext(Irp);

            if (fGoingToD0) {
                USBDIAG_KdPrint(("'USBDIAG_Power() Set PowerIrp Completion Routine, fGoingToD0 =%d\n", fGoingToD0));
                IoSetCompletionRoutine(Irp,
                       USBDIAG_PowerIrp_Complete,
                       // Always pass FDO to completion routine as its Context;
                       // This is because the DriverObject passed by the system to the routine
                       // is the Physical Device Object ( PDO ) not the Functional Device Object ( FDO )
                       DeviceObject,
                       TRUE,            // invoke on success
                       TRUE,            // invoke on error
                       TRUE);           // invoke on cancellation of the Irp
            }

            PoStartNextPowerIrp(Irp);
            ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                    Irp);

            USBDIAG_KdPrint(("'USBDIAG_Power() Exit IRP_MN_SET_POWER\n"));
            break;
        } /* case irpStack->Parameters.Power.Type */
        break; /* IRP_MN_SET_POWER */

    case IRP_MN_QUERY_POWER:
                //
                // A power policy manager sends this IRP to determine whether it can change
                // the system or device power state, typically to go to sleep.
                //

        USBDIAG_KdPrint(("'==========================================\n"));
        USBDIAG_KdPrint(("'USBDIAG_Power() IRP_MN_QUERY_POWER\n"));

        // We do nothing special here, just let the PDO handle it
        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);


        break; /* IRP_MN_QUERY_POWER */

    default:

        USBDIAG_KdPrint(("'==========================================\n"));
        USBDIAG_KdPrint(("'USBDIAG_Power() UNKNOWN POWER MESSAGE (%x)\n", irpStack->MinorFunction));

        //
        // All unhandled power messages are passed on to the PDO
        //

        IoCopyCurrentIrpStackLocationToNext(Irp);
        PoStartNextPowerIrp(Irp);
        ntStatus = PoCallDriver(deviceExtension->StackDeviceObject, Irp);

    } 

    USBDIAG_KdPrint(("'Exit USBDIAG_Power()  ntStatus = 0x%x\n", ntStatus ) );
    return ntStatus;
}







NTSTATUS
USBDIAG_SetDevicePowerState(
    IN PDEVICE_OBJECT   DeviceObject,
    IN ULONG            ulPowerState
    )
{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS            ntStatus        = STATUS_SUCCESS;
    POWER_STATE         PowerState;

    PowerState.DeviceState = (DEVICE_POWER_STATE)ulPowerState;

    deviceExtension->SelfRequestedPowerIrpEvent = ExAllocatePool(NonPagedPool, sizeof(KEVENT));

    if (!deviceExtension->SelfRequestedPowerIrpEvent)
        return STATUS_INSUFFICIENT_RESOURCES;

    KeInitializeEvent(deviceExtension->SelfRequestedPowerIrpEvent, NotificationEvent, FALSE);

    ntStatus = PoRequestPowerIrp(deviceExtension->PhysicalDeviceObject, 
                                 IRP_MN_SET_POWER,
                                 PowerState,
                                 USBDIAG_PoSelfRequestCompletion,
                                 DeviceObject,
                                 NULL);

    if  ( ntStatus == STATUS_PENDING ) 
    { 
        // We only need to wait for completion if we're powering up
        if ( deviceExtension->CurrentDeviceState.DeviceState > PowerState.DeviceState ) 
        {
            NTSTATUS waitStatus;

            waitStatus = KeWaitForSingleObject(
                           deviceExtension->SelfRequestedPowerIrpEvent,
                           Suspended,
                           KernelMode,
                           FALSE,
                           NULL);
            ExFreePool(deviceExtension->SelfRequestedPowerIrpEvent);
            deviceExtension->SelfRequestedPowerIrpEvent = NULL;
        }
    }

    deviceExtension->CurrentDeviceState.DeviceState = PowerState.DeviceState;
    USBDIAG_KdPrint(("'CurrentDeviceState set to 0x%x\n",deviceExtension->CurrentDeviceState.DeviceState));
    ntStatus = STATUS_SUCCESS;

    return ntStatus;
}




NTSTATUS
USBDIAG_PowerIrp_Complete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when An IRP_MN_SET_POWER of type 'DevicePowerState'
    has been received by USBDIAG_ProcessPowerIrp(), and that routine has  determined
        1) the request is for full powerup ( to PowerDeviceD0 ), and
        2) We are not already in that state
    A call is then made to PoRequestPowerIrp() with this routine set as the completion routine.


Arguments:

    DeviceObject - Pointer to the device object for the class device.

    Irp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PDEVICE_OBJECT deviceObject       = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;

    USBDIAG_KdPrint(("'enter USBDIAG_PowerIrp_Complete\n"));

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) 
    {
        IoMarkIrpPending(Irp);
    }
    irpStack = IoGetCurrentIrpStackLocation (Irp);
    // We can assert that we're a  device powerup-to D0 request,
    // because that was the only type of request we set a completion routine
    // for in the first place
    ASSERT(irpStack->MajorFunction == IRP_MJ_POWER);
    ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
    ASSERT(irpStack->Parameters.Power.Type==DevicePowerState);
    ASSERT(irpStack->Parameters.Power.State.DeviceState==PowerDeviceD0);

    // Now that we know we've let the lower drivers do what was needed to power up,
    //  we can set our device extension flags accordingly
    deviceExtension->CurrentDeviceState.DeviceState = PowerDeviceD0;

    Irp->IoStatus.Status = ntStatus;

    USBDIAG_KdPrint(("'exit USBDIAG_PowerIrp_Complete Exit IRP_MN_SET_POWER D0 complete\n"));
    return ntStatus;
}
#if 0
NTSTATUS
ISOPERF_ResetPipe(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE_INFORMATION Pipe,
    IN BOOLEAN IsoClearStall
    )
/*++

Routine Description:

    Reset a given USB pipe.
    
    NOTES:

    This will reset the host to Data0 and should also reset the device
    to Data0 for Bulk and Interrupt pipes.

    For Iso pipes this will set the virgin state of pipe so that ASAP
    transfers begin with the current bus frame instead of the next frame
    after the last transfer occurred.

Arguments:

Return Value:


--*/
{
    NTSTATUS ntStatus;
    PURB urb;

    ISOPERF_KdPrint ( DBGLVL_MEDIUM, (" Reset Pipe %x\n", Pipe));

    urb = ExAllocatePool(NonPagedPool,
                         sizeof(struct _URB_PIPE_REQUEST));

    if (urb) {

        urb->UrbHeader.Length = (USHORT) sizeof (struct _URB_PIPE_REQUEST);
        urb->UrbHeader.Function = URB_FUNCTION_RESET_PIPE;
        urb->UrbPipeRequest.PipeHandle =
            Pipe->PipeHandle;

        ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

        ExFreePool(urb);

    } else {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Memphis RESET_PIPE will send a Clear-Feature Endpoint Stall to
    // reset the data toggle of non-Iso pipes as part of a RESET_PIPE
    // request.  It does not do this for Iso pipes as Iso pipes do not use
    // the data toggle (all Iso packets are Data0).  However, we also use
    // the Clear-Feature Endpoint Stall request in our device firmware to
    // reset data buffer points inside the device so we explicitly send
    // this request to the device for Iso pipes if desired.
    //
    if (NT_SUCCESS(ntStatus) && IsoClearStall &&
        (Pipe->PipeType == UsbdPipeTypeIsochronous)) {
        
        urb = ExAllocatePool(NonPagedPool,
                             sizeof(struct _URB_CONTROL_FEATURE_REQUEST));

        if (urb) 
                {
            UsbBuildFeatureRequest(urb,
                                   URB_FUNCTION_CLEAR_FEATURE_TO_ENDPOINT,
                                   USB_FEATURE_ENDPOINT_STALL,
                                   Pipe->EndpointAddress,
                                   NULL);

            ntStatus = ISOPERF_CallUSBD(DeviceObject, urb);

            ExFreePool(urb);
        } 
                else 
                {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
}
#endif

NTSTATUS
USBDIAG_DisableRemoteWakeupEnable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN bDisable
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS ntStatus;

    WCHAR KeyName[] = L"DisableRemoteWakeup";
    ULONG KeyNameLength = sizeof(KeyName);
    PVOID Data = ExAllocatePool(NonPagedPool, sizeof(ULONG));
    ULONG DataLength = sizeof(ULONG);
    ULONG KeyType = REG_DWORD;

    if (Data)
    {
        *((PULONG)Data) = bDisable ? 0x01 : 0x00;

        USBDIAG_KdPrint(("'calling USBD_SetPdoRegistryParameter with Data = 0x%x\n", *((PULONG)Data)));

        ntStatus = USBD_SetPdoRegistryParameter(deviceExtension->PhysicalDeviceObject,
                                                KeyName,
                                                KeyNameLength,
                                                Data,
                                                DataLength,
                                                KeyType,
                                                PLUGPLAY_REGKEY_DRIVER);
        USBDIAG_KdPrint(("'USBD_SetPdoRegistryParameter returned ntStatus 0x%x\n", ntStatus));

        ExFreePool(Data);
        Data = NULL;
    }
    else
    {
        ntStatus = STATUS_NO_MEMORY;
    }
    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\chap11.h ===
#define REQ_FUNCTION_HUB_READCHANGEPIPE                 0x000B

// raw packet can be used for sending a USB setup 
// packet down to the device from the app.
#define REQ_FUNCTION_ORAW_PACKET                        0x00F1

struct _REQ_READ_HUBCHANGEPIPE {
  struct _REQ_HEADER Hdr;
  PVOID     pvBuffer;
};



struct _REQ_SEND_ORAWPACKET {
  struct _REQ_HEADER Hdr;
  PVOID     pvBuffer;
  USHORT    wIndex;
  USHORT    wLength;
  USHORT    wValue;
  UCHAR     bmRequestType;
  UCHAR     bRequest;
}; 

/*
struct _REQ_SEND_ORAWPACKET {
  struct _REQ_HEADER Hdr;
  PVOID     pvBuffer;
  char		Setup[8] ;
};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\ioctl.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    ioctl.h

Abstract:

        

Environment:

    Kernel & user mode

Revision History:

    5-10-96 : created

--*/

#ifndef   __IOCTL_H__
#define   __IOCTL_H__

// make sure that USBDIAG ioctls do not get above 80 or they will
// collide with USBLOOP ioctls
#define USBDIAG_IOCTL_INDEX  0x0000


#define IOCTL_USBDIAG_CHAP9_GET_DEVHANDLE     CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  USBDIAG_IOCTL_INDEX,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_USBDIAG_CHAP9_CONTROL           CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  USBDIAG_IOCTL_INDEX+1,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_USBDIAG_HIDP_GETCOLLECTION      CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  USBDIAG_IOCTL_INDEX+2,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_USBDIAG_CONFIGURE_DEVICE        CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  USBDIAG_IOCTL_INDEX+3,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)

#define IOCTL_USBDIAG_GET_USBDI_VERSION       CTL_CODE(FILE_DEVICE_UNKNOWN,  \
                                                  USBDIAG_IOCTL_INDEX+4,\
                                                  METHOD_BUFFERED,  \
                                                  FILE_ANY_ACCESS)


#endif   // __IOCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\iso.h ===
// Kosar - insert code here


NTSTATUS 
USBLOOP_StartIsoTest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\opaque.h ===
#ifndef   __OPAQUE_H__
#define   __OPAQUE_H__

// ******************************************************************************
//
// information for each active pipe on a device 
//
typedef struct _USBD_PIPE {
    ULONG Sig;
    USB_ENDPOINT_DESCRIPTOR    EndpointDescriptor;
    PVOID HcdEndpoint;
    ULONG MaxTransferSize;
#if 1
    ULONG ScheduleOffset;
    ULONG UsbdPipeFlags;
#endif
} USBD_PIPE, *PUSBD_PIPE;

//
// information for each active interface
// for a device
//
typedef struct _USBD_INTERFACE {
    ULONG Sig;
    BOOLEAN HasAlternateSettings;
    UCHAR Pad[3];
    USB_INTERFACE_DESCRIPTOR InterfaceDescriptor;   // copy of interface descriptor
    // copy of interfaceInformation structure, stores user parameters
    // for interface in case of failure during alt-interface selection
    PUSBD_INTERFACE_INFORMATION InterfaceInformation; 
    USBD_PIPE PipeHandle[0];                        // array of pipe handle structures
} USBD_INTERFACE, *PUSBD_INTERFACE;

//
// informnation for the active configuration
// on a device
//
typedef struct _USBD_CONFIG {
    ULONG Sig;
    PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor;        
    PUSBD_INTERFACE InterfaceHandle[1];             // array of pointers to interface
} USBD_CONFIG, *PUSBD_CONFIG;

typedef struct _USBD_DEVICE_DATA {
    ULONG Sig;
    USHORT DeviceAddress;                    // address assigned to the device
    UCHAR Pad[2];
    PUSBD_CONFIG ConfigurationHandle;   
//   KTIMER TimeoutTimer;
//    KDPC TimeoutDpc;

    USBD_PIPE DefaultPipe;   
    USB_DEVICE_DESCRIPTOR DeviceDescriptor;  // a copy of the USB device descriptor        
    BOOLEAN LowSpeed;                        // TRUE if the device is low speed
    BOOLEAN AcceptingRequests;
} USBD_DEVICE_DATA, *PUSBD_DEVICE_DATA;


DECLSPEC_IMPORT
NTSTATUS
USBD_CreateDevice(
	IN OUT PUSBD_DEVICE_DATA *DeviceData,
	IN PDEVICE_OBJECT DeviceObject,
	IN BOOLEAN DeviceIsLowSpeed,
	IN ULONG MaxPacketSize_Endpoint0,
	IN OUT PULONG NonCompliantDevice
	);

DECLSPEC_IMPORT
NTSTATUS
USBD_InitializeDevice(
	IN PUSBD_DEVICE_DATA DeviceData,
	IN PDEVICE_OBJECT DeviceObject,
	IN OUT PUSB_DEVICE_DESCRIPTOR DeviceDescriptor,
	IN ULONG DeviceDescriptorLength,
	IN OUT PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor,
	IN ULONG ConfigDescriptorLength
	);	

DECLSPEC_IMPORT
NTSTATUS
USBD_RemoveDevice(
	IN PUSBD_DEVICE_DATA DeviceData,
	IN PDEVICE_OBJECT DeviceObject,
	IN UCHAR Flags
	);	
// END OF OPAQUE INFO ***********************************************************
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\ioctl.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

   ioctl.c

Abstract:

    USB device driver for Intel/Microsoft diagnostic apps 

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

     5-4-96 : created
    7-21-97 : Added Chapter 11 IOCTL's (t-toddca)

--*/

#define DRIVER
 

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

// Enable 1-byte alignment in structs
#pragma pack (push,1)
#include "usb100.h"
#include "usbdi.h"
#include "usbdlib.h"
#include "usbioctl.h"
#pragma pack (pop) //disable 1-byte alignment

#include "opaque.h"

// Enable 1-byte alignment in structs
#pragma pack (push,1)
#include "ioctl.h"
#include "chap9drv.h"
#include "USBDIAG.h"
#pragma pack (pop) //disable 1-byte alignment

extern USBD_VERSION_INFORMATION gVersionInformation;

NTSTATUS
USBDIAG_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - pointer to the device object for this instance of the 82930
                    devcice.
                    

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpStack;
    PVOID ioBuffer;
    ULONG inputBufferLength;
    ULONG outputBufferLength;
    PDEVICE_EXTENSION deviceExtension;
    ULONG ioControlCode;
    NTSTATUS ntStatus = STATUS_SUCCESS;
     
    USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MJ_DEVICE_CONTROL\n"));
    //
    // Get a pointer to the current location in the Irp. This is where
    //     the function codes and parameters are located.
    //

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the device extension
    //

    deviceExtension = DeviceObject->DeviceExtension;

    //USBDIAG_KdPrint(("USBDIAG.SYS: DeviceObj: %X | DeviceExt: %X\n",DeviceObject, DeviceObject->DeviceExtension));

    ioBuffer           = Irp->AssociatedIrp.SystemBuffer;
    inputBufferLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    outputBufferLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;
    
    USBDIAG_KdPrint(("USBDIAG.SYS: IOControlCode: %X\n", ioControlCode));

    // 
    // Handle Ioctls from User mode
    //

    switch (ioControlCode) {

    case IOCTL_USBDIAG_GET_USBDI_VERSION:
        {
            PULONG pulUSBDIVersion = (PULONG)ioBuffer;

            *pulUSBDIVersion = gVersionInformation.USBDI_Version;
            
            Irp->IoStatus.Status = ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(ULONG);                
        }
        break;

    case IOCTL_USBDIAG_CHAP9_GET_DEVHANDLE:

        {
        //
        // inputs  - ptr to _REQ_DEVICE_HANDLES structure
        //           with devicehandle set to the last handle 
        //           returned or NULL.
        
        // outputs - 
        //

        struct _REQ_DEVICE_HANDLES *reqDeviceHandles;
        PDEVICE_LIST_ENTRY device;
        PDEVICE_EXTENSION localDeviceExtension;
        PDEVICE_OBJECT deviceObject;

        //USBDIAG_KdPrint(("USBDIAG.SYS: IOCTL_USBDIAG_CHAP9_GET_DEVHANDLE\n"));

        // walk our list of PDOs and find the current one
        // if cuurent is NULL return the first PDO in our list
        // if current can not be found then return NULL for next_device

        reqDeviceHandles = ioBuffer;

        //
        // Check that the buffer length is of the appropriate size
        //

        if (inputBufferLength < sizeof(struct _REQ_DEVICE_HANDLES) ||
            outputBufferLength < sizeof(struct _REQ_DEVICE_HANDLES)) {

            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = STATUS_INVALID_BUFFER_SIZE;
            break;
        }

        device = deviceExtension->DeviceList;

        // should always have at least one
        if (device != NULL) 
        {
            if (reqDeviceHandles->DeviceHandle != NULL)
            {
                //
                // Searching for the next device in the list
                //

                while (device != NULL && device != reqDeviceHandles->DeviceHandle)
                {
                    device = device->Next;
                }

                //
                // Make device point to the next possible device in our list,
                //  if we haven't reached the end of the list
                //

                if (NULL != device) 
                {
                    device = device -> Next;
                }
            }

            //
            // At this point, device is either NULL or points to a usbdiag
            //  device.  However, the diag device may not yet be started and
            //  if so, should not be reported in this query so we must skip
            //  over it.  We will skip over all such devices in our list.
            //  Do that here.
            //

            while (device != NULL)
            {
                deviceObject = FDO_FROM_DEVICE_HANDLE(device);

                localDeviceExtension = deviceObject -> DeviceExtension;

                if (!(localDeviceExtension -> Stopped))
                {
                    //
                    // Found a legit started device, break out of this loop
                    //

                    break;
                }

                //
                // Oops, we've got a device but it hasn't been started yet, 
                //  don't return it in the query. Try the next one in the list.
                //
            
                device = device -> Next;
            }

            //
            // At this point, device is either NULL or points to a device that
            //  can be legitimately returned to the calling app.  If a legit
            //  device, then create a device string for it.
            //

            if (NULL != device) 
            {
                sprintf(reqDeviceHandles->DeviceString, 
                        "%2.2d Vid (0x%4.4x) Pid (0x%4.4x)",
                        device->DeviceNumber, 
                        localDeviceExtension->pDeviceDescriptor->idVendor, 
                        localDeviceExtension->pDeviceDescriptor->idProduct);            
            }
        }
        
        reqDeviceHandles -> NextDeviceHandle = device;
        Irp->IoStatus.Information = sizeof(struct _REQ_DEVICE_HANDLES);                
        Irp->IoStatus.Status = STATUS_SUCCESS;
        
        }
    
        break;

    case IOCTL_USBDIAG_CHAP9_CONTROL:

        //
        // inputs  -
        // outputs - 
        //
        //USBDIAG_KdPrint(("USBDIAG.SYS: IOCTL_USBDIAG_CHAP9_CONTROL\n"));

        ntStatus = USBDIAG_Chap9Control(DeviceObject, Irp);
        //USBDIAG_KdPrint(("USBDIAG.SYS: Done w/ IOCTL_USBDIAG_CHAP9_CONTROL\n"));
        
        goto USBDIAG_ProcessIOCTL_Done;
        
        break;        

    case IOCTL_USBDIAG_HIDP_GETCOLLECTION:
        
        /* 
        //  calls thru to the HID Parser
        //  NOTE: The function called will complete the IRP since it will 
        //        free the buffers created by the HID parser immediately
        //        thereafter, and since BUFFERED method is used, the IOS
        //        needs the buffers to be present while it's copying it
        //        back to the user space.  So, we jump to the end to avoid this.
        */
        //USBDIAG_KdPrint(("USBDIAG.SYS: IOCTL_USBDIAG_HIDP_GETCOLLECTION\n"));

        ntStatus = USBDIAG_HIDP_GetCollection (DeviceObject, Irp);
        break;

    case IOCTL_USBDIAG_CONFIGURE_DEVICE:

        /*
        //  Configures a given device in the given configuration 
        //  Input:  IOCTL block indicating what configuration to put
        //                      device into
        //  Output:     Success/error code
        //
        */
        //USBDIAG_KdPrint(("USBDIAG.SYS: IOCTL_USBDIAG_CONFIGURE_DEVICE\n"));

        ntStatus = USBDIAG_Configure_Device (DeviceObject, Irp);

        break;   


        default:                        
          Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;                      
    }  

    //USBDIAG_KdPrint(("USBDIAG.SYS: Chap9Ctrl Compltng Irp w/ IoStatus.Status=%X | .Inf = %X | ntSt=%X\n",
    //Irp->IoStatus.Status, Irp->IoStatus.Information, ntStatus));

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

USBDIAG_ProcessIOCTL_Done:

    return ntStatus;                       
        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\chap9drv.h ===
#ifndef   __CHAP9_H__
#define   __CHAP9_H__


//
// CHAP9_GETDEVHANDLE requires that the lpInBuffer parameter of the
// DeviceIOControl function points to a REQ_DEVICE_HANDLES structure.
//
// CHAP9_USB_CONTROL requires that the lpInBuffer parameter of the
// DeviceIOControl function points to a REQ structure.  The 'function'
// field of REQ_HEADER determines which union structure is actually
// passed.


// Structure for getting device handles.  DeviceHandle should be set to
// either NULL or a valid handle.  If it is set to NULL, then the driver
// should return the first USB device handle.  On return, the driver will
// set NextDeviceHandle to a valid handle for the next USB device.  If no
// more devices exist then the field is set to NULL.  The returned
// DeviceString should be some way that users can identify the device.
// Identification should include the Vendor ID and Product ID and some
// instance info.
//

struct _REQ_DEVICE_HANDLES {
  PVOID DeviceHandle;
  PVOID NextDeviceHandle;
  UCHAR  DeviceString[128];
};

//
// These functions are put in the function field of REQ_HEADER
//

#define REQ_FUNCTION_GET_DESCRIPTOR                     0x0001
#define REQ_FUNCTION_SET_DESCRIPTOR                     0x0002
#define REQ_FUNCTION_SET_FEATURE                        0x0003
#define REQ_FUNCTION_CLEAR_FEATURE                      0x0004
#define REQ_FUNCTION_GET_STATUS                         0x0005
// Functions below this line may not be implementable because the
// stacks dont support them.  Do we want to allow a special interface
// to let these happen??
#define REQ_FUNCTION_SET_ADDRESS                        0x0006
#define REQ_FUNCTION_GET_CONFIGURATION                  0x0007
#define REQ_FUNCTION_SET_CONFIGURATION                  0x0008
#define REQ_FUNCTION_GET_INTERFACE                      0x0009
#define REQ_FUNCTION_SET_INTERFACE                      0x000A
#define REQ_FUNCTION_GET_CHAP9VERSION                   0x000B


// raw packet can be used for sending a USB setup 
// packet down to the device from the app.
#define REQ_FUNCTION_RAW_PACKET                         0x00F0

// Function codes to read and write from a device's endpoints
#define REQ_FUNCTION_READ_FROM_PIPE                     0x01F1
#define REQ_FUNCTION_WRITE_TO_PIPE                      0x01F2

// Cancel transfers on a device
// Only the REQ_HEADER is needed for this FUNCTION
#define REQ_FUNCTION_CANCEL_TRANSFERS                                   0x01F3
#define REQ_FUNCTION_CANCEL_WAIT_WAKE                   0x01F4

// power ioctl's
#define REQ_FUNCTION_SET_DEVICE_POWER_STATE             0x02F0
#define REQ_FUNCTION_GET_DEVICE_POWER_STATE             0x02F1
#define REQ_FUNCTION_ISSUE_WAIT_WAKE                            0x02F2
#define REQ_FUNCTION_WAIT_FOR_WAKEUP                            0x02F3

// Chapter 11 IOCTL's
#define REQ_FUNCTION_CHAP11_CREATE_USBD_DEVICE              0x000F
#define REQ_FUNCTION_CHAP11_INIT_USBD_DEVICE                0x0010
#define REQ_FUNCTION_CHAP11_DESTROY_USBD_DEVICE             0x0011
#define REQ_FUNCTION_CHAP11_SEND_PACKET_DOWNSTREAM          0x0012
#define REQ_FUNCTION_CHAP11_GET_DOWNSTREAM_DESCRIPTOR   0x0013

#define REQ_FUNCTION_DISABLE_ENABLING_REMOTE_WAKEUP     0x0030
#define REQ_FUNCTION_ENABLE_ENABLING_REMOTE_WAKEUP      0x0031

#define REQ_FUNCTION_RESET_PARENT_PORT                  0x001F

#define REQ_FUNCTION_GET_DEVICE_STATE                   0x0020

//
// Chap9drv status codes.  Returned in status field of REQ_HEADER.
//                                                 Also returned if a GetLastError() is done.
//

#define CH9_STATUS_SUCCESS                              0x00000000
#define CH9_STATUS_PENDING                              0x00000001
#define CH9_STATUS_NO_MEMORY                            0x00000002
#define CH9_STATUS_BAD_COMMAND                          0x00000003
#define CH9_STATUS_BUSY                                 0x00000004
#define CH9_STATUS_INVALID_PARAMETER                    0x00000005
#define CH9_STATUS_ENDPOINT_STALLED                     0x00000006
#define CH9_STATUS_ABORTED                              0x00000007
#define CH9_STATUS_INVALID_DESCRIPTOR_INDEX             0x00000008
#define CH9_STATUS_DEVICE_NOT_RESPONDING                                                                0x00000009
#define CH9_STATUS_DEVICE_ERROR                         0x0000000A
#define CH9_STATUS_CRC_ERROR                            0x0000000B
#define CH9_STATUS_BITSTUFF_ERROR                       0x0000000C
#define CH9_STATUS_DATA_TOGGLE_ERROR                    0x0000000D

#define CH9_STATUS_ERROR_VALUE                          0x000000ff

//########---------------------------------------

// ---- Macro to get the "PDO" which is where the UsbdDeviceHandle used to
//      live in the structure below.  
//
//      Eventually change the app so that we can rename this element and
//         call it a PDO, which is what it really is.
//
#define GET_DEVICE_OBJECT_FROM_HANDLE(hU) (((PDEVICE_EXTENSION)(((PDEVICE_OBJECT)(hU))->DeviceExtension))->PhysicalDeviceObject)

struct _REQ_HEADER {
    //
    // Fields filled in by client driver
    //
    USHORT Length;                  // Total length of structure
    USHORT Function;                // Determines function to perform and
                                    // structure type in union
    ULONG  Status;                  // Return codes defined above
    PVOID UsbdDeviceHandle;         // device handle for device of interest
};

struct _REQ_GETCHAP9_VERSION {
  struct        _REQ_HEADER Hdr;
  USHORT        Version;                        // version includes major version in HIBYTE and minir version# in LOBYTE
}; 

struct _REQ_GETSET_DESCRIPTOR {
  struct        _REQ_HEADER Hdr;               // function code indicates get or set.
  ULONG         TransferBufferLength;
  PVOID         TransferBuffer;                 // This contains the descriptor data
  USHORT        Index;                          // Zero-based index
  USHORT        DescriptorType;                 // Ch 9-defined constants (Tbl 9-4)
  USHORT        LanguageId;                    // String descriptors only
}; 

struct _REQ_GET_STATUS {
        struct _REQ_HEADER Hdr;
        
        IN  USHORT           Recipient; //Recipient of status request
                                                //Use constants defined above.
                                                //DEVICE_STATUS
                                                //INTERFACE_STATUS
                                                //ENDPOINT_STATUS
        IN  USHORT          Index;
                                                // zero for device
                                                // else specifies interface/endpoint number
        USHORT Status;
}; 

struct _REQ_FEATURE {
  struct _REQ_HEADER Hdr;
  USHORT FeatureSelector;
  USHORT Recipient;                     // zero, interface or endpoint
  USHORT Index;
}; 

struct _REQ_SET_ADDRESS {
  struct _REQ_HEADER Hdr;
  USHORT DevAddr;
}; 


struct _REQ_GETSET_CONFIGURATION {
  struct _REQ_HEADER Hdr;
  USHORT ConfigValue;
}; 

struct _REQ_GETSET_INTERFACE {
  struct _REQ_HEADER Hdr;
  USHORT Index;
  USHORT AltSetting;
}; 

struct _REQ_GET_SET_DEVICE_POWER_STATE {
    struct _REQ_HEADER Hdr;
    ULONG DevicePowerState;
};


// The following structure is a later addition to allow an 
// application  to send a USB raw packet directly down to
// the stack.
//
//BUGBUG make these fields all ULONGs since some (like wLength) are
//       overloaded and used for other reasons in the driver.
//
struct _REQ_SEND_RAWPACKET {
  struct _REQ_HEADER Hdr;
  USHORT    bmRequestType;
  USHORT    bRequest;
  USHORT    wValue;
  USHORT    wIndex;
  PVOID     pvBuffer;
  USHORT    wLength;
}; 

//Follwing are lifted from usbdi.h just for consistency
#define USB_ENDPOINT_TYPE_CONTROL                 0x00
#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
#define USB_ENDPOINT_TYPE_BULK                    0x02
#define USB_ENDPOINT_TYPE_INTERRUPT               0x03

struct _PIPE_CONTXT {
    ULONG PipeNum;
    ULONG PipeType; //use #defines above (note they are the same as USBDI.H)
};    
    
/* 
// This IOCTL REQ block is sent by the app to configure the device in 
// a given configuration.  The app should determine the configuration
// value by reading the configuration descriptor using the appropriate
// REQ block for that above.
//
// This REQ block is sent with the IOCTL code IOCTL_USBDIAG_CONFIGURE_DEVICE.
*/
struct _REQ_SET_DEVICE_CONFIG {
  struct _REQ_HEADER Hdr;
  ULONG iConfigurationDescIndex;//It's the DESCRIPTOR Index, not the bConfigurationValue!
                                //and don't get cute and send me the Descriptor Type in here; Make that a ZERO!
                                //So, for the first config descriptor, send a ZERO here.  For the second
                                //config descriptor, send a ONE here, etc.
  ULONG nNumContexts;           //Number of __elements__ in the Contxt array below
  struct _PIPE_CONTXT Contxt[0];//First pipe context in array which will be filled in
                                //by the driver upon successful return
}; 

/* 
// This IOCTL REQ block is sent by the app to read or write from the device in 
// a given configuration.  This REQ block corresponds to the READ/WRITE Function
// that an app would send down to the USBDIAG driver (using IOCTL_USBDIAG_CHAP9_CONTROL).
// The app must have set device config using IOCTL_USBDIAG_CONFIGURE_DEVICE.
*/
struct _REQ_READ_WRITE_PIPE {
  IN struct _REQ_HEADER    Hdr;      //Set according to whether it's a read or write
                                         //(see the #define-s above to use constants here)
  IN struct _PIPE_CONTXT   Contxt;   //Read or Write from one pipe at a time
  IN PVOID                 pvBuffer; //Buffer to take data from or read data into
  IN OUT ULONG             ulLength; //Length of pvBuffer (IN:  bytes provided)
                                     //                   (OUT: actual bytes txferred)
}; 

typedef struct _REQ {
    union {
        struct _REQ_HEADER                      REQHeader;
        struct _REQ_GETSET_DESCRIPTOR           REQGetSetDescriptor;
        struct _REQ_GET_STATUS                  REQGetStatus;
        struct _REQ_FEATURE                     REQFeature;
        struct _REQ_SET_ADDRESS                 REQSetAddress;
        struct _REQ_GETSET_CONFIGURATION        REQGetSetConfiguration;
        struct _REQ_GETSET_INTERFACE            REQGetSetInterface;
        struct _REQ_SEND_RAWPACKET              REQRawPacket;
        struct _REQ_SET_DEVICE_CONFIG           REQSetDeviceConfig;
        struct _REQ_READ_WRITE_PIPE             REQReadWritePipe;
        struct _REQ_DEVICE_HANDLES              REQhDev;
        struct _REQ_GETCHAP9_VERSION            REQGetCh9;
        struct _REQ_GET_SET_DEVICE_POWER_STATE  REQGetSetDevicePowerState;
    };
} REQ, *PREQ;




#define RECIPIENT_DEVICE                ((UCHAR)0x00)
#define RECIPIENT_INTERFACE             ((UCHAR)0x01)
#define RECIPIENT_ENDPOINT              ((UCHAR)0x02)

#define bmReqH2D                                ((UCHAR)0x00)
#define bmReqD2H                                ((UCHAR)0x80)
#define bmReqSTANDARD                   ((UCHAR)0x00)
#define bmReqCLASS                              ((UCHAR)0x20)
#define bmReqVENDOR                             ((UCHAR)0x40)
#define bmReqRESERVED                   ((UCHAR)0x60)
#define bmReqDEVICE                             ((UCHAR)0x00)
#define bmReqINTERFACE                  ((UCHAR)0x01)
#define bmReqENDPOINT                   ((UCHAR)0x02)

#define GET_STATUS_DATA_LEN             2
#define SETUP_PACKET_LEN            8



typedef struct _REQ_ENUMERATE_DOWNSTREAM_DEVICE {
    struct _REQ_HEADER Hdr;
    BOOLEAN bLowSpeed;
    UCHAR   ucPortNumber;
} REQ_ENUMERATE_DOWNSTREAM_DEVICE, * PREQ_ENUMERATE_DOWNSTREAM_DEVICE;

typedef struct _CHAP11_SETUP_PACKET {
        USHORT wRequest;
        USHORT wValue;
        USHORT wIndex;
        USHORT wLength;
} CHAP11_SETUP_PACKET, * PCHAP11_SETUP_PACKET;

typedef struct _REQ_SEND_PACKET_DOWNSTREAM {
    struct _REQ_HEADER                   Hdr;
    USHORT                                               bLowSpeed;
    USHORT                                               usPortNumber;
        struct  _CHAP11_SETUP_PACKET SetupPacket;
        PUCHAR pucBuffer;
        ULONG  ulUrbStatus;
        ULONG  dwBytes;
} REQ_SEND_PACKET_DOWNSTREAM, * PREQ_SEND_PACKET_DOWNSTREAM;

typedef struct _REQ_GET_DOWNSTREAM_DESCRIPTOR {
    struct _REQ_HEADER  Hdr;
    USHORT                              usPortNumber;
    USHORT                  Index;          // Zero-based index
    USHORT                  DescriptorType; // Ch 9-defined constants (Tbl 9-4)
    USHORT                  LanguageId;     // String descriptors only
    PVOID                       TransferBuffer; // This contains the descriptor data
    ULONG                       TransferBufferLength;
} REQ_GET_DOWNSTREAM_DESCRIPTOR, * PREQ_GET_DOWNSTREAM_DESCRIPTOR;






#endif /*  __UCHAP9_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\typedefs.h ===
/*      TypeDefs.H, Type definitions for BYTE, DWORD etc. */

/*  like WinDef.h in Win32/MFC */

#ifndef _TYPEDEFS_H_
#define _TYPEDEFS_H_

#ifdef _NTDDK_

#ifdef __cplusplus
extern "C" {
#endif

/*
 * BASETYPES is defined in ntdef.h if these types are already defined
 */

#ifndef BASETYPES
#define BASETYPES
typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef char *PSZ;
#endif  /* !BASETYPES */

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

#ifndef FALSE
#define FALSE               0
#endif

#ifndef TRUE
#define TRUE                1
#endif

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;

/* Types use for passing & returning polymorphic values */
typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

#define MAKEWORD(a, b)      ((WORD)(((BYTE)(a)) | ((WORD)((BYTE)(b))) << 8))
#define MAKELONG(a, b)      ((LONG)(((WORD)(a)) | ((DWORD)((WORD)(b))) << 16))
#define LOWORD(l)           ((WORD)(l))
#define HIWORD(l)           ((WORD)(((DWORD)(l) >> 16) & 0xFFFF))
#define LOBYTE(w)           ((BYTE)(w))
#define HIBYTE(w)           ((BYTE)(((WORD)(w) >> 8) & 0xFF))


typedef WORD                ATOM;

#ifdef __cplusplus
}
#endif

#endif /* _NTDDK_  */

#endif /* _TYPEDEFS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\usbdiag.h ===
/*++
Copyright (c) 1996  Microsoft Corporation

Module Name:
    usbdiag.h

Environment:
    Kernel & user mode

Revision History:
    5-10-96 : created
--*/

#ifndef   __USBDIAG_H__
#define   __USBDIAG_H__

#define IRP_TYPE_READ_PIPE  0
#define IPR_TYPE_OTHER      1

#define FDO_FROM_DEVICE_HANDLE(dev) (((PDEVICE_LIST_ENTRY)(dev))->DeviceObject)

#define USBDIAG_NAME_MAX    64
#define NAME_MAX            256
#define MAX_INTERFACE       8
#define USBDIAG_MAX_PIPES   256
#define MAX_DOWNSTREAM_DEVICES 10

#define USBD_WIN98_GOLD_VERSION 0x0101
#define USBD_WIN98_SE_VERSION   0x0200
#define USBD_WIN2K_VERSION      0x0200

typedef struct _IRPNODE {
    LIST_ENTRY entry;
    PIRP Irp;
    struct _IRPNODE * next;
} IRPNODE, * PIRPNODE;

typedef struct _COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PIO_COMPLETION_ROUTINE  CompletionRoutine;
    PVOID Context;
    KEVENT DoneEvent;
} COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

typedef struct _DEVICE_LIST_ENTRY {
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT DeviceObject;
    struct _DEVICE_LIST_ENTRY *Next;
    ULONG DeviceNumber;
} DEVICE_LIST_ENTRY, *PDEVICE_LIST_ENTRY;

typedef struct _USBDIAG_WORKITEM {
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT  DeviceObject;
} USBDIAG_WORKITEM, *PUSBDIAG_WORKITEM;

typedef struct _DEVICE_EXTENSION
{
	PDEVICE_OBJECT  PhysicalDeviceObject; // physical device object
	PDEVICE_OBJECT  StackDeviceObject;    // stack device object
	PDEVICE_LIST_ENTRY   DeviceList;
	ULONG                ulInstance;  // keeps track of device instance

	// Name buffer for our named Functional device object link
	WCHAR DeviceLinkNameBuffer[USBDIAG_NAME_MAX];

    
	// descriptors for device instance

	PUSB_CONFIGURATION_DESCRIPTOR pUsbConfigDesc;
	PUSBD_INTERFACE_INFORMATION   Interface[MAX_INTERFACE];

	ULONG    OpenFRC;

	PUSB_DEVICE_DESCRIPTOR   pDeviceDescriptor;

	KTIMER   TimeoutTimer;
	KDPC     TimeoutDpc;

    ULONG DeviceHackFlags;

    PIRP PowerIrp;
    KEVENT WaitWakeEvent;

	// handle to configuration that was selected
	USBD_CONFIGURATION_HANDLE ConfigurationHandle;
	ULONG      numPipesInUse;    // number of pipes in use

    LIST_ENTRY  ListHead;
    KSPIN_LOCK  SpinLock;
    KEVENT      CancelEvent;

    PKEVENT SelfRequestedPowerIrpEvent;

	BOOLEAN     Stopped;      // keeps track of device status
	BOOLEAN     bTestDevice;  // flag for test devices

    PDEVICE_OBJECT RootHubPdo;
    PDEVICE_OBJECT TopOfHcdStackDeviceObject;

    //BOOLEAN     WaitWakePending;
    PIRP        WaitWakeIrp;
    DEVICE_CAPABILITIES DeviceCapabilities;
    POWER_STATE CurrentSystemState;
    POWER_STATE CurrentDeviceState; 

    // remember the irp corresponding to the interrupt pipe
    PIRP InterruptIrp;

    PUSBD_DEVICE_DATA DeviceData[MAX_DOWNSTREAM_DEVICES+1];  // pointers to downstream devices
    PUSB_CONFIGURATION_DESCRIPTOR DownstreamConfigDescriptor[MAX_DOWNSTREAM_DEVICES+1];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#if DBG

#define USBDIAG_KdPrint(_x_) DbgPrint _x_ ;

#define TRAP() DbgBreakPoint()

#else

#define USBDIAG_KdPrint(_x_) 

#define TRAP()

#endif

PVOID
USBDIAG_ExAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );
    
VOID
USBDIAG_ExFreePool(
    IN PVOID P
    );

NTSTATUS
USBDIAG_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
USBDIAG_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

NTSTATUS
USBDIAG_Power(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    );

VOID
USBDIAG_Unload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
USBDIAG_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBDIAG_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBDIAG_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    );

NTSTATUS
USBDIAG_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT PhysicalDeviceObject
    ); 

NTSTATUS
USBDIAG_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    BOOLEAN Global
    );

NTSTATUS
USBDIAG_ProcessIOCTL(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBDIAG_Configure_Device (
        IN PDEVICE_OBJECT DeviceObject, 
        IN PIRP Irp);

NTSTATUS
USBDIAG_SelectInterfaces(
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSB_CONFIGURATION_DESCRIPTOR ConfigurationDescriptor,
    IN PUSBD_INTERFACE_INFORMATION Interface,
    IN OUT struct _REQ_SET_DEVICE_CONFIG * REQSetDeviceConfig
    );

NTSTATUS
USBDIAG_Chap9Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );    

NTSTATUS
USBDIAG_HIDP_GetCollection(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );    

NTSTATUS
USBDIAG_RemoveGlobalDeviceObject(
    );
    
NTSTATUS
USBDIAG_Ch9CallUSBD(
	IN PDEVICE_OBJECT DeviceObject,
	IN PURB Urb,
    IN BOOLEAN fBlock,
    PIO_COMPLETION_ROUTINE CompletionRoutine,
    PVOID pvContext,
    BOOLEAN fWantTimeOut
	);

NTSTATUS
USBDIAG_SendPacket(
    IN PDEVICE_OBJECT DeviceObject, 
	IN CHAR	SetUpPacket[], 
	PVOID	TxBuffer,
	ULONG *	TxBufferLen,
	ULONG * pulUrbStatus
    );

VOID
USBDIAG_SyncTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
USBDIAG_IoCancelRoutine (
		PDEVICE_OBJECT DeviceObject,
		PIRP		   Irp
);


NTSTATUS
USBDIAG_IoGenericCompletionRoutine (
	PDEVICE_OBJECT DeviceObject,
	PIRP Irp,
	PVOID context
);



NTSTATUS 
USBDIAG_IssueWaitWake(
    IN PDEVICE_OBJECT DeviceObject
    );


NTSTATUS
USBDIAG_RequestWaitWakeCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );


NTSTATUS
USBDIAG_PoRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
USBDIAG_PowerIrpCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
USBDIAG_SetDevicePowerState(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG          ulPowerState
    );

NTSTATUS
USBDIAG_PoSelfRequestCompletion(
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

NTSTATUS
USBDIAG_SaveIrp(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP irp
    );

NTSTATUS
USBDIAG_ClearSavedIrp(
    IN PDEVICE_EXTENSION deviceExtension,
    IN PIRP irp
    );


NTSTATUS
USBDIAG_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBDIAG_CancelAllIrps(
    PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
USBDIAG_WaitWakeCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
USBDIAG_WaitWakeCancelRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
USBDIAG_RemoveDownstreamDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
USBDIAG_Chap11SetConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS
USBDIAG_Chap11EnableRemoteWakeup(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    );
NTSTATUS
USBDIAG_Chap11SendPacketDownstream(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
	IN PREQ_SEND_PACKET_DOWNSTREAM pSendPacketDownstream
    );


// ********************************************


#if DBG
#define DEBUG_LOG
#define DEBUG_HEAP
#endif

#define SIG_DEVICE          0x56454455  //"UDEV" signature for device handle


#if DBG
                                
#define ASSERT_DEVICE(d)        ASSERT((d)->Sig == SIG_DEVICE)



ULONG
_cdecl
USBD_KdPrintX(
    PCH Format,
    ...
    );

extern ULONG USBD_Debug_Trace_Level;
#define USBD_KdPrint(l, _x_) if ((l) <= USBD_Debug_Trace_Level) \
    {USBD_KdPrintX _x_;\
    }

VOID
USBD_Assert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define USBD_ASSERT( exp ) \
    if (!(exp)) \
        USBD_Assert( #exp, __FILE__, __LINE__, NULL )

#define USBD_ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        USBD_Assert( #exp, __FILE__, __LINE__, msg )

// TEST_TRAP() is a code coverage trap these should be removed
// if you are able to 'g' past the OK
// 
// TRAP() breaks in the debugger on the debugger build
// these indicate bugs in client drivers or fatal error 
// conditions that should be debugged. also used to mark 
// code for features not implemented yet.
//
// KdBreak() breaks in the debugger when in MAX_DEBUG mode
// ie debug trace info is turned on, these are intended to help
// debug drivers devices and special conditions on the
// bus.

#ifdef NTKERN
// Ntkern currently implements DebugBreak with a global int 3,
// we really would like the int 3 in our own code.
    
#define DBGBREAK() _asm { int 3 }
#else
#define DBGBREAK() DbgBreakPoint()
#endif /* NTKERN */

#define TEST_TRAP() { DbgPrint( " Code Coverage Trap %s %d\n", __FILE__, __LINE__); \
                      DBGBREAK(); }

#ifdef MAX_DEBUG
#define USBD_KdBreak(_x_) { DbgPrint("USBD:"); \
                            DbgPrint _x_ ; \
                            DBGBREAK(); }
#else
#define USBD_KdBreak(_x_)
#endif

#define USBD_KdTrap(_x_)  { DbgPrint( "USBD: "); \
                            DbgPrint _x_; \
                            DBGBREAK(); }


#else /* DBG not defined */

#define USBD_KdBreak(_x_) 

#define USBD_KdTrap(_x_)  

#define TEST_TRAP()

#define ASSERT_DEVICE(d)   

#define USBD_ASSERT( exp )

#define USBD_ASSERTMSG( msg, exp )

#endif /* DBG */





#ifndef   __HCDI_H__
#define   __HCDI_H__

typedef NTSTATUS ROOT_HUB_POWER_FUNCTION(PDEVICE_OBJECT DeviceObject, 
                                         PIRP Irp);
typedef NTSTATUS HCD_DEFFERED_START_FUNCTION(PDEVICE_OBJECT DeviceObject, 
                                             PIRP Irp);
typedef NTSTATUS HCD_SET_DEVICE_POWER_STATE(PDEVICE_OBJECT DeviceObject, 
                                            PIRP Irp,
                                            DEVICE_POWER_STATE DeviceState);

typedef struct _USBD_EXTENSION {
    // ptr to true device extension or NULL if this
    // is the true extension
    PVOID TrueDeviceExtension;
    // size of this structure
    ULONG Length;

    ROOT_HUB_POWER_FUNCTION *RootHubPower;
    HCD_DEFFERED_START_FUNCTION *HcdDeferredStartDevice;
    HCD_SET_DEVICE_POWER_STATE *HcdSetDevicePowerState;

    DEVICE_POWER_STATE HcCurrentDevicePowerState;

    KEVENT PnpStartEvent;
    
    //
    // Owner of frame length control for this HC
    //
    PVOID FrameLengthControlOwner;

    //
    // HCD device object we are connected to.
    //
    PDEVICE_OBJECT HcdDeviceObject;

    // wake irp passed to us by the hub driver
    // for the root hub
    PIRP PendingWakeIrp;

    // wakeup irp we send down the HC stack
    PIRP HcWakeIrp;

    //
    // device object for top of the HCD stack
    // this = HcdDeviceObject when no filters
    // are present.
    //
    
    PDEVICE_OBJECT HcdTopOfStackDeviceObject;

    PDEVICE_OBJECT HcdTopOfPdoStackDeviceObject;

    //
    // copy of the host controller device
    // capabilities
    //
    DEVICE_CAPABILITIES HcDeviceCapabilities;

    DEVICE_CAPABILITIES RootHubDeviceCapabilities;

    PIRP PowerIrp;

    //
    // Used to serialize open/close endpoint and
    // device configuration
    //
    KSEMAPHORE UsbDeviceMutex;
    
    //
    // Bitmap of assigned USB addresses
    //
    ULONG AddressList[4];

    //
    // Remember the Root Hub PDO we created.
    //

    PDEVICE_OBJECT RootHubPDO;

    PDRIVER_OBJECT DriverObject;

    //
    // symbolic link created for HCD stack
    //
    
    UNICODE_STRING DeviceLinkUnicodeString;

    BOOLEAN DiagnosticMode;
    BOOLEAN DiagIgnoreHubs;

    BOOLEAN Reserved; // used to be supportNonComp
    UCHAR HcWakeFlags; 

    ULONG DeviceHackFlags;

    //
    // Store away the PDO
    //
    PDEVICE_OBJECT HcdPhysicalDeviceObject;

    PVOID RootHubDeviceData;

    DEVICE_POWER_STATE RootHubDeviceState;

    // current USB defined power state of the bus
    // during last suspend.
    DEVICE_POWER_STATE SuspendPowerState;

    UNICODE_STRING RootHubSymbolicLinkName;

} USBD_EXTENSION, *PUSBD_EXTENSION;

#define HC_ENABLED_FOR_WAKEUP           0x01
#define HC_WAKE_PENDING                 0x02


// device hack flags, these flags alter the stacks default behavior
// in order to support certain broken "legacy" devices

#define USBD_DEVHACK_SLOW_ENUMERATION   0x00000001
#define USBD_DEVHACK_DISABLE_SN         0x00000002

//
// This macro returns the true device object for the HCD give 
// either the true device_object or a PDO owned by the HCD/BUS 
// driver.
//

//
// HCD specific URB commands
//

#define URB_FUNCTION_HCD_OPEN_ENDPOINT                0x1000
#define URB_FUNCTION_HCD_CLOSE_ENDPOINT               0x1001
#define URB_FUNCTION_HCD_GET_ENDPOINT_STATE           0x1002
#define URB_FUNCTION_HCD_SET_ENDPOINT_STATE           0x1003
#define URB_FUNCTION_HCD_ABORT_ENDPOINT               0x1004

// this bit is set for all functions that must be handled by HCD
#define HCD_URB_FUNCTION                              0x1000  
// this bit is set in the function code by USBD to indicate that
// this is an internal call originating from USBD 
#define HCD_NO_USBD_CALL                              0x2000  

//
// values for HcdEndpointState
//

//
// set if the current state of the endpoint in the HCD is 'stalled'
//
#define HCD_ENDPOINT_HALTED_BIT            0
#define HCD_ENDPOINT_HALTED                (1<<HCD_ENDPOINT_HALTED_BIT)

//
// set if the HCD has any transfers queued for the endpoint
//
#define HCD_ENDPOINT_TRANSFERS_QUEUED_BIT  1
#define HCD_ENDPOINT_TRANSFERS_QUEUED      (1<<HCD_ENDPOINT_TRANSFERS_QUEUED_BIT)


//
// set if the HCD should reset the data toggle on the host side
//
#define HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT 2
#define HCD_ENDPOINT_RESET_DATA_TOGGLE     (1<<HCD_ENDPOINT_RESET_DATA_TOGGLE_BIT )


//
// HCD specific URBs
//
    
struct _URB_HCD_OPEN_ENDPOINT {
    struct _URB_HEADER;
    USHORT DeviceAddress;
    BOOLEAN LowSpeed;
    BOOLEAN NeverHalt;
    PUSB_ENDPOINT_DESCRIPTOR EndpointDescriptor;
    ULONG MaxTransferSize;
    PVOID HcdEndpoint;
};

struct _URB_HCD_CLOSE_ENDPOINT {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
};

struct _URB_HCD_ENDPOINT_STATE {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
    ULONG HcdEndpointState;
};

struct _URB_HCD_ABORT_ENDPOINT {
    struct _URB_HEADER;
    PVOID HcdEndpoint;
};


//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.
//

typedef struct _COMMON_TRANSFER_EXTENSION {
    union {
        struct {
            ULONG StartFrame;
            ULONG NumberOfPackets;
            ULONG ErrorCount;
            USBD_ISO_PACKET_DESCRIPTOR IsoPacket[0];     
        } Isoch;
        UCHAR SetupPacket[8];    
    } u;
} COMMON_TRANSFER_EXTENSION, *PCOMMON_TRANSFER_EXTENSION;


struct _URB_HCD_COMMON_TRANSFER {
    struct _URB_HEADER;
    PVOID UsbdPipeHandle;
    ULONG TransferFlags;
    ULONG TransferBufferLength;
    PVOID TransferBuffer;
    PMDL TransferBufferMDL;
    struct _HCD_URB *UrbLink;   // link to next urb request
                                // if this is a chain of requests
    struct _URB_HCD_AREA hca;       // fields for HCD use

    COMMON_TRANSFER_EXTENSION Extension; 
/*    
    //BUGBUG add fields for isoch and
    //control transfers
    UCHAR SetupPacket[8];

    ULONG StartFrame;
    // number of packets that make up this request
    ULONG NumberOfPackets;
    // number of packets that completed with errors
    ULONG ErrorCount;
    USBD_ISO_PACKET_DESCRIPTOR IsoPacket[0]; 
*/    
};

typedef struct _HCD_URB {
    union {
            struct _URB_HEADER                      UrbHeader;
            struct _URB_HCD_OPEN_ENDPOINT           HcdUrbOpenEndpoint;
            struct _URB_HCD_CLOSE_ENDPOINT          HcdUrbCloseEndpoint;
            struct _URB_GET_FRAME_LENGTH            UrbGetFrameLength;
            struct _URB_SET_FRAME_LENGTH            UrbSetFrameLength;
            struct _URB_GET_CURRENT_FRAME_NUMBER    UrbGetCurrentFrameNumber;
            struct _URB_HCD_ENDPOINT_STATE          HcdUrbEndpointState;
            struct _URB_HCD_ABORT_ENDPOINT          HcdUrbAbortEndpoint;
            //formats for USB transfer requests.
            struct _URB_HCD_COMMON_TRANSFER         HcdUrbCommonTransfer;
            //formats for specific transfer types
            //that have fields not contained in
            //CommonTransfer.
            //BUGBUG this will be merged with commontransfer
            struct _URB_ISOCH_TRANSFER              UrbIsochronousTransfer;

    };
} HCD_URB, *PHCD_URB;


//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13



#endif /* __HCDI_H__ */

#define USBD_TAG         0x44425355 /* "USBD" */

#if DBG
#define DEBUG_LOG
#endif

//enable pageable code
#ifndef PAGE_CODE
#define PAGE_CODE
#endif

#define _USBD_

//
// Constents used to format USB setup packets
// for the default pipe
//

//
// Values for the bmRequest field
//
                                        
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//
// USB standard command values
// combines bmRequest and bRequest fields 
// in the setup packet for standard control 
// transfers
//
                                                
#define STANDARD_COMMAND_REQUEST_MASK           0xff00

#define STANDARD_COMMAND_GET_DESCRIPTOR         ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_DESCRIPTOR<<8))
                                                    
#define STANDARD_COMMAND_SET_DESCRIPTOR         ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_DESCRIPTOR<<8))    

#define STANDARD_COMMAND_GET_STATUS_ENDPOINT    ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_ENDPOINT) | \
                                                (USB_REQUEST_GET_STATUS<<8))
                                                    
#define STANDARD_COMMAND_GET_STATUS_INTERFACE   ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_INTERFACE) | \
                                                (USB_REQUEST_GET_STATUS<<8))
                                                
#define STANDARD_COMMAND_GET_STATUS_DEVICE      ((USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_STATUS<<8))

#define STANDARD_COMMAND_SET_CONFIGURATION      ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_CONFIGURATION<<8))

#define STANDARD_COMMAND_SET_INTERFACE          ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_INTERFACE) | \
                                                (USB_REQUEST_SET_INTERFACE<<8))
                                                    
#define STANDARD_COMMAND_SET_ADDRESS            ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_ADDRESS<<8))

#define STANDARD_COMMAND_CLEAR_FEATURE_ENDPOINT ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_ENDPOINT) | \
                                                (USB_REQUEST_CLEAR_FEATURE<<8))

// added by kk
#define STANDARD_COMMAND_SET_DEVICE_FEATURE     ((USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_SET_FEATURE<<8))


//
// USB class command macros
//

#define CLASS_COMMAND_GET_DESCRIPTOR            ((USB_CLASS_COMMAND | \
                                                USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_DEVICE) | \
                                                (USB_REQUEST_GET_DESCRIPTOR<<8))    

#define CLASS_COMMAND_GET_STATUS_OTHER          ((USB_CLASS_COMMAND | \
                                                USB_DEVICE_TO_HOST | \
                                                USB_COMMAND_TO_OTHER) | \
                                                (USB_REQUEST_GET_STATUS<<8))

#define CLASS_COMMAND_SET_FEATURE_TO_OTHER         ((USB_CLASS_COMMAND | \
                                                USB_HOST_TO_DEVICE | \
                                                USB_COMMAND_TO_OTHER) | \
                                                (USB_REQUEST_SET_FEATURE<<8))                                                    

//
// Macros to set transfer direction flag
//

#define USBD_SET_TRANSFER_DIRECTION_IN(tf)  ((tf) |= USBD_TRANSFER_DIRECTION_IN)  

#define USBD_SET_TRANSFER_DIRECTION_OUT(tf) ((tf) &= ~USBD_TRANSFER_DIRECTION_IN)  

                                        
//
// Flags for the URB header flags field used
// by USBD
//                                  
#define USBD_REQUEST_IS_TRANSFER        0x00000001
#define USBD_REQUEST_MDL_ALLOCATED      0x00000002
#define USBD_REQUEST_USES_DEFAULT_PIPE  0x00000004          
#define USBD_REQUEST_NO_DATA_PHASE      0x00000008    

typedef struct _USB_STANDARD_SETUP_PACKET {
    USHORT RequestCode;
    USHORT wValue;
    USHORT wIndex;
    USHORT wLength;
} USB_STANDARD_SETUP_PACKET, *PUSB_STANDARD_SETUP_PACKET;



//
// instance information for a device 
//

#define PIPE_CLOSED(ph) ((ph)->HcdEndpoint == NULL)

#define GET_DEVICE_EXTENSION(DeviceObject)    (((PUSBD_EXTENSION)(DeviceObject->DeviceExtension))->TrueDeviceExtension)
//#define GET_DEVICE_EXTENSION(DeviceObject)    ((PUSBD_EXTENSION)(DeviceObject->DeviceExtension))

#define HCD_DEVICE_OBJECT(DeviceObject)        (DeviceObject)

#define DEVICE_FROM_DEVICEHANDLEROBJECT(UsbdDeviceHandle) (PUSBD_DEVICE_DATA) (UsbdDeviceHandle)

#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)

#define HC_URB(urb) ((PHCD_URB)(urb))

//
// we use a semaphore to serialize access to the configuration functions
// in USBD
//
#define InitializeUsbDeviceMutex(de)  KeInitializeSemaphore(&(de)->UsbDeviceMutex, 1, 1);

#define USBD_WaitForUsbDeviceMutex(de)  { USBD_KdPrint(3, ("'***WAIT dev mutex %x\n", &(de)->UsbDeviceMutex)); \
                                          KeWaitForSingleObject(&(de)->UsbDeviceMutex, \
                                                                Executive,\
                                                                KernelMode, \
                                                                FALSE, \
                                                                NULL); \
                                            }                                                                 

#define USBD_ReleaseUsbDeviceMutex(de)  { USBD_KdPrint(3, ("'***RELEASE dev mutex %x\n", &(de)->UsbDeviceMutex));\
                                          KeReleaseSemaphore(&(de)->UsbDeviceMutex,\
                                                             LOW_REALTIME_PRIORITY,\
                                                             1,\
                                                             FALSE);\
//
//Function Prototypes
//

#if DBG
VOID
USBD_Warning(
    PUSBD_DEVICE_DATA DeviceData,
    PUCHAR Message,
    BOOLEAN DebugBreak
    );
#else
#define USBD_Warning(x, y, z)
#endif    

NTSTATUS
USBD_Internal_Device_Control(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PUSBD_EXTENSION DeviceExtension,
    IN PBOOLEAN IrpIsPending
    );

NTSTATUS
USBD_SendCommand(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT RequestCode,
    IN USHORT WValue,
    IN USHORT WIndex,
    IN USHORT WLength,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned,
    OUT USBD_STATUS *UsbStatus
    );

#if 0
NTSTATUS
USBDIAG_CreateDevice(
    IN OUT PUSBD_DEVICE_DATA *DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN DeviceIsLowSpeed,
    IN ULONG MaxPacketSize_Endpoint0,
    IN OUT PULONG NonCompliantDevice
    );
#endif



NTSTATUS
USBD_ProcessURB(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PURB Urb,
    OUT PBOOLEAN IrpIsPending
    );

NTSTATUS
USBD_MapError_UrbToNT(
    IN PURB Urb,
    IN NTSTATUS NtStatus
    );

NTSTATUS
USBD_Irp_Complete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#if 0
USHORT
USBD_AllocateUsbAddress(
    IN PDEVICE_OBJECT DeviceObject
    );
#endif

NTSTATUS
USBDIAG_CreateInitDownstreamDevice(
    PREQ_ENUMERATE_DOWNSTREAM_DEVICE pEnumerate,
    PDEVICE_EXTENSION deviceExtension
    );

NTSTATUS
USBD_GetDescriptor(
    IN PUSBD_DEVICE_DATA Device,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PUCHAR DescriptorBuffer,
    IN USHORT DescriptorBufferLength,
    IN USHORT DescriptorTypeAndIndex
    );

NTSTATUS
USBD_CloseEndpoint(
    IN PUSBD_DEVICE_DATA Device,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus
    );

NTSTATUS
USBD_SubmitSynchronousURB(
    IN PURB Urb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_DEVICE_DATA DeviceData
    );

NTSTATUS
USBD_GetEndpointState(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    OUT USBD_STATUS *UsbStatus,
    OUT PULONG EndpointState
    );    


NTSTATUS 
USBDIAG_SyncGetRootHubPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *TopOfHcdStackDeviceObject
    );

NTSTATUS
USBDIAG_PowerIrp_Complete(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
USBDIAG_SetCfgEnableRWu(
    PDEVICE_EXTENSION deviceExtension, 
    PREQ_ENUMERATE_DOWNSTREAM_DEVICE pEnumerate
    );

NTSTATUS
USBDIAG_WaitForWakeup(
    PDEVICE_EXTENSION deviceExtension
    );


NTSTATUS
USBD_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    ); 

NTSTATUS
USBD_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    );

NTSTATUS
USBDIAG_DisableRemoteWakeupEnable(
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN bDisable
    );

NTSTATUS
USBDIAG_PassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBDIAG_QueryCapabilitiesCompletionRoutine(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


NTSTATUS
USBDIAG_GenericCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

#endif  //__USBDIAG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\usbdiag.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    usbdiag.c

Abstract:

    USB device driver for Intel/Microsoft USB diagnostic apps 

Environment:

    kernel mode only

Notes:

  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
  PURPOSE.

  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.


Revision History:

     5-4-96 : created
    7-21-97 : Todd Carpenter adds Chap11 IOCTL's

--*/

#define DRIVER

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"

#pragma pack (push,1)
#include "usb100.h"
#include "usbdi.h"
#include "usbdlib.h"
#include "usbioctl.h"
#pragma pack (pop) //disable 1-byte alignment
 
#include "opaque.h"

#pragma pack (push,1)
#include "ioctl.h"
#include "chap9drv.h"
#include "USBDIAG.h"
#pragma pack (pop) //disable 1-byte alignment

PDEVICE_OBJECT          USBDIAG_GlobalDeviceObject = NULL;

ULONG USBDIAG_NextDeviceNumber = 0;
ULONG USBDIAG_NumberDevices = 0;
ULONG gulMemoryAllocated = 0;

USBD_VERSION_INFORMATION gVersionInformation;


/* UCHAR *SystemPowerStateString[] = {
   "PowerSystemUnspecified",
   "PowerSystemWorking",
   "PowerSystemSleeping1",
   "PowerSystemSleeping2",
   "PowerSystemSleeping3",
   "PowerSystemHibernate",
   "PowerSystemShutdown",
   "PowerSystemMaximum"
};

UCHAR *DevicePowerStateString[] = {
   "PowerDeviceUnspecified",
   "PowerDeviceD0",
   "PowerDeviceD1",
   "PowerDeviceD2",
   "PowerDeviceD3",
   "PowerDeviceMaximum"
}; */



//
// Global pointer to Driver Object
//

PDRIVER_OBJECT USBDIAG_DriverObject;

#define REMOTE_WAKEUP 0x20

#ifdef PAGE_CODE
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBD_SubmitSynchronousURB)
#pragma alloc_text(PAGE, USBD_CloseEndpoint)
#endif
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path
                   to driver-specific key in the registry

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    //PDEVICE_OBJECT deviceObject = NULL;

    DbgPrint("USBDIAG.SYS: entering (USBDIAG) DriverEntry\n");
    DbgPrint("USBDIAG.SYS: USBDIAG Driver Build Date/Time: %s  %s\n",
              __DATE__, __TIME__);

    USBDIAG_DriverObject = DriverObject;

    //
    // Create dispatch points for device control, create, close.
    //

    DriverObject->MajorFunction[IRP_MJ_PNP]     = USBDIAG_PnP;
    DriverObject->MajorFunction[IRP_MJ_POWER]   = USBDIAG_Power;
                
    DriverObject->MajorFunction[IRP_MJ_CREATE]  =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]   =  USBDIAG_Dispatch;

    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  =  USBDIAG_ProcessIOCTL;
    DriverObject->MajorFunction[IRP_MJ_WRITE]   =  NULL;
    DriverObject->MajorFunction[IRP_MJ_READ]    =  NULL;
    DriverObject->DriverUnload                  =  USBDIAG_Unload;
                                            
    DriverObject->DriverExtension->AddDevice    = USBDIAG_PnPAddDevice;

    DbgPrint ("'USBDIAG.SYS: exiting (USBDIAG) DriverEntry (%x)\n", ntStatus);


    // determine the os version and store in a global.
    USBD_GetUSBDIVersion(&gVersionInformation);

    return ntStatus;
}


NTSTATUS
USBDIAG_Dispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
    PIO_STACK_LOCATION irpStack;
    NTSTATUS ntStatus;
    PDEVICE_EXTENSION globalDeviceExtension;
    
    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_Dispatch\n"));

    //
    // Default return status unless overridden later
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    //
    // Get a pointer to the current location in the Irp.  This is where
    // the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    switch (irpStack->MajorFunction) {
    case IRP_MJ_CREATE:
        //USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MJ_CREATE\n"));
        ASSERT(USBDIAG_GlobalDeviceObject != NULL);
        globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;
        globalDeviceExtension->OpenFRC++;
                break;
                
    case IRP_MJ_CLOSE:
        //USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MJ_CLOSE\n"));
        ASSERT(USBDIAG_GlobalDeviceObject != NULL);
        globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;
        globalDeviceExtension->OpenFRC--;
        break;

    default:
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;    
        break;
        
    } /* case MajorFunction */

    ntStatus = Irp->IoStatus.Status;

    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    //USBDIAG_KdPrint(("USBDIAG.SYS: Exit USBDIAG_Dispatch %x\n", ntStatus));
    
    return ntStatus;
}


NTSTATUS
USBDIAG_PnP(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp
    )
/*++

Routine Description:

    Process the PnP IRPs sent to this device.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  irpStack;
    PDEVICE_EXTENSION   deviceExtension;
    PDEVICE_EXTENSION   globalDeviceExtension;
    PDEVICE_LIST_ENTRY  device, foundDevice;
    BOOLEAN             passDownIrp;


    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_PnP\n"));

    //
    // Default to passing down all Irps unless overridden later.
    //
    passDownIrp = TRUE;

    //
    // Get a pointer to the current location in the Irp.  This is where
    // the function codes and parameters are located.
    //
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //
    // Get a pointer to the device extension
    //
    deviceExtension = DeviceObject->DeviceExtension;

    ASSERT (deviceExtension != NULL);

    //
    // Get a pointer to the global device extension
    //
    globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;
    
    //
    // Switch on the PnP minor function
    //
    switch (irpStack->MinorFunction) {
        case IRP_MN_START_DEVICE:
            //USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MN_START_DEVICE\n"));
            ntStatus = USBDIAG_PassDownIrp(DeviceObject, Irp);
            USBDIAG_KdPrint (("Back from passing down IRP_MN_START_DEVICE; status: %#X\n",
                              ntStatus));

            if (NT_SUCCESS(ntStatus))
            {
                // Now we can begin our configuration actions on the device
                //
                ntStatus = USBDIAG_StartDevice(DeviceObject);
            }
            passDownIrp = FALSE;
            break;
        
        case IRP_MN_QUERY_CAPABILITIES: // 0x09
            USBDIAG_KdPrint (("*********************************\n"));
            USBDIAG_KdPrint (("IRP_MN_QUERY_CAPABILITIES\n"));
            passDownIrp = FALSE;

            IoCopyCurrentIrpStackLocationToNext(Irp);
            IoSetCompletionRoutine(Irp,
                                   USBDIAG_QueryCapabilitiesCompletionRoutine,
                                   DeviceObject,
                                   TRUE,
                                   TRUE,
                                   TRUE);

            ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);
            break;


        case IRP_MN_STOP_DEVICE:
            //USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MN_STOP_DEVICE\n"));
            ntStatus = USBDIAG_StopDevice(DeviceObject);
            break;

        case IRP_MN_REMOVE_DEVICE:
            {
                int i = 1;
                //USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MN_REMOVE_DEVICE\n"));
                ntStatus = USBDIAG_StopDevice(DeviceObject);

                // remove all downstream devices
                for (i = 1; i <= MAX_DOWNSTREAM_DEVICES; i++)
                {
                    if (deviceExtension->DeviceData[i])
                    {
                        USBDIAG_KdPrint(("IRP_MN_REMOVE_DEVICE: Removing device on downstream port %d\n", i));
                        USBDIAG_RemoveDownstreamDevice(deviceExtension->DeviceData[i],
                                                       deviceExtension->StackDeviceObject);

                    }
                }
                USBDIAG_KdPrint(("Done removing downstream devices\n"));
                //
                // Remove this device object from our list
                //

                device = globalDeviceExtension->DeviceList;

                USBDIAG_KdPrint(("USBDIAG.SYS: IRP_MN_REMOVE_DEVICE devobj = %x dev = %x\n", 
                                  DeviceObject, device));

                ASSERT(device != NULL);

                if (device->DeviceObject == DeviceObject) {
                    //
                    // DeviceObject is the first one on the list.  Delete from the
                    // list by setting the head of the list to point to the next
                    // one on the list.
                    //
                    globalDeviceExtension->DeviceList = device->Next;                

                    USBDIAG_ExFreePool(device);
                
                } else {
                    //
                    // DeviceObject is not the first one on the list.  Walk the
                    // list and find it.
                    //
                    while (device->Next) {
                        if (device->Next->DeviceObject == DeviceObject) {
                            //
                            // DeviceObject is the next one on the list, remember
                            // the next one and delete it by setting the next one
                            // to the next next one.
                            //
                            foundDevice = device->Next;
                            device->Next = foundDevice->Next;

                            USBDIAG_ExFreePool(foundDevice);
                            break;
                                }
                        device = device->Next;
                    }
                }

                //USBDIAG_KdPrint(("USBDIAG.SYS: Detaching stack device object...%X\n",
                                  //deviceExtension->StackDeviceObject));
                IoDetachDevice(deviceExtension->StackDeviceObject);

                //
                // Pass the REMOVE_DEVICE Irp down now after detaching and
                // removing the device instead of later.
                //
                passDownIrp = FALSE;

                IoSkipCurrentIrpStackLocation (Irp);

                ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

                //USBDIAG_KdPrint(("USBDIAG.SYS: Deleting device object...%X\n", DeviceObject));
                IoDeleteDevice(DeviceObject);

                USBDIAG_NumberDevices--;

                //
                // Free the GlobalDeviceObject if this was the last real
                // DeviceObject.   XXXXX Take a careful look at what the
                // hell this routine is all about.
                //
                USBDIAG_RemoveGlobalDeviceObject();
            }
            break;
            
        default:
            //USBDIAG_KdPrint(("USBDIAG.SYS: PnP IOCTL not handled: (%#X)\n",
                              //irpStack->MinorFunction));
            break;
    }

    if (passDownIrp)
    {
        //
        // Pass the PnP Irp down the stack
        //
        IoSkipCurrentIrpStackLocation (Irp);
        ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                                Irp);
    }

    //USBDIAG_KdPrint(("USBDIAG.SYS: Exit USBDIAG_PnP %x\n", ntStatus));
    
    return ntStatus;
}

NTSTATUS
USBDIAG_PassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension = DeviceObject->DeviceExtension;
    KEVENT              localevent;
    NTSTATUS            ntStatus;

    PAGED_CODE();

    // Initialize the event we'll wait on
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Copy down Irp params for the next driver
    //
    IoCopyCurrentIrpStackLocationToNext(Irp);

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutine(Irp,
                           USBDIAG_GenericCompletionRoutine,
                           &localevent,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, Irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = Irp->IoStatus.Status;
    }

    return ntStatus;
}

NTSTATUS
USBDIAG_GenericCompletionRoutine(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
{
    PKEVENT kevent;

    kevent = (PKEVENT)Context;
    KeSetEvent(kevent, IO_NO_INCREMENT,FALSE);
    return STATUS_MORE_PROCESSING_REQUIRED;
}


VOID
USBDIAG_Unload(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    Free all the allocated resources, etc.

Arguments:

    DriverObject - pointer to a driver object

Return Value:


--*/
{
    DbgPrint ("USBDIAG.SYS: enter USBDIAG_Unload\n");

    //
    // Free any global resources allocated
    // in DriverEntry
    //

    // free the global deviceobject here

        USBDIAG_RemoveGlobalDeviceObject();
    DbgPrint ("USBDIAG.SYS: exit USBDIAG_Unload\n");
}



NTSTATUS
USBDIAG_StartDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes a given instance of the device on the USB.

Arguments:

    DeviceObject - pointer to the device object for this instance of a 
                    UTB

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS ntStatus;
    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    PURB urb;
    ULONG siz;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_StartDevice\n"));    

    //
    // Fetch the device descriptor for the device
    // 
    urb = USBDIAG_ExAllocatePool(NonPagedPool, 
                         sizeof(struct _URB_CONTROL_DESCRIPTOR_REQUEST));
                         
    if (urb) 
    {
        siz = sizeof(USB_DEVICE_DESCRIPTOR);

        deviceDescriptor = USBDIAG_ExAllocatePool(NonPagedPool, siz);

        if (deviceDescriptor) 
        {    
            UsbBuildGetDescriptorRequest(urb,
                                         (USHORT) sizeof (struct _URB_CONTROL_DESCRIPTOR_REQUEST),
                                         USB_DEVICE_DESCRIPTOR_TYPE,
                                         0,
                                         0,
                                         deviceDescriptor,
                                         NULL,
                                         siz,
                                         NULL);
                                                                  
            ntStatus = USBDIAG_CallUSBD(DeviceObject, urb);

            if (NT_SUCCESS(ntStatus)) 
            {
                //USBDIAG_KdPrint(("USBDIAG.SYS: Device Descriptor = %x, len %x\n", 
                                //deviceDescriptor, 
                                //urb->UrbControlDescriptorRequest.TransferBufferLength));    

                //USBDIAG_KdPrint(("USBDIAG.SYS: USB Device Descriptor:\n"));
                //USBDIAG_KdPrint(("USBDIAG.SYS: -------------------------\n"));                
                //USBDIAG_KdPrint(("USBDIAG.SYS: bLength %d\n", deviceDescriptor->bLength));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bDescriptorType 0x%x\n", deviceDescriptor->bDescriptorType));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bcdUSB 0x%x\n", deviceDescriptor->bcdUSB));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bDeviceClass 0x%x\n", deviceDescriptor->bDeviceClass));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bDeviceSubClass 0x%x\n", deviceDescriptor->bDeviceSubClass));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bDeviceProtocol 0x%x\n", deviceDescriptor->bDeviceProtocol));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bMaxPacketSize0 0x%x\n", deviceDescriptor->bMaxPacketSize0));
                //USBDIAG_KdPrint(("USBDIAG.SYS: idVendor 0x%x\n", deviceDescriptor->idVendor));
                //USBDIAG_KdPrint(("USBDIAG.SYS: idProduct 0x%x\n", deviceDescriptor->idProduct));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bcdDevice 0x%x\n", deviceDescriptor->bcdDevice));
                //USBDIAG_KdPrint(("USBDIAG.SYS: iManufacturer 0x%x\n", deviceDescriptor->iManufacturer));
                //USBDIAG_KdPrint(("USBDIAG.SYS: iProduct 0x%x\n", deviceDescriptor->iProduct));
                //USBDIAG_KdPrint(("USBDIAG.SYS: iSerialNumber 0x%x\n", deviceDescriptor->iSerialNumber));
                //USBDIAG_KdPrint(("USBDIAG.SYS: bNumConfigurations 0x%x\n", deviceDescriptor->bNumConfigurations));
            }
        } 
        else 
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }            
        
        if (NT_SUCCESS(ntStatus)) 
        {
            deviceExtension->pDeviceDescriptor = deviceDescriptor;
            deviceExtension->Stopped = FALSE;
        } 
        else if (deviceDescriptor) 
        {
             USBDIAG_ExFreePool(deviceDescriptor);
        }

        USBDIAG_ExFreePool(urb);
    } 
    else 
    {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;        
    }        


    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_StartDevice (%x)\n", ntStatus));

    return ntStatus;
}

NTSTATUS
USBDIAG_QueryCapabilitiesCompletionRoutine(
    IN PDEVICE_OBJECT NullDeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PDEVICE_OBJECT deviceObject       = (PDEVICE_OBJECT) Context;
    PDEVICE_EXTENSION deviceExtension = deviceObject->DeviceExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (Irp);
    ULONG ulPowerLevel;

    USBDIAG_KdPrint(("enter USBDIAG_QueryCapabilitiesCompletionRoutine (Irp->IoStatus.Status = 0x%x)\n", Irp->IoStatus.Status));

    //  If the lower driver returned PENDING, mark our stack location as pending also.
    if (Irp->PendingReturned) 
    {
        IoMarkIrpPending(Irp);
    }
    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);
    ASSERT(irpStack->MinorFunction == IRP_MN_QUERY_CAPABILITIES);

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    USBDIAG_KdPrint(("sizeof(DEVICE_CAPABILITIES) = %d (0x%x)\n",sizeof(DEVICE_CAPABILITIES),sizeof(DEVICE_CAPABILITIES)));

    // this is for Win2k
    irpStack->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = TRUE;
    irpStack->Parameters.DeviceCapabilities.Capabilities->Removable         = TRUE;

    RtlCopyMemory(&deviceExtension->DeviceCapabilities, 
                  irpStack->Parameters.DeviceCapabilities.Capabilities, 
                  sizeof(DEVICE_CAPABILITIES));


    // print out capabilities info
    USBDIAG_KdPrint(("************ Device Capabilites ************\n"));
    USBDIAG_KdPrint(("SystemWake = 0x%x\n", deviceExtension->DeviceCapabilities.SystemWake));
    USBDIAG_KdPrint(("DeviceWake = 0x%x\n", deviceExtension->DeviceCapabilities.DeviceWake));

//    USBDIAG_KdPrint(("SystemWake = %s\n",
//                    SystemPowerStateString[deviceExtension->DeviceCapabilities.SystemWake]));
//    USBDIAG_KdPrint(("DeviceWake = %s\n",
//                    DevicePowerStateString[deviceExtension->DeviceCapabilities.DeviceWake]));

    USBDIAG_KdPrint(("Device Address: 0x%x\n", deviceExtension->DeviceCapabilities.Address));

    for (ulPowerLevel=PowerSystemUnspecified; ulPowerLevel< PowerSystemMaximum; ulPowerLevel++) 
    {
//        USBDIAG_KdPrint(("Dev State Map: sys st %s = dev st %s\n",
//                        SystemPowerStateString[ulPowerLevel],
//                        DevicePowerStateString[deviceExtension->DeviceCapabilities.DeviceState[ulPowerLevel]] ));
    }
    Irp->IoStatus.Status = STATUS_SUCCESS;

    return ntStatus;
}


NTSTATUS
USBDIAG_StopDevice(
    IN  PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Stops a given instance of a UTB device on the 82930.

Arguments:

    DeviceObject - pointer to the device object for this instance of a 82930 

Return Value:

    NT status code

--*/
{
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    NTSTATUS          ntStatus        = STATUS_SUCCESS;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_StopDevice\n"));    

    if (deviceExtension->Stopped != TRUE)
    {
        ntStatus = USBDIAG_CancelAllIrps(deviceExtension);
        // 
        // if we are already stopped then just exit
        //

        if (deviceExtension->pDeviceDescriptor)
        {
            USBDIAG_ExFreePool(deviceExtension->pDeviceDescriptor);
            deviceExtension->pDeviceDescriptor = NULL;
        }
        deviceExtension->Stopped = TRUE;
    }

    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_StopDevice (%x)\n", ntStatus));

    return ntStatus;
}



NTSTATUS
USBDIAG_PnPAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN OUT PDEVICE_OBJECT PhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device

Arguments:

    DriverObject - pointer to the driver object for this instance of USBDIAG

    PhysicalDeviceObject - pointer to device object created by the bus

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT          deviceObject = NULL;
    PDEVICE_EXTENSION       deviceExtension, globalDeviceExtension = NULL;
//    PDEVICE_OBJECT          tempdeviceObject = NULL;
    
    USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_PnPAddDevice\n"));

    //
    // Are we given the physical device object?
    //
    if (PhysicalDeviceObject) {

            if (USBDIAG_GlobalDeviceObject == NULL) {

                //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice Creating Global Device Object\n"));

                ntStatus = 
                    USBDIAG_CreateDeviceObject(DriverObject, &USBDIAG_GlobalDeviceObject, TRUE);
                    
                if (NT_SUCCESS(ntStatus)) {  
                    globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;
                    
                    USBDIAG_GlobalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            
                    globalDeviceExtension->DeviceList = NULL;    
                    globalDeviceExtension->OpenFRC = 0;                    
                }                                        
            } 
            else 
            {
                 globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;
            }

            //
            // create our funtional device object (FDO)
            //

            if (NT_SUCCESS(ntStatus)) 
            {            
                //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice creating new USB device object\n"));

                ntStatus = USBDIAG_CreateDeviceObject(DriverObject, &deviceObject, FALSE);

                if (NT_SUCCESS(ntStatus)) 
                {
                    //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice DONE creating new USB device object\n"));
                }//if
            }
            if (NT_SUCCESS(ntStatus)) 
            {
                PDEVICE_LIST_ENTRY device;
                
                deviceExtension = deviceObject->DeviceExtension;
                RtlZeroMemory(deviceExtension->DeviceData, MAX_DOWNSTREAM_DEVICES * sizeof(PUSBD_DEVICE_DATA));

                // We support buffered I/O only
                deviceObject->Flags |= DO_BUFFERED_IO;

                // 
                // remember the Physical device Object
                //
                deviceExtension->PhysicalDeviceObject=PhysicalDeviceObject;

                //
                // Attach to the PDO
                //
                //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice attaching device to Stack.\n"));

                //
                // The stackdeviceobject is what we use to send Urbs down the stack
                //
                deviceExtension->StackDeviceObject =
                    IoAttachDeviceToDeviceStack(deviceObject, PhysicalDeviceObject);

                RtlZeroMemory(deviceExtension->DeviceData, MAX_DOWNSTREAM_DEVICES * sizeof(PUSBD_DEVICE_DATA));

                if ((deviceExtension->StackDeviceObject) != NULL) 
                {

                    //passed the IoAttachDeviceToDeviceStack call
                    //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice successfully attached device to stack\n"));
                    
                    USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice stackDevObj: %X\n",deviceExtension->StackDeviceObject));
                    
                    USBDIAG_KdPrint(("USBDIAG.SYS: Saving in deviceExtension 0x%x.\n",
                                      deviceExtension));

                    if (gVersionInformation.USBDI_Version >= USBD_WIN98_SE_VERSION) // Win98 SE, Win2K and beyond
                    {
                        device = USBDIAG_ExAllocatePool(NonPagedPool, sizeof(DEVICE_LIST_ENTRY));

                        if (device) 
                        {
                            PDEVICE_OBJECT RootHubPdo = NULL;
                            PDEVICE_OBJECT TopOfHcdStackDeviceObject = NULL;

                            ASSERT(globalDeviceExtension != NULL);
                            device->Next = globalDeviceExtension->DeviceList;
                            globalDeviceExtension->DeviceList = device;
                            device->DeviceNumber = USBDIAG_NextDeviceNumber++;
                            device->PhysicalDeviceObject = PhysicalDeviceObject;
                            device->DeviceObject = deviceObject;

                            KeInitializeEvent(&deviceExtension->WaitWakeEvent, SynchronizationEvent, FALSE);


                            // Get the RootHubPdo & TopOfHcdStackDeviceObject
                            ntStatus = USBDIAG_SyncGetRootHubPdo(deviceExtension->StackDeviceObject,
                                                                                                                         PhysicalDeviceObject,
                                                                 &RootHubPdo,
                                                                 &TopOfHcdStackDeviceObject);

                            if (NT_SUCCESS(ntStatus))
                            {
                                ASSERT(RootHubPdo);
                                deviceExtension->RootHubPdo = RootHubPdo;

                                //ASSERT(TopOfHcdStackDeviceObject);
                                //deviceExtension->TopOfHcdStackDeviceObject = TopOfHcdStackDeviceObject;
                            }
                            else
                            {
                                ASSERT(FALSE);
                                deviceExtension->RootHubPdo = NULL;
                                deviceExtension->TopOfHcdStackDeviceObject = NULL;

                            }
                            ntStatus = STATUS_SUCCESS;
                        } //if device allocate was successful
                    }
                        
                }//if attach device was successful
                else
                {
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                    //USBDIAG_KdPrint(("USBDIAG.SYS: PnPAddDevice FAILED attaching device to stack\n"));
                } //else attach failed     

            }// if successfully created device object                

    } 
    else 
    {
        //
        // Given no physical device object, therefore asked to do detection.
        // This is a dream on as all USB controller are PCI devices.
        //

        ntStatus = STATUS_NO_MORE_ENTRIES;
    }//else no PDO given

    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_PnPAddDevice (%x)\n", ntStatus));

        if(NT_SUCCESS(ntStatus))
                USBDIAG_NumberDevices++;

    return ntStatus;
}


NTSTATUS
USBDIAG_CreateDeviceObject(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT *DeviceObject,
    BOOLEAN Global
    )
/*++

Routine Description:

    Creates a Functional DeviceObject for the diag driver
    
Arguments:

    DriverObject - pointer to the driver object for device

    DeviceObject - pointer to DeviceObject pointer to return
                    created device object.

    Global - create the global device object and symbolic link.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    WCHAR deviceLinkBuffer[]  = L"\\DosDevices\\USBDIAG";
    UNICODE_STRING deviceLinkUnicodeString;
    WCHAR deviceNameBuffer[]  = L"\\Device\\USBDIAG";
    UNICODE_STRING deviceNameUnicodeString;
    PDEVICE_EXTENSION deviceExtension;
    STRING deviceName;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_CreateDeviceObject\n"));


    //
    // fix up device names based on Instance
    //

    //USBDIAG_KdPrint(("USBDIAG.SYS: USBDIAG_CreateDeviceObject InitUnicode String\n"));

    RtlInitUnicodeString (&deviceNameUnicodeString,
                          deviceNameBuffer);


    //USBDIAG_KdPrint(("USBDIAG.SYS: USBDIAG_CreateDeviceObject Convert unicode to ansi\n"));

    //Print out the unicode string

    deviceName.Buffer = NULL;

    ntStatus = RtlUnicodeStringToAnsiString (&deviceName,
                                             &deviceNameUnicodeString, 
                                             TRUE);


    if (NT_SUCCESS(ntStatus)) {
        //USBDIAG_KdPrint(("USBDIAG.SYS: Create Device Name (%s)\n", deviceName.Buffer));
        RtlFreeAnsiString (&deviceName);
        if (!NT_SUCCESS(ntStatus)) {
            //USBDIAG_KdPrint(("USBDIAG.SYS: Failed freeing ansi string!\n"));
        }//if not successful ntstatus
    } else {
        //USBDIAG_KdPrint(("USBDIAG.SYS: Unicode to Ansi str failed w/ ntStatus: 0x%x\n",ntStatus));
    }

    
    //USBDIAG_KdPrint(("USBDIAG.SYS: USBDIAG_CreateDeviceObject IOCreateDevice \n"));

    ntStatus = IoCreateDevice (DriverObject,
                                   sizeof (DEVICE_EXTENSION),
                               Global ? &deviceNameUnicodeString : NULL,
                                   FILE_DEVICE_UNKNOWN,
                               0,
                                   FALSE,
                               DeviceObject);

    if (NT_SUCCESS(ntStatus)) {

        //
        // Initialize our device extension
        //
        
        deviceExtension = (PDEVICE_EXTENSION) ((*DeviceObject)->DeviceExtension);

        if (Global)
                {
            RtlInitUnicodeString (&deviceLinkUnicodeString,
                                  deviceLinkBuffer);
                                  
            //USBDIAG_KdPrint(("USBDIAG.SYS: Global: Create DosDevice name (%s)\n", deviceLinkBuffer));        
            
            ntStatus = IoCreateSymbolicLink (&deviceLinkUnicodeString,
                                             &deviceNameUnicodeString);

            RtlCopyMemory(deviceExtension->DeviceLinkNameBuffer, 
                      deviceLinkBuffer,        
                      sizeof(deviceLinkBuffer));
        }//if Global
                else
                {
                deviceExtension->Stopped = TRUE;
            (*DeviceObject)->Flags |= DO_POWER_PAGABLE;
                        (*DeviceObject)->Flags &= ~DO_DEVICE_INITIALIZING;
                }//else


        //Setup the ptr to the device extension for this device & init the Irp field (for now)
        //deviceExtension->IrpHead = NULL;

        InitializeListHead(&deviceExtension->ListHead);
        KeInitializeSpinLock(&deviceExtension->SpinLock);
        KeInitializeEvent(&deviceExtension->CancelEvent, NotificationEvent, FALSE);

        // this event is triggered when self-requested power irps complete
        //KeInitializeEvent(&deviceExtension->SelfRequestedPowerIrpEvent, NotificationEvent, FALSE);
        deviceExtension->SelfRequestedPowerIrpEvent = NULL;

        // initialize original power level as fully on
        deviceExtension->CurrentDeviceState.DeviceState = PowerDeviceD0;
        deviceExtension->CurrentSystemState.SystemState = PowerSystemWorking;

        deviceExtension->WaitWakeIrp  = NULL;
        deviceExtension->InterruptIrp = NULL;
   
    }//if ntsuccess 

    //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_CreateDeviceObject (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBDIAG_CallUSBD(
    IN PDEVICE_OBJECT DeviceObject,
    IN PURB Urb
    )
/*++

Routine Description:

    Passes a URB to the USBD class driver

Arguments:

    DeviceObject - pointer to the device object for this instance of an 82930  

    Urb - pointer to Urb request block

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PDEVICE_EXTENSION deviceExtension;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

        //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_CallUSBD\n"));

    deviceExtension = DeviceObject->DeviceExtension;

    //
    // issue a synchronous request   
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                deviceExtension->StackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    //
    // pass the URB to the USB driver stack
    // 
    nextStack->Parameters.Others.Argument1 = Urb;
    

    //USBDIAG_KdPrint(("USBDIAG.SYS: calling USBD\n"));

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject, 
                            irp);

    //USBDIAG_KdPrint(("USBDIAG.SYS: return from IoCallDriver USBD %x\n", ntStatus));

        {
                KIRQL irql;
                irql = KeGetCurrentIrql();
                ASSERT(irql <= PASSIVE_LEVEL);
        }

    if (ntStatus == STATUS_PENDING) {
        //USBDIAG_KdPrint(("USBDIAG.SYS: Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);    

        //USBDIAG_KdPrint(("USBDIAG.SYS: Wait for single object, returned %x\n", status));

    } else {
        ioStatus.Status = ntStatus;        
    }        

    //USBDIAG_KdPrint(("USBDIAG.SYS: URB status = %x status = %x irp status %x\n", 
//        Urb->UrbHeader.Status, status, ioStatus.Status));

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

        //USBDIAG_KdPrint(("USBDIAG.SYS: exit USBDIAG_CallUSBD (%x)\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBDIAG_RemoveGlobalDeviceObject(
    )
/*++

Routine Description:

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PDEVICE_EXTENSION globalDeviceExtension;
    UNICODE_STRING deviceLinkUnicodeString;
        KIRQL irql;

    //USBDIAG_KdPrint(("USBDIAG.SYS: enter USBDIAG_RemoveGlobalDeviceObjec\n"));    

        irql = KeGetCurrentIrql();
        ASSERT(irql <= PASSIVE_LEVEL);

    if (USBDIAG_GlobalDeviceObject != NULL) {
    
        globalDeviceExtension = USBDIAG_GlobalDeviceObject->DeviceExtension;

        //USBDIAG_KdPrint(("USBDIAG.SYS: USBDIAG_RemoveGlobalDeviceObject open frc = %x, list = %x\n",
                          //globalDeviceExtension->OpenFRC,
                          //globalDeviceExtension->DeviceList));    

        if ( globalDeviceExtension->DeviceList == NULL && 
             globalDeviceExtension->OpenFRC == 0) {

            //USBDIAG_KdPrint(("USBDIAG.SYS: Deleting global device object\n"));

            // delete our global device object once we have no more devices
        
            RtlInitUnicodeString (&deviceLinkUnicodeString,
                                  globalDeviceExtension->DeviceLinkNameBuffer);

            //USBDIAG_KdPrint(("USBDIAG.SYS: Deleting Symbolic Link (UnicodeStr) at addr %X\n",
                              //&deviceLinkUnicodeString));

            ntStatus = IoDeleteSymbolicLink(&deviceLinkUnicodeString);

            if (NT_SUCCESS(ntStatus)) {

                //USBDIAG_KdPrint(("USBDIAG.SYS: Deleting Global Device Object at addr %X\n",
                                //  USBDIAG_GlobalDeviceObject));

                IoDeleteDevice( USBDIAG_GlobalDeviceObject );
    
                USBDIAG_GlobalDeviceObject = NULL;

                //USBDIAG_KdPrint(("USBDIAG.SYS: Successfully Deleted Global Device Object\n"));
            
            }            
        }
    }

    return ntStatus;
}


#define MEM_SIGNATURE                   ((ULONG) 'CLLA')
#define MEM_FREED_SIGNATURE             ((ULONG) 'EERF')


PVOID
USBDIAG_ExAllocatePool(
    IN POOL_TYPE    PoolType,
    IN ULONG        NumberOfBytes
    )
{
        PULONG  pMem;

        // allocate memory plus a little extra for our own use
        pMem = ExAllocatePool(PoolType, NumberOfBytes + (2 * sizeof(ULONG)));

        // see if we actually allocated any memory
        if(pMem)
        {
                // store number of bytes allocated at start of memory allocated
                *pMem++ = NumberOfBytes;

                // now we are pointing at the memory allocated for caller
                // put signature word at end

                // get new pointer that points to end of buffer - ULONG
                pMem = (PULONG) (((PUCHAR) pMem) + NumberOfBytes);

                // write signature
                *pMem = MEM_SIGNATURE;

                // get back pointer to return to caller
                pMem = (PULONG) (((PUCHAR) pMem) - NumberOfBytes);

        gulMemoryAllocated += NumberOfBytes;
        //USBDIAG_KdPrint(("USBDIAG_ExAllocatePool: bytes allocated: %d\n", gulMemoryAllocated));
        }

        return (PVOID) pMem;    
}

VOID
USBDIAG_ExFreePool(
    IN PVOID    P
    )
{
        PULONG  pTmp = (PULONG) P;
        ULONG   buffSize;
        //PULONG  pSav=pTmp;
        
        // point at size ULONG at start of buffer, and address to free
        pTmp--;

        // get the size of memory allocated by caller
        buffSize = *pTmp;

        // point at signature and make sure it's O.K.
        ((PCHAR) P) += buffSize;

        if(*((PULONG) P) == MEM_SIGNATURE)
        {
                // let's go ahead and get rid of signature in case we get called
                // with this pointer again and memory is still paged in
                *((PULONG) P) = MEM_FREED_SIGNATURE;
                
                // free real pointer
                ExFreePool(pTmp);

        gulMemoryAllocated -= buffSize;

        //USBDIAG_KdPrint(("USBDIAG_ExFreePool: bytes allocated: %d\n", gulMemoryAllocated));
        }
        else {
                TRAP();
    }//else    
}

NTSTATUS
USBDIAG_ResetParentPort(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Reset the our parent port

Arguments:

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus, status = STATUS_SUCCESS;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
    PDEVICE_EXTENSION deviceExtension = DeviceObject->DeviceExtension;//USBDIAG_GlobalDeviceObject->DeviceExtension;

    USBDIAG_KdPrint(("enter USBDIAG_ResetParentPort\n"));

    ASSERT(deviceExtension);
    ASSERT(deviceExtension->StackDeviceObject);

    if (!deviceExtension->StackDeviceObject)
        return STATUS_UNSUCCESSFUL;
    //
    // issue a synchronous request
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);


    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_RESET_PORT,
                deviceExtension->StackDeviceObject,
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the class driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);

    USBDIAG_KdPrint(("USBDIAG_ResetParentPort() calling USBD enable port api\n"));

    ntStatus = IoCallDriver(deviceExtension->StackDeviceObject,
                            irp);
                            
    USBDIAG_KdPrint(("USBDIAG_ResetParentPort() return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) 
    {
        USBDIAG_KdPrint(("USBDIAG_ResetParentPort() Wait for single object\n"));

        status = KeWaitForSingleObject(
                       &event,
                       Suspended,
                       KernelMode,
                       FALSE,
                       NULL);

        USBDIAG_KdPrint(("USBDIAG_ResetParentPort() Wait for single object, returned %x\n", status));
    } 
    else 
    {
        ioStatus.Status = ntStatus;
    }

    //
    // USBD maps the error code for us
    //
    ntStatus = ioStatus.Status;

    USBDIAG_KdPrint(("Exit USBDIAG_ResetPort (%x)\n", ntStatus));

    return ntStatus;
}

// *************************************
PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ);

// **************************************************************************
// **************************************************************************
// downstream manipulation routines

NTSTATUS
USBDIAG_RemoveDownstreamDevice(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PUSBD_PIPE defaultPipe = &DeviceData->DefaultPipe;

        //USBDIAG_KdPrint(("- USBDIAG_RemoveDownstreamDevice calling USBD_CloseEndpoint -\n"));
    ntStatus = USBD_CloseEndpoint(DeviceData,
                                  DeviceObject,
                                  defaultPipe,
                                  NULL);

    DeviceData = NULL;

    return ntStatus;

}

NTSTATUS
USBDIAG_Chap11SetConfiguration(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

        ASSERT(DeviceObject);

    USBDIAG_KdPrint(("USBDIAG_Chap11SetConfiguration: DeviceData 0x%x (& 0x%x), DeviceObject 0x%x\n",
                     *DeviceData,
                     DeviceData,
                     DeviceObject));

    ntStatus = USBD_SendCommand(DeviceData,
                                DeviceObject,
                                STANDARD_COMMAND_SET_CONFIGURATION,
                                0x01,   // wValue  = 1
                                0,      // wIndex  = 0
                                0,      // wLength = 0
                                NULL,
                                0,
                                NULL,
                                NULL);

    return ntStatus;
}

NTSTATUS
USBDIAG_Chap11EnableRemoteWakeup(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    NTSTATUS ntStatus = STATUS_SUCCESS;

    ASSERT(DeviceData);

    USBDIAG_KdPrint(("USBDIAG_Chap11EnableRemoteWakeup: DeviceData 0x%x (& 0x%x), DeviceObject 0x%x\n",
                     *DeviceData,
                     DeviceData,
                     DeviceObject));

    ntStatus = USBD_SendCommand(DeviceData,
                                DeviceObject,
                                STANDARD_COMMAND_SET_DEVICE_FEATURE,
                                0x01,   // wValue  = 2 for rwu
                                0,      // wIndex  = 0
                                0,      // wLength = 0
                                NULL,
                                0,
                                NULL,
                                NULL);

    return ntStatus;
}

NTSTATUS
USBDIAG_Chap11SendPacketDownstream(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
        IN PREQ_SEND_PACKET_DOWNSTREAM pSendPacketDownstream
    )
{
    NTSTATUS                     ntStatus               = STATUS_SUCCESS;
        PCHAP11_SETUP_PACKET pSetupPacket       = &pSendPacketDownstream->SetupPacket;
        PUCHAR                           pucTempBuffer  = NULL;

    if (pSetupPacket->wLength)
    {
        pucTempBuffer = ExAllocatePool(NonPagedPool, pSetupPacket->wLength);
            if (!pucTempBuffer)
                    return STATUS_INSUFFICIENT_RESOURCES;
    }


    ASSERT(DeviceData);

    ntStatus = USBD_SendCommand(DeviceData,
                                DeviceObject,
                                pSetupPacket->wRequest,
                                pSetupPacket->wValue,
                                pSetupPacket->wIndex,
                                                                pSetupPacket->wLength,
                                pucTempBuffer,
                                pSetupPacket->wLength,
                                &pSendPacketDownstream->dwBytes,
                                &pSendPacketDownstream->ulUrbStatus);

    if (NT_SUCCESS(ntStatus) && pSetupPacket->wLength && pSendPacketDownstream->pucBuffer)
    {
        RtlCopyMemory(pSendPacketDownstream->pucBuffer, pucTempBuffer, pSendPacketDownstream->dwBytes);
    }

    if (pSetupPacket->wLength && pSendPacketDownstream->pucBuffer && pucTempBuffer)
    {
        ExFreePool(pucTempBuffer);
        pucTempBuffer = NULL;
    }

    return ntStatus;
}

NTSTATUS
USBDIAG_CreateInitDownstreamDevice(
    PREQ_ENUMERATE_DOWNSTREAM_DEVICE pEnumerate,
    PDEVICE_EXTENSION deviceExtension
    )
{
    NTSTATUS    ntStatus            = STATUS_SUCCESS;
    UCHAR       ucPortNumber        = pEnumerate->ucPortNumber;
    PUSBD_DEVICE_DATA DeviceData    = NULL; 
    BOOLEAN     bLowSpeed           = pEnumerate->bLowSpeed;
    ULONG       MaxPacketSize0      = 8;
    ULONG       DeviceHackFlags;

    PUSB_DEVICE_DESCRIPTOR deviceDescriptor = NULL;
    ULONG deviceDescriptorLength = 0;
        PUSB_CONFIGURATION_DESCRIPTOR configDescriptor = NULL;
        ULONG configDescriptorLength = 0;

    if (deviceExtension->DeviceData[ucPortNumber])
        return STATUS_SUCCESS;

        USBDIAG_KdPrint(("***************************************************\n"));
    USBDIAG_KdPrint(("USBDIAG.SYS: REQ_FUNCTION_CHAP11_CREATE_USBD_DEVICE\n"));
    USBDIAG_KdPrint(("- Downstream device:\n"));
    USBDIAG_KdPrint(("- Port:     %d\n",   pEnumerate->ucPortNumber));
    USBDIAG_KdPrint(("- Lowspeed: %d\n",   pEnumerate->bLowSpeed));

        if (!deviceExtension->RootHubPdo)
                return STATUS_INVALID_PARAMETER;

    ntStatus = USBD_CreateDevice(&DeviceData,
                               deviceExtension->RootHubPdo,
                               bLowSpeed, 
                               MaxPacketSize0,
                               &DeviceHackFlags);

    USBDIAG_KdPrint(("* After USBD_CreateDevice, DeviceData = 0x%x\n", DeviceData));

    if (NT_SUCCESS(ntStatus))
    {
        ASSERT(DeviceData);

        //USBDIAG_KdPrint(("deviceExtension->DeviceData[%d] = 0x%x\n", deviceExtension->DeviceData[ucPortNumber]));


        deviceDescriptorLength = sizeof(USB_DEVICE_DESCRIPTOR);
        deviceDescriptor = ExAllocatePool(NonPagedPool, deviceDescriptorLength);

        if (!deviceDescriptor)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
                else
                {
                        configDescriptorLength = 0xFF;
                        configDescriptor = ExAllocatePool(NonPagedPool, configDescriptorLength);
                }

                if (!configDescriptor)
                {
                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

    }

    if (NT_SUCCESS(ntStatus))
    { 
                USBDIAG_KdPrint(("== Chap9Control calling USBD_InitializeDevice ==\n"));
        ntStatus = USBD_InitializeDevice(DeviceData,
                                                                                 deviceExtension->RootHubPdo,
                                         deviceDescriptor,
                                         deviceDescriptorLength,
                                                                                 configDescriptor,
                                                                                 configDescriptorLength); 

        }

    if (NT_SUCCESS(ntStatus))
    {
        deviceExtension->DeviceData[ucPortNumber] = DeviceData;

        USBDIAG_KdPrint(("SAVING...\n"));
        USBDIAG_KdPrint(("PortNumber: %d\n", ucPortNumber));
        USBDIAG_KdPrint(("DeviceData: 0x%x\n", DeviceData));

        if (configDescriptor)
        {
            deviceExtension->DownstreamConfigDescriptor[ucPortNumber] = configDescriptor;
        }
        else
        {
            USBDIAG_KdPrint(("configDescriptor after USBD_InitializeDevice is NULL\n!"));
        }

        //USBDIAG_KdPrint(("deviceExtension->DeviceData[%d]: 0x%x\n", 
                          //ucPortNumber,
                          //deviceExtension->DeviceData[ucPortNumber]));

        //USBDIAG_KdPrint(("deviceExtension: 0x%x\n", deviceExtension));
        //USBDIAG_KdPrint(("deviceExtension->DeviceData: 0x%x\n", 
                           //deviceExtension->DeviceData));
        //USBDIAG_KdPrint(("&deviceExtension->DeviceData[0]: 0x%x\n", 
                          //&deviceExtension->DeviceData[0]));
        //USBDIAG_KdPrint(("&deviceExtension->DeviceData[%d]: 0x%x\n", 
                          //ucPortNumber,
                          //&deviceExtension->DeviceData[ucPortNumber]));

    }

        if (!deviceExtension->DeviceData[ucPortNumber])
    {
        USBDIAG_KdPrint(("Attempt to create/init downstream device FAILED!\n"));
                ntStatus = STATUS_UNSUCCESSFUL;
    }

    return ntStatus;
}

NTSTATUS
USBDIAG_SetCfgEnableRWu(
    PDEVICE_EXTENSION deviceExtension, 
    PREQ_ENUMERATE_DOWNSTREAM_DEVICE pEnumerate
    )
{
    UCHAR ucPortNumber = pEnumerate->ucPortNumber;
    PUSBD_DEVICE_DATA DeviceData = deviceExtension->DeviceData[ucPortNumber];
    NTSTATUS ntStatus = STATUS_INVALID_PARAMETER;
    PUSB_CONFIGURATION_DESCRIPTOR configDescriptor = deviceExtension->DownstreamConfigDescriptor[ucPortNumber];


        USBDIAG_KdPrint(("*************************************************\n"));
    USBDIAG_KdPrint(("USBDIAG.SYS: REQ_FUNCTION_CHAP11_INIT_USBD_DEVICE\n"));
    USBDIAG_KdPrint(("PortNumber: %d\n", ucPortNumber));
    USBDIAG_KdPrint(("DeviceData: 0x%x\n", DeviceData));
    USBDIAG_KdPrint(("deviceExtension->DeviceData[%d]: 0x%x\n", 
                      ucPortNumber,
                      deviceExtension->DeviceData[ucPortNumber]));

        ASSERT(deviceExtension->RootHubPdo);

        ASSERT(DeviceData);

        USBDIAG_KdPrint(("- Chap9Control calling USBDIAG_Chap11SetConfiguration -\n"));
        if (DeviceData)
        {
                ntStatus = USBDIAG_Chap11SetConfiguration(DeviceData,
                                                                                                  deviceExtension->RootHubPdo);

        USBDIAG_KdPrint(("Set Config On Downstream Device On Port %d %s\n",
                         ucPortNumber,
                         NT_SUCCESS(ntStatus) ? "Passed" : "FAILED"));


                if (NT_SUCCESS(ntStatus))
                {
            if (configDescriptor->bmAttributes & REMOTE_WAKEUP)
            {
                            USBDIAG_KdPrint((" Chap9Control calling USBDIAG_Chap11EnableRemoteWakeup -\n"));
                            ntStatus = USBDIAG_Chap11EnableRemoteWakeup(DeviceData,
                                                                                                                    //deviceExtension->StackDeviceObject);
                                                                                                                    deviceExtension->RootHubPdo);
                USBDIAG_KdPrint(("Enable RWu On Downstream Device On Port %d %s\n",
                                 ucPortNumber,
                                 NT_SUCCESS(ntStatus) ? "Passed" : "FAILED"));
            }
                }
    }
    return ntStatus;
}

NTSTATUS
USBD_SendCommand(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN USHORT RequestCode,
    IN USHORT WValue,
    IN USHORT WIndex,
    IN USHORT WLength,
    IN PVOID Buffer,
    IN ULONG BufferLength,
    OUT PULONG BytesReturned,
    OUT USBD_STATUS *UsbStatus
    )
/*++

Routine Description:

    Send a standard USB command on the default pipe.

Arguments:

    DeviceData - ptr to USBD device structure the command will be sent to

    DeviceObject -

    RequestCode -

    WValue - wValue for setup packet

    WIndex - wIndex for setup packet

    WLength - wLength for setup packet

    Buffer - Input/Output Buffer for command                                                                                                                                                                                                                  
  BufferLength - Length of Input/Output buffer.

    BytesReturned - pointer to ulong to copy number of bytes
                    returned (optional)

    UsbStatus - USBD status code returned in the URB.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb = NULL;
    PUSBD_PIPE defaultPipe = &(DeviceData->DefaultPipe);
    PUSB_STANDARD_SETUP_PACKET setupPacket;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    //USBDIAG_KdPrint(("enter USBD_SendCommand\n"));
    ASSERT_DEVICE(DeviceData);

    deviceExtension = DeviceObject->DeviceExtension;
    

    if (deviceExtension->DeviceHackFlags & 
        USBD_DEVHACK_SLOW_ENUMERATION) {
        
        //
        // if noncomplience switch is on in the
        // registry we'll pause here to give the
        // device a chance to respond.
        //
        
        LARGE_INTEGER deltaTime;
        deltaTime.QuadPart = 100 * -10000;
        (VOID) KeDelayExecutionThread(KernelMode,
                                      FALSE,
                                      &deltaTime);
    }

    urb = ExAllocatePool(NonPagedPool,
                  sizeof(struct _URB_CONTROL_TRANSFER));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_CONTROL_TRANSFER);

        urb->UrbHeader.Function = URB_FUNCTION_CONTROL_TRANSFER;

        setupPacket = (PUSB_STANDARD_SETUP_PACKET) 
            urb->HcdUrbCommonTransfer.Extension.u.SetupPacket;
        setupPacket->RequestCode = RequestCode;
        setupPacket->wValue = WValue;
        setupPacket->wIndex = WIndex;
        setupPacket->wLength = WLength;

        urb->HcdUrbCommonTransfer.hca.HcdEndpoint = defaultPipe->HcdEndpoint;
        urb->HcdUrbCommonTransfer.TransferFlags = USBD_SHORT_TRANSFER_OK;

        // USBD is responsible for setting the transfer direction
        //
        // TRANSFER direction is implied in the command

        if (RequestCode & USB_DEVICE_TO_HOST)
            USBD_SET_TRANSFER_DIRECTION_IN(urb->HcdUrbCommonTransfer.TransferFlags);
        else
            USBD_SET_TRANSFER_DIRECTION_OUT(urb->HcdUrbCommonTransfer.TransferFlags);

        urb->HcdUrbCommonTransfer.TransferBufferLength = BufferLength;
        urb->HcdUrbCommonTransfer.TransferBuffer = Buffer;
        urb->HcdUrbCommonTransfer.TransferBufferMDL = NULL;
        urb->HcdUrbCommonTransfer.UrbLink = NULL;

        //USBDIAG_KdPrint(("SendCommand cmd = 0x%x buffer = 0x%x length = 0x%x direction = 0x%x\n",
                         //setupPacket->RequestCode,
                         //urb->HcdUrbCommonTransfer.TransferBuffer,
                         //urb->HcdUrbCommonTransfer.TransferBufferLength,
                         //urb->HcdUrbCommonTransfer.TransferFlags
                         //));

        ntStatus = USBD_SubmitSynchronousURB((PURB)urb, DeviceObject, DeviceData);

        if (BytesReturned) {
            *BytesReturned = urb->HcdUrbCommonTransfer.TransferBufferLength;
        }            

        if (UsbStatus) {
            *UsbStatus = urb->HcdUrbCommonTransfer.Status;
        }            

        // free the transfer URB

        ExFreePool(urb);

    }

    //USBDIAG_KdPrint(("exit USBD_SendCommand 0x%x\n", ntStatus));

    return ntStatus;
}


NTSTATUS
USBD_CloseEndpoint(
    IN PUSBD_DEVICE_DATA DeviceData,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_PIPE PipeHandle,
    IN OUT USBD_STATUS *UsbStatus
    )
/*++

Routine Description:

    Close an Endpoint

Arguments:

    DeviceData - ptr to USBD device data structure.

    DeviceObject - USBD device object.

    PipeHandle - USBD pipe handle associated with the endpoint.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus;
    PHCD_URB urb;
    PUSBD_EXTENSION deviceExtension;

    PAGED_CODE();
    //USBDIAG_KdPrint(("enter USBD_CloseEndpoint\n"));
    ASSERT_DEVICE(DeviceData);

    deviceExtension = DeviceObject->DeviceExtension;

    urb = ExAllocatePool(NonPagedPool,
                  sizeof(struct _URB_HCD_CLOSE_ENDPOINT));

    if (!urb) {
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
    } else {

        urb->UrbHeader.Length = sizeof(struct _URB_HCD_CLOSE_ENDPOINT);
        urb->UrbHeader.Function = URB_FUNCTION_HCD_CLOSE_ENDPOINT;


        urb->HcdUrbCloseEndpoint.HcdEndpoint = PipeHandle->HcdEndpoint;

        //
        // Serialize Close Endpoint requests
        //

        ntStatus = USBD_SubmitSynchronousURB((PURB) urb, DeviceObject, 
                DeviceData);

       if (UsbStatus)
            *UsbStatus = urb->UrbHeader.Status;

        ExFreePool(urb);
    }

    //USBDIAG_KdPrint(("exit USBD_CloseEndpoint 0x%x\n", ntStatus));

    return ntStatus;
}




// downstream manipulation routines done
// **************************************************************************
// **************************************************************************

NTSTATUS
USBDIAG_WaitForWakeup(
    PDEVICE_EXTENSION deviceExtension
    )
{
    NTSTATUS ntStatus;
    
    USBDIAG_KdPrint(("'USBDIAG_WaitForWakeup: Waiting for Wait/Wake completion event\n"));

    USBDIAG_KdPrint(("Waiting for WaitWakeEvent...\n"));
    ntStatus = KeWaitForSingleObject(&deviceExtension->WaitWakeEvent,
                                     Suspended,
                                     KernelMode,
                                     FALSE,
                                     NULL);

    USBDIAG_KdPrint(("'WaitWakeEvent Signalled, Clearing ...\n"));
    KeClearEvent(&deviceExtension->WaitWakeEvent);

    return ntStatus;
}







PWCHAR
GetString(PWCHAR pwc, BOOLEAN MultiSZ)
{
    PWCHAR  psz, p;
    SIZE_T  Size;

    PAGED_CODE();
    psz=pwc;
    while (*psz!='\0' || (MultiSZ && *(psz+1)!='\0')) {
        psz++;
    }

    Size=(psz-pwc+1+(MultiSZ ? 1: 0))*sizeof(*pwc);

    // We use pool here because these pointers are passed
    // to the PnP code who is responsible for freeing them
    if ((p=ExAllocatePool(PagedPool, Size))!=NULL) {
        RtlCopyMemory(p, pwc, Size);
    }

    return(p);
}

#if DBG
ULONG USBD_Debug_Trace_Level =
#ifdef MAX_DEBUG
9;
#else
#ifdef NTKERN
1;
#else
0;
#endif /* NTKERN */
#endif /* MAX_DEBUG */
#endif /* DBG */

#ifdef DEBUG_LOG
struct USBD_LOG_ENTRY {
    CHAR    le_name[4];        // Identifying string
    ULONG    le_info1;        // entry specific info
    ULONG    le_info2;        // entry specific info
    ULONG    le_info3;        // entry specific info
}; /* USBD_LOG_ENTRY */


struct USBD_LOG_ENTRY *LStart = 0;    // No log yet
struct USBD_LOG_ENTRY *LPtr;
struct USBD_LOG_ENTRY *LEnd;
#endif /* DEBUG_LOG */






#if DBG
ULONG
_cdecl
USBD_KdPrintX(
    PCH Format,
    ...
    )
{
    va_list list;
    int i;
    int arg[5];

    if (USBD_Debug_Trace_Level == 1) {
        DbgPrint("USBD: ");
    } else {        
        DbgPrint("'USBD: ");
    }        
    va_start(list, Format);
    for (i=0; i<4; i++)
        arg[i] = va_arg(list, int);

    DbgPrint(Format, arg[0], arg[1], arg[2], arg[3]);

    return 0;
}


VOID
USBD_Warning(
    PUSBD_DEVICE_DATA DeviceData,
    PUCHAR Message,
    BOOLEAN DebugBreak
    )
{                                                                                               
    DbgPrint("USBD: Warning ****************************************************************\n");
    if (DeviceData) {
        DbgPrint("Device PID %04.4x, VID %04.4x\n",     
                 DeviceData->DeviceDescriptor.idProduct, 
                 DeviceData->DeviceDescriptor.idVendor); 
    }
    DbgPrint("%s", Message);

    DbgPrint("******************************************************************************\n");

//    if (DebugBreak) {
//        DBGBREAK();
//    }
}
 

VOID
USBD_Assert(
    IN PVOID FailedAssertion,
    IN PVOID FileName,
    IN ULONG LineNumber,
    IN PCHAR Message
    )
/*++

Routine Description:

    Debug Assert function.

Arguments:

    DeviceObject - pointer to a device object

    Irp          - pointer to an I/O Request Packet

Return Value:


--*/
{
#ifdef NTKERN  
    // this makes the compiler generate a ret
    ULONG stop = 1;
    
assert_loop:
#endif
    // just call the NT assert function and stop
    // in the debugger.
    RtlAssert( FailedAssertion, FileName, LineNumber, Message );

    // loop here to prevent users from going past
    // are assert before we can look at it
#ifdef NTKERN    
    DBGBREAK();
    if (stop) {
        goto assert_loop;
    }        
#endif
    return;
}
#endif /* DBG */

#define DEADMAN_TIMER
#define DEADMAN_TIMEOUT     5000     //timeout in ms
                                     //use a 5 second timeout
typedef struct _USBD_DEADMAN_TIMER {
    PIRP Irp;
    KTIMER TimeoutTimer;
    KDPC TimeoutDpc;
} USBD_DEADMAN_TIMER, *PUSBD_DEADMAN_TIMER;


NTSTATUS
USBD_SubmitSynchronousURB(
    IN PURB Urb,
    IN PDEVICE_OBJECT DeviceObject,
    IN PUSBD_DEVICE_DATA DeviceData
    )
/*++

Routine Description:

    Submit a Urb to HCD synchronously

Arguments:

    Urb - Urb to submit

    DeviceObject USBD device object

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;
//#ifdef DEADMAN_TIMER
#if 0
    BOOLEAN haveTimer = FALSE;
    PUSBD_DEADMAN_TIMER timer;
#endif /* DEADMAN_TIMER */     

    PAGED_CODE();

    //USBDIAG_KdPrint(("enter USBD_SubmitSynchronousURB\n"));
    ASSERT_DEVICE(DeviceData);

    irp = IoBuildDeviceIoControlRequest(
                IOCTL_INTERNAL_USB_SUBMIT_URB,
                HCD_DEVICE_OBJECT(DeviceObject),
                NULL,
                0,
                NULL,
                0,
                TRUE, /* INTERNAL */
                &event,
                &ioStatus);

    //
    // Call the hc driver to perform the operation.  If the returned status
    // is PENDING, wait for the request to complete.
    //

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    nextStack = IoGetNextIrpStackLocation(irp);
    ASSERT(nextStack != NULL);
    nextStack->Parameters.Others.Argument1 = Urb;

    //
    // initialize flags field
    // for internal request
    //
    Urb->UrbHeader.UsbdFlags = 0;

    //
    // Init the Irp field for transfers
    //

    switch(Urb->UrbHeader.Function) {
    case URB_FUNCTION_CONTROL_TRANSFER:
    case URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER:
        HC_URB(Urb)->HcdUrbCommonTransfer.hca.HcdIrp = irp;

        if (HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL == NULL &&
            HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferLength != 0) {

            if ((HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL =
                IoAllocateMdl(HC_URB(Urb)->HcdUrbCommonTransfer.TransferBuffer,
                              HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferLength,
                              FALSE,
                              FALSE,
                              NULL)) == NULL)
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            else {
                Urb->UrbHeader.UsbdFlags |= USBD_REQUEST_MDL_ALLOCATED;
                MmBuildMdlForNonPagedPool(HC_URB(Urb)->HcdUrbCommonTransfer.TransferBufferMDL);
            }

        }
        break;
    }

    //USBDIAG_KdPrint(("USBD_SubmitSynchronousURB: calling HCD with URB\n"));

    if (NT_SUCCESS(ntStatus)) {
        // set the renter bit on the URB function code
        Urb->UrbHeader.Function |= 0x2000;
        
        ntStatus = IoCallDriver(HCD_DEVICE_OBJECT(DeviceObject),
                                irp);
    }                                

    //USBDIAG_KdPrint(("ntStatus from IoCallDriver = 0x%x\n", ntStatus));

    status = STATUS_SUCCESS;
    if (ntStatus == STATUS_PENDING) {
    
//#ifdef DEADMAN_TIMER
#if 0

        LARGE_INTEGER dueTime;

        timer = ExAllocatePool(NonPagedPool, sizeof(USBD_DEADMAN_TIMER));
        if (timer) {
            timer->Irp = irp;
            KeInitializeTimer(&timer->TimeoutTimer);
            KeInitializeDpc(&timer->TimeoutDpc,
                            USBD_SyncUrbTimeoutDPC,
                            timer);

            dueTime.QuadPart = -10000 * DEADMAN_TIMEOUT;

            KeSetTimer(&timer->TimeoutTimer,
                       dueTime,
                       &timer->TimeoutDpc);        

            haveTimer = TRUE;
        }
        
#endif /* DEADMAN_TIMER */           

        status = KeWaitForSingleObject(
                            &event,
                            Suspended,
                            KernelMode,
                            FALSE,
                            NULL);  
                            
        ntStatus = ioStatus.Status;
    } else {
        ioStatus.Status = ntStatus;
    }   

//#ifdef DEADMAN_TIMER
#if 0
    //
    // remove our timeoutDPC from the queue
    //
    if (haveTimer) {
        KeCancelTimer(&timer->TimeoutTimer);
        ExFreePool(timer);
    }                
#endif /* DEADMAN_TIMER */

// NOTE:
// mapping is handled by completion routine
// called by HCD

    //USBDIAG_KdPrint(("Leave Synch URB urb status = 0x%x ntStatus = 0x%x\n", Urb->UrbHeader.Status, ntStatus));

    return ntStatus;
}



NTSTATUS 
USBDIAG_SyncGetRootHubPdo(
        IN PDEVICE_OBJECT     StackDeviceObject,
    IN PDEVICE_OBJECT     PhysicalDeviceObject,
    IN OUT PDEVICE_OBJECT *RootHubPdo,
    IN OUT PDEVICE_OBJECT *TopOfHcdStackDeviceObject
    )
{
    NTSTATUS ntStatus, status;
    PIRP irp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    PIO_STACK_LOCATION nextStack;

    PAGED_CODE();
    
    USBDIAG_KdPrint(("enter USBDIAG_SyncGetRootHubPdo\n"));

    //
    // issue a synchronous request to the RootHubBdo
    //
    KeInitializeEvent(&event, NotificationEvent, FALSE);

        //USBDIAG_KdPrint(("USBDIAG_SyncGetRootHubPdo: ioctl code: 0x%x\n", IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO));

    irp = IoBuildDeviceIoControlRequest(IOCTL_INTERNAL_USB_GET_PARENT_HUB_INFO,
                                     //StackDeviceObject, //PhysicalDeviceObject,
                                     PhysicalDeviceObject,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     TRUE,  // INTERNAL
                                     &event,
                                     &ioStatus);

    if (NULL == irp) {
        USBDIAG_KdPrint(("USBUSBDIAG_SyncGetRootHubPdo build Irp failed\n"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // Call the class driver to perform the operation.  If the returned
    // status
    // is PENDING, wait for the request to complete.
    //
    nextStack = IoGetNextIrpStackLocation(irp);
        //nextStack = IoGetCurrentIrpStackLocation(irp);

    //
    // pass the URB to the USBD 'class driver'
    //
    nextStack->Parameters.Others.Argument1 = NULL;
    nextStack->Parameters.Others.Argument2 = NULL;
    //nextStack->Parameters.Others.Argument3 = NULL;
    nextStack->Parameters.Others.Argument4 = RootHubPdo;

// _asm int 3

    ntStatus = IoCallDriver(PhysicalDeviceObject, irp);

    USBDIAG_KdPrint(("return from IoCallDriver USBD %x\n", ntStatus));

    if (ntStatus == STATUS_PENDING) 
    {
        USBDIAG_KdPrint(("Wait for single object\n"));

        status = KeWaitForSingleObject(&event,
                                       Suspended,
                                       KernelMode,
                                       FALSE,
                                       NULL);

        USBDIAG_KdPrint(("Wait for single object, returned %x\n", status));
    } else {
        ioStatus.Status = ntStatus;
    }

    ntStatus = ioStatus.Status;

    USBDIAG_KdPrint(("exit USBDIAG_SyncGetRootHubPdo with ntStatus: 0x%x)\n", ntStatus));

    return ntStatus;
}


//#ifdef DEADMAN_TIMER
#if 0
VOID
USBD_SyncUrbTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine runs at DISPATCH_LEVEL IRQL. 

    
    
Arguments:

    Dpc - Pointer to the DPC object.

    DeferredContext - 

    SystemArgument1 - not used.
    
    SystemArgument2 - not used.

Return Value:

    None.

--*/
{
    PUSBD_DEADMAN_TIMER timer;
#if DBG
    BOOLEAN status;
#endif

    timer = DeferredContext;    

    
#if DBG
    status = 
#endif
        IoCancelIrp(timer->Irp);

#if DBG
    USBD_ASSERT(status == TRUE);    
#endif    
}
#endif /* DEADMAN_TIMER */

NTSTATUS
USBD_SetPdoRegistryParameter (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PWCHAR KeyName,
    IN ULONG KeyNameLength,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType,
    IN ULONG DevInstKeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus;
    HANDLE handle;
    UNICODE_STRING keyNameUnicodeString;

    PAGED_CODE();

    RtlInitUnicodeString(&keyNameUnicodeString, KeyName);

    ntStatus=IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                     DevInstKeyType,
                                     STANDARD_RIGHTS_ALL,
                                     &handle);


    if (NT_SUCCESS(ntStatus)) {

        USBD_SetRegistryKeyValue(handle,
                                 &keyNameUnicodeString,
                                 Data,
                                 DataLength,
                                 KeyType);

        ZwClose(handle);
    }

    //USBDIAG_KdPrint((" RtlQueryRegistryValues status 0x%x\n"));

    return ntStatus;
}


NTSTATUS
USBD_SetRegistryKeyValue (
    IN HANDLE Handle,
    IN PUNICODE_STRING KeyNameUnicodeString,
    IN PVOID Data,
    IN ULONG DataLength,
    IN ULONG KeyType
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_INSUFFICIENT_RESOURCES;

    PAGED_CODE();

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    ntStatus = ZwSetValueKey(Handle,
                             KeyNameUnicodeString,
                             0,
                             KeyType,
                             Data,
                             DataLength);

    //USBDIAG_KdPrint((" ZwSetKeyValue = 0x%x\n", ntStatus));

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\exe\tst.c ===
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//


#include <windows.h>

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>


#include "devioctl.h"

#include "usbdi.h"

#include "..\chap9drv.h"
#include "..\ioctl.h"

HANDLE hDiag, hHcd;

struct _REQ_DEVICE_HANDLES buf;

HANDLE
open_dev(char *devname)
{

	char completeDeviceName[64] = "";
	//char devname[] = "UTBD0";
	int success = 1;
	HANDLE h;


	strcat (completeDeviceName,
            "\\\\.\\"
            );

    strcat (completeDeviceName,
			devname
            );
    printf("completeDeviceName = (%s)\n", completeDeviceName);
	h = CreateFile(completeDeviceName,
		GENERIC_WRITE,
		FILE_SHARE_WRITE,
		NULL,
		OPEN_EXISTING,
		0,
		NULL);

	if (h == INVALID_HANDLE_VALUE) {
		printf("Failed to open (%s) = %d\n", completeDeviceName, GetLastError());
		success = 0;
	}
	else
		printf("Opened successfully.\n");

	return h;
}

void
rw_diag()
{
	BOOLEAN success;
	int siz, nBytes, i;
	int *p;

	siz = sizeof(buf);

	if (hDiag == INVALID_HANDLE_VALUE) {
		printf("HCD not open");
		return;
	}
	
	success = DeviceIoControl(hDiag,
			IOCTL_USBDIAG_CHAP9_GET_DEVHANDLE,
			&buf,
			siz,
			&buf,
			siz,
			&nBytes,
			NULL);

	printf("request complete, success = %d nBytes = %d\n", success, nBytes);
	if (success) {
		printf("devhandle %x\n",  buf.DeviceHandle);
		printf("nextdevhandle %x\n",	buf.NextDeviceHandle);
		printf("str %s\n",	buf.DeviceString);
	}
	
	return;

}

void
rw_usb()
{
	BOOLEAN success;
	int siz, nBytes, i;
	int *p;
	ULONG buf[2];

	siz = sizeof(buf);

	if (hHcd == INVALID_HANDLE_VALUE) {
		printf("HCD not open");
		return;
	}
	
	success = DeviceIoControl(hHcd,
			IOCTL_USB_DIAGNOSTIC_MODE_ON,
			buf,
			siz,
			buf,
			siz,
			&nBytes,
			NULL);

	printf("request complete, success = %d nBytes = %d\n", success, nBytes);
	if (success)
	   printf("iobase = %x pqh phys address = %x\n", buf[0], buf[1]);
	
	return;
}

int _cdecl main(
    int argc,
	char *argv[])
{

    if ((hHcd = open_dev("HCD0")) != INVALID_HANDLE_VALUE) {
		rw_usb();
	}

	if ((hDiag = open_dev("USBDIAG")) != INVALID_HANDLE_VALUE) {
		buf.DeviceHandle = NULL;
		rw_diag();
		buf.DeviceHandle = buf.NextDeviceHandle;
		rw_diag();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\usbloop.h ===
/****************************************************************************

Copyright (c) 1993  Microsoft Corporation

Module Name:

	usbloop.h

Abstract:

		This header file is used both by ring3 app and ring0 driver, hence the
		use of #define DRIVER

Environment:

	Kernel & user mode

Revision History:

	1-10-96 : created

****************************************************************************/

#ifdef DRIVER

#include <wdm.h>
#include <usbdi.h>
#include <usbdlib.h>

#else

#include <usbdi.h>

#endif

#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>


#define NAME_MAX										256
#define MAX_INTERFACE									8
#define USBLOOP_PARENT									"\\\\.\\USBLOOPXXX"

// IOCTL info

#define USBLOOP_IOCTL_INDEX  0x0080

#define GET_NUM_DEVICES CTL_CODE(FILE_DEVICE_UNKNOWN,	\
								 USBLOOP_IOCTL_INDEX+0,	\
								 METHOD_BUFFERED,		\
								 FILE_ANY_ACCESS)

#define GET_DEVICE_INFO CTL_CODE(FILE_DEVICE_UNKNOWN,	\
								 USBLOOP_IOCTL_INDEX+1,	\
								 METHOD_BUFFERED,		\
								 FILE_ANY_ACCESS)

#define GET_DEVICE_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,		\
									   USBLOOP_IOCTL_INDEX+2,	\
									   METHOD_BUFFERED,			\
									   FILE_ANY_ACCESS)

#define GET_CONFIG_DESCRIPTOR CTL_CODE(FILE_DEVICE_UNKNOWN,		\
									   USBLOOP_IOCTL_INDEX+3,	\
									   METHOD_BUFFERED,			\
									   FILE_ANY_ACCESS)


#define GET_VERSION CTL_CODE(FILE_DEVICE_UNKNOWN,	\
							 USBLOOP_IOCTL_INDEX+4,	\
							 METHOD_BUFFERED,		\
							 FILE_ANY_ACCESS)

#define GET_INTERFACE_INFO CTL_CODE(FILE_DEVICE_UNKNOWN,	\
							 USBLOOP_IOCTL_INDEX+5,	\
							 METHOD_BUFFERED,		\
							 FILE_ANY_ACCESS)

#define USBLOOP_START_ISO_TEST CTL_CODE(FILE_DEVICE_UNKNOWN,	\
										USBLOOP_IOCTL_INDEX+6,	\
										METHOD_BUFFERED,		\
										FILE_ANY_ACCESS)

#ifdef DRIVER

#define USBDIAG_NAME_MAX								64
#define USBLOOP_MAX_PIPES								256
#define USBLOOP_MAX_XFER_SIZE							16384		   // 16K
#define USBLOOP_MAX_ENUM_DEVICES						8

typedef struct _DEVICE_LIST_ENTRY {
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT DeviceObject;
    struct _DEVICE_LIST_ENTRY *Next;
    ULONG DeviceNumber;
} DEVICE_LIST_ENTRY, *PDEVICE_LIST_ENTRY;

// data structure to describe each pipe
typedef struct _PipeDescr
{
		BOOLEAN bPipeInUse;				// pipe in use flag
		// layout of PipeAttr is LSB|ep|alt_interface|interface|configuration|MSB
		ULONG   PipeAttr;				// describes pipe configuration, interface, etc.
} PipeDescr, *pPipeDescr;

		// device extension for driver instance, used to store needed data

typedef struct _DEVICE_EXTENSION
{
		PDEVICE_OBJECT		PhysicalDeviceObject;	// physical device object
		PDEVICE_OBJECT		StackDeviceObject;		// stack device object
		PDEVICE_LIST_ENTRY	DeviceList;
		ULONG				ulInstance;				// keeps track of device instance

		// Name buffer for our named Functional device object link
		WCHAR DeviceLinkNameBuffer[USBDIAG_NAME_MAX];

		// descriptors for device instance

		PUSB_CONFIGURATION_DESCRIPTOR pUsbConfigDesc;
		PUSBD_INTERFACE_INFORMATION	  Interface[MAX_INTERFACE];

		ULONG						  OpenFRC;

		PUSB_DEVICE_DESCRIPTOR		  pDeviceDescriptor;

		KTIMER						  TimeoutTimer;
		KDPC						  TimeoutDpc;

		// handle to configuration that was selected
		USBD_CONFIGURATION_HANDLE ConfigurationHandle;
		ULONG					  numPipesInUse;			// number of pipes in use
		PipeDescr				  pipes[USBLOOP_MAX_PIPES];	// array of pipe descriptors
		//Pointer to an Irp outstanding on this device
		// BUGBUG (kosar) This should really be kept on a per-pipe basis but
		//				  we're only keeping on outstanding Irp on this device
		//				  at a time.
		PIRP					  pIrp;
		BOOLEAN					  Stopped;					// keeps track of device status
		BOOLEAN					  bTestDevice;				// flag for test devices
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;



#define PIPE_MASK				0xff
#define NUM_ATTR_BYTES			4
#define ALT_INT_SHIFT			8
#define INT_SHIFT				16
#define CONFIG_SHIFT			24
#define DEADMAN_TIMEOUT		 	5000

// extract alt interface from FsContext
#define ALT_INTERFACE(context)  ((ULONG) ((ULONG) context >> ALT_INT_SHIFT) & PIPE_MASK)

// extract interface from FsContext
#define INTERFACE(context)	  ((ULONG) ((ULONG) context >> INT_SHIFT) & PIPE_MASK)

// extract configuration from FsContext
#define CONFIGURATION(context)  ((ULONG) ((ULONG) context >> CONFIG_SHIFT) & PIPE_MASK)

// extract pipe number from FsContext
#define PIPENUM(context)		((ULONG) context & PIPE_MASK)

// turns ULONGs into attribute byte for pipe
#define MAKEPIPEATTR(config, interface, alt_interface, pipenum) \
		((ULONG) (((config & PIPE_MASK) << CONFIG_SHIFT) +		\
		((interface & PIPE_MASK) << INT_SHIFT) +				\
		((alt_interface & PIPE_MASK) << ALT_INT_SHIFT) +		\
		(pipenum & PIPE_MASK)))

ULONG ulNumLogDev;

static WCHAR deviceLinkBuffer[NAME_MAX]  = L"\\DosDevices\\USBLOOP";
static WCHAR deviceNameBuffer[NAME_MAX]  = L"\\Device\\USBLOOP";


// this data structure will be used for async transfers, contains urb
// structure, a timer object, pointer to the irp, and a callback object for
// the timer. The timer will be cancelled when the USB transfer completes
typedef struct AsyncTransfer
{
	struct _URB_BULK_OR_INTERRUPT_TRANSFER urb;
    KTIMER	TimeoutTimer;
	PIRP	irp;
    KDPC	TimeoutDpc;
	BOOLEAN	bTimerExpired;
} AsyncTransfer, *pAsyncTransfer;


#if DBG

#define USBLOOP_KdPrint(_x_) DbgPrint("USBLOOP.SYS: "); \
														 DbgPrint _x_ ;
#define USBLOOP_TRAP() DbgBreakPoint()

#else

#define USBLOOP_KdPrint(_x_)

#define USBLOOP_TRAP()

#endif


NTSTATUS
USBLOOP_Dispatch(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP			  Irp
	);

VOID
USBLOOP_Unload(
	IN PDRIVER_OBJECT DriverObject
	);

NTSTATUS
USBLOOP_StartDevice(
	IN  PDEVICE_OBJECT DeviceObject
	);

NTSTATUS
USBLOOP_StopDevice(
	IN  PDEVICE_OBJECT DeviceObject
	);

NTSTATUS
USBLOOP_CreateDeviceObject(
	IN PDRIVER_OBJECT DriverObject,
		IN PDEVICE_OBJECT *DeviceObject,
		ULONG			   Instance
		);

NTSTATUS
USBLOOP_CallUSBD(
		IN PDEVICE_OBJECT DeviceObject,
		IN PURB			  Urb
		);

NTSTATUS
USBLOOP_PnPAddDevice(
		IN PDRIVER_OBJECT DriverObject,
		IN PDEVICE_OBJECT PhysicalDeviceObject
		);

NTSTATUS
USBLOOP_SelectInterfaces(
	IN PDEVICE_OBJECT				 DeviceObject,
	IN PUSB_CONFIGURATION_DESCRIPTOR configDesc
	);

NTSTATUS
USBLOOP_ConfigureDevice(
	IN  PDEVICE_OBJECT DeviceObject
	);

NTSTATUS
USBLOOP_GetDescriptor(
	IN  PDEVICE_OBJECT DeviceObject,
	IN  UCHAR		   DescType,
	IN OUT PVOID	   pvBuffer
	);

NTSTATUS
USBLOOP_Read(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP			  Irp
	);

NTSTATUS
USBLOOP_Write(
	IN PDEVICE_OBJECT DeviceObject,
	IN PIRP			  Irp
	);

NTSTATUS
USBLOOP_getPipeAttr(
		IN PCWSTR	pDeviceName,
		OUT PULONG	pPipeAttr
		);

pAsyncTransfer
USBLOOP_BuildAsyncRequest(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP				Irp,
    IN USBD_PIPE_HANDLE	PipeHandle,
    IN BOOLEAN			Read
    );

NTSTATUS
USBLOOP_AsyncReadWrite_Complete(
    IN PDEVICE_OBJECT	DeviceObject,
    IN PIRP				Irp,
    IN PVOID			Context
    );


VOID
USBLOOP_SyncTimeoutDPC(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\usb_dfw.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

	USB_DFW.H

Abstract:

	Extracted structures from USBDI.H to allow apps to use the struct alignment of their
	choice for the common device framework structures.  Due to the problems w/ byte alignment,
	apps that use the USBDI.H file cannot always end up with the same alignment if all the 
	proper env variables aren't set.  So, this file is created to pull o ut the interesting
	stuff and allow apps to use it.

	BUGBUG :
	Need to fix this somehow so that we can import USBDI.H directly.  The trick is to
	figure out which vars must be set properly to get the #include <PSHPACK1.H> to do the right things
	because now even though that #include is in USBDI.H, it isn't causing the right things to happen
	because of incorrectly set env vars.
        

Environment:

    Kernel & user mode

Revision History:

    8-4-96 : created by Kosar Jaff

--*/

#ifndef   __USB_DFW_H__
#define   __USB_DFW_H__

//
// USB descriptor types, bDescriptorType field
// in USB descriptor structure
//

#define USB_DEVICE_DESCRIPTOR_TYPE                0x01
#define USB_CONFIGURATION_DESCRIPTOR_TYPE         0x02
#define USB_STRING_DESCRIPTOR_TYPE                0x03
#define USB_INTERFACE_DESCRIPTOR_TYPE             0x04
#define USB_ENDPOINT_DESCRIPTOR_TYPE              0x05

#define USB_DESCRIPTOR_MAKE_TYPE_AND_INDEX(d, i) ((USHORT)((USHORT)d<<8 | i))

//
// Values for bmAttributes field of an
// endpoint descriptor
//

#define USB_ENDPOINT_TYPE_MASK                    0x03

#define USB_ENDPOINT_TYPE_CONTROL                 0x00
#define USB_ENDPOINT_TYPE_ISOCHRONOUS             0x01
#define USB_ENDPOINT_TYPE_BULK                    0x02
#define USB_ENDPOINT_TYPE_INTERRUPT               0x03

//
// Endpoint direction bit, stored in address
//

#define USB_ENDPOINT_DIRECTION_MASK               0x80

// test direction bit in the bEndpointAddress field of
// an endpoint descriptor.
#define USB_ENDPOINT_DIRECTION_OUT(addr)          (!((addr) & USB_ENDPOINT_DIRECTION_MASK))
#define USB_ENDPOINT_DIRECTION_IN(addr)           ((addr) & USB_ENDPOINT_DIRECTION_MASK)

//
// USB defined request codes
// see chapter 9 of the USB 1.0 specifcation for
// more information.
//

// These are the correct values based on the USB 1.0
// specification

#define USB_REQUEST_GET_STATUS                    0x00
#define USB_REQUEST_CLEAR_FEATURE                 0x01

#define USB_REQUEST_SET_FEATURE                   0x03

#define USB_REQUEST_SET_ADDRESS                   0x05
#define USB_REQUEST_GET_DESCRIPTOR                0x06
#define USB_REQUEST_SET_DESCRIPTOR                0x07
#define USB_REQUEST_GET_CONFIGURATION             0x08
#define USB_REQUEST_SET_CONFIGURATION             0x09
#define USB_REQUEST_GET_INTERFACE                 0x0A
#define USB_REQUEST_SET_INTERFACE                 0x0B
#define USB_REQUEST_SYNC_FRAME                    0x0C


//#include <PSHPACK1.H>

typedef struct _USB_DEVICE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
    USHORT idVendor;
    USHORT idProduct;
    USHORT bcdDevice;
    UCHAR iManufacturer;
    UCHAR iProduct;
    UCHAR iSerialNumber;
    UCHAR bNumConfigurations;
} USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;

typedef struct _USB_ENDPOINT_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bEndpointAddress;
    UCHAR bmAttributes;
    USHORT wMaxPacketSize;
    UCHAR bInterval;
} USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;

//
// values for bmAttributes Field in
// USB_CONFIGURATION_DESCRIPTOR
//

#define BUS_POWERED                           0x80
#define SELF_POWERED                          0x40
#define REMOTE_WAKEUP                         0x20

typedef struct _USB_CONFIGURATION_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT wTotalLength;
    UCHAR bNumInterfaces;
    UCHAR bConfigurationValue;
    UCHAR iConfiguration;
    UCHAR bmAttributes;
    UCHAR MaxPower;
} USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;

typedef struct _USB_INTERFACE_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    UCHAR bInterfaceNumber;
    UCHAR bAlternateSetting;
    UCHAR bNumEndpoints;
    UCHAR bInterfaceClass;
    UCHAR bInterfaceSubClass;
    UCHAR bInterfaceProtocol;
    UCHAR iInterface;
} USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;

typedef struct _USB_STRING_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
    WCHAR bString[1];
} USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;

typedef struct _USB_COMMON_DESCRIPTOR {
    UCHAR bLength;
    UCHAR bDescriptorType;
} USB_COMMON_DESCRIPTOR, *PUSB_COMMON_DESCRIPTOR;

typedef struct _USB_HUB_DESCRIPTOR {
    UCHAR        bDescriptorLength;      // Length of this descriptor
    UCHAR        bDescriptorType;        // Hub configuration type
    UCHAR        bNumberOfPorts;         // number of ports on this hub
    USHORT       wHubCharacteristics;    // Hub Charateristics
    UCHAR        bPowerOnToPowerGood;    // port power on till power good in 2ms
    UCHAR        bHubControlCurrent;     // max current in mA
    //
    // room for 255 ports power control and removable bitmask
    UCHAR        bRemoveAndPowerMask[64];       
} USB_HUB_DESCRIPTOR, *PUSB_HUB_DESCRIPTOR;


//#include <POPPACK.H>


#endif   // __USB_DFW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\dbg.h ===
/*++

Copyright (c) 1996-1998 Microsoft Corporation

Module Name:

    DBG.H

Abstract:

    Header file for USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#if DBG
  #if defined(DEBUG_LOG)
    #undef DEBUG_LOG
  #endif
  #define DEBUG_LOG 1
#else
  #if !defined(DEBUG_LOG)
    #define DEBUG_LOG 0
  #endif
#endif


#if !DBG

#define DBGFBRK(flag)
#define DBGPRINT(level, _x_)

#else

#define DBGF_BRK_DRIVERENTRY            0x00000001
#define DBGF_BRK_UNLOAD                 0x00000002
#define DBGF_BRK_ADDDEVICE              0x00000004
#define DBGF_BRK_REMOVEDEVICE           0x00000008
#define DBGF_BRK_STARTDEVICE            0x00000010
#define DBGF_BRK_STOPDEVICE             0x00000020
#define DBGF_BRK_QUERYSTOPDEVICE        0x00000040
#define DBGF_BRK_CANCELSTOPDEVICE       0x00000080
#define DBGF_BRK_RESET                  0x00000100
#define DBGF_BRK_RESETPIPE              0x00000200
#define DBGF_BRK_CREATE                 0x00010000
#define DBGF_BRK_CLOSE                  0x00020000
#define DBGF_BRK_READWRITE              0x00040000
#define DBGF_BRK_IOCTL                  0x00080000
#define DBGF_BRK_SCSI                   0x00100000
#define DBGF_BRK_INVALID_REQ            0x00200000

#define DBGFBRK(flag) do { \
    if (USBSTOR_DriverGlobals.DebugFlags & flag) { \
        DbgBreakPoint(); \
    } \
} while (0)

#define DBGPRINT(level, _x_) do { \
    if (level <= USBSTOR_DriverGlobals.DebugLevel) { \
        KdPrint(("USBSTOR: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

#if !DEBUG_LOG

#define LOGINIT()
#define LOGUNINIT()
#define LOGENTRY(tag, info1, info2, info3)

#else

#define LOGSIZE 4096

#define LOGINIT() USBSTOR_LogInit()

#define LOGUNINIT() USBSTOR_LogUnInit()

#define LOGENTRY(tag, info1, info2, info3) \
   USBSTOR_LogEntry(((((tag) >> 24) & 0x000000FF) | \
                     (((tag) >>  8) & 0x0000FF00) | \
                     (((tag) <<  8) & 0x00FF0000) | \
                     (((tag) << 24) & 0xFF000000)), \
                    ((ULONG_PTR)info1),             \
                    ((ULONG_PTR)info2),             \
                    ((ULONG_PTR)info3))

#endif

//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

#if DEBUG_LOG

typedef struct _USBSTOR_LOG_ENTRY {
    ULONG       le_tag;
    ULONG_PTR   le_info1;
    ULONG_PTR   le_info2;
    ULONG_PTR   le_info3;
} USBSTOR_LOG_ENTRY, *PUSBSTOR_LOG_ENTRY;

#endif

#if DBG || DEBUG_LOG

typedef struct _DRIVERGLOBALS
{
#if DBG
    ULONG               DebugFlags;     // DBGF_* Flags
    LONG                DebugLevel;     // Level of debug output
#endif
    PUSBSTOR_LOG_ENTRY  LogStart;       // Start of log buffer (older entries)
    PUSBSTOR_LOG_ENTRY  LogPtr;         // Current entry in log buffer
    PUSBSTOR_LOG_ENTRY  LogEnd;         // End of log buffer (newer entries)
    KSPIN_LOCK          LogSpinLock;    // Protects LogPtr

} DRIVERGLOBALS;

#endif

//*****************************************************************************
//
// G L O B A L S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG || DEBUG_LOG

DRIVERGLOBALS USBSTOR_DriverGlobals;

#endif


//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// DBG.C
//

#if DBG

VOID
USBSTOR_QueryGlobalParams (
    );

#endif

#if DEBUG_LOG

VOID
USBSTOR_LogInit (
);

VOID
USBSTOR_LogUnInit (
);

VOID
USBSTOR_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
);

#endif

#if DBG

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
);

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
);

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
);

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
);

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
);

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
);

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbdiag\_m_usb.h ===
#define _m_UsbBuildSetDescriptorRequest(urb, \
                                     length, \
                                     descriptorType, \
                                     index, \
                                     languageId, \
                                     transferBuffer, \
                                     transferBufferMDL, \
                                     transferBufferLength, \
                                     link) { \
            (urb)->UrbHeader.Function =  URB_FUNCTION_SET_DESCRIPTOR_TO_DEVICE; \
            (urb)->UrbHeader.Length = (length); \
            (urb)->UrbControlDescriptorRequest.TransferBufferLength = (transferBufferLength); \
            (urb)->UrbControlDescriptorRequest.TransferBufferMDL = (transferBufferMDL); \
            (urb)->UrbControlDescriptorRequest.TransferBuffer = (transferBuffer); \
            (urb)->UrbControlDescriptorRequest.DescriptorType = (descriptorType); \
            (urb)->UrbControlDescriptorRequest.Index = (index); \
            (urb)->UrbControlDescriptorRequest.LanguageId = (languageId); \
            (urb)->UrbControlDescriptorRequest.UrbLink = (link); }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\dbg.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    DBG.C

Abstract:

    USBSTOR driver debug utility functions

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "usbmass.h"

#ifdef ALLOC_PRAGMA
#if DBG
#pragma alloc_text(PAGE, USBSTOR_QueryGlobalParams)
#endif
#if DEBUG_LOG
#pragma alloc_text(PAGE, USBSTOR_LogInit)
#pragma alloc_text(PAGE, USBSTOR_LogUnInit)
#endif
#if DBG
#pragma alloc_text(PAGE, DumpDeviceDesc)
#pragma alloc_text(PAGE, DumpConfigDesc)
#pragma alloc_text(PAGE, DumpConfigurationDescriptor)
#pragma alloc_text(PAGE, DumpInterfaceDescriptor)
#pragma alloc_text(PAGE, DumpEndpointDescriptor)
#endif
#endif


//******************************************************************************
//
// G L O B A L S
//
//******************************************************************************

#if DBG || DEBUG_LOG

DRIVERGLOBALS USBSTOR_DriverGlobals =
{
#if DBG
    0,                      // DebugFlags
    0,                      // DebugLevel
#endif
    0,      // LogStart
    0,      // LogPtr
    0,      // LogEnd
    0       // LogSpinLock
};

#endif

#if DBG

//******************************************************************************
//
// USBSTOR_QueryGlobalParams()
//
//******************************************************************************

VOID
USBSTOR_QueryGlobalParams (
    )
{
    RTL_QUERY_REGISTRY_TABLE paramTable[3];

    DBGPRINT(2, ("enter: USBSTOR_QueryGlobalParams\n"));

    RtlZeroMemory (&paramTable[0], sizeof(paramTable));

    paramTable[0].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name          = L"DebugFlags";
    paramTable[0].EntryContext  = &USBSTOR_DriverGlobals.DebugFlags;
    paramTable[0].DefaultType   = REG_BINARY;
    paramTable[0].DefaultData   = &USBSTOR_DriverGlobals.DebugFlags;
    paramTable[0].DefaultLength = sizeof(ULONG);

    paramTable[1].Flags         = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[1].Name          = L"DebugLevel";
    paramTable[1].EntryContext  = &USBSTOR_DriverGlobals.DebugLevel;
    paramTable[1].DefaultType   = REG_BINARY;
    paramTable[1].DefaultData   = &USBSTOR_DriverGlobals.DebugLevel;
    paramTable[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"USBSTOR",
                           &paramTable[0],
                           NULL,           // Context
                           NULL);          // Environment

    DBGPRINT(2, ("exit: USBSTOR_QueryGlobalParams\n"));
}

#endif

#if DBG || DEBUG_LOG

//*****************************************************************************
//
// USBSTOR_LogInit()
//
//*****************************************************************************

VOID
USBSTOR_LogInit (
)
{
    KeInitializeSpinLock(&USBSTOR_DriverGlobals.LogSpinLock);

    USBSTOR_DriverGlobals.LogStart = ExAllocatePoolWithTag(NonPagedPool,
                                                           LOGSIZE,
                                                           POOL_TAG);

    if (USBSTOR_DriverGlobals.LogStart != NULL)
    {
        USBSTOR_DriverGlobals.LogEnd = USBSTOR_DriverGlobals.LogStart +
                                      LOGSIZE / sizeof(USBSTOR_LOG_ENTRY);

        USBSTOR_DriverGlobals.LogPtr = USBSTOR_DriverGlobals.LogEnd - 1;
    }
}

//*****************************************************************************
//
// USBSTOR_LogUnInit()
//
//*****************************************************************************

VOID
USBSTOR_LogUnInit (
)
{
    PUSBSTOR_LOG_ENTRY logStart;

    logStart = USBSTOR_DriverGlobals.LogStart;

    USBSTOR_DriverGlobals.LogStart = 0;

    ExFreePool(logStart);
}

//*****************************************************************************
//
// USBSTOR_LogEntry()
//
//*****************************************************************************

VOID
USBSTOR_LogEntry (
    IN ULONG     Tag,
    IN ULONG_PTR Info1,
    IN ULONG_PTR Info2,
    IN ULONG_PTR Info3
)
{
    KIRQL irql;

    if (USBSTOR_DriverGlobals.LogStart == NULL)
    {
        return;
    }

    KeAcquireSpinLock(&USBSTOR_DriverGlobals.LogSpinLock, &irql);

    USBSTOR_DriverGlobals.LogPtr->le_tag     = Tag;
    USBSTOR_DriverGlobals.LogPtr->le_info1   = Info1;
    USBSTOR_DriverGlobals.LogPtr->le_info2   = Info2;
    USBSTOR_DriverGlobals.LogPtr->le_info3   = Info3;

    if (USBSTOR_DriverGlobals.LogPtr > USBSTOR_DriverGlobals.LogStart)
    {
        USBSTOR_DriverGlobals.LogPtr--;
    }
    else
    {
        USBSTOR_DriverGlobals.LogPtr = USBSTOR_DriverGlobals.LogEnd - 1;
    }

    KeReleaseSpinLock(&USBSTOR_DriverGlobals.LogSpinLock, irql);
}

#endif

#if DBG

//*****************************************************************************
//
// PnPMinorFunctionString()
//
// MinorFunction - The IRP_MJ_PNP minor function
//
//*****************************************************************************

PCHAR
PnPMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_START_DEVICE:
            return "IRP_MN_START_DEVICE";
        case IRP_MN_QUERY_REMOVE_DEVICE:
            return "IRP_MN_QUERY_REMOVE_DEVICE";
        case IRP_MN_REMOVE_DEVICE:
            return "IRP_MN_REMOVE_DEVICE";
        case IRP_MN_CANCEL_REMOVE_DEVICE:
            return "IRP_MN_CANCEL_REMOVE_DEVICE";
        case IRP_MN_STOP_DEVICE:
            return "IRP_MN_STOP_DEVICE";
        case IRP_MN_QUERY_STOP_DEVICE:
            return "IRP_MN_QUERY_STOP_DEVICE";
        case IRP_MN_CANCEL_STOP_DEVICE:
            return "IRP_MN_CANCEL_STOP_DEVICE";
        case IRP_MN_QUERY_DEVICE_RELATIONS:
            return "IRP_MN_QUERY_DEVICE_RELATIONS";
        case IRP_MN_QUERY_INTERFACE:
            return "IRP_MN_QUERY_INTERFACE";
        case IRP_MN_QUERY_CAPABILITIES:
            return "IRP_MN_QUERY_CAPABILITIES";
        case IRP_MN_QUERY_RESOURCES:
            return "IRP_MN_QUERY_RESOURCES";
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
            return "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
        case IRP_MN_QUERY_DEVICE_TEXT:
            return "IRP_MN_QUERY_DEVICE_TEXT";
        case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
            return "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
        case IRP_MN_READ_CONFIG:
            return "IRP_MN_READ_CONFIG";
        case IRP_MN_WRITE_CONFIG:
            return "IRP_MN_WRITE_CONFIG";
        case IRP_MN_EJECT:
            return "IRP_MN_EJECT";
        case IRP_MN_SET_LOCK:
            return "IRP_MN_SET_LOCK";
        case IRP_MN_QUERY_ID:
            return "IRP_MN_QUERY_ID";
        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            return "IRP_MN_QUERY_PNP_DEVICE_STATE";
        case IRP_MN_QUERY_BUS_INFORMATION:
            return "IRP_MN_QUERY_BUS_INFORMATION";
        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            return "IRP_MN_DEVICE_USAGE_NOTIFICATION";
        case IRP_MN_SURPRISE_REMOVAL:
            return "IRP_MN_SURPRISE_REMOVAL";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerMinorFunctionString()
//
// MinorFunction - The IRP_MJ_POWER minor function
//
//*****************************************************************************

PCHAR
PowerMinorFunctionString (
    UCHAR MinorFunction
)
{
    switch (MinorFunction)
    {
        case IRP_MN_WAIT_WAKE:
            return "IRP_MN_WAIT_WAKE";
        case IRP_MN_POWER_SEQUENCE:
            return "IRP_MN_POWER_SEQUENCE";
        case IRP_MN_SET_POWER:
            return "IRP_MN_SET_POWER";
        case IRP_MN_QUERY_POWER:
            return "IRP_MN_QUERY_POWER";
        default:
            return "IRP_MN_?????";
    }
}

//*****************************************************************************
//
// PowerDeviceStateString()
//
// State - The DEVICE_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerDeviceStateString (
    DEVICE_POWER_STATE State
)
{
    switch (State)
    {
        case PowerDeviceUnspecified:
            return "PowerDeviceUnspecified";
        case PowerDeviceD0:
            return "PowerDeviceD0";
        case PowerDeviceD1:
            return "PowerDeviceD1";
        case PowerDeviceD2:
            return "PowerDeviceD2";
        case PowerDeviceD3:
            return "PowerDeviceD3";
        case PowerDeviceMaximum:
            return "PowerDeviceMaximum";
        default:
            return "PowerDevice?????";
    }
}

//*****************************************************************************
//
// PowerSystemStateString()
//
// State - The SYSTEM_POWER_STATE
//
//*****************************************************************************

PCHAR
PowerSystemStateString (
    SYSTEM_POWER_STATE State
)
{
    switch (State)
    {
        case PowerSystemUnspecified:
            return "PowerSystemUnspecified";
        case PowerSystemWorking:
            return "PowerSystemWorking";
        case PowerSystemSleeping1:
            return "PowerSystemSleeping1";
        case PowerSystemSleeping2:
            return "PowerSystemSleeping2";
        case PowerSystemSleeping3:
            return "PowerSystemSleeping3";
        case PowerSystemHibernate:
            return "PowerSystemHibernate";
        case PowerSystemShutdown:
            return "PowerSystemShutdown";
        case PowerSystemMaximum:
            return "PowerSystemMaximum";
        default:
            return "PowerSystem?????";
    }
}

//*****************************************************************************
//
// DumpDeviceDesc()
//
// DeviceDesc - The Device Descriptor
//
//*****************************************************************************

VOID
DumpDeviceDesc (
    PUSB_DEVICE_DESCRIPTOR   DeviceDesc
)
{
    DBGPRINT(3, ("------------------\n"));
    DBGPRINT(3, ("Device Descriptor:\n"));

    DBGPRINT(3, ("bcdUSB:             0x%04X\n",
                 DeviceDesc->bcdUSB));

    DBGPRINT(3, ("bDeviceClass:         0x%02X\n",
                 DeviceDesc->bDeviceClass));

    DBGPRINT(3, ("bDeviceSubClass:      0x%02X\n",
                 DeviceDesc->bDeviceSubClass));

    DBGPRINT(3, ("bDeviceProtocol:      0x%02X\n",
                 DeviceDesc->bDeviceProtocol));

    DBGPRINT(3, ("bMaxPacketSize0:      0x%02X (%d)\n",
                 DeviceDesc->bMaxPacketSize0,
                 DeviceDesc->bMaxPacketSize0));

    DBGPRINT(3, ("idVendor:           0x%04X\n",
                 DeviceDesc->idVendor));

    DBGPRINT(3, ("idProduct:          0x%04X\n",
                 DeviceDesc->idProduct));

    DBGPRINT(3, ("bcdDevice:          0x%04X\n",
                 DeviceDesc->bcdDevice));

    DBGPRINT(3, ("iManufacturer:        0x%02X\n",
                 DeviceDesc->iManufacturer));

    DBGPRINT(3, ("iProduct:             0x%02X\n",
                 DeviceDesc->iProduct));

    DBGPRINT(3, ("iSerialNumber:        0x%02X\n",
                 DeviceDesc->iSerialNumber));

    DBGPRINT(3, ("bNumConfigurations:   0x%02X\n",
                 DeviceDesc->bNumConfigurations));

}

//*****************************************************************************
//
// DumpConfigDesc()
//
// ConfigDesc - The Configuration Descriptor, and associated Interface and
// EndpointDescriptors
//
//*****************************************************************************

VOID
DumpConfigDesc (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    PUCHAR                  descEnd;
    PUSB_COMMON_DESCRIPTOR  commonDesc;
    BOOLEAN                 dumpUnknown;

    descEnd = (PUCHAR)ConfigDesc + ConfigDesc->wTotalLength;

    commonDesc = (PUSB_COMMON_DESCRIPTOR)ConfigDesc;

    while ((PUCHAR)commonDesc + sizeof(USB_COMMON_DESCRIPTOR) < descEnd &&
           (PUCHAR)commonDesc + commonDesc->bLength <= descEnd)
    {
        dumpUnknown = FALSE;

        switch (commonDesc->bDescriptorType)
        {
            case USB_CONFIGURATION_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_CONFIGURATION_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpConfigurationDescriptor((PUSB_CONFIGURATION_DESCRIPTOR)commonDesc);
                break;

            case USB_INTERFACE_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_INTERFACE_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpInterfaceDescriptor((PUSB_INTERFACE_DESCRIPTOR)commonDesc);
                break;

            case USB_ENDPOINT_DESCRIPTOR_TYPE:
                if (commonDesc->bLength != sizeof(USB_ENDPOINT_DESCRIPTOR))
                {
                    dumpUnknown = TRUE;
                    break;
                }
                DumpEndpointDescriptor((PUSB_ENDPOINT_DESCRIPTOR)commonDesc);
                break;

            default:
                dumpUnknown = TRUE;
                break;
        }

        if (dumpUnknown)
        {
            // DumpUnknownDescriptor(commonDesc);
        }

        (PUCHAR)commonDesc += commonDesc->bLength;
    }
}


//*****************************************************************************
//
// DumpConfigurationDescriptor()
//
//*****************************************************************************

VOID
DumpConfigurationDescriptor (
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc
)
{
    DBGPRINT(3, ("-------------------------\n"));
    DBGPRINT(3, ("Configuration Descriptor:\n"));

    DBGPRINT(3, ("wTotalLength:       0x%04X\n",
                 ConfigDesc->wTotalLength));

    DBGPRINT(3, ("bNumInterfaces:       0x%02X\n",
                 ConfigDesc->bNumInterfaces));

    DBGPRINT(3, ("bConfigurationValue:  0x%02X\n",
                 ConfigDesc->bConfigurationValue));

    DBGPRINT(3, ("iConfiguration:       0x%02X\n",
                 ConfigDesc->iConfiguration));

    DBGPRINT(3, ("bmAttributes:         0x%02X\n",
                 ConfigDesc->bmAttributes));

    if (ConfigDesc->bmAttributes & 0x80)
    {
        DBGPRINT(3, ("  Bus Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x40)
    {
        DBGPRINT(3, ("  Self Powered\n"));
    }

    if (ConfigDesc->bmAttributes & 0x20)
    {
        DBGPRINT(3, ("  Remote Wakeup\n"));
    }

    DBGPRINT(3, ("MaxPower:             0x%02X (%d Ma)\n",
                 ConfigDesc->MaxPower,
                 ConfigDesc->MaxPower * 2));

}

//*****************************************************************************
//
// DumpInterfaceDescriptor()
//
//*****************************************************************************

VOID
DumpInterfaceDescriptor (
    PUSB_INTERFACE_DESCRIPTOR   InterfaceDesc
)
{
    DBGPRINT(3, ("---------------------\n"));
    DBGPRINT(3, ("Interface Descriptor:\n"));

    DBGPRINT(3, ("bInterfaceNumber:     0x%02X\n",
                 InterfaceDesc->bInterfaceNumber));

    DBGPRINT(3, ("bAlternateSetting:    0x%02X\n",
                 InterfaceDesc->bAlternateSetting));

    DBGPRINT(3, ("bNumEndpoints:        0x%02X\n",
                 InterfaceDesc->bNumEndpoints));

    DBGPRINT(3, ("bInterfaceClass:      0x%02X\n",
                 InterfaceDesc->bInterfaceClass));

    DBGPRINT(3, ("bInterfaceSubClass:   0x%02X\n",
                 InterfaceDesc->bInterfaceSubClass));

    DBGPRINT(3, ("bInterfaceProtocol:   0x%02X\n",
                 InterfaceDesc->bInterfaceProtocol));

    DBGPRINT(3, ("iInterface:           0x%02X\n",
                 InterfaceDesc->iInterface));

}

//*****************************************************************************
//
// DumpEndpointDescriptor()
//
//*****************************************************************************

VOID
DumpEndpointDescriptor (
    PUSB_ENDPOINT_DESCRIPTOR    EndpointDesc
)
{
    DBGPRINT(3, ("--------------------\n"));
    DBGPRINT(3, ("Endpoint Descriptor:\n"));

    DBGPRINT(3, ("bEndpointAddress:     0x%02X\n",
                 EndpointDesc->bEndpointAddress));

    switch (EndpointDesc->bmAttributes & 0x03)
    {
        case 0x00:
            DBGPRINT(3, ("Transfer Type:     Control\n"));
            break;

        case 0x01:
            DBGPRINT(3, ("Transfer Type: Isochronous\n"));
            break;

        case 0x02:
            DBGPRINT(3, ("Transfer Type:        Bulk\n"));
            break;

        case 0x03:
            DBGPRINT(3, ("Transfer Type:   Interrupt\n"));
            break;
    }

    DBGPRINT(3, ("wMaxPacketSize:     0x%04X (%d)\n",
                 EndpointDesc->wMaxPacketSize,
                 EndpointDesc->wMaxPacketSize));

    DBGPRINT(3, ("bInterval:            0x%02X\n",
                 EndpointDesc->bInterval));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\debugwdm.h ===
/****************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	DEBUGWDM.H

Abstract:

	This header file is for debug and diagnostics for a WDM driver

Environment:

	Kernel mode and user mode

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.

Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/

#ifndef __DEBUGWDM_H__
#define __DEBUGWDM_H__


// this makes it easy to hide static vars, make visible for debug
#if DBG
#define LOCAL
#define GLOBAL
#else
#define LOCAL	static
#define GLOBAL
#endif

#ifdef POOL_TAGGING
#undef  ExAllocatePool
#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'CBSU')
#endif

#if DBG

#define DEBUG_TRACE1(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 1)	\
						{									\
							DbgPrint _x_ ;					\
						}									\
														}
#define DEBUG_TRACE2(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 2)	\
						{									\
							DbgPrint("%s: ",DriverName);	\
							DbgPrint _x_ ;					\
						}									\
														}
#define DEBUG_TRACE3(_x_)								{	\
						if(Usbser_Debug_Trace_Level >= 3)	\
						{									\
							DbgPrint("%s: ",DriverName);	\
							DbgPrint _x_ ;					\
						}									\
														}

#define DEBUG_TRAP()		DbgBreakPoint()

#else

#define DEBUG_TRACE1(_x_)
#define DEBUG_TRACE2(_x_)
#define DEBUG_TRACE3(_x_)

#define DEBUG_TRAP()		DbgBreakPoint()

#endif // DBG




// these macros are for logging things, avoid subroutine call
// if they are disabled (number of entries = 0)

#ifdef PROFILING_ENABLED

// need these for creating macros for speed in logging and history

extern GLOBAL ULONG					IRPHistorySize;
extern GLOBAL ULONG		 			DebugPathSize;
extern GLOBAL ULONG					ErrorLogSize;

#define DEBUG_LOG_IRP_HIST(dobj, pirp, majfunc, buff, bufflen)	{	\
	if(IRPHistorySize)												\
		Debug_LogIrpHist(dobj, pirp, majfunc, buff, bufflen);		\
																}

#define DEBUG_LOG_PATH(path)									{	\
	if(DebugPathSize)												\
		Debug_LogPath(path);										\
																}

#define DEBUG_LOG_ERROR(status)									{	\
	if(ErrorLogSize)												\
		Debug_LogError(status);										\
																}


#define DEBUG_ASSERT(msg, exp)									{	\
    if(!(exp))														\
        Debug_Assert(#exp, __FILE__, __LINE__, msg);				\
																}

#define DEBUG_OPEN			Debug_OpenWDMDebug

#define DEBUG_CLOSE			Debug_CloseWDMDebug

#define DEBUG_MEMALLOC		Debug_MemAlloc

#define DEBUG_MEMFREE		Debug_MemFree

#define DEBUG_CHECKMEM      Debug_CheckAllocations


// prototypes

NTSTATUS
Debug_OpenWDMDebug(VOID);

VOID
Debug_CloseWDMDebug(VOID);

NTSTATUS
Debug_SizeIRPHistoryTable(IN ULONG Size);

NTSTATUS
Debug_SizeDebugPathHist(IN ULONG Size);

NTSTATUS
Debug_SizeErrorLog(ULONG Size);

VOID
Debug_LogIrpHist(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
				 IN ULONG MajorFunction, IN PVOID IoBuffer, IN ULONG BufferLen);

VOID
Debug_LogPath(IN PCHAR Path);

VOID
Debug_LogError(IN NTSTATUS NtStatus);

VOID
Debug_Trap(IN PCHAR TrapCause);

VOID
Debug_Assert(IN PVOID FailedAssertion, IN PVOID FileName, IN ULONG LineNumber,
			 IN PCHAR Message);

ULONG
Debug_ExtractAttachedDevices(IN PDRIVER_OBJECT DriverObject, OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_GetDriverInfo(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractIRPHist(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractPathHist(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_ExtractErrorLog(OUT PCHAR Buffer, IN ULONG BuffSize);

ULONG
Debug_DumpDriverLog(IN PDEVICE_OBJECT DeviceObject, OUT PCHAR Buffer, IN ULONG BuffSize);

PCHAR
Debug_TranslateStatus(IN NTSTATUS NtStatus);

PCHAR
Debug_TranslateIoctl(IN LONG Ioctl);

#else

VOID
Debug_CheckAllocations(VOID);

PVOID
Debug_MemAlloc(IN POOL_TYPE PoolType, IN ULONG NumberOfBytes);

VOID
Debug_MemFree(IN PVOID pMem);

#define DEBUG_LOG_IRP_HIST(dobj, pirp, majfunc, buff, bufflen)

#define DEBUG_LOG_PATH(path)

#define DEBUG_LOG_ERROR(status)

#define DEBUG_ASSERT(msg, exp)

#define DEBUG_OPEN()				STATUS_SUCCESS

#define DEBUG_CLOSE()

#define DEBUG_MEMALLOC		Debug_MemAlloc

#define DEBUG_MEMFREE		Debug_MemFree

#define DEBUG_CHECKMEM      Debug_CheckAllocations


#endif // PROFILING_ENABLED


#endif // __DEBUGWDM_H__

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\scsi.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    SCSI.C

Abstract:

    This source file contains the dispatch routines which handle:

    IRP_MJ_DEVICE_CONTROL
    IRP_MJ_SCSI

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>
#include <ntddscsi.h>
#include <ntddstor.h>

#include "usbmass.h"

//*****************************************************************************
// L O C A L    F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************

NTSTATUS
USBSTOR_QueryProperty (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_BuildDeviceDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    );

NTSTATUS
USBSTOR_BuildAdapterDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    );

NTSTATUS
USBSTOR_SendPassThrough (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             RequestIrp
    );

VOID
USBSTOR_CancelIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
// CBI (Control/Bulk/Interrupt) Routines
//

NTSTATUS
USBSTOR_IssueClientCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ClientCdbCompletion  (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueClientBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ClientBulkCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_InterruptDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueRequestSenseCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_RequestSenseCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_IssueRequestSenseBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_SenseDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_IssueRequestSenseInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

NTSTATUS
USBSTOR_RequestSenseInterruptCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    );

NTSTATUS
USBSTOR_ProcessRequestSenseCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    );

VOID
USBSTOR_QueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_ResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

//
// Bulk-Only Routines
//

NTSTATUS
USBSTOR_CbwTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_CbwCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_DataTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_DataCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_CswTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_CswCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_IssueRequestSense (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_BulkQueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_BulkResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

//
// CBI / Bulk-Only Common Routines
//

VOID
USBSTOR_QueueResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_ResetDeviceWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    );

NTSTATUS
USBSTOR_IsDeviceConnected (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_ResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_IssueInternalCdb (
    PDEVICE_OBJECT  DeviceObject,
    PVOID           DataBuffer,
    PULONG          DataTransferLength,
    PCDB            Cdb,
    UCHAR           CdbLength,
    ULONG           TimeOutValue
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBSTOR_DeviceControl)
#pragma alloc_text(PAGE, USBSTOR_QueryProperty)
#pragma alloc_text(PAGE, USBSTOR_BuildDeviceDescriptor)
#pragma alloc_text(PAGE, USBSTOR_BuildAdapterDescriptor)
#pragma alloc_text(PAGE, USBSTOR_SendPassThrough)
#pragma alloc_text(PAGE, USBSTOR_IssueInternalCdb)
#pragma alloc_text(PAGE, USBSTOR_GetInquiryData)
#pragma alloc_text(PAGE, USBSTOR_IsFloppyDevice)
#endif


//******************************************************************************
//
// USBSTOR_DeviceControl()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL
//
//******************************************************************************

NTSTATUS
USBSTOR_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;
    ULONG               ioControlCode;
    NTSTATUS            ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_DeviceControl\n"));

    //LOGENTRY('IOCT', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_IOCTL);

    deviceExtension = DeviceObject->DeviceExtension;

    // Only the PDO should handle these ioctls
    //
    if (deviceExtension->Type == USBSTOR_DO_TYPE_PDO)
    {
        PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

        fdoDeviceExtension = ((PPDO_DEVICE_EXTENSION)deviceExtension)->ParentFDO->DeviceExtension;
        ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

        switch (ioControlCode)
        {
            case IOCTL_STORAGE_QUERY_PROPERTY:
                ntStatus = USBSTOR_QueryProperty(DeviceObject, Irp);
                break;

            case IOCTL_SCSI_PASS_THROUGH:
            case IOCTL_SCSI_PASS_THROUGH_DIRECT:

                ntStatus = USBSTOR_SendPassThrough(DeviceObject, Irp);

                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;


            case IOCTL_SCSI_GET_ADDRESS:        // XXXXX
                DBGPRINT(2, ("IOCTL_SCSI_GET_ADDRESS\n"));
                goto IoctlNotSupported;


            case IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER:
                //
                // Pass the Irp down the stack
                //
                IoSkipCurrentIrpStackLocation(Irp);

                ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                                        Irp);
                break;


            default:
IoctlNotSupported:
                // Maybe we can just ignore these.  Print debug info
                // for now so we know what IOCTLs that we've seen so
                // far that we fail.
                //
                DBGPRINT(2, ("ioControlCode not supported 0x%08X\n",
                             ioControlCode));

                DBGFBRK(DBGF_BRK_IOCTL);

                ntStatus = STATUS_NOT_SUPPORTED;
                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                break;
        }
    }
    else
    {
        ASSERT(deviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        DBGPRINT(2, ("ioctl not supported for FDO\n"));

        ntStatus = STATUS_NOT_SUPPORTED;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(2, ("exit:  USBSTOR_DeviceControl %08X\n", ntStatus));

    //LOGENTRY('ioct', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_QueryProperty()
//
// Dispatch routine which handles IRP_MJ_DEVICE_CONTROL,
// IOCTL_STORAGE_QUERY_PROPERTY for the PDO
//
//******************************************************************************

NTSTATUS
USBSTOR_QueryProperty (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSTORAGE_PROPERTY_QUERY query;
    ULONG                   inputLength;
    ULONG                   outputLength;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_QueryProperty\n"));

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    query = Irp->AssociatedIrp.SystemBuffer;

    inputLength  = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (inputLength < sizeof(STORAGE_PROPERTY_QUERY))
    {
        ntStatus = STATUS_INVALID_PARAMETER;    // Bad InputBufferLength
        outputLength = 0;
        goto USBSTOR_QueryPropertyDone;
    }

    switch (query->PropertyId)
    {
        case StorageDeviceProperty:

            switch (query->QueryType)
            {
                case PropertyExistsQuery:
                    ntStatus = STATUS_SUCCESS;
                    outputLength = 0;
                    break;

                case PropertyStandardQuery:
                    ntStatus = USBSTOR_BuildDeviceDescriptor(
                                   DeviceObject,
                                   Irp->AssociatedIrp.SystemBuffer,
                                   &outputLength);
                    break;

                default:
                    ntStatus = STATUS_INVALID_PARAMETER_2;  // Bad QueryType
                    outputLength = 0;
                    break;

            }
            break;

        case StorageAdapterProperty:

            switch (query->QueryType)
            {
                case PropertyExistsQuery:
                    ntStatus = STATUS_SUCCESS;
                    outputLength = 0;
                    break;

                case PropertyStandardQuery:
                    ntStatus = USBSTOR_BuildAdapterDescriptor(
                                   DeviceObject,
                                   Irp->AssociatedIrp.SystemBuffer,
                                   &outputLength);
                    break;

                default:
                    ntStatus = STATUS_INVALID_PARAMETER_2;  // Bad QueryType
                    outputLength = 0;
                    break;

            }
            break;

        default:

            ntStatus = STATUS_INVALID_PARAMETER_1;          // Bad PropertyId
            outputLength = 0;
            break;
    }

USBSTOR_QueryPropertyDone:

    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = outputLength;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit:  USBSTOR_QueryProperty %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_BuildDeviceDescriptor()
//
//******************************************************************************

NTSTATUS
USBSTOR_BuildDeviceDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    )
{
    PPDO_DEVICE_EXTENSION       pdoDeviceExtension;
    PINQUIRYDATA                inquiryData;
    LONG                        inquiryLength;
    STORAGE_DEVICE_DESCRIPTOR   localDescriptor;
    PUCHAR                      currentOffset;
    LONG                        bytesRemaining;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_BuildDeviceDescriptor\n"));

    // Get a pointer to our Inquiry data
    //
    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    inquiryData = (PINQUIRYDATA)pdoDeviceExtension->InquiryDataBuffer;

    // inquiryLength = 5 + inquiryData->AdditionalLength;
    //
    //     if (inquiryLength > INQUIRYDATABUFFERSIZE)
    //     {
    //         inquiryLength = INQUIRYDATABUFFERSIZE;
    //     }
    //
    // Just return whatever we got from the device and leave it up to
    // whoever looks at this information to decide how much is valid.
    //
    inquiryLength = sizeof(pdoDeviceExtension->InquiryDataBuffer);

    // Zero initialize the output buffer
    //
    RtlZeroMemory(Descriptor, *DescriptorLength);


    // Build the temp local descriptor
    //
    RtlZeroMemory(&localDescriptor, sizeof(localDescriptor));

    localDescriptor.Version = sizeof(localDescriptor);

    localDescriptor.Size    = FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                           RawDeviceProperties) +
                              inquiryLength +
                              sizeof(inquiryData->VendorId) + 1 +
                              sizeof(inquiryData->ProductId) + 1 +
                              sizeof(inquiryData->ProductRevisionLevel) + 1;

    localDescriptor.DeviceType          = inquiryData->DeviceType;
    localDescriptor.DeviceTypeModifier  = inquiryData->DeviceTypeModifier;
    localDescriptor.RemovableMedia      = inquiryData->RemovableMedia;

    localDescriptor.BusType = BusTypeUsb;


    // Start copying as much data as will fit in the output buffer
    //
    currentOffset   = (PUCHAR)Descriptor;
    bytesRemaining  = *DescriptorLength;


    // First copy the temp local descriptor
    //
    RtlCopyMemory(currentOffset,
                  &localDescriptor,
                  min(bytesRemaining,
                      FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                   RawDeviceProperties)));

    bytesRemaining  -= FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                    RawDeviceProperties);

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    // This should advance us to RawDeviceProperties[0]
    //
    currentOffset   += FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR,
                                    RawDeviceProperties);

    // Next copy the Inquiry data
    //
    Descriptor->RawPropertiesLength = min(bytesRemaining, inquiryLength);

    RtlCopyMemory(currentOffset,
                  inquiryData,
                  Descriptor->RawPropertiesLength);

    bytesRemaining  -= inquiryLength;

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += inquiryLength;


    // Now copy the Vendor Id
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->VendorId,
                  min(bytesRemaining, sizeof(inquiryData->VendorId)));

    bytesRemaining  -= sizeof(inquiryData->VendorId) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->VendorIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                             (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += sizeof(inquiryData->VendorId) + 1;


    // Now copy the Product Id
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->ProductId,
                  min(bytesRemaining, sizeof(inquiryData->ProductId)));

    bytesRemaining  -= sizeof(inquiryData->ProductId) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->ProductIdOffset = (ULONG)((ULONG_PTR) currentOffset -
                                              (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    currentOffset   += sizeof(inquiryData->ProductId) + 1;


    // And finally copy the Product Revision Level
    //
    RtlCopyMemory(currentOffset,
                  inquiryData->ProductRevisionLevel,
                  min(bytesRemaining, sizeof(inquiryData->ProductRevisionLevel)));

    bytesRemaining  -= sizeof(inquiryData->ProductRevisionLevel) + 1; // include null

    if (bytesRemaining >= 0)
    {
        Descriptor->ProductRevisionOffset = (ULONG)((ULONG_PTR) currentOffset -
                                                    (ULONG_PTR) Descriptor);
    }

    if (bytesRemaining <= 0)
    {
        return STATUS_SUCCESS;
    }

    *DescriptorLength -= bytesRemaining;

    return STATUS_SUCCESS;
}

//******************************************************************************
//
// USBSTOR_BuildAdapterDescriptor()
//
//******************************************************************************

NTSTATUS
USBSTOR_BuildAdapterDescriptor (
    IN PDEVICE_OBJECT               DeviceObject,
    IN PSTORAGE_DEVICE_DESCRIPTOR   Descriptor,
    IN OUT PULONG                   DescriptorLength
    )
{
    PPDO_DEVICE_EXTENSION       pdoDeviceExtension;
    PFDO_DEVICE_EXTENSION       fdoDeviceExtension;
    STORAGE_ADAPTER_DESCRIPTOR  localDescriptor;
    NTSTATUS                    ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_BuildAdapterDescriptor\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceExtension = pdoDeviceExtension->ParentFDO->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    localDescriptor.Version = sizeof(localDescriptor);
    localDescriptor.Size    = sizeof(localDescriptor);

    localDescriptor.MaximumTransferLength = USBSTOR_MAX_TRANSFER_SIZE;
    localDescriptor.MaximumPhysicalPages  = USBSTOR_MAX_TRANSFER_PAGES;
    localDescriptor.AlignmentMask = 0;
    localDescriptor.AdapterUsesPio = FALSE;
    localDescriptor.AdapterScansDown = FALSE;
    localDescriptor.CommandQueueing = FALSE;
    localDescriptor.AcceleratedTransfer = FALSE;

    localDescriptor.BusType = BusTypeUsb;

    localDescriptor.BusMajorVersion = fdoDeviceExtension->DeviceIsHighSpeed ?
                                      2 : 1;

    localDescriptor.BusMinorVersion = 0;

    if (*DescriptorLength > localDescriptor.Size)
    {
        *DescriptorLength = localDescriptor.Size;
    }

    RtlCopyMemory(Descriptor,
                  &localDescriptor,
                  *DescriptorLength);

    ntStatus = STATUS_SUCCESS;

    DBGPRINT(2, ("exit:  USBSTOR_BuildAdapterDescriptor %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SendPassThrough()
//
// This routine handles IOCTL_SCSI_PASS_THROUGH requests.
// It creates an Irp/Srb which is processed normally by the port driver.
// This call is synchornous.
//
// (This routine borrowed from ATAPI.SYS)
//
//******************************************************************************

NTSTATUS
USBSTOR_SendPassThrough (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             RequestIrp
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_PASS_THROUGH      srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   bufferOffset;
    PVOID                   buffer;
    PVOID                   endByte;
    PVOID                   senseBuffer;
    UCHAR                   majorCode;
    NTSTATUS                status;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_SendPassThrough\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    startingOffset.QuadPart = (LONGLONG)1;

    // Get a pointer to the control block.
    //
    irpStack    = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl  = RequestIrp->AssociatedIrp.SystemBuffer;

    // Validiate the user buffer.
    //
    if (irpStack->Parameters.DeviceIoControl.InputBufferLength <
        sizeof(SCSI_PASS_THROUGH))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (srbControl->Length != sizeof(SCSI_PASS_THROUGH) &&
        srbControl->Length != sizeof(SCSI_PASS_THROUGH_DIRECT))
    {
        return STATUS_REVISION_MISMATCH;
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    // Validate the rest of the buffer parameters.
    //
    if (srbControl->CdbLength > 16)
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (srbControl->SenseInfoLength != 0 &&
        (srbControl->Length > srbControl->SenseInfoOffset ||
        (srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
        srbControl->DataBufferOffset && srbControl->DataTransferLength != 0)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    majorCode = !srbControl->DataIn ? IRP_MJ_WRITE : IRP_MJ_READ;

    if (srbControl->DataTransferLength == 0)
    {
        length = 0;
        buffer = NULL;
        bufferOffset = 0;
        majorCode = IRP_MJ_FLUSH_BUFFERS;

    }
    else if ((srbControl->DataBufferOffset > outputLength) &&
             (srbControl->DataBufferOffset >
              irpStack->Parameters.DeviceIoControl.InputBufferLength))
    {
        // The data buffer offset is greater than system buffer.  Assume this
        // is a user mode address.
        //
        if ((srbControl->SenseInfoOffset + srbControl->SenseInfoLength  >
             outputLength) &&
            srbControl->SenseInfoLength)
        {
            return STATUS_INVALID_PARAMETER;
        }

        length = srbControl->DataTransferLength;
        buffer = (PCHAR) srbControl->DataBufferOffset;
        bufferOffset = 0;

        // make sure the user buffer is valid
        //
        if (RequestIrp->RequestorMode != KernelMode)
        {
            if (length)
            {
                endByte =  (PVOID)((PCHAR)buffer + length - 1);

                if (buffer >= endByte)
                {
                    return STATUS_INVALID_USER_BUFFER;
                }
            }
        }
    }
    else
    {
        if (srbControl->DataIn != SCSI_IOCTL_DATA_IN)
        {
            if (((srbControl->SenseInfoOffset + srbControl->SenseInfoLength >
                  outputLength) &&
                 srbControl->SenseInfoLength != 0) ||
                (srbControl->DataBufferOffset + srbControl->DataTransferLength >
                 irpStack->Parameters.DeviceIoControl.InputBufferLength) ||
                (srbControl->Length > srbControl->DataBufferOffset))
            {
                return STATUS_INVALID_PARAMETER;
            }
        }

        if (srbControl->DataIn)
        {
            if ((srbControl->DataBufferOffset + srbControl->DataTransferLength >
                 outputLength) ||
                (srbControl->Length > srbControl->DataBufferOffset))
            {
                return STATUS_INVALID_PARAMETER;
            }
        }

        length = (ULONG)srbControl->DataBufferOffset +
                        srbControl->DataTransferLength;

        buffer = (PUCHAR) srbControl;
        bufferOffset = (ULONG)srbControl->DataBufferOffset;
    }

    // Validate that the request isn't too large for the miniport.
    //
    if (srbControl->DataTransferLength &&
        ((ADDRESS_AND_SIZE_TO_SPAN_PAGES(
              (PUCHAR)buffer+bufferOffset,
              srbControl->DataTransferLength
              ) > USBSTOR_MAX_TRANSFER_PAGES) ||
        (USBSTOR_MAX_TRANSFER_SIZE < srbControl->DataTransferLength)))
    {
        return STATUS_INVALID_PARAMETER;
    }

    if (srbControl->TimeOutValue == 0 ||
        srbControl->TimeOutValue > 30 * 60 * 60)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check for illegal command codes.
    //

    if (srbControl->Cdb[0] == SCSIOP_COPY ||
        srbControl->Cdb[0] == SCSIOP_COMPARE ||
        srbControl->Cdb[0] == SCSIOP_COPY_COMPARE)
    {
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // If this request came through a normal device control rather than from
    // class driver then the device must exist and be unclaimed. Class drivers
    // will set the minor function code for the device control.  It is always
    // zero for a user request.
    //
    if (irpStack->MinorFunction == 0 &&
        pdoDeviceExtension->Claimed)
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate an aligned request sense buffer.
    //
    if (srbControl->SenseInfoLength != 0)
    {
        senseBuffer = ExAllocatePoolWithTag(NonPagedPoolCacheAligned,
                                            srbControl->SenseInfoLength,
                                            POOL_TAG);
        if (senseBuffer == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    else
    {
        senseBuffer = NULL;
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an addation stack locate would be needed.
    //

    try
    {
        irp = IoBuildSynchronousFsdRequest(
                    majorCode,
                    DeviceObject,
                    buffer,
                    length,
                    &startingOffset,
                    &event,
                    &ioStatusBlock);

    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        // An exception was incurred while attempting to probe the
        // caller's parameters.  Dereference the file object and return
        // an appropriate error status code.
        //
        if (senseBuffer != NULL)
        {
            ExFreePool(senseBuffer);
        }

        return GetExceptionCode();
    }

    if (irp == NULL)
    {
        if (senseBuffer != NULL)
        {
            ExFreePool(senseBuffer);
        }

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    // Set major code.
    //
    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->MinorFunction = 1;

    // Fill in SRB fields.
    //
    irpStack->Parameters.Others.Argument1 = &srb;

    // Zero out the srb.
    //
    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    // Fill in the srb.
    //
    srb.Length = SCSI_REQUEST_BLOCK_SIZE;
    srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb.SrbStatus = SRB_STATUS_PENDING;
    srb.CdbLength = srbControl->CdbLength;
    srb.SenseInfoBufferLength = srbControl->SenseInfoLength;

    switch (srbControl->DataIn)
    {
        case SCSI_IOCTL_DATA_OUT:
            if (srbControl->DataTransferLength)
            {
                srb.SrbFlags = SRB_FLAGS_DATA_OUT;
            }
            break;

        case SCSI_IOCTL_DATA_IN:
            if (srbControl->DataTransferLength)
            {
                srb.SrbFlags = SRB_FLAGS_DATA_IN;
            }
            break;

        default:
            srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT;
            break;
    }

    if (srbControl->DataTransferLength == 0)
    {
        srb.SrbFlags = 0;
    }
    else
    {
        // Flush the data buffer for output. This will insure that the data is
        // written back to memory.
        //
        KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);
    }

    srb.DataTransferLength = srbControl->DataTransferLength;
    srb.TimeOutValue = srbControl->TimeOutValue;
    srb.DataBuffer = (PCHAR) buffer + bufferOffset;
    srb.SenseInfoBuffer = senseBuffer;
    srb.OriginalRequest = irp;
    RtlCopyMemory(srb.Cdb, srbControl->Cdb, srbControl->CdbLength);

    // Call port driver to handle this request.
    //
    status = IoCallDriver(DeviceObject, irp);

    // Wait for request to complete.
    //
    if (status == STATUS_PENDING)
    {
        KeWaitForSingleObject(&event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
    }
    else
    {
        ioStatusBlock.Status = status;
    }

    // Copy the returned values from the srb to the control structure.
    //
    srbControl->ScsiStatus = srb.ScsiStatus;

    if (srb.SrbStatus  & SRB_STATUS_AUTOSENSE_VALID)
    {
        // Set the status to success so that the data is returned.
        //
        ioStatusBlock.Status = STATUS_SUCCESS;
        srbControl->SenseInfoLength = srb.SenseInfoBufferLength;

        // Copy the sense data to the system buffer.
        //
        RtlCopyMemory((PUCHAR) srbControl + srbControl->SenseInfoOffset,
                      senseBuffer,
                      srb.SenseInfoBufferLength);
    }
    else
    {
        srbControl->SenseInfoLength = 0;
    }


    // Free the sense buffer.
    //
    if (senseBuffer != NULL)
    {
        ExFreePool(senseBuffer);
    }

    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //
    if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN)
    {
        ioStatusBlock.Status = STATUS_SUCCESS;
    }

    srbControl->DataTransferLength = srb.DataTransferLength;

    // Set the information length
    //
    if (!srbControl->DataIn || bufferOffset == 0)
    {

        RequestIrp->IoStatus.Information = srbControl->SenseInfoOffset +
                                           srbControl->SenseInfoLength;
    }
    else
    {
        RequestIrp->IoStatus.Information = srbControl->DataBufferOffset +
                                           srbControl->DataTransferLength;
    }

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    DBGPRINT(2, ("exit:  USBSTOR_SendPassThrough %08X\n",
                 ioStatusBlock.Status));

    return ioStatusBlock.Status;
}


//******************************************************************************
//
// IsRequestValid()
//
// Validates IRP_MJ_SCSI SRB_FUNCTION_EXECUTE_SCSI requests against
// assumptions made later when processing the Srb.
//
//******************************************************************************

BOOLEAN
IsRequestValid (
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    BOOLEAN                 result;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Default return value unless a problem is found.
    //
    result = TRUE;

    // Note: SRB_FLAGS_UNSPECIFIED_DIRECTION is defined as
    //  (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == 0) {

        // Neither SRB_FLAGS_DATA_IN nor SRB_FLAGS_DATA_IN is set.
        // A transfer buffer should not be specified.

        if (srb->DataTransferLength ||
            srb->DataBuffer ||
            Irp->MdlAddress) {

            result = FALSE;
        }

    } else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) ==
               SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        // Both SRB_FLAGS_DATA_IN and SRB_FLAGS_DATA_IN are set.
        // We don't currently have a way to resolve this.

        result = FALSE;

    } else {

        // Either SRB_FLAGS_DATA_IN or SRB_FLAGS_DATA_IN is set.
        // A transfer buffer should be specified.

        if (!srb->DataTransferLength ||
            srb->DataTransferLength > USBSTOR_MAX_TRANSFER_SIZE ||
            //!srb->DataBuffer ||
            !Irp->MdlAddress) {

            result = FALSE;
        }
    }

    if (!result) {

        DBGPRINT(1, ("SrbFlags %08X, DataTransferLength %08X, "
                     "DataBuffer %08X, MdlAddress %08X\n",
                     srb->SrbFlags,
                     srb->DataTransferLength,
                     srb->DataBuffer,
                     Irp->MdlAddress));

        DBGPRINT(1, ("Irp %08X, Srb %08X\n",
                     Irp, srb));

        DBGFBRK(DBGF_BRK_INVALID_REQ);
    }

    return result;
}

//******************************************************************************
//
// USBSTOR_Scsi()
//
// Dispatch routine which handles IRP_MJ_SCSI
//
//******************************************************************************

NTSTATUS
USBSTOR_Scsi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PDEVICE_EXTENSION       deviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_Scsi\n"));

    DBGFBRK(DBGF_BRK_SCSI);

    deviceExtension = DeviceObject->DeviceExtension;

    // Only the PDO should handle IRP_MJ_SCSI
    //
    if (deviceExtension->Type == USBSTOR_DO_TYPE_PDO)
    {
        pdoDeviceExtension = DeviceObject->DeviceExtension;

        irpStack = IoGetCurrentIrpStackLocation(Irp);

        srb = irpStack->Parameters.Scsi.Srb;

        LOGENTRY('SCSI', DeviceObject, Irp, srb->Function);

        switch (srb->Function)
        {
            case SRB_FUNCTION_EXECUTE_SCSI:

                DBGPRINT(3, ("SRB_FUNCTION_EXECUTE_SCSI\n"));

                // XXXXX check STOP / REMOVE flags

                // XXXXX check SRB_FLAGS_BYPASS_LOCKED_QUEUE flag

                if (IsRequestValid(Irp))
                {
                    srb->SrbStatus = SRB_STATUS_PENDING;

                    IoMarkIrpPending(Irp);

                    IoStartPacket(pdoDeviceExtension->ParentFDO,
                                  Irp,
                                  &srb->QueueSortKey,
                                  USBSTOR_CancelIo);

                    ntStatus = STATUS_PENDING;
                }
                else
                {
                    ntStatus = STATUS_INVALID_PARAMETER;
                }
                break;


            case SRB_FUNCTION_FLUSH:

                DBGPRINT(2, ("SRB_FUNCTION_FLUSH\n"));

                ntStatus = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                break;

            case SRB_FUNCTION_CLAIM_DEVICE:

                DBGPRINT(2, ("SRB_FUNCTION_CLAIM_DEVICE\n"));

                //KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  &irql);
                {
                    if (pdoDeviceExtension->Claimed)
                    {
                        ntStatus = STATUS_DEVICE_BUSY;
                        srb->SrbStatus = SRB_STATUS_BUSY;
                    }
                    else
                    {
                        pdoDeviceExtension->Claimed = TRUE;
                        srb->DataBuffer = DeviceObject;
                        ntStatus = STATUS_SUCCESS;
                        srb->SrbStatus = SRB_STATUS_SUCCESS;
                    }
                }
                //KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  irql);
                break;

            case SRB_FUNCTION_RELEASE_DEVICE:

                DBGPRINT(2, ("SRB_FUNCTION_RELEASE_DEVICE\n"));

                //KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  &irql);
                {
                    pdoDeviceExtension->Claimed = FALSE;
                }
                //KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                //                  irql);

                ntStatus = STATUS_SUCCESS;
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                break;

            default:

                DBGPRINT(2, ("Unhandled SRB function %d\n", srb->Function));

                ntStatus = STATUS_NOT_SUPPORTED;
                srb->SrbStatus = SRB_STATUS_ERROR;
                break;
        }
    }
    else
    {
        ASSERT(deviceExtension->Type == USBSTOR_DO_TYPE_FDO);

        DBGPRINT(2, ("IRP_MJ_SCSI not supported for FDO\n"));

        ntStatus = STATUS_NOT_SUPPORTED;
    }

    if (ntStatus != STATUS_PENDING)
    {
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    DBGPRINT(3, ("exit:  USBSTOR_Scsi %08X\n", ntStatus));

    LOGENTRY('scsi', ntStatus, 0, 0);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_TranslateCDBSubmit()
//
// Called by USBSTOR_StartIo() before a request is started.
//
//******************************************************************************

VOID
USBSTOR_TranslateCDBSubmit (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PSCSI_REQUEST_BLOCK  Srb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCDB                    cdb;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->InterfaceDescriptor->bInterfaceSubClass ==
        USBSTOR_SUBCLASS_SCSI_PASSTHROUGH)
    {
        return;
    }

    // Save the original CDB
    //
    cdb = (PCDB)Srb->Cdb;

    RtlCopyMemory(fdoDeviceExtension->OriginalCDB, cdb, 16);

    // Make sure the CDB is padded with zero bytes.
    //
    if (Srb->CdbLength < 16)
    {
        RtlZeroMemory(&Srb->Cdb[Srb->CdbLength],
                      16 - Srb->CdbLength);

    }
    Srb->CdbLength = 12;

    switch (Srb->Cdb[0])
    {
        // Send a SCSIOP_START_STOP_UNIT request instead of a
        // SCSIOP_TEST_UNIT_READY request for selected buggy
        // devices which don't otherwise update their internal
        // geometry information when the media changes.
        //
        case SCSIOP_TEST_UNIT_READY:

            if (TEST_FLAG(fdoDeviceExtension->DeviceHackFlags,
                          DHF_TUR_START_UNIT))
            {
                // Zero the new CDB
                //
                RtlZeroMemory(cdb, 16);

                cdb->START_STOP.OperationCode = SCSIOP_START_STOP_UNIT;
                cdb->START_STOP.Start = 1;
            }
            break;

        // Convert 6-byte Mode Sense to 10-byte Mode Sense
        //
        case SCSIOP_MODE_SENSE:
        {
            UCHAR PageCode;
            UCHAR Length;

            // Extract the relevant params from original CDB
            //
            PageCode = cdb->MODE_SENSE.PageCode;
            Length   = cdb->MODE_SENSE.AllocationLength;

            // Zero the new CDB
            //
            RtlZeroMemory(cdb, 16);

            // Insert the relevant params into the translated CDB
            //
            cdb->MODE_SENSE10.OperationCode         = SCSIOP_MODE_SENSE10;
            cdb->MODE_SENSE10.PageCode              = PageCode;
            cdb->MODE_SENSE10.AllocationLength[1]   = Length;
        }
        break;

        // Convert 6-byte Mode Select to 10-byte Mode Select
        //
        case SCSIOP_MODE_SELECT:
        {
            UCHAR SPBit;
            UCHAR Length;

            // Extract the relevant params from original CDB
            //
            SPBit   = cdb->MODE_SELECT.SPBit;
            Length  = cdb->MODE_SELECT.ParameterListLength;

            // Zero the new CDB
            //
            RtlZeroMemory(cdb, 16);

            // Insert the relevant params into the translated CDB
            //
            cdb->MODE_SELECT10.OperationCode            = SCSIOP_MODE_SELECT10;
            cdb->MODE_SELECT10.SPBit                    = SPBit;
            cdb->MODE_SELECT10.PFBit                    = 1;
            cdb->MODE_SELECT10.ParameterListLength[1]   = Length;
        }
        break;
    }
}

//******************************************************************************
//
// USBSTOR_TranslateSrbStatus()
//
// This routine translates an srb status into an ntstatus.
//
//******************************************************************************

NTSTATUS
USBSTOR_TranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_BUS_RESET:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}

//******************************************************************************
//
// USBSTOR_TranslateCDBComplete()
//
// Called everywhere a request is completed.
//
//******************************************************************************

VOID
USBSTOR_TranslateCDBComplete (
    IN PDEVICE_OBJECT       DeviceObject,
    IN PIRP                 Irp,
    IN PSCSI_REQUEST_BLOCK  Srb
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCDB                    cdb;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    if (fdoDeviceExtension->InterfaceDescriptor->bInterfaceSubClass ==
        USBSTOR_SUBCLASS_SCSI_PASSTHROUGH)
    {
#if DBG
        if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
            (Srb->SenseInfoBufferLength >= 14))
        {
            PSENSE_DATA senseData;

            senseData = (PSENSE_DATA)Srb->SenseInfoBuffer;

            DBGPRINT(1, ("OP: %02X SenseKey %02X ASC %02X ASCQ %02X\n",
                         Srb->Cdb[0],
                         senseData->SenseKey,
                         senseData->AdditionalSenseCode,
                         senseData->AdditionalSenseCodeQualifier));
        }
#endif
        if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS)
        {
            Irp->IoStatus.Status = USBSTOR_TranslateSrbStatus(Srb);
        }

        return;
    }

    if (Srb->Cdb[0] != fdoDeviceExtension->OriginalCDB[0])
    {
        cdb = (PCDB)Srb->Cdb;

        switch (Srb->Cdb[0])
        {
            // Convert 10-byte Mode Sense back to 6-byte Mode Sense
            //
            case SCSIOP_MODE_SENSE10:
            {
                if ((SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_SUCCESS ||
                     SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) &&
                    Srb->DataTransferLength >= sizeof(MODE_PARAMETER_HEADER10))
                {
                    PMODE_PARAMETER_HEADER   hdr6;
                    PMODE_PARAMETER_HEADER10 hdr10;

                    hdr6  = (PMODE_PARAMETER_HEADER)  Srb->DataBuffer;
                    hdr10 = (PMODE_PARAMETER_HEADER10)Srb->DataBuffer;

                    // Convert the 10-byte header to a 6-byte header
                    //
                    hdr6->ModeDataLength = hdr10->ModeDataLength[1];

                    hdr6->MediumType = hdr10->MediumType;

                    hdr6->DeviceSpecificParameter =
                        hdr10->DeviceSpecificParameter;

                    hdr6->BlockDescriptorLength =
                        hdr10->BlockDescriptorLength[1];

                    // Advance past headers
                    //
                    hdr6++;
                    hdr10++;

                    // Copy everything past the 10-byte header
                    //
                    RtlMoveMemory(hdr6,
                                  hdr10,
                                  (Srb->DataTransferLength -
                                   sizeof(MODE_PARAMETER_HEADER10)));

                    // Adjust the return size to account for the smaller header
                    //
                    Srb->DataTransferLength -= (sizeof(MODE_PARAMETER_HEADER10) -
                                                sizeof(MODE_PARAMETER_HEADER));

                    // Since we just shrunk Srb->DataTransferLength, don't
                    // we have SRB_STATUS_DATA_OVERRUN by definition???
                    //
                    if (Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID)
                    {
                        Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN |
                                         SRB_STATUS_AUTOSENSE_VALID;
                    }
                    else
                    {
                        Srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
                    }
                }
            }
            break;
        }

        // Restore the original CDB
        //
        RtlCopyMemory(cdb, fdoDeviceExtension->OriginalCDB, 16);
    }

#if DBG
    if ((Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
        (Srb->SenseInfoBufferLength >= 14))
    {
        PSENSE_DATA senseData;

        senseData = (PSENSE_DATA)Srb->SenseInfoBuffer;

        DBGPRINT(1, ("OP: %02X SenseKey %02X ASC %02X ASCQ %02X\n",
                     Srb->Cdb[0],
                     senseData->SenseKey,
                     senseData->AdditionalSenseCode,
                     senseData->AdditionalSenseCodeQualifier));
    }
#endif

    if (SRB_STATUS(Srb->SrbStatus) != SRB_STATUS_SUCCESS)
    {
        Irp->IoStatus.Status = USBSTOR_TranslateSrbStatus(Srb);
    }
}

//******************************************************************************
//
// USBSTOR_CancelIo()
//
// This routine runs at DPC level (until the cancel spinlock is released).
//
//******************************************************************************

VOID
USBSTOR_CancelIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    if (DeviceObject->CurrentIrp == Irp)
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        LOGENTRY('CAN1', DeviceObject, Irp, 0);

        DBGPRINT(1, ("USBSTOR_CancelIo cancelling CurrentIrp\n"));
    }
    else if (KeRemoveEntryDeviceQueue(&DeviceObject->DeviceQueue,
                                      &Irp->Tail.Overlay.DeviceQueueEntry))
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);

        LOGENTRY('CAN2', DeviceObject, Irp, 0);

        DBGPRINT(1, ("USBSTOR_CancelIo cancelling queued Irp\n"));

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }
    else
    {
        IoReleaseCancelSpinLock(Irp->CancelIrql);
    }
}

//******************************************************************************
//
// USBSTOR_StartIo()
//
// This routine handles IRP_MJ_SCSI, SRB_FUNCTION_EXECUTE_SCSI requests from
// the device the queue.
//
// This routine runs at DPC level.
//
//******************************************************************************

VOID
USBSTOR_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    BOOLEAN                 startNext;
    BOOLEAN                 deviceDisconnected;
    BOOLEAN                 persistentError;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('STIO', DeviceObject, Irp, 0);

    DBGPRINT(3, ("enter: USBSTOR_StartIo %08X %08X\n",
                 DeviceObject, Irp));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Check to see if this is a power down Irp.
    //
    if (irpStack->MajorFunction == IRP_MJ_POWER)
    {
        // This is a power down Irp.  Now that we know that no transfer
        // requests are in progress, pass down the power Irp.

        ASSERT(irpStack->MinorFunction == IRP_MN_SET_POWER);
        ASSERT(irpStack->Parameters.Power.Type == DevicePowerState);
        ASSERT(irpStack->Parameters.Power.State.DeviceState !=
               PowerDeviceD0);

        DBGPRINT(2, ("FDO Power Down Passing Down %08X %08X\n",
                     DeviceObject, Irp));

        LOGENTRY('FPDC', DeviceObject, Irp, 0);

        //
        // Signal that it is time to pass the request down to the next
        // lower driver
        //
        KeSetEvent(&fdoDeviceExtension->PowerDownEvent,
                   IO_NO_INCREMENT,
                   0);

        // Leave the device queue blocked now by simply not calling
        // IoStartNextPacket().  When we want to start the device queue
        // again, simply call IoStartNextPacket().

        return;
    }

    // If the Irp is not IRP_MJ_POWER it better be IRP_MJ_SCSI
    //
    ASSERT(irpStack->MajorFunction == IRP_MJ_SCSI);

    // Check to see if the current Irp was cancelled.
    //
    IoAcquireCancelSpinLock(&irql);
    IoSetCancelRoutine(Irp, NULL);

    if (Irp->Cancel)
    {
        // The current Irp was cancelled.  Complete the request now, and start
        // the next request, unless a reset is still in progress in which case
        // the next request will be started when the reset completes.
        //
        KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
        {
            startNext = !TEST_FLAG(fdoDeviceExtension->DeviceFlags,
                                   DF_RESET_IN_PROGRESS);
        }
        KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);

        IoReleaseCancelSpinLock(irql);

        LOGENTRY('CAN3', DeviceObject, Irp, 0);

        Irp->IoStatus.Status = STATUS_CANCELLED;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        if (startNext)
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }

        return;
    }

    // The current Irp was not cancelled.  It is no longer cancelable.
    //
    IoReleaseCancelSpinLock(irql);

    // Get our Irp parameters
    //
    srb = irpStack->Parameters.Scsi.Srb;
    fdoDeviceExtension->OriginalSrb = srb;

    deviceDisconnected = FALSE;
    persistentError = FALSE;

    KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
    {
        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_DEVICE_DISCONNECTED))
        {
            deviceDisconnected = TRUE;
        }
        else
        {
            fdoDeviceExtension->SrbTimeout = srb->TimeOutValue;

            if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR))
            {
                persistentError = TRUE;

                CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);


    if (deviceDisconnected)
    {
        LOGENTRY('siod', DeviceObject, Irp, 0);

        // The device is disconnected, fail this request immediately and start
        // the next request.
        //
        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        srb->DataTransferLength = 0;

        ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);

        IoStartNextPacket(DeviceObject, TRUE);
    }
    else
    {
        // Translate the CDB if necessary
        //
        USBSTOR_TranslateCDBSubmit(DeviceObject, Irp, srb);

        DBGPRINT(3, ("CDB OP 0x%02X, Length %d\n", srb->Cdb[0], srb->CdbLength));

        if (fdoDeviceExtension->DriverFlags == DeviceProtocolBulkOnly)
        {
            ntStatus = USBSTOR_CbwTransfer(DeviceObject,
                                           Irp);
        }
        else
        {
            if (persistentError && (srb->Cdb[0] != SCSIOP_REQUEST_SENSE))
            {
                // There was a persistent error during the last request which
                // was not cleared with an AutoSense, and this request is not
                // a Request Sense, so first clear the persistent error with a
                // Request Sense before issuing this request.
                //
                ntStatus = USBSTOR_IssueRequestSenseCdb(DeviceObject,
                                                        Irp,
                                                        NON_AUTO_SENSE);
            }
            else
            {
                // Normal case, just issue the real request.
                //
                ntStatus = USBSTOR_IssueClientCdb(DeviceObject,
                                                  Irp);
            }
        }
    }

    DBGPRINT(3, ("exit:  USBSTOR_StartIo %08X\n", ntStatus));

    return;
}

//******************************************************************************
//
// USBSTOR_CheckRequestTimeOut()
//
// Returns TRUE if the request timed out and the request should be completed.
//
//******************************************************************************

BOOLEAN
USBSTOR_CheckRequestTimeOut (
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp,
    IN  PSCSI_REQUEST_BLOCK Srb,
    OUT PNTSTATUS           NtStatus
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 resetStarted;
    KIRQL                   irql;
    PIO_STACK_LOCATION      irpStack;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Check to see if a reset was started while this request was in progress.
    //
    resetStarted = FALSE;

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);

        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS))
        {
            LOGENTRY('CRT1', DeviceObject, Irp, Srb);

            resetStarted = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // If a timeout reset has been started, then complete this request with
    // a timeout error.  Well, don't actually complete the request just yet.
    // Signal the cancel completion event and let USBSTOR_ResetDeviceWorkItem()
    // complete the request.  This allows USBSTOR_ResetDeviceWorkItem() to
    // cancel the request without worrying about the request completing and
    // disappearing out from underneath it.
    //
    if (resetStarted)
    {
        irpStack = IoGetCurrentIrpStackLocation(Irp);

        Srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = Srb;

        Irp->IoStatus.Status = STATUS_IO_TIMEOUT;
        Irp->IoStatus.Information = 0;
        Srb->SrbStatus = SRB_STATUS_TIMEOUT;

        USBSTOR_TranslateCDBComplete(DeviceObject, Irp, Srb);

        *NtStatus = STATUS_MORE_PROCESSING_REQUIRED;

        KeSetEvent(&fdoDeviceExtension->CancelEvent,
                   IO_NO_INCREMENT,
                   FALSE);

        return TRUE;
    }
    else
    {
        fdoDeviceExtension->PendingIrp = NULL;

        return FALSE;
    }
}

//******************************************************************************
//
// USBSTOR_IssueControlRequest()
//
// This routine is called by USBSTOR_IssueClientCdb() and
// USBSTOR_IssueRequestSenseCdb()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Intializes the Control transfer Urb and sends it down the stack:
//
// bmRequestType = 0x21, Class specific, host to device transfer, to
//                       recipient interface
// bRequest      = 0x00, Accept Device Specific Command
// wValue        = 0x00, Not Used
// wIndex        = bInterfaceNumber
// wLength       = length of device specific command block
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueControlRequest (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN ULONG                    TransferBufferLength,
    IN PVOID                    TransferBuffer,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine,
    IN PVOID                    Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      nextStack;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_IssueControlRequest\n"));

    LOGENTRY('ICTR', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control/Bulk/Interrupt Transfer URB in our
    // Device Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Initialize the Control Transfer URB, all fields default to zero
    //
    RtlZeroMemory(controlUrb, sizeof(*controlUrb));

    controlUrb->Hdr.Length = sizeof(*controlUrb);

    controlUrb->Hdr.Function = URB_FUNCTION_CLASS_INTERFACE;

    // controlUrb->TransferFlags            is already zero

    controlUrb->TransferBufferLength = TransferBufferLength;

    controlUrb->TransferBuffer = TransferBuffer;

    // controlUrb->TransferBufferMDL        is already zero

    // controlUrb->RequestTypeReservedBits  is already zero

    // controlUrb->Request                  is already zero

    // controlUrb->Value                    is already zero

    // Target the request at the proper interface on the device
    //
    controlUrb->Index = fdoDeviceExtension->InterfaceInfo->InterfaceNumber;

    // Set the Irp parameters for the lower driver
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = controlUrb;

    // Set the completion routine, which will handle the next phase of the Srb
    //
    IoSetCompletionRoutine(Irp,
                           CompletionRoutine,
                           Context,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel


    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        fdoDeviceExtension->PendingIrp = Irp;

        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);


    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(3, ("exit:  USBSTOR_IssueControlRequest %08X\n", ntStatus));

    LOGENTRY('ictr', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueBulkOrInterruptRequest()
//
// This routine is called by USBSTOR_IssueClientBulkRequest(),
// USBSTOR_IssueInterruptRequest() and USBSTOR_IssueRequestSenseBulkRequest().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Initializes the Bulk or Interrupt transfer Urb and sends it down the stack
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueBulkOrInterruptRequest (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PIRP                     Irp,
    IN USBD_PIPE_HANDLE         PipeHandle,
    IN ULONG                    TransferFlags,
    IN ULONG                    TransferBufferLength,
    IN PVOID                    TransferBuffer,
    IN PMDL                     TransferBufferMDL,
    IN PIO_COMPLETION_ROUTINE   CompletionRoutine,
    IN PVOID                    Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      nextStack;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkIntrUrb;

    DBGPRINT(3, ("enter: USBSTOR_IssueBulkOrInterruptRequest\n"));

    LOGENTRY('IBIR', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk/Interrupt Transfer URB in our Device Extension
    //
    bulkIntrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Initialize the Bulk/Interrupt Transfer URB, all fields default to zero
    //
    RtlZeroMemory(bulkIntrUrb, sizeof(*bulkIntrUrb));

    bulkIntrUrb->Hdr.Length = sizeof(*bulkIntrUrb);

    bulkIntrUrb->Hdr.Function = URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;

    bulkIntrUrb->PipeHandle = PipeHandle;

    bulkIntrUrb->TransferFlags = TransferFlags;

    bulkIntrUrb->TransferBufferLength = TransferBufferLength;

    bulkIntrUrb->TransferBuffer = TransferBuffer;

    bulkIntrUrb->TransferBufferMDL = TransferBufferMDL;

    // Set the Irp parameters for the lower driver
    //
    nextStack = IoGetNextIrpStackLocation(Irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_SUBMIT_URB;

    nextStack->Parameters.Others.Argument1 = bulkIntrUrb;

    // Set the completion routine, which will handle the next phase of the Srb
    //
    IoSetCompletionRoutine(Irp,
                           CompletionRoutine,
                           Context,
                           TRUE,    // InvokeOnSuccess
                           TRUE,    // InvokeOnError
                           TRUE);   // InvokeOnCancel


    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        fdoDeviceExtension->PendingIrp = Irp;

        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            Irp);

    DBGPRINT(3, ("exit:  USBSTOR_IssueBulkOrInterruptRequest %08X\n", ntStatus));

    LOGENTRY('ibir', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//
// CBI (Control/Bulk/Interrupt) Routines
//

//
// Phase 1, CDB Control transfer
//

//******************************************************************************
//
// USBSTOR_IssueClientCdb()
//
// This routine is called by USBSTOR_StartIo().
//
// It runs at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write the Srb->Cdb out the control endpoint.
//
// Sets USBSTOR_ClientCdbCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueClientCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueClientCdb\n"));

    LOGENTRY('ICDB', DeviceObject, Irp, 0);

    // Get the client Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    ntStatus = USBSTOR_IssueControlRequest(
                   DeviceObject,
                   Irp,
                   srb->CdbLength,              // TransferBufferLength
                   srb->Cdb,                    // TransferBuffer
                   USBSTOR_ClientCdbCompletion, // CompletionRoutine
                   NULL);                       // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueClientCdb %08X\n", ntStatus));

    LOGENTRY('icdb', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ClientCdbCompletion()
//
// Completion routine used by USBSTOR_IssueClientCdb()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the CDB USB transfer failed due to a STALL and AutoSense is not
// disabled, do not complete the request yet and start a Request Sense by
// calling USBSTOR_IssueRequestSenseCdb(AUTO_SENSE).
//
// Else if the CDB USB transfer failed due to a STALL and AutoSense is
// disabled, mark a persistant error and complete the request.
//
// Else if the CDB USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the CDB USB transfer succeeded and the Srb has a transfer buffer,
// do not complete the request yet and start the bulk data transfer by calling
// USBSTOR_IssueClientBulkRequest().
//
// Else if the CDB USB transfer succeeded and the Srb has no transfer buffer,
// do not complete the request yet and start the command completion interrupt
// data transfer by calling USBSTOR_IssueInterruptRequest().
//
//******************************************************************************

NTSTATUS
USBSTOR_ClientCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_ClientCdbCompletion\n"));

    LOGENTRY('CDBC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control Transfer URB in our Device Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cdb1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_ClientCdbCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The CDB Control Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('cdb2', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CDB transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, controlUrb->Hdr.Status));

        if (USBD_STATUS(controlUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Control Transfer

            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
            srb->DataTransferLength = 0;

            if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
                (srb->SenseInfoBufferLength != 0) &&
                (srb->SenseInfoBuffer != NULL))
            {
                LOGENTRY('cdb3', fdoDeviceObject, Irp, srb);

                // AutoSense is not disabled so do not complete the request yet
                // and issue a Request Sense.  This request will be completed
                // and the next request started when the AutoSense Request
                // Sense completes later.
                //
                ntStatus = USBSTOR_IssueRequestSenseCdb(fdoDeviceObject,
                                                        Irp,
                                                        AUTO_SENSE);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                LOGENTRY('cdb4', fdoDeviceObject, Irp, srb);

                // AutoSense is disabled so mark a persistent error and complete
                // this request now.  Also start the next request now.
                //
                ntStatus = STATUS_IO_DEVICE_ERROR;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  &irql);
                {
                    SET_FLAG(fdoDeviceExtension->DeviceFlags,
                             DF_PERSISTENT_ERROR);
                }
                KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  irql);

                USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

                KeRaiseIrql(DISPATCH_LEVEL, &irql);
                {
                    IoStartNextPacket(fdoDeviceObject, TRUE);
                }
                KeLowerIrql(irql);

                return ntStatus;
            }
        }
        else
        {
            LOGENTRY('cdb5', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_ClientCdbCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    // The CDB Control Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or Command Completion Interrupt Transfer, and do
    // not complete the request yet (unless there is no Bulk Transfer and the
    // Interrupt Transfer is not supported).
    //
    if (Irp->MdlAddress != NULL)
    {
        LOGENTRY('cdb6', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength != 0);

        // The Srb has a transfer buffer, start the Data Bulk Transfer.
        //
        ntStatus = USBSTOR_IssueClientBulkRequest(fdoDeviceObject,
                                                  Irp);

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_ERROR;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);
        }
    }
    else
    {
        ASSERT(srb->DataTransferLength == 0);

        // The Srb has no transfer buffer.  If the Command Completion
        // Interrupt Transfer is supported, start the Command Completion
        // Interrupt Transfer, else just complete the request now and
        // start the next request.
        //
        if (fdoDeviceExtension->InterruptInPipe)
        {
            LOGENTRY('cdb7', fdoDeviceObject, Irp, srb);

            srb->SrbStatus = SRB_STATUS_SUCCESS;

            ntStatus = USBSTOR_IssueInterruptRequest(fdoDeviceObject,
                                                     Irp);

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('cdb8', fdoDeviceObject, Irp, srb);

            ntStatus = STATUS_SUCCESS;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_SUCCESS;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            {
                IoStartNextPacket(fdoDeviceObject, TRUE);
            }
            KeLowerIrql(irql);
        }
    }

    DBGPRINT(3, ("exit:  USBSTOR_ClientCdbCompletion %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 2, Data Bulk transfer
//

//******************************************************************************
//
// USBSTOR_IssueClientBulkRequest()
//
// This routine is called by USBSTOR_ClientCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read or write the Srb->DataBuffer data In or Out
// the Bulk endpoint.
//
// Sets USBSTOR_ClientBulkCompletionRoutine() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueClientBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PMDL                    mdl;
    PVOID                   mdlVa;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueClientBulkRequest\n"));

    LOGENTRY('ICBK', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Bulk IN or Bulk OUT?
    //
    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_IN)
    {
        pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;
        transferFlags = USBD_SHORT_TRANSFER_OK;
    }
    else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_OUT)
    {
        pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;
        transferFlags = 0;
    }
    else
    {
        // Something is wrong if we end up here.
        //
        ASSERT((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) &&
               ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) !=
                SRB_FLAGS_UNSPECIFIED_DIRECTION));

        return STATUS_INVALID_PARAMETER;
    }

    // Check to see if this request is part of a split request.
    //
    mdlVa = MmGetMdlVirtualAddress(Irp->MdlAddress);

    if (mdlVa == (PVOID)srb->DataBuffer)
    {
        // Not part of a split request, use original MDL
        //
        mdl = Irp->MdlAddress;
    }
    else
    {
        // Part of a split request, allocate new partial MDL
        //
        mdl = IoAllocateMdl(srb->DataBuffer,
                            srb->DataTransferLength,
                            FALSE,
                            FALSE,
                            NULL);
        if (mdl == NULL)
        {
            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            IoBuildPartialMdl(Irp->MdlAddress,
                              mdl,
                              srb->DataBuffer,
                              srb->DataTransferLength);
        }
    }

    if (mdl != NULL)
    {
        ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                       DeviceObject,
                       Irp,
                       pipeHandle,                          // PipeHandle
                       transferFlags,                       // TransferFlags
                       srb->DataTransferLength,             // TransferBufferLen
                       NULL,                                // TransferBuffer
                       mdl,                                 // TransferBufferMDL
                       USBSTOR_ClientBulkCompletionRoutine, // CompletionRoutine
                       NULL);                               // Context

        // Just return STATUS_SUCCESS at this point.  If there is an error,
        // USBSTOR_ClientBulkCompletionRoutine() will handle it, not the caller
        // of USBSTOR_IssueClientBulkRequest().
        //
        ntStatus = STATUS_SUCCESS;
    }

    DBGPRINT(3, ("exit:  USBSTOR_IssueClientBulkRequest %08X\n", ntStatus));

    LOGENTRY('icbk', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ClientBulkCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueClientBulkRequest
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Bulk USB transfer failed due to a STALL and AutoSense is not
// disabled, do not complete the request yet and start a pipe reset by calling
// USBSTOR_QueueResetPipe().
//
// Else if the Bulk USB transfer failed due to a STALL and AutoSense is
// disabled, mark a persistant error and complete the request.
//
// Else if the Bulk USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Bulk USB transfer succeeded, start the command completion
// interrupt data transfer by calling USBSTOR_IssueInterruptRequest().
//
//******************************************************************************

NTSTATUS
USBSTOR_ClientBulkCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_ClientBulkCompletionRoutine\n"));

    LOGENTRY('CBKC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (bulkUrb->TransferBufferMDL != Irp->MdlAddress)
    {
        IoFreeMdl(bulkUrb->TransferBufferMDL);
    }

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cbk1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_ClientBulkCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('cbk2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Client Bulk transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Bulk Transfer

            srb->SrbStatus = SRB_STATUS_ERROR;
            srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
            srb->DataTransferLength = bulkUrb->TransferBufferLength;

            if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
                (srb->SenseInfoBufferLength != 0) &&
                (srb->SenseInfoBuffer != NULL))
            {
                LOGENTRY('cbk3', fdoDeviceObject, Irp, srb);

                // AutoSense is not disabled so do not complete the request
                // yet.  Queue a bulk pipe reset.  After the bulk pipe reset
                // completes, a Request Sense will be issued.  This request
                // will be completed and the next request started when the
                // AutoSense Request Sense completes later.
                //
                USBSTOR_QueueResetPipe(fdoDeviceObject);

                return STATUS_MORE_PROCESSING_REQUIRED;
            }
            else
            {
                LOGENTRY('cbk4', fdoDeviceObject, Irp, srb);

                // AutoSense is disabled so mark a persistent error and
                // complete the request, but also queue a bulk pipe reset.
                //
                // The next request will be started when the bulk pipe
                // reset completes.
                //
                ntStatus = STATUS_IO_DEVICE_ERROR;
                Irp->IoStatus.Status = ntStatus;
                Irp->IoStatus.Information = 0;

                KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  &irql);
                {
                    SET_FLAG(fdoDeviceExtension->DeviceFlags,
                             DF_PERSISTENT_ERROR);
                }
                KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock,
                                  irql);

                USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

                USBSTOR_QueueResetPipe(fdoDeviceObject);

                return ntStatus;
            }
        }
        else
        {
            LOGENTRY('cbk5', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_ClientBulkCompletionRoutine: xfer error completion\n"));

            return ntStatus;
        }
    }

    // Check for overrun
    //
    if (bulkUrb->TransferBufferLength < srb->DataTransferLength)
    {
        srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
    }
    else
    {
        srb->SrbStatus = SRB_STATUS_SUCCESS;
    }

    // Update the the Srb data transfer length based on the actual bulk
    // transfer length.
    //
    srb->DataTransferLength = bulkUrb->TransferBufferLength;

    // Client data Bulk Transfer successful completion.  If the Command
    // Completion Interrupt Transfer is supported, start the Command Completion
    // Interrupt Transfer, else just complete the request now and start the
    // next request.
    //
    if (fdoDeviceExtension->InterruptInPipe)
    {
        LOGENTRY('cbk6', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

        ntStatus = USBSTOR_IssueInterruptRequest(fdoDeviceObject,
                                                 Irp);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        LOGENTRY('cbk7', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

        ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Status = ntStatus;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        Irp->IoStatus.Information = srb->DataTransferLength;

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(fdoDeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }

    DBGPRINT(3, ("exit:  USBSTOR_ClientBulkCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 3, Command completion Interrupt transfer
//

//******************************************************************************
//
// USBSTOR_IssueInterruptRequest()
//
// This routine is called by USBSTOR_ClientCdbCompletion() and
// USBSTOR_ClientBulkCompletionRoutine()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the command completion interrupt data In
// the Interrupt endpoint.
//
// Sets USBSTOR_InterruptDataCompletionRoutine() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueInterruptRequest\n"));

    LOGENTRY('IINT', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    pipeHandle = fdoDeviceExtension->InterruptInPipe->PipeHandle;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.InterruptData);

    transferBuffer = &fdoDeviceExtension->Cbi.InterruptData;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                              // PipeHandle
                   0,                                       // TransferFlags
                   transferBufferLength,                    // TransferBufferLength
                   transferBuffer,                          // TransferBuffer
                   NULL,                                    // TransferBufferMDL
                   USBSTOR_InterruptDataCompletionRoutine,  // CompletionRoutine
                   NULL);                                   // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueInterruptRequest %08X\n", ntStatus));

    LOGENTRY('iint', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_InterruptDataCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueInterruptRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Interrupt USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is not disabled, do not complete the request yet and
// start a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is disabled, mark a persistant error and complete
// the request.
//
// Else if the Interrupt USB transfer succeeded and the completion data is
// zero, complete the request.
//
//******************************************************************************

NTSTATUS
USBSTOR_InterruptDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *intrUrb;

    DBGPRINT(3, ("enter: USBSTOR_InterruptDataCompletionRoutine\n"));

    LOGENTRY('IDCR', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Interrupt Transfer URB in our Device Extension
    //
    intrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('idc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_InterruptDataCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Interrupt CDB USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        LOGENTRY('idc2', Irp->IoStatus.Status, intrUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Interrupt transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, intrUrb->Hdr.Status));

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_InterruptDataCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    if ((fdoDeviceExtension->Cbi.InterruptData != 0) &&
        (srb->Cdb[0] != SCSIOP_INQUIRY) &&
        (srb->Cdb[0] != SCSIOP_REQUEST_SENSE))
    {
        // Command completion interrupt data indicates an error.  Either don't
        // complete the request yet and start an AutoSense, or complete the
        // request now and indicate a persistent error.
        //
        srb->SrbStatus = SRB_STATUS_ERROR;
        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        srb->DataTransferLength = 0; // XXXXX Leave as set by bulk completion???

        if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
            (srb->SenseInfoBufferLength != 0) &&
            (srb->SenseInfoBuffer != NULL))
        {
            LOGENTRY('idc3', fdoDeviceObject, Irp, srb);

            // AutoSense is not disabled so do not complete the request
            // yet.  Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a Request Sense will be issued.  This request
            // will be completed and the next request started when the
            // AutoSense Request Sense completes later.
            //
            USBSTOR_QueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('idc4', fdoDeviceObject, Irp, srb);

            // AutoSense is disabled so mark a persistent error and
            // complete the request, but also queue a bulk pipe reset.
            //
            // The next request will be started when the bulk pipe
            // reset completes.
            //
            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;

            KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
            {
                SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
            }
            KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetPipe(fdoDeviceObject);

            return ntStatus;
        }
    }

    // Hack for Y-E Data USB Floppy.  Occasionally it will return interrupt
    // data with the wrong data toggle.  The interrupt data with the wrong
    // toggle is silently ignored, which results in a request timeout.
    // Forcing a Request Sense command between the completion of one command
    // and the start of the next appears to be one way to work around this.
    //
    if (TEST_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_FORCE_REQUEST_SENSE))
    {
        KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
        {
            SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR);
        }
        KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);
    }

    // The Interrupt USB transfer succeeded and the completion data is zero,
    // complete this request now.  Also start the next request now.

    ntStatus = STATUS_SUCCESS;
    Irp->IoStatus.Status = ntStatus;

    ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

    USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

    Irp->IoStatus.Information = srb->DataTransferLength;

    LOGENTRY('idc5', fdoDeviceObject, Irp, srb);

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(fdoDeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    DBGPRINT(3, ("exit:  USBSTOR_InterruptDataCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 4, Request Sense CDB Control transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseCdb()
//
// This routine can be called by USBSTOR_StartIo, USBSTOR_ClientCdbCompletion(),
// USBSTOR_InterruptDataCompletionRoutine(), and by USBSTOR_ResetPipeWorkItem().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write a Request Sense CDB out the control endpoint.
//
// Sets USBSTOR_RequestSenseCdbCompletion(AutoFlag) as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseCdb (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSenseCdb\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get the client Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // The Control Transfer data buffer is our own Request Sense Cdb
    //
    RtlZeroMemory(fdoDeviceExtension->Cbi.RequestSenseCDB,
                  sizeof(fdoDeviceExtension->Cbi.RequestSenseCDB));

    fdoDeviceExtension->Cbi.RequestSenseCDB[0] = SCSIOP_REQUEST_SENSE;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.RequestSenseCDB);

    transferBuffer = fdoDeviceExtension->Cbi.RequestSenseCDB;

    // If this is an AutoSense, we'll use the client Srb Sense Info Buffer,
    // else we are doing this Request Sense to clear a persistent error and
    // we'll use our own sense info buffer.
    //
    if (AutoFlag == AUTO_SENSE)
    {
        fdoDeviceExtension->Cbi.RequestSenseCDB[4] =
            srb->SenseInfoBufferLength;
    }
    else
    {
        fdoDeviceExtension->Cbi.RequestSenseCDB[4] =
            sizeof(fdoDeviceExtension->Cbi.SenseData);
    }

    ntStatus = USBSTOR_IssueControlRequest(
                   DeviceObject,
                   Irp,
                   transferBufferLength,                // TransferBufferLength
                   transferBuffer,                      // TransferBuffer
                   USBSTOR_RequestSenseCdbCompletion,   // CompletionRoutine
                   (PVOID)AutoFlag);                    // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSenseCdb %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_RequestSenseCdbCompletion()
//
// Completion routine used by USBSTOR_IssueRequestSenseCdb
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Request Sense CDB USB transfer failed, complete the request and
// start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Request Sense CDB USB transfer succeeded, do not complete the
// request yet and start the Request Sense Bulk USB data transfer by calling
// USBSTOR_IssueRequestSenseBulkRequest(AutoFlag)
//
//******************************************************************************

NTSTATUS
USBSTOR_RequestSenseCdbCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST *controlUrb;

    DBGPRINT(3, ("enter: USBSTOR_RequestSenseCdbCompletion\n"));

    LOGENTRY('RSCC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Control/Bulk/Interrupt Transfer URB in our Device
    // Extension
    //
    controlUrb = &fdoDeviceExtension->Urb.ControlUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('rsc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_RequestSenseCdbCompletion: timeout completion\n"));
        return ntStatus;
    }


    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        LOGENTRY('rsc2', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Request Sense CDB transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, controlUrb->Hdr.Status));

        // The Request Sense CDB USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_RequestSenseCdbCompletion: xfer error completion\n"));

        return ntStatus;
    }

    LOGENTRY('rsc3', Irp->IoStatus.Status, controlUrb->Hdr.Status, 0);

    // The Request Sense CDB USB transfer succeeded, do not complete the request
    // yet and start the Request Sense Bulk USB data transfer.
    //
    ntStatus = USBSTOR_IssueRequestSenseBulkRequest(fdoDeviceObject,
                                                    Irp,
                                                    (ULONG_PTR)AutoFlag);

    DBGPRINT(3, ("exit:  USBSTOR_RequestSenseCdbCompletion %08X\n", ntStatus));

    return STATUS_MORE_PROCESSING_REQUIRED;
}

//
// Phase 5, Request Sense Bulk transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseBulkRequest()
//
// This routine is called by USBSTOR_RequestSenseCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the Requese Sense data in the bulk endpoint.
//
// If AutoFlag==AUTO, transfer buffer = Srb->SenseInfoBuffer.
//
// Else if AutoFlag==NON_AUTO, transfer buffer = bit bucket
//
// Sets USBSTOR_SenseDataCompletionRoutine(AutoFlag) as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseBulkRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;

    // If this is an AutoSense, we'll use the client Srb Sense Info Buffer,
    // else we are doing this Request Sense to clear a persistent error and
    // we'll use our own sense info buffer.
    //
    if (AutoFlag == AUTO_SENSE)
    {
        transferBufferLength = srb->SenseInfoBufferLength;
        transferBuffer = srb->SenseInfoBuffer;
    }
    else
    {
        transferBufferLength = sizeof(fdoDeviceExtension->Cbi.SenseData);
        transferBuffer = &fdoDeviceExtension->Cbi.SenseData;
    }

    RtlZeroMemory(&fdoDeviceExtension->Cbi.SenseData,
                  sizeof(fdoDeviceExtension->Cbi.SenseData));

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                          // PipeHandle
                   USBD_SHORT_TRANSFER_OK,              // TransferFlags
                   transferBufferLength,                // TransferBufferLength
                   transferBuffer,                      // TransferBuffer
                   NULL,                                // TransferBufferMDL
                   USBSTOR_SenseDataCompletionRoutine,  // CompletionRoutine
                   (PVOID)AutoFlag);                    // Context

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_SenseDataCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueRequestSenseBulkRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Request Sense Bulk USB transfer failed due to any reason,
// complete the request and start a reset by queuing a call to
// USBSTOR_ResetDeviceWorkItem().
//
// Else if the Request Sense Bulk USB transfer succeeded and the device
// does support the command completion interrupt, start the command completion
// interrupt transfer by calling USBSTOR_IssueRequestSenseInterruptRequest().
//
// Else if the Request Sense Bulk USB transfer succeeded and the device
// does not support the command completion interrupt, complete the request
// by calling USBSTOR_ProcessRequestSenseCompletion().
//
//******************************************************************************

NTSTATUS
USBSTOR_SenseDataCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_SenseDataCompletionRoutine\n"));

    LOGENTRY('SDCR', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('sdc1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_SenseDataCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        LOGENTRY('sdc2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("BULK sense data transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        // The Request Sense Bulk USB transfer failed.  Complete this request
        // now and then reset the device.  The next request will be started
        // when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_SenseDataCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    // The Request Sense Bulk transfer completed successfully.

    LOGENTRY('sdc3', Irp->IoStatus.Status, bulkUrb->Hdr.Status,
             bulkUrb->TransferBufferLength);

    // Save the sense data so we can look at it after the command
    // completion interrupt transfer completes.
    //
    if ((ULONG_PTR)AutoFlag == AUTO_SENSE)
    {
        RtlCopyMemory(&fdoDeviceExtension->Cbi.SenseData,
                      bulkUrb->TransferBuffer,
                      min(bulkUrb->TransferBufferLength,
                          sizeof(fdoDeviceExtension->Cbi.SenseData)));

        // Update the SRB with the length of the sense data that was
        // actually returned.
        //
        srb->SenseInfoBufferLength = (UCHAR)bulkUrb->TransferBufferLength;
    }

    DBGPRINT(2, ("Sense Data: 0x%02X 0x%02X 0x%02X\n",
                 fdoDeviceExtension->Cbi.SenseData.SenseKey,
                 fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode,
                 fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCodeQualifier));

    if (fdoDeviceExtension->InterruptInPipe)
    {
        // Command completion interrupt supported.  Do not complete the
        // request yet.  Start the Request Sense command completion interrupt
        // transfer.
        //
        ntStatus = USBSTOR_IssueRequestSenseInterruptRequest(
                       fdoDeviceObject,
                       Irp,
                       (ULONG_PTR)AutoFlag);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }
    else
    {
        // Command completion interrupt not supported.  Complete the request
        // now.
        //
        ntStatus = USBSTOR_ProcessRequestSenseCompletion(
                       fdoDeviceObject,
                       Irp,
                       (ULONG_PTR)AutoFlag);
    }

    DBGPRINT(3, ("exit:  USBSTOR_SenseDataCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 6, Request Sense Command completion Interrupt transfer
//

//******************************************************************************
//
// USBSTOR_IssueRequestSenseInterruptRequest()
//
// This routine is called USBSTOR_SenseDataCompletionRoutine()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the command completion interrupt data In
// the Interrupt endpoint.
//
// Sets USBSTOR_RequestSenseInterruptCompletionRoutine() as the completion
// routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSenseInterruptRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferBufferLength;
    PVOID                   transferBuffer;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSenseInterruptRequest\n"));

    LOGENTRY('IRSI', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    pipeHandle = fdoDeviceExtension->InterruptInPipe->PipeHandle;

    transferBufferLength = sizeof(fdoDeviceExtension->Cbi.InterruptData);

    transferBuffer = &fdoDeviceExtension->Cbi.InterruptData;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                              // PipeHandle
                   0,                                       // TransferFlags
                   transferBufferLength,                    // TransferBufferLength
                   transferBuffer,                          // TransferBuffer
                   NULL,                                    // TransferBufferMDL
                   USBSTOR_RequestSenseInterruptCompletionRoutine,  // CompletionRoutine
                   (PVOID)AutoFlag);                        // Context

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSenseInterruptRequest %08X\n",
                 ntStatus));

    LOGENTRY('irsi', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_RequestSenseInterruptCompletionRoutine()
//
// Completion routine used by USBSTOR_IssueRequestSenseInterruptRequest()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Interrupt USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Interrupt USB transfer succeeded but the completion data is
// non-zero and AutoSense is not disabled, do not complete the request yet and
// start a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if the Interrupt USB transfer succeeded, ignore the interrupt data
// and complete the request by calling USBSTOR_ProcessRequestSenseCompletion().
//
//******************************************************************************

NTSTATUS
USBSTOR_RequestSenseInterruptCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            AutoFlag
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *intrUrb;

    DBGPRINT(3, ("enter: USBSTOR_RequestSenseInterruptCompletionRoutine\n"));

    LOGENTRY('RSIC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Interrupt Transfer URB in our Device Extension
    //
    intrUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('rsi1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_RequestSenseInterruptCompletionRoutine: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The command completion Interrupt USB transfer failed.  Complete
        // this request now and then reset the device.  The next request will
        // be started when the reset completes.
        //
        LOGENTRY('rsi2', Irp->IoStatus.Status, intrUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Interrupt transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, intrUrb->Hdr.Status));

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_RequestSenseInterruptCompletionRoutine: xfer error completion\n"));

        return ntStatus;
    }

    // Request Sense Command Completion Interrupt tranfer completed successfully.

    LOGENTRY('rsi3', Irp->IoStatus.Status, intrUrb->Hdr.Status,
             intrUrb->TransferBufferLength);

    ntStatus = USBSTOR_ProcessRequestSenseCompletion(
                   fdoDeviceObject,
                   Irp,
                   (ULONG_PTR)AutoFlag);

    DBGPRINT(3, ("exit:  USBSTOR_RequestSenseInterruptCompletionRoutine %08X\n", ntStatus));

    return ntStatus;
}


//******************************************************************************
//
// USBSTOR_ProcessRequestSenseCompletion()
//
// This routine handles completion for USBSTOR_SenseDataCompletionRoutine()
// and USBSTOR_RequestSenseInterruptCompletionRoutine().  It basically just
// handles a couple of special cases.
//
// This routine may run at DPC level.
//
//******************************************************************************

NTSTATUS
USBSTOR_ProcessRequestSenseCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG_PTR        AutoFlag
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('PRSC', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (AutoFlag == NON_AUTO_SENSE)
    {
        LOGENTRY('prs1', DeviceObject, Irp, srb);

        if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
             SCSI_SENSE_UNIT_ATTENTION)
            &&
            (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
             SCSI_ADSENSE_BUS_RESET))
        {
            fdoDeviceExtension->LastSenseWasReset = TRUE;
        }

        // Just cleared the persistent error from the previous request,
        // now issue the real request.
        //
        ntStatus = USBSTOR_IssueClientCdb(DeviceObject,
                                          Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    // SrbStatus and DataTransferLength were already set in
    // USBSTOR_ClientCdbCompletion(), USBSTOR_ClientBulkCompletionRoutine(), or in
    // or USBSTOR_InterruptDataCompletionRoutine() before we got here.
    //
    srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

    USBSTOR_TranslateCDBComplete(DeviceObject, Irp, srb);

    Irp->IoStatus.Information = srb->DataTransferLength;

    ntStatus = Irp->IoStatus.Status;

    // Disgusting hack for Y-E Data USB Floppy.  On Medium Changed it doesn't
    // automatically update the Write Protect status that you get back in
    // the Mode Parameter Header on a Mode Sense.  Supposedly a Start Unit
    // request after a Medium Changed should cause it to update the Write
    // Protect status, but that does not seem to be the case.  A good old
    // bus reset gets its attention though and updates the Write Protect
    // status.  Don't do this if the last status was a Bus Reset or that
    // will cause a loop.
    //
    if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
         SCSI_SENSE_UNIT_ATTENTION)
        &&
        (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
         SCSI_ADSENSE_MEDIUM_CHANGED)
        &&
        !fdoDeviceExtension->LastSenseWasReset
        &&
        TEST_FLAG(fdoDeviceExtension->DeviceHackFlags, DHF_MEDIUM_CHANGE_RESET))
    {
        LOGENTRY('prs2', DeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(DeviceObject);
    }
    else
    {
        if ((fdoDeviceExtension->Cbi.SenseData.SenseKey ==
             SCSI_SENSE_UNIT_ATTENTION)
            &&
            (fdoDeviceExtension->Cbi.SenseData.AdditionalSenseCode ==
             SCSI_ADSENSE_BUS_RESET))
        {
            LOGENTRY('prs3', DeviceObject, Irp, srb);

            fdoDeviceExtension->LastSenseWasReset = TRUE;
        }
        else
        {
            LOGENTRY('prs4', DeviceObject, Irp, srb);

            fdoDeviceExtension->LastSenseWasReset = FALSE;
        }

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }

    return ntStatus;
}


//******************************************************************************
//
// USBSTOR_QueueResetPipe()
//
// Called by USBSTOR_BulkCompletionRoutine() to clear the STALL on the bulk
// endpoints.
//
//******************************************************************************

VOID
USBSTOR_QueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

    LOGENTRY('QRSP', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_ResetPipeWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_ResetPipeWorkItem()
//
// WorkItem routine used by USBSTOR_ResetPipe()
//
// This routine runs at PASSIVE level.
//
// Basic idea:
//
// Issue a Reset Pipe request to clear the Bulk endpoint STALL and reset
// the data toggle to Data0.
//
// If AutoSense is not disabled, do not complete the request yet and start
// a Request Sense by calling USBSTOR_IssueRequestSenseCdb(AUTO).
//
// Else if AutoSense is disabled, complete the request.
//
//******************************************************************************

VOID
USBSTOR_ResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 persistentError;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    LOGENTRY('RSPW', DeviceObject, 0, 0);

    DBGPRINT(2, ("enter: USBSTOR_ResetPipeWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Reset the Bulk Endpoint.  This clears the endpoint halt on the
    // host side, resets the host side data toggle to Data0, and issues
    // the Clear_Feature Endpoint_Stall request to the device.
    //
    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 fdoDeviceExtension->BulkInPipe->PipeHandle);

    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 fdoDeviceExtension->BulkOutPipe->PipeHandle);

    persistentError = FALSE;

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        if (TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_PERSISTENT_ERROR))
        {
            persistentError = TRUE;
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    if (persistentError)
    {
        // We are not doing an AutoSense, start the next packet.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(DeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }
    else
    {
        // We are doing an AutoSense, send the REQUEST_SENSE Cdb to the device.
        //
        ntStatus = USBSTOR_IssueRequestSenseCdb(
                       (PDEVICE_OBJECT)DeviceObject,
                       ((PDEVICE_OBJECT)DeviceObject)->CurrentIrp,
                       AUTO_SENSE);
    }

    DBGPRINT(2, ("exit:  USBSTOR_ResetPipeWorkItem\n"));

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);
}

//
// Bulk-Only Routines
//

//
// Phase 1, CBW Transfer
//

//******************************************************************************
//
// USBSTOR_CbwTransfer()
//
// This routine is called by USBSTOR_StartIo().
//
// It runs at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to write the Srb->Cdb wrapped inside a CBW out
// the Bulk OUT endpoint.
//
// Sets USBSTOR_CbwCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_CbwTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PCBW                    cbw;
    USBD_PIPE_HANDLE        pipeHandle;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_CbwTransfer\n"));

    LOGENTRY('ICBW', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    fdoDeviceExtension->BulkOnly.StallCount = 0;

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    // Get the PDO extension from the PDO which was saved in the current
    // stack location when the Irp was originally sent to the PDO.
    //
    pdoDeviceExtension = irpStack->DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    LOGENTRY('icbl', DeviceObject, irpStack->DeviceObject,
             pdoDeviceExtension->LUN);

    // Get the client Srb
    //
    srb = irpStack->Parameters.Scsi.Srb;

    // Initialize the Command Block Wrapper
    //
    cbw = &fdoDeviceExtension->BulkOnly.CbwCsw.Cbw;

    cbw->dCBWSignature = CBW_SIGNATURE;

    cbw->dCBWTag = PtrToUlong(Irp);

    cbw->dCBWDataTransferLength = srb->DataTransferLength;

    cbw->bCBWFlags = (srb->SrbFlags & SRB_FLAGS_DATA_IN) ?
                     CBW_FLAGS_DATA_IN : CBW_FLAGS_DATA_OUT;

    cbw->bCBWLUN = pdoDeviceExtension->LUN;

    cbw->bCDBLength = srb->CdbLength;

    RtlCopyMemory(cbw->CBWCDB, srb->Cdb, 16);

    pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,              // PipeHandle
                   0,                       // TransferFlags
                   sizeof(CBW),             // TransferBufferLength
                   cbw,                     // TransferBuffer
                   NULL,                    // TransferBufferMDL
                   USBSTOR_CbwCompletion,   // CompletionRoutine
                   NULL);                   // Context

    DBGPRINT(3, ("exit:  USBSTOR_CbwTransfer %08X\n", ntStatus));

    LOGENTRY('icbw', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CbwCompletion()
//
// Completion routine used by USBSTOR_CbwTransfer()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the CBW USB transfer failed due to any reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the CBW USB transfer succeeded and the Srb has a transfer buffer,
// do not complete the request yet and start the bulk data transfer by calling
// USBSTOR_DataTransfer().
//
// Else if the CBW USB transfer succeeded and the Srb has no transfer buffer,
// do not complete the request yet and start the CSW bulk transfer by calling
// USBSTOR_CswTransfer().
//
//******************************************************************************

NTSTATUS
USBSTOR_CbwCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_CbwCompletion\n"));

    LOGENTRY('CBWC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('cbw1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_CbwCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The CBW Bulk Transfer was not successful.
        //
        LOGENTRY('cbw2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CBW transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = srb;

        // Complete this request now and then reset the device.  The next
        // request will be started when the reset completes.
        //
        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);

        DBGPRINT(1, ("USBSTOR_CbwCompletion: xfer error completion\n"));

        return ntStatus;
    }

    // The CBW Bulk Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or CSW Bulk Transfer, and do not complete the
    // request yet.
    //
    if (Irp->MdlAddress != NULL ||
        srb != fdoDeviceExtension->OriginalSrb)
    {
        // The Srb has a transfer buffer, start the Data Bulk Transfer.
        //
        LOGENTRY('cbw3', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength != 0);

        ntStatus = USBSTOR_DataTransfer(fdoDeviceObject,
                                        Irp);

        if (NT_SUCCESS(ntStatus))
        {
            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_ERROR;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);
        }
    }
    else
    {
        // The Srb has no transfer buffer.  Start the CSW Bulk Transfer.
        //
        LOGENTRY('cbw4', fdoDeviceObject, Irp, srb);

        ASSERT(srb->DataTransferLength == 0);

        srb->SrbStatus = SRB_STATUS_SUCCESS;

        ntStatus = USBSTOR_CswTransfer(fdoDeviceObject,
                                       Irp);

        ntStatus = STATUS_MORE_PROCESSING_REQUIRED;
    }

    DBGPRINT(3, ("exit:  USBSTOR_CbwCompletion %08X\n", ntStatus));

    return ntStatus;
}

//
// Phase 2, Data Transfer
//

//******************************************************************************
//
// USBSTOR_DataTransfer()
//
// This routine is called by USBSTOR_ClientCdbCompletion().
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read or write the Srb->DataBuffer data In or Out
// the Bulk endpoint.
//
// Sets USBSTOR_DataCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_DataTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PMDL                    mdl;
    PVOID                   mdlVa;
    PVOID                   transferBuffer;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_DataTransfer\n"));

    LOGENTRY('IBKD', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Bulk IN or Bulk OUT?
    //
    if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_IN)
    {
        pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;
        transferFlags = USBD_SHORT_TRANSFER_OK;
    }
    else if ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) == SRB_FLAGS_DATA_OUT)
    {
        pipeHandle = fdoDeviceExtension->BulkOutPipe->PipeHandle;
        transferFlags = 0;
    }
    else
    {
        // Something is wrong if we end up here.
        //
        ASSERT((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) &&
               ((srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) !=
                SRB_FLAGS_UNSPECIFIED_DIRECTION));

        return STATUS_INVALID_PARAMETER;
    }

    mdl = NULL;
    transferBuffer = NULL;

    if (srb == fdoDeviceExtension->OriginalSrb)
    {
        // Check to see if this request is part of a split request.
        //
        mdlVa = MmGetMdlVirtualAddress(Irp->MdlAddress);

        if (mdlVa == (PVOID)srb->DataBuffer)
        {
            // Not part of a split request, use original MDL
            //
            mdl = Irp->MdlAddress;
        }
        else
        {
            // Part of a split request, allocate new partial MDL
            //
            mdl = IoAllocateMdl(srb->DataBuffer,
                                srb->DataTransferLength,
                                FALSE,
                                FALSE,
                                NULL);
            if (mdl == NULL)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                IoBuildPartialMdl(Irp->MdlAddress,
                                  mdl,
                                  srb->DataBuffer,
                                  srb->DataTransferLength);
            }
        }
    }
    else
    {
        transferBuffer = srb->DataBuffer;

        // If (srb != fdoDeviceExtension->OriginalSrb) then
        // srb->DataBuffer should equal OriginalSrb->SenseInfoBuffer,
        // which should not be NULL if we end up here.
        //
        ASSERT(transferBuffer);

        if (!transferBuffer) {
            // just in case
            ntStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (mdl != NULL || transferBuffer != NULL)
    {
        ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                       DeviceObject,
                       Irp,
                       pipeHandle,              // PipeHandle
                       transferFlags,           // TransferFlags
                       srb->DataTransferLength, // TransferBufferLength
                       transferBuffer,          // TransferBuffer
                       mdl,                     // TransferBufferMDL
                       USBSTOR_DataCompletion,  // CompletionRoutine
                       NULL);                   // Context

        // Just return STATUS_SUCCESS at this point.  If there is an error,
        // USBSTOR_DataCompletion() will handle it, not the caller of
        // USBSTOR_DataTransfer().
        //
        ntStatus = STATUS_SUCCESS;
    }

    DBGPRINT(3, ("exit:  USBSTOR_DataTransfer %08X\n", ntStatus));

    LOGENTRY('ibkd', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_DataCompletion()
//
// Completion routine used by USBSTOR_DataTransfer
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
// Else if the Bulk USB transfer failed due to a STALL do not complete the
// request yet and start a pipe reset by calling USBSTOR_BulkQueueResetPipe().
//
// Else if the Bulk USB transfer failed due to some other reason, complete the
// request and start a reset by queuing USBSTOR_ResetDeviceWorkItem().
//
// Else if the Bulk USB transfer succeeded, start CSW transfer by calling
// USBSTOR_CswTransfer().
//
//******************************************************************************

NTSTATUS
USBSTOR_DataCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_DataCompletion\n"));

    LOGENTRY('BKDC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    if (srb == fdoDeviceExtension->OriginalSrb &&
        bulkUrb->TransferBufferMDL != Irp->MdlAddress)
    {
        IoFreeMdl(bulkUrb->TransferBufferMDL);
    }

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('bkd1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_DataCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('bkd2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("Data transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID))
        {
            // The device STALLed the Data Bulk Transfer
            //
            fdoDeviceExtension->BulkOnly.StallCount++;

            // A STALL during the Data Bulk Transfer does not necessarily
            // indicate an error.  Accept the data that was actually
            // transferred.  If a STALL was seen it must have been seen
            // before the requested amount of data was transferred.
            //
            ASSERT(bulkUrb->TransferBufferLength < srb->DataTransferLength);
            srb->DataTransferLength = bulkUrb->TransferBufferLength;
            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;

            LOGENTRY('bkd3', fdoDeviceObject, Irp, srb);

            // Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a CSW transfer will be started.
            //
            USBSTOR_BulkQueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('bkd4', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_DataCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    // Check for overrun
    //
    if (bulkUrb->TransferBufferLength < srb->DataTransferLength)
    {
        srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
    }
    else
    {
        srb->SrbStatus = SRB_STATUS_SUCCESS;
    }

    // Update the the Srb data transfer length based on the actual bulk
    // transfer length.
    //
    srb->DataTransferLength = bulkUrb->TransferBufferLength;

    // Client data Bulk Transfer successful completion.  Start the CSW transfer.
    //
    LOGENTRY('bkd5', fdoDeviceObject, Irp, bulkUrb->TransferBufferLength);

    ntStatus = USBSTOR_CswTransfer(fdoDeviceObject,
                                   Irp);

    ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

    DBGPRINT(3, ("exit:  USBSTOR_DataCompletion %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CswTransfer()
//
// This routine is called by USBSTOR_CbwCompletion() and
// USBSTOR_DataCompletion()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// Starts a USB transfer to read the CSW in the Bulk IN endpoint.
//
// Sets USBSTOR_CswCompletion() as the completion routine.
//
//******************************************************************************

NTSTATUS
USBSTOR_CswTransfer (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PCSW                    csw;
    USBD_PIPE_HANDLE        pipeHandle;
    ULONG                   transferFlags;
    ULONG                   transferBufferLength;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_CswTransfer\n"));

    LOGENTRY('ICSW', DeviceObject, Irp, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    csw = &fdoDeviceExtension->BulkOnly.CbwCsw.Csw;

    pipeHandle = fdoDeviceExtension->BulkInPipe->PipeHandle;

    // Workaround for USB 2.0 controller Data Toggle / Babble bug
    //
    if (fdoDeviceExtension->BulkInPipe->MaximumPacketSize ==
        sizeof(fdoDeviceExtension->BulkOnly.CbwCsw.MaxPacketSize))

    {
        transferFlags = USBD_SHORT_TRANSFER_OK;

        transferBufferLength =
            sizeof(fdoDeviceExtension->BulkOnly.CbwCsw.MaxPacketSize);
    }
    else
    {
        transferFlags = 0;

        transferBufferLength = sizeof(CSW);
    }

    ntStatus = USBSTOR_IssueBulkOrInterruptRequest(
                   DeviceObject,
                   Irp,
                   pipeHandle,                  // PipeHandle
                   transferFlags,               // TransferFlags
                   transferBufferLength,        // TransferBufferLength
                   csw,                         // TransferBuffer
                   NULL,                        // TransferBufferMDL
                   USBSTOR_CswCompletion,       // CompletionRoutine
                   NULL);                       // Context

    DBGPRINT(3, ("exit:  USBSTOR_CswTransfer %08X\n", ntStatus));

    LOGENTRY('icsw', DeviceObject, Irp, ntStatus);

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_CswCompletion()
//
// Completion routine used by USBSTOR_CswTransfer()
//
// This routine may run at DPC level.
//
// Basic idea:
//
// If a timeout reset occured, complete the request.
//
//******************************************************************************

NTSTATUS
USBSTOR_CswCompletion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    PCSW                    csw;
    KIRQL                   irql;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    DBGPRINT(3, ("enter: USBSTOR_CswCompletion\n"));

    LOGENTRY('CSWC', DeviceObject, Irp, Irp->IoStatus.Status);

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Get our Irp parameters
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    csw = &fdoDeviceExtension->BulkOnly.CbwCsw.Csw;

    // If a timeout reset occured, complete the request.
    //
    if (USBSTOR_CheckRequestTimeOut(fdoDeviceObject,
                                    Irp,
                                    srb,
                                    &ntStatus))
    {
        LOGENTRY('csw1', fdoDeviceObject, Irp, srb);
        DBGPRINT(1, ("USBSTOR_CswCompletion: timeout completion\n"));
        return ntStatus;
    }

    if (!NT_SUCCESS(Irp->IoStatus.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        LOGENTRY('csw2', Irp->IoStatus.Status, bulkUrb->Hdr.Status, 0);

        DBGPRINT(1, ("CSW transfer failed %08X %08X\n",
                     Irp->IoStatus.Status, bulkUrb->Hdr.Status));

        if (USBD_STATUS(bulkUrb->Hdr.Status) ==
            USBD_STATUS(USBD_STATUS_STALL_PID) &&
            fdoDeviceExtension->BulkOnly.StallCount < 2)
        {
            // The device STALLed the CSW Bulk Transfer
            //
            fdoDeviceExtension->BulkOnly.StallCount++;

            LOGENTRY('csw3', fdoDeviceObject, Irp, srb);

            // Queue a bulk pipe reset.  After the bulk pipe reset
            // completes, a CSW transfer will be started.
            //
            USBSTOR_BulkQueueResetPipe(fdoDeviceObject);

            return STATUS_MORE_PROCESSING_REQUIRED;
        }
        else
        {
            LOGENTRY('csw4', fdoDeviceObject, Irp, srb);

            // Else some other strange error has occured.  Maybe the device is
            // unplugged, or maybe the device port was disabled, or maybe the
            // request was cancelled.
            //
            // Complete this request now and then reset the device.  The next
            // request will be started when the reset completes.
            //
            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            ntStatus = STATUS_IO_DEVICE_ERROR;
            Irp->IoStatus.Status = ntStatus;
            Irp->IoStatus.Information = 0;
            srb->SrbStatus = SRB_STATUS_BUS_RESET;

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            USBSTOR_QueueResetDevice(fdoDeviceObject);

            DBGPRINT(1, ("USBSTOR_DataCompletion: xfer error completion\n"));

            return ntStatus;
        }
    }

    if (csw->bCSWStatus == CSW_STATUS_GOOD)
    {
        // Complete this request now.  Also start the next request now.
        //

        // SrbStatus should have been set in USBSTOR_DataCompletion()
        //
        ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

        if (srb != fdoDeviceExtension->OriginalSrb)
        {
            // Update the original SRB with the length of the sense data that
            // was actually returned.
            //
            fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength =
                (UCHAR)srb->DataTransferLength;

            srb = fdoDeviceExtension->OriginalSrb;
            irpStack->Parameters.Scsi.Srb = srb;

            srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
        }

        ntStatus = STATUS_SUCCESS;
        Irp->IoStatus.Status = ntStatus;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        Irp->IoStatus.Information = srb->DataTransferLength;

        LOGENTRY('csw5', fdoDeviceObject, Irp, srb);

        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoStartNextPacket(fdoDeviceObject, TRUE);
        }
        KeLowerIrql(irql);
    }
    else if (csw->bCSWStatus == CSW_STATUS_FAILED &&
             srb == fdoDeviceExtension->OriginalSrb)
    {
        LOGENTRY('csw6', fdoDeviceObject, Irp, srb);

        srb->SrbStatus = SRB_STATUS_ERROR;
        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
        srb->DataTransferLength = 0; // XXXXX Leave as set by bulk completion???

        if (!(srb->SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) &&
            (srb->SenseInfoBufferLength != 0) &&
            (srb->SenseInfoBuffer != NULL))
        {
            // Start the Request Sense thing
            //
            ntStatus = USBSTOR_IssueRequestSense(fdoDeviceObject,
                                                 Irp);

            ntStatus = STATUS_MORE_PROCESSING_REQUIRED;

        }
        else
        {
            ntStatus = STATUS_IO_DEVICE_ERROR; // XXXXX
            Irp->IoStatus.Status = ntStatus; // XXXXX
            Irp->IoStatus.Information = 0; // XXXXX

            USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

            KeRaiseIrql(DISPATCH_LEVEL, &irql);
            {
                IoStartNextPacket(fdoDeviceObject, TRUE);
            }
            KeLowerIrql(irql);
        }
    }
    else
    {
        LOGENTRY('csw7', fdoDeviceObject, Irp, srb);

        // PHASE ERROR or Unknown Status
        //
        // Complete this request now and then reset the device.  The next
        // request will be started when the reset completes.
        //
        srb = fdoDeviceExtension->OriginalSrb;
        irpStack->Parameters.Scsi.Srb = srb;

        ntStatus = STATUS_IO_DEVICE_ERROR;
        Irp->IoStatus.Status = ntStatus;
        Irp->IoStatus.Information = 0;
        srb->SrbStatus = SRB_STATUS_BUS_RESET;

        USBSTOR_TranslateCDBComplete(fdoDeviceObject, Irp, srb);

        USBSTOR_QueueResetDevice(fdoDeviceObject);
    }

    DBGPRINT(3, ("exit:  USBSTOR_CswCompletion %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueRequestSense()
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueRequestSense (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIO_STACK_LOCATION      irpStack;
    PSCSI_REQUEST_BLOCK     srb;
    NTSTATUS                ntStatus;

    DBGPRINT(3, ("enter: USBSTOR_IssueRequestSense\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get the current Srb
    //
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = irpStack->Parameters.Scsi.Srb;

    // Get a pointer to the internal Srb.
    //
    srb = &fdoDeviceExtension->BulkOnly.InternalSrb;

    irpStack->Parameters.Scsi.Srb = srb;


    // Initialize SRB & CDB to all ZERO
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    // Initialize SRB
    //
    srb->Length     = sizeof(SCSI_REQUEST_BLOCK);
    srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
    srb->CdbLength  = 12;
    srb->SrbFlags   = SRB_FLAGS_DATA_IN |
                      SRB_FLAGS_DISABLE_AUTOSENSE;

    srb->DataTransferLength = fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength;
    srb->DataBuffer         = fdoDeviceExtension->OriginalSrb->SenseInfoBuffer;

    // Initialize CDB
    //
    srb->Cdb[0] = SCSIOP_REQUEST_SENSE;
    srb->Cdb[4] = fdoDeviceExtension->OriginalSrb->SenseInfoBufferLength;

    ntStatus = USBSTOR_CbwTransfer(DeviceObject,
                                   Irp);

    return ntStatus;

    DBGPRINT(3, ("exit:  USBSTOR_IssueRequestSense %08X\n", ntStatus));
}

//******************************************************************************
//
// USBSTOR_BulkQueueResetPipe()
//
// Called by USBSTOR_DataCompletion() and USBSTOR_CswCompletion() to clear the
// STALL on the bulk endpoints.
//
//******************************************************************************

VOID
USBSTOR_BulkQueueResetPipe (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;

    LOGENTRY('QRSP', DeviceObject, 0, 0);

    DBGFBRK(DBGF_BRK_RESETPIPE);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_BulkResetPipeWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_BulkResetPipeWorkItem()
//
// WorkItem routine used by USBSTOR_BulkQueueResetPipe()
//
// This routine runs at PASSIVE level.
//
// Basic idea:
//
// Issue a Reset Pipe request to clear the Bulk endpoint STALL and reset
// the data toggle to Data0.
//
// Then start the CSW transfer.
//
//******************************************************************************

VOID
USBSTOR_BulkResetPipeWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    NTSTATUS                ntStatus;

    struct _URB_BULK_OR_INTERRUPT_TRANSFER *bulkUrb;

    LOGENTRY('RSPW', DeviceObject, 0, 0);

    DBGPRINT(2, ("enter: USBSTOR_BulkResetPipeWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Get a pointer to the Bulk Transfer URB in our Device Extension.
    // We'll pull the appropriate Bulk Endpoint pipe handle out of the URB.
    //
    // NOTE: This assumes that the URB in our Device Extension has
    // not been touched since USBSTOR_DataCompletion() or
    // USBSTOR_CswCompletion() called USBSTOR_BulkQueueResetPipe().
    //
    bulkUrb = &fdoDeviceExtension->Urb.BulkIntrUrb;

    // Reset the Bulk Endpoint.  This clears the endpoint halt on the
    // host side, resets the host side data toggle to Data0, and issues
    // the Clear_Feature Endpoint_Stall request to the device.
    //
    ntStatus = USBSTOR_ResetPipe((PDEVICE_OBJECT)DeviceObject,
                                 bulkUrb->PipeHandle);

    ntStatus = USBSTOR_CswTransfer(
                   (PDEVICE_OBJECT)DeviceObject,
                   ((PDEVICE_OBJECT)DeviceObject)->CurrentIrp);


    DBGPRINT(2, ("exit:  USBSTOR_BulkResetPipeWorkItem\n"));

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);
}

//
// CBI / Bulk-Only Common Routines
//

//******************************************************************************
//
// USBSTOR_TimerTick()
//
// Called once per second at DISPATCH_LEVEL after the device has been started.
// Checks to see if there is an active Srb which has timed out, and if so,
// kicks off the reset recovery process.
//
//******************************************************************************

VOID
USBSTOR_TimerTick (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          NotUsed
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    BOOLEAN                 reset;

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    reset = FALSE;

    KeAcquireSpinLockAtDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);
    {
        if (!TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS) &&
             TEST_FLAG(fdoDeviceExtension->DeviceFlags, DF_SRB_IN_PROGRESS))
        {
            // There is no reset in progress and there is an Srb in progress.
            // Decrement the timeout of the Srb.  If it reaches zero, then we
            // will reset the device.
            //
            if (--fdoDeviceExtension->SrbTimeout == 0)
            {
                SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);

                reset = TRUE;
            }
        }
    }
    KeReleaseSpinLockFromDpcLevel(&fdoDeviceExtension->ExtensionDataSpinLock);

    if (reset)
    {
        LOGENTRY('TIMR', DeviceObject, 0, 0);

        DBGPRINT(2, ("queuing USBSTOR_ResetDeviceWorkItem\n"));

        //  Queue WorkItem to reset the device
        //
        INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

        IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                        USBSTOR_ResetDeviceWorkItem,
                        CriticalWorkQueue,
                        NULL);
    }
}

//******************************************************************************
//
// USBSTOR_QueueResetDevice()
//
//******************************************************************************

VOID
USBSTOR_QueueResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KIRQL                   irql;

    LOGENTRY('QRSD', DeviceObject, 0, 0);

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    //  Queue WorkItem to reset the device
    //
    INCREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    IoQueueWorkItem(fdoDeviceExtension->IoWorkItem,
                    USBSTOR_ResetDeviceWorkItem,
                    CriticalWorkQueue,
                    NULL);
}

//******************************************************************************
//
// USBSTOR_ResetDeviceWorkItem()
//
// Work item which runs at PASSIVE_LEVEL in the context of a system thread.
// This routine first checks to see if the device is still attached, and if
// it is, the device is reset.
//
//******************************************************************************

VOID
USBSTOR_ResetDeviceWorkItem (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PVOID            Context
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    KIRQL                   irql;
    ULONG                   retryCount;
    NTSTATUS                ntStatus;

    LOGENTRY('RSDW', DeviceObject, 0, 0);

    DBGFBRK(DBGF_BRK_RESET);

    DBGPRINT(2, ("enter: USBSTOR_ResetDeviceWorkItem\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // If the we timed out a request and it is still pending, cancel
    // it and then wait for the cancel to finish, and then complete
    // the request.
    //
    if (fdoDeviceExtension->PendingIrp)
    {
        LOGENTRY('rsd1', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        IoCancelIrp(fdoDeviceExtension->PendingIrp);

        LOGENTRY('rsd2', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        KeWaitForSingleObject(&fdoDeviceExtension->CancelEvent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        LOGENTRY('rsd3', DeviceObject, fdoDeviceExtension->PendingIrp, 0);

        // Some storage drivers (e.g. CDROM.SYS) assume that requests complete
        // at DISPATCH_LEVEL.
        //
        KeRaiseIrql(DISPATCH_LEVEL, &irql);
        {
            IoCompleteRequest(fdoDeviceExtension->PendingIrp, IO_NO_INCREMENT);
        }
        KeLowerIrql(irql);

        fdoDeviceExtension->PendingIrp = NULL;
    }

    // Try the reset up to 3 times
    //
    for (retryCount = 0; retryCount < 3; retryCount++)
    {
        //
        // First figure out if the device is still connected.
        //
        ntStatus = USBSTOR_IsDeviceConnected(DeviceObject);

        if (!NT_SUCCESS(ntStatus))
        {
            // Give up if the device is no longer connected.
            break;
        }

        //
        // The device is still connected, now reset the device.
        //
        DBGPRINT(1, ("Reseting Device %d\n", retryCount));

        ntStatus = USBSTOR_ResetDevice(DeviceObject);

        if (NT_SUCCESS(ntStatus))
        {
            // Reset was successful!
            break;
        }
    }

    KeAcquireSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, &irql);
    {
        CLEAR_FLAG(fdoDeviceExtension->DeviceFlags, DF_RESET_IN_PROGRESS);

        // If the reset failed, then abandon all hope and mark the device as
        // disconnected.
        //
        if (!NT_SUCCESS(ntStatus))
        {
            SET_FLAG(fdoDeviceExtension->DeviceFlags, DF_DEVICE_DISCONNECTED);
        }
    }
    KeReleaseSpinLock(&fdoDeviceExtension->ExtensionDataSpinLock, irql);

    // A request has failed in a bad way or timed out if we are reseting the
    // device.  If the protocol was not specified then the default protocol
    // was DeviceProtocolCB.  Let's try DeviceProtocolBulkOnly now and see if
    // we have any better luck.  (Note that if a DeviceProtocolCB device fails
    // the first request in a bad way then will we retry the first request as
    // a DeviceProtocolBulkOnly device, which will then also fail and we will
    // not recover from that situation).
    //
    if (fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified)
    {
        DBGPRINT(1, ("Setting Unspecified device to BulkOnly\n"));

        fdoDeviceExtension->DriverFlags = DeviceProtocolBulkOnly;
    }

    KeRaiseIrql(DISPATCH_LEVEL, &irql);
    {
        IoStartNextPacket(DeviceObject, TRUE);
    }
    KeLowerIrql(irql);

    DECREMENT_PENDING_IO_COUNT(fdoDeviceExtension);

    DBGPRINT(2, ("exit:  USBSTOR_ResetDeviceWorkItem %08X\n", ntStatus));
}

//******************************************************************************
//
// USBSTOR_IsDeviceConnected()
//
// This routine checks to see if the device is still attached.
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBSTOR_IsDeviceConnected (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    DBGPRINT(1, ("enter: USBSTOR_IsDeviceConnected\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_GET_PORT_STATUS;

    nextStack->Parameters.Others.Argument1 = &portStatus;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // Pass the Irp down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    if (NT_SUCCESS(ntStatus) && !(portStatus & USBD_PORT_CONNECTED))
    {
        ntStatus = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    DBGPRINT(1, ("exit:  USBSTOR_IsDeviceConnected %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_ResetDevice()
//
// This routine resets the device (actually it resets the port to which the
// device is attached).
//
// This routine runs at PASSIVE level.
//
//******************************************************************************

NTSTATUS
USBSTOR_ResetDevice (
    IN PDEVICE_OBJECT   DeviceObject
    )
{
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PIRP                    irp;
    KEVENT                  localevent;
    PIO_STACK_LOCATION      nextStack;
    ULONG                   portStatus;
    NTSTATUS                ntStatus;

    DBGPRINT(1, ("enter: USBSTOR_ResetDevice\n"));

    fdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    // Allocate the Irp
    //
    irp = IoAllocateIrp((CCHAR)(fdoDeviceExtension->StackDeviceObject->StackSize),
                        FALSE);

    if (irp == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // Initialize the event we'll wait on.
    //
    KeInitializeEvent(&localevent,
                      SynchronizationEvent,
                      FALSE);

    // Set the Irp parameters
    //
    nextStack = IoGetNextIrpStackLocation(irp);

    nextStack->MajorFunction = IRP_MJ_INTERNAL_DEVICE_CONTROL;

    nextStack->Parameters.DeviceIoControl.IoControlCode =
        IOCTL_INTERNAL_USB_RESET_PORT;

    // Set the completion routine, which will signal the event
    //
    IoSetCompletionRoutineEx(DeviceObject,
                             irp,
                             USBSTOR_SyncCompletionRoutine,
                             &localevent,
                             TRUE,      // InvokeOnSuccess
                             TRUE,      // InvokeOnError
                             TRUE);     // InvokeOnCancel

    // Pass the Irp & Urb down the stack
    //
    ntStatus = IoCallDriver(fdoDeviceExtension->StackDeviceObject,
                            irp);

    // If the request is pending, block until it completes
    //
    if (ntStatus == STATUS_PENDING)
    {
        KeWaitForSingleObject(&localevent,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        ntStatus = irp->IoStatus.Status;
    }

    IoFreeIrp(irp);

    DBGPRINT(1, ("exit:  USBSTOR_ResetDevice %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IssueInternalCdb()
//
//******************************************************************************

NTSTATUS
USBSTOR_IssueInternalCdb (
    PDEVICE_OBJECT  DeviceObject,
    PVOID           DataBuffer,
    PULONG          DataTransferLength,
    PCDB            Cdb,
    UCHAR           CdbLength,
    ULONG           TimeOutValue
    )
{
    PIRP                    irp;
    PIO_STACK_LOCATION      nextStack;
    PSCSI_REQUEST_BLOCK     srb;
    PSENSE_DATA             senseInfoBuffer;
    PMDL                    mdl;
    ULONG                   retryCount;
    KEVENT                  localevent;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_IssueInternalCdb\n"));

    // Initialize these so we can bail early if an allocation fails
    //
    ntStatus        = STATUS_INSUFFICIENT_RESOURCES;
    irp             = NULL;
    srb             = NULL;
    senseInfoBuffer = NULL;
    mdl             = NULL;

    // Allocate the Srb
    //
    srb = ExAllocatePoolWithTag(NonPagedPool, sizeof(SCSI_REQUEST_BLOCK),
                                POOL_TAG);

    if (srb == NULL)
    {
        goto USBSTOR_GetInquiryData_Exit;
    }

    // Allocate the sense buffer
    //
    senseInfoBuffer = ExAllocatePoolWithTag(NonPagedPool, SENSE_BUFFER_SIZE,
                                            POOL_TAG);

    if (senseInfoBuffer == NULL)
    {
        goto USBSTOR_GetInquiryData_Exit;
    }


    // Try the request up to 3 times
    //
    for (retryCount = 0; retryCount < 3; retryCount++)
    {
        // Allocate an Irp including a stack location for a completion routine
        //
        irp = IoAllocateIrp((CCHAR)(DeviceObject->StackSize), FALSE);

        if (irp == NULL)
        {
            break;
        }

        nextStack = IoGetNextIrpStackLocation(irp);
        nextStack->MajorFunction = IRP_MJ_SCSI;
        nextStack->Parameters.Scsi.Srb = srb;

        // (Re)Initialize the Srb
        //
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK)); // SRB & CDB all ZERO

        srb->Length     = sizeof(SCSI_REQUEST_BLOCK);
        srb->Function   = SRB_FUNCTION_EXECUTE_SCSI;
        srb->CdbLength  = CdbLength;
        srb->SrbFlags   = SRB_FLAGS_DATA_IN;

        srb->SenseInfoBufferLength  = SENSE_BUFFER_SIZE;
        srb->SenseInfoBuffer        = senseInfoBuffer;

        srb->DataTransferLength     = *DataTransferLength;
        srb->DataBuffer             = DataBuffer;

        srb->TimeOutValue = TimeOutValue;

        // (Re)Initialize the Cdb
        //
        RtlCopyMemory(srb->Cdb, Cdb, CdbLength);

        // Initialize the MDL (first time only)
        //
        if (retryCount == 0)
        {
            mdl = IoAllocateMdl(DataBuffer,
                                *DataTransferLength,
                                FALSE,
                                FALSE,
                                NULL);

            if (!mdl)
            {
                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto USBSTOR_GetInquiryData_Exit;
            }

            MmBuildMdlForNonPagedPool(mdl);
        }

        irp->MdlAddress = mdl;


        // Initialize the event we'll wait on
        //
        KeInitializeEvent(&localevent,
                          SynchronizationEvent,
                          FALSE);

        // Set the completion routine, which will signal the event
        //
        IoSetCompletionRoutine(irp,
                               USBSTOR_SyncCompletionRoutine,
                               &localevent,
                               TRUE,    // InvokeOnSuccess
                               TRUE,    // InvokeOnError
                               TRUE);   // InvokeOnCancel

        // Pass the Irp & Srb down the stack
        //
        ntStatus = IoCallDriver(DeviceObject, irp);

        // If the request is pending, block until it completes
        //
        if (ntStatus == STATUS_PENDING)
        {
            KeWaitForSingleObject(&localevent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);

            // Get final completion status
            //
            ntStatus = irp->IoStatus.Status;
        }

        DBGPRINT(2, ("USBSTOR_IssueInternalCdb %d %08X %08X\n",
                     retryCount, ntStatus, srb->SrbStatus));

        if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
            (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN))
        {
            ntStatus = STATUS_SUCCESS;
            *DataTransferLength = srb->DataTransferLength;
            break;
        }
        else
        {
            ntStatus = STATUS_UNSUCCESSFUL;
        }

        // Free the Irp.  A new one will be allocated the next time around.
        //
        IoFreeIrp(irp);
        irp = NULL;
    }

USBSTOR_GetInquiryData_Exit:

    if (mdl != NULL)
    {
        IoFreeMdl(mdl);
    }

    if (senseInfoBuffer != NULL)
    {
        ExFreePool(senseInfoBuffer);
    }

    if (srb != NULL)
    {
        ExFreePool(srb);
    }

    if (irp != NULL)
    {
        IoFreeIrp(irp);
    }

    DBGPRINT(2, ("exit:  USBSTOR_IssueInternalCdb %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_GetInquiryData()
//
//******************************************************************************

NTSTATUS
USBSTOR_GetInquiryData (
    PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION   pdoDeviceExtension;
    PDEVICE_OBJECT          fdoDeviceObject;
    PFDO_DEVICE_EXTENSION   fdoDeviceExtension;
    PVOID                   dataBuffer;
    ULONG                   dataTransferLength;
    CDB                     cdb;
    NTSTATUS                ntStatus;

    PAGED_CODE();

    DBGPRINT(2, ("enter: USBSTOR_GetInquiryData\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    fdoDeviceObject = pdoDeviceExtension->ParentFDO;
    fdoDeviceExtension = fdoDeviceObject->DeviceExtension;
    ASSERT(fdoDeviceExtension->Type == USBSTOR_DO_TYPE_FDO);

    dataBuffer = pdoDeviceExtension->InquiryDataBuffer;
    dataTransferLength = sizeof(pdoDeviceExtension->InquiryDataBuffer);

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;
    cdb.CDB6INQUIRY.AllocationLength = (UCHAR)dataTransferLength;

    ntStatus = USBSTOR_IssueInternalCdb(DeviceObject,
                                        dataBuffer,
                                        &dataTransferLength,
                                        &cdb,
                                        sizeof(cdb.CDB6INQUIRY),
                                        20);

    if (NT_SUCCESS(ntStatus) &&
        fdoDeviceExtension->DriverFlags == DeviceProtocolUnspecified)
    {
        // The Inquiry request is the first request we send to the device.  If
        // the first request was successful and the protocol was not specified,
        // set it to the default protocol, which is DeviceProtocolCB.
        //
        DBGPRINT(1, ("Setting Unspecified device to CB\n"));

        fdoDeviceExtension->DriverFlags = DeviceProtocolCB;
    }

    DBGPRINT(2, ("exit:  USBSTOR_GetInquiryData %08X\n", ntStatus));

    return ntStatus;
}

//******************************************************************************
//
// USBSTOR_IsFloppyDevice()
//
// This routine issues a SCSIOP_READ_FORMATTED_CAPACITY request and looks
// at the returned Format Capacity Descriptor list to see if the device
// supports any of the known floppy capacities.  If the device does support
// a known floppy capacity, it is assumed that the device is a floppy.
//
//******************************************************************************

typedef struct _FORMATTED_CAPACITY
{
    ULONG   NumberOfBlocks;
    ULONG   BlockLength;
} FORMATTED_CAPACITY, *PFORMATTED_CAPACITY;

FORMATTED_CAPACITY FloppyCapacities[] =
{
    // Blocks    BlockLen      H   T  B/S S/T
    {0x00000500, 0x000200}, // 2  80  512   8    640 KB  F5_640_512
    {0x000005A0, 0x000200}, // 2  80  512   9    720 KB  F3_720_512
    {0x00000960, 0x000200}, // 2  80  512  15   1.20 MB  F3_1Pt2_512   (Toshiba)
    {0x000004D0, 0x000400}, // 2  77 1024   8   1.23 MB  F3_1Pt23_1024 (NEC)
    {0x00000B40, 0x000200}, // 2  80  512  18   1.44 MB  F3_1Pt44_512
    {0x0003C300, 0x000200}, // 8 963  512  32    120 MB  F3_120M_512
    {0x000600A4, 0x000200}  //13 890  512  34    200 MB  HiFD
};

#define FLOPPY_CAPACITIES (sizeof(FloppyCapacities)/sizeof(FloppyCapacities[0]))

BOOLEAN
USBSTOR_IsFloppyDevice (
    PDEVICE_OBJECT  DeviceObject
    )
{
    PPDO_DEVICE_EXTENSION               pdoDeviceExtension;
    BOOLEAN                             isFloppy;
    struct _READ_FORMATTED_CAPACITIES   cdb;
    PFORMATTED_CAPACITY_LIST            capList;
    PVOID                               dataBuffer;
    ULONG                               dataTransferLength;
    NTSTATUS                            ntStatus;

    PAGED_CODE();

    DBGPRINT(1, ("enter: USBSTOR_IsFloppyDevice\n"));

    pdoDeviceExtension = DeviceObject->DeviceExtension;
    ASSERT(pdoDeviceExtension->Type == USBSTOR_DO_TYPE_PDO);

    isFloppy = FALSE;

    // Allocate a transfer buffer for the SCSIOP_READ_FORMATTED_CAPACITY request
    // The length of the returned descriptor array is limited to a byte field
    // in the capacity list header.
    //
    dataTransferLength = sizeof(FORMATTED_CAPACITY_LIST) +
                         31 * sizeof(FORMATTED_CAPACITY_DESCRIPTOR);

    ASSERT(dataTransferLength < 0x100);

    dataBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       dataTransferLength,
                                       POOL_TAG);

    if (dataBuffer)
    {
        RtlZeroMemory(dataBuffer, dataTransferLength);

        RtlZeroMemory(&cdb, sizeof(cdb));

        cdb.OperationCode = SCSIOP_READ_FORMATTED_CAPACITY;
        cdb.AllocationLength[1] = (UCHAR)dataTransferLength;

        capList = (PFORMATTED_CAPACITY_LIST)dataBuffer;

        ntStatus = USBSTOR_IssueInternalCdb(DeviceObject,
                                            dataBuffer,
                                            &dataTransferLength,
                                            (PCDB)&cdb,
                                            sizeof(cdb),
                                            20);

        DBGPRINT(1, ("%08X %08X %02X\n",
                     ntStatus, dataTransferLength, capList->CapacityListLength));

        if (NT_SUCCESS(ntStatus) &&
            dataTransferLength >= sizeof(FORMATTED_CAPACITY_LIST) &&
            capList->CapacityListLength &&
            capList->CapacityListLength % sizeof(FORMATTED_CAPACITY_DESCRIPTOR) == 0)
        {
            ULONG   NumberOfBlocks;
            ULONG   BlockLength;
            ULONG   i, j, count;

            // Subtract the size of the Capacity List Header to get
            // just the size of the Capacity List Descriptor array.
            //
            dataTransferLength -= sizeof(FORMATTED_CAPACITY_LIST);

            // Only look at the Capacity List Descriptors that were
            // actually returned.
            //
            if (dataTransferLength < capList->CapacityListLength)
            {
                count = dataTransferLength /
                        sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
            }
            else
            {
                count = capList->CapacityListLength /
                        sizeof(FORMATTED_CAPACITY_DESCRIPTOR);
            }

            for (i=0; i<count; i++)
            {
                NumberOfBlocks = (capList->Descriptors[i].NumberOfBlocks[0] << 24) +
                                 (capList->Descriptors[i].NumberOfBlocks[1] << 16) +
                                 (capList->Descriptors[i].NumberOfBlocks[2] <<  8) +
                                  capList->Descriptors[i].NumberOfBlocks[3];

                BlockLength = (capList->Descriptors[i].BlockLength[0] << 16) +
                              (capList->Descriptors[i].BlockLength[1] <<  8) +
                               capList->Descriptors[i].BlockLength[2];

                DBGPRINT(1, ("Capacity[%d] %08X %06X %d%d\n",
                             i,
                             NumberOfBlocks,
                             BlockLength,
                             capList->Descriptors[i].Valid,
                             capList->Descriptors[i].Maximum));

                for (j=0; j<FLOPPY_CAPACITIES; j++)
                {
                    if (NumberOfBlocks == FloppyCapacities[j].NumberOfBlocks &&
                        BlockLength    == FloppyCapacities[j].BlockLength)
                    {
                        isFloppy = TRUE;
                    }
                }

            }
        }

        ExFreePool(dataBuffer);
    }

    DBGPRINT(1, ("exit:  USBSTOR_IsFloppyDevice %d\n", isFloppy));

    return isFloppy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\ocrw.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    OCRW.C

Abstract:

    This source file contains the dispatch routines which handle
    opening, closing, reading, and writing to the device, i.e.:

    IRP_MJ_CREATE
    IRP_MJ_CLOSE
    IRP_MJ_READ
    IRP_MJ_WRITE

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <ntddk.h>
#include <usbdi.h>
#include <usbdlib.h>

#include "usbmass.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, USBSTOR_Create)
#pragma alloc_text(PAGE, USBSTOR_Close)
#pragma alloc_text(PAGE, USBSTOR_ReadWrite)
#endif

//******************************************************************************
//
// USBSTOR_Create()
//
// Dispatch routine which handles IRP_MJ_CREATE
//
//******************************************************************************

NTSTATUS
USBSTOR_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    DBGPRINT(2, ("enter: USBSTOR_Create\n"));

    LOGENTRY('CREA', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CREATE);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_Create\n"));

    LOGENTRY('crea', 0, 0, 0);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// USBSTOR_Close()
//
// Dispatch routine which handles IRP_MJ_CLOSE
//
//******************************************************************************

NTSTATUS
USBSTOR_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    DBGPRINT(2, ("enter: USBSTOR_Close\n"));

    LOGENTRY('CLOS', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_CLOSE);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_Close\n"));

    LOGENTRY('clos', 0, 0, 0);

    return STATUS_SUCCESS;
}


//******************************************************************************
//
// USBSTOR_ReadWrite()
//
// Dispatch routine which handles IRP_MJ_READ and IRP_MJ_WRITE
//
//******************************************************************************

NTSTATUS
USBSTOR_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS            ntStatus;

    DBGPRINT(2, ("enter: USBSTOR_ReadWrite\n"));

    LOGENTRY('RW  ', DeviceObject, Irp, 0);

    DBGFBRK(DBGF_BRK_READWRITE);

    ntStatus = STATUS_INVALID_PARAMETER;
    Irp->IoStatus.Status = ntStatus;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    DBGPRINT(2, ("exit: USBSTOR_ReadWrite %08X\n", ntStatus));

    LOGENTRY('rw  ', ntStatus, 0, 0);

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\serioctl.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

        SERIOCTL.C

Abstract:

        Routines to handle serial IOCTLs for Legacy USB Modem Driver.

Environment:

        kernel mode only

Notes:

        THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
        KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
        IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
        PURPOSE.

        Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

        12/27/97 : created

Authors:

        Tom Green


****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "serioctl.h"
#include "utils.h"
#include "usbserpw.h"
#include "debugwdm.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGEUSBS, SetBaudRate)
#pragma alloc_text(PAGEUSBS, GetBaudRate)
#pragma alloc_text(PAGEUSBS, SetLineControl)
#pragma alloc_text(PAGEUSBS, GetLineControl)
#pragma alloc_text(PAGEUSBS, SetTimeouts)
#pragma alloc_text(PAGEUSBS, GetTimeouts)
#pragma alloc_text(PAGEUSBS, SetChars)
#pragma alloc_text(PAGEUSBS, GetChars)
#pragma alloc_text(PAGEUSBS, SetClrDtr)
#pragma alloc_text(PAGEUSBS, ResetDevice)
#pragma alloc_text(PAGEUSBS, SetRts)
#pragma alloc_text(PAGEUSBS, ClrRts)
#pragma alloc_text(PAGEUSBS, SetBreak)
#pragma alloc_text(PAGEUSBS, SetQueueSize)
#pragma alloc_text(PAGEUSBS, GetWaitMask)
#pragma alloc_text(PAGEUSBS, SetWaitMask)
#pragma alloc_text(PAGEUSBS, WaitOnMask)
#pragma alloc_text(PAGEUSBS, ImmediateChar)
#pragma alloc_text(PAGEUSBS, Purge)
#pragma alloc_text(PAGEUSBS, GetHandflow)
#pragma alloc_text(PAGEUSBS, SetHandflow)
#pragma alloc_text(PAGEUSBS, GetModemStatus)
#pragma alloc_text(PAGEUSBS, GetDtrRts)
#pragma alloc_text(PAGEUSBS, GetCommStatus)
#pragma alloc_text(PAGEUSBS, GetProperties)
#pragma alloc_text(PAGEUSBS, LsrmstInsert)
#pragma alloc_text(PAGEUSBS, ConfigSize)
#pragma alloc_text(PAGEUSBS, GetStats)
#pragma alloc_text(PAGEUSBS, ClearStats)
#pragma alloc_text(PAGEUSBS, SerialGetProperties)
#endif // ALLOC_PRAGMA


LOCAL UCHAR StopBits[] =
{
        STOP_BIT_1,                     // USB_COMM_STOPBITS_10
        STOP_BITS_1_5,                  // USB_COMM_STOPBITS_15
        STOP_BITS_2                     // USB_COMM_STOPBITS_20
};

LOCAL UCHAR ParityType[] =
{
        NO_PARITY,                      // USB_COMM_PARITY_NONE
        ODD_PARITY,                     // USB_COMM_PARITY_ODD
        EVEN_PARITY,                    // USB_COMM_PARITY_EVEN
        MARK_PARITY,                    // USB_COMM_PARITY_MARK
        SPACE_PARITY                    // USB_COMM_PARITY_SPACE
};



/************************************************************************/
/* SetBaudRate                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_BAUD_RATE                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_BAUD_RATE   Br = (PSERIAL_BAUD_RATE) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;
   PDEVICE_EXTENSION   DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetBaudRate(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_BAUD_RATE)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
      DeviceExtension->CurrentBaud = Br->BaudRate;
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("BaudRate (%08X)\n", Br->BaudRate));

      NtStatus = SetLineControlAndBaud(PDevObj);

   }

   DEBUG_LOG_PATH("exit  SetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetBaudRate %08X\n", NtStatus));

   return NtStatus;
} // SetBaudRate


/************************************************************************/
/* GetBaudRate                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_BAUD_RATE                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetBaudRate(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_BAUD_RATE   Br = (PSERIAL_BAUD_RATE) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;
   PDEVICE_EXTENSION   DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetBaudRate(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_BAUD_RATE)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      GetLineControlAndBaud(PDevObj);

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      Br->BaudRate = DeviceExtension->CurrentBaud;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIAL_BAUD_RATE);
   }

   DEBUG_LOG_PATH("exit  GetBaudRate");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetBaudRate %08X\n", NtStatus));

   return NtStatus;
} // GetBaudRate


/************************************************************************/
/* SetLineControl                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_LINE_CONTROL                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
   PSERIAL_LINE_CONTROL    LineControl
      = (PSERIAL_LINE_CONTROL) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   KIRQL                   OldIrql;
   PIO_STACK_LOCATION      IrpStack;
   PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetLineControl");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetLineControl(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_LINE_CONTROL)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->LineControl = *LineControl;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      // set line control for USB modem
      NtStatus = SetLineControlAndBaud(PDevObj);
   }

   DEBUG_LOG_PATH("exit  SetLineControl");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetLineControl %08X\n", NtStatus));

   return NtStatus;
} // SetLineControl


/************************************************************************/
/* GetLineControl                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_LINE_CONTROL                            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetLineControl(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
        PSERIAL_LINE_CONTROL    LineControl =
           (PSERIAL_LINE_CONTROL) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;
        PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetLineControl");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetLineControl(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_LINE_CONTROL))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                GetLineControlAndBaud(PDevObj);

                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *LineControl = DeviceExtension->LineControl;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_LINE_CONTROL);
        }

        DEBUG_LOG_PATH("exit  GetLineControl");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetLineControl %08X\n", NtStatus));

        return NtStatus;
} // GetLineControl



/************************************************************************/
/* SetTimeouts                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_TIMEOUTS                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_TIMEOUTS        Timeouts =
           (PSERIAL_TIMEOUTS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS               NtStatus = STATUS_SUCCESS;
        KIRQL                  OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM,
                         (">SetTimeouts(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(SERIAL_TIMEOUTS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                DeviceExtension->Timeouts = *Timeouts;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM, ("<SetTimeouts %08X\n",
                                                           NtStatus));

        return NtStatus;
} // SetTimeouts


/************************************************************************/
/* GetTimeouts                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_TIMEOUTS                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetTimeouts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_TIMEOUTS        Timeouts =
           (PSERIAL_TIMEOUTS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM,
                         (">GetTimeouts(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_TIMEOUTS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *Timeouts = DeviceExtension->Timeouts;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_TIMEOUTS);
        }

        DEBUG_LOG_PATH("exit  GetTimeouts");
        UsbSerSerialDump(USBSERTRACEIOC | USBSERTRACETM, ("<GetTimeouts %08X\n",
                                                           NtStatus));

        return NtStatus;
} // GetTimeouts


/************************************************************************/
/* SetChars                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_CHARS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_CHARS           SpecialChars =
           (PSERIAL_CHARS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetChars");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetChars(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(SERIAL_CHARS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                DeviceExtension->SpecialChars = *SpecialChars;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetChars");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetChars %08X\n"));

        return NtStatus;
} // SetChars


/************************************************************************/
/* GetChars                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_CHARS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetChars(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PSERIAL_CHARS           SpecialChars =
           (PSERIAL_CHARS) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS                NtStatus = STATUS_SUCCESS;
        KIRQL                   OldIrql;
        PIO_STACK_LOCATION      IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetChars");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetChars(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(SERIAL_CHARS))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *SpecialChars = DeviceExtension->SpecialChars;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(SERIAL_CHARS);
        }

        DEBUG_LOG_PATH("exit  GetChars");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetChars %08X\n", NtStatus));

        return NtStatus;
} // GetChars


/************************************************************************/
/* SetClrDtr                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_DTR and IOCTL_SERIAL_CLR_DTR            */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj  - pointer to device object                             */
/*      Set - TRUE if setting DTR, FALSE if clearing DTR                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetClrDtr(IN PDEVICE_OBJECT PDevObj, IN BOOLEAN Set)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetClrDtr");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetClrDtr\n"));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        if(DeviceExtension->DTRRTSState & SERIAL_RTS_STATE)
           State |= USB_COMM_RTS;

        if (Set) {
           DeviceExtension->DTRRTSState |= SERIAL_DTR_STATE;
           State |= USB_COMM_DTR;
        } else {
           DeviceExtension->DTRRTSState &= ~SERIAL_DTR_STATE;
        }

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        if(DeviceExtension->DTRRTSState & SERIAL_RTS_STATE)
           State |= USB_COMM_RTS;

        NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SET_CONTROL_LINE_STATE,
                                      State, DeviceExtension->CommInterface,
                                      NULL, NULL, FALSE, USBSER_CLASS_COMMAND);

        if(!NT_SUCCESS(NtStatus)) {
           ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
           DeviceExtension->DTRRTSState &= ~SERIAL_DTR_STATE;
           RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
        }

        DEBUG_LOG_PATH("exit  SetClrDtr");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetClrDtr %08X\n", NtStatus));

        return NtStatus;
} // SetClrDtr


/************************************************************************/
/* ResetDevice                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_RESET_DEVICE                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ResetDevice(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ResetDevice");
        UsbSerSerialDump(USBSERTRACEIOC, (">ResetDevice(%08X)\n", Irp));

        // get line control and baud rate info
        GetLineControlAndBaud(PDevObj);

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        // do device extension device specific stuff here
        DeviceExtension->SupportedBauds = SERIAL_BAUD_300 | SERIAL_BAUD_600
           | SERIAL_BAUD_1200 | SERIAL_BAUD_2400 | SERIAL_BAUD_4800
           | SERIAL_BAUD_9600 | SERIAL_BAUD_19200 | SERIAL_BAUD_38400
           | SERIAL_BAUD_57600  | SERIAL_BAUD_115200;

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ResetDevice");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ResetDevice %08X\n"));

        return NtStatus;
} // ResetDevice


/************************************************************************/
/* SetRts                                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_RTS                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter SetRts");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetRts(%08X)\n", Irp));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
        DeviceExtension->DTRRTSState |= SERIAL_RTS_STATE;
        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  SetRts");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetRts %08X\n", NtStatus));

        return NtStatus;
} // SetRts


/************************************************************************/
/* ClrRts                                                               */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CLR_RTS                                     */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;
        USHORT                          State = 0;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ClrRts");
        UsbSerSerialDump(USBSERTRACEIOC, (">ClrRts(%08X)\n", Irp));

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
        DeviceExtension->DTRRTSState &= ~SERIAL_RTS_STATE;
        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ClrRts");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ClrRts %08X\n", NtStatus));

        return NtStatus;
} // ClrRts


/************************************************************************/
/* SetBreak                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_BREAK_ON & IOCTL_SERIAL_SET_BREAK_OFF   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      PDevObj         - pointer to device object                      */
/*      Time            - time to assert break in ms                    */
/*                        (0xFFFF - on / 0x0000 - off)                  */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetBreak(IN PIRP Irp, IN PDEVICE_OBJECT PDevObj, USHORT Time)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        PDEVICE_EXTENSION            DeviceExtension = PDevObj->DeviceExtension;

        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter SetBreak");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetBreak(%08X)\n", Irp));

        NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SEND_BREAK, Time,
                                      DeviceExtension->CommInterface, NULL,
                                      NULL, FALSE, USBSER_CLASS_COMMAND);

        DEBUG_LOG_PATH("exit  SetBreak");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetBreak %08X\n", NtStatus));

        return NtStatus;
} // SetBreak


/************************************************************************/
/* SetQueueSize                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_QUEUE_SIZE                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetQueueSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS           NtStatus = STATUS_SUCCESS;
        PIO_STACK_LOCATION IrpStack;
        PULONG             QueueSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;

        DEBUG_LOG_PATH("enter SetQueueSize");
        UsbSerSerialDump(USBSERTRACEIOC, (">SetQueueSize(%08X)\n", Irp));

        USBSER_LOCKED_PAGED_CODE();

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.InputBufferLength
           < sizeof(ULONG))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
         DEBUG_TRACE1(("SetQueueSize (%08X)\n", *QueueSize));
                // we will go ahead and save this, but we don't care.
//                DeviceExtension->RxQueueSize = *QueueSize;
        }

        DEBUG_LOG_PATH("exit  SetQueueSize");
        UsbSerSerialDump(USBSERTRACEIOC, ("<SetQueueSize %08X\n", NtStatus));

        return NtStatus;
} // SetQueueSize


/************************************************************************/
/* GetWaitMask                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_WAIT_MASK                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        PULONG              WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
        NTSTATUS            NtStatus = STATUS_SUCCESS;
        KIRQL               OldIrql;
        PIO_STACK_LOCATION  IrpStack;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter GetWaitMask");
        UsbSerSerialDump(USBSERTRACEIOC, (">GetWaitMask(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        IrpStack = IoGetCurrentIrpStackLocation(Irp);

        if(IrpStack->Parameters.DeviceIoControl.OutputBufferLength
           < sizeof(ULONG))
        {
                NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
                ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

                *WaitMask = DeviceExtension->IsrWaitMask;

                RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

                Irp->IoStatus.Information = sizeof(ULONG);
        }

        DEBUG_LOG_PATH("exit  GetWaitMask");
        UsbSerSerialDump(USBSERTRACEIOC, ("<GetWaitMask %08X\n"));

        return NtStatus;
} // GetWaitMask


/************************************************************************/
/* SetWaitMask                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_WAIT_MASK                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetWaitMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG                  WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   KIRQL                   OldIrql;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetWaitMask");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetWaitMask(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      // make sure it's a valid request
      if (*WaitMask & ~(       SERIAL_EV_RXCHAR   |
                               SERIAL_EV_RXFLAG   |
                               SERIAL_EV_TXEMPTY  |
                               SERIAL_EV_CTS      |
                               SERIAL_EV_DSR      |
                               SERIAL_EV_RLSD     |
                               SERIAL_EV_BREAK    |
                               SERIAL_EV_ERR      |
                               SERIAL_EV_RING     |
                               SERIAL_EV_PERR     |
                               SERIAL_EV_RX80FULL |
                               SERIAL_EV_EVENT1   |
                               SERIAL_EV_EVENT2)) {
         NtStatus = STATUS_INVALID_PARAMETER;
      } else {
         UsbSerCompletePendingWaitMasks(DeviceExtension);

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         DeviceExtension->HistoryMask = 0;

         DeviceExtension->IsrWaitMask = *WaitMask;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         DEBUG_TRACE3(("SetWaitMask (%08X)\n", *WaitMask));
      }
   }

   DEBUG_LOG_PATH("exit  SetWaitMask");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetWaitMask %08X\n", NtStatus));

   return NtStatus;
} // SetWaitMask


/************************************************************************/
/* WaitOnMask                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_WAIT_ON_MASK                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
WaitOnMask(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              WaitMask = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter WaitOnMask");
   UsbSerSerialDump(USBSERTRACEIOC, (">WaitOnMask(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      // if we have an event to report, just go ahead and return it
      if (DeviceExtension->HistoryMask) {
         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         *WaitMask = DeviceExtension->HistoryMask;
         DeviceExtension->HistoryMask = 0;

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         Irp->IoStatus.Information = sizeof(ULONG);

         UsbSerSerialDump(USBSERCOMPEV,
                          ("Completing maskirp(3) %08x\n",
                           *WaitMask));

         DEBUG_TRACE3(("Signal Event (%08X)\n", *WaitMask));
      } else {
         KIRQL cancelIrql;

         ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

         // just in case something comes in, we'll do a while loop
         while (DeviceExtension->CurrentMaskIrp) {
            PIRP pOldIrp;

            DEBUG_TRACE3(("Completing previous mask\n"));

            pOldIrp = DeviceExtension->CurrentMaskIrp;
            DeviceExtension->CurrentMaskIrp = NULL;

            pOldIrp->IoStatus.Status = STATUS_SUCCESS;
            IoSetCancelRoutine(pOldIrp, NULL);

            *WaitMask = 0;

            UsbSerSerialDump(USBSERCOMPEV,
                             ("Completing maskirp(4)\n"));

            //
            // Release locks, complete request, then
            // reacquire the locks
            //


            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock,
                              OldIrql);

            RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

            IoCompleteRequest(pOldIrp, IO_SERIAL_INCREMENT);

            ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock,
                              &OldIrql);
         }


         //
         // Check to see if it needs to be cancelled
         //

         if (Irp->Cancel) {

            Irp->IoStatus.Status = STATUS_CANCELLED;
            Irp->IoStatus.Information = 0;
            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

            RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
         } else {
            IoSetCancelRoutine(Irp, UsbSerCancelWaitOnMask);
            NtStatus = Irp->IoStatus.Status = STATUS_PENDING;

            DeviceExtension->CurrentMaskIrp = Irp;

         	RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

         	RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
         	
            IoMarkIrpPending(Irp);

         }

      }

   }

   DEBUG_LOG_PATH("exit  WaitOnMask");
   UsbSerSerialDump(USBSERTRACEIOC, ("<WaitOnMask %08X\n", NtStatus));

   return NtStatus;
} // WaitOnMask


/************************************************************************/
/* ImmediateChar                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_IMMEDIATE_CHAR                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceObject    - pointer to device object                      */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ImmediateChar(IN PIRP Irp, IN PDEVICE_OBJECT DeviceObject)
{
   PUCHAR                  Char = (PUCHAR) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter ImmediateChar");
   UsbSerSerialDump(USBSERTRACEIOC, (">ImmediateChar(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(UCHAR)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      //
      // We just treat this as a write since we have no internal
      // data buffer.
      //

      IrpStack->Parameters.Write.Length = sizeof(UCHAR);

      NtStatus = UsbSer_Write(DeviceObject, Irp);
   }

   DEBUG_LOG_PATH("exit  ImmediateChar");
   UsbSerSerialDump(USBSERTRACEIOC, ("<ImmediateChar, %08X\n", NtStatus));

   return NtStatus;
} // ImmediateChar


/************************************************************************/
/* Purge                                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_PURGE                                       */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
Purge(IN PDEVICE_OBJECT PDevObj, IN PIRP Irp,
      IN PDEVICE_EXTENSION DeviceExtension)
{
   ULONG                   Mask = *((PULONG) Irp->AssociatedIrp.SystemBuffer);
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;
   KIRQL                   OldIrql;
   ULONG                   Count;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter Purge");
   UsbSerSerialDump(USBSERTRACEIOC, (">Purge(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      // make sure purge request is valid
      if ((!Mask) || (Mask & ( ~(      SERIAL_PURGE_TXABORT |
                                       SERIAL_PURGE_RXABORT |
                                       SERIAL_PURGE_TXCLEAR |
                                       SERIAL_PURGE_RXCLEAR)))) {
         NtStatus = STATUS_INVALID_PARAMETER;
      } else {
         if (Mask & SERIAL_PURGE_RXCLEAR) {
            ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

            Count = DeviceExtension->CharsInReadBuff;

            DeviceExtension->CharsInReadBuff        = 0;
            DeviceExtension->CurrentReadBuffPtr     = 0;

            RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

			if(Count)
			{
	            RestartRead(DeviceExtension);
	        }
         }

         if (Mask & SERIAL_PURGE_RXABORT) {
            UsbSerKillAllReadsOrWrites(PDevObj, &DeviceExtension->ReadQueue,
                                       &DeviceExtension->CurrentReadIrp);
         }

         if (Mask & SERIAL_PURGE_TXABORT) {
            //
            // DO NOTHING because USB owns the request.  However, it may
            // prove in practice that we will have to cancel the IRPs on behalf
            // of the caller.
         }
      }
   }

   DEBUG_LOG_PATH("exit  Purge");
   UsbSerSerialDump(USBSERTRACEIOC, ("<Purge %08X\n", NtStatus));

   return NtStatus;
} // Purge


/************************************************************************/
/* GetHandflow                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_HANDFLOW                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_HANDFLOW    HandFlow
      = (PSERIAL_HANDFLOW) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetHandFlow(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_HANDFLOW)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *HandFlow = DeviceExtension->HandFlow;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIAL_HANDFLOW);
   }

   DEBUG_LOG_PATH("exit  GetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetHandFlow %08X\n", NtStatus));

   return NtStatus;
} // GetHandflow


/************************************************************************/
/* SetHandflow                                                          */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_SET_HANDFLOW                                */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
SetHandflow(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_HANDFLOW    HandFlow
      = (PSERIAL_HANDFLOW) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, (">SetHandFlow(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.InputBufferLength
       < sizeof(SERIAL_HANDFLOW)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->HandFlow = *HandFlow;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("ControlHandShake (%08X)\n",
                    DeviceExtension->HandFlow.ControlHandShake));

   }

   DEBUG_LOG_PATH("exit  SetHandflow");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SetHandFlow %08X\n", NtStatus));

   return NtStatus;
} // SetHandflow

/************************************************************************/
/* GetModemStatus                                                       */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_MODEMSTATUS                             */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetModemStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              ModemStatus = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetModemStatus");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetModemStatus(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *ModemStatus = DeviceExtension->FakeModemStatus;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(ULONG);

      DEBUG_TRACE3(("ModemStatus (%08X)\n", *ModemStatus));
   }

   DEBUG_LOG_PATH("exit  GetModemStatus");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetModemStatus %08X\n", NtStatus));

   return NtStatus;
} // GetModemStatus


/************************************************************************/
/* GetDtrRts                                                            */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_DTRRTS                                  */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetDtrRts(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG              ModemControl = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION  IrpStack;
   KIRQL               OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetDtrRts");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetDtrRts(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {

      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *ModemControl = DeviceExtension->DTRRTSState;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DEBUG_LOG_PATH("exit  GetDtrRts");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetDtrRts %08X\n", NtStatus));

   return NtStatus;
} // GetDtrRts


/************************************************************************/
/* GetCommStatus                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_COMMSTATUS                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetCommStatus(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIAL_STATUS      SerialStatus
      = (PSERIAL_STATUS) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetCommStatus");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetCommStatus(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_STATUS)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      if (NT_SUCCESS(NtStatus)) {
         RtlZeroMemory(SerialStatus, sizeof(SERIAL_STATUS));

         ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);
         SerialStatus->AmountInInQueue   = DeviceExtension->CharsInReadBuff;
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

       DEBUG_TRACE2(("AmountInInQueue (%08X)\n", SerialStatus->AmountInInQueue));

         SerialStatus->Errors            = 0;
         SerialStatus->EofReceived       = FALSE;
         SerialStatus->AmountInOutQueue  = 0;
         SerialStatus->WaitForImmediate  = 0;
         SerialStatus->HoldReasons       = 0;

         Irp->IoStatus.Information = sizeof(SERIAL_STATUS);
      }
   }

   DEBUG_LOG_PATH("exit  GetCommStatus");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetCommStatus %08X\n", NtStatus));

   return NtStatus;
} // GetCommStatus


/************************************************************************/
/* GetProperties                                                        */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_PROPERTIES                              */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetProperties(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION      IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter GetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetProperties(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIAL_COMMPROP)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      SerialGetProperties(DeviceExtension,
                          (PSERIAL_COMMPROP)Irp->AssociatedIrp.SystemBuffer);

      Irp->IoStatus.Information = sizeof(SERIAL_COMMPROP);
   }

   DEBUG_LOG_PATH("exit  GetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetProperties %08X\n", NtStatus));

   return NtStatus;
} // GetProperties


/************************************************************************/
/* LsrmstInsert                                                         */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_LSRMST_INSERT                               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
LsrmstInsert(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        USBSER_LOCKED_PAGED_CODE();

        DEBUG_LOG_PATH("enter LsrmstInsert");

        UsbSerSerialDump(USBSERTRACEIOC, (">LsrmstInsert(%08X)\n", Irp));

        UsbSerSerialDump(USBSERTRACEIOC, ("<LsrmstInsert (%08X)\n",
                                          STATUS_NOT_SUPPORTED));

        return STATUS_NOT_SUPPORTED;

} // LsrmstInsert


/************************************************************************/
/* ConfigSize                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CONFIG_SIZE                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ConfigSize(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PULONG               ConfigSize = (PULONG) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS             NtStatus = STATUS_SUCCESS;
   PIO_STACK_LOCATION   IrpStack;

   USBSER_LOCKED_PAGED_CODE();

   DEBUG_LOG_PATH("enter ConfigSize");
   UsbSerSerialDump(USBSERTRACEIOC, (">ConfigSize(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(ULONG)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      *ConfigSize = 0;

      Irp->IoStatus.Information = sizeof(ULONG);
   }

   DEBUG_LOG_PATH("exit  ConfigSize");
   UsbSerSerialDump(USBSERTRACEIOC, ("<ConfigSize %08X\n", NtStatus));

   return NtStatus;
} // ConfigSize


/************************************************************************/
/* GetStats                                                             */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_GET_STATS                                   */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
GetStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
   PSERIALPERF_STATS   Stats
      = (PSERIALPERF_STATS) Irp->AssociatedIrp.SystemBuffer;
   NTSTATUS            NtStatus = STATUS_SUCCESS;
   KIRQL               OldIrql;
   PIO_STACK_LOCATION  IrpStack;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter GetStats");
   UsbSerSerialDump(USBSERTRACEIOC, (">GetStats(%08X)\n", Irp));

   Irp->IoStatus.Information = 0;

   IrpStack = IoGetCurrentIrpStackLocation(Irp);

   if (IrpStack->Parameters.DeviceIoControl.OutputBufferLength
       < sizeof(SERIALPERF_STATS)) {
      NtStatus = STATUS_BUFFER_TOO_SMALL;
   } else {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      *Stats = DeviceExtension->PerfStats;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      Irp->IoStatus.Information = sizeof(SERIALPERF_STATS);
   }

   DEBUG_LOG_PATH("exit  GetStats");
   UsbSerSerialDump(USBSERTRACEIOC, ("<GetStats %08X\n", NtStatus));

   return NtStatus;
} // GetStats


/************************************************************************/
/* ClearStats                                                           */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Handle IOCTL_SERIAL_CLEAR_STATS                                 */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      Irp             - pointer to an I/O Request Packet              */
/*      DeviceExtension - pointer to device extension                   */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
ClearStats(IN PIRP Irp, IN PDEVICE_EXTENSION DeviceExtension)
{
        NTSTATUS                        NtStatus = STATUS_SUCCESS;
        KIRQL                           OldIrql;

        USBSER_ALWAYS_LOCKED_CODE();

        DEBUG_LOG_PATH("enter ClearStats");
        UsbSerSerialDump(USBSERTRACEIOC, (">ClearStats(%08X)\n", Irp));

        Irp->IoStatus.Information = 0;

        ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

        RtlZeroMemory(&DeviceExtension->PerfStats,
                                  sizeof(SERIALPERF_STATS));

        RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

        DEBUG_LOG_PATH("exit  ClearStats");
        UsbSerSerialDump(USBSERTRACEIOC, ("<ClearStats %08X\n", NtStatus));

        return NtStatus;
} // ClearStats


/************************************************************************/
/* SerialGetProperties                                                  */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Get serial device properties                                    */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceExtension - pointer to device extension                   */
/*      Properties      - pointer to device properties to fill in       */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      VOID                                                            */
/*                                                                      */
/************************************************************************/
VOID
SerialGetProperties(IN PDEVICE_EXTENSION DeviceExtension,
                    IN PSERIAL_COMMPROP Properties)
{
   KIRQL OldIrql;

   USBSER_ALWAYS_LOCKED_CODE();

   DEBUG_LOG_PATH("enter SerialGetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, (">SerialGetProperties\n"));



   RtlZeroMemory(Properties, sizeof(SERIAL_COMMPROP));

   Properties->PacketLength   = sizeof(SERIAL_COMMPROP);
   Properties->PacketVersion  = 2;
   Properties->ServiceMask    = SERIAL_SP_SERIALCOMM;
   Properties->MaxTxQueue     = 0;
   Properties->MaxRxQueue     = 0;
   Properties->MaxBaud        = SERIAL_BAUD_USER;
   Properties->ProvSubType    = SERIAL_SP_MODEM;

   Properties->ProvCapabilities = SERIAL_PCF_DTRDSR | SERIAL_PCF_CD
      | SERIAL_PCF_PARITY_CHECK | SERIAL_PCF_TOTALTIMEOUTS
      | SERIAL_PCF_INTTIMEOUTS;

   Properties->SettableParams = SERIAL_SP_PARITY | SERIAL_SP_BAUD
      | SERIAL_SP_DATABITS | SERIAL_SP_STOPBITS | SERIAL_SP_HANDSHAKING
      | SERIAL_SP_PARITY_CHECK | SERIAL_SP_CARRIER_DETECT;


   Properties->SettableData  = SERIAL_DATABITS_7 | SERIAL_DATABITS_8;

   Properties->SettableStopParity  = SERIAL_STOPBITS_10 | SERIAL_PARITY_NONE
      | SERIAL_PARITY_ODD  | SERIAL_PARITY_EVEN | SERIAL_PARITY_MARK
      | SERIAL_PARITY_SPACE;

   Properties->CurrentTxQueue = 0;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   Properties->CurrentRxQueue = DeviceExtension->RxQueueSize;
   Properties->SettableBaud   = DeviceExtension->SupportedBauds;

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   DEBUG_LOG_PATH("exit  SerialGetProperties");
   UsbSerSerialDump(USBSERTRACEIOC, ("<SerialGetProperties\n"));

} // SerialGetProperties


/************************************************************************/
/* GetLineControlAndBaud                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      CDC command to get line control settings and baud               */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj - pointer to device object                              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   GetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj)
{
   NTSTATUS                NtStatus = STATUS_SUCCESS;
   USB_COMM_LINE_CODING    LineCoding;
   ULONG                   Size = sizeof(LineCoding);
   KIRQL                   OldIrql;
   PDEVICE_EXTENSION       DeviceExtension = PDevObj->DeviceExtension;

   DEBUG_LOG_PATH("enter GetLineControlAndBaud");

   NtStatus = ClassVendorCommand(PDevObj, USB_COMM_GET_LINE_CODING, 0,
                                 DeviceExtension->CommInterface,
                                 &LineCoding, &Size, TRUE,
                                 USBSER_CLASS_COMMAND);

   if (NT_SUCCESS(NtStatus)) {
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      DeviceExtension->CurrentBaud = LineCoding.DTERate;
      DeviceExtension->LineControl.StopBits = StopBits[LineCoding.CharFormat];
      DeviceExtension->LineControl.Parity = ParityType[LineCoding.ParityType];
      DeviceExtension->LineControl.WordLength = LineCoding.DataBits;

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      DEBUG_TRACE3(("Baud (%08X)  StopBits (%08X)  DataBits (%08X)\n",
                    LineCoding.DTERate, LineCoding.CharFormat,
                    LineCoding.DataBits));
   }

   DEBUG_LOG_PATH("exit  GetLineControlAndBaud");

   return NtStatus;
} // GetLineControlAndBaud


/************************************************************************/
/* SetLineControlAndBaud                                                */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      CDC command to set line control and baud                        */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      PDevObj - pointer to device object                              */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
   SetLineControlAndBaud(IN PDEVICE_OBJECT PDevObj)
{
   NTSTATUS                        NtStatus = STATUS_SUCCESS;
   USB_COMM_LINE_CODING            LineCoding;
   ULONG                           Size = sizeof(LineCoding);
   PSERIAL_LINE_CONTROL            LineControl;
   KIRQL                           OldIrql;
   PDEVICE_EXTENSION               DeviceExtension = PDevObj->DeviceExtension;

   DEBUG_LOG_PATH("enter SetLineControlAndBaud");

   // get pointer to line control in extension
   LineControl = &DeviceExtension->LineControl;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   // set up the line coding data structure
   LineCoding.DTERate  = DeviceExtension->CurrentBaud;
   LineCoding.DataBits = LineControl->WordLength;

   switch (DeviceExtension->LineControl.StopBits) {
   case STOP_BIT_1:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_10;
      break;
   case STOP_BITS_1_5:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_15;
      break;
   case STOP_BITS_2:
      LineCoding.CharFormat   = USB_COMM_STOPBITS_20;
      break;
   default:
      NtStatus = STATUS_INVALID_PARAMETER;
      break;
   }

   switch (DeviceExtension->LineControl.Parity) {
   case NO_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_NONE;
      break;
   case ODD_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_ODD;
      break;
   case EVEN_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_EVEN;
      break;

   case MARK_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_MARK;
      break;
   case SPACE_PARITY:
      LineCoding.ParityType   = USB_COMM_PARITY_SPACE;
      break;
   default:
      NtStatus = STATUS_INVALID_PARAMETER;
      break;
   }

   RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

   // the request must be valid, so send it down to the device
   if (NT_SUCCESS(NtStatus)) {
      NtStatus = ClassVendorCommand(PDevObj, USB_COMM_SET_LINE_CODING, 0,
                                    DeviceExtension->CommInterface,
                                    &LineCoding, &Size, FALSE,
                                    USBSER_CLASS_COMMAND);
   }

   // let's go ahead and just grab this info again in case of an error
   GetLineControlAndBaud(PDevObj);

   DEBUG_LOG_PATH("exit  SetLineControlAndBaud");

   return NtStatus;
} // SetLineControlAndBaud


/************************************************************************/
/* NotifyCompletion                                                     */
/************************************************************************/
/*                                                                      */
/* Routine Description:                                                 */
/*                                                                      */
/*      Notify completion routine.                                      */
/*                                                                      */
/* Arguments:                                                           */
/*                                                                      */
/*      DeviceObject - pointer to a device object                       */
/*      Irp          - pointer to Irp                                   */
/*      Context      - pointer to driver defined context                */
/*                                                                      */
/* Return Value:                                                        */
/*                                                                      */
/*      NTSTATUS                                                        */
/*                                                                      */
/************************************************************************/
NTSTATUS
NotifyCompletion(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp, IN PVOID Context)
{
   PDEVICE_EXTENSION          DeviceExtension = (PDEVICE_EXTENSION) Context;
   PURB                       Urb;
   ULONG                      Count;
   KIRQL                      OldIrql;
   KIRQL                      cancelIrql;
   PUSB_COMM_SERIAL_STATUS    SerialState;
   USHORT                     ModemStatus;
   USHORT                     OldModemStatus;
   PIRP                       CurrentMaskIrp = NULL;
   BOOLEAN					  startRead = FALSE;

   DEBUG_LOG_PATH("enter NotifyCompletion");

   Urb = DeviceExtension->NotifyUrb;

   Count = Urb->UrbBulkOrInterruptTransfer.TransferBufferLength;

   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   SerialState = (PUSB_COMM_SERIAL_STATUS) DeviceExtension->NotificationBuff;

   // see if it is our notification
   if (SerialState->Notification == USB_COMM_SERIAL_STATE
       && Count == sizeof(USB_COMM_SERIAL_STATUS)) {
      OldModemStatus = DeviceExtension->FakeModemStatus;

      // cobble up a fake modem status
      DeviceExtension->FakeModemStatus = SERIAL_MSR_CTS;
      DeviceExtension->FakeLineStatus  = 0;
      DeviceExtension->HistoryMask     = 0;


      ModemStatus = SerialState->SerialState;
      DeviceExtension->FakeLineStatus = 0;

      DEBUG_TRACE1(("CDC Serial State (%08X)\n", ModemStatus));

      if (ModemStatus & USB_COMM_DSR)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_DSR;

      if (ModemStatus & USB_COMM_DCD)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_DCD;

      if (ModemStatus & USB_COMM_RING)
         DeviceExtension->FakeModemStatus        |= SERIAL_MSR_RI;

      // let's see what has changed in the status register
      ModemStatus = OldModemStatus ^ DeviceExtension->FakeModemStatus;

      if (ModemStatus & SERIAL_MSR_DSR)
         DeviceExtension->HistoryMask            |= SERIAL_EV_DSR;

      if (ModemStatus & SERIAL_MSR_DCD)
         DeviceExtension->HistoryMask            |= SERIAL_EV_RLSD;

      if (ModemStatus & SERIAL_MSR_RI)
         DeviceExtension->HistoryMask            |= SERIAL_EV_RING;

      // see if we have any events we are waiting for
      DeviceExtension->HistoryMask &= DeviceExtension->IsrWaitMask;

      // update perf stats if we had any errors
      if (ModemStatus & USB_COMM_FRAMING_ERROR) {
         DeviceExtension->PerfStats.FrameErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_FE;
      }

      if (ModemStatus & USB_COMM_OVERRUN) {
         DeviceExtension->PerfStats.BufferOverrunErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_OE;
      }

      if (ModemStatus & USB_COMM_PARITY_ERROR) {
         DeviceExtension->PerfStats.ParityErrorCount++;
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_PE;
      }

      if (ModemStatus & USB_COMM_BREAK) {
         DeviceExtension->FakeLineStatus |= SERIAL_LSR_BI;
      }

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      ACQUIRE_CANCEL_SPINLOCK(DeviceExtension, &cancelIrql);
      ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

      // let's see if we have any events to signal
      CurrentMaskIrp = DeviceExtension->CurrentMaskIrp;

      if (CurrentMaskIrp && DeviceExtension->HistoryMask) {
         *(PULONG) (CurrentMaskIrp->AssociatedIrp.SystemBuffer) =
            DeviceExtension->HistoryMask;

         CurrentMaskIrp->IoStatus.Status         = STATUS_SUCCESS;
         CurrentMaskIrp->IoStatus.Information    = sizeof(ULONG);

         DeviceExtension->CurrentMaskIrp         = NULL;

      } 
      else 
      {
         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
         RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);
      }
      DEBUG_TRACE1(("Modem Status (%08X)\n", DeviceExtension->FakeModemStatus));
   }
   else
   {
     RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   }



   // complete the queued IRP if needed
   if (CurrentMaskIrp && DeviceExtension->HistoryMask
       && Irp->IoStatus.Status == STATUS_SUCCESS) 
   {
      
      //
      // We should still be holding cancel spin lock because
      // of above if()


      UsbSerSerialDump(USBSERCOMPEV, ("Completing maskirp (4) %08X\n",
                                      DeviceExtension->HistoryMask));

      DeviceExtension->HistoryMask = 0;

      IoSetCancelRoutine(CurrentMaskIrp, NULL);

      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
      RELEASE_CANCEL_SPINLOCK(DeviceExtension, cancelIrql);

      IoCompleteRequest(CurrentMaskIrp, IO_NO_INCREMENT);
      
   } 
 
   // check for Irp cancelled or error
   if(Irp->IoStatus.Status == STATUS_CANCELLED) 
   {
      goto NotifyCompletionErr;
   }
   else if(!NT_SUCCESS(Irp->IoStatus.Status)) 
   {
      UsbSerFetchBooleanLocked(&DeviceExtension->AcceptingRequests,
                               FALSE, &DeviceExtension->ControlLock);
      goto NotifyCompletionErr;
   }


   ACQUIRE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, &OldIrql);

   // kick off another notification request if we still need to
   if (DeviceExtension->AcceptingRequests
       && (DeviceExtension->CurrentDevicePowerState == PowerDeviceD0)) 
   {
	  // see if we have a work item queued already
      if(DeviceExtension->IoWorkItem == NULL)
      {
      	  startRead = TRUE;
      	  
	  	  // kick off another read
      	  DeviceExtension->IoWorkItem = IoAllocateWorkItem(DeviceExtension->PhysDeviceObject);
      }

      if(startRead && DeviceExtension->IoWorkItem)
      {

         RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);

      	 IoQueueWorkItem(DeviceExtension->IoWorkItem,
                         USBSER_RestartNotifyReadWorkItem,
                         CriticalWorkQueue,
                         DeviceExtension);
      }
	  else 
	  {
      	RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   	  }

   } else {
      RELEASE_SPINLOCK(DeviceExtension, &DeviceExtension->ControlLock, OldIrql);
   }

NotifyCompletionErr:;

   //
   // Notify everyone if this is the last IRP and we aren't starting another read
   //

   if((InterlockedDecrement(&DeviceExtension->PendingNotifyCount) == 0)) 
   {
      UsbSerSerialDump(USBSERTRACERD, ("Notify pipe is empty\n"));
      
      if(!startRead)
      {
	      KeSetEvent(&DeviceExtension->PendingNotifyEvent, IO_NO_INCREMENT, FALSE);
	  }
   }


   DEBUG_LOG_PATH("exit  NotifyCompletion");

   return STATUS_MORE_PROCESSING_REQUIRED;
} // NotifyCompletion



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbmass\usbmass.h ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    USBMASS.H

Abstract:

    Header file for USBSTOR driver

Environment:

    kernel mode

Revision History:

    06-01-98 : started rewrite

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <scsi.h>
#include "dbg.h"

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))


#define CLASS_URB(urb)      urb->UrbControlVendorClassRequest
#define FEATURE_URB(urb)    urb->UrbControlFeatureRequest


#define USBSTOR_MAX_TRANSFER_SIZE   0x00010000
#define USBSTOR_MAX_TRANSFER_PAGES  ((USBSTOR_MAX_TRANSFER_SIZE/PAGE_SIZE)+1)


// Interface Descriptor values
//
#define USBSTOR_SUBCLASS_RBC                0x01
#define USBSTOR_SUBCLASS_SFF8020i           0x02
#define USBSTOR_SUBCLASS_QIC157             0x03
#define USBSTOR_SUBCLASS_SFF8070i_UFI       0x04
#define USBSTOR_SUBCLASS_SFF8070i           0x05
#define USBSTOR_SUBCLASS_SCSI_PASSTHROUGH   0x06

#define USBSTOR_PROTOCOL_BULK_ONLY          0x50



#define USBSTOR_DO_TYPE_FDO     '!ODF'
#define USBSTOR_DO_TYPE_PDO     '!ODP'

#define USB_RECIPIENT_DEVICE    0
#define USB_RECIPIENT_INTERFACE 1
#define USB_RECIPIENT_ENDPOINT  2
#define USB_RECIPIENT_OTHER     3

// Bulk-Only class-specific bRequest codes
//
#define BULK_ONLY_MASS_STORAGE_RESET        0xFF
#define BULK_ONLY_GET_MAX_LUN               0xFE

// Maximum value that can be returned by BULK_ONLY_GET_MAX_LUN request
//
#define BULK_ONLY_MAXIMUM_LUN               0x0F


#define POOL_TAG                'SAMU'

#define INCREMENT_PENDING_IO_COUNT(deviceExtension) \
    InterlockedIncrement(&((deviceExtension)->PendingIoCount))

#define DECREMENT_PENDING_IO_COUNT(deviceExtension) do { \
    if (InterlockedDecrement(&((deviceExtension)->PendingIoCount)) == 0) { \
        KeSetEvent(&((deviceExtension)->RemoveEvent), \
                   IO_NO_INCREMENT, \
                   0); \
    } \
} while (0)


#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))


// PDEVICE_EXTENSION->DeviceFlags state flags
//
#define DF_SRB_IN_PROGRESS          0x00000002
#define DF_PERSISTENT_ERROR         0x00000004
#define DF_RESET_IN_PROGRESS        0x00000008
#define DF_DEVICE_DISCONNECTED      0x00000010


// PDEVICE_EXTENSION->DeviceHackFlags flags

// Force a Request Sense command between the completion of one command
// and the start of the next command.
//
#define DHF_FORCE_REQUEST_SENSE     0x00000001

// Reset the device when a Medium Changed AdditionalSenseCode is returned.
//
#define DHF_MEDIUM_CHANGE_RESET     0x00000002

// Turn SCSIOP_TEST_UNIT_READY requests into SCSIOP_START_STOP_UNIT requests.
//
#define DHF_TUR_START_UNIT          0x00000004


// Indicates that a Request Sense is being performed when the Srb has
// a SenseInfoBuffer and AutoSense is not disabled.
//
#define AUTO_SENSE                  0

// Indicates that a Request Sense is being performed when the Srb has
// no SenseInfoBuffer or AutoSense is disabled.  In this case the Request
// Sense is being performed to clear the "persistent error" condition
// in the wacky CBI spec.  (See also the DF_PERSISTENT_ERROR flag).
//
#define NON_AUTO_SENSE              1



// Command Block Wrapper Signature 'USBC'
//
#define CBW_SIGNATURE               0x43425355

#define CBW_FLAGS_DATA_IN           0x80
#define CBW_FLAGS_DATA_OUT          0x00

// Command Status Wrapper Signature 'USBS'
//
#define CSW_SIGNATURE               0x53425355

#define CSW_STATUS_GOOD             0x00
#define CSW_STATUS_FAILED           0x01
#define CSW_STATUS_PHASE_ERROR      0x02


//*****************************************************************************
// T Y P E D E F S
//*****************************************************************************

typedef enum _DEVICE_STATE
{
    DeviceStateCreated = 1,     // After IoCreateDevice
    DeviceStateStarted,         // After START_DEVICE
    DeviceStateStopPending,     // After QUERY_STOP
    DeviceStateStopped,         // After STOP_DEVICE
    DeviceStateRemovePending,   // After QUERY_REMOVE
    DeviceStateSurpriseRemove,  // After SURPRISE_REMOVAL
    DeviceStateRemoved          // After REMOVE_DEVICE

} DEVICE_STATE;


typedef enum _DEVICE_PROTOCOL
{
    // This value indicates that the value was not set in the registry.
    // This should only happen on upgrades before the value started being
    // set by the .INF?
    //
    DeviceProtocolUnspecified = 0,

    // This value indicates that the device uses the Bulk-Only specification
    //
    DeviceProtocolBulkOnly,

    // This value indicates that the device uses the Control/Bulk/Interrupt
    // specification and that command completion Interrupt transfers are
    // supported after every request.
    //
    DeviceProtocolCBI,

    // This value indicates that the device uses the Control/Bulk/Interrupt
    // specification and that command completion Interrupt transfers are not
    // supported at all, or not supported after every request.  The Interrupt
    // endpoint will never be used by the driver for this type of device.
    //
    DeviceProtocolCB,

    // Anything >= this value is bogus
    //
    DeviceProtocolLast

} DEVICE_PROTOCOL;


#pragma pack (push, 1)

// Command Block Wrapper
//
typedef struct _CBW
{
    ULONG   dCBWSignature;

    ULONG   dCBWTag;

    ULONG   dCBWDataTransferLength;

    UCHAR   bCBWFlags;

    UCHAR   bCBWLUN;

    UCHAR   bCDBLength;

    UCHAR   CBWCDB[16];

} CBW, *PCBW;


// Command Status Wrapper
//
typedef struct _CSW
{
    ULONG   dCSWSignature;

    ULONG   dCSWTag;

    ULONG   dCSWDataResidue;

    UCHAR   bCSWStatus;

} CSW, *PCSW;

#pragma pack (pop)


// Device Extension header that is common to both FDO and PDO Device Extensions
//
typedef struct _DEVICE_EXTENSION
{
    // Either USBSTOR_DO_TYPE_FDO or USBSTOR_DO_TYPE_PDO
    //
    ULONG                           Type;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


// Device Extension for the FDO we attach on top of the USB enumerated PDO.
//
typedef struct _FDO_DEVICE_EXTENSION
{
    // USBSTOR_DO_TYPE_FDO
    //
    ULONG                           Type;

    // Back pointer to FDO Device Object to which this Device Extension
    // is attached.
    //
    PDEVICE_OBJECT                  FdoDeviceObject;

    // PDO passed to USBSTOR_AddDevice
    //
    PDEVICE_OBJECT                  PhysicalDeviceObject;

    // Our FDO is attached to this device object
    //
    PDEVICE_OBJECT                  StackDeviceObject;

    // List of child PDOs that we enumerate
    //
    LIST_ENTRY                      ChildPDOs;

    // Device Descriptor retrieved from the device
    //
    PUSB_DEVICE_DESCRIPTOR          DeviceDescriptor;

    // Configuration Descriptor retrieved from the device
    //
    PUSB_CONFIGURATION_DESCRIPTOR   ConfigurationDescriptor;

    // Interface Descriptor contained within above Configuration Descriptor
    //
    PUSB_INTERFACE_DESCRIPTOR       InterfaceDescriptor;

    // Serial Number String Descriptor
    //
    PUSB_STRING_DESCRIPTOR          SerialNumber;

    // ConfigurationHandle returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    USBD_CONFIGURATION_HANDLE       ConfigurationHandle;

    // Interface info returned from URB_FUNCTION_SELECT_CONFIGURATION
    //
    PUSBD_INTERFACE_INFORMATION     InterfaceInfo;

    // Pointers back into InterfaceInfo for Bulk IN, Bulk OUT, and
    // Interrupt IN pipes.
    //
    PUSBD_PIPE_INFORMATION          BulkInPipe;

    PUSBD_PIPE_INFORMATION          BulkOutPipe;

    PUSBD_PIPE_INFORMATION          InterruptInPipe;

    // Initialized to one in AddDevice.
    // Incremented by one for each pending request.
    // Decremented by one for each pending request.
    // Decremented by one in REMOVE_DEVICE.
    //
    ULONG                           PendingIoCount;

    // Set when PendingIoCount is decremented to zero
    //
    KEVENT                          RemoveEvent;

    // DriverFlags read from regisry
    //
    ULONG                           DriverFlags;

    // NonRemovable read from regisry
    //
    ULONG                           NonRemovable;

    // Various DF_xxxx flags
    //
    ULONG                           DeviceFlags;

    // Various DHF_xxxx flags
    //
    ULONG                           DeviceHackFlags;

    // SpinLock which protects DeviceFlags
    //
    KSPIN_LOCK                      ExtensionDataSpinLock;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by USBSTOR_FdoSetPower(), used by
    // USBSTOR_FdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    // Set when the DevicePowerState >PowerDeviceD0 Irp is ready to be passed
    // down the stack.
    //
    KEVENT                          PowerDownEvent;

    ULONG                           SrbTimeout;

    PIRP                            PendingIrp;

    KEVENT                          CancelEvent;

    // Work Item used to issue Reset Pipe / Reset Port requests at PASSIVE_LEVEL
    //
    PIO_WORKITEM                    IoWorkItem;

    // URB used for ADSC Control Transfer and associated Bulk Transfer.
    // ADSC requests are serialized through StartIo so no need to protect
    // access to this single URB.
    //
    union
    {
        struct _URB_CONTROL_VENDOR_OR_CLASS_REQUEST ControlUrb;
        struct _URB_BULK_OR_INTERRUPT_TRANSFER      BulkIntrUrb;
    } Urb;

    // Original Srb saved here by USBSTOR_StartIo()
    //
    PSCSI_REQUEST_BLOCK             OriginalSrb;

    // Original CDB saved here by USBSTOR_TranslateCDB()
    //
    UCHAR                           OriginalCDB[16];

    union
    {
        // Fields used only for Control/Bulk/Interrupt devices
        //
        struct _CONTROL_BULK_INT
        {
            // Commmand completion interrupt data transferred here
            //
            USHORT                  InterruptData;

            // CDB for issuing a Request Sense when there is an error
            //
            UCHAR                   RequestSenseCDB[12];

            // Buffer for receiving Request Sense sense data when the Srb
            // doesn't have a sense buffer.
            //
            SENSE_DATA              SenseData;

        } Cbi;

        // Fields used only for Bulk Only devices
        //
        struct _BULK_ONLY
        {
            union
            {
                // Command Block Wrapper
                //
                CBW                 Cbw;

                // Command Status Wrapper
                //
                CSW                 Csw;

                // Workaround for USB 2.0 controller Data Toggle / Babble bug
                //
                UCHAR               MaxPacketSize[512];

            } CbwCsw;

            // How many times a STALL is seen trying to retrieve CSW
            //
            ULONG                   StallCount;

            // Srb used by USBSTOR_IssueRequestSense()
            //
            SCSI_REQUEST_BLOCK      InternalSrb;

        } BulkOnly;
    };

    BOOLEAN                         LastSenseWasReset;

    BOOLEAN                         DeviceIsHighSpeed;

} FDO_DEVICE_EXTENSION, *PFDO_DEVICE_EXTENSION;

// Device Extension for the PDO we we enumerate as a child of the FDO
// attached on top of the USB enumerated PDO.
//
typedef struct _PDO_DEVICE_EXTENSION
{
    // USBSTOR_DO_TYPE_PDO
    //
    ULONG                           Type;

    // Back pointer to PDO Device Object to which this Device Extension
    // is attached.
    //
    PDEVICE_OBJECT                  PdoDeviceObject;

    // Parent FDO that enumerated us
    //
    PDEVICE_OBJECT                  ParentFDO;

    // List of child PDOs enumerated from parent FDO
    //
    LIST_ENTRY                      ListEntry;

    // PnP Device State
    //
    DEVICE_STATE                    DeviceState;

    // Current system power state
    //
    SYSTEM_POWER_STATE              SystemPowerState;

    // Current device power state
    //
    DEVICE_POWER_STATE              DevicePowerState;

    // Current power Irp, set by USBSTOR_PdoSetPower(), used by
    // USBSTOR_PdoSetPowerCompletion().
    //
    PIRP                            CurrentPowerIrp;

    BOOLEAN                         Claimed;

    BOOLEAN                         IsFloppy;

    // LUN value which is used in bCBWLUN
    //
    UCHAR                           LUN;

    // Data returned by an Inquiry command.  We are only interested in the
    // first 36 bytes, not the whole 96 bytes.
    //
    UCHAR                           InquiryDataBuffer[INQUIRYDATABUFFERSIZE];

} PDO_DEVICE_EXTENSION, *PPDO_DEVICE_EXTENSION;

//*****************************************************************************
//
// F U N C T I O N    P R O T O T Y P E S
//
//*****************************************************************************

//
// USBMASS.C
//

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  RegistryPath
    );

VOID
USBSTOR_Unload (
    IN PDRIVER_OBJECT   DriverObject
    );

NTSTATUS
USBSTOR_AddDevice (
    IN PDRIVER_OBJECT   DriverObject,
    IN PDEVICE_OBJECT   PhysicalDeviceObject
    );

VOID
USBSTOR_QueryFdoParams (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_Power (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_FdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
USBSTOR_FdoSetPowerD0Completion (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            NotUsed
    );

NTSTATUS
USBSTOR_PdoSetPower (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_PdoSetPowerCompletion(
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            MinorFunction,
    IN POWER_STATE      PowerState,
    IN PVOID            Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
USBSTOR_SystemControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Pnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_GetDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

USBSTOR_GetStringDescriptors (
    IN PDEVICE_OBJECT   DeviceObject
    );

VOID
USBSTOR_AdjustConfigurationDescriptor (
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUSB_CONFIGURATION_DESCRIPTOR   ConfigDesc,
    OUT PUSB_INTERFACE_DESCRIPTOR      *InterfaceDesc,
    OUT PLONG                           BulkInIndex,
    OUT PLONG                           BulkOutIndex,
    OUT PLONG                           InterruptInIndex
    );

NTSTATUS
USBSTOR_GetPipes (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_CreateChildPDO (
    IN PDEVICE_OBJECT   FdoDeviceObject,
    IN UCHAR            Lun
    );

NTSTATUS
USBSTOR_FdoStopDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoCancelStopRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_FdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoStartDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoRemoveDevice (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoQueryID (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

PCHAR
USBSTOR_PdoDeviceTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    );

PCHAR
USBSTOR_PdoGenericTypeString (
    IN  PDEVICE_OBJECT  DeviceObject
    );

VOID
CopyField (
    IN PUCHAR   Destination,
    IN PUCHAR   Source,
    IN ULONG    Count,
    IN UCHAR    Change
    );

NTSTATUS
USBSTOR_StringArrayToMultiSz(
    PUNICODE_STRING MultiString,
    PCSTR           StringArray[]
    );

NTSTATUS
USBSTOR_PdoQueryDeviceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryHardwareIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryCompatibleIds (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryDeviceText (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoBusQueryInstanceId (
    IN  PDEVICE_OBJECT  DeviceObject,
    OUT PUNICODE_STRING UnicodeString
    );

NTSTATUS
USBSTOR_PdoQueryDeviceRelations (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_PdoQueryCapabilities (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_SyncPassDownIrp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_SyncCompletionRoutine (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    );

NTSTATUS
USBSTOR_SyncSendUsbRequest (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PURB             Urb
    );

NTSTATUS
USBSTOR_GetDescriptor (
    IN PDEVICE_OBJECT   DeviceObject,
    IN UCHAR            Recipient,
    IN UCHAR            DescriptorType,
    IN UCHAR            Index,
    IN USHORT           LanguageId,
    IN ULONG            RetryCount,
    IN ULONG            DescriptorLength,
    OUT PUCHAR         *Descriptor
    );

NTSTATUS
USBSTOR_GetMaxLun (
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PUCHAR          MaxLun
    );

NTSTATUS
USBSTOR_SelectConfiguration (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_UnConfigure (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
USBSTOR_ResetPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    );

NTSTATUS
USBSTOR_AbortPipe (
    IN PDEVICE_OBJECT   DeviceObject,
    IN USBD_PIPE_HANDLE Pipe
    );


//
// OCRW.C
//

NTSTATUS
USBSTOR_Create (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Close (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_ReadWrite (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
// SCSI.C
//

NTSTATUS
USBSTOR_DeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

NTSTATUS
USBSTOR_Scsi (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
USBSTOR_TimerTick (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          NotUsed
    );

NTSTATUS
USBSTOR_GetInquiryData (
    IN PDEVICE_OBJECT   DeviceObject
    );

BOOLEAN
USBSTOR_IsFloppyDevice (
    PDEVICE_OBJECT  DeviceObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\drivers\wdm\usb\driver\usbser\debugwdm.c ===
/***************************************************************************

Copyright (c) 1998  Microsoft Corporation

Module Name:

	DEBUGWDM.C

Abstract:

	Debug and diagnostic routines for WDM driver 

Environment:

	Kernel mode only

Notes:

	THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
	KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
	IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
	PURPOSE.

	Copyright (c) 1998 Microsoft Corporation.  All Rights Reserved.


Revision History:

	12/23/97 : created

Author:

	Tom Green

****************************************************************************/


#include <wdm.h>
#include <ntddser.h>
#include <stdio.h>
#include <stdlib.h>
#include <usb.h>
#include <usbdrivr.h>
#include <usbdlib.h>
#include <usbcomm.h>

#ifdef WMI_SUPPORT
#include <wmilib.h>
#include <wmidata.h>
#include <wmistr.h>
#endif

#include "usbser.h"
#include "serioctl.h"
#include "utils.h"
#include "debugwdm.h"

// memory allocation stats
LOCAL  ULONG				MemoryAllocated		= 0L;
LOCAL  ULONG				MemAllocFailCnt		= 0L;
LOCAL  ULONG				MemAllocCnt			= 0L;
LOCAL  ULONG				MemFreeFailCnt		= 0L;
LOCAL  ULONG				MemFreeCnt			= 0L;
LOCAL  ULONG				MaxMemAllocated		= 0L;

// signature to write at end of allocated memory block
#define MEM_ALLOC_SIGNATURE	(ULONG) 'CLLA'

// signature to write at end of freed memory block
#define MEM_FREE_SIGNATURE	(ULONG) 'EERF'


#ifdef PROFILING_ENABLED

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE,Debug_OpenWDMDebug)
#pragma alloc_text(PAGE,Debug_CloseWDMDebug)
#pragma alloc_text(PAGE,Debug_SizeIRPHistoryTable)
#pragma alloc_text(PAGE,Debug_SizeDebugPathHist)
#pragma alloc_text(PAGE,Debug_SizeErrorLog)
#pragma alloc_text(PAGE,Debug_ExtractAttachedDevices)
#pragma alloc_text(PAGE,Debug_GetDriverInfo)
#pragma alloc_text(PAGE,Debug_ExtractIRPHist)
#pragma alloc_text(PAGE,Debug_ExtractPathHist)
#pragma alloc_text(PAGE,Debug_ExtractErrorLog)
#pragma alloc_text(PAGE,Debug_DumpDriverLog)
#pragma alloc_text(PAGE,Debug_TranslateStatus)
#pragma alloc_text(PAGE,Debug_TranslateIoctl)

#endif // ALLOC_PRAGMA



// data structures, macros, and data that the outside world doesn't need to know about

// amount of data to save from IRP buffer
#define IRP_DATA_SIZE		0x04

// size for temporary string formatting buffers
#define TMP_STR_BUFF_SIZE	0x100

// initial number of entries in tables and logs
#define DEFAULT_LOG_SIZE	64L


// data structures for debug stuff

// entry for IRP history table for IRPs going in and out
typedef struct IRPHistory
{
	LARGE_INTEGER			TimeStamp;
	PDEVICE_OBJECT			DeviceObject;
	PIRP					Irp;
	ULONG					MajorFunction;
	ULONG					IrpByteCount;
	UCHAR					IrpData[IRP_DATA_SIZE];
	UCHAR					IrpDataCount;
} IRPHist, *PIRPHist;

// entry for execution tracing
typedef struct PATHHistory
{
	LARGE_INTEGER			TimeStamp;
	PCHAR					Path;
} PATHHist, *PPATHHist;

// entry for error log
typedef struct ERRORLog
{
	LARGE_INTEGER			TimeStamp;
	NTSTATUS				Status;
} ERRLog, *PERRLog;

// this is for translating a code into an ASCII string
typedef struct Code2Ascii
{
	NTSTATUS				Code;
	PCHAR					Str;
} Code2Ascii;


// local data for debug file

// IRP history table components
LOCAL  PIRPHist				IRPHistoryTable		= NULL;
LOCAL  ULONG				IRPHistoryIndex		= 0L;
GLOBAL ULONG				IRPHistorySize		= 0L;

// Debug path storage
LOCAL  PPATHHist	 		DebugPathHist		= NULL;
LOCAL  ULONG		 		DebugPathIndex		= 0L;
GLOBAL ULONG		 		DebugPathSize		= 0L;

// Error log components
LOCAL  PERRLog		 		ErrorLog			= NULL;
LOCAL  ULONG				ErrorLogIndex		= 0L;
GLOBAL ULONG				ErrorLogSize		= 0L;

// this is for translating NT status codes into ASCII strings
LOCAL  Code2Ascii NTErrors[] =
{
	STATUS_SUCCESS,									"STATUS_SUCCESS",
	STATUS_PENDING,									"STATUS_PENDING",
	STATUS_TIMEOUT,									"STATUS_TIMEOUT",
	STATUS_DEVICE_BUSY,								"STATUS_DEVICE_BUSY",
	STATUS_INSUFFICIENT_RESOURCES,					"STATUS_INSUFFICIENT_RESOURCES",
	STATUS_INVALID_DEVICE_REQUEST,					"STATUS_INVALID_DEVICE_REQUEST",
	STATUS_DEVICE_NOT_READY,						"STATUS_DEVICE_NOT_READY",
	STATUS_INVALID_BUFFER_SIZE,						"STATUS_INVALID_BUFFER_SIZE",
	STATUS_INVALID_PARAMETER,						"STATUS_INVALID_PARAMETER",
	STATUS_INVALID_HANDLE,							"STATUS_INVALID_HANDLE",
	STATUS_OBJECT_PATH_NOT_FOUND,					"STATUS_OBJECT_PATH_NOT_FOUND",
	STATUS_BUFFER_TOO_SMALL,						"STATUS_BUFFER_TOO_SMALL",
	STATUS_NOT_SUPPORTED,							"STATUS_NOT_SUPPORTED",
	STATUS_DEVICE_DATA_ERROR,						"STATUS_DEVICE_DATA_ERROR",
	STATUS_CANCELLED,								"STATUS_CANCELLED",
	STATUS_OBJECT_NAME_INVALID,						"STATUS_OBJECT_NAME_INVALID",
	STATUS_OBJECT_NAME_NOT_FOUND,					"STATUS_OBJECT_NAME_NOT_FOUND"
};

LOCAL  ULONG				NumNTErrs = sizeof(NTErrors) / sizeof(Code2Ascii);
LOCAL  CHAR					UnknownStatus[80];

// this is for translating IOCTL codes into ASCII strings
LOCAL  Code2Ascii IoctlCodes[] =
{
	IRP_MJ_CREATE,						"CREATE",
	IRP_MJ_CREATE_NAMED_PIPE,			"CNPIPE",
	IRP_MJ_CLOSE,						"CLOSE ",
	IRP_MJ_READ,						"READ  ",
	IRP_MJ_WRITE,						"WRITE ",
	IRP_MJ_QUERY_INFORMATION,			"QRYINF",
	IRP_MJ_SET_INFORMATION,				"SETINF",
	IRP_MJ_QUERY_EA,					"QRYEA ",
	IRP_MJ_SET_EA,						"SETEA ",
	IRP_MJ_FLUSH_BUFFERS,				"FLSBUF",
	IRP_MJ_QUERY_VOLUME_INFORMATION,	"QRYVOL",
	IRP_MJ_SET_VOLUME_INFORMATION,		"SETVOL",
	IRP_MJ_DIRECTORY_CONTROL,			"DIRCTL",
	IRP_MJ_FILE_SYSTEM_CONTROL,			"SYSCTL",
	IRP_MJ_DEVICE_CONTROL,				"DEVCTL",
	IRP_MJ_INTERNAL_DEVICE_CONTROL,		"INDVCT",
	IRP_MJ_SHUTDOWN,					"SHTDWN",
	IRP_MJ_LOCK_CONTROL,				"LOKCTL",
	IRP_MJ_CLEANUP,						"CLNUP ",
	IRP_MJ_CREATE_MAILSLOT,				"MAILSL",
	IRP_MJ_QUERY_SECURITY,				"QRYSEC",
	IRP_MJ_SET_SECURITY,				"SETSEC",
	IRP_MJ_SYSTEM_CONTROL,              "SYSCTL",
	IRP_MJ_DEVICE_CHANGE,				"DEVCHG",
	IRP_MJ_QUERY_QUOTA,					"QRYQUO",
	IRP_MJ_SET_QUOTA,					"SETQUO",
	IRP_MJ_POWER,						"POWER ",
	IRP_MJ_PNP,							"PNP   ",
	IRP_MJ_MAXIMUM_FUNCTION,			"MAXFNC"
};

LOCAL ULONG					NumIoctl = sizeof(IoctlCodes) / sizeof(Code2Ascii);
LOCAL CHAR					UnknownIoctl[80];


/************************************************************************/
/*						Debug_OpenWDMDebug								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate resources and init history tables and logs.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  VOID																*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_OpenWDMDebug(VOID)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// allocate tables and logs
	NtStatus = Debug_SizeIRPHistoryTable(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}

	NtStatus = Debug_SizeDebugPathHist(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}

	NtStatus = Debug_SizeErrorLog(DEFAULT_LOG_SIZE);
	if(!NT_SUCCESS(NtStatus))
	{
		Debug_CloseWDMDebug();
		return NtStatus;
	}
	
	return NtStatus;	
} // Debug_OpenWDMDebug


/************************************************************************/
/*						Debug_CloseWDMDebug								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Free up resources used for history tables and logs.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  VOID																*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_CloseWDMDebug(VOID)
{
	PAGED_CODE();

	if(DebugPathHist)
	{
		DEBUG_MEMFREE(DebugPathHist);
		DebugPathHist	= NULL;
		DebugPathSize	= 0L;
	}

	if(IRPHistoryTable)
	{
		DEBUG_MEMFREE(IRPHistoryTable);
		IRPHistoryTable	= NULL;
		IRPHistorySize	= 0L;
	}

	if(ErrorLog)
	{
		DEBUG_MEMFREE(ErrorLog);
		ErrorLog		= NULL;
		ErrorLogSize	= 0L;
	}

    Debug_CheckAllocations();

	// see if we have a leak
	DEBUG_ASSERT("Memory Allocation Leak", MemAllocCnt == MemFreeCnt);
} // Debug_CloseWDMDebug


/************************************************************************/
/*						Debug_SizeIRPHistoryTable						*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate IRP history table											*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in table									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeIRPHistoryTable(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == IRPHistorySize)
		return NtStatus;

	// get rid of old history table if we got one
	if(IRPHistoryTable)
		DEBUG_MEMFREE(IRPHistoryTable);

	IRPHistoryTable	= NULL;
	IRPHistoryIndex	= 0L;
	IRPHistorySize	= 0L;

	if(Size != 0L)
	{
		IRPHistoryTable = DEBUG_MEMALLOC(NonPagedPool, sizeof(IRPHist) * Size);
		if(IRPHistoryTable == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(IRPHistoryTable, sizeof(IRPHist) * Size);
			IRPHistorySize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeIRPHistoryTable


/************************************************************************/
/*						Debug_SizeDebugPathHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate path history												*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in history									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeDebugPathHist(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == DebugPathSize)
		return NtStatus;

	// get rid of old path history if we got one
	if(DebugPathHist)
		DEBUG_MEMFREE(DebugPathHist);

	DebugPathHist	= NULL;
	DebugPathIndex	= 0L;
	DebugPathSize	= 0L;

	if(Size != 0L)
	{
		DebugPathHist = DEBUG_MEMALLOC(NonPagedPool, sizeof(PATHHist) * Size);
		if(DebugPathHist == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(DebugPathHist, sizeof(PATHHist) * Size);
			DebugPathSize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeDebugPathHist


/************************************************************************/
/*						Debug_SizeErrorLog								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Allocate error log													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Size - number of entries in error log								*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	NTSTATUS															*/
/*																		*/
/************************************************************************/
NTSTATUS
Debug_SizeErrorLog(IN ULONG Size)
{
	NTSTATUS		NtStatus = STATUS_SUCCESS;

	PAGED_CODE();

	// see if they are trying to set the same size
	if(Size == ErrorLogSize)
		return NtStatus;

	// get rid of old error log if we got one
	if(ErrorLog)
		DEBUG_MEMFREE(ErrorLog);
	ErrorLog		= NULL;
	ErrorLogIndex	= 0L;
	ErrorLogSize	= 0L;

	if(Size != 0L)
	{
		ErrorLog = DEBUG_MEMALLOC(NonPagedPool, sizeof(ERRLog) * Size);
		// make sure we actually allocated some memory
		if(ErrorLog == NULL)
			NtStatus = STATUS_INSUFFICIENT_RESOURCES;
		else
		{
			RtlZeroMemory(ErrorLog, sizeof(ERRLog) * Size);
			ErrorLogSize = Size;
		}
	}

	return NtStatus;
} // Debug_SizeErrorLog


/************************************************************************/
/*						Debug_LogIrpHist								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs IRP history. These are timestamped and put in a				*/
/*  circular buffer for extraction later.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  DeviceObject  - pointer to device object.							*/
/*  Irp           - pointer to IRP.										*/
/*  MajorFunction - major function of IRP.								*/
/*  IoBuffer      - buffer for data passed in and out of driver.		*/
/*  BufferLen     - length of data buffer.								*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogIrpHist(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp,
				 IN ULONG MajorFunction, IN PVOID IoBuffer, IN ULONG BufferLen)
{
	PIRPHist IrpHist;
	
	// get pointer to current entry in IRP history table
	IrpHist = &IRPHistoryTable[IRPHistoryIndex++];
	
	// point to the next entry in the IRP history table
	IRPHistoryIndex %= IRPHistorySize;

	// get time stamp
	IrpHist->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save IRP, device object, major function and first 8 bytes of data in buffer
	IrpHist->DeviceObject = DeviceObject;
	IrpHist->Irp = Irp;
	IrpHist->MajorFunction = MajorFunction;

	// copy any data if we have it
	IrpHist->IrpByteCount = BufferLen;
	IrpHist->IrpDataCount = (UCHAR) min(IRP_DATA_SIZE, BufferLen);
	if(BufferLen)
		*(ULONG *) IrpHist->IrpData = *(ULONG *) IoBuffer;
} // Debug_LogIrpHist


/************************************************************************/
/*						Debug_LogPath									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs execution path through code. These are timestamped and put		*/
/*  in a circular buffer for extraction later. Kernel print routines 	*/
/*  are also called.													*/
/*																		*/
/*  DANGER DANGER Will Robinson - the argument to this must be a 		*/
/*  const char pointer,													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  Path - Pointer to const char array that contains description of	*/
/*          of path.													*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogPath(IN CHAR *Path)
{
	PPATHHist	PHist;

	// get pointer to current entry in path history
	PHist = &DebugPathHist[DebugPathIndex++];

	// point to the next entry in path trace
	DebugPathIndex %= DebugPathSize;

	// get time stamp
	PHist->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save path string
	PHist->Path = Path;

	// now call kernel print routines
	DEBUG_TRACE2(("%s\n", Path));
} // Debug_LogPath


/************************************************************************/
/*						Debug_LogError									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Logs NTSTATUS type errors. These are timestamped and put in a		*/
/*  circular buffer for extraction later.								*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  NtStatus - NTSTATUS error to log.									*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_LogError(IN NTSTATUS NtStatus)
{
	PERRLog	ErrLog;

	// no error, so don't log
	if(NtStatus == STATUS_SUCCESS)
		return;

	// get pointer to current entry in error log
	ErrLog = &ErrorLog[ErrorLogIndex++];

	// point to the next entry in error log
	ErrorLogIndex %= ErrorLogSize;

	// get time stamp
	ErrLog->TimeStamp = KeQueryPerformanceCounter(NULL);

	// save status
	ErrLog->Status = NtStatus;
} // Debug_LogError


/************************************************************************/
/*						Debug_Trap										*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Trap. Causes execution to halt after logging message.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  TrapCause - pointer to char array that contains description			*/
/*				 of cause of trap.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_Trap(IN PCHAR TrapCause)
{
	// log the path
	DEBUG_LOG_PATH("Debug_Trap: ");

	DEBUG_LOG_PATH(TrapCause);

	// kernel debugger print
	DEBUG_TRACE3(("Debug_Trap: "));

	DEBUG_TRACE3(("%s\n",TrapCause));

	// halt execution
	DEBUG_TRAP();
} // Debug_TRAP


/************************************************************************/
/*						Debug_Assert									*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Assertion routine.													*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*  This should not be called directly. Use DEBUG_ASSERT macro.			*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	VOID																*/
/*																		*/
/************************************************************************/
VOID
Debug_Assert(IN PVOID FailedAssertion, IN PVOID FileName, IN ULONG LineNumber,
			 IN PCHAR Message)
{
#if DBG
	// just call the assert routine
    RtlAssert(FailedAssertion, FileName, LineNumber, Message);
#else
	DEBUG_TRAP();
#endif
} // Debug_Assert



/************************************************************************/
/*						Debug_ExtractAttachedDevices					*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places attached device info into a buffer.				*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	DriverObject  - pointer to driver object.							*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of Buffer.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractAttachedDevices(IN PDRIVER_OBJECT DriverObject, OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR				StrBuff;
	PDEVICE_EXTENSION	DeviceExtension;
	PDEVICE_OBJECT		DeviceObject;
	BOOLEAN				Dev = FALSE;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nAttached Devices\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// columns	
	sprintf(StrBuff, "Device              Device Obj  IRPs Complete   Byte Count\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// get the first device object
	DeviceObject = DriverObject->DeviceObject;

	// march through linked list of devices
	while(DeviceObject)
	{
		// found at least one device
		Dev = TRUE;

		// Get a pointer to the device extension
		DeviceExtension = DeviceObject->DeviceExtension;
		sprintf(StrBuff, "%-17s   0x%p  0x%08X      0x%08X%08X\n", &DeviceExtension->LinkName[12],
				DeviceObject, DeviceExtension->IRPCount,
				DeviceExtension->ByteCount.HighPart,
				DeviceExtension->ByteCount.LowPart);

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);

		DeviceObject = DeviceObject->NextDevice;
	}

	// if we don't have any devices, say so, but this should never happen (I think)
	if(!Dev)
	{
		sprintf(StrBuff, "No attached devices\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);
} // Debug_ExtractAttachedDevices

/************************************************************************/
/*						Debug_GetDriverInfo								*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places driver info into a buffer.						*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer        - pointer to buffer to fill with IRP history.			*/
/*  BuffSize      - size of Buffer.										*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_GetDriverInfo(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	PCHAR				StrBuff;

	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// driver name and version
	sprintf(StrBuff, "\n\n\nDriver:	 %s\n\nVersion: %s\n\n", DriverName, DriverVersion);

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	DEBUG_MEMFREE(StrBuff);
	return strlen(Buffer);	
} // Debug_GetDriverInfo


/************************************************************************/
/*						Debug_ExtractIRPHist							*/
/************************************************************************/
/*																		*/
/* Routine Description:													*/
/*																		*/
/*  Formats and places IRP history info into a buffer.					*/
/*																		*/
/* Arguments:															*/
/*																		*/
/*	Buffer   - pointer to buffer to fill with IRP history.				*/
/*  BuffSize - size of Buffer.											*/
/*																		*/
/* Return Value:														*/
/*																		*/
/*	ULONG - number of bytes written in buffer.							*/
/*																		*/
/************************************************************************/
ULONG
Debug_ExtractIRPHist(OUT PCHAR Buffer, IN ULONG BuffSize)
{
	ULONG		Index, Size;
	PIRPHist	IrpHist;
	PCHAR		StrBuff;
	BOOLEAN		Hist = FALSE;
	
	PAGED_CODE();

	// make sure we have a pointer and a number of bytes
	if(Buffer == NULL || BuffSize == 0L)
		return 0L;

	// allocate buffer for formatting strings
	StrBuff = DEBUG_MEMALLOC(NonPagedPool, TMP_STR_BUFF_SIZE);

	if(StrBuff == NULL)
		return 0L;

	// title
	sprintf(StrBuff, "\n\n\nIRP History\n\n");

	// make sure it fits in buffer
	if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
		strcat(Buffer, StrBuff);

	// see if error log is on
	if(IRPHistorySize == 0L)
	{
		sprintf(StrBuff, "IRP History is disabled\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);
	}
	else
	{
		// columns	
		sprintf(StrBuff, "Time Stamp          Device Obj  IRP         Func    Byte Count  Data\n\n");

		// make sure it fits in buffer
		if((strlen(Buffer) + strlen(StrBuff)) < BuffSize)
			strcat(Buffer, StrBuff);

		Index = IRPHistoryIndex;

		for(Size = 0; Size < IRPHistorySize; Size++)
		{
			// get pointer to current entry in IRP history table
			IrpHist = &IRPHistoryTable[Index++];

			// parse timestamp and IRP history and write to buffer
			if(IrpHist->TimeStamp.LowPart)
			{
				UCHAR	DataCount;
				CHAR	DataBuff[10];

				// we have at least one entry
				Hist = TRUE;

				sprintf(StrBuff, "0x%08X%08X  0x%p  0x%p  %s  0x%08X  ",
						IrpHist->TimeStamp.HighPart, IrpHist->TimeStamp.LowPart,
						IrpHist->DeviceObject, IrpHist->Irp,
						Debug_TranslateIoctl(IrpHist->MajorFunction),
						IrpHist->IrpByteCount);


				// add data bytes if we got 