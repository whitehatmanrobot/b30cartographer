_ProblemCode)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_HasProblem)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsDisabled)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsRunning)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_CharacteristicsOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CharacteristicsOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_ForceExclusive)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_ForceExclusive)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_DeviceTypeOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_DeviceTypeOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Security)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Security)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_EnumeratorName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_LowerFilters)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_LowerFilters)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_UpperFilters)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_UpperFilters)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_LocationInformation)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_LocationInformation)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_FriendlyName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_FriendlyName)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_Class)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_ServiceName)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get_CompatibleIds)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CompatibleIds)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_HardwareIds)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_HardwareIds)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_RebootRequired)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_RebootRequired)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Restart)();
	STDMETHOD(Stop)();
	STDMETHOD(Start)();
	STDMETHOD(Disable)();
	STDMETHOD(Enable)();
	STDMETHOD(Delete)();

	//
	// helpers
	//
	HRESULT TranslatePropVal(LPVARIANT var,DWORD * val);
	HRESULT CheckNoReboot();
	HDEVINFO GetDevInfoSet();
	HRESULT SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *keyval,BOOL writeable);
	BOOL SameAs(CDevice *pOther);
	BOOL SameAs(LPWSTR str);
	STDMETHOD(get_InstanceId)(/*[out, retval]*/ BSTR *pVal);
	HRESULT GetRemoteMachine(HANDLE *hMachine);
	HRESULT PutDevicePropertyMultiSz(DWORD prop,VARIANT *pVal);
	HRESULT PutDevicePropertyDword(DWORD prop,VARIANT *pVal);
	HRESULT PutDevicePropertyString(DWORD prop,VARIANT *pVal);
	HRESULT GetDeviceProperty(DWORD prop,VARIANT *pVal);

};

#endif //__DEVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devcon2.cpp ===
// DevCon2.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for DevCon2.idl by adding the following
//      files to the Outputs.
//          DevCon2_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f DevCon2ps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DevCon2.h"
#include "dlldatax.h"

#include "DevCon2_i.c"
#include "DeviceConsole.h"
#include "Devices.h"
#include "xStrings.h"
#include "SetupClasses.h"
#include "DeviceIcon.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CMyModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DeviceConsole, CDeviceConsole)
OBJECT_ENTRY(CLSID_Devices, CDevices)
OBJECT_ENTRY(CLSID_Strings, CStrings)
OBJECT_ENTRY(CLSID_SetupClasses, CSetupClasses)
OBJECT_ENTRY(CLSID_DeviceIcon, CDeviceIcon)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DEVCON2Lib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    //
    // DCOM support - App registration via IDR_DEVCON2
    //
    _Module.UpdateRegistryFromResource(IDR_DEVCON2, TRUE);
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    //
    // DCOM support - App cleanup via IDR_DEVCON2
    //
    _Module.UpdateRegistryFromResource(IDR_DEVCON2, FALSE);
    return _Module.UnregisterServer(TRUE);
}

//
// DCOM support, allow this DLL to also run as local server
// once the server is running, it needs to cleanup after a short period of time
//
const DWORD dwTimeOut = 5000; // time for server to be idle before shutting down

static void CALLBACK ModuleTimer(HWND /*hWnd*/,UINT /*uMsg*/,UINT_PTR /*idEvent*/,DWORD /*dwTime*/)
{
    _Module.CheckShutdown();
}

LONG CMyModule::Unlock()
{
    LONG l = CComModule::Unlock();
    //ATLTRACE("Unlock = %u\n",l);
    if (bServer && (l <= (punkFact ? 1 : 0)))
    {
        //
        // DCOM server
        // as soon as lock count reaches 1 (punkFact), timer is reset
        // if timer times out and lock count is still 1
        // then we can kill the server
        //
        SetTimer(NULL,0,dwTimeOut,ModuleTimer);
    }
    return l;
}

void CMyModule::KillServer()
{
    if(bServer) {
        //
        // make it a server no longer
        //
        CoRevokeClassObject(dwROC);
        bServer = FALSE;
    }
    if(punkFact) {
        punkFact->Release();
        punkFact = NULL;
    }
    if(m_nLockCnt != 0) {
        DebugBreak();
    }
}

void CMyModule::CheckShutdown()
{
    if(m_nLockCnt>(punkFact ? 1 : 0)) {
        //
        // module is still in use
        //
        return;
    }
    //
    // lock count stayed at zero for dwTimeOut ms
    //
    KillServer();
    PostMessage(NULL, WM_QUIT, 0, 0);
}

HRESULT CMyModule::InitServer(GUID & ClsId)
{
    HRESULT hr;

    hr = DllGetClassObject(ClsId, IID_IClassFactory, (LPVOID*)&punkFact);
    if(FAILED(hr)) {
        return hr;
    }
    hr = CoRegisterClassObject(ClsId, punkFact, CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE, &dwROC);
    if(FAILED(hr)) {
        punkFact->Release();
        punkFact = NULL;
        return hr;
    }
    bServer = true;

    return S_OK;
}

void WINAPI CreateLocalServerW(HWND /*hwnd*/, HINSTANCE /*hAppInstance*/, LPWSTR pszCmdLine, int /*nCmdShow*/)
{
    GUID ClsId;
    HRESULT hr;
    LPWSTR dup;
    LPWSTR p;
    size_t len;
    MSG msg;

    hr = CoInitialize(NULL);
    if(FAILED(hr)) {
        return;
    }

    //
    // pszCmdLine = the class GUID we want factory for
    //
    p = wcschr(pszCmdLine,'{');
    if(!p) {
        goto final;
    }
    pszCmdLine = p;
    p = wcschr(pszCmdLine,'}');
    if(!p) {
        goto final;
    }
    len = p-pszCmdLine+1;
    dup = new WCHAR[len+1];
    if(!dup) {
        goto final;
    }
    wcsncpy(dup,pszCmdLine,len+1);
    dup[len] = '\0';
    hr = CLSIDFromString(dup,&ClsId);
    delete [] dup;

    if(FAILED(hr)) {
        goto final;
    }
    hr = _Module.InitServer(ClsId);
    if(FAILED(hr)) {
        goto final;
    }

    //
    // now go into dispatch loop until we get a quit message
    //
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    _Module.KillServer();

final:
    CoUninitialize();
}


#ifdef _M_IA64

//$WIN64: Don't know why _WndProcThunkProc isn't defined

extern "C" LRESULT CALLBACK _WndProcThunkProc(HWND, UINT, WPARAM, LPARAM )
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\deviceconsole.cpp ===
// DeviceConsole.cpp : Implementation of CDeviceConsole
#include "stdafx.h"
#include "DevCon2.h"
#include "DeviceConsole.h"
#include "Devices.h"
#include "SetupClasses.h"
#include "xStrings.h"
#include "utils.h"

#include <dbt.h>

/////////////////////////////////////////////////////////////////////////////
// CDeviceConsole

//
// a window is used for events to ensure that we dispatch the events
// within the same apartment as the DeviceConsole object
//

LRESULT CDevConNotifyWindow::OnDeviceChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;
    switch(wParam) {
    case DBT_DEVNODES_CHANGED:
        //
        // post this so we don't block sender
        //
        PostMessage(UM_POSTGLOBALEVENT,wParam);
        return TRUE;
    default: ;
    }
    return ret;
}

LRESULT CDevConNotifyWindow::OnPostGlobalEvent(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;

    //
    // defer this global event to CDeviceConsole
    //
    if(m_pDevCon) {
        m_pDevCon->FireGlobalEvent(wParam);
    }

    return ret;
}

LRESULT CDevConNotifyWindow::OnPostEvents(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    LRESULT ret = TRUE;
    bHandled = TRUE;

    //
    // handle all the pending events
    //

    return ret;
}

STDMETHODIMP CDeviceConsole::AllDevices(VARIANT flags, VARIANT machine, LPDISPATCH *pDevices)
{
    CComVariant m;
    DWORD diflags = 0;
    HRESULT hr;
    LPCWSTR pMachine;
    HDEVINFO hDevInfo;

    *pDevices = NULL;

    hr = TranslateDeviceFlags(&flags,&diflags);
    if(FAILED(hr)) {
        return hr;
    }
    diflags |= DIGCF_ALLCLASSES;
    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hDevInfo = SetupDiGetClassDevsEx(NULL,NULL,NULL,diflags,NULL,pMachine,NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        DWORD Err = GetLastError();
        return  HRESULT_FROM_SETUPAPI(Err);
    }
    return BuildDeviceList(hDevInfo,pDevices);
}

HRESULT CDeviceConsole::BuildDeviceList(HDEVINFO hDevInfo,LPDISPATCH *pDevices)
{
    *pDevices = NULL;

    HRESULT hr;
    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    CComPtr<IDevices> dPtr = d;
    hr = d->Init(hDevInfo,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pDevices = dPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::CreateEmptyDeviceList(VARIANT machine, LPDISPATCH *pDevices)
{
    CComVariant machine_v;
    LPCWSTR pMachine;
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hr = GetOptionalString(&machine,machine_v,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hDevInfo = SetupDiCreateDeviceInfoListEx(NULL,
                                              NULL,
                                              pMachine,
                                              NULL);
    if(hDevInfo != INVALID_HANDLE_VALUE) {
        return BuildDeviceList(hDevInfo,pDevices);
    }
    Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);
}

typedef BOOL (WINAPI *UpdateDriverForPlugAndPlayDevicesProtoW)(HWND hwndParent,
                                                         LPCWSTR HardwareId,
                                                         LPCWSTR FullInfPath,
                                                         DWORD InstallFlags,
                                                         PBOOL bRebootRequired OPTIONAL
                                                         );

#define UPDATEDRIVERFORPLUGANDPLAYDEVICESW "UpdateDriverForPlugAndPlayDevicesW"

STDMETHODIMP CDeviceConsole::UpdateDriver(BSTR infname, BSTR hwid, VARIANT op_flags)
{
    HMODULE newdevMod = NULL;
    UpdateDriverForPlugAndPlayDevicesProtoW UpdateFnW;
    BOOL reboot = FALSE;
    DWORD flags = 0;
    WCHAR InfPath[MAX_PATH];
    HRESULT hr;
    CComVariant flags_v;

    //
    // op_flags are optional
    //

    if(V_VT(&op_flags)!=VT_ERROR) {
        hr = flags_v.ChangeType(VT_BSTR,&op_flags);
        if(FAILED(hr)) {
            return hr;
        }
        flags = V_I4(&flags_v);
    } else if (V_ERROR(&op_flags) != DISP_E_PARAMNOTFOUND) {
        hr = V_ERROR(&op_flags);
        return hr;
    }

    //
    // Inf must be a full pathname
    //
    if(GetFullPathName(infname,MAX_PATH,InfPath,NULL) >= MAX_PATH) {
        //
        // inf pathname too long
        //
        return E_INVALIDARG;
    }

    //
    // make use of UpdateDriverForPlugAndPlayDevices
    //
    newdevMod = LoadLibrary(TEXT("newdev.dll"));
    if(!newdevMod) {
        goto final;
    }
    UpdateFnW = (UpdateDriverForPlugAndPlayDevicesProtoW)GetProcAddress(newdevMod,UPDATEDRIVERFORPLUGANDPLAYDEVICESW);
    if(!UpdateFnW)
    {
        goto final;
    }

    if(!UpdateFnW(NULL,hwid,InfPath,flags,&reboot)) {
        DWORD Err = GetLastError();
        hr = HRESULT_FROM_SETUPAPI(Err);
        goto final;
    }
    if(reboot) {
        RebootRequired = VARIANT_TRUE;
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }


final:

    if(newdevMod) {
        FreeLibrary(newdevMod);
    }

    return hr;
}

STDMETHODIMP CDeviceConsole::CheckReboot()
{
    WCHAR RebootText[MAX_PATH];
    WCHAR RebootCaption[MAX_PATH];

    if(!RebootRequired) {
        return S_OK;
    }
    int str = LoadString(GetModuleHandle(NULL),IDS_REBOOTREQ,RebootText,MAX_PATH);
    if(!str) {
        return E_UNEXPECTED;
    }
    str = LoadString(GetModuleHandle(NULL),IDS_REBOOTCAP,RebootCaption,MAX_PATH);
    if(!str) {
        return E_UNEXPECTED;
    }

    MessageBeep(MB_ICONSTOP);
    int mb = MessageBox(NULL,RebootText,RebootCaption,MB_YESNO|MB_ICONSTOP);
    if(mb == IDOK) {
        return RebootReasonHardware();
    }
    return S_FALSE;
}

STDMETHODIMP CDeviceConsole::RebootReasonHardware()
{
    HANDLE Token;
    TOKEN_PRIVILEGES NewPrivileges;
    LUID Luid;

    //
    // On WinNT, need to "turn on" reboot privilege
    // if any of this fails, try reboot anyway
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
        goto final;
    }

    if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
        CloseHandle(Token);
        goto final;
    }

    NewPrivileges.PrivilegeCount = 1;
    NewPrivileges.Privileges[0].Luid = Luid;
    NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    AdjustTokenPrivileges(
            Token,
            FALSE,
            &NewPrivileges,
            0,
            NULL,
            NULL
            );

    CloseHandle(Token);

final:

    //
    // attempt reboot - inform system that this is planned hardware install
    //
    return ExitWindowsEx(EWX_REBOOT, REASON_PLANNED_FLAG|REASON_HWINSTALL) ? S_OK : E_UNEXPECTED;
}

STDMETHODIMP CDeviceConsole::get_RebootRequired(VARIANT_BOOL *pVal)
{
    *pVal = RebootRequired ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDeviceConsole::put_RebootRequired(VARIANT_BOOL newVal)
{
    RebootRequired = newVal ? VARIANT_TRUE : VARIANT_FALSE;

    return S_OK;
}

STDMETHODIMP CDeviceConsole::SetupClasses(VARIANT classList, VARIANT machine, LPDISPATCH *pDevices)
{
    *pDevices = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    CComObject<CSetupClasses> *d;
    hr = CComObject<CSetupClasses>::CreateInstance(&d);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> dPtr = d;
    hr = d->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    if(IsBlankString(&classList)) {
        hr = d->AllClasses();
    } else {
        hr = d->Add(classList);
    }
    if(FAILED(hr)) {
        return hr;
    }
    *pDevices = dPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::CreateEmptySetupClassList(VARIANT machine, LPDISPATCH *pResult)
{
    *pResult = NULL;

    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    CComObject<CSetupClasses> *d;
    hr = CComObject<CSetupClasses>::CreateInstance(&d);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> dPtr = d;
    hr = d->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pResult = dPtr.Detach();
    return S_OK;
}


STDMETHODIMP CDeviceConsole::DevicesBySetupClasses(VARIANT SetupClasses, VARIANT flags, VARIANT machine, LPDISPATCH *pDevices)
{
    *pDevices = NULL;

    CComObject<CSetupClasses> *pClasses = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;

    //
    // shorthand for initializing class collection
    // to get devices
    //
    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }
    hr = CComObject<CSetupClasses>::CreateInstance(&pClasses);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<ISetupClasses> pClassesPtr = pClasses;
    hr = pClasses->Init(pMachine,this);
    if(FAILED(hr)) {
        return hr;
    }
    hr = pClasses->Add(SetupClasses);
    if(FAILED(hr)) {
        return hr;
    }
    hr = pClasses->Devices(flags,pDevices);
    return hr;
}

STDMETHODIMP CDeviceConsole::DevicesByInterfaceClasses(VARIANT InterfaceClasses, VARIANT machine, LPDISPATCH *pDevicesOut)
{
    *pDevicesOut = NULL;

    //
    // similar to above, but for interface classes
    //
    CComObject<CStrings> *pStrings = NULL;
    CComObject<CDevices> *pDevices = NULL;
    CComVariant m;
    HRESULT hr;
    LPCWSTR pMachine;
    HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HDEVINFO hPrevDevInfo = NULL;
    DWORD Err;
    DWORD c;
    BSTR str;

    hr = GetOptionalString(&machine,m,&pMachine);
    if(FAILED(hr)) {
        return hr;
    }

    hr = CComObject<CStrings>::CreateInstance(&pStrings);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IStrings> pStringsPtr = pStrings;

    hr = pStrings->Add(InterfaceClasses);
    if(FAILED(hr)) {
        return hr;
    }

    for(c=0;pStrings->InternalEnum(c,&str);c++) {
        //
        // convert string to interface
        //
        GUID guid;
        hr = CLSIDFromString(str,&guid);
        if(FAILED(hr)) {
            return hr;
        }
        //
        // query present devices of interface
        //
        hDevInfo = SetupDiGetClassDevsEx(&guid,NULL,NULL,DIGCF_DEVICEINTERFACE|DIGCF_PRESENT,hPrevDevInfo,pMachine,NULL);
        if(hDevInfo == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            if(hPrevDevInfo) {
                SetupDiDestroyDeviceInfoList(hPrevDevInfo);
            }
            return HRESULT_FROM_SETUPAPI(Err);
        }
        hPrevDevInfo = hDevInfo;
    }
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        return E_INVALIDARG;
    }
    //
    // now build resultant list
    //

    hr = CComObject<CDevices>::CreateInstance(&pDevices);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    CComPtr<IDevices> pDevicesPtr = pDevices;
    hr = pDevices->Init(hDevInfo,this);
    if(FAILED(hr)) {
        return hr;
    }
    *pDevicesOut = pDevicesPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::DevicesByInstanceIds(VARIANT InstanceIdList, VARIANT machine, LPDISPATCH *pDevices)
{
    //
    // shorthand for CreateEmptyDeviceList followed by Add
    //
    HRESULT hr;
    LPDISPATCH Devices = NULL;
    CComQIPtr<IDevices> pIf;
    hr = CreateEmptyDeviceList(machine,&Devices);
    if(FAILED(hr)) {
        return hr;
    }
    pIf = Devices;
    if(!pIf) {
        return E_UNEXPECTED;
    }
    hr = pIf->Add(InstanceIdList);
    if(FAILED(hr)) {
        Devices->Release();
        return hr;
    }
    *pDevices = Devices;
    return S_OK;
}

STDMETHODIMP CDeviceConsole::StringList(VARIANT from, LPDISPATCH *pDest)
{
    //
    // convinience only
    //
    *pDest = NULL;
    HRESULT hr;
    CComObject<CStrings> *pStrings = NULL;
    hr = CComObject<CStrings>::CreateInstance(&pStrings);
    if(FAILED(hr)) {
        return hr;
    }
    CComPtr<IStrings> pStringsPtr = pStrings;

    if(!IsNoArg(&from)) {
        hr = pStrings->Add(from);
        if(FAILED(hr)) {
            return hr;
        }
    }
    *pDest = pStringsPtr.Detach();
    return S_OK;
}

STDMETHODIMP CDeviceConsole::AttachEvent(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk)
{
    *pOk = VARIANT_FALSE;
    if(!NotifyWindow()) {
        return E_OUTOFMEMORY;
    }
    return m_Events.AttachEvent(eventName,handler,pOk);
}

STDMETHODIMP CDeviceConsole::DetachEvent(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk)
{
    return m_Events.DetachEvent(eventName,handler,pOk);
}

CDevConNotifyWindow *CDeviceConsole::NotifyWindow()
{
    if(m_pNotifyWindow) {
        return m_pNotifyWindow;
    }
    m_pNotifyWindow = new CDevConNotifyWindow;
    if(!m_pNotifyWindow) {
        return NULL;
    }
    m_pNotifyWindow->m_pDevCon = this;
    RECT nil;
    nil.top = 0;
    nil.left = 0;
    nil.bottom = 8;
    nil.right = 8;
    if(!m_pNotifyWindow->Create(NULL,nil,NULL)) {
        delete m_pNotifyWindow;
        m_pNotifyWindow = NULL;
        return NULL;
    }
    return m_pNotifyWindow;
}

void CDeviceConsole::FireGlobalEvent(WPARAM wParam)
{
    switch(wParam) {
    case DBT_DEVNODES_CHANGED:
        m_Events.Invoke(L"OnDeviceNodesChanged",0,NULL);
        break;
    }
}


HRESULT CEventsDispEntry::AttachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    try {
        *pStatus = VARIANT_FALSE;
        push_back(pDisp);
        *pStatus = VARIANT_TRUE;
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return S_OK;
}

HRESULT CEventsDispEntry::DetachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    try {
        *pStatus = VARIANT_FALSE;
        remove(pDisp);
        *pStatus = VARIANT_TRUE;
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return S_OK;
}

HRESULT CEventsDispEntry::Invoke(UINT argc,VARIANT *argv)
{
    CEventsDispEntry::iterator i;
    for(i = begin();i != end();i++) {
        i->Invoke(argc,argv);
    }
    return S_OK;
}

CEventsDispEntry & CEventsMap::LookupNc(LPWSTR Name) throw(std::bad_alloc)
{
    HRESULT hr;
    size_t len = wcslen(Name)+1;
    wchar_t *pBuffer = new wchar_t[len+1];
    if(!pBuffer) {
        throw std::bad_alloc();
    }
    wcscpy(pBuffer,Name);
    _wcsupr(pBuffer);
    std::wstring ind = pBuffer;
    delete [] pBuffer;
    return (*this)[ind];
}

HRESULT CEventsMap::AttachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    HRESULT hr;
    try {
        *pStatus = VARIANT_FALSE;
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.AttachEvent(pDisp,pStatus);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT CEventsMap::DetachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus)
{
    HRESULT hr;
    try {
        *pStatus = VARIANT_FALSE;
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.DetachEvent(pDisp,pStatus);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }

    return hr;
}

HRESULT CEventsMap::Invoke(LPWSTR Name,UINT argc,VARIANT *argv)
{
    HRESULT hr;
    try {
        CEventsDispEntry &Ent = LookupNc(Name);
        hr = Ent.Invoke(argc,argv);
    } catch(std::bad_alloc) {
        return E_OUTOFMEMORY;
    } catch(...) {
        return E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\deviceicon.cpp ===
// DeviceIcon.cpp : Implementation of CDeviceIcon

#include "stdafx.h"
#include "DevCon2.h"
#include "DeviceIcon.h"
#include "Device.h"
#include "SetupClass.h"

/////////////////////////////////////////////////////////////////////////////
// CDeviceIcon

//
// SetupDiLoadClassIcon(guid,&hIcon,&miniicon)
// SetupDiDrawMiniIcon(....)
//

void CDeviceIcon::ResetIcon()
{
	if(m_hIcon) {
		DestroyIcon(m_hIcon);
		m_hIcon = NULL;
	}
	if(m_hSmallImage) {
		DeleteObject(m_hSmallImage);
		m_hSmallImage = NULL;
	}
	if(m_hSmallMask) {
		DeleteObject(m_hSmallMask);
		m_hSmallMask = NULL;
	}
}

HRESULT CDeviceIcon::OnDraw(ATL_DRAWINFO& di)
{
	if(!m_hIcon) {
		return S_OK;
	}
	RECT rect = *(RECT*)di.prcBounds;
	int asp_x;
	int asp_y;
	int asp;
	asp_x = rect.right-rect.left;
	asp_y = rect.bottom-rect.top;
	asp = min(asp_x,asp_y);
	if(asp>=32) {
		asp = 32;
	} else {
		asp = 16;
	}
	rect.left += (asp_x-asp)/2;
	rect.top += (asp_y-asp)/2;
	rect.right = rect.left+asp;
	rect.bottom = rect.top+asp;

	if(asp == 16) {
		//
		// draw mini-icon
		// this is complex because of the way SetupDiDrawMiniIcon works
		// and we want this to be like a real icon when placed on a web page
		//
		DrawMiniIcon(di.hdcDraw,rect,m_MiniIcon);
	} else {
		//
		// draw regular icon
		//
		DrawIcon(di.hdcDraw,rect.left,rect.top,m_hIcon);
	}

	return S_OK;
}


BOOL CDeviceIcon::DrawMiniIcon(HDC hDC, RECT &rect,INT icon)
{
    HBITMAP hbmOld;
    HDC     hdcMem;

	hdcMem = CreateCompatibleDC(hDC);
	if(!hdcMem) {
		return FALSE;
	}
	if(!(m_hSmallImage && m_hSmallMask)) {
		//
		// create bitmaps (once)
		//
		if(!m_hSmallImage) {
			m_hSmallImage = CreateCompatibleBitmap(hDC,rect.right-rect.left,rect.bottom-rect.top);
			if(!m_hSmallImage) {
				DeleteDC(hdcMem);
				return FALSE;
			}
		}
		if(!m_hSmallMask) {
			m_hSmallMask = CreateBitmap(rect.right-rect.left,rect.bottom-rect.top,1,1,NULL);
			if(!m_hSmallMask) {
				DeleteDC(hdcMem);
				return FALSE;
			}
		}
		//
		// obtain the bitmap data (once)
		//
		RECT memRect;
		memRect.left = memRect.top = 0;
		memRect.right = rect.right-rect.left;
		memRect.bottom = rect.bottom-rect.top;
		//
		// mask first
		//
		hbmOld = (HBITMAP)SelectObject(hdcMem,m_hSmallMask);
		SetupDiDrawMiniIcon(hdcMem,memRect,icon,DMI_USERECT|DMI_MASK);
		//
		// now source
		//
		SelectObject(hdcMem,m_hSmallImage);
		SetupDiDrawMiniIcon(hdcMem,memRect,icon,DMI_USERECT);
	} else {
		//
		// select source
		//
		hbmOld = (HBITMAP)SelectObject(hdcMem,m_hSmallImage);
	}	

	//
	// now blt image via mask
	//
	if(GetDeviceCaps(hDC,RASTERCAPS)&RC_BITBLT) {
		//
		// draw icon using mask
		//
		MaskBlt(hDC,
				rect.left,
				rect.top,
				rect.right-rect.left,
				rect.bottom-rect.top,
				hdcMem,
				0,
				0,
				m_hSmallMask,
				0,
				0,
				MAKEROP4(0xAA0029,SRCCOPY) // 0xAA0029 (from MSDN) = transparent
				);
	}
	SelectObject(hdcMem,hbmOld);
	DeleteDC(hdcMem);

	return TRUE;
}


STDMETHODIMP CDeviceIcon::ObtainIcon(LPDISPATCH pSource)
{
	HRESULT hr;
	CComQIPtr<IDeviceInternal> pDevice;
	CComQIPtr<ISetupClassInternal> pSetupClass;
	BSTR pMachine = NULL;
	GUID cls;
	HICON hIcon;
	INT miniIcon;

	if(!pSource) {
		ResetIcon();
		return S_OK;
	}
	pSetupClass = pSource;
	pDevice = pSource;
	
	if(pSetupClass) {
		//
		// obtain icon for specified device/class
		// based on devices class
		//
		hr = pSetupClass->get__Machine(&pMachine);
		if(FAILED(hr)) {
			pMachine = NULL;
		} else {
			hr = pSetupClass->get__ClassGuid(&cls);
		}
		if(FAILED(hr)) {
			cls = GUID_DEVCLASS_UNKNOWN;
		}

		//
		// obtain icon
		//
		if(!SetupDiLoadClassIcon(&cls,&hIcon,&miniIcon)) {
			cls = GUID_DEVCLASS_UNKNOWN;
			if(!SetupDiLoadClassIcon(&cls,&hIcon,&miniIcon)) {
				DWORD err = GetLastError();
				SysFreeString(pMachine);
				return HRESULT_FROM_SETUPAPI(err);
			}
		}
		ResetIcon();
		m_hIcon = hIcon;
		m_MiniIcon = miniIcon;
		FireViewChange();
		if(pMachine) {
			SysFreeString(pMachine);
		}
		return S_OK;


	} else {
		return E_INVALIDARG;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\deviceconsole.h ===
// DeviceConsole.h : Declaration of the CDeviceConsole

#ifndef __DEVICECONSOLE_H_
#define __DEVICECONSOLE_H_

#include "resource.h"       // main symbols

#define UM_POSTEVENTS      (WM_USER+101)
#define UM_POSTGLOBALEVENT (WM_USER+102)

class CEventsDispEntry;
class CEventsMap;
class CDispHandlerEvent;
class CDispHandlerCallback;
class CDispInterfaceHandlers;
class CDeviceConsole;

class CEventsDispPtr
{
private:
    CComQIPtr<IDispatch> m_Dispatch;

public:
    //
    // I have to use const due to way STL works
    // however I need to cast away const for ref-counting
    // *sigh*
    //
    CEventsDispPtr(const IDispatch*p) {
        m_Dispatch = (IDispatch*)p;
    }
    CEventsDispPtr(const CEventsDispPtr & p) {
        m_Dispatch = (IDispatch*)p.m_Dispatch;
    }
    bool operator==(const CEventsDispPtr & p) const {
        return m_Dispatch == p.m_Dispatch;
    }
    HRESULT Invoke(UINT argc,VARIANT * argv) {
        if(!m_Dispatch) {
            return S_FALSE;
        }
        DISPPARAMS DispParams;
        UINT Err;
        HRESULT hr;
        DispParams.cArgs = argc;
        DispParams.cNamedArgs = 0;
        DispParams.rgdispidNamedArgs = NULL;
        DispParams.rgvarg = argv;

        hr = m_Dispatch->Invoke(0,IID_NULL,0,DISPATCH_METHOD,&DispParams,NULL,NULL,&Err);
        return hr;
    }

};


//
// attachEvent detachEvent operation
//
class CEventsDispEntry : public std::list<CEventsDispPtr>
{
public:
    HRESULT AttachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT DetachEvent(LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT Invoke(UINT argc,VARIANT *argv);
};

class CEventsMap : public std::map<std::wstring,CEventsDispEntry>
{
public:
    HRESULT AttachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT DetachEvent(LPWSTR Name,LPDISPATCH pDisp,VARIANT_BOOL *pStatus);
    HRESULT Invoke(LPWSTR Name,UINT argc,VARIANT *argv);
    CEventsDispEntry & LookupNc(LPWSTR Name) throw(std::bad_alloc);
};

//
// map of interface/handle and callbacks
//
class CDispInterfaceHandlers
{
public:
    CDispInterfaceHandlers *m_pPrev;
    CDispInterfaceHandlers *m_pNext;
    GUID m_InterfaceClass;
    HDEVNOTIFY m_hNotify;
    CDispHandlerCallback *m_pFirstCallback;
    CDispHandlerCallback *m_pLastCallback;

    CDispHandlerEvent *m_pFirstEvent;
    CDispHandlerEvent *m_pLastEvent;

public:
    CDispInterfaceHandlers() {
    }

    ~CDispInterfaceHandlers() {
    }

};

class CDispHandlerCallback
{
public:
    CDispHandlerCallback *m_pPrev;
    CDispHandlerCallback *m_pNext;

public:
    CDispHandlerCallback() {
    }

    ~CDispHandlerCallback() {
    }

    virtual void DeviceEvent(CDispHandlerEvent * pEvent) = 0;
};

class CDispHandlerEvent
{
public:
    CDispHandlerEvent *m_pNext;
    BSTR m_Device;
    WPARAM m_Event;

    CDispHandlerEvent() {
    }
    ~CDispHandlerEvent() {
    }
};

typedef CWinTraits<WS_POPUP,0> CPopupWinTraits;

class CDevConNotifyWindow :
    public CWindowImpl<CDevConNotifyWindow,CWindow,CPopupWinTraits>
{
public:
    CDeviceConsole *m_pDevCon;

public:
    CDevConNotifyWindow() {
        m_pDevCon = NULL;
    }

   BEGIN_MSG_MAP(CDevConNotifyWindow)
      MESSAGE_HANDLER(WM_DEVICECHANGE,    OnDeviceChange)
      MESSAGE_HANDLER(UM_POSTEVENTS,      OnPostEvents)
      MESSAGE_HANDLER(UM_POSTGLOBALEVENT, OnPostGlobalEvent)
   END_MSG_MAP()

   LRESULT OnDeviceChange(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   LRESULT OnPostEvents(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
   LRESULT OnPostGlobalEvent(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
};

/////////////////////////////////////////////////////////////////////////////
// CDeviceConsole
class ATL_NO_VTABLE CDeviceConsole :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDeviceConsole, &CLSID_DeviceConsole>,
    public IDispatchImpl<IDeviceConsole, &IID_IDeviceConsole, &LIBID_DEVCON2Lib>
{
public:
    VARIANT_BOOL RebootRequired;
    CEventsMap m_Events;

    CDevConNotifyWindow *m_pNotifyWindow;

    CDispInterfaceHandlers *m_pFirstWatch;
    CDispInterfaceHandlers *m_pLastWatch;

    CDeviceConsole()
    {
        m_pNotifyWindow = NULL;
        m_pFirstWatch = NULL;
        m_pLastWatch = NULL;
        RebootRequired = VARIANT_FALSE;
    }
    ~CDeviceConsole()
    {
        if(m_pNotifyWindow) {
            m_pNotifyWindow->DestroyWindow();
            delete m_pNotifyWindow;
        }
    }

    CDevConNotifyWindow *NotifyWindow();

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICECONSOLE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceConsole)
    COM_INTERFACE_ENTRY(IDeviceConsole)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDeviceConsole
public:
    void FireGlobalEvent(WPARAM wParam);
    STDMETHOD(AttachEvent)(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk);
    STDMETHOD(DetachEvent)(/*[in]*/ BSTR eventName,/*[in]*/ LPDISPATCH handler,/*[out, retval]*/ VARIANT_BOOL *pOk);
    STDMETHOD(StringList)(/*[in]*/ VARIANT from,/*[out,retval]*/ LPDISPATCH *pDest);
    STDMETHOD(DevicesByInstanceIds)(/*[in]*/ VARIANT InstanceIdList,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH *pDevList);
    STDMETHOD(DevicesByInterfaceClasses)(/*[in]*/ VARIANT InterfaceClasses,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pDevices);
    STDMETHOD(DevicesBySetupClasses)(/*[in]*/ VARIANT SetupClasses,/*[in,optional]*/ VARIANT flags,/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pDevices);
    STDMETHOD(CreateEmptySetupClassList)(/*[in,optional]*/ VARIANT machine,/*[out,retval]*/ LPDISPATCH * pResult);
    STDMETHOD(SetupClasses)(/*[in,optional]*/ VARIANT match,/*[in,optional]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);
    STDMETHOD(get_RebootRequired)(/*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_RebootRequired)(/*[in]*/ VARIANT_BOOL newVal);
    STDMETHOD(RebootReasonHardware)();
    STDMETHOD(CheckReboot)();
    STDMETHOD(UpdateDriver)(/*[in]*/ BSTR infname,/*[in]*/ BSTR hwid,/*[in,optional]*/ VARIANT flags);
    STDMETHOD(CreateEmptyDeviceList)(/*[in,optional]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);
    STDMETHOD(AllDevices)(/*[in]*/ VARIANT flags,/*[in]*/ VARIANT machine,/*[retval,out]*/ LPDISPATCH *pDevices);

    //
    // helpers
    //
    HRESULT BuildDeviceList(HDEVINFO hDevInfo, LPDISPATCH *pDevices);
};

#endif //__DEVICECONSOLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\deviceicon.h ===
// DeviceIcon.h : Declaration of the CDeviceIcon

#ifndef __DEVICEICON_H_
#define __DEVICEICON_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


/////////////////////////////////////////////////////////////////////////////
// CDeviceIcon
class ATL_NO_VTABLE CDeviceIcon : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDeviceIcon, &IID_IDeviceIcon, &LIBID_DEVCON2Lib>,
	public CComControl<CDeviceIcon>,
	public IPersistStreamInitImpl<CDeviceIcon>,
	public IOleControlImpl<CDeviceIcon>,
	public IOleObjectImpl<CDeviceIcon>,
	public IOleInPlaceActiveObjectImpl<CDeviceIcon>,
	public IViewObjectExImpl<CDeviceIcon>,
	public IOleInPlaceObjectWindowlessImpl<CDeviceIcon>,
	public IPersistStorageImpl<CDeviceIcon>,
	public ISpecifyPropertyPagesImpl<CDeviceIcon>,
	public IQuickActivateImpl<CDeviceIcon>,
	public IDataObjectImpl<CDeviceIcon>,
	public IProvideClassInfo2Impl<&CLSID_DeviceIcon, NULL, &LIBID_DEVCON2Lib>,
	public CComCoClass<CDeviceIcon, &CLSID_DeviceIcon>
{
protected:
	HICON m_hIcon;
    HBITMAP m_hSmallImage;
	HBITMAP m_hSmallMask;
	INT   m_MiniIcon;
public:
	CDeviceIcon()
	{
		m_hIcon = NULL;
		m_MiniIcon = 0;
		m_hSmallImage = NULL;
		m_hSmallMask = NULL;
	}
	~CDeviceIcon()
	{
		ResetIcon();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICEICON)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDeviceIcon)
	COM_INTERFACE_ENTRY(IDeviceIcon)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IViewObjectEx)
	COM_INTERFACE_ENTRY(IViewObject2)
	COM_INTERFACE_ENTRY(IViewObject)
	COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceObject)
	COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY(IOleControl)
	COM_INTERFACE_ENTRY(IOleObject)
	COM_INTERFACE_ENTRY(IPersistStreamInit)
	COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
	COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY(IQuickActivate)
	COM_INTERFACE_ENTRY(IPersistStorage)
	COM_INTERFACE_ENTRY(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

	public:

BEGIN_PROP_MAP(CDeviceIcon)
	PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
	PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	// PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CDeviceIcon)
	CHAIN_MSG_MAP(CComControl<CDeviceIcon>)
	DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

	HRESULT OnDraw(ATL_DRAWINFO& di);


// IViewObjectEx
	DECLARE_VIEW_STATUS(0)

// IDeviceIcon
public:
	BOOL DrawMiniIcon(HDC hDC,RECT & rect,INT icon);
	STDMETHOD(ObtainIcon)(/*[in]*/ LPDISPATCH pSource);
	void ResetIcon();

};

#endif //__DEVICEICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devicesenum.cpp ===
// DevicesEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "Device.h"
#include "Devices.h"
#include "DevicesEnum.h"

/////////////////////////////////////////////////////////////////////////////
//
CDevicesEnum::~CDevicesEnum()
{
	DWORD c;
	if(pDevices) {
		for(c=0;c<Count;c++) {
			pDevices[c]->Release();
		}
		delete [] pDevices;
	}
}


HRESULT CDevicesEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDevice *pDev;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDev = pDevices[Position];
		pDev->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDev;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDevicesEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CDevicesEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDevicesEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDevicesEnum> *pEnum = NULL;
	hr = CComObject<CDevicesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyDevices(pDevices,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDevicesEnum::CopyDevices(CDevice **pArray, DWORD NewCount)
{
	DWORD c;

	if(pDevices) {
		delete [] pDevices;
		pDevices = NULL;
	}
	Count = 0;
	Position = 0;
	pDevices = new CDevice*[NewCount];
	if(!pDevices) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDevices[c] = pArray[c];
		if(!pDevices[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devices.cpp ===
// Devices.cpp : Implementation of CDevices
#include "stdafx.h"
#include "DevCon2.h"
#include "Devices.h"
#include "Device.h"
#include "DevicesEnum.h"
#include "DevInfoSet.h"
#include "xStrings.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDevices

CDevices::~CDevices()
{
	DWORD c;
	if(pDevices) {
		for(c=0;c<Count;c++) {
			pDevices[c]->Release();
		}
		delete [] pDevices;
	}
}


STDMETHODIMP CDevices::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CDevices::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pDevices[i]->AddRef();
	*ppVal = pDevices[i];

	return S_OK;
}

STDMETHODIMP CDevices::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDevicesEnum> *pEnum = NULL;
	hr = CComObject<CDevicesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyDevices(pDevices,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


HRESULT CDevices::InternalAdd(LPCWSTR InstanceId)
{
	HRESULT hr;
	DWORD c;
	HDEVINFO hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	//
	// create the SP_DEVINFO_DATA holder
	//
	CComObject<CDevice> *pDevice = NULL;
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevice> pDevicePtr = pDevice;
	hr = pDevice->Init(DevInfoSet,InstanceId,DeviceConsole);
	if(FAILED(hr)) {
		return hr;
	}
	//
	// see if we have a device already in our list
	// if we have, don't add another copy
	//
	for(c=0;c<Count;c++) {
		if(pDevices[c]->SameAs(pDevice)) {
			return S_OK;
		}
	}

	pDevicePtr.Detach();
	pDevices[Count++] = pDevice;

	return S_OK;
}

STDMETHODIMP CDevices::Add(VARIANT InstanceIds)
{
	CComObject<CStrings> *pStrings = NULL;
	HRESULT hr;
	BSTR str;
	DWORD c;

	hr = CComObject<CStrings>::CreateInstance(&pStrings);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IStrings> pStringsPtr = pStrings;

	hr = pStrings->Add(InstanceIds);
	if(FAILED(hr)) {
		return hr;
	}

	for(c=0;pStrings->InternalEnum(c,&str);c++) {
		//
		// convert string to interface
		//
		hr = InternalAdd(str);
		if(FAILED(hr)) {
			return hr;
		}
	}
	return S_OK;
}

STDMETHODIMP CDevices::Remove(VARIANT Index)
{
	//
	// remove from logical list
	// removal from HDEVINFO based on refcounting
	//
	DWORD i;
	HRESULT hr;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	if(i >= Count) {
		return E_INVALIDARG;
	}
	pDevices[i]->Release();
	Count--;
	DWORD c;
	for(c=i;c<Count;c++) {
		pDevices[c] = pDevices[c+1];
	}

	return S_OK;
}

HRESULT CDevices::Init(HDEVINFO hDevInfo,IDeviceConsole *pDevCon)
{
	SP_DEVINFO_DATA DeviceInfoData;
	Reset();
	DWORD c;
	HRESULT hr;

	CComObject<CDevInfoSet> *d;
	hr = CComObject<CDevInfoSet>::CreateInstance(&d);
	if(FAILED(hr)) {
		SetupDiDestroyDeviceInfoList(hDevInfo);
		return hr;
	}
	DeviceConsole = pDevCon;
	DevInfoSet = d; // addref's
	d->Init(hDevInfo);

	ZeroMemory(&DeviceInfoData,sizeof(DeviceInfoData));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	for(c=0;SetupDiEnumDeviceInfo(hDevInfo,c,&DeviceInfoData);c++) {
		if(!IncreaseArraySize(1)) {
			Reset();
			return E_OUTOFMEMORY;
		}
		CComObject<CDevice> *pDevice = NULL;
		hr = CComObject<CDevice>::CreateInstance(&pDevice);
		if(FAILED(hr)) {
			Reset();
			return hr;
		}
		pDevice->AddRef();
		pDevices[Count++] = pDevice;
		hr = pDevice->Init(DevInfoSet,&DeviceInfoData,DeviceConsole);
		if(FAILED(hr)) {
			Reset();
			return hr;
		}		
	}
	return Count ? S_OK : S_FALSE;
}

WINSETUPAPI BOOL WINAPI
  SetupDiEnumDeviceInfo(
    IN HDEVINFO  DeviceInfoSet,
    IN DWORD  MemberIndex,
    OUT PSP_DEVINFO_DATA  DeviceInfoData
    );

void CDevices::Reset()
{
	DWORD c;
	for(c=0;c<Count;c++) {
		pDevices[c]->Release();
	}
	Count = 0;
	DevInfoSet = NULL;
}

BOOL CDevices::IncreaseArraySize(DWORD add)
{
 	CDevice** pNewDevices;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewDevices = new CDevice*[Inc];
 	if(!pNewDevices) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewDevices[c] = pDevices[c];
 	}
 	delete [] pDevices;
 	pDevices = pNewDevices;
 	ArraySize = Inc;
 	return TRUE;
}

STDMETHODIMP CDevices::CreateRootDevice(VARIANT hwidParam, LPDISPATCH *pDispatch)
{
	*pDispatch = NULL;

	HRESULT hr;
	DWORD len;
	DWORD Err;
	LPWSTR hwidlist = NULL;
	CComObject<CDevice> *pDevice = NULL;
	HDEVINFO hDevInfo;
	SP_DEVINFO_DATA DeviceInfoData;
	WCHAR name[33];
	DWORD c,cc;
	LPCWSTR lastPart;
	LPCWSTR hwid;
	CComVariant hwid_v;
	LPCGUID pGuid = NULL;

	//
	// prepare list if we need to
	//
	hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}

	hr = GetOptionalString(&hwidParam,hwid_v,&hwid);
	if(FAILED(hr)) {
		return hr;
	}

	//
	// see if this devices collection is associated with a setup class
	//
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	if(memcmp(&devInfoListDetail.ClassGuid,&GUID_NULL,sizeof(devInfoListDetail.ClassGuid)) != 0) {
		//
		// collection is locked to a class, use that class to create device
		//
		pGuid = &devInfoListDetail.ClassGuid;
	} else {
		//
		// class is unknown
		//
		pGuid = &GUID_DEVCLASS_UNKNOWN;
	}

	if(hwid) {
		//
		// use hwid as basis of name
		// this really has no significant meaning, but helps for diagnostics
		// another option would be to use class name
		// be we don't know classname here
		//
		lastPart = wcsrchr(hwid,L'\\');
		if(!lastPart) {
			lastPart = hwid;
		}
		for(c=0,cc=0;c<16;c++) {
			//
			// ignore troublesome characters
			//
			while(lastPart[cc] &&
					((lastPart[cc] == L'/')
					|| (lastPart[cc] == L'\\')
					|| (lastPart[cc] == L'#')
					|| (lastPart[cc] >= 0x7f)
					|| (lastPart[cc] <= 0x20)
					)) {
				cc++;
			}
			if(!hwid[cc]) {
				break;
			}
			name[c] = hwid[cc];
		}
	} else {
		c = 0;
	}
	if(c) {
		name[c] = L'0';
	} else {
		wcscpy(name,L"NONAME");	
	}

	ZeroMemory(&DeviceInfoData,sizeof(DeviceInfoData));
	DeviceInfoData.cbSize = sizeof(DeviceInfoData);
	if (!SetupDiCreateDeviceInfo(hDevInfo,
		name,
		pGuid,
		NULL,
		0,
		DICD_GENERATE_ID,
		&DeviceInfoData))
	{
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}

	if(hwid && hwid[0]) {
		//
		// Add the HardwareID to the Device's HardwareID property.
		//
		len = wcslen(hwid);
		hwidlist = new WCHAR[len+2];
		if(!hwidlist) {
			hr = E_OUTOFMEMORY;
			goto final;
		}
		wcsncpy(hwidlist,hwid,len+1);
		hwidlist[len] = L'\0';
		hwidlist[len+1] = L'\0';
		
		if(!SetupDiSetDeviceRegistryProperty(hDevInfo,
 											&DeviceInfoData,
											SPDRP_HARDWAREID,
											(LPBYTE)hwidlist,
											(len+2)*sizeof(TCHAR)))
		{
			Err = GetLastError();
			hr = HRESULT_FROM_SETUPAPI(Err);
			goto final;
		}
	}

	//
	// Transform the registry element into an actual devnode
	// in the PnP HW tree.
	//
	if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
									hDevInfo,
									&DeviceInfoData))
	{
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		goto final;
	}

	//
	// create the SP_DEVINFO_DATA holder
	//
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	pDevice->AddRef();
	hr = pDevice->Init(DevInfoSet,&DeviceInfoData,DeviceConsole);
	if(FAILED(hr)) {
		pDevice->Release();
		goto final;
	}
	//
	// Add to list
	//
	pDevices[Count++] = pDevice;
	//
	// Return it
	//
	pDevice->AddRef();
	*pDispatch = pDevice;

	hr = S_OK;

final:

	if(hwidlist) {
		delete [] hwidlist;
	}

	if(FAILED(hr)) {
		if(!SetupDiCallClassInstaller(DIF_REMOVE,hDevInfo,&DeviceInfoData)) {
			//
			// if we failed to delete including class/co installers
			// force it
			//
			SetupDiRemoveDevice(hDevInfo,&DeviceInfoData);
		}
	}

	return hr;
}

HDEVINFO CDevices::GetDevInfoSet()
{
	ULONGLONG h;
	HRESULT hr;

	if(!DevInfoSet) {
		return (HDEVINFO)INVALID_HANDLE_VALUE;
	}
	hr = DevInfoSet->get_Handle(&h);
	if(FAILED(hr)) {
		return (HDEVINFO)INVALID_HANDLE_VALUE;
	}
	return (HDEVINFO)h;
}

HRESULT CDevices::GetIndex(LPVARIANT Index,DWORD * pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied instance id
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pDevices[c]->SameAs(V_BSTR(&v))) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// none found
	//
	return E_INVALIDARG;
}

STDMETHODIMP CDevices::get_Machine(BSTR *pVal)
{
	HDEVINFO hDevInfo = GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}

    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	if((devInfoListDetail.RemoteMachineHandle == NULL) || !devInfoListDetail.RemoteMachineName[0]) {
		*pVal = SysAllocString(L"");
		if(*pVal) {
			return S_FALSE;
		}
	} else {
		*pVal = SysAllocString(devInfoListDetail.RemoteMachineName);
		if(*pVal) {
			return S_OK;
		}
	}
	*pVal = NULL;
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devices.h ===
// Devices.h : Declaration of the CDevices

#ifndef __DEVICES_H_
#define __DEVICES_H_

#include "resource.h"       // main symbols

class CDevice;
/////////////////////////////////////////////////////////////////////////////
// CDevices
class ATL_NO_VTABLE CDevices : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CDevices, &CLSID_Devices>,
	public IDispatchImpl<IDevices, &IID_IDevices, &LIBID_DEVCON2Lib>
{
public:
	CComPtr<IDevInfoSet> DevInfoSet;
	CComPtr<IDeviceConsole> DeviceConsole;
	CDevice **pDevices;
	ULONG  ArraySize;
	ULONG  Count;

public:
	CDevices()
	{
		pDevices = NULL;
		ArraySize = 0;
		Count = 0;
	}
	~CDevices();

DECLARE_REGISTRY_RESOURCEID(IDR_DEVICES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevices)
	COM_INTERFACE_ENTRY(IDevices)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDevices
public:
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(CreateRootDevice)(/*[in]*/ VARIANT hwid,/*[out,retval]*/ LPDISPATCH *pDispatch);
	STDMETHOD(Remove)(/*[in]*/ VARIANT Index);
	STDMETHOD(Add)(/*[in]*/ VARIANT InstanceIds);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	HRESULT InternalAdd(LPCWSTR InstanceId);
	BOOL IncreaseArraySize(DWORD add);
	void Reset();
	HRESULT Init(HDEVINFO hDevInfo,IDeviceConsole *pDevCon);
	HRESULT GetIndex(LPVARIANT Index,DWORD * pAt);
	HDEVINFO GetDevInfoSet();
};

#endif //__DEVICES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devinfoset.cpp ===
// DevInfoSet.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "DevInfoSet.h"

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP CDevInfoSet::get_Handle(ULONGLONG *pVal)
{
	HDEVINFO h = Handle();
	*pVal = (ULONGLONG)h;
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devicesenum.h ===
// DevicesEnum.h: Definition of the CDevicesEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_)
#define AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevicesEnum

class CDevice;

class ATL_NO_VTABLE CDevicesEnum : 
	public IDevicesEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDevice** pDevices;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopyDevices(CDevice **pArray,DWORD Count);

	CDevicesEnum() {
		pDevices = NULL;
		Count = 0;
		Position = 0;
	}
	~CDevicesEnum();

BEGIN_COM_MAP(CDevicesEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IDevicesEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDevicesEnum) 

// IDevicesEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_DEVICESENUM_H__F9048FCD_C525_4BDD_AB79_018DEE3B71E8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\devinfoset.h ===
// DevInfoSet.h: Definition of the CDevInfoSet class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_)
#define AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDevInfoSet

class ATL_NO_VTABLE CDevInfoSet : 
	public IDevInfoSet,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:
	HDEVINFO hDevInfo;
public:
	CDevInfoSet() {
		//
		// use NULL to indicate uninitialized vs failed to initialize
		//
		hDevInfo = NULL;
	}
	~CDevInfoSet() {
		if(hDevInfo != INVALID_HANDLE_VALUE && hDevInfo != NULL) {
			SetupDiDestroyDeviceInfoList(hDevInfo);
		}
	}
	BOOL Init(HDEVINFO Handle) {
		hDevInfo = Handle;
		return TRUE;
	}
	HDEVINFO Handle() {
		//
		// initialize on demand
		//
		if(hDevInfo == NULL) {
			hDevInfo = SetupDiCreateDeviceInfoList(NULL,NULL);
		}
		return hDevInfo;
	}

DECLARE_NOT_AGGREGATABLE(CDevInfoSet) 

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDevInfoSet)
	COM_INTERFACE_ENTRY(IDevInfoSet)
END_COM_MAP()

// IDevInfoSet
public:
	STDMETHOD(get_Handle)(/*[out, retval]*/ ULONGLONG *pVal);
};

#endif // !defined(AFX_DEVINFOSET_H__7973729E_46E1_4B31_B15E_7B702679AC64__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_)
#define AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__2465E4C1_F3FF_47A4_9F80_D934F4E50C48__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "DevCon2_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\driver.cpp ===
// Driver.cpp : Implementation of CDriverPackage
#include "stdafx.h"
#include "DevCon2.h"
#include "Driver.h"
#include "Device.h"
#include "DrvSearchSet.h"
#include "xStrings.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverPackage

CDriverPackage::~CDriverPackage()
{
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
	}
}

HRESULT CDriverPackage::Init(CDrvSearchSet *pSet,PSP_DRVINFO_DATA pDrvInfoData)
{
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
	}
	pDrvSearchSet = NULL;
	if(!pSet) {
		return E_UNEXPECTED;
	}
	pSet->AddRef();
	pDrvSearchSet = pSet;
	if(pDrvInfoData) {
		DrvInfoData = *pDrvInfoData;
	} else {
		DrvInfoData.cbSize = 0;
	}
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Description(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.Description);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Manufacturer(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.MfgName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Provider(BSTR *pVal)
{
	*pVal = SysAllocString(DrvInfoData.ProviderName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Date(DATE *pVal)
{
	//
	// work out ticks to translate to Dec 30 1899
	//
	SYSTEMTIME sysTime;
	FILETIME ref_zero;
	FILETIME ref_one;
	ULARGE_INTEGER i_zero;
	ULARGE_INTEGER i_one;
	ULARGE_INTEGER i_act;

	sysTime.wYear = 1899;
	sysTime.wMonth = 12;
	sysTime.wDayOfWeek = 0;
	sysTime.wDay = 30;
	sysTime.wHour = 0;
	sysTime.wMinute = 0;
	sysTime.wSecond = 0;
	sysTime.wMilliseconds = 0;

	if(!SystemTimeToFileTime(&sysTime,&ref_zero)) {
		return E_UNEXPECTED;
	}

	i_zero.LowPart = ref_zero.dwLowDateTime;
	i_zero.HighPart = ref_zero.dwHighDateTime;

	sysTime.wYear = 1899;
	sysTime.wMonth = 12;
	sysTime.wDay = 31;

	if(!SystemTimeToFileTime(&sysTime,&ref_one)) {
		return E_UNEXPECTED;
	}

	i_one.LowPart = ref_one.dwLowDateTime;
	i_one.HighPart = ref_one.dwHighDateTime;
	i_one.QuadPart -= i_zero.QuadPart;

	//
	// now the real FILETIME
	//

	i_act.LowPart = DrvInfoData.DriverDate.dwLowDateTime;
	i_act.HighPart = DrvInfoData.DriverDate.dwHighDateTime;
	double dbl = (double)(__int64)i_act.QuadPart;
	dbl -= (double)(__int64)i_zero.QuadPart;
	dbl /= (double)(__int64)i_one.QuadPart;

	*pVal = dbl;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Version(BSTR *pVal)
{
	WCHAR fmt[64];
	ULARGE_INTEGER i;
	i.QuadPart = DrvInfoData.DriverVersion;
	swprintf(fmt,L"%u.%u.%u.%u",
					HIWORD(i.HighPart),
					LOWORD(i.HighPart),
					HIWORD(i.LowPart),
					LOWORD(i.LowPart));
	*pVal = SysAllocString(fmt);

	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ScriptName(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	HINF hInf = SetupOpenInfFile(detail.InfFileName,
									NULL,
									INF_STYLE_WIN4|INF_STYLE_OLDNT,
									NULL);
	if(hInf == INVALID_HANDLE_VALUE) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
	WCHAR buf[LINE_LEN];
	if(!SetupDiGetActualSectionToInstall(hInf,detail.SectionName,buf,LINE_LEN,NULL,NULL)) {
		SetupCloseInfFile(hInf);
		return E_UNEXPECTED;
	}
	*pVal = SysAllocString(buf);

	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ScriptFile(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	*pVal = SysAllocString(detail.InfFileName);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_HardwareIds(LPDISPATCH *pVal)
{
	PSP_DRVINFO_DETAIL_DATA pDetail;
	LPBYTE buffer = NULL;
	DWORD memsz = 8192;
	HRESULT hr;
	DWORD Err;

	for(;;) {
		buffer = new BYTE[memsz+sizeof(WCHAR)*2];
		if(!buffer) {
			return E_OUTOFMEMORY;
		}

		pDetail = (PSP_DRVINFO_DETAIL_DATA)buffer;
		ZeroMemory(pDetail,memsz+sizeof(WCHAR)*2);
		pDetail->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

		if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
										 pDrvSearchSet->GetDevInfoData(),
										 &DrvInfoData,
										 pDetail,
										 memsz,
										 &memsz)) {
			Err = GetLastError();
			if(Err != ERROR_INSUFFICIENT_BUFFER) {
				delete [] buffer;
				return HRESULT_FROM_SETUPAPI(Err);
			}			
		} else {
			break;
		}
		delete [] buffer;
	}

	if(pDetail->CompatIDsLength) {
		pDetail->HardwareID[pDetail->CompatIDsOffset] = L'\0';
	}
	
	//
	// now build multisz of hardware ID's
	//
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		delete [] buffer;
		return hr;
	}
	strings->AddRef();
	hr = strings->FromMultiSz(pDetail->HardwareID);
	delete [] buffer;
	
	if(FAILED(hr)) {
		strings->Release();
		return hr;
	}
	*pVal = strings;
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_CompatibleIds(LPDISPATCH *pVal)
{
	PSP_DRVINFO_DETAIL_DATA pDetail;
	LPBYTE buffer = NULL;
	DWORD memsz = 8192;
	HRESULT hr;
	DWORD Err;

	for(;;) {
		buffer = new BYTE[memsz+sizeof(WCHAR)*2];
		if(!buffer) {
			return E_OUTOFMEMORY;
		}

		pDetail = (PSP_DRVINFO_DETAIL_DATA)buffer;
		ZeroMemory(pDetail,memsz+sizeof(WCHAR)*2);
		pDetail->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

		if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
										 pDrvSearchSet->GetDevInfoData(),
										 &DrvInfoData,
										 pDetail,
										 memsz,
										 &memsz)) {
			Err = GetLastError();
			if(Err != ERROR_INSUFFICIENT_BUFFER) {
				delete [] buffer;
				return HRESULT_FROM_SETUPAPI(Err);
			}			
		} else {
			break;
		}
		delete [] buffer;
	}

	//
	// now build multisz of hardware ID's
	//
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		delete [] buffer;
		return hr;
	}
	strings->AddRef();
	if(pDetail->CompatIDsLength) {
		hr = strings->FromMultiSz(pDetail->HardwareID+pDetail->CompatIDsOffset);
	} else {
		hr = S_OK;
	}
	
	delete [] buffer;
	
	if(FAILED(hr)) {
		strings->Release();
		return hr;
	}
	*pVal = strings;
	return S_OK;
}

STDMETHODIMP CDriverPackage::get_DriverDescription(BSTR *pVal)
{
	SP_DRVINFO_DETAIL_DATA detail;
	detail.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
	if(!SetupDiGetDriverInfoDetail(pDrvSearchSet->GetDevInfoSet(),
									 pDrvSearchSet->GetDevInfoData(),
									 &DrvInfoData,
									 &detail,
									 sizeof(detail),
									 NULL)) {
		DWORD Err = GetLastError();
		if(Err != ERROR_INSUFFICIENT_BUFFER) {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	*pVal = SysAllocString(detail.DrvDescription);
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

UINT CDriverPackage::GetDriverListCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
{
	DriverListCallbackContext *pContext = (DriverListCallbackContext *)Context;
    LPTSTR file = (LPTSTR)Param1;

	pContext->hr = pContext->pList->InternalAdd(file,lstrlen(file));

    return FAILED(pContext->hr) ? ERROR_NO_MORE_ITEMS : NO_ERROR;
}

STDMETHODIMP CDriverPackage::DriverFiles(LPDISPATCH *pDriverFiles)
{
	//
	// if we were to install this driver, where would the files go?
	//
    SP_DEVINSTALL_PARAMS deviceInstallParams;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD scanResult;
	DWORD Err;
	HRESULT hr;

	HDEVINFO hDevInfo = pDrvSearchSet->GetDevInfoSet();
	PSP_DEVINFO_DATA pDevInfoData = pDrvSearchSet->GetDevInfoData();

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// select this driver (expect this to last only as long as this call)
	//
    if(!SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // now 'instigate' an install, obtaining all files to be copied into
    // a file queue
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// do it
	//
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, pDevInfoData) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // clear settings
    //
    deviceInstallParams.FileQueue = NULL;
    deviceInstallParams.Flags &= ~DI_NOVCP;
    SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams);

    //
    // we now have a list of delete/rename/copy files
    //
	DriverListCallbackContext context;
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		SetupCloseFileQueue(queueHandle);
		return hr;
	}
	strings->AddRef();

	context.pList = strings;
	context.hr = S_OK;

    if(!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACK,NULL,GetDriverListCallback,&context,&scanResult)) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		strings->Release();
		if(FAILED(context.hr)) {
			return context.hr;
		} else {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	SetupCloseFileQueue(queueHandle);
	*pDriverFiles = strings;
	return S_OK;
}

UINT CDriverPackage::GetManifestCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2)
{
	DriverListCallbackContext *pContext = (DriverListCallbackContext *)Context;
    FILEPATHS *pFileInfo = (FILEPATHS *)Param1;

	pContext->hr = pContext->pList->InternalAdd(pFileInfo->Source,lstrlen(pFileInfo->Source));

    return FAILED(pContext->hr) ? ERROR_NO_MORE_ITEMS : NO_ERROR;
}

STDMETHODIMP CDriverPackage::Manifest(LPDISPATCH *pManifest)
{
	//
	// source files
	//

    SP_DEVINSTALL_PARAMS deviceInstallParams;
    HSPFILEQ queueHandle = INVALID_HANDLE_VALUE;
    DWORD scanResult;
	DWORD Err;
	HRESULT hr;

	HDEVINFO hDevInfo = pDrvSearchSet->GetDevInfoSet();
	PSP_DEVINFO_DATA pDevInfoData = pDrvSearchSet->GetDevInfoData();

    ZeroMemory(&deviceInstallParams, sizeof(deviceInstallParams));
    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// select this driver (expect this to last only as long as this call)
	//
    if(!SetupDiSetSelectedDriver(hDevInfo, pDevInfoData, &DrvInfoData)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // now 'instigate' an install, obtaining all files to be copied into
    // a file queue
    //
    queueHandle = SetupOpenFileQueue();

    if ( queueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

    deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // we want to add the files to the file queue, not install them!
    //
    deviceInstallParams.FileQueue = queueHandle;
    deviceInstallParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// do it
	//
    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, hDevInfo, pDevInfoData) ) {
		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		return HRESULT_FROM_SETUPAPI(Err);
    }

    //
    // clear settings
    //
    deviceInstallParams.FileQueue = NULL;
    deviceInstallParams.Flags &= ~DI_NOVCP;
    SetupDiSetDeviceInstallParams(hDevInfo, pDevInfoData, &deviceInstallParams);

    //
    // we now have a list of delete/rename/copy files
    //
	DriverListCallbackContext context;
	CComObject<CStrings> *strings;
	hr = CComObject<CStrings>::CreateInstance(&strings);
	if(FAILED(hr)) {
		SetupCloseFileQueue(queueHandle);
		return hr;
	}
	strings->AddRef();

	context.pList = strings;
	context.hr = S_OK;

	//
	// WinXP has a perf option (no signing check) if these two flags are combined
	// if it doesn't work, fall back to Win2k method
	//
    if(!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACKEX|SPQ_SCAN_FILE_PRESENCE,NULL,GetManifestCallback,&context,&scanResult) &&
		(FAILED(context.hr) || 
		!SetupScanFileQueue(queueHandle,SPQ_SCAN_USE_CALLBACKEX,NULL,GetManifestCallback,&context,&scanResult))) {

		Err = GetLastError();
		SetupCloseFileQueue(queueHandle);
		strings->Release();
		if(FAILED(context.hr)) {
			return context.hr;
		} else {
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}
	SetupCloseFileQueue(queueHandle);
	*pManifest = strings;
	return S_OK;
}

BOOL CDriverPackage::IsSame(PSP_DRVINFO_DATA pInfo)
{
	if(pInfo->Reserved == DrvInfoData.Reserved) {
		return TRUE;
	}
	return FALSE;
}

STDMETHODIMP CDriverPackage::get_Reject(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_BAD_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_Reject(VARIANT_BOOL newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	DWORD newflags = (params.Flags & ~DNF_BAD_DRIVER) | (newVal ? DNF_BAD_DRIVER : 0);

	if(params.Flags != newflags) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_IsClassDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_CLASS_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_IsCompatibleDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_COMPATIBLE_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_DescriptionIsDuplicate(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_DUPDESC) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ProviderIsDuplicate(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_DUPPROVIDER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_ExcludeFromList(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_EXCLUDEFROMLIST) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_ExcludeFromList(VARIANT_BOOL newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}


	DWORD newflags = (params.Flags & ~DNF_EXCLUDEFROMLIST) | (newVal ? DNF_EXCLUDEFROMLIST : 0);

	if(params.Flags != newflags) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_FromInternet(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_INET_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_NoDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_NODRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_OldDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_OLDDRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_OldInternetDriver(VARIANT_BOOL *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}
								
	*pVal = (params.Flags & DNF_OLD_INET_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::get_Rank(long *pVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	*pVal = params.Rank & 0xffff;
	*pVal = (params.Flags & DNF_COMPATIBLE_DRIVER) ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CDriverPackage::put_Rank(long newVal)
{
	DWORD Err;

	SP_DRVINSTALL_PARAMS params;
	ZeroMemory(&params,sizeof(params));
	params.cbSize = sizeof(params);

	if(!SetupDiGetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
								      pDrvSearchSet->GetDevInfoData(),
								      &DrvInfoData,
									  &params)) {
		Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}


	DWORD newrank = newVal & 0xffff;

	if(params.Rank != newrank) {
		if(!SetupDiSetDriverInstallParams(pDrvSearchSet->GetDevInfoSet(),
									      pDrvSearchSet->GetDevInfoData(),
									      &DrvInfoData,
										  &params)) {
			Err = GetLastError();
			return HRESULT_FROM_SETUPAPI(Err);
		}
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\drivers.h ===
// Drivers.h : Declaration of the CDriverPackages

#ifndef __DRIVERS_H_
#define __DRIVERS_H_

#include "resource.h"       // main symbols

class CDriverPackage;
class CDrvSearchSet;
/////////////////////////////////////////////////////////////////////////////
// CDriverPackages
class ATL_NO_VTABLE CDriverPackages : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriverPackages, &IID_IDriverPackages, &LIBID_DEVCON2Lib>
{
public:
	CDrvSearchSet *pDrvSearchSet;
	CDriverPackage **pDrivers;
	ULONG  Count;
	ULONG  ArraySize;

public:
	CDriverPackages()
	{
		pDrvSearchSet = NULL;
		pDrivers = NULL;
		Count = 0;
		ArraySize = 0;
	}
	~CDriverPackages();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriverPackages)
	COM_INTERFACE_ENTRY(IDriverPackages)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriverPackages
public:
	STDMETHOD(BestDriver)(LPDISPATCH *ppVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	HRESULT InternalAdd(CDriverPackage *pDriver);
	HRESULT Init(CDrvSearchSet *pSet);
	BOOL IncreaseArraySize(DWORD add);
};

#endif //__DRIVERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\drivers.cpp ===
// Drivers.cpp : Implementation of CDriverPackages
#include "stdafx.h"
#include "DevCon2.h"
#include "Driver.h"
#include "Drivers.h"
#include "DrvSearchSet.h"
#include "DriversEnum.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CDriverPackages

CDriverPackages::~CDriverPackages()
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
		pDrvSearchSet = NULL;
	}
	
}


STDMETHODIMP CDriverPackages::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CDriverPackages::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pDrivers[i]->AddRef();
	*ppVal = pDrivers[i];

	return S_OK;
}

STDMETHODIMP CDriverPackages::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDriverPackagesEnum> *pEnum = NULL;
	hr = CComObject<CDriverPackagesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyDrivers(pDrivers,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}

BOOL CDriverPackages::IncreaseArraySize(DWORD add)
{
 	CDriverPackage** pNewDrivers;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewDrivers = new CDriverPackage*[Inc];
 	if(!pNewDrivers) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewDrivers[c] = pDrivers[c];
 	}
 	delete [] pDrivers;
 	pDrivers = pNewDrivers;
 	ArraySize = Inc;
 	return TRUE;
}



HRESULT CDriverPackages::Init(CDrvSearchSet *pSet)
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
	pDrivers = NULL;
	Count = 0;
	if(pDrvSearchSet) {
		pDrvSearchSet->Release();
		pDrvSearchSet = NULL;
	}
	pSet->AddRef();
	pDrvSearchSet = pSet;
	return S_OK;
}

HRESULT CDriverPackages::InternalAdd(CDriverPackage *pDriver)
{
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	pDriver->AddRef();
	pDrivers[Count++] = pDriver;
	return S_OK;
}

STDMETHODIMP CDriverPackages::BestDriver(LPDISPATCH *ppVal)
{
	DWORD Err;
	HRESULT hr;

	//
	// attempt to search for best driver
	//
	if(!SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
									pDrvSearchSet->GetDevInfoSet(),
									pDrvSearchSet->GetDevInfoData()
									)) {
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}
	SP_DRVINFO_DATA DriverInfoData;
	ZeroMemory(&DriverInfoData,sizeof(DriverInfoData));
	DriverInfoData.cbSize = sizeof(DriverInfoData);

	if(!SetupDiGetSelectedDriver(pDrvSearchSet->GetDevInfoSet(),
								 pDrvSearchSet->GetDevInfoData(),
								 &DriverInfoData)) {
		Err = GetLastError();
		hr = HRESULT_FROM_SETUPAPI(Err);
		return hr;
	}

	//
	// now get the driver object associated with this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pDrivers[c]->IsSame(&DriverInfoData)) {
			pDrivers[c]->AddRef();
			*ppVal = pDrivers[c];
			return S_OK;
		}
	}
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\drvsearchset.cpp ===
// DrvSearchSet.cpp : Implementation of CDrvSearchSet
#include "stdafx.h"
#include "DevCon2.h"
#include "DrvSearchSet.h"
#include "Drivers.h"
#include "Driver.h"
#include "Device.h"
#include "DevInfoSet.h"
#include "DeviceConsole.h"

/////////////////////////////////////////////////////////////////////////////
// CDrvSearchSet

CDrvSearchSet::~CDrvSearchSet()
{
	if(pActualDevice) {
		pActualDevice->Release();
	}
	if(pTempDevice) {
		pTempDevice->Release();
	}
}

HRESULT CDrvSearchSet::Init(CDevice *device,DWORD searchType)
{
	if(pActualDevice) {
		pActualDevice->Release();
		pActualDevice = NULL;
	}
	if(pTempDevice) {
		pTempDevice->Release();
		pTempDevice = NULL;
	}
	//
	// determine machine name that device resides on
	//
	HDEVINFO hDevInfo = device->GetDevInfoSet();
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_UNEXPECTED;
	}
    SP_DEVINFO_LIST_DETAIL_DATA devInfoListDetail;
	HRESULT hr;

    devInfoListDetail.cbSize = sizeof(devInfoListDetail);
    if(!SetupDiGetDeviceInfoListDetail(hDevInfo,&devInfoListDetail)) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
    }

	//
	// create empty device info set for same machine as device
	//
	hDevInfo = SetupDiCreateDeviceInfoListEx(NULL,
											 NULL,
											 devInfoListDetail.RemoteMachineName[0]
											     ? devInfoListDetail.RemoteMachineName
											     : NULL,
											 NULL);
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		DWORD Err = GetLastError();
		return HRESULT_FROM_SETUPAPI(Err);
	}

	CComObject<CDevInfoSet> *pDevInfoSet = NULL;
	hr = CComObject<CDevInfoSet>::CreateInstance(&pDevInfoSet);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevInfoSet> pDevInfoSetPtr = pDevInfoSet;
	hr = pDevInfoSet->Init(hDevInfo);
	if(FAILED(hr)) {
		return hr;
	}

	//
	// create a single entry device in new set
	//
	CComObject<CDevice> *pDevice = NULL;
	hr = CComObject<CDevice>::CreateInstance(&pDevice);
	if(FAILED(hr)) {
		return hr;
	}
	CComPtr<IDevice> pDevicePtr = pDevice;

	//
	// make a note of real device
	//
	device->AddRef();
	pActualDevice = device;
	//
	// and make a copy of it for temp device
	//
	BSTR Instance = NULL;
	hr = device->get_InstanceId(&Instance);
	if(FAILED(hr)) {
		return hr;
	}	
	hr = pDevice->Init(pDevInfoSet,Instance,device->DeviceConsole);
	SysFreeString(Instance);
	if(FAILED(hr)) {
		return hr;
	}
	pDevicePtr.Detach();
	pTempDevice = pDevice;
	SearchType = searchType;

	return S_OK;
}

HDEVINFO CDrvSearchSet::GetDevInfoSet()
{
	if(!pTempDevice) {
		return INVALID_HANDLE_VALUE;
	}
	return pTempDevice->GetDevInfoSet();
}

PSP_DEVINFO_DATA CDrvSearchSet::GetDevInfoData()
{
	if(!pTempDevice) {
		return NULL;
	}
	return &pTempDevice->DevInfoData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\driversenum.h ===
// DriverPackagesEnum.h: Definition of the CDriverPackagesEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_)
#define AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDriverPackagesEnum
class CDriverPackage;

class ATL_NO_VTABLE CDriverPackagesEnum : 
	public IDriverPackagesEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDriverPackage** pDrivers;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopyDrivers(CDriverPackage ** pArray,DWORD Count);

	CDriverPackagesEnum()
	{
		pDrivers = NULL;
		Count = 0;
		Position = 0;
	}

	~CDriverPackagesEnum();


BEGIN_COM_MAP(CDriverPackagesEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IDriverPackagesEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDriverPackagesEnum) 

// IDriverPackagesEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_DRIVERSENUM_H__840AC5A2_6A60_42B5_8CC7_FF67A2EA72B5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\driver.h ===
// Driver.h : Declaration of the CDriverPackage

#ifndef __DRIVER_H_
#define __DRIVER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CDriverPackage
class CDevice;
class CDrvSearchSet;
class CStrings;

class ATL_NO_VTABLE CDriverPackage : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriverPackage, &IID_IDriverPackage, &LIBID_DEVCON2Lib>
{
private:
	struct DriverListCallbackContext {
		CStrings *pList;
		HRESULT   hr;
	};

	static UINT CALLBACK GetDriverListCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2);
	static UINT CALLBACK GetManifestCallback(PVOID Context,UINT Notification,UINT_PTR Param1,UINT_PTR Param2);

protected:
	CDrvSearchSet *pDrvSearchSet;
	SP_DRVINFO_DATA DrvInfoData;

public:
	CDriverPackage()
	{
		pDrvSearchSet = NULL;
		ZeroMemory(&DrvInfoData,sizeof(DrvInfoData));
	}
	~CDriverPackage();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriverPackage)
	COM_INTERFACE_ENTRY(IDriverPackage)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriverPackage
public:
	STDMETHOD(get_Rank)(/*[out, retval]*/ long *pVal);
	STDMETHOD(put_Rank)(/*[in]*/ long newVal);
	STDMETHOD(get_OldInternetDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_OldDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_NoDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_FromInternet)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_ExcludeFromList)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_ExcludeFromList)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(get_ProviderIsDuplicate)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_DescriptionIsDuplicate)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsCompatibleDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_IsClassDriver)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(get_Reject)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_Reject)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Manifest)(/*[out,retval]*/ LPDISPATCH * pManifest);
	STDMETHOD(DriverFiles)(/*[out,retval]*/ LPDISPATCH * pDriverFiles);
	STDMETHOD(get_DriverDescription)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_CompatibleIds)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_HardwareIds)(/*[out, retval]*/ LPDISPATCH *pVal);
	STDMETHOD(get_ScriptFile)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_ScriptName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Version)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Date)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_Provider)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);

	//
	// helpers
	//
	BOOL IsSame(PSP_DRVINFO_DATA pInfo);
	HRESULT Init(CDrvSearchSet *pSet,PSP_DRVINFO_DATA pDrvInfoData);
};

#endif //__DRIVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\driversenum.cpp ===
// DriversEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "DriversEnum.h"
#include "Driver.h"

/////////////////////////////////////////////////////////////////////////////
//

CDriverPackagesEnum::~CDriverPackagesEnum()
{
	DWORD c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
}


HRESULT CDriverPackagesEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDriverPackage *pDrv;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDrv = pDrivers[Position];
		pDrv->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDrv;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDriverPackagesEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CDriverPackagesEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDriverPackagesEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDriverPackagesEnum> *pEnum = NULL;
	hr = CComObject<CDriverPackagesEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyDrivers(pDrivers,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDriverPackagesEnum::CopyDrivers(CDriverPackage **pArray, DWORD NewCount)
{
	DWORD c;

	if(pDrivers) {
		delete [] pDrivers;
		pDrivers = NULL;
	}
	Count = 0;
	Position = 0;
	pDrivers = new CDriverPackage*[NewCount];
	if(!pDrivers) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDrivers[c] = pArray[c];
		if(!pDrivers[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\drvsearchset.h ===
// DrvSearchSet.h : Declaration of the CDrvSearchSet

#ifndef __DRVSEARCHSET_H_
#define __DRVSEARCHSET_H_

#include "resource.h"       // main symbols

class CDevice;

/////////////////////////////////////////////////////////////////////////////
// CDrvSearchSet
class ATL_NO_VTABLE CDrvSearchSet : 
	public IDrvSearchSet,
	public CComObjectRootEx<CComSingleThreadModel>
{
public:
	CDevice *pActualDevice;
	CDevice *pTempDevice;
	DWORD   SearchType;

public:
	CDrvSearchSet()
	{
		pActualDevice = NULL;
		pTempDevice = NULL;
	}

	~CDrvSearchSet();

DECLARE_NOT_AGGREGATABLE(CDrvSearchSet)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDrvSearchSet)
	COM_INTERFACE_ENTRY(IDrvSearchSet)
END_COM_MAP()

// IDrvSearchSet
public:
	PSP_DEVINFO_DATA GetDevInfoData();
	HDEVINFO GetDevInfoSet();
	HRESULT Init(CDevice *device,DWORD searchType);
};

#endif //__DRVSEARCHSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DevCon2.rc
//
#define IDS_PROJNAME                    100
#define IDR_DEVICECONSOLE               101
#define IDR_DEVICES                     102
#define IDR_DRIVERS                     104
#define IDR_STRINGS                     106
#define IDS_DEVICESENUM_DESC            107
#define IDS_DRIVERSENUM_DESC            109
#define IDS_STRINGSENUM_DESC            111
#define IDS_DEVINFOSET_DESC             113
#define IDS_REBOOTREQ                   114
#define IDS_REBOOTCAP                   115
#define IDR_SETUPCLASSES                117
#define IDB_DEVICEICON                  120
#define IDR_DEVICEICON                  121
#define IDR_DEVCON2                     202

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclass.cpp ===
// SetupClass.cpp : Implementation of CSetupClass
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "devices.h"
#include "utils.h"
#include "xStrings.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClass

CSetupClass::~CSetupClass()
{
    if(pMachine) {
        SysFreeString(pMachine);
    }
}

HRESULT CSetupClass::Init(GUID *pGuid,LPWSTR Machine, IDeviceConsole *pDevCon)
{
    ClassGuid = *pGuid;
    if(pMachine) {
        SysFreeString(pMachine);
    }
    if(Machine) {
        pMachine = SysAllocString(Machine);
        if(!pMachine) {
            return E_OUTOFMEMORY;
        }
    } else {
        pMachine = NULL;
    }
    DeviceConsole = pDevCon;
    return S_OK;
}

BOOL CSetupClass::IsDuplicate(GUID *pCheck)
{
    //
    // only valid if pMachine/DeviceConsole known to be same
    //
    return memcmp(&ClassGuid,pCheck,sizeof(GUID)) ? FALSE : TRUE;
}

STDMETHODIMP CSetupClass::get_Name(BSTR *pVal)
{
    HRESULT hr;
    DWORD Err;
    LPWSTR Buffer;
    DWORD BuffSize=128;
    DWORD ReqSize;
    for(;;) {
        Buffer = new WCHAR[BuffSize];
        if(!Buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiClassNameFromGuidEx(&ClassGuid,Buffer,BuffSize,&ReqSize,pMachine,NULL)) {
            *pVal = SysAllocString(Buffer);
            delete [] Buffer;
            if(!*pVal) {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
        Err = GetLastError();
        delete [] Buffer;
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
        BuffSize = ReqSize+2;
    }
    return S_OK;
}

STDMETHODIMP CSetupClass::get_Description(BSTR *pVal)
{
    HRESULT hr;
    DWORD Err;
    LPWSTR Buffer;
    DWORD BuffSize=128;
    DWORD ReqSize;
    for(;;) {
        Buffer = new WCHAR[BuffSize];
        if(!Buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetClassDescriptionEx(&ClassGuid,Buffer,BuffSize,&ReqSize,pMachine,NULL)) {
            *pVal = SysAllocString(Buffer);
            delete [] Buffer;
            if(!*pVal) {
                return E_OUTOFMEMORY;
            }
            return S_OK;
        }
        Err = GetLastError();
        delete [] Buffer;
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
        BuffSize = ReqSize+2;
    }
    return S_OK;
}

STDMETHODIMP CSetupClass::Devices(VARIANT flags,LPDISPATCH * pDevices)
{
    DWORD diflags = 0;
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hr = TranslateDeviceFlags(&flags,&diflags);
    if(FAILED(hr)) {
        return hr;
    }
    hDevInfo = SetupDiGetClassDevsEx(&ClassGuid,NULL,NULL,diflags,NULL,pMachine,NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    d->AddRef();
    hr = d->Init(hDevInfo,DeviceConsole);
    if(FAILED(hr)) {
        d->Release();
        return hr;
    }
    *pDevices = d;
    return S_OK;
}

STDMETHODIMP CSetupClass::CreateEmptyDeviceList(LPDISPATCH *pDevices)
{
    HRESULT hr;
    HDEVINFO hDevInfo;
    DWORD Err;

    hDevInfo = SetupDiCreateDeviceInfoListEx(&ClassGuid,
                                              NULL,
                                              pMachine,
                                              NULL);
    if(hDevInfo == INVALID_HANDLE_VALUE) {
        Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }

    CComObject<CDevices> *d;
    hr = CComObject<CDevices>::CreateInstance(&d);
    if(FAILED(hr)) {
        SetupDiDestroyDeviceInfoList(hDevInfo);
        return hr;
    }
    d->AddRef();
    hr = d->Init(hDevInfo,DeviceConsole);
    if(FAILED(hr)) {
        d->Release();
        return hr;
    }
    *pDevices = d;
    return S_OK;
}

STDMETHODIMP CSetupClass::get_Guid(BSTR *pVal)
{
    LPOLESTR pStr;
    HRESULT hr = StringFromCLSID(ClassGuid,&pStr);
    if(FAILED(hr)) {
        return hr;
    }
    *pVal = SysAllocString(pStr);
    CoTaskMemFree(pStr);
    if(!*pVal) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

GUID* CSetupClass::Guid()
{
    return &ClassGuid;
}

STDMETHODIMP CSetupClass::get_Machine(BSTR *pVal)
{
    if((pMachine == NULL) || !pMachine[0]) {
        *pVal = SysAllocString(L"");
        if(*pVal) {
            return S_FALSE;
        }
    } else {
        *pVal = SysAllocString(pMachine);
        if(*pVal) {
            return S_OK;
        }
    }
    *pVal = NULL;
    return E_OUTOFMEMORY;
}

STDMETHODIMP CSetupClass::get__ClassGuid(GUID *pVal)
{
    *pVal = ClassGuid;

    return S_OK;
}

STDMETHODIMP CSetupClass::get__Machine(BSTR *pVal)
{
    return get_Machine(pVal);

    return S_OK;
}

HRESULT CSetupClass::GetClassProperty(DWORD prop, VARIANT *pVal)
{
#if 0
    //
    // first obtain raw registry data
    //
    LPBYTE buffer = NULL;
    DWORD size = 1024;
    DWORD bufsize;
    DWORD reqSize;
    DWORD dataType;
    HRESULT hr;

    for(;;) {
        if(buffer) {
            delete [] buffer;
        }
        bufsize = size + sizeof(WCHAR)*2;
        buffer = new BYTE[bufsize];
        if(!buffer) {
            return E_OUTOFMEMORY;
        }
        if(SetupDiGetClassRegistryProperty(&ClassGuid,prop,&dataType,buffer,size,&reqSize,pMachine,NULL)) {
            break;
        }
        DWORD Err = GetLastError();
        if(Err != ERROR_INSUFFICIENT_BUFFER) {
            delete [] buffer;
            hr = HRESULT_FROM_SETUPAPI(Err);
            return hr;
        }
    }

    //
    // now determine how to parcel it to caller
    //
    switch(dataType) {
    case REG_DWORD: {
            //
            // package value as a long
            //
            if(size != sizeof(DWORD)) {
                hr = E_INVALIDARG;
            } else {
                VariantClear(pVal);
                V_VT(pVal) = VT_I4;
                V_I4(pVal) = (long)*((DWORD*)buffer);
                hr = S_OK;
            }
        }
        break;

    case REG_SZ: {
            //
            // package value as string
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR));
            BSTR pString = SysAllocString((LPWSTR)buffer);
            if(!pString) {
                hr = E_OUTOFMEMORY;
            } else {
                V_VT(pVal) = VT_BSTR;
                V_BSTR(pVal) = pString;
                hr = S_OK;
            }
        }
        break;

    case REG_MULTI_SZ: {
            //
            // package as string-list
            //
            VariantClear(pVal);
            ZeroMemory(buffer+size,sizeof(WCHAR)*2);
            CComObject<CStrings> *strings;
            hr = CComObject<CStrings>::CreateInstance(&strings);
            if(FAILED(hr)) {
                break;
            }
            strings->AddRef();
            LPWSTR p;
            UINT len = 0;
            for(p = (LPWSTR)buffer;*p;p+=len+1) {
                len = wcslen(p);
                hr = strings->InternalAdd(p,len);
                if(FAILED(hr)) {
                    strings->Release();
                    break;
                }
            }
            V_VT(pVal) = VT_DISPATCH;
            V_DISPATCH(pVal) = strings;
            hr = S_OK;
        }
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    delete [] buffer;
    return hr;

#endif

    return E_NOTIMPL;
}

HRESULT CSetupClass::PutClassPropertyString(DWORD prop, VARIANT *pVal)
{
#if 0
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    CComVariant v;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = (SysStringLen(V_BSTR(&v))+1)*sizeof(WCHAR);
        data = (PBYTE)V_BSTR(&v);
    }

    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        data,
                                        len,
                                        pMachine,
                                        NULL)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;
}

HRESULT CSetupClass::PutClassPropertyDword(DWORD prop, VARIANT *pVal)
{
#if 0
    CComVariant v;
    HRESULT hr;
    DWORD len = 0;
    PBYTE data = NULL;
    if(!IsBlank(pVal)) {
        hr = v.ChangeType(VT_I4,pVal);
        if(FAILED(hr)) {
            return hr;
        }
        len = sizeof(V_I4(&v));
        data = (PBYTE)&V_I4(&v);
    }

    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        data,
                                        len,
                                        pMachine,
                                        NULL)) {
        return S_OK;
    }
    DWORD Err = GetLastError();
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;

}

HRESULT CSetupClass::PutClassPropertyMultiSz(DWORD prop, VARIANT *pVal)
{
#if 0
    //
    // build a CStrings collection
    //
    HRESULT hr;
    CComObject<CStrings> *strings = NULL;
    DWORD len = 0;
    PBYTE data = NULL;
    LPWSTR multisz;
    if(!IsBlank(pVal)) {
        hr = CComObject<CStrings>::CreateInstance(&strings);
        if(FAILED(hr)) {
            return hr;
        }
        strings->AddRef();
        hr = strings->Add(*pVal);
        if(FAILED(hr)) {
            strings->Release();
            return hr;
        }
        //
        // now obtain multisz from the collection
        //
        hr = strings->GetMultiSz(&multisz,&len);
        strings->Release(); // done with temporary collection
        if(FAILED(hr)) {
            return hr;
        }
        //
        // now write the multi-sz value to device registry
        //
        len *= sizeof(WCHAR);
        data = (PBYTE)multisz;
    }
    CONFIGRET cr = CM_Get_Class_Registry_Property(
    if(SetupDiSetClassRegistryProperty(&ClassGuid,
                                        prop,
                                        (PBYTE)multisz,
                                        len,
                                        pMachine,
                                        NULL)) {
        if(multisz) {
            delete [] multisz;
        }
        return S_OK;
    }
    DWORD Err = GetLastError();
    if(multisz) {
        delete [] multisz;
    }
    return HRESULT_FROM_SETUPAPI(Err);

#endif

    return E_NOTIMPL;
}


STDMETHODIMP CSetupClass::get_Security(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_SECURITY_SDS,pVal);
}

STDMETHODIMP CSetupClass::put_Security(VARIANT newVal)
{
    return PutClassPropertyString(SPDRP_SECURITY_SDS,&newVal);
}

STDMETHODIMP CSetupClass::get_DeviceTypeOverride(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_DEVTYPE,pVal);
}

STDMETHODIMP CSetupClass::put_DeviceTypeOverride(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_DEVTYPE,&newVal);
}

STDMETHODIMP CSetupClass::get_ForceExclusive(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_EXCLUSIVE,pVal);
}

STDMETHODIMP CSetupClass::put_ForceExclusive(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_EXCLUSIVE,&newVal);
}

STDMETHODIMP CSetupClass::get_CharacteristicsOverride(VARIANT *pVal)
{
    return GetClassProperty(SPDRP_CHARACTERISTICS,pVal);
}

STDMETHODIMP CSetupClass::put_CharacteristicsOverride(VARIANT newVal)
{
    return PutClassPropertyDword(SPDRP_CHARACTERISTICS,&newVal);
}



HRESULT CSetupClass::SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *pKeyVal,BOOL writeable)
{
    DWORD Scope = DICS_FLAG_GLOBAL;
    DWORD HwProfile = 0;
    HKEY hParentKey;
    LPWSTR keyname;
    LPCWSTR keyval;
    size_t len;

    hParentKey = SetupDiOpenClassRegKeyEx(&ClassGuid,
                                    writeable ? KEY_WRITE: KEY_READ,
                                    DIOCR_INSTALLER,
                                    pMachine,
                                    NULL
                                    );
    if((hParentKey == NULL) || (hParentKey == INVALID_HANDLE_VALUE)) {
        DWORD Err = GetLastError();
        return HRESULT_FROM_SETUPAPI(Err);
    }
    //
    // determine value part of key
    //
    keyval = wcsrchr(subkey,L'\\');
    if(!keyval) {
        *hKey = hParentKey;
        *pKeyVal = subkey[0] ? subkey : NULL;
        *pSubKey = NULL;
        return S_OK;
    }
    len = keyval-subkey+1;
    keyname = new WCHAR[len];
    if(!keyname) {
        RegCloseKey(hParentKey);
        return E_OUTOFMEMORY;
    }
    wcsncpy(keyname,subkey,len);
    keyname[len-1] = 0;
    keyval++;
    if(!keyval[0]) {
        keyval = NULL;
    }
    *hKey = hParentKey;
    *pSubKey = keyname;
    *pKeyVal = keyval;
    return S_OK;
}

STDMETHODIMP CSetupClass::RegRead(BSTR key,VARIANT * pValue)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR val;
    LPWSTR subkey;
    LONG regerr;
    DWORD regType;
    DWORD regSize;
    LPBYTE pByte;

    if(!pValue) {
        return E_INVALIDARG;
    }
    VariantInit(pValue);

    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&val,FALSE);
    if(FAILED(hr)) {
        return hr;
    }
    //
    // now work out and marshell data
    //
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_READ,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regSize = 0;
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,NULL,&regSize);
    if(regerr != NO_ERROR) {
        RegCloseKey(hKey);
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    pByte = new BYTE[regSize+sizeof(WCHAR)*2];
    if(!pByte) {
        RegCloseKey(hKey);
        return E_OUTOFMEMORY;
    }
    regerr = RegQueryValueEx(hKey,val,NULL,&regType,pByte,&regSize);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    switch(regType) {
    case REG_DWORD:
        if(regSize != 4) {
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }

        V_VT(pValue) = VT_UI4;
        V_UI4(pValue) = *(DWORD*)pByte;
        break;

    case REG_BINARY:
        switch(regSize) {
        case 1:
            V_VT(pValue) = VT_UI1;
            V_UI1(pValue) = *((BYTE*)pByte);
            break;
        case 2:
            V_VT(pValue) = VT_UI2;
            V_UI2(pValue) = *((WORD*)pByte);
            break;
        case 4:
            V_VT(pValue) = VT_UI4;
            V_UI4(pValue) = *((DWORD*)pByte);
            break;
        default:
            delete [] pByte;
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        V_VT(pValue) = VT_BSTR;
        V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    case REG_MULTI_SZ: {
            ZeroMemory(pByte+regSize,sizeof(WCHAR)*2);
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                delete [] pByte;
                return hr;
            }
            pStringTemp->AddRef();
            hr = pStringTemp->FromMultiSz((LPWSTR)pByte);
            if(FAILED(hr)) {
                pStringTemp->Release();
                delete [] pByte;
                return hr;
            }
            V_VT(pValue) = VT_DISPATCH;
            V_DISPATCH(pValue) = pStringTemp;
        }
        break;


    case REG_EXPAND_SZ:
        ZeroMemory(pByte+regSize,sizeof(WCHAR)*1);
        regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,0);
        if(regSize == 0) {
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString((LPWSTR)pByte);
        } else {
            LPWSTR pExp = new WCHAR[regSize+1];
            if(!pExp) {
                delete [] pByte;
                return E_OUTOFMEMORY;
            }
            regSize = ExpandEnvironmentStrings((LPWSTR)pByte,NULL,regSize);
            V_VT(pValue) = VT_BSTR;
            V_BSTR(pValue) = SysAllocString(pExp);
            delete [] pExp;
        }
        if(!V_BSTR(pValue)) {
            delete [] pByte;
            return E_OUTOFMEMORY;
        }
        break;

    default:
        delete [] pByte;
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    delete [] pByte;
    return S_OK;
}

STDMETHODIMP CSetupClass::RegWrite(BSTR key, VARIANT val, VARIANT strType)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    CComVariant strType_v;
    CComVariant val_v;
    LPCWSTR pType;
    HRESULT hr;
    DWORD dwType;
    BOOL DetermineType = FALSE;
    LPBYTE pData = NULL;
    LPWSTR pString = NULL;
    DWORD DataSize = 0;
    BYTE SimpleData[4];
    LPVARIANT pVal = &val;

    while(V_VT(pVal) == (VT_BYREF|VT_VARIANT)) {
        pVal = V_VARIANTREF(pVal);
    }

    //
    // validate strType
    //

    hr = GetOptionalString(&strType,strType_v,&pType);
    if(FAILED(hr)) {
        return hr;
    }

    if((pType == NULL) || !pType[0]) {
        //
        // determine type of variant
        //
        if(IsNumericVariant(pVal)) {
            dwType = REG_DWORD;
        } else if(IsMultiValueVariant(pVal)) {
            dwType = REG_MULTI_SZ;
        } else {
            dwType = REG_SZ;
        }
    } else if(_wcsicmp(pType,L"REG_DWORD")==0) {
        dwType = REG_DWORD;
    } else if(_wcsicmp(pType,L"REG_SZ")==0) {
        dwType = REG_SZ;
    } else if(_wcsicmp(pType,L"REG_EXPAND_SZ")==0) {
        dwType = REG_EXPAND_SZ;
    } else if(_wcsicmp(pType,L"REG_MULTI_SZ")==0) {
        dwType = REG_MULTI_SZ;
    } else if(_wcsicmp(pType,L"REG_BINARY")==0) {
        dwType = REG_BINARY;
    } else {
        return DISP_E_TYPEMISMATCH;
    }

    //
    // build up value data
    //
    switch(dwType) {
    case REG_BINARY:
        pData = SimpleData;
        switch V_VT(pVal) {
        case VT_I1:
        case VT_UI1:
            *(LPBYTE)pData = V_UI1(pVal);
            DataSize = 1;
            break;
        case VT_I1|VT_BYREF:
        case VT_UI1|VT_BYREF:
            *(LPBYTE)pData = *V_UI1REF(pVal);
            DataSize = 1;
            break;
        case VT_I2:
        case VT_UI2:
            *(LPWORD)pData = V_UI2(pVal);
            DataSize = 2;
            break;
        case VT_I2|VT_BYREF:
        case VT_UI2|VT_BYREF:
            *(LPWORD)pData = *V_UI2REF(pVal);
            DataSize = 2;
            break;
        case VT_I4:
        case VT_UI4:
            *(LPDWORD)pData = V_UI4(pVal);
            DataSize = 4;
            break;
        case VT_I4|VT_BYREF:
        case VT_UI4|VT_BYREF:
            *(LPDWORD)pData = *V_UI4REF(pVal);
            DataSize = 4;
            break;
        default:
            return DISP_E_TYPEMISMATCH;
        }
        break;

    case REG_DWORD:
        pData = SimpleData;
        hr = val_v.ChangeType(VT_UI4,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }
        *(LPDWORD)pData = V_UI4(pVal);
        DataSize = 4;
        break;

    case REG_SZ:
    case REG_EXPAND_SZ:
        hr = val_v.ChangeType(VT_BSTR,pVal);
        if(FAILED(hr)) {
            return DISP_E_TYPEMISMATCH;
        }

        DataSize = (SysStringLen(V_BSTR(&val_v))+1);
        pString = new WCHAR[DataSize];
        if(!pString) {
            return E_OUTOFMEMORY;
        }
        pData = (LPBYTE)pString;
        DataSize *= sizeof(WCHAR);
        memcpy(pData,V_BSTR(&val_v),DataSize);
        break;

    case REG_MULTI_SZ: {
            CComObject<CStrings> *pStringTemp = NULL;
            hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
            if(FAILED(hr)) {
                return hr;
            }
            pStringTemp->AddRef();
            hr = pStringTemp->InternalInsert(0,pVal);
            if(FAILED(hr)) {
                pStringTemp->Release();
                return hr;
            }
            hr = pStringTemp->GetMultiSz(&pString,&DataSize);
            pStringTemp->Release();
            if(FAILED(hr)) {
                return hr;
            }
            pData = (LPBYTE)pString;
            DataSize *= sizeof(WCHAR);
        }
        break;
    default:
        return DISP_E_TYPEMISMATCH;
    }

    hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        if(pString) {
            delete [] pString;
        }
        return hr;
    }
    if(subkey) {
        regerr = RegCreateKeyEx(hParentKey,subkey,0,NULL,0,KEY_WRITE,NULL,&hKey,NULL);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            if(pString) {
                delete [] pString;
            }
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }

    regerr = RegSetValueEx(hKey,valname,0,dwType,pData,DataSize);
    if(pString) {
        delete [] pString;
    }
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }

    return S_OK;
}

STDMETHODIMP CSetupClass::RegDelete(BSTR key)
{
    HKEY hParentKey;
    HKEY hKey;
    LPCWSTR valname;
    LPWSTR subkey;
    LONG regerr;
    HRESULT hr = SubKeyInfo(key,&hParentKey,&subkey,&valname,TRUE);
    if(FAILED(hr)) {
        return hr;
    }
    if(subkey) {
        regerr = RegOpenKeyEx(hParentKey,subkey,0,KEY_WRITE,&hKey);
        delete [] subkey;
        RegCloseKey(hParentKey);
        if(regerr != NO_ERROR) {
            return HRESULT_FROM_SETUPAPI(regerr);
        }
    } else {
        hKey = hParentKey;
    }
    regerr = RegDeleteValue(hKey,valname);
    RegCloseKey(hKey);
    if(regerr != NO_ERROR) {
        return HRESULT_FROM_SETUPAPI(regerr);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclassenum.h ===
// SetupClassEnum.h : Declaration of the CSetupClassEnum

#ifndef __SETUPCLASSENUM_H_
#define __SETUPCLASSENUM_H_

#include "resource.h"       // main symbols

class CSetupClass;
/////////////////////////////////////////////////////////////////////////////
// CSetupClassEnum
class ATL_NO_VTABLE CSetupClassEnum : 
	public ISetupClassEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CSetupClass** pSetupClasses;
	DWORD Count;
	DWORD Position;

public:
	BOOL CopySetupClasses(CSetupClass ** pArray,DWORD Count);

	CSetupClassEnum()
	{
		Position = 0;
		pSetupClasses = NULL;
		Count = 0;
	}
	~CSetupClassEnum();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClassEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(ISetupClassEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CSetupClassEnum) 

// ISetupClassEnum
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif //__SETUPCLASSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclassenum.cpp ===
// SetupClassEnum.cpp : Implementation of CSetupClassEnum
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "SetupClasses.h"
#include "SetupClassEnum.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClassEnum

CSetupClassEnum::~CSetupClassEnum()
{
	DWORD c;
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
}


HRESULT CSetupClassEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CSetupClass *pCls;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pCls = pSetupClasses[Position];
		pCls->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pCls;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CSetupClassEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CSetupClassEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CSetupClassEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CSetupClassEnum> *pEnum = NULL;
	hr = CComObject<CSetupClassEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopySetupClasses(pSetupClasses,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CSetupClassEnum::CopySetupClasses(CSetupClass **pArray, DWORD NewCount)
{
	DWORD c;

	if(pSetupClasses) {
		delete [] pSetupClasses;
		pSetupClasses = NULL;
	}
	Count = 0;
	Position = 0;
	pSetupClasses = new CSetupClass*[NewCount];
	if(!pSetupClasses) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pSetupClasses[c] = pArray[c];
		if(!pSetupClasses[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclass.h ===
// SetupClass.h : Declaration of the CSetupClass

#ifndef __SETUPCLASS_H_
#define __SETUPCLASS_H_

#include "resource.h"       // main symbols

class CDeviceConsole;
/////////////////////////////////////////////////////////////////////////////
// CSetupClass
class ATL_NO_VTABLE CSetupClass : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<ISetupClass, &IID_ISetupClass, &LIBID_DEVCON2Lib>,
	public ISetupClassInternal
{
protected:
	CComPtr<IDeviceConsole> DeviceConsole;
	BSTR pMachine;
	GUID ClassGuid;

public:
	CSetupClass()
	{
		pMachine = NULL;
		ZeroMemory(&ClassGuid,sizeof(ClassGuid));
	}
	~CSetupClass();

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClass)
	COM_INTERFACE_ENTRY(ISetupClass)
	COM_INTERFACE_ENTRY(ISetupClassInternal)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISetupClass
public:
	STDMETHOD(RegDelete)(/*[in]*/ BSTR key);
	STDMETHOD(RegWrite)(/*[in]*/ BSTR key,/*[in]*/ VARIANT val,/*[in,optional]*/ VARIANT strType);
	STDMETHOD(RegRead)(/*[in]*/ BSTR key,VARIANT * pValue);
	STDMETHOD(get_CharacteristicsOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_CharacteristicsOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_ForceExclusive)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_ForceExclusive)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_DeviceTypeOverride)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_DeviceTypeOverride)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Security)(/*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(put_Security)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Guid)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(CreateEmptyDeviceList)(/*[retval,out]*/ LPDISPATCH *pDevices);
	STDMETHOD(Devices)(/*[in,optional]*/ VARIANT flags,/*[out]*/ LPDISPATCH * pDevices);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);

// internal
public:
	STDMETHOD(get__Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get__ClassGuid)(/*[out, retval]*/ GUID *pVal);


	//
	// helpers
	//
	GUID* Guid();
	BOOL IsDuplicate(GUID *pCheck);
	HRESULT SubKeyInfo(LPCWSTR subkey, HKEY *hKey, LPWSTR *pSubKey,LPCWSTR *keyval,BOOL writeable);
	HRESULT Init(GUID *pGuid,LPWSTR Machine, IDeviceConsole *pDevCon);
	HRESULT GetClassProperty(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyString(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyDword(DWORD prop, VARIANT *pVal);
	HRESULT PutClassPropertyMultiSz(DWORD prop, VARIANT *pVal);
};

#endif //__SETUPCLASS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclasses.cpp ===
// SetupClasses.cpp : Implementation of CSetupClasses
#include "stdafx.h"
#include "DevCon2.h"
#include "SetupClass.h"
#include "SetupClassEnum.h"
#include "SetupClasses.h"
#include "DeviceConsole.h"
#include "Devices.h"
#include "xStrings.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CSetupClasses

CSetupClasses::~CSetupClasses()
{
	DWORD c;
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
	if(pMachine) {
		SysFreeString(pMachine);
	}
}


STDMETHODIMP CSetupClasses::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CSetupClasses::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	DWORD i = (DWORD)Index;
	if(i<1 || i > Count) {
		return E_INVALIDARG;
	}
	i--;
	pSetupClasses[i]->AddRef();
	*ppVal = pSetupClasses[i];

	return S_OK;
}

STDMETHODIMP CSetupClasses::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CSetupClassEnum> *pEnum = NULL;
	hr = CComObject<CSetupClassEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopySetupClasses(pSetupClasses,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


BOOL CSetupClasses::IncreaseArraySize(DWORD add)
{
 	CSetupClass** pNewSetupClasses;
 	DWORD Inc;
 	DWORD c;
 
 	if((ArraySize-Count)>=add) {
 		return TRUE;
 	}
 	Inc = ArraySize + add + 32;
 	pNewSetupClasses = new CSetupClass*[Inc];
 	if(!pNewSetupClasses) {
 		return FALSE;
 	}
 	for(c=0;c<Count;c++) {
 		pNewSetupClasses[c] = pSetupClasses[c];
 	}
 	delete [] pSetupClasses;
 	pSetupClasses = pNewSetupClasses;
 	ArraySize = Inc;
 	return TRUE;
}



HRESULT CSetupClasses::Init(LPCWSTR Machine, IDeviceConsole *pDevCon)
{
	if(pMachine) {
		SysFreeString(pMachine);
	}
	if(Machine) {
		pMachine = SysAllocString(Machine);
		if(!pMachine) {
			return E_OUTOFMEMORY;
		}
	} else {
		pMachine = NULL;
	}
	DeviceConsole = pDevCon;
	return S_OK;
}

HRESULT CSetupClasses::AppendClass(LPCWSTR Filter)
{
	DWORD nClasses;
	DWORD nClasses2;
	DWORD c;
	DWORD Err;
	HRESULT hr;

	if(Filter[0]==L'{') {
		//
		// possibly GUID
		//
		GUID guid;
		hr = CLSIDFromString((LPWSTR)Filter,&guid);
		if(SUCCEEDED(hr)) {
			//
			// class is in GUID format
			//
			if(FindDuplicate(&guid)) {
				return S_OK;
			}
			return AddGuid(&guid);
		}
	}
	//
	// class is probably in text format
	// obtain list of class id's that match class name
	// append all class devices for each class guid
	//
	if(SetupDiClassGuidsFromNameEx(Filter,NULL,0,&nClasses,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
		if(!nClasses) {
			//
			// no classes
			//
			return S_FALSE;
		}
		GUID *pList = new GUID[nClasses];
		if(!pList) {
			return E_OUTOFMEMORY;
		}
		if(SetupDiClassGuidsFromNameEx(Filter,pList,nClasses,&nClasses2,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
			//
			// count may have changed since last call
			//
			if(nClasses>nClasses2) {
				nClasses = nClasses2;
			}
			if(!nClasses) {
				//
				// no classes
				//
				delete [] pList;
				return S_FALSE;
			}
			for(c=0;c<nClasses;c++) {
				if(FindDuplicate(&pList[c])) {
					continue;
				}
				hr = AddGuid(&pList[c]);
				if(FAILED(hr)) {
					delete [] pList;
					return hr;
				}
			}
			delete [] pList;
			return hr;
		}
	}
	Err = GetLastError();
	return HRESULT_FROM_SETUPAPI(Err);
}


HRESULT CSetupClasses::AddGuid(GUID *pGuid)
{
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	CComObject<CSetupClass> *d;	
	HRESULT hr;
	hr = CComObject<CSetupClass>::CreateInstance(&d);
	if(FAILED(hr)) {
		return hr;
	}
	d->AddRef();
	hr = d->Init(pGuid,pMachine,DeviceConsole);
	if(FAILED(hr)) {
		d->Release();
		return hr;
	}
	pSetupClasses[Count++] = d;
	return S_OK;
}

STDMETHODIMP CSetupClasses::Add(VARIANT ClassNames)
{
	//
	// can pass in a collection
	//
	CComObject<CStrings> *pStrings = NULL;
	HRESULT hr;
	DWORD c;
	BSTR str;

	hr = CComObject<CStrings>::CreateInstance(&pStrings);
	if(FAILED(hr)) {
		return hr;
	}

	pStrings->AddRef();
	hr = pStrings->InternalInsert(0,&ClassNames);
	if(FAILED(hr)) {
		pStrings->Release();
		return hr;
	}

	for(c=0;pStrings->InternalEnum(c,&str);c++) {
		hr = AppendClass(str);
		if(FAILED(hr)) {
			pStrings->Release();
			return hr;
		}
	}
	pStrings->Release();
	return c ? S_OK : S_FALSE;
}

BOOL CSetupClasses::FindDuplicate(GUID *pGuid)
{
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pSetupClasses[c]->IsDuplicate(pGuid)) {
			return TRUE;
		}
	}
	return FALSE;
}


STDMETHODIMP CSetupClasses::Remove(VARIANT v)
{
	// TODO: Add your implementation code here

	return S_OK;
}

HRESULT CSetupClasses::GetIndex(LPVARIANT Index, DWORD *pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied guid?
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	BSTR pMatch = V_BSTR(&v);
	if(pMatch[0]!=L'{') {
		return E_INVALIDARG;
	}
	//
	// obtain GUID
	//
	GUID guid;
	hr = CLSIDFromString((LPWSTR)pMatch,&guid);
	if(FAILED(hr)) {
		return hr;
	}
	DWORD c;
	for(c=0;c<Count;c++) {
		if(pSetupClasses[c]->IsDuplicate(&guid)) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// still none found
	//
	return E_INVALIDARG;
}

STDMETHODIMP CSetupClasses::Devices(VARIANT flags, LPDISPATCH *pDevices)
{
	//
	// combine devices for all classes
	//
	DWORD diflags = 0;
	HRESULT hr;
	HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
	HDEVINFO hPrevDevInfo = NULL;
	DWORD Err;
	DWORD c;

	hr = TranslateDeviceFlags(&flags,&diflags);
	if(FAILED(hr)) {
		return hr;
	}
	for(c=0;c<Count;c++) {
		hDevInfo = SetupDiGetClassDevsEx(pSetupClasses[c]->Guid(),NULL,NULL,diflags,hPrevDevInfo,pMachine,NULL);
		if(hDevInfo == INVALID_HANDLE_VALUE) {
			Err = GetLastError();
			if(hPrevDevInfo) {
				SetupDiDestroyDeviceInfoList(hPrevDevInfo);
			}
			return HRESULT_FROM_SETUPAPI(Err);
		}
		hPrevDevInfo = hDevInfo;
	}
	if(hDevInfo == INVALID_HANDLE_VALUE) {
		return E_INVALIDARG;
	}

	CComObject<CDevices> *d;	
	hr = CComObject<CDevices>::CreateInstance(&d);
	if(FAILED(hr)) {
		SetupDiDestroyDeviceInfoList(hDevInfo);
		return hr;
	}
	d->AddRef();
	hr = d->Init(hDevInfo,DeviceConsole);
	if(FAILED(hr)) {
		d->Release();
		return hr;
	}
	*pDevices = d;
	return S_OK;
}

HRESULT CSetupClasses::AllClasses()
{
	DWORD nClasses;
	DWORD nClasses2;
	DWORD c;
	DWORD Err;
	HRESULT hr;

	//
	// start with empty list
	//
	if(pSetupClasses) {
		for(c=0;c<Count;c++) {
			pSetupClasses[c]->Release();
		}
		delete [] pSetupClasses;
	}
	//
	// all classes
	//
	if(SetupDiBuildClassInfoListEx(0,NULL,0,&nClasses,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
		if(!nClasses) {
			//
			// no classes
			//
			return S_FALSE;
		}
		GUID *pList = new GUID[nClasses];
		if(!pList) {
			return E_OUTOFMEMORY;
		}
		if(SetupDiBuildClassInfoListEx(0,pList,nClasses,&nClasses2,pMachine,NULL) || GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
			//
			// count may have changed since last call
			//
			if(nClasses>nClasses2) {
				nClasses = nClasses2;
			}
			if(!nClasses) {
				//
				// no classes
				//
				delete [] pList;
				return S_FALSE;
			}
			for(c=0;c<nClasses;c++) {
				hr = AddGuid(&pList[c]);
				if(FAILED(hr)) {
					delete [] pList;
					return hr;
				}
			}
			delete [] pList;
			return hr;
		}
	}
	Err = GetLastError();
	return HRESULT_FROM_SETUPAPI(Err);
}

STDMETHODIMP CSetupClasses::get_Machine(BSTR *pVal)
{
	if((pMachine == NULL) || !pMachine[0]) {
		*pVal = SysAllocString(L"");
		if(*pVal) {
			return S_FALSE;
		}
	} else {
		*pVal = SysAllocString(pMachine);
		if(*pVal) {
			return S_OK;
		}
	}
	*pVal = NULL;
	return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\setupclasses.h ===
// SetupClasses.h : Declaration of the CSetupClasses

#ifndef __SETUPCLASSES_H_
#define __SETUPCLASSES_H_

#include "resource.h"       // main symbols

class CSetupClass;
/////////////////////////////////////////////////////////////////////////////
// CSetupClasses
class ATL_NO_VTABLE CSetupClasses : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CSetupClasses, &CLSID_SetupClasses>,
	public IDispatchImpl<ISetupClasses, &IID_ISetupClasses, &LIBID_DEVCON2Lib>
{
protected:
	CComPtr<IDeviceConsole> DeviceConsole;
	BSTR pMachine;
	CSetupClass** pSetupClasses;
	DWORD Count;
	DWORD ArraySize;

public:
	CSetupClasses()
	{
		pMachine = NULL;
		pSetupClasses = NULL;
		Count = 0;
		ArraySize = 0;
	}

	~CSetupClasses();

DECLARE_REGISTRY_RESOURCEID(IDR_SETUPCLASSES)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetupClasses)
	COM_INTERFACE_ENTRY(ISetupClasses)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ISetupClasses
public:
	STDMETHOD(get_Machine)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(Devices)(/*[in,optional]*/ VARIANT flags,/*[out,retval]*/ LPDISPATCH * pDevices);
	STDMETHOD(Remove)(/*[in]*/ VARIANT v);
	STDMETHOD(Add)(/*[in]*/ VARIANT ClassNames);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	BOOL IncreaseArraySize(DWORD strings);
	HRESULT AddGuid(GUID *pGuid);
	HRESULT AppendClass(LPCWSTR Filter);
	HRESULT Init(LPCWSTR Machine, IDeviceConsole * pDevCon);
	BOOL FindDuplicate(GUID *pGuid);
	HRESULT GetIndex(LPVARIANT Index,DWORD *pAt);
	HRESULT AllClasses();
};

#endif //__SETUPCLASSES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED_)
#define AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//
// DCOM support (note, this must occur after atlbase.h but before anything else)
//
class CMyModule : public CComModule
{
public:
    CMyModule() {
        bServer = FALSE;
        punkFact = NULL;
        dwROC = 0;
    }
    LONG Unlock();
    void CheckShutdown();
    void KillServer();
    HRESULT InitServer(GUID & ClsId);
    bool bServer;
    IUnknown* punkFact;
    DWORD dwROC;
};
extern CMyModule _Module;

#include <atlcom.h>
#include <setupapi.h>
#include <devguid.h>
#include <cfgmgr32.h>
#include <regstr.h>
#include <atlctl.h>
#include <string>
#include <map>
#include <list>
#include <iterator>
#include <iostream>
#include <stdexcept>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2B158C89_9DAA_42AD_BAF7_44D5FA3A7C53__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devprop\devprop.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <tchar.h>

#include <setupapi.h>
#include <cfgmgr32.h>
#include <regstr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\xstrings.h ===
// Strings.h : Declaration of the CStrings

#ifndef __STRINGS_H_
#define __STRINGS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStrings
class ATL_NO_VTABLE CStrings : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStrings, &CLSID_Strings>,
	public IDispatchImpl<IStrings, &IID_IStrings, &LIBID_DEVCON2Lib>
{
protected:
	BSTR  *pMultiStrings;
	ULONG  ArraySize;
	ULONG  Count;
	VARIANT_BOOL   IsCaseSensative;

public:
	CStrings()
	{
		pMultiStrings = NULL;
		ArraySize = 0;
		Count = 0;
		IsCaseSensative = VARIANT_FALSE;
	}

	virtual ~CStrings();

DECLARE_REGISTRY_RESOURCEID(IDR_STRINGS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStrings)
	COM_INTERFACE_ENTRY(IStrings)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IStrings
public:
	STDMETHOD(get_CaseSensative)(/*[out, retval]*/ VARIANT_BOOL *pVal);
	STDMETHOD(put_CaseSensative)(/*[in]*/ VARIANT_BOOL newVal);
	STDMETHOD(Find)(/*[in]*/ BSTR name,/*[out,retval]*/ long *pFound);
	STDMETHOD(Remove)(/*[in]*/ VARIANT Index);
	STDMETHOD(Insert)(/*[in]*/ VARIANT Index,/*[in]*/ VARIANT Value);
	STDMETHOD(Add)(/*[in]*/ VARIANT Value);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ VARIANT Index,/*[out, retval]*/ VARIANT * pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

	//
	// helpers
	//
	BOOL InternalEnum(DWORD index,BSTR *pNext);
	HRESULT GetIndex(VARIANT *pIndex,DWORD *pAt);
	HRESULT FromMultiSz(LPCWSTR pMultiSz);
	HRESULT GetMultiSz(LPWSTR *pResult,DWORD *pSize);
	HRESULT InternalInsertString(DWORD Index,BSTR pString);
	HRESULT InternalInsertCollection(DWORD Index,IEnumVARIANT * pEnum);
	HRESULT InternalInsertArray(DWORD Index, VARTYPE vt,SAFEARRAY * pArray);
	HRESULT InternalInsertArrayDim(CComObject<CStrings> *pStringTemp, VARTYPE vt, SAFEARRAY *pArray,long *pDims,UINT dim,UINT dims);
	HRESULT InternalInsert(DWORD Index,LPVARIANT Value);
	HRESULT InternalAdd(LPCWSTR Value,UINT len);
	BOOL IncreaseArraySize(DWORD strings);
};

#endif //__STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\utils.h ===
//
// utils.h
//

inline BOOL IsNumericVariant(VARIANT * pVar)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if((V_VT(pVar) & ~(VT_TYPEMASK|VT_BYREF)) != 0) {
        return FALSE;
    }
    switch(V_VT(pVar) & VT_TYPEMASK) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_INT:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_UINT:
        case VT_R4:
        case VT_R8:
            return TRUE;
    }
    return FALSE;
}

inline BOOL IsArrayVariant(VARIANT * pVar,SAFEARRAY **pArray,VARTYPE *pType)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(!V_ISARRAY(pVar)) {
        return FALSE;
    }
    if(pArray) {
        if(V_ISBYREF(pVar)) {
            *pArray = *V_ARRAYREF(pVar);
        } else {
            *pArray = V_ARRAY(pVar);
        }
    }
    if(pType) {
        *pType = V_VT(pVar) & VT_TYPEMASK;
    }
    return TRUE;
}

inline BOOL IsCollectionVariant(VARIANT * pVar,IEnumVARIANT ** pCollection)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    CComVariant v;
    HRESULT hr = v.ChangeType(VT_DISPATCH,pVar);
    if(FAILED(hr)) {
        return FALSE;
    }
    //
    // look for an enumerator
    //
    DISPPARAMS params;
    LPDISPATCH pDisp = V_DISPATCH(&v);
    if(!pDisp) {
        return FALSE;
    }
    CComVariant result;
    params.cArgs = 0;
    params.cNamedArgs = 0;
    hr = pDisp->Invoke(DISPID_NEWENUM,
                        IID_NULL,
                        0,
                        DISPATCH_PROPERTYGET,
                        &params,
                        &result,
                        NULL,
                        NULL);

    if(FAILED(hr)) {
        return FALSE;
    }
    hr = result.ChangeType(VT_UNKNOWN);
    if(FAILED(hr)) {
        return FALSE;
    }
    IEnumVARIANT *pEnum;
    hr = V_UNKNOWN(&result)->QueryInterface(IID_IEnumVARIANT,(LPVOID*)&pEnum);
    if(FAILED(hr)) {
        return FALSE;
    }
    if(pCollection) {
        *pCollection = pEnum;
    } else {
        pEnum->Release();
    }
    return TRUE;
}

inline BOOL IsMultiValueVariant(VARIANT * pVar)
{
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(IsArrayVariant(pVar,NULL,NULL)) {
        return TRUE;
    }
    if(IsCollectionVariant(pVar,NULL)) {
        return TRUE;
    }
    return FALSE;
}

inline BOOL IsNoArg(LPVARIANT pVar)
{
    //
    // explicit "no parameter"
    //
    if((V_VT(pVar) == VT_ERROR) && (V_ERROR(pVar) == (DISP_E_PARAMNOTFOUND))) {
        return TRUE;
    }
    return FALSE;
}

inline BOOL IsBlank(LPVARIANT pVar)
{
    //
    // flexable "no parameter" allow 'null' 'nothing'
    //
    if(IsNoArg(pVar)) {
        return TRUE;
    }
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(V_ISBYREF(pVar) && !V_BYREF(pVar)) {
        return TRUE;
    }
    if((V_VT(pVar) == VT_EMPTY) || (V_VT(pVar) == VT_NULL)) {
        return TRUE;
    }
    if(((V_VT(pVar) == VT_UNKNOWN) || (V_VT(pVar) == VT_DISPATCH))  && !V_UNKNOWN(pVar)) {
        return TRUE;
    }
    if(((V_VT(pVar) == (VT_BYREF|VT_UNKNOWN)) || (V_VT(pVar) == (VT_BYREF|VT_DISPATCH)))
        && !(V_UNKNOWNREF(pVar) && *V_UNKNOWNREF(pVar))) {
        return TRUE;
    }
    //
    // consider everything else as a parameter
    //
    return FALSE;
}

inline BOOL IsBlankString(LPVARIANT pVar)
{
    //
    // even more flexable, allow "" too
    //
    if(IsBlank(pVar)) {
        return TRUE;
    }
    while(V_VT(pVar) == (VT_BYREF|VT_VARIANT)) {
        pVar = V_VARIANTREF(pVar);
    }
    if(V_VT(pVar) == VT_BSTR) {
        return SysStringLen(V_BSTR(pVar)) ? FALSE : TRUE;
    }
    if(V_VT(pVar) == (VT_BYREF|VT_BSTR)) {
        return (V_BSTRREF(pVar) && SysStringLen(*V_BSTRREF(pVar))) ? FALSE : TRUE;
    }
    return FALSE;
}

#define DEVFLAGS_HIDDEN        0x00000001
#define DEVFLAGS_SINGLEPROFILE 0x00000002
#define DEVFLAGS_ALL            0x00000003

inline HRESULT TranslateDeviceFlags(LPVARIANT flags,DWORD * di_flags)
{
    long fl_final = 0;
    CComVariant v;
    HRESULT hr;

    if(flags) {
        if(IsNoArg(flags)) {
            fl_final = 0;
        } else if(IsNumericVariant(flags)) {
            hr = v.ChangeType(VT_I4,flags);
            if(FAILED(hr)) {
                return hr;
            }
            fl_final = V_I4(&v);
        } else {
            return E_INVALIDARG;
        }
    }

    *di_flags = 0;
    if(fl_final & ~(DEVFLAGS_ALL)) {
        return E_INVALIDARG;
    }
    if(!(fl_final & DEVFLAGS_HIDDEN)) {
        *di_flags |= DIGCF_PRESENT;
    }
    if(fl_final & DEVFLAGS_SINGLEPROFILE) {
        *di_flags |= DIGCF_PROFILE;
    }

    return S_OK;
}

inline HRESULT GetOptionalString(LPVARIANT param,CComVariant &store,LPCWSTR *pString)
{
    HRESULT hr;

    *pString = NULL;
    if(param) {
        if(IsBlank(param)) {
            return S_OK;
        }
        hr = store.ChangeType(VT_BSTR,param);
        if(FAILED(hr)) {
            return hr;
        }
        *pString = V_BSTR(&store);
        return S_OK;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\stringsenum.h ===
// StringsEnum.h: Definition of the CStringsEnum class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_)
#define AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CStringsEnum
#include "xStrings.h"

class ATL_NO_VTABLE CStringsEnum : 
	public IStringsEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	BSTR* pMultiStrings;
	DWORD Count;
	DWORD Position;

public:
	CStringsEnum() {
		Position = 0;
		pMultiStrings = NULL;
		Count = 0;
	}
	~CStringsEnum();

BEGIN_COM_MAP(CStringsEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
	COM_INTERFACE_ENTRY(IStringsEnum)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CStringsEnum) 

// IStringsEnum
public:
	BOOL CopyStrings(BSTR *pArray,DWORD Count);
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif // !defined(AFX_STRINGSENUM_H__2DABC6B9_80D8_4E73_B4A9_7031AB8DF930__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\strings.cpp ===
// Strings.cpp : Implementation of CStrings
#include "stdafx.h"
#include "DevCon2.h"
#include "xStrings.h"
#include "StringsEnum.h"
#include "utils.h"

/////////////////////////////////////////////////////////////////////////////
// CStrings

CStrings::~CStrings()
{
	DWORD c;
	if(pMultiStrings) {
		for(c=0;c<Count;c++) {
			SysFreeString(pMultiStrings[c]);
		}
		delete [] pMultiStrings;
	}
}

STDMETHODIMP CStrings::get_Count(long *pVal)
{
	*pVal = (long)Count;
	return S_OK;
}

STDMETHODIMP CStrings::Item(VARIANT Index, VARIANT *pVal)
{
	HRESULT hr;
	DWORD i;
	BSTR ValueCopy = NULL;
	if(!IsNoArg(&Index)) {
		//
		// get single value
		//
		hr = GetIndex(&Index,&i);
		if(FAILED(hr)) {
			return hr;
		}
		ValueCopy = SysAllocStringLen(pMultiStrings[i],SysStringLen(pMultiStrings[i]));
		if(!ValueCopy) {
			return E_OUTOFMEMORY;
		}
		VariantInit(pVal);
		V_VT(pVal) = VT_BSTR;
		V_BSTR(pVal) = ValueCopy;
		return S_OK;
	}
	//
	// return collection as an array of strings
	//
#if 1
	SAFEARRAY *pArray;
	SAFEARRAYBOUND bounds[1];
	LONG ind[1];
	bounds[0].lLbound = 1;
	bounds[0].cElements = Count;
	VARIANT v;
	pArray = SafeArrayCreate(VT_VARIANT,1,bounds);
	if(!pArray) {
		return E_OUTOFMEMORY;
	}
	DWORD c;
	VariantInit(&v);
	for(c=0;c<Count;c++) {
		ind[0] = (LONG)(c+1);
		V_VT(&v) = VT_BSTR;
		V_BSTR(&v) = pMultiStrings[c];

		hr = SafeArrayPutElement(pArray,ind,&v);
		if(FAILED(hr)) {
			SafeArrayDestroy(pArray);
			return hr;
		}
	}
	VariantInit(pVal);
	V_VT(pVal) = VT_ARRAY | VT_VARIANT;
	V_ARRAY(pVal) = pArray;
#else
	SAFEARRAY *pArray;
	SAFEARRAYBOUND bounds[1];
	LONG ind[1];
	bounds[0].lLbound = 1;
	bounds[0].cElements = Count;
	pArray = SafeArrayCreate(VT_BSTR,1,bounds);
	if(!pArray) {
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=0;c<Count;c++) {
		ind[0] = (LONG)(c+1);
		hr = SafeArrayPutElement(pArray,ind,pMultiStrings[c]);
		if(FAILED(hr)) {
			SafeArrayDestroy(pArray);
			return hr;
		}
	}
	VariantInit(pVal);
	V_VT(pVal) = VT_ARRAY | VT_BSTR;
	V_ARRAY(pVal) = pArray;
#endif

	
	return S_OK;
}

STDMETHODIMP CStrings::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CStringsEnum> *pEnum = NULL;
	hr = CComObject<CStringsEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->CopyStrings(pMultiStrings,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}


HRESULT CStrings::InternalAdd(LPCWSTR Value, UINT len)
{
	if(len == (UINT)(-1)) {
		len = wcslen(Value);
	}
	BSTR ValueCopy = NULL;
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	ValueCopy = SysAllocStringLen(Value,len);
	if(!ValueCopy) {
		return E_OUTOFMEMORY;
	}
	pMultiStrings[Count++] = ValueCopy;

	return S_OK;
}

STDMETHODIMP CStrings::Add(VARIANT Value)
{
	return InternalInsert(Count,&Value);
}

BOOL CStrings::IncreaseArraySize(DWORD strings)
{
	BSTR* pNewStrings;
	DWORD Inc;
	DWORD c;

	if((ArraySize-Count)>=strings) {
		return TRUE;
	}
	Inc = ArraySize + strings + 32;
	pNewStrings = new BSTR[Inc];
	if(!pNewStrings) {
		return FALSE;
	}
	for(c=0;c<Count;c++) {
		pNewStrings[c] = pMultiStrings[c];
	}
	delete [] pMultiStrings;
	pMultiStrings = pNewStrings;
	ArraySize = Inc;
	return TRUE;
}

STDMETHODIMP CStrings::Insert(VARIANT Index, VARIANT Value)
{
	HRESULT hr;
	DWORD i;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	//
	// allow i==Count
	//
	if(i>Count) {
		return E_INVALIDARG;
	}
	return InternalInsert(i,&Value);
}

STDMETHODIMP CStrings::Remove(VARIANT Index)
{
	HRESULT hr;
	DWORD i;
	hr = GetIndex(&Index,&i);
	if(FAILED(hr)) {
		return hr;
	}
	if(i>=Count) {
		return E_INVALIDARG;
	}

	DWORD c;

	SysFreeString(pMultiStrings[i]);
	Count--;
	for(c=i;c<Count;c++) {
		pMultiStrings[c] = pMultiStrings[c+1];
	}

	return S_OK;
}

HRESULT CStrings::InternalInsert(DWORD Index, LPVARIANT pVal)
{
	CComVariant v;
	HRESULT hr;
	SAFEARRAY *pArray;
	VARTYPE vt;
	CComPtr<IEnumVARIANT> pEnum;

	if(IsArrayVariant(pVal,&pArray,&vt)) {
		return InternalInsertArray(Index,vt,pArray);
	}
	if(IsCollectionVariant(pVal,&pEnum)) {
		return InternalInsertCollection(Index,pEnum);
	}
	//
	// now see if we can treat it as a string
	//
	hr = v.ChangeType(VT_BSTR,pVal);
	if(SUCCEEDED(hr)) {
		return InternalInsertString(Index,V_BSTR(&v));
	}
	return hr;
}

HRESULT CStrings::InternalInsertArray(DWORD Index, VARTYPE vt, SAFEARRAY *pArray)
{
	HRESULT hr;
	UINT dims = SafeArrayGetDim(pArray);
	if(!dims) {
		return S_FALSE;
	}
	long *pDims = new long[dims];
	if(!pDims) {
		return E_OUTOFMEMORY;
	}

	//
	// write values into a temporary collection
	//
	CComObject<CStrings> *pStringTemp = NULL;
	hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
	if(FAILED(hr)) {
		delete [] pDims;
		return hr;
	}
	pStringTemp->AddRef();

	hr = InternalInsertArrayDim(pStringTemp,vt,pArray,pDims,0,dims);
	delete [] pDims;
	if(FAILED(hr)) {
		pStringTemp->Release();
		return hr;
	}
	//
	// now quickly insert pStringTemp strings into this collection
	//
	DWORD Added = pStringTemp->Count;
	if(!IncreaseArraySize(Added)) {
		pStringTemp->Release();
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=Count;c>Index;c--) {
		pMultiStrings[c-1+Added] = pMultiStrings[c-1];
	}
	for(c=0;c<Added;c++) {
		pMultiStrings[Index+c] = pStringTemp->pMultiStrings[c];
	}
	Count += Added;
	//
	// throw strings in temp collection away without free'ing them
	//
	pStringTemp->Count = 0;
	pStringTemp->Release();

	return S_OK;
}

HRESULT CStrings::InternalInsertArrayDim(CComObject<CStrings> *pStringTemp, VARTYPE vt, SAFEARRAY *pArray,long *pDims,UINT dim,UINT dims)
{
	long lower;
	long upper;
	long aIndex;
	HRESULT hr;
	UINT nextdim = dim+1;

	hr = SafeArrayGetLBound(pArray,nextdim,&lower);
	if(FAILED(hr)) {
		return hr;
	}
	hr = SafeArrayGetUBound(pArray,nextdim,&upper);
	if(FAILED(hr)) {
		return hr;
	}
	if(nextdim<dims) {
		for(aIndex=lower;aIndex<=upper;aIndex++) {
			pDims[dim] = aIndex;
			hr = InternalInsertArrayDim(pStringTemp,vt,pArray,pDims,nextdim,dims);
			if(FAILED(hr)) {
				return hr;
			}
		}
		return S_OK;
	}
	if(upper-lower<0) {
		return S_OK;
	}
	//
	// write values for this vector
	//
	UINT elemsize = SafeArrayGetElemsize(pArray);
	PBYTE buffer = new BYTE[elemsize];
	if(!buffer) {
		return E_OUTOFMEMORY;
	}
	for(aIndex=lower;aIndex<=upper;aIndex++) {
		pDims[dim] = aIndex;
		hr = SafeArrayGetElement(pArray,pDims,buffer);
		if(FAILED(hr)) {
			delete [] buffer;
			return hr;
		}
		VARIANT v;
		if(elemsize < sizeof(VARIANT)) {
			VariantInit(&v);
			V_VT(&v) = vt & ~(VT_ARRAY|VT_VECTOR|VT_BYREF);
			memcpy(&V_BYREF(&v),buffer,elemsize);
		} else {
			memcpy(&v,buffer,sizeof(v));
		}
		if(V_VT(&v)!=VT_EMPTY) {
			//
			// only add non-empty items
			//
			hr = pStringTemp->Add(v);
		}
		VariantClear(&v);
		if(FAILED(hr)) {
			delete [] buffer;
			return hr;
		}
	}
	return S_OK;
}

HRESULT CStrings::InternalInsertCollection(DWORD Index, IEnumVARIANT *pEnum)
{
	pEnum->Reset();
	CComVariant ent;
	//
	// get first item - this allows us to do little work if
	// source collection is empty
	//
	HRESULT hr = pEnum->Next(1,&ent,NULL);
	if(FAILED(hr)) {
		return hr;
	}
	if(hr != S_OK) {
		//
		// empty
		//
		return S_FALSE;
	}
	//
	// create a temporary collection for working
	//
	CComObject<CStrings> *pStringTemp = NULL;
	hr = CComObject<CStrings>::CreateInstance(&pStringTemp);
	if(FAILED(hr)) {
		return hr;
	}
	pStringTemp->AddRef();
	do {
		//
		// this will recursively process an element of this collection
		//
		hr = pStringTemp->Add(ent);
		if(FAILED(hr)) {
			break;
		}
		//
		// next
		//
		ent.Clear();
		hr = pEnum->Next(1,&ent,NULL);
	} while(hr == S_OK);
	if(FAILED(hr)) {
		pStringTemp->Release();
		return hr;
	}
	//
	// now quickly insert pStringTemp strings into this collection
	//
	DWORD Added = pStringTemp->Count;
	if(!IncreaseArraySize(Added)) {
		pStringTemp->Release();
		return E_OUTOFMEMORY;
	}
	DWORD c;
	for(c=Count;c>Index;c--) {
		pMultiStrings[c-1+Added] = pMultiStrings[c-1];
	}
	for(c=0;c<Added;c++) {
		pMultiStrings[Index+c] = pStringTemp->pMultiStrings[c];
	}
	Count += Added;
	//
	// throw strings in temp collection away without free'ing them
	//
	pStringTemp->Count = 0;
	pStringTemp->Release();

	return S_OK;
}

HRESULT CStrings::InternalInsertString(DWORD Index, BSTR pString)
{
	DWORD c;
	BSTR ValueCopy = NULL;

	if(Index>Count) {
		return E_INVALIDARG;
	}
	if(!IncreaseArraySize(1)) {
		return E_OUTOFMEMORY;
	}
	ValueCopy = SysAllocStringLen(pString,SysStringLen(pString));
	if(!ValueCopy) {
		return E_OUTOFMEMORY;
	}
	for(c=Count;c>Index;c--) {
		pMultiStrings[c] = pMultiStrings[c-1];
	}	
	pMultiStrings[Index] = ValueCopy;
	Count++;

	return S_OK;
}

HRESULT CStrings::GetMultiSz(LPWSTR *pResult, DWORD *pSize)
{
	//
	// get a multi-sz buffer from this list of strings
	//
	DWORD c;
	DWORD buflen = 1;
	DWORD actlen = 0;
	LPWSTR buffer = NULL;
	for(c=0;c<Count;c++) {
		//
		// estimate buffer size
		//
		DWORD ellen = SysStringLen(pMultiStrings[c]);
		if(ellen) {
			buflen += ellen+1;
		}
	}
	buffer = new WCHAR[buflen];
	if(!buffer) {
		return E_OUTOFMEMORY;
	}
	for(c=0;c<Count;c++) {
		//
		// first NULL of string might be inside string
		// in such a case, terminate string there
		//
		DWORD ellen = wcslen(pMultiStrings[c]);
		if(ellen == 0) {
			continue;
		}
		memcpy(buffer+actlen,pMultiStrings[c],ellen*sizeof(WCHAR));
		actlen += ellen;
		buffer[actlen++] = 0;
	}
	buffer[actlen++] = 0;
	*pResult = buffer;
	*pSize = actlen;
	return S_OK;
}

HRESULT CStrings::FromMultiSz(LPCWSTR pMultiSz)
{
	//
	// append to list from multi-sz
	// usually used with a temporary/new CStrings
	//
	DWORD len = 0;
	HRESULT hr;
	for(;*pMultiSz;pMultiSz+=len+1) {
		len = wcslen(pMultiSz);
		hr = InternalAdd(pMultiSz,len);
		if(FAILED(hr)) {
			return hr;
		}
	}
	return S_OK;
}

HRESULT CStrings::GetIndex(VARIANT *Index, DWORD *pAt)
{
	CComVariant v;
	HRESULT hr;
	if(IsNumericVariant(Index)) {
		hr = v.ChangeType(VT_I4,Index);
		if(FAILED(hr)) {
			return DISP_E_TYPEMISMATCH;
		}
		if(V_I4(&v)<1) {
			return E_INVALIDARG;
		}
		*pAt = ((DWORD)V_I4(&v))-1;
		return S_OK;
	}
	//
	// user actually supplied instance id
	//
	hr = v.ChangeType(VT_BSTR,Index);
	if(FAILED(hr)) {
		return DISP_E_TYPEMISMATCH;
	}
	if(!Count) {
		//
		// cannot match anything
		//
		return E_INVALIDARG;
	}
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(wcscmp(pMultiStrings[c],V_BSTR(&v))==0) {
			*pAt = c;
			return S_OK;
		}
	}
	//
	// none found, run through again ignoring case
	//
	if(!IsCaseSensative) {
		for(c=0;c<Count;c++) {
			if(_wcsicmp(pMultiStrings[c],V_BSTR(&v))==0) {
				*pAt = c;
				return S_OK;
			}
		}
	}

	//
	// still none found
	//
	return E_INVALIDARG;
}

BOOL CStrings::InternalEnum(DWORD index,BSTR *pNext)
{
	//
	// note that pNext returned is not a unique string
	//
	if(index>=Count) {
		return FALSE;
	}
	*pNext = pMultiStrings[index];
	return TRUE;
}

STDMETHODIMP CStrings::Find(BSTR name, long *pFound)
{
	//
	// find an existing device that matches this
	//
	DWORD c;
	for(c=0;c<Count;c++) {
		if(wcscmp(pMultiStrings[c],name)==0) {
			*pFound = (long)(c+1);
			return S_OK;
		}
	}
	//
	// none found, run through again ignoring case
	//
	if(!IsCaseSensative) {
		for(c=0;c<Count;c++) {
			if(_wcsicmp(pMultiStrings[c],name)==0) {
				*pFound = (long)(c+1);
				return S_OK;
			}
		}
	}

	*pFound = 0;
	return S_FALSE;
}

STDMETHODIMP CStrings::get_CaseSensative(VARIANT_BOOL *pVal)
{
	*pVal = IsCaseSensative ? VARIANT_TRUE : VARIANT_FALSE;
	return S_OK;
}

STDMETHODIMP CStrings::put_CaseSensative(VARIANT_BOOL newVal)
{
	IsCaseSensative = newVal ? VARIANT_TRUE : VARIANT_FALSE;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devprop\devprop.c ===
#include "precomp.h"
#pragma hdrstop

//
//  Format:  devprop <Enumerator | DeviceId | *> [-m <MachineName>]
//

TCHAR DevPropTable[][34] = {
                            TEXT("SPDRP_DEVICEDESC"),
                            TEXT("SPDRP_HARDWAREID"),
                            TEXT("SPDRP_COMPATIBLEIDS"),
                            TEXT("SPDRP_UNUSED0"),
                            TEXT("SPDRP_SERVICE"),
                            TEXT("SPDRP_UNUSED1"),
                            TEXT("SPDRP_UNUSED2"),
                            TEXT("SPDRP_CLASS"),
                            TEXT("SPDRP_CLASSGUID"),
                            TEXT("SPDRP_DRIVER"),
                            TEXT("SPDRP_CONFIGFLAGS"),
                            TEXT("SPDRP_MFG"),
                            TEXT("SPDRP_FRIENDLYNAME"),
                            TEXT("SPDRP_LOCATION_INFORMATION"),
                            TEXT("SPDRP_PHYSICAL_DEVICE_OBJECT_NAME"),
                            TEXT("SPDRP_CAPABILITIES"),
                            TEXT("SPDRP_UI_NUMBER"),
                            TEXT("SPDRP_UPPERFILTERS"),
                            TEXT("SPDRP_LOWERFILTERS"),
                            TEXT("SPDRP_BUSTYPEGUID"),
                            TEXT("SPDRP_LEGACYBUSTYPE"),
                            TEXT("SPDRP_BUSNUMBER"),
                            TEXT("SPDRP_ENUMERATOR_NAME"),
                            TEXT("SPDPR_SECURITY"),
                            TEXT("SPDRP_SECURITY_SDS"),
                            TEXT("SPDRP_DEVTYPE"),
                            TEXT("SPDRP_EXCLUSIVE"),
                            TEXT("SPDRP_CHARACTERISTICS"),
                            TEXT("SPDRP_ADDRESS"),
                            TEXT("SPDRP_UI_NUMBER_DESC_FORMAT")
                         };

int
__cdecl
_tmain(
    IN int    argc,
    IN PTCHAR argv[]
    )
{
    TCHAR DeviceId[MAX_DEVICE_ID_LEN];
    TCHAR MachineName[SP_MAX_MACHINENAME_LENGTH];
    int CharsInUnicodeString;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD Err;
    DWORD i, j, k, RegDataType, BufferSize;
    BYTE Buffer[1024];
    LPCTSTR CurString;
    LPCTSTR MachineNameString = NULL;
    BOOL OpenSpecificDevice = FALSE;

    if((argc < 2) || !lstrcmp(argv[1], TEXT("-?")) || !lstrcmp(argv[1], TEXT("/?"))) {
        _tprintf(TEXT("Usage:  devprop <Enumerator | DeviceId | *> [-m <MachineName>]\n"));
        return -1;
    }

    //
    // The user specified either an enumerator name, a specific device ID, or a
    // wildcard ('*').  We can tell the difference between the first two based
    // on whether or not there's a path separator character in the string.
    //

    if(lstrlen(argv[1]) >= MAX_DEVICE_ID_LEN) {
        _tprintf(TEXT("DeviceId must be less than %d characters.\n"), MAX_DEVICE_ID_LEN);
        return -1;
    }
    lstrcpyn(DeviceId, argv[1], MAX_DEVICE_ID_LEN);

    if((lstrlen(DeviceId) == 1) && (*DeviceId == TEXT('*'))) {
        //
        // The wildcard character ('*') was specified--process all devices
        //
        CurString = NULL;

    } else if(_tcschr(DeviceId, TEXT('\\'))) {
        //
        // This device has a path separator character--assume it's a valid
        // device id.
        //
        OpenSpecificDevice = TRUE;

    } else {
        //
        // Assume this string is an enumerator name.
        //
        CurString = DeviceId;
    }

    //
    // See if the user pointed us at a remote machine via the "-m" option.
    //
    if((argc > 3) && !_tcsicmp(argv[2], TEXT("-m"))) {

        if(lstrlen(argv[3]) >= SP_MAX_MACHINENAME_LENGTH) {
            _tprintf(TEXT("Machine name must be less than %d characters.\n"), SP_MAX_MACHINENAME_LENGTH);
            return -1;
        }
        lstrcpy(MachineName, argv[3]);

        MachineNameString = MachineName;
    }

    if(OpenSpecificDevice) {
        //
        // Create an HDEVINFO set, and open up a device information element for the specified
        // device within that set.
        //
        DeviceInfoSet = SetupDiCreateDeviceInfoListEx(NULL, NULL, MachineNameString, NULL);
        if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
            _tprintf(TEXT("SetupDiCreateDeviceInfoList failed with %lx\n"), GetLastError());
            return -1;
        }

        if(!SetupDiOpenDeviceInfo(DeviceInfoSet,
                                  DeviceId,
                                  NULL,
                                  0,
                                  NULL)) {

            Err = GetLastError();
            _tprintf(TEXT("SetupDiOpenDeviceInfo failed with %lx\n"), Err);
            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
            return -1;
        }

    } else {
        DeviceInfoSet = SetupDiGetClassDevsEx(NULL,
                                              CurString,
                                              NULL,
                                              DIGCF_ALLCLASSES,
                                              NULL,
                                              MachineNameString,
                                              NULL
                                             );

        if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
            _tprintf(TEXT("SetupDiGetClassDevs failed with %lx\n"), GetLastError());
            return -1;
        }
    }

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    for(i = 0;
        SetupDiEnumDeviceInfo(DeviceInfoSet, i, &DeviceInfoData);
        i++)
    {
        SetupDiGetDeviceInstanceId(DeviceInfoSet,
                                   &DeviceInfoData,
                                   DeviceId,
                                   MAX_DEVICE_ID_LEN,
                                   NULL
                                  );

        _tprintf(TEXT("For device \"%s\"\n"), DeviceId);

        for(j = 0; j < (sizeof(DevPropTable) / sizeof(DevPropTable[0])); j++) {

            _tprintf(TEXT("  %s : ("), DevPropTable[j]);

            if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                &DeviceInfoData,
                                                j,
                                                &RegDataType,
                                                Buffer,
                                                sizeof(Buffer),
                                                &BufferSize)) {
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }

            if(Err == NO_ERROR) {

                switch(RegDataType) {

                    case REG_SZ :
                        _tprintf(TEXT("REG_SZ:%d) \"%s\"\n"),
                                 BufferSize,
                                 (LPCTSTR)Buffer
                                );
                        break;

                    case REG_MULTI_SZ :
                        _tprintf(TEXT("REG_MULTI_SZ:%d)"), BufferSize);
                        for(CurString = (LPCTSTR)Buffer;
                            *CurString;
                            CurString += lstrlen(CurString) + 1) {

                            _tprintf(TEXT(" \"%s\""), CurString);
                        }
                        _tprintf(TEXT("\n"));
                        break;

                    case REG_DWORD :
                        _tprintf(TEXT("REG_DWORD:%d) %lx\n"),
                                 BufferSize,
                                 *((PDWORD)Buffer)
                                );
                        break;

                    case REG_BINARY :
                        _tprintf(TEXT("REG_BINARY:%d)"), BufferSize);
                        for(k = 0; k < BufferSize; k++) {
                            _tprintf(TEXT(" %lx"), Buffer[k]);
                        }
                        _tprintf(TEXT("\n"));
                        break;

                    default :
                        _tprintf(TEXT("Registry data type %lx:%d)\n"),
                                 RegDataType,
                                 BufferSize
                                );
                }

            } else {
                _tprintf(TEXT("Error %lx)\n"), Err);
            }


        }
    }

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devcon2\stringsenum.cpp ===
// StringsEnum.cpp : Implementation of CDevCon2App and DLL registration.

#include "stdafx.h"
#include "DevCon2.h"
#include "StringsEnum.h"

/////////////////////////////////////////////////////////////////////////////
//

CStringsEnum::~CStringsEnum()
{
	DWORD c;
	if(pMultiStrings) {
		for(c=0;c<Count;c++) {
			SysFreeString(pMultiStrings[c]);
		}
		delete [] pMultiStrings;
	}
}


HRESULT CStringsEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	ULONG i;
	BSTR b;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		b = SysAllocStringLen(pMultiStrings[Position],SysStringLen(pMultiStrings[Position]));
		if(!b) {
			for(i=0;i<fetched;i++) {
				VariantClear(&rgVar[i]);
			}
			return E_OUTOFMEMORY;
		}
		V_VT(&rgVar[fetched]) = VT_BSTR;
		V_BSTR(&rgVar[fetched]) = b;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CStringsEnum::Skip(
                ULONG celt
            )
{
	DWORD remaining = Count-Position;
	if(remaining<celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (DWORD)celt;
		return S_OK;
	}
}

HRESULT CStringsEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CStringsEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CStringsEnum> *pEnum = NULL;
	hr = CComObject<CStringsEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->CopyStrings(pMultiStrings,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}

BOOL CStringsEnum::CopyStrings(BSTR *pArray, DWORD NewCount)
{
	DWORD c;

	if(pMultiStrings) {
		delete [] pMultiStrings;
		pMultiStrings = NULL;
	}
	Count = 0;
	Position = 0;
	pMultiStrings = new BSTR[NewCount];
	if(!pMultiStrings) {
		return FALSE;
	}
	for(c=0;c<NewCount;c++) {
		pMultiStrings[c] = SysAllocStringLen(pArray[c],SysStringLen(pArray[c]));
		if(!pMultiStrings[c]) {
			Count = c;
			return FALSE;
		}
	}
	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\devprop\precomp.h ===
#include "devprop.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\dock\dock.h ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    DOCK.H

Abstract:

    This module contains the common private declarations for the undock tester


Author:

    Kenneth Ray

Environment:

    User Mode Only

Notes:


Revision History:

    Created June 98

--*/

#ifndef DOCK_H
#define DOCK_H


#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4705)   // Statement has no effect


#define MIN(_A_,_B_) (((_A_) < (_B_)) ? (_A_) : (_B_))


//
// Prototypes
//




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\drvlist\drvlist.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <setupapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\drvlist\drvlist.c ===
#include "precomp.h"
#pragma hdrstop
#include <initguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

//
// Define the size (in characters) of a GUID string, including terminating NULL.
//
#define GUID_STRING_LEN (39)

//
// Define a global variable to hold the source path to be used.
//
TCHAR SourcePath[MAX_PATH];

//
// Define a file enumeration callback prototype.
// (Used by pSysSetupEnumerateFiles)
//
typedef BOOL (*PFILEENUM_CALLBACK) (
    IN     PCTSTR,
    IN OUT PVOID
    );

//
// Private function prototypes:
//
BOOL
PrecompileSingleInf(
    IN     PCTSTR FullInfPath,
    IN OUT PVOID  Context
    );

BOOL
DeleteSinglePnf(
    IN     PCTSTR FullPnfPath,
    IN OUT PVOID  Context
    );

VOID
pSysSetupEnumerateFiles(
    IN OUT PWSTR              SearchSpec,
    IN     PFILEENUM_CALLBACK FileEnumCallback,
    IN OUT PVOID              Context
    );

#if 1
UINT
FileQueueScanCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );
#else
UINT
DriverListMsgHandler(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    );
#endif

DWORD
FilesFromInfSectionAndNeededSections(
    IN HINF              InfHandle,
    IN PCTSTR            InfPath,
    IN PCTSTR            SectionName,
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    );

BOOL
GetActualSectionToInstallEx(
    IN  HINF                    InfHandle,
    IN  PCTSTR                  InfSectionName,
    IN  WORD                    ProcessorArchitecture,
    OUT PTSTR                   InfSectionWithExt,
    IN  DWORD                   InfSectionWithExtSize
    );

VOID
Usage(
    VOID
    );

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    int StringLen;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD Err = NO_ERROR;
    DWORD i;
    SP_DRVINFO_DATA DriverInfoData;
    HSPFILEQ QueueHandle = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    DWORD ScanResult;
//    SP_DRVINSTALL_PARAMS DriverInstallParams;
    TCHAR SearchSpec[MAX_PATH];
    BOOL CacheEnable;
    BOOL DontCallClassInstaller = FALSE;
    BOOL NonNativeSearch = FALSE;
    BOOL IncludeInfsInList = FALSE;
    BOOL DownLevel = FALSE;
    TCHAR CertClassInfPath[MAX_PATH];
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    TCHAR TargetInfDirectory[MAX_PATH];
    TCHAR ActualSectionName[LINE_LEN];
    TCHAR ActualSectionName2[LINE_LEN];
    PTSTR p;
    LONG GuidIndex, ClassGuidCount = 0;
    HINF hInf;
    LPGUID ClassGuidList = NULL;
    INFCONTEXT InfContext;
    TCHAR GuidStringBuffer[GUID_STRING_LEN];
    HRESULT hr;
    SP_ALTPLATFORM_INFO_V1 AltPlatformInfo;
    ULONG Ver = 0;

    ZeroMemory(&AltPlatformInfo,sizeof(AltPlatformInfo));
    AltPlatformInfo.cbSize = sizeof(AltPlatformInfo);
    //
    // Process any optional arguments that may precede the (non-optional)
    // SourcePath.
    //
    *CertClassInfPath = TEXT('\0');

    for(i = 1; i < (DWORD)argc; i++) {

        if((*(argv[i]) != TEXT('/')) && (*(argv[i]) != TEXT('-'))) {
            break;
        }

        if(!(*(argv[i]+1)) || *(argv[i]+2)) {
            Usage();
            return -1;
        }

        switch(*(argv[i]+1)) {

            case 'H' :
            case 'h' :
            case '?' :
                //
                // Display usage help
                //
                Usage();
                return -1;

            case 'S' :
            case 's' :
                //
                // Skip class-/co-installers, queue files directly from INF
                //
                DontCallClassInstaller = TRUE;
                break;

            case 'F' :
            case 'f' :
                //
                // Filter the list based on the INF in the next argument
                //
                i++;

                if(i == (DWORD)argc) {
                    Usage();
                    return -1;
                }

#ifdef UNICODE

                StringLen = MultiByteToWideChar(CP_ACP,
                                                MB_PRECOMPOSED,
                                                argv[i],
                                                -1,
                                                CertClassInfPath,
                                                sizeof(CertClassInfPath) / sizeof(WCHAR)
                                               );
                if(!StringLen) {
                    _tprintf(TEXT("CertClassInfPath must be less than %d characters.\n"), MAX_PATH);
                    return -1;
                }

#else // !UNICODE

                StringLen = lstrlen(argv[i]);
                if(StringLen >= MAX_PATH) {
                    _tprintf(TEXT("CertClassInfPath must be less than %d characters.\n"), MAX_PATH);
                    return -1;
                }
                CopyMemory(CertClassInfPath, argv[i], StringLen);

#endif // !UNICODE

                //
                // Now open this INF and retrieve all the GUIDs contained in the
                // [DriverSigningClasses] section.
                //
                hInf = SetupOpenInfFile(CertClassInfPath,
                                        NULL,
                                        INF_STYLE_WIN4,
                                        NULL
                                       );

                if(hInf == INVALID_HANDLE_VALUE) {
                    _tprintf(TEXT("SetupOpenInfFile failed with %lx\n"), GetLastError());
                    return -1;
                }

                ClassGuidCount = SetupGetLineCount(hInf, TEXT("DriverSigningClasses"));

                if(ClassGuidCount < 0) {
                    _tprintf(TEXT("CertClassInf specified doesn't contain a [DriverSigningClasses] section\n"));
                    return -1;
                }

                if(!ClassGuidCount) {
                    //
                    // No classes in the section--nothing to do.
                    //
                    return 0;
                }

                ClassGuidList = malloc(ClassGuidCount * sizeof(GUID));

                if(!ClassGuidList) {
                    _tprintf(TEXT("Out of memory\n"));
                    return -1;
                }

                for(GuidIndex = 0; GuidIndex < ClassGuidCount; GuidIndex++) {
                    if(!SetupGetLineByIndex(hInf,
                                            TEXT("DriverSigningClasses"),
                                            GuidIndex,
                                            &InfContext)) {
                        _tprintf(TEXT("SetupGetLineByIndex failed with %lx\n"), GetLastError());
                        return -1;
                    }

                    if(!SetupGetStringField(&InfContext,
                                            0,
                                            GuidStringBuffer,
                                            sizeof(GuidStringBuffer) / sizeof(TCHAR),
                                            NULL)) {

                        _tprintf(TEXT("SetupGetStringField failed with %lx\n"), GetLastError());
                        return -1;
                    }

                    hr = CLSIDFromString(GuidStringBuffer, &(ClassGuidList[GuidIndex]));

                    if(FAILED(hr)) {
                        _tprintf(TEXT("CLSIDFromString failed with %lx\n"), hr);
                        return -1;
                    }
                }

                //
                // We're finished with the INF.
                //
                SetupCloseInfFile(hInf);
                break;

            case 'A' :
            case 'a' :
                //
                // Target Architecture
                // 0 = Intel x86
                // 6 = IA64
                // 9 = AMD64
                //
                i++;

                if(i == (DWORD)argc) {
                    Usage();
                    return -1;
                }
                AltPlatformInfo.ProcessorArchitecture = (WORD)strtoul(argv[i],NULL,0);
                NonNativeSearch = TRUE;

                break;

            case 'V' :
            case 'v' :
                //
                // Version, eg 5.1
                //
                i++;

                if(i == (DWORD)argc) {
                    Usage();
                    return -1;
                }
                Ver = strtoul(argv[i],NULL,16);
                AltPlatformInfo.MajorVersion = HIBYTE(Ver);
                AltPlatformInfo.MinorVersion = LOBYTE(Ver);
                NonNativeSearch = TRUE;
                break;

            case 'I' :
            case 'i' :
                //
                // Include INFs in the list
                //
                IncludeInfsInList = TRUE;

                //
                // Retrieve the location of the INF directory, so when we add
                // the INFs to the copy queue it reports the proper path for
                // their destination.
                //
                StringLen = GetSystemWindowsDirectory(
                                TargetInfDirectory, 
                                sizeof(TargetInfDirectory) / sizeof(TCHAR)
                                );

                if(!StringLen) {
                    _tprintf(TEXT("GetSystemWindowsDirectory failed with %lx\n"), GetLastError());
                    return -1;
                }

                if(StringLen >= (sizeof(TargetInfDirectory) / sizeof(TCHAR))) {
                    _tprintf(TEXT("GetSystemWindowsDirectory requires a larger buffer than we supplied\n"));
                    return -1;
                }

                if(TargetInfDirectory[StringLen - 1] != TEXT('\\')) {
                    TargetInfDirectory[StringLen++] = TEXT('\\');
                }
                lstrcpyn(TargetInfDirectory + StringLen,
                         TEXT("INF"),
                         (sizeof(TargetInfDirectory) / sizeof(TCHAR)) - StringLen
                        );
                break;

            default :
                //
                // Invalid option
                //
                Usage();
                return -1;
        }
    }

    //
    // We should have processed all arguments except the last one, which should
    // contain the SourcePath.
    //
    if(i != ((DWORD)argc - 1)) {
        Usage();
        return -1;
    }

#ifdef UNICODE

    StringLen = MultiByteToWideChar(CP_ACP,
                                    MB_PRECOMPOSED,
                                    argv[i],
                                    -1,
                                    SourcePath,
                                    sizeof(SourcePath) / sizeof(WCHAR)
                                   );
    if(!StringLen) {
        _tprintf(TEXT("SourcePath must be less than %d characters.\n"), MAX_PATH);
        return -1;
    }

    //
    // We don't want StringLen to include the terminating null character.
    //
    StringLen--;

#else // !UNICODE

    StringLen = lstrlen(argv[i]);
    if(!StringLen) {
        _tprintf(TEXT("SourcePath cannot be an empty string.\n"));
        return -1;
    }
    if(StringLen >= MAX_PATH) {
        _tprintf(TEXT("SourcePath must be less than %d characters.\n"), MAX_PATH);
        return -1;
    }
    CopyMemory(SourcePath, argv[i], StringLen);

#endif // !UNICODE

    if(NonNativeSearch) {
        //
        // fix up platform information
        //
        AltPlatformInfo.Platform = VER_PLATFORM_WIN32_NT;
        if(!Ver) {
            AltPlatformInfo.MajorVersion = HIBYTE(_WIN32_WINNT);
            AltPlatformInfo.MinorVersion = LOBYTE(_WIN32_WINNT);
        }
        AltPlatformInfo.Reserved = 0;
    }
    //
    // Precompile all INFs in the specified directory (we'll delete the PNFs
    // when we're done).
    //
    CopyMemory(SearchSpec, SourcePath, StringLen * sizeof(TCHAR));
    if(SearchSpec[StringLen - 1] != TEXT('\\')) {
        SearchSpec[StringLen++] = TEXT('\\');
    }

    lstrcpyn(SearchSpec + StringLen,
             TEXT("*.INF"),
             (sizeof(SearchSpec) / sizeof(TCHAR)) - StringLen
            );

    CacheEnable = TRUE;
    pSysSetupEnumerateFiles(SearchSpec, PrecompileSingleInf, &CacheEnable);

    //
    // Create an HDEVINFO set to contain our placeholder device.
    //
    DeviceInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
        _tprintf(TEXT("SetupDiCreateDeviceInfoList failed with %lx\n"), GetLastError());
        return -1;
    }

    //
    // Now create the placeholder device for which each driver node will be selected/analyzed.
    //
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if(!SetupDiCreateDeviceInfo(DeviceInfoSet,
                                TEXT("DRIVER_LIST_PLACEHOLDER"),
                                (LPGUID)&GUID_NULL,
                                NULL,
                                NULL,
                                DICD_GENERATE_ID,
                                &DeviceInfoData)) {
        Err = GetLastError();
        _tprintf(TEXT("SetupDiCreateDeviceInfo failed with %lx\n"), Err);
        goto clean0;
    }

    //
    // Create file queue here before search so that we can associate a different
    // platform with the search
    //
    QueueHandle = SetupOpenFileQueue();

    if(QueueHandle == INVALID_HANDLE_VALUE) {
        //
        // This can only happen due to out-of-memory, and GetLastError() actually isn't even
        // being set currently in this case.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        _tprintf(TEXT("SetupOpenFileQueue failed with %lx\n"), Err);
        goto clean0;
    }

    if(NonNativeSearch) {
        if(!SetupSetFileQueueAlternatePlatform(QueueHandle,(PSP_ALTPLATFORM_INFO)&AltPlatformInfo,NULL)) {
            DownLevel = TRUE;
        }
    }

    //
    // Redirect our driver search to look in the specified directory.
    // specify file queue that we'll use to base search on
    // and use for all cumulative installs
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if(!SetupDiGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        _tprintf(TEXT("SetupDiGetDeviceInstallParams (1st time) failed with %lx\n"), Err);
        goto clean0;
    }

    //
    // specify search path
    //
    lstrcpy(DeviceInstallParams.DriverPath, SourcePath);
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;
    //
    // specify file queue to search
    //
    DeviceInstallParams.FileQueue = QueueHandle;
    DeviceInstallParams.Flags |= DI_NOVCP;

    if(!SetupDiSetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        _tprintf(TEXT("SetupDiSetDeviceInstallParams (1st time) failed with %lx\n"), Err);
        goto clean0;
    }
    //
    // other flags we desire to have
    //
    if(NonNativeSearch && !DownLevel) {
        //
        // if we can, try to make use of DI_FLAGSEX_ALTPLATFORM_DRVSEARCH
        // this supports manufacturer decoration
        //
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
        if(!SetupDiSetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams)) {
            DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_ALTPLATFORM_DRVSEARCH;
            DownLevel = TRUE;
        }
    }
    //
    // if we can, try to make use of DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE
    // this ensures we look at duplicate nodes (which is broken in itself)
    //
    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE;
    if(!SetupDiSetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams)) {
        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE;
    }

    //
    // Now build a class driver list with every driver node we support.
    //
    if(!SetupDiBuildDriverInfoList(DeviceInfoSet, &DeviceInfoData, SPDIT_CLASSDRIVER)) {
        Err = GetLastError();
        _tprintf(TEXT("SetupDiBuildDriverInfoList failed with %lx\n"), Err);
        goto clean0;
    }

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    for(i = 0;
        SetupDiEnumDriverInfo(DeviceInfoSet,
                              &DeviceInfoData,
                              SPDIT_CLASSDRIVER,
                              i,
                              &DriverInfoData);
        i++) {

        if(!SetupDiSetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData)) {
            Err = GetLastError();
            _tprintf(TEXT("SetupDiSetSelectedDriver failed with %lx\n"), Err);
            goto clean1;
        }

        //
        // The device information element's class GUID will have automatically
        // been updated by SetupDiSetSelectedDriver to reflect the class of the
        // driver node's INF.  If we're supposed to filter based on a certclas.inf,
        // then check to make sure that this class is in our list.
        //
        if(ClassGuidCount) {

            for(GuidIndex = 0; GuidIndex < ClassGuidCount; GuidIndex++) {

                if(IsEqualGUID(&(DeviceInfoData.ClassGuid), &(ClassGuidList[GuidIndex]))) {
                    break;
                }
            }

            if(GuidIndex == ClassGuidCount) {
                //
                // Then we didn't find the class GUID in our list--skip this
                // driver node.
                //
                continue;
            }
        }

        //
        // If we're also supposed to include the INFs in our list of driver
        // files, then retrieve the detailed driver info to find out what INF
        // is associated with this driver node.
        //
        if(IncludeInfsInList) {

            DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

            if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                           &DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInfoDetailData,
                                           sizeof(DriverInfoDetailData),
                                           NULL)) {
                //
                // If we failed with ERROR_INSUFFICIENT_BUFFER, then that's OK.
                //
                Err = GetLastError();
                if(Err != ERROR_INSUFFICIENT_BUFFER) {
                    _tprintf(TEXT("SetupDiGetDriverInfoDetail failed with %lx\n"), Err);
                    goto clean1;
                }
            }

            //
            // OK, now that we have the INF name, add it to our queue.
            //
            p = _tcsrchr(DriverInfoDetailData.InfFileName, TEXT('\\'));
            if(!p || !(*(++p))) {
                _tprintf(TEXT("Invalid INF name encountered\n"));
                goto clean1;
            }

            if(!SetupQueueCopy(QueueHandle,
                               SourcePath,
                               NULL,
                               p,
                               NULL,
                               NULL,
                               TargetInfDirectory,
                               p,
                               0)) {

                Err = GetLastError();
                _tprintf(TEXT("SetupQueueCopy failed with %lx\n"), Err);
                goto clean1;
            }

        }

        if(NonNativeSearch) {
            //
            // have to go around the houses here
            // since SetupDiInstallDriverFiles does not support alternate platform
            //
            DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

            if(!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                           &DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInfoDetailData,
                                           sizeof(DriverInfoDetailData),
                                           NULL)) {
                //
                // If we failed with ERROR_INSUFFICIENT_BUFFER, then that's OK.
                //
                Err = GetLastError();
                if(Err != ERROR_INSUFFICIENT_BUFFER) {
                    _tprintf(TEXT("SetupDiGetDriverInfoDetail failed with %lx\n"), Err);
                    goto clean1;
                }
            }
            hInf = SetupOpenInfFile(DriverInfoDetailData.InfFileName,NULL,INF_STYLE_WIN4,NULL);
            if(hInf == INVALID_HANDLE_VALUE) {
                _tprintf(TEXT("SetupOpenInfFile %s failed with %lx\n"),DriverInfoDetailData.InfFileName, GetLastError());
                goto clean1;
            }
            if(!GetActualSectionToInstallEx(hInf,
                                            DriverInfoDetailData.SectionName,
                                            AltPlatformInfo.ProcessorArchitecture,
                                            ActualSectionName,
                                            LINE_LEN)) {
                Err = GetLastError();
                _tprintf(TEXT("GetActualSectionToInstallEx failed with %lx\n"), Err);
                goto clean1;
            }
            Err = FilesFromInfSectionAndNeededSections(hInf,
                                                       SourcePath,
                                                       ActualSectionName,
                                                       DeviceInfoSet,
                                                       &DeviceInfoData,
                                                       QueueHandle);
            if(Err) {
                _tprintf(TEXT("FilesFromInfSectionAndNeededSections failed with %lx\n"), Err);
                goto clean1;
            }
            lstrcpy(ActualSectionName2,ActualSectionName);
            lstrcat(ActualSectionName2,TEXT(".CoInstallers"));
            Err = FilesFromInfSectionAndNeededSections(hInf,
                                                       SourcePath,
                                                       ActualSectionName2,
                                                       DeviceInfoSet,
                                                       &DeviceInfoData,
                                                       QueueHandle);
            if(Err) {
                _tprintf(TEXT("FilesFromInfSectionAndNeededSections failed with %lx\n"), Err);
                goto clean1;
            }
            lstrcpy(ActualSectionName2,ActualSectionName);
            lstrcat(ActualSectionName2,TEXT(".Interfaces"));
            Err = FilesFromInfSectionAndNeededSections(hInf,
                                                       SourcePath,
                                                       ActualSectionName2,
                                                       DeviceInfoSet,
                                                       &DeviceInfoData,
                                                       QueueHandle);
            if(Err) {
                _tprintf(TEXT("FilesFromInfSectionAndNeededSections failed with %lx\n"), Err);
                goto clean1;
            }
            //
            // done
            //
            SetupCloseInfFile(hInf);
        } else if(DontCallClassInstaller) {
            //
            // appeneded to the queue we've associated with DeviceInfoSet
            //
            if(!SetupDiInstallDriverFiles(DeviceInfoSet, &DeviceInfoData)) {
                Err = GetLastError();
                _tprintf(TEXT("SetupDiInstallDriverFiles failed with %lx\n"), Err);
                goto clean1;
            }
        } else {
            if(!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, DeviceInfoSet, &DeviceInfoData)) {
                Err = GetLastError();
                _tprintf(TEXT("SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES) failed with %lx\n"), Err);
                goto clean1;
            }
        }
    }

    //
    // OK, now we've got all the file operations in our file queue.  Now scan
    // the file queue and print out each file to be copied.
    //
    if(!SetupScanFileQueue(QueueHandle,
                           SPQ_SCAN_USE_CALLBACKEX|SPQ_SCAN_FILE_PRESENCE,
                           NULL,
                           FileQueueScanCallback,
                           NULL,
                           &ScanResult)) {
        //
        // Might have been because SPQ_SCAN_FILE_PRESENCE combo not understood
        // try as a 2nd resort...
        //
        if(!SetupScanFileQueue(QueueHandle,
                               SPQ_SCAN_USE_CALLBACKEX,
                               NULL,
                               FileQueueScanCallback,
                               NULL,
                               &ScanResult)) {
            Err = GetLastError();
            _tprintf(TEXT("SetupScanFileQueue failed with %lx\n"), Err);
            goto clean1;
        }
    }

    //
    // We're done!  We've successfully printed out all files that are installed by this driver
    // node.
    //

clean1:



clean0:

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    if (QueueHandle != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(QueueHandle);
    }

    //
    // Clean up PNFs.
    //
    lstrcpy(SearchSpec + StringLen, TEXT("*.PNF"));
    pSysSetupEnumerateFiles(SearchSpec, DeleteSinglePnf, NULL);

    return ((Err == NO_ERROR) ? 0 : -1);
}


VOID
pSysSetupEnumerateFiles(
    IN OUT PWSTR              SearchSpec,
    IN     PFILEENUM_CALLBACK FileEnumCallback,
    IN OUT PVOID              Context
    )
/*++

Routine Description:

    This routine enumerates every (non-directory) file matching the specified wildcard, and
    passes the filename (w/path) to the specified callback, along with the caller-supplied
    context.

Arguments:

    SearchSpec - Specifies the files to be enumerated (e.g., "C:\WINNT\INF\*.INF").
        The character buffer pointed to must be at least MAX_PATH characters large.
        THIS BUFFER IS USED AS WORKING SPACE BY THIS ROUTINE, AND ITS CONTENTS WILL
        BE MODIFIED!

    FileEnumCallback - Supplies the address of the callback routine to be called for each
        file enumerated.  The prototype of this function is:

            typedef BOOL (*PFILEENUM_CALLBACK) {
                IN     PCTSTR Filename,
                IN OUT PVOID  Context
                );

        (Returning TRUE from the callback continues enumeration, FALSE aborts it.)

    Context - Supplies a context that is passed to the callback for each file.

Return Value:

    None.

--*/
{
    PWSTR FilenameStart;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    FilenameStart = _tcsrchr(SearchSpec, TEXT('\\'));
    FilenameStart++;

    if((FindHandle = FindFirstFile(SearchSpec, &FindData)) != INVALID_HANDLE_VALUE) {

        do {
            //
            // Skip directories
            //
            if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                continue;
            }

            //
            // Form full pathname of file in SearchSpec.
            //
            lstrcpy(FilenameStart, FindData.cFileName);

            //
            // Call the callback for this file.
            //
            if(!FileEnumCallback(SearchSpec, Context)) {
                //
                // Callback aborted enumeration.
                //
                break;
            }

        } while(FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }
}


BOOL
PrecompileSingleInf(
    IN     PCTSTR FullInfPath,
    IN OUT PVOID  Context
    )
/*++

Routine Description:

    This routine precompiles the specified INF.

Arguments:

    FullInfPath - Supplies the name of the INF to be precompiled.

    Context - Supplies a pointer to a boolean.  If non-zero, caching is enabled,
        otherwise it's disabled (i.e., the corresponding PNF is deleted).

Return Value:

    TRUE to continue enumeration, FALSE to abort it (we always return TRUE).

--*/
{
    HINF hInf;

    hInf = SetupOpenInfFile(FullInfPath,
                            NULL,
                            INF_STYLE_WIN4 | (*((PBOOL)Context) ? INF_STYLE_CACHE_ENABLE : INF_STYLE_CACHE_DISABLE),
                            NULL
                           );

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    return TRUE;
}


BOOL
DeleteSinglePnf(
    IN     PCTSTR FullPnfPath,
    IN OUT PVOID  Context
    )
{
    UNREFERENCED_PARAMETER(Context);

    DeleteFile(FullPnfPath);
    return TRUE;
}


#if 1

UINT
FileQueueScanCallback(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    PFILEPATHS FilePaths = (PFILEPATHS)Param1;
    PTSTR Source, Target;

    if(Notification == SPFILENOTIFY_QUEUESCAN_EX) {

#if FULL_FILEPATHS_SPEW
        _tprintf(TEXT("%s -> %s (err %lx, flags %lx)\n"),
                 FilePaths->Source,
                 FilePaths->Target,
                 FilePaths->Win32Error,
                 FilePaths->Flags
                );
#else
        //
        // Get simple filenames for source and target...
        //
        Source = _tcsrchr(FilePaths->Source, TEXT('\\'));
        if(!Source) {
            _tprintf(TEXT("ERROR! Full source path not included for %s--aborting!\n"), FilePaths->Source);
            return ERROR_PATH_NOT_FOUND;
        }

        Target = _tcsrchr(FilePaths->Target, TEXT('\\'));
        if(!Target) {
            _tprintf(TEXT("ERROR! Full target path not included for %s--aborting!\n"), FilePaths->Target);
            return ERROR_PATH_NOT_FOUND;
        }

        Source++;
        Target++;

        _tprintf(TEXT("%s\n"), Source);

#endif // FULL_FILEPATHS_SPEW

    }

    return NO_ERROR;
}

#else

UINT
DriverListMsgHandler(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
{
    UINT ret = FILEOP_SKIP;
    PFILEPATHS FilePaths = (PFILEPATHS)Param1;

    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(Param2);

    if(Notification == SPFILENOTIFY_STARTCOPY) {
        //
        // Print out the source filename...
        //
        _tprintf(TEXT("%s ( "), FilePaths->Source);

        //
        // Now print out any flags set for this copy operation.
        //

        //
        // First, here are the flags that can't come from an INF (but the
        // class installer might have set them)...
        //
        if(FilePaths->Flags & SP_COPY_DELETESOURCE) {
            _tprintf(TEXT("DELETESOURCE "));
        }
        if(FilePaths->Flags & SP_COPY_NOOVERWRITE) {
            _tprintf(TEXT("NOOVERWRITE "));
        }
        if(FilePaths->Flags & SP_COPY_LANGUAGEAWARE) {
            _tprintf(TEXT("LANGUAGEAWARE "));
        }
        if(FilePaths->Flags & SP_COPY_SOURCE_ABSOLUTE) {
            _tprintf(TEXT("SOURCE_ABSOLUTE "));
        }
        if(FilePaths->Flags & SP_COPY_SOURCEPATH_ABSOLUTE) {
            _tprintf(TEXT("SOURCEPATH_ABSOLUTE "));
        }
        if(FilePaths->Flags & SP_COPY_NOBROWSE) {
            _tprintf(TEXT("NOBROWSE "));
        }
        if(FilePaths->Flags & SP_COPY_SOURCE_SIS_MASTER) {
            _tprintf(TEXT("SOURCE_SIS_MASTER "));
        }

        //
        // Now for the flags that are settable via an INF...
        //

        //
        // Did the INF specify the COPYFLG_REPLACEONLY bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_REPLACEONLY) {
            _tprintf(TEXT("REPLACEONLY "));
        }

        //
        // Did the INF specify the COPYFLG_NOVERSIONCHECK bit?  If so, then
        // the SP_COPY_NEWER_OR_SAME bit will be _cleared_.
        // (The class-installer may have also cleared this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_NEWER_OR_SAME) {  // same as SP_COPY_NEWER
            _tprintf(TEXT("NEWER_OR_SAME "));
        }

        //
        // Did the INF specify the COPYFLG_NODECOMP bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_NODECOMP) {
            _tprintf(TEXT("NODECOMP "));
        }

        //
        // Did the INF specify the COPYFLG_FORCE_FILE_IN_USE bit?  If so, then
        // both the SP_COPY_IN_USE_NEEDS_REBOOT and SP_COPY_FORCE_IN_USE flags
        // will be set.
        // (The class-installer may have also set these flags, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_IN_USE_NEEDS_REBOOT) {
            _tprintf(TEXT("IN_USE_NEEDS_REBOOT "));
        }
        if(FilePaths->Flags & SP_COPY_FORCE_IN_USE) {
            _tprintf(TEXT("FORCE_IN_USE "));
        }

        //
        // Did the INF specify the COPYFLG_NOSKIP bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_NOSKIP) {
            _tprintf(TEXT("NOSKIP "));
        }

        //
        // Did the INF specify the COPYFLG_NO_OVERWRITE bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_FORCE_NOOVERWRITE) {
            _tprintf(TEXT("FORCE_NOOVERWRITE "));
        }

        //
        // Did the INF specify the COPYFLG_NO_VERSION_DIALOG bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_FORCE_NEWER) {
            _tprintf(TEXT("FORCE_NEWER "));
        }

        //
        // Did the INF specify the COPYFLG_WARN_IF_SKIP bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_WARNIFSKIP) {
            _tprintf(TEXT("WARNIFSKIP "));
        }

        //
        // Did the INF specify the COPYFLG_OVERWRITE_OLDER_ONLY bit?
        // (The class-installer may have also set this flag, but it's unlikely.)
        //
        if(FilePaths->Flags & SP_COPY_NEWER_ONLY) {
            _tprintf(TEXT("NEWER_ONLY "));
        }

        //
        // Get ready for next line...
        //
        _tprintf(TEXT(")\n"));

    } else if(Notification == SPFILENOTIFY_NEEDMEDIA) {
        lstrcpy((PTSTR)Param2, SourcePath);
        ret = FILEOP_NEWPATH;
    }

    //
    // Since FILEOP_SKIP is a nonzero value, it's OK to always return this.
    //
    return ret;
}

#endif

DWORD
FilesFromInfSectionAndNeededSections(
    IN HINF              InfHandle,
    IN PCTSTR            InfPath,
    IN PCTSTR            SectionName,
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    )
/*++

Routine Description:

    Process Copy directives from specified section
    taking note of Include/Needs

Return Value:

    If successful, the return value is NO_ERROR, otherwise, it is a Win32 error code
    indicating the cause of the failure.

--*/
{
    DWORD FieldIndex, Err;
    INFCONTEXT InfContext;
    BOOL NeedsEntriesToProcess;
    TCHAR SectionToInstall[LINE_LEN];
    TCHAR InfFullPath[MAX_PATH];
    int FileLen;


    //
    // Store the full directory path to where the supplied INF is located, so we
    // can first attempt to append-load the included INFs from that same directory.
    //
    lstrcpyn(InfFullPath, InfPath, MAX_PATH-3);
    FileLen = lstrlen(InfFullPath);
    if((*CharPrev(InfFullPath,InfFullPath+FileLen)!=TEXT('\\')) &&
       (*CharPrev(InfFullPath,InfFullPath+FileLen)!=TEXT('/'))) {
        InfFullPath[FileLen++] = TEXT('\\');
    }

    if(SetupFindFirstLine(InfHandle, SectionName, TEXT("include"), &InfContext)) {

        for(FieldIndex = 1;
            SetupGetStringField(&InfContext,
                                FieldIndex,
                                InfFullPath+FileLen,
                                (DWORD)(MAX_PATH-FileLen),
                                NULL);
            FieldIndex++)
        {
            //
            // Try only full path, if that fails, tough
            //
            SetupOpenAppendInfFile(InfFullPath, InfHandle, NULL);
        }
    }
    SetupOpenAppendInfFile(NULL, InfHandle, NULL);


    lstrcpyn(SectionToInstall, SectionName, LINE_LEN);

    NeedsEntriesToProcess = SetupFindFirstLine(InfHandle,
                                               SectionName,
                                               TEXT("needs"),
                                               &InfContext
                                              );

    Err = NO_ERROR;

    for(FieldIndex = 0; (!FieldIndex || NeedsEntriesToProcess); FieldIndex++) {

        if(FieldIndex) {
            //
            // Get next section name on "needs=" line to be processed.
            //
            if(!SetupGetStringField(&InfContext,
                                    FieldIndex,
                                    SectionToInstall,
                                    LINE_LEN,
                                    NULL)) {
                //
                // We've exhausted all the extra sections we needed to install.
                //
                break;
            }
        }

        SetupInstallFilesFromInfSection(InfHandle,NULL,UserFileQ,SectionToInstall,NULL,0);
    }

    return Err;
}

BOOL
GetActualSectionToInstallEx(
    IN  HINF                    InfHandle,
    IN  PCTSTR                  InfSectionName,
    IN  WORD                    ProcessorArchitecture,
    OUT PTSTR                   InfSectionWithExt,
    IN  DWORD                   InfSectionWithExtSize
    )
{
    //
    // Poor mans SetupDiGetActualSectionToInstallEx
    //
    DWORD SectionNameLen = (DWORD)lstrlen(InfSectionName);
    DWORD ExtBufferLen;
    BOOL ExtFound = TRUE;
    DWORD Err = NO_ERROR;
    DWORD Platform;
    PCTSTR NtArchSuffix;
    DWORD  NtArchSuffixSize;

    switch(ProcessorArchitecture) {

        case PROCESSOR_ARCHITECTURE_INTEL :
            NtArchSuffix = TEXT(".ntx86");
            break;

        case PROCESSOR_ARCHITECTURE_IA64 :
            NtArchSuffix = TEXT(".ntia64");
            break;

        case PROCESSOR_ARCHITECTURE_AMD64 :
            NtArchSuffix = TEXT(".ntamd64");
            break;

        default:
            //
            // Unknown/invalid architecture
            //
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    NtArchSuffixSize = (DWORD)lstrlen(NtArchSuffix)+1;
    if((SectionNameLen+NtArchSuffixSize)>InfSectionWithExtSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    lstrcpy(InfSectionWithExt,InfSectionName);
    lstrcat(InfSectionWithExt,NtArchSuffix);
    if(SetupGetLineCount(InfHandle, InfSectionWithExt) != -1) {
        return TRUE;
    }
    lstrcpy(InfSectionWithExt,InfSectionName);
    lstrcat(InfSectionWithExt,TEXT(".nt"));
    if(SetupGetLineCount(InfHandle, InfSectionWithExt) != -1) {
        return TRUE;
    }
    lstrcpy(InfSectionWithExt,InfSectionName);
    return TRUE;
}


VOID
Usage(
    VOID
    )
{
    _tprintf(TEXT("Usage:  DRVLIST [/S] [/I] [/F CertClassInfPath] [/A arch] [/V ver] SourcePath\n\n"));
    _tprintf(TEXT("Options:\n\n"));
    _tprintf(TEXT("/I Include INFs in the list\n"));
    _tprintf(TEXT("/S Skip class-/co-installers; build list strictly from INFs\n"));
    _tprintf(TEXT("/F Filter based on list of class GUIDs in [DriverSigningClasses]\n"));
    _tprintf(TEXT("   section of specified INF\n"));
    _tprintf(TEXT("/A Architecture to build for, eg '/A 6' (IA64). Assumes /S\n"));
    _tprintf(TEXT("/V Version to build for, eg '/V 0501' (5.1). Assumes /S\n"));
    _tprintf(TEXT("/? or /H Display brief usage message\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\scrubber\precomp.h ===
#include "scrubber.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\dock\dock.c ===
/*++

Copyright (c) 1996    Microsoft Corporation

Module Name:

    locate.c

Abstract:

    This module contains the code
    for finding, adding, removing, and identifying hid devices.

Environment:

    Kernel & user mode

Revision History:

    Nov-96 : Created by Kenneth D. Ray

--*/

#include <basetyps.h>
#include <stdlib.h>
#include <wtypes.h>
#include <cfgmgr32.h>
#include <initguid.h>
#include <stdio.h>
#include <winioctl.h>
#include "dock.h"

#define USAGE "Usage: dock [-e] [-v] [-f]\n" \
              "\t -e eject dock\n"  \
              "\t -v verbose\n" \
              "\t -f force\n"

VOID
DockStartEject (
    BOOLEAN Verbose,
    BOOLEAN Force
    );


__cdecl
main (
  ULONG argc,
  CHAR *argv[]
  )
/*++
++*/
{
    BOOLEAN eject = FALSE;
    BOOLEAN verbose = FALSE;
    BOOLEAN force = FALSE;
    BOOLEAN error = FALSE;
    ULONG i;
    char * parameter = NULL;

    //
    // parameter parsing follows:
    //
    try {
        if (argc < 2) {
            leave;
        }

        for (i = 1; i < argc; i++) {
            parameter = argv[i];

            if ('-' == *(parameter ++)) {
                switch (*parameter) {
                case 'e':
                    eject = TRUE;
                    break;

                case 'v':
                    verbose = TRUE;
                    break;

                case 'f':
                    force = TRUE;
                    break;

                default:
                    error = TRUE;
                    leave;
                }
            } else {
                error = TRUE;
                leave;
            }
        }


    } finally {
        if (error || ((!eject) && (!verbose))) {
            printf (USAGE);
            exit (1);
        }
        if (verbose) {
            printf ("Verbose Mode Requested \n");
        }
        if (eject) {
            printf ("Eject Requested \n");
            DockStartEject (verbose, force);
        }
    }

    printf("Done\n");

    return 0;
}


VOID
DockStartEject (
    BOOLEAN Verbose,
    BOOLEAN Force
    )
/*++

--*/
{
    CONFIGRET   status;
    BOOL        present;

    if (Verbose) {
        printf("Checking if Dock Present\n");
    }

    status = CM_Is_Dock_Station_Present (&present);

    if (Verbose) {
        printf("ret 0x%x, Present %s\n",
               status,
               (present ? "TRUE" : "FALSE"));
    }

    if (Force || present) {
        if (Verbose) {
            printf("Calling eject\n");
        }

        status = CM_Request_Eject_PC ();

        if (Verbose) {
            printf("ret 0x%x\n", status);
        }

    } else {
        printf("Skipping eject call\n");
    }
}


#if 0

BOOLEAN
OpenGamePort (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_INTERFACE_DEVICE_DATA   DeviceInfoData,
    IN OUT   PGAME_PORT                  GamePort
    );

BOOLEAN
FindKnownGamePorts (
   OUT PGAME_PORT *     GamePorts, // A array of struct _GAME_PORT.
   OUT PULONG           NumberDevices // the length in elements of this array.
   )
/*++
Routine Description:
   Do the required PnP things in order to find, the all the HID devices in
   the system at this time.
--*/
{
   HDEVINFO                 hardwareDeviceInfo;
   SP_INTERFACE_DEVICE_DATA deviceInfoData;
   ULONG                    i;
   BOOLEAN                  done;
   PGAME_PORT               gamePortInst;
   LPGUID                   gamePortGuid;

   gamePortGuid = (LPGUID) &GUID_GAMEENUM_BUS_ENUMERATOR;

   *GamePorts = NULL;
   *NumberDevices = 0;

   //
   // Open a handle to the plug and play dev node.
   //
   hardwareDeviceInfo = SetupDiGetClassDevs (
                           gamePortGuid,
                           NULL, // Define no enumerator (global)
                           NULL, // Define no
                           (DIGCF_PRESENT | // Only Devices present
                            DIGCF_INTERFACEDEVICE)); // Function class devices.

   //
   // Take a wild guess to start
   //
   *NumberDevices = 4;
   done = FALSE;
   deviceInfoData.cbSize = sizeof (SP_INTERFACE_DEVICE_DATA);

   i=0;
   while (!done) {
      *NumberDevices *= 2;

      if (*GamePorts) {
         *GamePorts =
               realloc (*GamePorts, (*NumberDevices * sizeof (GAME_PORT)));
      } else {
         *GamePorts = calloc (*NumberDevices, sizeof (GAME_PORT));
      }

      if (NULL == *GamePorts) {
         SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
         return FALSE;
      }

      gamePortInst = *GamePorts + i;

      for (; i < *NumberDevices; i++, gamePortInst++) {
         if (SetupDiEnumInterfaceDevice (hardwareDeviceInfo,
                                         0, // No care about specific PDOs
                                         gamePortGuid,
                                         i,
                                         &deviceInfoData)) {

            if( !OpenGamePort (hardwareDeviceInfo, &deviceInfoData, gamePortInst) )
                printf("Error: OpenGamePort returned FALSE\n");

         } else {
            if (ERROR_NO_MORE_ITEMS == GetLastError()) {
               done = TRUE;
               break;
            }
         }
      }
   }

   *NumberDevices = i;

   SetupDiDestroyDeviceInfoList (hardwareDeviceInfo);
   return TRUE;
}

BOOLEAN
OpenGamePort (
    IN       HDEVINFO                    HardwareDeviceInfo,
    IN       PSP_INTERFACE_DEVICE_DATA   DeviceInfoData,
    IN OUT   PGAME_PORT                  GamePort
    )
/*++
RoutineDescription:
    Given the HardwareDeviceInfo, representing a handle to the plug and
    play information, and deviceInfoData, representing a specific hid device,
    open that device and fill in all the relivant information in the given
    HID_DEVICE structure.

    return if the open and initialization was successfull or not.

--*/
{
    PSP_INTERFACE_DEVICE_DETAIL_DATA     functionClassDeviceData = NULL;
    ULONG                                predictedLength = 0;
    ULONG                                requiredLength = 0;
    ULONG                                i, bytes;
    GAMEENUM_REMOVE_HARDWARE             remove;

    //
    // allocate a function class device data structure to receive the
    // goods about this particular device.
    //
    SetupDiGetInterfaceDeviceDetail (
            HardwareDeviceInfo,
            DeviceInfoData,
            NULL, // probing so no output buffer yet
            0, // probing so output buffer length of zero
            &requiredLength,
            NULL); // not interested in the specific dev-node


    predictedLength = requiredLength;
    // sizeof (SP_FNCLASS_DEVICE_DATA) + 512;

    functionClassDeviceData = malloc (predictedLength);
    functionClassDeviceData->cbSize = sizeof (SP_INTERFACE_DEVICE_DETAIL_DATA);

    //
    // Retrieve the information from Plug and Play.
    //
    if (! SetupDiGetInterfaceDeviceDetail (
               HardwareDeviceInfo,
               DeviceInfoData,
               functionClassDeviceData,
               predictedLength,
               &requiredLength,
               NULL)) {
        printf("Error in SetupDiGetInterfaceDeviceDetail\n");
        free (functionClassDeviceData);
        return FALSE;
    }

    printf("Opening %s\n", functionClassDeviceData->DevicePath);

    GamePort->File = CreateFile (
                              functionClassDeviceData->DevicePath,
                              GENERIC_READ | GENERIC_WRITE,
                              0, // FILE_SHARE_READ | FILE_SHARE_WRITE
                              NULL, // no SECURITY_ATTRIBUTES structure
                              OPEN_EXISTING, // No special create flags
                              0, // No special attributes
                              NULL); // No template file

    if (INVALID_HANDLE_VALUE == GamePort->File) {
        printf("Error in CreateFile: %x", GetLastError());
        free (functionClassDeviceData);
        return FALSE;
    }
    printf("File Opened!!!\n");

    GamePort->Desc.Size = sizeof (GamePort->Desc);

    if (!DeviceIoControl (GamePort->File,
                          IOCTL_GAMEENUM_PORT_DESC,
                          &GamePort->Desc, sizeof (GamePort->Desc),
                          &GamePort->Desc, sizeof (GamePort->Desc),
                          &bytes, NULL)) {
        printf("Error in DeviceIoctl IOCTL_GAMEENUM_PORT_DESC: %x", GetLastError());
        free (functionClassDeviceData);
        return FALSE;
    }

    printf("Description: Size (%d), Handle (0x%x), Address (0x%x) \n",
           GamePort->Desc.Size,
           GamePort->Desc.PortHandle,
           GamePort->Desc.PortAddress);


    //
    // Set the port up
    //
    if(bExpose) {
        printf("\nThis handle is not valid for remove!!!\n\nExposing port\n");

        GamePort->Hardware = malloc (bytes = (sizeof (GAMEENUM_EXPOSE_HARDWARE) +
                                              GAME_HARDWARE_IDS_LENGTH));

        GamePort->Hardware->Size = sizeof (GAMEENUM_EXPOSE_HARDWARE);
        GamePort->Hardware->PortHandle = GamePort->Desc.PortHandle;
        printf("Enter Number of Joysticks:");
        scanf("%d",&GamePort->Hardware->NumberJoysticks);
        printf("Enter Number of Buttons:");
        scanf("%d", &GamePort->Hardware->NumberButtons);
        printf("Enter Number of Axes:");
        scanf("%d", &GamePort->Hardware->NumberAxis);
        memcpy (GamePort->Hardware->HardwareIDs,
                GAME_HARDWARE_IDS,
                GAME_HARDWARE_IDS_LENGTH);

        if (!DeviceIoControl (GamePort->File,
                              IOCTL_GAMEENUM_EXPOSE_HARDWARE,
                              GamePort->Hardware, bytes,
                              GamePort->Hardware, bytes,
                              &bytes, NULL)) {
              free (functionClassDeviceData);
              free (GamePort->Hardware);
              GamePort->Hardware = NULL;
              printf("Error in DeviceIoctl IOCTL_GAMEENUM_EXPOSE_HARDWARE:  0x%x\n", GetLastError());
              return FALSE;
        }
        printf("Hardware handle 0x%x   <-----  Save this handle!!!\n",GamePort->Hardware->HardwareHandle);
        printf("\t\tGameEnum -r will not be able retrieve it for you.\n");

        free (GamePort->Hardware);
        GamePort->Hardware = NULL;
    }

    if(bRemove) {
        printf("Removing  port\n");

        remove.Size = bytes = sizeof (remove);
        printf("Enter hardware handle: ");
        scanf("%x",&remove.HardwareHandle);
        printf("Entered Handle: %x", remove.HardwareHandle);

        if (!DeviceIoControl (GamePort->File,
                              IOCTL_GAMEENUM_REMOVE_HARDWARE,
                              &remove, bytes,
                              &remove, bytes,
                              &bytes, NULL)) {
            printf("Error in DeviceIoctl IOCTL_GAMEENUM_REMOVE_HARDWARE:  0x%x\n", GetLastError());
            return FALSE;
        }
    }

    free (functionClassDeviceData);
    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\drvlist\precomp.h ===
#include "drvlist.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\scrubber\scrubber.c ===
/*
 Note: This program creates the following files in %systemroot%\system32\config:

  system.sc0	Backup at start of operations
  system.scc	Backup if compression is on
  system.scb	Backup after removing devnodes
  system.scn	Temporary during replacement of system (should go away)
  system		Updated system hive (should match system.scb)

  Modification History:
  10/3/2000		original version from jasconc
  10/4/2000		put back compression option, version 0.9
  10/10/2000	if compression (no removals), save backup as .scc, else as .sc0
  10/13/2000	Add version check (Win2K only, not NT4, not Whistler, etc.)
  10/20/2000	Return DevicesRemoved to help with diskpart in scripts
*/

//#include "scrubber.h"
#include <windows.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <stdio.h>
#include <stdlib.h>

#include <initguid.h>
#include <devguid.h>
#include <winioctl.h>

CONST GUID *ClassesToClean[2] = {
    &GUID_DEVCLASS_DISKDRIVE,
    &GUID_DEVCLASS_VOLUME
};

CONST GUID *DeviceInterfacesToClean[5] = {
    &DiskClassGuid,
    &PartitionClassGuid,
    &WriteOnceDiskClassGuid,
    &VolumeClassGuid,
    &StoragePortClassGuid
};


void PERR(void);

BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    BOOL b;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;

    b = AllocateAndInitializeSid(&NtAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 DOMAIN_ALIAS_RID_ADMINS,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 0,
                                 &AdministratorsGroup
                                 );

    if (b) {

        if (!CheckTokenMembership(NULL,
                                  AdministratorsGroup,
                                  &b
                                  )) {
            b = FALSE;
        }

        FreeSid(AdministratorsGroup);
    }

    return (b);
}

int
__cdecl
main(
    IN int   argc,
    IN char *argv[]
    )
{
    HDEVINFO DeviceInfoSet;
    HDEVINFO InterfaceDeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    int DevicesRemoved = 0;
    int i, InterfaceIndex;
    int MemberIndex, InterfaceMemberIndex;
    BOOL bDoRemove = TRUE, bDoCompress = FALSE;
    DWORD Status, Problem;
    CONFIGRET cr;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
	TCHAR DirBuff[MAX_PATH], DirBuffX[MAX_PATH], BackupDir[MAX_PATH];
	UINT uPathLen;
	HKEY hKey;
	DWORD dwMessage;
	TOKEN_PRIVILEGES tp;
	HANDLE hToken;
	LUID luid;
	LPTSTR MachineName=NULL; // pointer to machine name
	DWORD dwSubKeyIndex=0;   // index into key
	DWORD dwSubKeyLength=_MAX_FNAME; // length of SubKey buffer
	OSVERSIONINFO osvi;

    // 
    // enable backup privilege at least
    // 
	printf("SCRUBBER 0.93 Storage Device Node Cleanup\nCopyright (c) 2000 Microsoft Corp. All rights reserved.\n");

	//
    // parse parameters.
    //
    for (i = 1; i < argc; i++)
	{
		//
		// Check for help
		//
		if ( (lstrcmpi(argv[i], TEXT("-?")) == 0) ||
				(lstrcmpi(argv[i], TEXT("/?")) == 0) ){

			printf("\nSCRUBBER will remove phantom storage device nodes from this machine.\n\n");
			printf("Usage: scrubber [/n] [/c]\n");
			printf("\twhere /n displays but does not remove the phantom devnodes.\n");
			printf("\t  and /c will compress the registry hive even if no changes are made.\n");
			printf("\nBackup and Restore privileges are required to run this utility.\n");
			printf("A copy of the registry will saved in %%systemroot%%\\system32\\config\\system.sc0\n");
			return 0;
		}

		//
		// Check for -n which means just list the devices that
		// we will remove.
		//
		if ( (lstrcmpi(argv[i], TEXT("-n")) == 0) ||
			 (lstrcmpi(argv[i], TEXT("/n")) == 0) ) {
			bDoRemove = FALSE;
		}

		//
        // Force compress mode?
        //
		if ( (lstrcmpi(argv[i], TEXT("-c")) == 0) ||
			 (lstrcmpi(argv[i], TEXT("/c")) == 0) ){
			bDoCompress = TRUE;
		}
	}

    //
    // Only run on Windows 2000 (not Whistler, etc.) Initialize the OSVERSIONINFOEX structure.
    //
    ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	if (!GetVersionEx(&osvi))
	{
		fprintf(stderr, "SCRUBBER: Unable to verify Windows version, exiting...\n");
		return -1;
	}
	if ( (osvi.dwMajorVersion != 5) || (osvi.dwMinorVersion != 0) )
	{
		fprintf(stderr, "SCRUBBER: This utility is only designed to run on Windows 2000\n");
		return -1;
	}

    //
    // The process must have admin credentials.
    //
    if (!IsUserAdmin()) {
		fprintf(stderr, "SCRUBBER: You must be an administrator to run this utility.\n");
		return -1;
    }

    //
	// see if we can do the task, need backup privelege.
    //
    if(!OpenProcessToken(GetCurrentProcess(),
                        TOKEN_ADJUST_PRIVILEGES,
                        &hToken ))
    {
		fprintf(stderr, "SCRUBBER: Unable to obtain process token.\nCheck privileges.\n");
        return -1;
    }

    if(!LookupPrivilegeValue(MachineName, SE_BACKUP_NAME, &luid))

    {
		fprintf(stderr, "SCRUBBER: Backup Privilege is required to save the registry.\n"
			"Please rerun from a privileged account\n");
        return -1;
    }

    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
                                NULL, NULL ))
    {
		fprintf(stderr, "SCRUBBER: Unable to set Backup Privilege.\n");
        return -1;
    }

	// Backup the file if we aren't doing a dry run
	if ( bDoCompress || bDoRemove)
	{
		if(!LookupPrivilegeValue(MachineName, SE_RESTORE_NAME, &luid))

		{
			fprintf(stderr, "SCRUBBER: Restore Privilege is required to make changes to the registry.\n"
				"Please rerun from a privileged account\n");
			return -1;
		}

		tp.Privileges[0].Luid       = luid;

		AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES),
									NULL, NULL );

		if (GetLastError() != ERROR_SUCCESS)
		{
			fprintf(stderr, "SCRUBBER: Unable to set Restore Privilege.\n");
			return -1;
		}


		if (RegOpenKey(HKEY_LOCAL_MACHINE, "System", &hKey) == ERROR_SUCCESS)
		{
			uPathLen = GetSystemDirectory(DirBuffX, sizeof(DirBuffX));
			if (uPathLen < MAX_PATH - strlen("\\config\\system.scx") - 1)
			{
				strcat(DirBuffX, "\\config\\system.scx");

				dwMessage = RegSaveKey(hKey, DirBuffX, NULL);

				if (dwMessage == ERROR_ALREADY_EXISTS)
				{
					DeleteFile(DirBuffX);
					dwMessage = RegSaveKey(hKey, DirBuffX, NULL);
				}
				RegCloseKey(hKey);

				if (dwMessage != ERROR_SUCCESS)
				{
					fprintf(stderr, "Unable to save a backup copy of the system hive.\n"
						"No changes have been made.\n\n");
					return -1;
				}
			}
		}
	}

    for (i=0; (i<sizeof(ClassesToClean)) && (bDoRemove || !bDoCompress); i++) {

        DeviceInfoSet = SetupDiGetClassDevs(ClassesToClean[i],
                                            NULL,
                                            NULL,
                                            0
                                            );

        if (DeviceInfoSet != INVALID_HANDLE_VALUE) {

            DeviceInfoData.cbSize = sizeof(DeviceInfoData);
            MemberIndex = 0;

            while (SetupDiEnumDeviceInfo(DeviceInfoSet,
                                         MemberIndex++,
                                         &DeviceInfoData
                                         )) {

                //
                // Check if this device is a Phantom
                //
                cr = CM_Get_DevNode_Status(&Status,
                                           &Problem,
                                           DeviceInfoData.DevInst,
                                           0
                                           );

                if ((cr == CR_NO_SUCH_DEVINST) ||
                    (cr == CR_NO_SUCH_VALUE)) {

                    //
                    // This is a phantom.  Now get the DeviceInstanceId so we
                    // can display this as output.
                    //
                    if (CM_Get_Device_ID(DeviceInfoData.DevInst,
                                         DeviceInstanceId,
                                         sizeof(DeviceInstanceId) / sizeof(TCHAR),
                                         0) == CR_SUCCESS) {
    
        
                        if (bDoRemove) {
        
                            printf("SCRUBBER: %s will be removed.\n",
                                   DeviceInstanceId
                                   );

                            //
                            // Since DeviceRemoval doesn't always clean out all
                            // of the device's interfaces (this is the case for
                            // RAW devnodes) then we need to manually build up
                            // a list of device interfaces that we care about 
                            // that are associated with this DeviceInfoData and 
                            // manually remove them.
                            //
                            for (InterfaceIndex = 0;
                                 InterfaceIndex < sizeof(DeviceInterfacesToClean);
                                 InterfaceIndex++) {

                                //
                                // Build up a list of the interfaces for this specific
                                // device.
                                //
                                InterfaceDeviceInfoSet = 
                                    SetupDiGetClassDevs(DeviceInterfacesToClean[InterfaceIndex],
                                                        DeviceInstanceId,
                                                        NULL,
                                                        DIGCF_DEVICEINTERFACE
                                                        );

                                if (InterfaceDeviceInfoSet != INVALID_HANDLE_VALUE) {

                                    //
                                    // Enumerate through the interfaces that we just 
                                    // built up.
                                    //
                                    DeviceInterfaceData.cbSize = sizeof(DeviceInterfaceData);
                                    InterfaceMemberIndex = 0;
                                    while (SetupDiEnumDeviceInterfaces(InterfaceDeviceInfoSet,
                                                                       NULL,
                                                                       DeviceInterfacesToClean[InterfaceIndex],
                                                                       InterfaceMemberIndex++,
                                                                       &DeviceInterfaceData
                                                                       )) {
                                        
                                        //
                                        // Remove this Interface from the registry.
                                        //
                                        SetupDiRemoveDeviceInterface(InterfaceDeviceInfoSet,
                                                                     &DeviceInterfaceData
                                                                     );
                                    }

                                    //
                                    // Destroy the list of Interfaces that we built up.
                                    //
                                    SetupDiDestroyDeviceInfoList(InterfaceDeviceInfoSet);
                                }
                            }


                            //
                            // Call DIF_REMOVE to remove the device's hardware
                            // and software registry keys.
                            //
                            if (SetupDiCallClassInstaller(DIF_REMOVE,
                                                          DeviceInfoSet,
                                                          &DeviceInfoData
                                                          )) {
                                
                                DevicesRemoved++;

                            } else {
                            
                                fprintf(stderr, "SCRUBBER: Error 0x%X removing phantom\n",
                                       GetLastError());
                            }


                        } else {
        
                            printf("SCRUBBER: %s would have been removed.\n",
                                   DeviceInstanceId
                                   );
                        }
                    }
                }
            }


            SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        }
    }
	
	// compress registry now
	if (DevicesRemoved || bDoCompress)
	{
		uPathLen = GetSystemDirectory(DirBuff, sizeof(DirBuff));
		SetLastError(0);
		if (uPathLen < MAX_PATH - strlen("\\config\\system.scn") - 1)
		{
			// Rename our backup copy
			if (!DevicesRemoved)
			{
				strcat(DirBuff, "\\config\\system.scc");
			}
			else
			{
				strcat(DirBuff, "\\config\\system.sc0");
			}
			DeleteFile(DirBuff);
			if (rename(DirBuffX, DirBuff))
			{
				fprintf(stderr, "SCRUBBER: Failed to rename backup file (system.scx)\n");
			}
			else
			{
				printf("System hive backup saved in %s\n", DirBuff);
			}
		}
		else
		{
			fprintf(stderr, "SCRUBBER: Path name too long. Registry not compressed.\n");
		}

		if (RegOpenKey(HKEY_LOCAL_MACHINE, "System", &hKey) == ERROR_SUCCESS)
		{
			// Make an additional copy now because it gets blown away on replace
			uPathLen = GetSystemDirectory(DirBuff, sizeof(DirBuff));
			strcat(DirBuff, "\\config\\system.scn");
			dwMessage = RegSaveKey(hKey, DirBuff, NULL);

			if (dwMessage == ERROR_ALREADY_EXISTS)
			{
				DeleteFile(DirBuff);
				dwMessage = RegSaveKey(hKey, DirBuff, NULL);
			}

			if (dwMessage == ERROR_SUCCESS)
			{
                if (bDoCompress) {
                
    				TCHAR *tcPtr;
    
    
    				sprintf(BackupDir, DirBuff);
    				tcPtr = strstr(BackupDir, ".scn");
    				strcpy(tcPtr, ".scb");
    				if (!DeleteFile(BackupDir))
    				{
    					dwMessage = GetLastError();
    				}
    
    				dwMessage = RegReplaceKey(hKey, NULL, DirBuff, BackupDir);
    
    				if (dwMessage != ERROR_SUCCESS)
    					PERR();
    				else
    					printf("Saved new system hive.\n");
                }
			}
			else
			{
				PERR();
			}
			RegCloseKey(hKey);
		}
	}
	else
		DeleteFile(DirBuffX);
    
    return DevicesRemoved;
}

void PERR(void)
{
	LPVOID lpMsgBuf;

	FormatMessage( 
				FORMAT_MESSAGE_ALLOCATE_BUFFER | 
				FORMAT_MESSAGE_FROM_SYSTEM | 
				FORMAT_MESSAGE_IGNORE_INSERTS,
				NULL,
				GetLastError(),
				MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf,
				0,
				NULL);
	fprintf(stderr, lpMsgBuf);
	LocalFree(lpMsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\scrubber\scrubber.h ===
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <tchar.h>
#include <cfgmgr32.h>
#include <setupapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopall\precomp.h ===
#include "stopall.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\pnpreg\pnpreg.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pnpreg.c

Abstract:

    The module contains the the initialization code for the executive
    component. It also contains the display string and shutdown system
    services.

Author:

    Robert B. Nelson (robertn) 10-Feb-1998

Revision History:

--*/

#include <windows.h>
#include <aclapi.h>
#include <regstr.h>
#include <stdio.h>
#include <malloc.h>
#include <tchar.h>

PSID                g_pAdminSid;
PSID                g_pSystemSid;

SECURITY_DESCRIPTOR g_DeviceParametersSD;
PACL                g_pDeviceParametersDacl;

SECURITY_DESCRIPTOR g_LockedPrivateKeysSD;
PACL                g_pLockedPrivateKeysDacl;


#if DBG || UMODETEST
#define DBGF_ERRORS                 0x00000001
#define DBGF_WARNINGS               0x00000002

#define DBGF_REGISTRY               0x00000010

void    RegFixDebugMessage(LPTSTR format, ...);
#define DBGTRACE(l, x)  (g_RegFixDebugFlag & (l) ? RegFixDebugMessage x : (void)0)

DWORD   g_RegFixDebugFlag = DBGF_WARNINGS | DBGF_ERRORS;

TCHAR   g_szCurrentKeyName[4096];
DWORD   g_dwCurrentKeyNameLength = 0;

#else
#define DBGTRACE(l, x)
#endif

VOID
FreeSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This function deallocates the data structures allocated and initialized by
    CreateDeviceParametersSD.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (g_pDeviceParametersDacl) {
        LocalFree(g_pDeviceParametersDacl);
        g_pDeviceParametersDacl = NULL;
    }

    if (g_pLockedPrivateKeysDacl) {
        LocalFree(g_pLockedPrivateKeysDacl);
        g_pLockedPrivateKeysDacl = NULL;
    }

    if (g_pAdminSid != NULL) {
        FreeSid(g_pAdminSid);
        g_pAdminSid = NULL;
    }

    if (g_pSystemSid != NULL) {
        FreeSid(g_pSystemSid);
        g_pSystemSid = NULL;
    }
}

BOOL
CreateSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This function creates a properly initialized Security Descriptor for the
    Device Parameters key and its subkeys.  The SIDs and DACL created by this
    routine must be freed by calling FreeDeviceParametersSD.

Arguments:

    None.

Return Value:

    Pointer to the initialized Security Descriptor.  NULL is returned if an
    error occurs.

--*/

{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

    EXPLICIT_ACCESS             ExplicitAccess[2];

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    //
    // Create SIDs - Admins and System
    //

    bSuccess =             AllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &g_pAdminSid);

    bSuccess = bSuccess && AllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &g_pSystemSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 2; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = CONTAINER_INHERIT_ACE;
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }

        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)g_pSystemSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)g_pAdminSid;

        //
        // Create the DACL with the both the above ACEs for the DeviceParameters
        //
        dwError = SetEntriesInAcl( 2,
                                   ExplicitAccess,
                                   NULL,
                                   &g_pDeviceParametersDacl );

        if (dwError == ERROR_SUCCESS)
        {
            //
            // Create the DACL with just the system ACE for the locked private
            // keys.
            //
            dwError = SetEntriesInAcl( 1,
                                       ExplicitAccess,
                                       NULL,
                                       &g_pLockedPrivateKeysDacl );
        }

        bSuccess = dwError == ERROR_SUCCESS;
    }

    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_DeviceParametersSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_DeviceParametersSD,
                                                      TRUE,
                                                      g_pDeviceParametersDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_DeviceParametersSD );


    //
    // Initialize the DeviceParameters security descriptor
    //
    bSuccess = bSuccess && InitializeSecurityDescriptor( &g_LockedPrivateKeysSD,
                                                         SECURITY_DESCRIPTOR_REVISION );

    //
    // Set the new DACL in the security descriptor
    //
    bSuccess = bSuccess && SetSecurityDescriptorDacl( &g_LockedPrivateKeysSD,
                                                      TRUE,
                                                      g_pLockedPrivateKeysDacl,
                                                      FALSE);

    //
    // validate the new security descriptor
    //
    bSuccess = bSuccess && IsValidSecurityDescriptor( &g_LockedPrivateKeysSD );



    if (!bSuccess) {

        FreeSecurityDescriptors();
    }

    return bSuccess;
}

VOID
EnumKeysAndApplyDacls(
    IN HKEY                 hParentKey,
    IN LPTSTR               pszKeyName,
    IN DWORD                dwLevel,
    IN BOOL                 bInDeviceParameters,
    IN BOOL                 bApplyTopDown,
    IN PSECURITY_DESCRIPTOR pPrivateKeySD,
    IN PSECURITY_DESCRIPTOR pDeviceParametersSD
    )

/*++

Routine Description:

    This function applies the DACL in pSD to all the keys rooted at hKey
    including hKey itself.

Arguments:

    hParentKey      Handle to a registry key.
    pszKeyName      Name of the key.
    dwLevel         Number of levels remaining to recurse.
    pSD             Pointer to a security descriptor containing a DACL.

Return Value:

    None.


--*/

{
    LONG        RegStatus;
    DWORD       dwMaxSubKeySize;
    LPTSTR      pszSubKey;
    DWORD       index;
    HKEY        hKey;
    BOOL        bNewInDeviceParameters;

#if DBG || UMODETEST
    DWORD       dwStartKeyNameLength = g_dwCurrentKeyNameLength;

    if (g_dwCurrentKeyNameLength != 0)  {

        g_szCurrentKeyName[ g_dwCurrentKeyNameLength++ ] = TEXT('\\');
    }
    _tcscpy(&g_szCurrentKeyName[g_dwCurrentKeyNameLength], pszKeyName);
    g_dwCurrentKeyNameLength += _tcslen(pszKeyName);
#endif

    DBGTRACE( DBGF_REGISTRY,
              (TEXT("EnumKeysAndApplyDacls(0x%08X, \"%s\", %d, %s, %s, 0x%08X, 0x%08X)\n"),
              hParentKey,
              g_szCurrentKeyName,
              dwLevel,
              bInDeviceParameters ? TEXT("TRUE") : TEXT("FALSE"),
              bApplyTopDown ? TEXT("TRUE") : TEXT("FALSE"),
              pPrivateKeySD,
              pDeviceParametersSD) );

    if (bApplyTopDown) {

        RegStatus = RegOpenKeyEx( hParentKey,
                                  pszKeyName,
                                  0,
                                  WRITE_DAC,
                                  &hKey
                                  );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));

            return;
        }

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way down\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));
        }

        //
        // Close the key and reopen it later for read (which hopefully was just
        // granted in the DACL we just wrote
        //
        RegCloseKey( hKey );
    }

    RegStatus = RegOpenKeyEx( hParentKey,
                              pszKeyName,
                              0,
                              KEY_READ | WRITE_DAC,
                              &hKey
                              );

    if (RegStatus != ERROR_SUCCESS) {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegOpenKeyEx() failed, error = %d\n"),
                  g_szCurrentKeyName, RegStatus));

        return;
    }

    //
    // Determine length of longest subkey
    //
    RegStatus = RegQueryInfoKey( hKey,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &dwMaxSubKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL );

    if (RegStatus == ERROR_SUCCESS) {

        //
        // Allocate a buffer to hold the subkey names. RegQueryInfoKey returns the
        // size in characters and doesn't include the NUL terminator.
        //
        pszSubKey = LocalAlloc(0, ++dwMaxSubKeySize * sizeof(TCHAR));

        if (pszSubKey != NULL) {

            //
            // Enumerate all the subkeys and then call ourselves recursively for each
            // until dwLevel reaches 0.
            //

            for (index = 0; ; index++) {

                RegStatus = RegEnumKey( hKey,
                                        index,
                                        pszSubKey,
                                        dwMaxSubKeySize
                                        );

                if (RegStatus != ERROR_SUCCESS) {

                    if (RegStatus != ERROR_NO_MORE_ITEMS) {

                        DBGTRACE( DBGF_ERRORS,
                                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegEnumKeyEx() failed, error = %d\n"),
                                  g_szCurrentKeyName,
                                  RegStatus) );
                    }

                    break;
                }

                bNewInDeviceParameters = bInDeviceParameters ||
                                         (dwLevel == 3 &&
                                            _tcsicmp( pszSubKey,
                                                      REGSTR_KEY_DEVICEPARAMETERS ) == 0);

                EnumKeysAndApplyDacls( hKey,
                                       pszSubKey,
                                       dwLevel + 1,
                                       bNewInDeviceParameters,
                                       bApplyTopDown,
                                       pPrivateKeySD,
                                       pDeviceParametersSD
                                       );
            }

            LocalFree( pszSubKey );
        }
    }
    else
    {
        DBGTRACE( DBGF_ERRORS,
                  (TEXT("EnumKeysAndApplyDacls(\"%s\") RegQueryInfoKey() failed, error = %d\n"),
                  g_szCurrentKeyName, RegStatus));
    }

    if (!bApplyTopDown) {

        DBGTRACE( DBGF_REGISTRY,
                  (TEXT("Setting security on %s on the way back up\n"),
                  g_szCurrentKeyName) );

        //
        // apply the new security to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey,
                                       DACL_SECURITY_INFORMATION,
                                       bInDeviceParameters ?
                                           pDeviceParametersSD :
                                           pPrivateKeySD
                                       );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("EnumKeysAndApplyDacls(\"%s\") RegSetKeySecurity() failed, error = %d\n"),
                      g_szCurrentKeyName, RegStatus));
        }
    }

    RegCloseKey( hKey );

#if DBG || UMODETEST
    g_dwCurrentKeyNameLength = dwStartKeyNameLength;
    g_szCurrentKeyName[g_dwCurrentKeyNameLength] = TEXT('\0');
#endif
}

VOID
LockUnlockEnumTree(
    LPTSTR  pszMachineName,
    BOOL    bLock
    )
{
    PSECURITY_DESCRIPTOR    pSD;
    HKEY                    hParentKey;
    LONG                    RegStatus;

    if (pszMachineName != NULL) {

        RegStatus = RegConnectRegistry( pszMachineName,
                                        HKEY_LOCAL_MACHINE,
                                        &hParentKey );

        if (RegStatus != ERROR_SUCCESS) {
            DBGTRACE( DBGF_ERRORS,
                      (TEXT("Could not connect to remote registry on %s, status = %d\n"),
                      pszMachineName,
                      RegStatus) );
        }
    } else {

        hParentKey = HKEY_LOCAL_MACHINE;
    }

    if (CreateSecurityDescriptors()) {

        EnumKeysAndApplyDacls( hParentKey,
                               REGSTR_PATH_SYSTEMENUM,
                               0,
                               FALSE,
                               !bLock,
                               bLock ? &g_LockedPrivateKeysSD : &g_DeviceParametersSD,
                               &g_DeviceParametersSD
                               );

        FreeSecurityDescriptors();
    }
}
#if DBG || UMODETEST
void
RegFixDebugMessage(LPWSTR format, ...)
{
    va_list args;

    va_start(args, format);

    _vtprintf(format, args);
}
#endif

#if UMODETEST
void
usage(int argc, TCHAR **argv)
{
    PTCHAR  pszProgram;

    if ((pszProgram = _tcsrchr(argv[0], TEXT('\\'))) != NULL) {
        pszProgram++;
    } else {
        pszProgram = argv[0];
    }

    _tprintf(TEXT("%s: Lock or Unlock PnP Registry (Enum key)\n\n"), pszProgram);
    _tprintf(TEXT("Usage: %s [-m <machine>] -l | -u\n"), pszProgram);
    _tprintf(TEXT("    -m <machine>    Remote machine without leading \\\\\n"));
    _tprintf(TEXT("    -l              Locks Enum key\n"));
    _tprintf(TEXT("    -u              Unlocks Enum key\n\n"));
    _tprintf(TEXT("Note: -m is optional.  Only one of -l or -u may be used.\n"));
}

int __cdecl
_tmain(int argc, TCHAR **argv)
{
    LPTSTR      pszMachineName = NULL;
    LPTSTR      pszArg;
    int         idxArg;

    if ( argc == 1 )
    {
        usage(argc, argv);
        return 0;
    }

    for (idxArg = 1; idxArg < argc; idxArg++)
    {
        pszArg = argv[ idxArg ];

        if (*pszArg == '/' || *pszArg == '-')
        {
            pszArg++;

            while (pszArg != NULL && *pszArg != '\0') {

                switch (*pszArg)
                {
                case '/':   // Ignore these, caused by cmds like /m/l
                    pszArg++;
                    break;

                case 'l':
                case 'L':
                    pszArg++;
                    LockUnlockEnumTree( pszMachineName, TRUE );
                    break;

                case 'm':
                case 'M':
                    pszArg++;

                    if (*pszArg == ':' || *pszArg == '=')
                    {
                        if (pszArg[ 1 ] != '\0')
                        {
                            pszMachineName = ++pszArg;
                        }
                    }
                    else if (*pszArg != '\0')
                    {
                        pszMachineName = pszArg;
                    }
                    else if ((idxArg + 1) < argc && (argv[ idxArg + 1 ][0] != '/' && argv[ idxArg + 1 ][0] != '-'))
                    {
                        pszMachineName = argv[ ++idxArg ];
                    }

                    if (pszMachineName == NULL)
                    {
                        _tprintf(
                            TEXT("%c%c : missing machine name argument\n"),
                            argv[ idxArg ][ 0 ], pszArg [ - 1 ]
                            );

                        usage(argc, argv);

                        return 1;
                    }
                    pszArg = NULL;
                    break;

                case 'u':
                case 'U':
                    pszArg++;

                    LockUnlockEnumTree( pszMachineName, FALSE );
                    break;

                case 'v':
                case 'V':
                    pszArg++;

                    g_RegFixDebugFlag |= DBGF_REGISTRY;
                    break;

                default:
                    _tprintf(
                        TEXT("%c%c : invalid option\n"),
                        argv[ idxArg ][ 0 ], *pszArg
                        );
                    break;
                }
            }
        }
    }

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopall\stopall.c ===
#include "precomp.h"
#pragma hdrstop

#define BUFFERSIZE 1024

typedef struct _DEVICEINFO {
    BOOL DevNodeStarted;
} DEVICEINFO, *PDEVICEINFO;

BOOL
IsDriverLoaded(
    PTSTR ServiceName
    )
{
    NTSTATUS Status;
    BOOL bObjectIsLoaded = FALSE;
    UCHAR Buffer[BUFFERSIZE];
    UNICODE_STRING UnicodeStringDriver, UnicodeStringServiceName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;    
    POBJECT_NAME_INFORMATION NameInfo;
    ULONG Context = 0;
    ULONG ReturnedLength;

    RtlZeroMemory(Buffer, BUFFERSIZE);
    
    RtlInitUnicodeString(&UnicodeStringServiceName, ServiceName);
    RtlInitUnicodeString(&UnicodeStringDriver, TEXT("\\Driver"));

    InitializeObjectAttributes(&Attributes,
                               &UnicodeStringDriver,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = NtOpenDirectoryObject(&DirectoryHandle,
                                   DIRECTORY_QUERY,
                                   &Attributes
                                   );

    if (!NT_SUCCESS(Status)) {
        printf("NtOpenDirectoryObject failed with 0x%X\n", Status);
        goto clean0;
    }

    //
    // Get the actual name of the object directory object.
    //
    NameInfo = (POBJECT_NAME_INFORMATION)&Buffer[0];
    if (!NT_SUCCESS(Status = NtQueryObject(DirectoryHandle,
                                           ObjectNameInformation,
                                           NameInfo,
                                           BUFFERSIZE,
                                           (PULONG)NULL))) {
        printf( "Unexpected error obtaining actual object directory name\n" );
        printf( "Error was:  %X\n", Status );                                 
        goto clean0;                                                               
    }

    //
    // Grab the driver objects in chuncks instead of one at a time.
    //
    for (Status = NtQueryDirectoryObject(DirectoryHandle,
                                         &Buffer,
                                         BUFFERSIZE,
                                         FALSE,
                                         FALSE,
                                         &Context,
                                         &ReturnedLength
                                         );
         NT_SUCCESS(Status) && !bObjectIsLoaded;
         Status = NtQueryDirectoryObject(DirectoryHandle,
                                         &Buffer,
                                         BUFFERSIZE,
                                         FALSE,
                                         FALSE,
                                         &Context,
                                         &ReturnedLength
                                         )) {
        if (!NT_SUCCESS(Status)) {
            if (Status != STATUS_NO_MORE_FILES) {
                printf("NtQueryDirectoryObject failed with 0x%X\n", Status);
            }
            break;
        }

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {
            //
            // Check if there is another record. If there isn't, then get out 
            // of the loop now.
            //
            if (DirInfo->Name.Length == 0) {
                break;
            }

            if (RtlCompareUnicodeString(&UnicodeStringServiceName, &(DirInfo->Name), TRUE) == 0) {
                bObjectIsLoaded = TRUE;
                break;
            }

            DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR)DirInfo) +
                                                      sizeof(OBJECT_DIRECTORY_INFORMATION));
        }

        RtlZeroMemory(Buffer, BUFFERSIZE);
    }

clean0:
    NtClose(DirectoryHandle);

    return bObjectIsLoaded;
}
         
BOOL
RestartDevicesUsingService(
    LPTSTR ServiceName
    )
{
    BOOL b = TRUE;
    CONFIGRET cr;
    DEVNODE DevNode;
    BOOL bIsDriverLoaded;
    INT count, i;
    TCHAR VetoName[512];
    ULONG VetoNameLength;
    PNP_VETO_TYPE VetoType;
    ULONG Status, Problem;
    ULONG BufferLen;
    OSVERSIONINFO osvi;
    PTSTR Buffer = NULL;
    PTSTR p;
    PDEVICEINFO DeviceInfo = NULL;

    printf("Stopping all devices that are using the service %ws\n", ServiceName);

    try {
        bIsDriverLoaded = IsDriverLoaded(ServiceName);

        printf("%ws %ws loaded\n", 
               ServiceName, 
               bIsDriverLoaded
                    ? TEXT("is")
                    : TEXT("is NOT")
               );

        //
        // If this service is not loaded then we don't need to do anything.
        //
        if (!bIsDriverLoaded) {
            goto clean0;
        }
        
        //
        // Find out how large a buffer it will take to hold all the devices that
        // are using this service.
        //
        if (((cr = CM_Get_Device_ID_List_Size(&BufferLen,
                                              ServiceName,
                                              CM_GETIDLIST_FILTER_SERVICE
                                              )) != CR_SUCCESS) ||
            (BufferLen == 0)) {
            if (cr != CR_SUCCESS) {
                b = FALSE;
                printf("CM_Get_Device_ID_List_Size failed with 0x%X\n", cr);
            } else {
                printf("There are no devices using this service!\n");
            }
            goto clean0;
        }
    
        Buffer = LocalAlloc(LPTR, BufferLen*sizeof(TCHAR));
    
        if (Buffer == NULL) {
            b = FALSE;
            goto clean0;
        }
    
        //
        // Get all of the devices that are using this service.
        //
        if (CM_Get_Device_ID_List(ServiceName,
                                  Buffer,
                                  BufferLen,
                                  CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                                  ) != CR_SUCCESS) {
            b = FALSE;
            goto clean0;
        }

        //
        // Count up how many devices we are dealing with.
        //
        count = 0;
        for (p = Buffer; *p; p += (lstrlen(p) + 1)) {
            count++;
        }

        if (count == 0) {
            printf("There are no devices using this service!\n");
            goto clean0;
        }

        printf("%d devices are using this service\n", count);

        //
        // Allocate an array of our DEVICEINFO structures so we can keep
        // track of the Devnodes and whether a device was started or not
        // before we tried to unloade the specified driver.
        //
        DeviceInfo = LocalAlloc(LPTR, count*sizeof(DEVICEINFO));

        if (DeviceInfo == NULL) {
            b = FALSE;
            goto clean0;
        }

    
        //
        // Enumerate through all of the devices and stop each one.
        //
        for (p=Buffer, i=0; *p; p+=(lstrlen(p) + 1),i++) {
            printf("Stopping device %ws\n", p);

            if ((cr = CM_Locate_DevNode(&DevNode, p, 0)) == CR_SUCCESS) {
                if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) == CR_SUCCESS) &&
                    (Status & DN_STARTED)) {
                    DeviceInfo[i].DevNodeStarted = TRUE;
                } else {
                    printf("\tdevice is not started...skipping\n");
                    DeviceInfo[i].DevNodeStarted = FALSE;
                    continue;
                }

                //
                // We will pass in the VetoType and VetoName to 
                // CM_Query_And_Remove_Subtree so we can log while a specific
                // device could not be stopped.  This will also prevent the
                // kernel from poping up a dialog telling the user that the
                // device could not be removed.
                //
                // NOTE: It is important to note that on Whistler we pass in the
                // CM_REMOVE_NO_RESTART flag.  This ensures that the devnode
                // will not be restarted until we call CM_Setup_DevNode to 
                // restart it at a later time.  Without this flag (like in 
                // Windows 2000) it is possible for the device to restart again
                // due to some other program or driver triggering a 
                // reenumeration.
                //
                VetoNameLength = sizeof(VetoName)/sizeof(TCHAR);
                cr = CM_Query_And_Remove_SubTree(DevNode,
                                                 &VetoType,
                                                 VetoName,
                                                 VetoNameLength,
                                                 CM_QUERY_REMOVE_UI_NOT_OK
                                                 );
    
                if (cr == CR_REMOVE_VETOED) {
                    //
                    // Someone vetoed the removal of this device!
                    //
                    // This is here for logging purposes only.  If no logging is 
                    // required then there is no need for this check.
                    //
                    printf("\tVetoed 0x%X %ws\n", VetoType, VetoName);
                }
    
                if (cr != CR_SUCCESS) {
                    //
                    // If we couldn't stop one of the devices then we might as well
                    // stop since we are going to need a reboot.
                    //
                    printf("\tFailed with 0x%X!\n", cr);
                    b = FALSE;
                    break;
                }
    
            } else {
                //
                // If we couldn't locate one of the devices then there is no need to 
                // continue through the list since a reboot will be needed.
                //
                printf("\tCouldn't locate the devnode, error 0x%X!\n", cr);
                b = FALSE;
                break;
            }
        }

        printf("\n");

        if (b) {
            bIsDriverLoaded = IsDriverLoaded(ServiceName);
            
            printf("%ws %ws loaded\n\n", 
                   ServiceName, 
                   bIsDriverLoaded
                       ? TEXT("is")
                       : TEXT("is NOT")
                   );

            //
            // If the driver did not unload, even after we stopped all the
            // devices using it, the we need to reboot!
            //
            if (bIsDriverLoaded) {
                b = FALSE;
            }
        }
    
        //
        // At this point we need to enumerate through all the devices once again
        // and restart them all.  It doesn't matter whether we succeeded or not in
        // stopping them all, we still need to restart them.
        //
        for (p=Buffer, i=0; *p; p+=(lstrlen(p) + 1), i++) {
            printf("Starting device %ws\n", p);

            if ((cr = CM_Locate_DevNode(&DevNode, p, 0)) == CR_SUCCESS) {
                //
                // NOTE: For Whistler we will call CM_Setup_DevNode with the
                // CM_SETUP_DEVNODE_RESET flag which will clear the
                // CM_REMOVE_NO_RESTART flag we set earlier.  These two flags
                // ensure that the devnode will not get restarted by some other
                // program or driver until we want them to.
                //
                if ((cr = CM_Setup_DevNode(DevNode, CM_SETUP_DEVNODE_READY)) == CR_SUCCESS) {
                    //
                    // We successfully restarted the device, lets make sure that it
                    // started and doesn't have any problems.  We will only make
                    // this check if the device was started before.
                    //
                    if (DeviceInfo[i].DevNodeStarted == TRUE) {
                        if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) != CR_SUCCESS) ||
                            !(Status & DN_STARTED)) {
                            //
                            // We couldn't get the status of this device, or it did not 
                            // restart properly, so we will need to reboot.
                            //
                            printf("\tDevice could not be restarted!\n");
                            b = FALSE;
                        }
                    }
                } else {
                    //
                    // We couldn't restart this device, so we will need to reboot.
                    //
                    printf("\tDevice could not be restarted, error 0x%X!\n", cr);
                    b = FALSE;
                }
            } else {
                //
                // We couldn't locate the devnode to restart it.
                //
                printf("\tCouldn't locate the devnode, error 0x%X!\n", cr);
                b = FALSE;
            }
        }

        printf("%ws %ws loaded\n", 
               ServiceName, 
               IsDriverLoaded(ServiceName) 
                    ? TEXT("is")
                    : TEXT("is NOT")
               );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Buffer = Buffer;
        DeviceInfo = DeviceInfo;
        b = FALSE;
    }

clean0:

    if (Buffer) {
        LocalFree(Buffer);
    }

    if (DeviceInfo) {
        LocalFree(DeviceInfo);
    }

    return b;
}

int
__cdecl
wmain(
    IN int   argc,
    IN char *argv[]
    )
{
    SC_HANDLE hServiceManager;
    ENUM_SERVICE_STATUS ServiceStatus[1000];
    DWORD ResumeHandle = 0;
    DWORD cbBytesNeeded, cbServicesReturned;
    UINT i;

    hServiceManager = OpenSCManager(NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE);

    if (hServiceManager) {

        if (EnumServicesStatus(hServiceManager,
                                 SERVICE_DRIVER,
                                 SERVICE_ACTIVE,
                                 ServiceStatus,
                                 sizeof(ServiceStatus),
                                 &cbBytesNeeded,
                                 &cbServicesReturned,
                                 &ResumeHandle) ||
               (GetLastError() == ERROR_MORE_DATA)) {

            for (i=0; i<cbServicesReturned; i++) {
                
                printf("\n\n***********************************************************\n");
                printf("%ws\n", ServiceStatus[i].lpServiceName);
                RestartDevicesUsingService(ServiceStatus[i].lpServiceName);
                printf("***********************************************************\n");
            }
        }

        CloseServiceHandle(hServiceManager);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopdevs\precomp.h ===
#include "stopdevs.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopall\stopall.h ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <cfgmgr32.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopdevs\stopdevs.c ===
#include "precomp.h"
#pragma hdrstop

#define BUFFERSIZE 1024

typedef struct _DEVICEINFO {
    BOOL DevNodeStarted;
} DEVICEINFO, *PDEVICEINFO;

BOOL
IsDriverLoaded(
    PTSTR ServiceName
    )
{
    NTSTATUS Status;
    BOOL bObjectIsLoaded = FALSE;
    UCHAR Buffer[BUFFERSIZE];
    UNICODE_STRING UnicodeStringDriver, UnicodeStringServiceName;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;    
    POBJECT_NAME_INFORMATION NameInfo;
    ULONG Context = 0;
    ULONG ReturnedLength;

    RtlZeroMemory(Buffer, BUFFERSIZE);
    
    RtlInitUnicodeString(&UnicodeStringServiceName, ServiceName);
    RtlInitUnicodeString(&UnicodeStringDriver, TEXT("\\Driver"));

    InitializeObjectAttributes(&Attributes,
                               &UnicodeStringDriver,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL
                               );

    Status = NtOpenDirectoryObject(&DirectoryHandle,
                                   DIRECTORY_QUERY,
                                   &Attributes
                                   );

    if (!NT_SUCCESS(Status)) {
        printf("NtOpenDirectoryObject failed with 0x%X\n", Status);
        goto clean0;
    }

    //
    // Get the actual name of the object directory object.
    //
    NameInfo = (POBJECT_NAME_INFORMATION)&Buffer[0];
    if (!NT_SUCCESS(Status = NtQueryObject(DirectoryHandle,
                                           ObjectNameInformation,
                                           NameInfo,
                                           BUFFERSIZE,
                                           (PULONG)NULL))) {
        printf( "Unexpected error obtaining actual object directory name\n" );
        printf( "Error was:  %X\n", Status );                                 
        goto clean0;                                                               
    }

    //
    // Grab the driver objects in chuncks instead of one at a time.
    //
    for (Status = NtQueryDirectoryObject(DirectoryHandle,
                                         &Buffer,
                                         BUFFERSIZE,
                                         FALSE,
                                         FALSE,
                                         &Context,
                                         &ReturnedLength
                                         );
         NT_SUCCESS(Status) && !bObjectIsLoaded;
         Status = NtQueryDirectoryObject(DirectoryHandle,
                                         &Buffer,
                                         BUFFERSIZE,
                                         FALSE,
                                         FALSE,
                                         &Context,
                                         &ReturnedLength
                                         )) {
        if (!NT_SUCCESS(Status)) {
            if (Status != STATUS_NO_MORE_FILES) {
                printf("NtQueryDirectoryObject failed with 0x%X\n", Status);
            }
            break;
        }

        DirInfo = (POBJECT_DIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {
            //
            // Check if there is another record. If there isn't, then get out 
            // of the loop now.
            //
            if (DirInfo->Name.Length == 0) {
                break;
            }

            if (RtlCompareUnicodeString(&UnicodeStringServiceName, &(DirInfo->Name), TRUE) == 0) {
                bObjectIsLoaded = TRUE;
                break;
            }

            DirInfo = (POBJECT_DIRECTORY_INFORMATION)(((PUCHAR)DirInfo) +
                                                      sizeof(OBJECT_DIRECTORY_INFORMATION));
        }

        RtlZeroMemory(Buffer, BUFFERSIZE);
    }

clean0:
    NtClose(DirectoryHandle);

    return bObjectIsLoaded;
}
         
BOOL
RestartDevicesUsingService(
    LPTSTR ServiceName
    )
{
    BOOL b = TRUE;
    CONFIGRET cr;
    DEVNODE DevNode;
    BOOL bIsDriverLoaded;
    INT count, i;
    TCHAR VetoName[512];
    ULONG VetoNameLength;
    PNP_VETO_TYPE VetoType;
    ULONG Status, Problem;
    ULONG BufferLen;
    OSVERSIONINFO osvi;
    PTSTR Buffer = NULL;
    PTSTR p;
    PDEVICEINFO DeviceInfo = NULL;

    printf("Stopping all devices that are using the service %ws\n", ServiceName);

    try {
        bIsDriverLoaded = IsDriverLoaded(ServiceName);

        printf("%ws %ws loaded\n", 
               ServiceName, 
               bIsDriverLoaded
                    ? TEXT("is")
                    : TEXT("is NOT")
               );

        //
        // If this service is not loaded then we don't need to do anything.
        //
        if (!bIsDriverLoaded) {
            goto clean0;
        }
        
        //
        // Find out how large a buffer it will take to hold all the devices that
        // are using this service.
        //
        if (((cr = CM_Get_Device_ID_List_Size(&BufferLen,
                                              ServiceName,
                                              CM_GETIDLIST_FILTER_SERVICE
                                              )) != CR_SUCCESS) ||
            (BufferLen == 0)) {
            if (cr != CR_SUCCESS) {
                b = FALSE;
                printf("CM_Get_Device_ID_List_Size failed with 0x%X\n", cr);
            } else {
                printf("There are no devices using this service!\n");
            }
            goto clean0;
        }
    
        Buffer = LocalAlloc(LPTR, BufferLen*sizeof(TCHAR));
    
        if (Buffer == NULL) {
            b = FALSE;
            goto clean0;
        }
    
        //
        // Get all of the devices that are using this service.
        //
        if (CM_Get_Device_ID_List(ServiceName,
                                  Buffer,
                                  BufferLen,
                                  CM_GETIDLIST_FILTER_SERVICE | CM_GETIDLIST_DONOTGENERATE
                                  ) != CR_SUCCESS) {
            b = FALSE;
            goto clean0;
        }

        //
        // Count up how many devices we are dealing with.
        //
        count = 0;
        for (p = Buffer; *p; p += (lstrlen(p) + 1)) {
            count++;
        }

        if (count == 0) {
            printf("There are no devices using this service!\n");
            goto clean0;
        }

        printf("%d devices are using this service\n", count);

        //
        // Allocate an array of our DEVICEINFO structures so we can keep
        // track of the Devnodes and whether a device was started or not
        // before we tried to unloade the specified driver.
        //
        DeviceInfo = LocalAlloc(LPTR, count*sizeof(DEVICEINFO));

        if (DeviceInfo == NULL) {
            b = FALSE;
            goto clean0;
        }

    
        //
        // Enumerate through all of the devices and stop each one.
        //
        for (p=Buffer, i=0; *p; p+=(lstrlen(p) + 1),i++) {
            printf("Stopping device %ws\n", p);

            if ((cr = CM_Locate_DevNode(&DevNode, p, 0)) == CR_SUCCESS) {
                if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) == CR_SUCCESS) &&
                    (Status & DN_STARTED)) {
                    DeviceInfo[i].DevNodeStarted = TRUE;
                } else {
                    printf("\tdevice is not started...skipping\n");
                    DeviceInfo[i].DevNodeStarted = FALSE;
                    continue;
                }

                //
                // We will pass in the VetoType and VetoName to 
                // CM_Query_And_Remove_Subtree so we can log while a specific
                // device could not be stopped.  This will also prevent the
                // kernel from poping up a dialog telling the user that the
                // device could not be removed.
                //
                // NOTE: It is important to note that on Whistler we pass in the
                // CM_REMOVE_NO_RESTART flag.  This ensures that the devnode
                // will not be restarted until we call CM_Setup_DevNode to 
                // restart it at a later time.  Without this flag (like in 
                // Windows 2000) it is possible for the device to restart again
                // due to some other program or driver triggering a 
                // reenumeration.
                //
                VetoNameLength = sizeof(VetoName)/sizeof(TCHAR);
                cr = CM_Query_And_Remove_SubTree(DevNode,
                                                 &VetoType,
                                                 VetoName,
                                                 VetoNameLength,
                                                 CM_QUERY_REMOVE_UI_NOT_OK |
                                                 CM_REMOVE_NO_RESTART
                                                 );
    
                if (cr == CR_REMOVE_VETOED) {
                    //
                    // Someone vetoed the removal of this device!
                    //
                    // This is here for logging purposes only.  If no logging is 
                    // required then there is no need for this check.
                    //
                    printf("\tVetoed 0x%X %ws\n", VetoType, VetoName);
                }
    
                if (cr != CR_SUCCESS) {
                    //
                    // If we couldn't stop one of the devices then we might as well
                    // stop since we are going to need a reboot.
                    //
                    printf("\tFailed with 0x%X!\n", cr);
                    b = FALSE;
                    break;
                }
    
            } else {
                //
                // If we couldn't locate one of the devices then there is no need to 
                // continue through the list since a reboot will be needed.
                //
                printf("\tCouldn't locate the devnode, error 0x%X!\n", cr);
                b = FALSE;
                break;
            }
        }

        printf("\n");

        if (b) {
            bIsDriverLoaded = IsDriverLoaded(ServiceName);
            
            printf("%ws %ws loaded\n\n", 
                   ServiceName, 
                   bIsDriverLoaded
                       ? TEXT("is")
                       : TEXT("is NOT")
                   );

            //
            // If the driver did not unload, even after we stopped all the
            // devices using it, the we need to reboot!
            //
            if (bIsDriverLoaded) {
                b = FALSE;
            }
        }
    
        //
        // At this point we need to enumerate through all the devices once again
        // and restart them all.  It doesn't matter whether we succeeded or not in
        // stopping them all, we still need to restart them.
        //
        for (p=Buffer, i=0; *p; p+=(lstrlen(p) + 1), i++) {
            printf("Starting device %ws\n", p);

            if ((cr = CM_Locate_DevNode(&DevNode, p, 0)) == CR_SUCCESS) {
                //
                // NOTE: For Whistler we will call CM_Setup_DevNode with the
                // CM_SETUP_DEVNODE_RESET flag which will clear the
                // CM_REMOVE_NO_RESTART flag we set earlier.  These two flags
                // ensure that the devnode will not get restarted by some other
                // program or driver until we want them to.
                //
                if ((cr = CM_Setup_DevNode(DevNode, CM_SETUP_DEVNODE_READY)) == CR_SUCCESS) {
                    //
                    // We successfully restarted the device, lets make sure that it
                    // started and doesn't have any problems.  We will only make
                    // this check if the device was started before.
                    //
                    if (DeviceInfo[i].DevNodeStarted == TRUE) {
                        if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) != CR_SUCCESS) ||
                            !(Status & DN_STARTED)) {
                            //
                            // We couldn't get the status of this device, or it did not 
                            // restart properly, so we will need to reboot.
                            //
                            printf("\tDevice could not be restarted!\n");
                            b = FALSE;
                        }
                    }
                } else {
                    //
                    // We couldn't restart this device, so we will need to reboot.
                    //
                    printf("\tDevice could not be restarted, error 0x%X!\n", cr);
                    b = FALSE;
                }
            } else {
                //
                // We couldn't locate the devnode to restart it.
                //
                printf("\tCouldn't locate the devnode, error 0x%X!\n", cr);
                b = FALSE;
            }
        }

        printf("%ws %ws loaded\n", 
               ServiceName, 
               IsDriverLoaded(ServiceName) 
                    ? TEXT("is")
                    : TEXT("is NOT")
               );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Buffer = Buffer;
        DeviceInfo = DeviceInfo;
        b = FALSE;
    }

clean0:

    if (Buffer) {
        LocalFree(Buffer);
    }

    if (DeviceInfo) {
        LocalFree(DeviceInfo);
    }

    return b;
}

int
__cdecl
wmain(
    IN int   argc,
    IN char *argv[]
    )
{
    BOOL bDriverUnloaded; 

    if (argc != 2) {
        printf("Usage: StopDevs X\n");
        printf("\twhere X is the name of the service.\n");
        return 0;
    }

    bDriverUnloaded = RestartDevicesUsingService((LPTSTR)argv[1]);

    if (bDriverUnloaded) {
        printf("\n\nThe driver unloaded, no need to reboot!\n\n");
        return 1;
    } else {
        printf("\n\nThe driver did NOT unload, a reboot is required!\n\n");
        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\tools\stopdevs\stopdevs.h ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <tchar.h>
#include <cfgmgr32.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\main.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module contains the startup and termination code for the
    User-mode Plug-and-Play service.

Author:

    Paula Tomlinson (paulat) 6-20-1995

Environment:

    User mode only.

Revision History:

    3-Mar-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"

//
// global data
//
HANDLE  ghPnPHeap;                  // Private heap for PNP Manager
HANDLE  ghInst;                     // Module handle
HKEY    ghEnumKey = NULL;           // Key to HKLM\System\CCC\Enum
HKEY    ghServicesKey = NULL;       // Key to HKLM\System\CCC\Services
HKEY    ghClassKey = NULL;          // key to HKLM\System\CCC\Class
HKEY    ghPerHwIdKey = NULL;        // key to HKLM\Software\Microsoft\Windows NT\CurrentVersion\PerHwIdStorage
LUID    gLuidLoadDriverPrivilege;   // LUID of LoadDriver privilege
LUID    gLuidUndockPrivilege;       // LUID of Undock privilege

CRITICAL_SECTION PnpSynchronousCall;



BOOL
DllMainCRTStartup(
   PVOID hModule,
   ULONG Reason,
   PCONTEXT pContext
   )

/*++

Routine Description:

   This is the standard DLL entrypoint routine, called whenever a process
   or thread attaches or detaches.
   Arguments:

   hModule -   PVOID parameter that specifies the handle of the DLL

   Reason -    ULONG parameter that specifies the reason this entrypoint
               was called (either PROCESS_ATTACH, PROCESS_DETACH,
               THREAD_ATTACH, or THREAD_DETACH).

   pContext -  Reserved, not used.

Return value:

   Returns true if initialization compeleted successfully, false is not.

--*/

{
    UNREFERENCED_PARAMETER(pContext);

    ghInst = (HANDLE)hModule;

    switch (Reason) {

    case DLL_PROCESS_ATTACH:

        ghPnPHeap = HeapCreate(0, 65536, 0);

        if (ghPnPHeap == NULL) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Failed to create heap, error = %d\n",
                       GetLastError()));

            ghPnPHeap = GetProcessHeap();
        }

        try {
            InitializeCriticalSection(&PnpSynchronousCall);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // InitializeCriticalSection may raise STATUS_NO_MEMORY exception
            //
            return FALSE;
        }

        if (ghEnumKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathEnum, 0,
                                KEY_ALL_ACCESS, &ghEnumKey)
                                != ERROR_SUCCESS) {

                if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszRegPathEnum,
                                    0, NULL, REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS, NULL, &ghEnumKey,
                                    NULL) != ERROR_SUCCESS) {
                    ghEnumKey = NULL;
                }
            }
        }

        if (ghServicesKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathServices, 0,
                                KEY_ALL_ACCESS, &ghServicesKey)
                                != ERROR_SUCCESS) {
                ghServicesKey = NULL;
            }
        }

        if (ghClassKey == NULL) {

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathClass, 0,
                                KEY_ALL_ACCESS, &ghClassKey)
                                != ERROR_SUCCESS) {
                ghClassKey = NULL;
            }
        }

        if(ghPerHwIdKey == NULL) {

            if(ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                               pszRegPathPerHwIdStorage,
                                               0, 
                                               NULL, 
                                               REG_OPTION_NON_VOLATILE,
                                               KEY_ALL_ACCESS, 
                                               NULL, 
                                               &ghPerHwIdKey,
                                               NULL)) {
                ghPerHwIdKey = NULL;
            }
        }

        //
        // Initialize notification lists.
        //

        if (!InitNotification()) {
            return FALSE;
        }
        break;

    case DLL_PROCESS_DETACH:

        if (ghEnumKey != NULL) {
            RegCloseKey(ghEnumKey);
            ghEnumKey = NULL;
        }

        if (ghServicesKey != NULL) {
            RegCloseKey(ghServicesKey);
            ghServicesKey = NULL;
        }

        if (ghClassKey != NULL) {
            RegCloseKey(ghClassKey);
            ghClassKey = NULL;
        }

        if (ghPerHwIdKey != NULL) {
            RegCloseKey(ghPerHwIdKey);
            ghPerHwIdKey = NULL;
        }

        try {
            DeleteCriticalSection(&PnpSynchronousCall);
        } except(EXCEPTION_EXECUTE_HANDLER) {
            NOTHING;
        }

        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
        break;
    }

    return TRUE;

} // DllMainCRTStartup
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\osver.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    osver.c

Abstract:

    This module contains utility routines for identifying different NT product
    version types, suites, and feature attributes.

Author:

    Jim Cavalaris (jamesca) 03-07-2001

Environment:

    User-mode only.

Revision History:

    07-March-2001     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"


//
// global data
//

const TCHAR RegWinlogonKeyName[] =
      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");

const TCHAR RegAllowMultipleTSSessionsValueName[] =
      TEXT("AllowMultipleTSSessions");




BOOL
IsEmbeddedNT(
    VOID
    )
/*++

Routine Description:

    Check if this is Embedded product suite of NT.

Arguments:

    None.

Return Value:

    Return TRUE / FALSE.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsEmbeddedNT = FALSE;

    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osvix.wSuiteMask = VER_SUITE_EMBEDDEDNT;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_SUITENAME,
                              dwlConditionMask)) {
            bIsEmbeddedNT = TRUE;
        }

        bVerified = TRUE;
    }

    return bIsEmbeddedNT;

} // IsEmbeddedNT



BOOL
IsTerminalServer(
    VOID
    )
/*++

Routine Description:

    Check if Terminal Services are available on this version of NT.

Arguments:

    None.

Return Value:

    Return TRUE / FALSE.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsTerminalServer = FALSE;

    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix, VER_SUITENAME, dwlConditionMask)) {
            bIsTerminalServer = TRUE;
        }

        bVerified = TRUE;
    }

    return bIsTerminalServer;

} // IsTerminalServer



BOOL
IsFastUserSwitchingEnabled(
    VOID
    )
/*++

Routine Description:

    Checks to see if Terminal Services Fast User Switching is enabled.  This is
    to check if we should use the physical console session for UI dialogs, or
    always use session 0.

    Fast User Switching exists only on workstation product version, where terminal
    services are available, when AllowMultipleTSSessions is set.

    On server and above, or when multiple TS users are not allowed, session 0
    can only be attached remotely be special request, in which case it should be
    considered the "Console" session.

Arguments:

    None.

Return Value:

    Returns TRUE if Fast User Switching is currently enabled, FALSE otherwise.

--*/
{
    static BOOL bVerified = FALSE;
    static BOOL bIsTSWorkstation = FALSE;

    HKEY   hKey;
    ULONG  ulSize, ulValue;
    BOOL   bFusEnabled;

    //
    // Verify the product version if we haven't already.
    //
    if (!bVerified) {
        OSVERSIONINFOEX osvix;
        DWORDLONG dwlConditionMask = 0;

        ZeroMemory(&osvix, sizeof(OSVERSIONINFOEX));
        osvix.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        osvix.wProductType = VER_NT_WORKSTATION;
        VER_SET_CONDITION(dwlConditionMask, VER_PRODUCT_TYPE, VER_LESS_EQUAL);

        osvix.wSuiteMask = VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS;
        VER_SET_CONDITION(dwlConditionMask, VER_SUITENAME, VER_OR);

        if (VerifyVersionInfo(&osvix,
                              VER_PRODUCT_TYPE | VER_SUITENAME,
                              dwlConditionMask)) {
            bIsTSWorkstation = TRUE;
        }

        bVerified = TRUE;
    }

    //
    // Fast user switching (FUS) only applies to the Workstation product where
    // Terminal Services are enabled (i.e. Personal, Professional).
    //
    if (!bIsTSWorkstation) {
        return FALSE;
    }

    //
    // Check if multiple TS sessions are currently allowed.  We can't make this
    // info static because it can change dynamically.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     RegWinlogonKeyName,
                     0,
                     KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    ulValue = 0;
    ulSize = sizeof(ulValue);
    bFusEnabled = FALSE;

    if (RegQueryValueEx(hKey,
                        RegAllowMultipleTSSessionsValueName,
                        NULL,
                        NULL,
                        (LPBYTE)&ulValue,
                        &ulSize) == ERROR_SUCCESS) {
        bFusEnabled = (ulValue != 0);
    }
    RegCloseKey(hKey);

    return bFusEnabled;

} // IsFastUserSwitchingEnabled




=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\pnp_s_stub.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    pnp_s_stub.c

Abstract:

    Stub file to allow pnp_s.c to work with precompiled headers.

Author:

    Jim Cavalaris (jamesca) 04-06-2001

Environment:

    User-mode only.

Revision History:

    06-April-2001     jamesca

        Creation and initial implementation.

Notes:

    The included file pnp_s.c contains the server side stubs for the PNP RPC
    interface.  The stubs are platform specific, and are included from
    ..\idl\$(O).  You must first build ..\idl for the current platform prior to
    building umpnpmgr.

--*/

#include "precomp.h"
#include "pnp_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rconflist.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rconflist.c

Abstract:

    This module contains the server-side conflict list reporting APIs.

                  PNP_QueryResConfList

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"


//
// private prototypes
//
CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceID,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    );



CONFIGRET
PNP_QueryResConfList(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  RESOURCEID ResourceID,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   OUT LPBYTE     clBuffer,
   IN  ULONG      clBufferLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  conflict information for a specified resource.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ResourceID    Type of resource, ResType_xxxx

    ResourceData  Resource specific data

    ResourceLen   length of ResourceData

    clBuffer      Buffer filled with conflict list

    clBufferLen   Size of clBuffer

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET           Status = CR_SUCCESS;
    NTSTATUS            NtStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CONFLICT_DATA ControlData;
    PPLUGPLAY_CONTROL_CONFLICT_LIST pConflicts;
    CM_RESOURCE_LIST    NtResourceList;
    ULONG               Index;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(ResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // look at buffer we need to fill in
        // validate parameters passed in buffer
        // buffer should always be big enough to hold header
        //
        if(clBufferLen < sizeof(PPLUGPLAY_CONTROL_CONFLICT_LIST)) {
            Status = CR_INVALID_STRUCTURE_SIZE;
            goto Clean0;
        }

        pConflicts = (PPLUGPLAY_CONTROL_CONFLICT_LIST)clBuffer;

        //
        // Convert the user-mode version of the resource list to an
        // NT CM_RESOURCE_LIST structure.
        //
        // we'll sort out InterfaceType and BusNumber in kernel
        //
        NtResourceList.Count = 1;
        NtResourceList.List[0].InterfaceType           = InterfaceTypeUndefined;
        NtResourceList.List[0].BusNumber               = 0;
        NtResourceList.List[0].PartialResourceList.Version = NT_RESLIST_VERSION;
        NtResourceList.List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
        NtResourceList.List[0].PartialResourceList.Count = 1;

        Status = ResDesToNtResource(ResourceData, ResourceID, ResourceLen,
                 &NtResourceList.List[0].PartialResourceList.PartialDescriptors[0], 0, ulFlags);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // now fill in ControlData
        //
        RtlInitUnicodeString(&ControlData.DeviceInstance, pDeviceID);
        ControlData.ResourceList = &NtResourceList;
        ControlData.ResourceListSize = sizeof(NtResourceList);
        ControlData.ConflictBuffer = pConflicts;
        ControlData.ConflictBufferSize = clBufferLen;
        ControlData.Flags = ulFlags;
        ControlData.Status = STATUS_SUCCESS;

        NtStatus = NtPlugPlayControl(PlugPlayControlQueryConflictList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NtStatus == STATUS_SUCCESS) {
            Status = CR_SUCCESS;
        } else {
            Status = MapNtStatusToCmError(NtStatus);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // unspecified failure
        //
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_QueryResConfList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\precomp.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the user-mode Plug and Play Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpnpapi.h>
#include <ntddpcm.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <cfgmgr32.h>
#include <dbt.h>
#include <regstr.h>
#include <infstr.h>

//
// Win32 Private Header Files
//
#include <pnpmgr.h>
#include <winuserp.h>

//
// CRT Header Files
//
#include <stdlib.h>

//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "umpnplib.h"   // private shared header, for routines in shared umpnplib
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rhwprof.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    rhwprof.c

Abstract:

    This module contains the server-side hardware profile APIs.

                  PNP_IsDockStationPresent
                  PNP_RequestEjectPC
                  PNP_HwProfFlags
                  PNP_GetHwProfInfo
                  PNP_SetHwProf

Author:

    Paula Tomlinson (paulat) 7-18-1995

Environment:

    User-mode only.

Revision History:

    18-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//

#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"

#include <profiles.h>


//
// private prototypes
//
BOOL
IsCurrentProfile(
      ULONG  ulProfile
      );



CONFIGRET
PNP_IsDockStationPresent(
    IN  handle_t     hBinding,
    OUT PBOOL        Present
    )

/*++

Routine Description:
    This routine determines whether a docking station is currently present.

Parameters:

    hBinding         RPC binding handle, not used.

    Present          Supplies the address of a boolean variable that is set
                     upon successful return to indicate whether or not a
                     docking station is currently present.

Return Value:

    If the function succeeds, the return value is CR_SUCCESS.
        If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   status = CR_SUCCESS;
    ULONG       regStatus = ERROR_SUCCESS;
    HKEY        hCurrentDockInfo = NULL, hIDConfigDB = NULL;
    DWORD       dataType;
    ULONG       dockingState;
    ULONG       ejectableDocks;
    ULONG       size;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters.
        //
        if (!ARGUMENT_PRESENT(Present)) {
            status = CR_FAILURE;
            goto Clean0;
        }

        *Present = FALSE;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         pszRegPathIDConfigDB,
                         0,
                         KEY_READ,
                         &hIDConfigDB) != ERROR_SUCCESS) {
            status = CR_REGISTRY_ERROR;
            hIDConfigDB = NULL;
            goto Clean0;
        }

        if (RegOpenKeyEx(hIDConfigDB,
                         pszRegKeyCurrentDockInfo,
                         0,
                         KEY_READ,
                         &hCurrentDockInfo) != ERROR_SUCCESS) {
            status = CR_REGISTRY_ERROR;
            hCurrentDockInfo = NULL;
            goto Clean0;
        }

        size = sizeof (dockingState);

        if ((RegQueryValueEx(hCurrentDockInfo,
                             pszRegValueDockingState,
                             0,
                             &dataType,
                             (PUCHAR) &dockingState,
                             &size) != ERROR_SUCCESS) ||
            (dataType != REG_DWORD)   ||
            (size != sizeof (ULONG))) {
            status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        if ((dockingState & HW_PROFILE_DOCKSTATE_UNKNOWN) ==
            HW_PROFILE_DOCKSTATE_DOCKED) {

            size = sizeof(ejectableDocks);

            if ((RegQueryValueEx(hCurrentDockInfo,
                                 pszRegValueEjectableDocks,
                                 0,
                                 &dataType,
                                 (PUCHAR) &ejectableDocks,
                                 &size) == ERROR_SUCCESS) &&
                (dataType == REG_DWORD) &&
                (size == sizeof(ULONG)) &&
                (ejectableDocks > 0)) {
                *Present = TRUE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        status = CR_FAILURE;
    }

    if (hIDConfigDB) {
        RegCloseKey(hIDConfigDB);
    }

    if (hCurrentDockInfo) {
        RegCloseKey(hCurrentDockInfo);
    }

    return status;

} // PNP_IsDockStationPresent



CONFIGRET
PNP_RequestEjectPC(
    IN  handle_t     hBinding
    )

/*++

Routine Description:

    This routine requests that the PC be ejected (i.e., undocked).

Parameters:

   hBinding          RPC binding handle.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is a CR failure code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    WCHAR       szDockDevInst[MAX_DEVICE_ID_LEN + 1];
    PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA dockData;

    try {
        dockData.DeviceInstance = szDockDevInst;
        dockData.DeviceInstanceLength = MAX_DEVICE_ID_LEN;

        ntStatus = NtPlugPlayControl(PlugPlayControlRetrieveDock,
                                     &dockData,
                                     sizeof(PLUGPLAY_CONTROL_RETRIEVE_DOCK_DATA));

        if (NT_SUCCESS(ntStatus)) {
            Status = PNP_RequestDeviceEject(hBinding,
                                            szDockDevInst,
                                            NULL,           // pVetoType
                                            NULL,           // pszVetoName
                                            0,              // ulNameLength
                                            0);             // ulFlags
        } else {
            Status = MapNtStatusToCmError(ntStatus);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RequestEjectPC



CONFIGRET
PNP_HwProfFlags(
      IN handle_t     hBinding,
      IN ULONG        ulAction,
      IN LPCWSTR      pDeviceID,
      IN ULONG        ulConfig,
      IN OUT PULONG   pulValue,
      OUT PPNP_VETO_TYPE   pVetoType,
      OUT LPWSTR      pszVetoName,
      IN ULONG        ulNameLength,
      IN ULONG        ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routines that
  get and set the hardware profile flags.

Arguments:

   hBinding          RPC binding handle.

   ulAction          Specified whether to get or set the flag.  Can be one
                     of the PNP_*_HWPROFFLAGS values.

   pDeviceID         Device instance to get/set the hw profile flag for.

   ulConfig          Specifies which profile to get/set the flag for. A
                     value of zero indicates to use the current profile.

   pulValue          If setting the flag, then this value on entry contains
                     the value to set the hardware profile flag to.  If
                     getting the flag, then this value will return the
                     current hardware profile flag.

   pVetoType         Buffer to receive the type of veto. If this is NULL
                     then no veto information will be received and the OS wil
                     display the veto information.

   pszVetoName       Buffer to receive the veto information. If this is NULL
                     then no veto information will be received and the OS will
                     display the veto information.

   ulNameLength      Size of the pszVetoName buffer.

   ulFlags           Depends on the action being performed.
                     For PNP_GET_HWPROFFLAGS, no flags are valid.
                     For PNP_SET_HWPROFFLAGS, may be CM_SET_HW_PROF_FLAGS_BITS.

Return Value:

   If the function succeeds it returns CR_SUCCESS.  Otherwise it returns one
   of the CR_* values.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH];
    HKEY        hKey = NULL, hDevKey = NULL;
    ULONG       ulValueSize = sizeof(ULONG);
    ULONG       ulCurrentValue, ulChange, ulDisposition;
    BOOL        AffectsCurrentProfile;

    //
    // NOTE: The device is not checked for presense or not, this flag is
    // always just set or retrieved directly from the registry, as it is
    // done on Windows 95
    //

    try {
        //
        // validate parameters
        //
        if ((ulAction != PNP_GET_HWPROFFLAGS) &&
            (ulAction != PNP_SET_HWPROFFLAGS)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulValue)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (ulAction == PNP_GET_HWPROFFLAGS) {
            //
            // Validate flags for PNP_GET_HWPROFFLAGS
            //
            if (INVALID_FLAGS(ulFlags, 0)) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }

        } else if (ulAction == PNP_SET_HWPROFFLAGS) {
            //
            // Validate flags and value for PNP_SET_HWPROFFLAGS
            //
            if (INVALID_FLAGS(ulFlags, CM_SET_HW_PROF_FLAGS_BITS)) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }
            if (INVALID_FLAGS(*pulValue, CSCONFIGFLAG_BITS)) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // a configuration value of zero implies to use the current config
        //
        if (ulConfig == 0) {
            wsprintf(RegStr, TEXT("%s\\%s\\%s"),
                     pszRegPathHwProfiles,      // System\CCC\Hardware Profiles
                     pszRegKeyCurrent,          // Current
                     pszRegPathEnum);           // System\Enum
        } else {
            wsprintf(RegStr, TEXT("%s\\%04u\\%s"),
                     pszRegPathHwProfiles,      // System\CCC\Hardware Profiles
                     ulConfig,                  // xxxx (profile id)
                     pszRegPathEnum);           // System\Enum
        }

        //----------------------------------------------------
        // caller wants to retrieve the hw profile flag value
        //----------------------------------------------------

        if (ulAction == PNP_GET_HWPROFFLAGS) {

            //
            // open the profile specific enum key
            //
            RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, RegStr, 0,
                                      KEY_QUERY_VALUE, &hKey);

            if (RegStatus != ERROR_SUCCESS) {
                *pulValue = 0;          // success,this is what Win95 does
                goto Clean0;
            }

            //
            // open the enum\device-instance key under the profile key
            //
            RegStatus = RegOpenKeyEx( hKey, pDeviceID, 0, KEY_QUERY_VALUE, &hDevKey);

            if (RegStatus != ERROR_SUCCESS) {
                *pulValue = 0;          // success,this is what Win95 does
                goto Clean0;
            }

            //
            // query the profile flag
            //
            ulValueSize = sizeof(ULONG);
            RegStatus = RegQueryValueEx( hDevKey, pszRegValueCSConfigFlags,
                                         NULL, NULL, (LPBYTE)pulValue,
                                         &ulValueSize);

            if (RegStatus != ERROR_SUCCESS) {

                *pulValue = 0;

                if (RegStatus != ERROR_CANTREAD && RegStatus != ERROR_FILE_NOT_FOUND) {
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }
            }
        }


        //----------------------------------------------
        // caller wants to set the hw profile flag value
        //----------------------------------------------

        else if (ulAction == PNP_SET_HWPROFFLAGS) {

            if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
                Status = CR_ACCESS_DENIED;
                goto Clean0;
            }

            //
            // open the profile specific enum key.
            //
            // note that we may actually end up creating a Hardware Profile key
            // here for the specified profile id, even if no such profile
            // exists.  ideally, we should check that such a profile exists, but
            // we've been doing this for too long to change it now.  the
            // consolation here is that the client must have appropriate
            // privilege to actually do this.
            //
            RegStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE, RegStr, 0, NULL,
                                        REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE,
                                        NULL, &hKey, &ulDisposition);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // open the enum\device-instance key under the profile key
            //
            RegStatus = RegCreateKeyEx( hKey, pDeviceID, 0, NULL,
                                        REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                        NULL, &hDevKey, NULL);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // before setting, query the current profile flag
            //
            ulValueSize = sizeof(ulCurrentValue);
            RegStatus = RegQueryValueEx( hDevKey, pszRegValueCSConfigFlags,
                                         NULL, NULL, (LPBYTE)&ulCurrentValue,
                                         &ulValueSize);

            if (RegStatus == ERROR_CANTREAD || RegStatus == ERROR_FILE_NOT_FOUND) {

                ulCurrentValue = 0;       // success,this is what Win95 does

            } else if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // if requested flags different than current, write out to registry
            //
            ulChange = ulCurrentValue ^ *pulValue;

            if (ulChange) {

                AffectsCurrentProfile = (BOOL)(ulConfig == 0 || IsCurrentProfile(ulConfig));

                //
                // we're about to change the disable bit on the current profile,
                // try and disable the device in the process
                //
                if ((ulChange & CSCONFIGFLAG_DISABLED) &&
                    (*pulValue & CSCONFIGFLAG_DISABLED) && AffectsCurrentProfile) {
                    //
                    // disable the devnode
                    //
                    Status = DisableDevInst(pDeviceID,
                                            pVetoType,
                                            pszVetoName,
                                            ulNameLength);
                    if (Status != CR_SUCCESS) {
                        if (Status == CR_NOT_DISABLEABLE) {
                            //
                            // we got refused!
                            // (note that this error also implies *NO* changes to the registry entry)
                            //
                            goto Clean0;

                        } else {
                            //
                            // we can go ahead and disable after restart
                            //
                            Status = CR_NEED_RESTART;
                        }
                    }
                }
                //
                // assume Status is valid and typically CR_SUCCESS or CR_NEED_RESTART
                //

                //
                // now update the registry
                //
                RegStatus = RegSetValueEx( hDevKey, pszRegValueCSConfigFlags, 0,
                                        REG_DWORD, (LPBYTE)pulValue,
                                        sizeof(ULONG));

                if (RegStatus != ERROR_SUCCESS) {
                    Status = CR_REGISTRY_ERROR;
                    goto Clean0;
                }

                if (Status == CR_NEED_RESTART) {
                    //
                    // we have to RESTART due to not being able to disable device immediately
                    //
                    goto Clean0;
                }

                //
                // If this doesn't effect the current config, then we're done.
                //
                if (!AffectsCurrentProfile) {
                    goto Clean0;
                }

                //
                // are we enabling the device?
                //

                if ((ulChange & CSCONFIGFLAG_DISABLED) && !(*pulValue & CSCONFIGFLAG_DISABLED)) {
                    //
                    // enable the devnode
                    //
                    EnableDevInst(pDeviceID);
                }

                //
                // did the do-not-create bit change?
                //
                if (ulChange & CSCONFIGFLAG_DO_NOT_CREATE) {
                    if (*pulValue & CSCONFIGFLAG_DO_NOT_CREATE) {
                        //
                        // if subtree can be removed, remove it now
                        //
                        if (QueryAndRemoveSubTree( pDeviceID,
                                                pVetoType,
                                                pszVetoName,
                                                ulNameLength,
                                                PNP_QUERY_AND_REMOVE_NO_RESTART) != CR_SUCCESS) {

                            Status = CR_NEED_RESTART;
                            goto Clean0;
                        }
                    }
                    else {
                        //
                        // The DO_NOT_CREATE flag was turned off, reenumerate the devnode
                        //
                        ReenumerateDevInst(pDeviceID, TRUE, 0);
                    }
                }
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (hDevKey != NULL) {
        RegCloseKey(hDevKey);
    }

    return Status;

} // PNP_HwProfFlags



CONFIGRET
PNP_GetHwProfInfo(
      IN  handle_t       hBinding,
      IN  ULONG          ulIndex,
      OUT PHWPROFILEINFO pHWProfileInfo,
      IN  ULONG          ulProfileInfoSize,
      IN  ULONG          ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routine
  CM_Get_Hardware_Profile_Info.  It returns a structure of info for
  the specified hardware profile.

Arguments:

   hBinding          RPC binding handle, not used.

   ulIndex           Specifies which profile to use. A value of 0xFFFFFFFF
                     indicates to use the current profile.

   pHWProfileInfo    Pointer to HWPROFILEINFO struct, returns profile info

   ulProfileInfoSize Specifies the size of the HWPROFILEINFO struct

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds it returns CR_SUCCESS.  Otherwise it returns one
   of the CR_* values.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   ULONG       RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH];
   HKEY        hKey = NULL, hDockKey = NULL, hCfgKey = NULL;
   ULONG       ulSize, ulDisposition;
   ULONG       enumIndex, targetIndex;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, 0)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      //
      // validate the size of the HWPROFILEINFO struct
      //
      if (ulProfileInfoSize != sizeof(HWPROFILEINFO)) {
        Status = CR_INVALID_DATA;
        goto Clean0;
      }

      //
      // initialize the HWPROFILEINFO struct fields
      //
      pHWProfileInfo->HWPI_ulHWProfile = 0;
      pHWProfileInfo->HWPI_szFriendlyName[0] = '\0';
      pHWProfileInfo->HWPI_dwFlags = 0;

      //
      // open a key to IDConfigDB (create if it doesn't already exist
      //
      RegStatus = RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszRegPathIDConfigDB, 0,
                                 NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE,
                                 NULL, &hKey, &ulDisposition);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }

      //
      // open a key to Hardware Profiles (create if it doesn't already exist)
      //
      RegStatus = RegCreateKeyEx(hKey, pszRegKeyKnownDockingStates, 0,
                                 NULL, REG_OPTION_NON_VOLATILE,
                                 KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, NULL,
                                 &hDockKey, &ulDisposition);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }


      //
      // a configuration value of 0xFFFFFFFF implies to use the current config
      //
      if (ulIndex == 0xFFFFFFFF) {
         //
         // get the current profile index stored under IDConfigDB
         //
         ulSize = sizeof(ULONG);
         RegStatus = RegQueryValueEx(
                  hKey, pszRegValueCurrentConfig, NULL, NULL,
                  (LPBYTE)&pHWProfileInfo->HWPI_ulHWProfile, &ulSize);

         if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            pHWProfileInfo->HWPI_ulHWProfile = 0;
            goto Clean0;
         }

      }

      //
      // values other than 0xFFFFFFFF mean that we're essentially
      // enumerating profiles (the value is an enumeration index)
      //
      else {
         //
         // enumerate the profile keys under Known Docking States
         //
         Status = CR_SUCCESS;
         enumIndex = 0;
         targetIndex = ulIndex;
         while(enumIndex <= targetIndex) {
             ulSize = MAX_CM_PATH;
             RegStatus = RegEnumKeyEx(hDockKey,
                                      enumIndex,
                                      RegStr,
                                      &ulSize,
                                      NULL,
                                      NULL,
                                      NULL,
                                      NULL);
             if (RegStatus == ERROR_NO_MORE_ITEMS) {
                 Status = CR_NO_MORE_HW_PROFILES;
                 goto Clean0;
             } else if (RegStatus != ERROR_SUCCESS) {
                 Status = CR_REGISTRY_ERROR;
                 goto Clean0;
             }

             if (_wtoi(RegStr) == 0) {
                 //
                 // we found the pristine amidst the profiles we're enumerating.
                 // enumerate one extra key to make up for it.
                 //
                 targetIndex++;
             }
             if (enumIndex == targetIndex) {
                 //
                 // this is the one we want.
                 //
                 pHWProfileInfo->HWPI_ulHWProfile = _wtoi(RegStr);
                 Status = CR_SUCCESS;
                 break;
             }
             enumIndex++;
         }
      }

      //
      // open the key for this profile
      //
      wsprintf(RegStr, TEXT("%04u"),
               pHWProfileInfo->HWPI_ulHWProfile);

      RegStatus = RegOpenKeyEx(
               hDockKey, RegStr, 0, KEY_QUERY_VALUE, &hCfgKey);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }

      //
      // retrieve the friendly name
      //
      ulSize = MAX_PROFILE_LEN * sizeof(WCHAR);
      RegStatus = RegQueryValueEx(
               hCfgKey, pszRegValueFriendlyName, NULL, NULL,
               (LPBYTE)(pHWProfileInfo->HWPI_szFriendlyName),
               &ulSize);

      //
      // retrieve the DockState
      //
#if 0
//
// KENRAY
// This is the wrong way to determine docking state caps
// You must instead check the alias tables
//
      wsprintf(RegStr, TEXT("%04u"), pHWProfileInfo->HWPI_ulHWProfile);

      ulSize = sizeof(SYSTEM_DOCK_STATE);
      RegStatus = RegQueryValueEx(
               hCfgKey, pszRegValueDockState, NULL, NULL,
               (LPBYTE)&DockState, &ulSize);

      if (RegStatus != ERROR_SUCCESS) {
         pHWProfileInfo->HWPI_dwFlags = CM_HWPI_NOT_DOCKABLE;
      }
      else {
         //
         // map SYSTEM_DOCK_STATE enumerated types into CM_HWPI_ flags
         //
         if (DockState == SystemDocked) {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_DOCKED;
         }
         else if (DockState == SystemUndocked) {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_UNDOCKED;
         }
         else {
            pHWProfileInfo->HWPI_dwFlags = CM_HWPI_NOT_DOCKABLE;
         }
      }
#endif

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }
   if (hDockKey != NULL) {
      RegCloseKey(hDockKey);
   }
   if (hCfgKey != NULL) {
      RegCloseKey(hCfgKey);
   }

   return Status;

} // PNP_GetHwProfInfo



CONFIGRET
PNP_SetHwProf(
    IN  handle_t   hBinding,
    IN  ULONG      ulHardwareProfile,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(ulHardwareProfile);
    UNREFERENCED_PARAMETER(ulFlags);

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_SetHwProf



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------

BOOL
IsCurrentProfile(
      ULONG  ulProfile
      )

/*++

Routine Description:

  This routine determines if the specified profile matches the current
  profile.

Arguments:

   ulProfile    Profile id value (value from 1 - 9999).

Return Value:

   Return TRUE if this is the current profile, FALSE if it isn't.

--*/

{
   HKEY  hKey;
   ULONG ulSize, ulCurrentProfile;

   //
   // open a key to IDConfigDB
   //
   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegPathIDConfigDB, 0,
            KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
       return FALSE;
   }

   //
   // get the current profile index stored under IDConfigDB
   //
   ulSize = sizeof(ULONG);
   if (RegQueryValueEx(
            hKey, pszRegValueCurrentConfig, NULL, NULL,
            (LPBYTE)&ulCurrentProfile, &ulSize) != ERROR_SUCCESS) {
      RegCloseKey(hKey);
      return FALSE;
   }

   RegCloseKey(hKey);

   if (ulCurrentProfile == ulProfile) {
      return TRUE;
   }

   return FALSE;

} // IsCurrentProfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rmisc.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rmisc.c

Abstract:

    This module contains the server-side misc configuration manager routines.

                  PNP_GetVersion
                  PNP_GetVersionInternal
                  PNP_GetGlobalState
                  PNP_SetActiveService
                  PNP_QueryArbitratorFreeData
                  PNP_QueryArbitratorFreeSize
                  PNP_RunDetection
                  PNP_Connect
                  PNP_Disconnect
                  PNP_GetBlockedDriverInfo

    The following routines are used by the RPC server stubs to allocate and free memory.

                  MIDL_user_allocate
                  MIDL_user_free

Author:

    Paula Tomlinson (paulat) 6-28-1995

Environment:

    User-mode only.

Revision History:

    28-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"


//
// global data
//

extern DWORD CurrentServiceState; // current state of the PlugPlay service - DO NOT MODIFY



CONFIGRET
PNP_GetVersion(
   IN handle_t      hBinding,
   IN OUT WORD *    pVersion
   )

/*++

Routine Description:

  This is the RPC server entry point, it returns the version
  number for the server-side component.

Arguments:

   hBinding    Not used.


Return Value:

   Return the version number, with the major version in the high byte and
   the minor version number in the low byte.

--*/

{
   CONFIGRET      Status = CR_SUCCESS;

   UNREFERENCED_PARAMETER(hBinding);

   try {

      *pVersion = (WORD)PNP_VERSION;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetVersion



CONFIGRET
PNP_GetVersionInternal(
   IN handle_t      hBinding,
   IN OUT WORD *    pwVersion
   )
/*++

Routine Description:

  This is the RPC server entry point, it returns the internal version
  number for the server-side component.

Arguments:

   hBinding    Not used.

   pwVersion   Receives the internal cfgmgr32 version number, returns the
               internal server version number, with the major version in the
               high byte and the minor version number in the low byte.

Return Value:

   Return CR_SUCCESS if the function succeeds, otherwise it returns one
   of the CR_* errors.

--*/
{
    CONFIGRET  Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        *pwVersion = (WORD)PNP_VERSION_INTERNAL;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetVersionInternal



CONFIGRET
PNP_GetGlobalState(
   IN  handle_t   hBinding,
   OUT PULONG     pulState,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point, it returns the Global State of the
  Configuration Manager.

Arguments:

   hBinding    Not used.

   pulState    Returns the current global state.

   ulFlags     Not used, must be zero.


Return Value:

   Return CR_SUCCESS if the function succeeds, otherwise it returns one
   of the CR_* errors.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;

   UNREFERENCED_PARAMETER(hBinding);

   if (INVALID_FLAGS(ulFlags, 0)) {
       return CR_INVALID_FLAG;
   }

   try {
      *pulState =
            CM_GLOBAL_STATE_CAN_DO_UI |
            CM_GLOBAL_STATE_SERVICES_AVAILABLE;

      if ((CurrentServiceState == SERVICE_STOP_PENDING) ||
          (CurrentServiceState == SERVICE_STOPPED)) {
          *pulState |= CM_GLOBAL_STATE_SHUTTING_DOWN;
      }

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetGlobalState



CONFIGRET
PNP_SetActiveService(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pszService,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

    This routine is currently not an rpc routine, it is called directly
    and privately by the service controller.

Arguments:

    hBinding    RPC binding handle, not used.

    pszService  Specifies the service name.

    ulFlags     Either PNP_SERVICE_STARTED or PNP_SERVICE_STOPPED.


Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize = 0, ulStatus = 0;
    LPWSTR      pDeviceList = NULL, pszDevice = NULL;
    HKEY        hKey = NULL, hControlKey = NULL;
    WCHAR       RegStr[MAX_PATH];

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (pszService == NULL) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((ulFlags != PNP_SERVICE_STOPPED) &&
            (ulFlags != PNP_SERVICE_STARTED)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // not handling stops right now, everything beyond here assumes
        // the service is starting (or at least it attempted to start)
        //
        if (ulFlags == PNP_SERVICE_STOPPED) {
            goto Clean0;    // not handling this right now
        }


        //
        // retreive the list of devices that this service is controlling
        //
        Status = PNP_GetDeviceListSize(NULL, pszService, &ulSize,
                                       CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
        if (pDeviceList == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        Status = PNP_GetDeviceList(NULL, pszService, pDeviceList, &ulSize,
                                   CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }


        //
        // set the ActiveService value for each device
        //
        for (pszDevice = pDeviceList;
             *pszDevice;
             pszDevice += lstrlen(pszDevice) + 1) {

            wsprintf(RegStr, TEXT("%s\\%s"),
                     pszRegPathEnum,
                     pszDevice);

            //
            // open the device instance key
            //
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
                             &hKey) == ERROR_SUCCESS) {

                //
                // open/create the volatile Control key
                //
                if (RegCreateKeyEx(hKey, pszRegKeyDeviceControl, 0, NULL,
                                   REG_OPTION_VOLATILE, KEY_ALL_ACCESS, NULL,
                                   &hControlKey, NULL) == ERROR_SUCCESS) {

                    RegSetValueEx(hControlKey, pszRegValueActiveService,
                                  0, REG_SZ, (LPBYTE)pszService,
                                  (lstrlen(pszService) + 1) * sizeof(WCHAR));

                    //
                    // set the statusflag to DN_STARTED
                    //
                    SetDeviceStatus(pszDevice, DN_STARTED, 0);

                    RegCloseKey(hControlKey);
                    hControlKey = NULL;
                }

                RegCloseKey(hKey);
                hKey = NULL;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }


    if (pDeviceList != NULL) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_SetActiveService



//--------------------------------------------------------------------
// Stub server side CM routines - not implemented yet
//--------------------------------------------------------------------


CONFIGRET
PNP_QueryArbitratorFreeData(
    IN  handle_t   hBinding,
    OUT LPBYTE     pData,
    IN  ULONG      ulDataLen,
    IN  LPCWSTR    pszDeviceID,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pData);
    UNREFERENCED_PARAMETER(ulDataLen);
    UNREFERENCED_PARAMETER(pszDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ulFlags);

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_QueryArbitratorFreeData



CONFIGRET
PNP_QueryArbitratorFreeSize(
    IN  handle_t   hBinding,
    OUT PULONG     pulSize,
    IN  LPCWSTR    pszDeviceID,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pszDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ulFlags);

    try {
        if (ARGUMENT_PRESENT(pulSize)) {
            *pulSize = 0;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_QueryArbitratorFreeSize



CONFIGRET
PNP_RunDetection(
    IN  handle_t   hBinding,
    IN  ULONG      ulFlags
    )
{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(ulFlags);

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_RunDetection



CONFIGRET
PNP_Connect(
   IN PNP_HANDLE  UNCServerName
   )
{
   UNREFERENCED_PARAMETER(UNCServerName);
   return CR_SUCCESS;

} // PNP_Connect


CONFIGRET
PNP_Disconnect(
   IN PNP_HANDLE  UNCServerName
   )
{
   UNREFERENCED_PARAMETER(UNCServerName);
   return CR_SUCCESS;

} // PNP_Disconnect



CONFIGRET
PNP_GetBlockedDriverInfo(
    IN handle_t     hBinding,
    OUT LPBYTE      Buffer,
    OUT PULONG      pulTransferLen,
    IN OUT  PULONG  pulLength,
    IN ULONG        ulFlags
    )

/*++

Routine Description:

   This is the RPC server entry point for the CMP_GetBlockedDriverInfo routine.

Arguments:

   hBinding        - RPC binding handle, not used.

   Buffer          - Supplies the address of the buffer that receives the
                     list.  Can be NULL when simply retrieving data size.

   pulTransferLen  - Used by stubs, indicates how much data (in bytes) to
                     copy back into user buffer.

   pulLength       - Parameter passed in by caller, on entry it contains the
                     size (in bytes) of the buffer, on exit it contains either
                     the number of bytes transferred to the caller's buffer (if
                     a transfer occured) or else the size of buffer required to
                     hold the list.

   ulFlags           Not used, must be zero.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one of the
    CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;
    PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA controlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if ((!ARGUMENT_PRESENT(pulTransferLen)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(Buffer)) && (*pulLength != 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // We should never have both arguments pointing to the same memory...
        //
        ASSERT(pulTransferLen != pulLength);

        //
        // ...but if we do, fail the call.
        //
        if (pulTransferLen == pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Retrieve the blocked driver list via kernel-mode.
        //

        memset(&controlData, 0, sizeof(PLUGPLAY_CONTROL_BLOCKED_DRIVER_DATA));
        controlData.Buffer = Buffer;
        controlData.BufferLength = *pulLength;
        controlData.Flags = ulFlags;

        ntStatus = NtPlugPlayControl(PlugPlayControlGetBlockedDriverList,
                                     &controlData,
                                     sizeof(controlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulTransferLen = *pulLength;           // Transfer everything back
            *pulLength = controlData.BufferLength;  // Length of valid data

        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulTransferLen = 0;                    // Nothing to transfer
            *pulLength = controlData.BufferLength;
            Status = CR_BUFFER_SMALL;

        } else {
            *pulLength = *pulTransferLen = 0;       // Nothing to transfer
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetBlockedDriverInfo



void __RPC_FAR * __RPC_USER
MIDL_user_allocate(
    size_t cBytes
    )
{
    return HeapAlloc(ghPnPHeap, 0, cBytes);

} // MIDL_user_allocate


void __RPC_USER
MIDL_user_free(
    void __RPC_FAR * pBuffer
    )
{
    HeapFree(ghPnPHeap, 0, pBuffer);

} // MIDL_user_free
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rdevnode.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rdevnode.c

Abstract:

    This module contains the server-side device node APIs.

                  PNP_CreateDevInst
                  PNP_DeviceInstanceAction
                  PNP_GetDeviceStatus
                  PNP_SetDeviceProblem
                  PNP_UninstallDevInst
                  PNP_AddID
                  PNP_RegisterDriver
                  PNP_QueryRemove
                  PNP_DisableDevInst
                  PNP_RequestDeviceEject

Author:

    Paula Tomlinson (paulat) 7-11-1995

Environment:

    User-mode only.

Revision History:

    11-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"


//
// private prototypes
//
CONFIGRET
SetupDevInst(
   IN PCWSTR   pszDeviceID,
   IN ULONG    ulFlags
   );

CONFIGRET
CreateDefaultDeviceInstance(
   IN PCWSTR   pszDeviceID,
   IN PCWSTR   pszParentID,
   IN BOOL     bPhantom,
   IN BOOL     bMigrated
   );

ULONG
GetCurrentConfigFlag(
   IN PCWSTR   pDeviceID
   );

BOOL
MarkDevicePhantom(
   IN HKEY     hKey,
   IN ULONG    ulValue
   );

CONFIGRET
GenerateDeviceInstance(
   OUT LPWSTR   pszFullDeviceID,
   IN  LPWSTR   pszDeviceID,
   IN  ULONG    ulDevId
   );

BOOL
IsDeviceRegistered(
    IN LPCWSTR  pszDeviceID,
    IN LPCWSTR  pszService
    );

BOOL
IsPrivatePhantomFromFirmware(
    IN HKEY hKey
    );

typedef struct {

    LIST_ENTRY  ListEntry;
    WCHAR       DevInst[ANYSIZE_ARRAY];

} ENUM_ELEMENT, *PENUM_ELEMENT;

CONFIGRET
EnumerateSubTreeTopDownBreadthFirstWorker(
    IN      handle_t    BindingHandle,
    IN      LPCWSTR     DevInst,
    IN OUT  PLIST_ENTRY ListHead
    );

//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY



CONFIGRET
PNP_CreateDevInst(
   IN handle_t    hBinding,
   IN OUT LPWSTR  pszDeviceID,
   IN LPWSTR      pszParentDeviceID,
   IN ULONG       ulLength,
   IN ULONG       ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Create_DevNode routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to create.

   pszParentDeviceID Parent of the new device.

   ulLength          Max length of pDeviceID on input and output.

   ulFlags           This value depends on the value of the ulMajorAction and
                     further defines the specific action to perform

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szFullDeviceID[MAX_DEVICE_ID_LEN];
    ULONG       ulStatusFlag=0, ulConfigFlag=0, ulCSConfigFlag=0, ulProblem=0;
    ULONG       ulPhantom = 0, ulMigrated = 0;
    ULONG       ulSize=0;
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
    WCHAR       szService[MAX_PATH];
    NTSTATUS    ntStatus;


    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //

        if (INVALID_FLAGS(ulFlags, CM_CREATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Additionally, Windows NT does not support the
        // CM_CREATE_DEVNODE_NO_WAIT_INSTALL flag.
        //

        if (ulFlags & CM_CREATE_DEVNODE_NO_WAIT_INSTALL) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // RULE: validate that parent is the root devnode; only allow creating
        // root enumerating devices using this routine.
        //

        if (!IsRootDeviceID(pszParentDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // create a unique instance value if requested
        //

        if (ulFlags & CM_CREATE_DEVNODE_GENERATE_ID) {

            Status = GenerateDeviceInstance(szFullDeviceID,
                                            (LPTSTR)pszDeviceID,
                                            MAX_DEVICE_ID_LEN);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            if (((ULONG)lstrlen(szFullDeviceID) + 1) > ulLength) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            lstrcpy(pszDeviceID, szFullDeviceID);
        }


        //
        // try opening the registry key for this device instance
        //
        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                 KEY_READ | KEY_WRITE, &hKey);

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_REGISTRY,
                   "UMPNPMGR: PNP_CreateDevInst opened key %ws\n",
                   pszDeviceID));

        //
        // if the key already exists, check if it is marked as "Migrated".
        //
        if (RegStatus == ERROR_SUCCESS) {
            ulSize = sizeof(ULONG);
            if (RegQueryValueEx(hKey,
                                pszRegValueMigrated,
                                NULL,
                                NULL,
                                (LPBYTE)&ulMigrated,
                                &ulSize) != ERROR_SUCCESS) {
                ulMigrated = 0;
            } else {
                //
                // if the value exists at all, be paranoid and check that it's 1
                //
                ASSERT(ulMigrated == 1);
            }
        }

        //
        // first handle phantom devnode case
        //
        if (ulFlags & CM_CREATE_DEVNODE_PHANTOM) {
            //
            // for a phantom devnode, it must not already exist in the registry
            // unless it's an unregistered firmware mapper device instance.
            //
            if (RegStatus == ERROR_SUCCESS) {
                ASSERT(hKey != NULL);
                //
                // Check to see if the device is migrated, or is a firmware
                // mapper-created phantom--if so, it's OK to allow the create to
                // succeed.
                //
                if (ulMigrated != 0) {
                    //
                    // this key was specifically request (not generated) so it
                    // will be used -- remove the migrated value.
                    //
                    RegDeleteValue(hKey, pszRegValueMigrated);
                    Status = CR_SUCCESS;
                } else if (IsPrivatePhantomFromFirmware(hKey)) {
                    Status = CR_SUCCESS;
                } else {
                    Status = CR_ALREADY_SUCH_DEVINST;
                }
                goto Clean0;
            }

            //
            // it doesn't exist in the registry so create a phantom devnode
            //
            CreateDefaultDeviceInstance(pszDeviceID,
                                        pszParentDeviceID,
                                        TRUE,
                                        FALSE);

            goto Clean0;
        }

        //
        // for a normal devnode, fail if the device is already present in the
        // registry and alive, and not migrated
        //
        if ((RegStatus == ERROR_SUCCESS)     &&
            (IsDeviceIdPresent(pszDeviceID)) &&
            (ulMigrated == 0)) {
            //
            // Set status to NEEDS ENUM and fail the create call.
            //
            Status = CR_ALREADY_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // if couldn't open the device instance, or the key was migrated, then
        // most likely the key doesn't exist yet, or should be treated as if it
        // doesn't exist yet, so create a device instance key with default
        // values.
        //
        if ((RegStatus != ERROR_SUCCESS) || (ulMigrated != 0)) {

            //
            // this key will be used -- remove the migrated value
            // and close the key.
            //
            if (ulMigrated != 0) {
                ASSERT(RegStatus == ERROR_SUCCESS);
                ASSERT(hKey != NULL);
                RegDeleteValue(hKey, pszRegValueMigrated);
                RegCloseKey(hKey);
                hKey = NULL;
            }

            //
            // create the default device instance, finding and unused instance
            // if necessary.  if the key was migrated, a new key will not be
            // created, but the default instance data will be added to the
            // existing key.
            //
            CreateDefaultDeviceInstance(pszDeviceID,
                                        pszParentDeviceID,
                                        FALSE,
                                        (ulMigrated != 0));

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_REGISTRY,
                       "UMPNPMGR: PNP_CreateDevInst opened key %ws\n",
                       pszDeviceID));

            RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                     KEY_READ | KEY_WRITE, &hKey);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

        //
        // retrieve flags
        //

        ulConfigFlag = GetDeviceConfigFlags(pszDeviceID, hKey);
        ulCSConfigFlag = GetCurrentConfigFlag(pszDeviceID);

        //
        // check if the device is blocked
        //

        if ((ulCSConfigFlag & CSCONFIGFLAG_DO_NOT_CREATE) ||
            (ulConfigFlag & CONFIGFLAG_REMOVED) ||
            (ulConfigFlag & CONFIGFLAG_NET_BOOT)) {

            Status = CR_CREATE_BLOCKED;
            goto Clean0;
        }

        //
        // Call kernel-mode to create the device node
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.Flags = 0;

        ntStatus = NtPlugPlayControl(PlugPlayControlInitializeDevice,
                                     &ControlData,
                                     sizeof(ControlData));
        if (!NT_SUCCESS(ntStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Retrieve devnode status
        //

        GetDeviceStatus(pszDeviceID, &ulStatusFlag, &ulProblem);

        //
        // Are we converting a phantom into a real devnode?
        //

        ulSize = sizeof(ULONG);
        if (RegQueryValueEx(hKey, pszRegValuePhantom, NULL, NULL,
                            (LPBYTE)&ulPhantom, &ulSize) != ERROR_SUCCESS) {
            ulPhantom = 0;
        }

        if (ulPhantom) {

            //
            // If we're turning a phantom into a real devnode, suppress the found new
            // hardware popup for this device, then clear the phantom flag.
            //

            RegDeleteValue(hKey, pszRegValuePhantom);

        } else {

            //
            // if device not installed, set a problem
            //

            if (ulConfigFlag & CONFIGFLAG_REINSTALL ||
                ulConfigFlag & CONFIGFLAG_FAILEDINSTALL) {

                SetDeviceStatus(pszDeviceID, DN_HAS_PROBLEM, CM_PROB_NOT_CONFIGURED);
            }
        }

        if (ulFlags & CM_CREATE_DEVNODE_DO_NOT_INSTALL) {

            //
            // If the device has a service, register it
            //

            ulSize = MAX_PATH * sizeof(WCHAR);
            if (RegQueryValueEx(hKey, pszRegValueService, NULL, NULL,
                    (LPBYTE)szService, &ulSize) == ERROR_SUCCESS) {

                if (szService[0]) {

                    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
                    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
                    ControlData.Flags = 0;

                    NtPlugPlayControl(PlugPlayControlRegisterNewDevice,
                                      &ControlData,
                                      sizeof(ControlData));
                }
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_CreateDevInst



CONFIGRET
PNP_DeviceInstanceAction(
   IN handle_t   hBinding,
   IN ULONG      ulAction,
   IN ULONG      ulFlags,
   IN PCWSTR     pszDeviceInstance1,
   IN PCWSTR     pszDeviceInstance2
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager routines that
  perform some operation on DevNodes (such as create, setup, disable,
  and enable, etc). It handles various routines in this one routine by
  accepting a major and minor action value.

Arguments:

   hBinding          RPC binding handle.

   ulMajorAction     Specifies the requested action to perform (one of the
                     PNP_DEVINST_* values)

   ulFlags           This value depends on the value of the ulMajorAction and
                     further defines the specific action to perform

   pszDeviceInstance1   This is a device instance string to be used in
                     performing the specified action, it's value depends on
                     the ulMajorAction value.

   pszDeviceInstance2   This is a device instance string to be used in
                     performing the specified action, it's value depends on
                     the ulMajorAction value.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_ALREADY_SUCH_DEVNODE,
         CR_INVALID_DEVICE_ID,
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG,
         CR_FAILURE,
         CR_NOT_DISABLEABLE,
         CR_INVALID_POINTER, or
         CR_OUT_OF_MEMORY.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            return CR_ACCESS_DENIED;
        }

        PNP_ENTER_SYNCHRONOUS_CALL();

        //
        // pass the request on to a private routine that handles each major
        // device instance action request
        //
        switch (ulAction) {

        case PNP_DEVINST_SETUP:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Setup_DevInst called\n"));

            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = SetupDevInst(pszDeviceInstance1, ulFlags);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_ENABLE:
            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = EnableDevInst(pszDeviceInstance1);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_REENUMERATE:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Reenumerate_DevInst called\n"));

            if (IsLegalDeviceId(pszDeviceInstance1)) {
                Status = ReenumerateDevInst(pszDeviceInstance1, TRUE, ulFlags);
            } else {
                Status = CR_INVALID_DEVNODE;
            }
            break;

        case PNP_DEVINST_DISABLE:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Disable_DevNode called\n"));

            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_QUERYREMOVE:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Query_Remove_SubTree called\n"));

            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_REMOVESUBTREE:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Remove_SubTree called\n"));

            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_REQUEST_EJECT:
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "CM_Request_Device_Eject called\n"));

            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        case PNP_DEVINST_MOVE:
            Status = CR_CALL_NOT_IMPLEMENTED;
            break;

        default:
            Status = CR_INVALID_FLAG;
            break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    PNP_LEAVE_SYNCHRONOUS_CALL();

    return Status;

} // PNP_DeviceInstanceAction



CONFIGRET
PNP_GetDeviceStatus(
   IN  handle_t   hBinding,
   IN  LPCWSTR    pDeviceID,
   OUT PULONG     pulStatus,
   OUT PULONG     pulProblem,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Get_DevNode_Status routines.  It retrieves device instance specific
  status information.

Arguments:

   hBinding          RPC binding handle, not used.

   pDeviceID         This is a device instance string to retrieve status
                     information for.

   pulStatus         Pointer to ULONG variable to return Status Flags in

   pulProblem        Pointer to ULONG variable to return Problem in

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG, or
         CR_INVALID_POINTER.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       tmpString[16], tmpDevice[MAX_DEVICE_ID_LEN];
    ULONG       PropertyData, DataSize, DataTransferLen, DataType;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters.
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulStatus) ||
            !ARGUMENT_PRESENT(pulProblem)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *pulStatus = 0;
        *pulProblem = 0;

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Retrieve the Flags information from the DeviceNode (which is then
        // mapped into status and problem values).
        //

        Status = GetDeviceStatus(pDeviceID, pulStatus, pulProblem);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Map special flags that aren't stored in the DeviceNode Flags field
        //

        //
        // DN_ROOT_ENUMERATED?
        //

        lstrcpy(tmpString, pszRegKeyRootEnum);
        lstrcat(tmpString, TEXT("\\"));
        lstrcpyn(tmpDevice, pDeviceID, lstrlen(tmpString)+1);
        if (lstrcmpi(tmpString, tmpDevice) == 0) {
            //
            // Do not mark PnP BIOS enumerated as ROOT enumerated
            //
            //  Bios enumerated devices look like:
            //      Root\*aaannnn\PnPBIOS_n
            if (lstrlen(pDeviceID) < (4 + 1 + 8 + 1 + 8) ||
                _wcsnicmp(&pDeviceID[14], L"PnPBIOS_", 8) != 0 ) {

                *pulStatus |= DN_ROOT_ENUMERATED;
            }
        }

        //
        // DN_REMOVABLE?
        //
        DataSize = DataTransferLen = sizeof(ULONG);
        if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                               pDeviceID,
                                               CM_DRP_CAPABILITIES,
                                               &DataType,
                                               (LPBYTE)&PropertyData,
                                               &DataTransferLen,
                                               &DataSize,
                                               0)) {

            if (PropertyData & CM_DEVCAP_REMOVABLE) {
                *pulStatus |= DN_REMOVABLE;
            }
        }

        //
        // DN_MANUAL?
        //
        DataSize = DataTransferLen = sizeof(ULONG);
        if (CR_SUCCESS != PNP_GetDeviceRegProp(NULL,
                                               pDeviceID,
                                               CM_DRP_CONFIGFLAGS,
                                               &DataType,
                                               (LPBYTE)&PropertyData,
                                               &DataTransferLen,
                                               &DataSize,
                                               0)) {
            PropertyData = 0;
        }

        if (PropertyData & CONFIGFLAG_MANUAL_INSTALL) {
            *pulStatus |= DN_MANUAL;
        }

        //
        // If there isn't already a problem, check to see if the config flags indicate this
        // was a failed installation.
        //
        if (!(*pulStatus & DN_HAS_PROBLEM) && (PropertyData & CONFIGFLAG_FAILEDINSTALL)) {
            *pulStatus |= DN_HAS_PROBLEM;
            *pulProblem = CM_PROB_FAILED_INSTALL;
        }


    Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }


   return Status;

} // PNP_GetDeviceStatus



CONFIGRET
PNP_SetDeviceProblem(
   IN handle_t  hBinding,
   IN LPCWSTR   pDeviceID,
   IN ULONG     ulProblem,
   IN ULONG     ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Set_DevNode_Problem routines.  It set device instance specific
  problem information.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         This is a device instance string to retrieve status
                     information for.

   ulProblem         A ULONG variable that specifies the Problem

   ulFlags           May be one of the following two values:

                         CM_SET_DEVNODE_PROBLEM_NORMAL -- only set problem
                             if currently no problem

                         CM_SET_DEVNODE_PROBLEM_OVERRIDE -- override current
                             problem with new problem

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
         CR_INVALID_DEVNODE,
         CR_INVALID_FLAG.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulCurrentProblem = 0, ulCurrentStatus = 0;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_SET_DEVNODE_PROBLEM_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // If there's already a problem, do nothing unless CM_SET_DEVNODE_PROBLEM_OVERRIDE
        // is specified.
        //

        Status = GetDeviceStatus(pDeviceID, &ulCurrentStatus, &ulCurrentProblem);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        if (ulProblem) {
            //
            // The caller is wanting to set a problem.  Make sure that if the device
            // already has a problem, it's the same one as we're trying to set (unless
            // we're overriding the current problem).
            //
            if ((ulCurrentStatus & DN_HAS_PROBLEM) &&
                (ulCurrentProblem != ulProblem) &&
                ((ulFlags & CM_SET_DEVNODE_PROBLEM_BITS) != CM_SET_DEVNODE_PROBLEM_OVERRIDE)) {

                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        if (!ulProblem) {
            Status = ClearDeviceStatus(pDeviceID, DN_HAS_PROBLEM, ulCurrentProblem);
        } else {
            Status = SetDeviceStatus(pDeviceID, DN_HAS_PROBLEM, ulProblem);
        }

    Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_SetDeviceProblem



CONFIGRET
PNP_UninstallDevInst(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pDeviceID,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Deinstall_DevNode routine. It removes the device instance
  registry key and any subkeys (only for phantoms).

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         The device instance to deinstall.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH];
    ULONG       ulCount=0, ulProfile = 0;
    ULONG       ulStatus, ulProblem;

    try {

        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //------------------------------------------------------------------
        // Uninstall deletes instance key (and all subkeys) for all
        // the hardware keys (this means the main Enum branch, the
        // config specific keys under HKLM, and the Enum branch under
        // HKCU). In the case of the user hardware keys (under HKCU),
        // I delete those whether it's a phantom or not, but since
        // I can't access the user key from the service side, I have
        // to do that part on the client side. For the main hw Enum key
        // and the config specific hw keys, I only delete them outright
        // if they are phantoms. If not a phantom, then I just make the
        // device instance volatile (by saving the original key, deleting
        // old key, creating new volatile key and restoring the old
        // contents) so at least it will go away during the next boot
        //------------------------------------------------------------------

        if ((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) &&
            (ulStatus & DN_DRIVER_LOADED)) {

            //-------------------------------------------------------------
            // device is not a phantom
            //-------------------------------------------------------------

            if ((ulStatus & DN_ROOT_ENUMERATED)!=0 &&
                (ulStatus & DN_DISABLEABLE)==0) {

                //
                // if a device is root enumerated, but not disableable, it is not uninstallable
                // return status is CR_NOT_DISABLEABLE, as that is why it cannot be uninstalled
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_UninstallDevInst failed uninstall of %ws (this root device is not disableable)\n",
                           pDeviceID));

                Status = CR_NOT_DISABLEABLE;

            } else {

                //
                // do the volatile-copy-thing
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_UninstallDevInst doing volatile key thing on %ws\n",
                           pDeviceID));

                Status = UninstallRealDevice(pDeviceID);
            }

        } else {

            //-------------------------------------------------------------
            // device is a phantom
            //-------------------------------------------------------------

            //
            // deregister the device, and delete the registry keys.
            //
            Status = UninstallPhantomDevice(pDeviceID);
            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            //
            // if it is a root enumerated device, we need to reenumerate the
            // root so that the PDO will go away, otherwise a new device could
            // be created and the root enumerator would get very confused.
            //
            if (IsDeviceRootEnumerated(pDeviceID)) {
                ReenumerateDevInst(pszRegRootEnumerator, FALSE, 0);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

   return Status;

} // PNP_UninstallDevInst



CONFIGRET
PNP_AddID(
   IN handle_t   hBinding,
   IN LPCWSTR    pszDeviceID,
   IN LPCWSTR    pszID,
   IN ULONG      ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Add_ID routine. It adds a hardware or compatible ID to
  the registry for this device instance.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       The device instance to add an ID for.

   pszID             The hardware or compatible ID to add.

   ulFlags           Specifies the type of ID to add.
                     May be one of the following two values:

                       CM_ADD_ID_HARDWARE   -- add hardware ID

                       CM_ADD_ID_COMPATIBLE -- add compatible ID

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    WCHAR       szCurrentID[REGSTR_VAL_MAX_HCID_LEN];
    ULONG       ulLength = 0, transferLength, type;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_ADD_ID_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pszID) ||
            ((lstrlen(pszID) + 2) > REGSTR_VAL_MAX_HCID_LEN)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        szCurrentID[0] = L'\0';
        transferLength = ulLength = REGSTR_VAL_MAX_HCID_LEN*sizeof(WCHAR);
        Status = PNP_GetDeviceRegProp(hBinding,
                                      pszDeviceID,
                                      (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                      &type,
                                      (LPBYTE)szCurrentID,
                                      &transferLength,
                                      &ulLength,
                                      0);
        if (Status == CR_SUCCESS) {

            if (!MultiSzSearchStringW(szCurrentID, pszID)) {
                //
                // This ID is not already in the list, so append the new ID
                // to the end of the existing IDs and write it back to the
                // registry
                //
                ulLength = REGSTR_VAL_MAX_HCID_LEN*sizeof(WCHAR);
                if (MultiSzAppendW(szCurrentID,
                                   &ulLength,
                                   pszID)) {

                    Status = PNP_SetDeviceRegProp(hBinding,
                                                  pszDeviceID,
                                                  (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                                  REG_MULTI_SZ,
                                                  (LPBYTE)szCurrentID,
                                                  ulLength,
                                                  0);
                } else {
                    //
                    // Couldn't append the new ID to the multi-sz.
                    //
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }
        } else {
            //
            // write out the id with a double null terminator
            //
            lstrcpy(szCurrentID, pszID);
            szCurrentID[lstrlen(pszID)] = L'\0';
            szCurrentID[lstrlen(pszID) + 1] = L'\0';
            Status = PNP_SetDeviceRegProp(hBinding,
                                          pszDeviceID,
                                          (ulFlags == CM_ADD_ID_HARDWARE)? CM_DRP_HARDWAREID : CM_DRP_COMPATIBLEIDS,
                                          REG_MULTI_SZ,
                                          (LPBYTE)szCurrentID,
                                          (lstrlen(szCurrentID) + 2 ) * sizeof(WCHAR),
                                          0);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

   return Status;

} // PNP_AddID



CONFIGRET
PNP_RegisterDriver(
    IN handle_t hBinding,
    IN LPCWSTR  pszDeviceID,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the ConfigManager
  CM_Register_Device_Driver routine. It setups flags for the
  driver/device and enumerates it.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       The device instance to register the driver for.

   ulFlags           Flags associated with the driver.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   Otherwise it returns one of the CR_ERROR codes.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulStatusFlag = 0;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REGISTER_DEVICE_DRIVER_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        SetDeviceStatus(pszDeviceID, ulStatusFlag, 0);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;

} // PNP_RegisterDriver



CONFIGRET
PNP_QueryRemove(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This is the RPC server entry point for the CM_Query_And_Remove_SubTree
   routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to query and remove.

   ulFlags           Specifies flags describing how the query removal
                     should be processed.

                     Currently, the following flags are defined:
                       CM_REMOVE_UI_OK
                       CM_REMOVE_UI_NOT_OK,
                       CM_REMOVE_NO_RESTART,

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

Note:

   Note that this routine actually checks for presence of the CM_REMOVE_* flags,
   not the CR_QUERY_REMOVE_* flags.  Note that currently the following
   CM_QUERY_REMOVE_* and CM_REMOVE_* flags are defined:

     CM_QUERY_REMOVE_UI_OK,     ==   CM_REMOVE_UI_OK
     CM_QUERY_REMOVE_UI_NOT_OK  ==   CM_REMOVE_UI_NOT_OK
                                     CM_REMOVE_NO_RESTART

   Which is why we can simply check for the CM_REMOVE_* flags.

   Also, note that currently the CM_REMOVE_UI_OK and CM_REMOVE_UI_NOT_OK flags
   are ignored here on the server side.  User interface dialogs are displayed
   based on whether veto type and veto name buffers are supplied, so the client
   has used these flags to determine whether a buffer was to be supplied or not.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_REMOVE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID) ||
            IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        Status = QueryAndRemoveSubTree(pszDeviceID,
                                       pVetoType,
                                       pszVetoName,
                                       ulNameLength,
                                       (ulFlags & CM_REMOVE_NO_RESTART) ?
                                       PNP_QUERY_AND_REMOVE_NO_RESTART :
                                       0);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_QueryRemove



CONFIGRET
PNP_DisableDevInst(
   IN  handle_t         hBinding,
   IN  LPCWSTR          pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This is the RPC server entry point for the CM_Disable_DevNode_Ex routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Device instance to disable.

   ulFlags           May specify CM_DISABLE_BITS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS. Otherwise it
   returns a CR_ error code.

Note:

   Note that although the client may supply flags to this routine, they are not
   used.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DISABLE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID) ||
            IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        Status = DisableDevInst(pszDeviceID,
                                pVetoType,
                                pszVetoName,
                                ulNameLength);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_DisableDevInst



CONFIGRET
PNP_RequestDeviceEject(
    IN  handle_t        hBinding,
    IN  LPCWSTR         pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength,
    IN  ULONG           ulFlags
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulPropertyData, ulDataSize, ulTransferLen, ulDataType;
    BOOL        bDockDevice = FALSE;

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Do the appropriate security test
        //
        ulDataSize = ulTransferLen = sizeof(ULONG);
        if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                               pszDeviceID,
                                               CM_DRP_CAPABILITIES,
                                               &ulDataType,
                                               (LPBYTE)&ulPropertyData,
                                               &ulTransferLen,
                                               &ulDataSize,
                                               0)) {

            if (ulPropertyData & CM_DEVCAP_DOCKDEVICE) {
                bDockDevice = TRUE;
            }
        }

        if (bDockDevice) {
            //
            // Undocking (ie ejecting a dock) uses a special privilege.
            //

            if ((!IsClientLocal(hBinding)) &&
                (!IsClientAdministrator(hBinding))) {
                //
                // Non-local RPC calls from non-Admins are denied access,
                // regardless of privilege.
                //
                Status = CR_ACCESS_DENIED;

            } else if (!VerifyClientAccess(hBinding, &gLuidUndockPrivilege)) {
                //
                // Callers not posessing the undock privilege are denied access.
                //
                Status = CR_ACCESS_DENIED;
            }

        } else {
            //
            // If the client is not interactive, or is not using the active
            // console session, we require the special load-driver privilege.
            //
            if (!IsClientUsingLocalConsole(hBinding) ||
                !IsClientInteractive(hBinding)) {
                if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
                    Status = CR_ACCESS_DENIED;
                }
            }
        }

        if (Status != CR_ACCESS_DENIED) {
            //
            // Call kernel-mode to eject the device node
            //
            Status = QueryAndRemoveSubTree(pszDeviceID,
                                           pVetoType,
                                           pszVetoName,
                                           ulNameLength,
                                           PNP_QUERY_AND_REMOVE_EJECT_DEVICE);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RequestDeviceEject



//-------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------

CONFIGRET
SetupDevInst(
   IN PCWSTR   pszDeviceID,
   IN ULONG    ulFlags
   )

/*++

Routine Description:


Arguments:


Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   ULONG       RegStatus = ERROR_SUCCESS;
   HKEY        hKey = NULL;
   ULONG       ulStatusFlag=0, ulProblem=0, ulDisableCount=0, ulSize=0;
   PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
   NTSTATUS    ntStatus = STATUS_SUCCESS;

   try {
      //
      // Validate parameters
      //
      if (IsRootDeviceID(pszDeviceID)) {
         goto Clean0;
      }

      if (INVALID_FLAGS(ulFlags, CM_SETUP_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      switch(ulFlags) {

         case CM_SETUP_DOWNLOAD:
         case CM_SETUP_WRITE_LOG_CONFS:
            //
            // On NT, these values are a no-op.
            //
            break;

         case CM_SETUP_DEVNODE_READY:
         case CM_SETUP_DEVNODE_RESET:

            if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ | KEY_WRITE,
                             &hKey) != ERROR_SUCCESS) {
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }

            //
            // Check the disable count, if greater than zero, do nothing
            //
            ulSize = sizeof(ulDisableCount);
            if (RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                                (LPBYTE)&ulDisableCount, &ulSize) == ERROR_SUCCESS) {
                if (ulDisableCount > 0) {

                    break;
                }
            }

            GetDeviceStatus(pszDeviceID, &ulStatusFlag, &ulProblem);

            //
            // If there's no problem or if install was done already
            // (immediately) then there's nothing more to do
            //
            if (ulStatusFlag & DN_STARTED) {
               break;
            }

            if (ulStatusFlag & DN_HAS_PROBLEM) {
                //
                // reset the problem and set status to need to enum
                //
                Status = ClearDeviceStatus(pszDeviceID, DN_HAS_PROBLEM, ulProblem);
            }

            if (Status == CR_SUCCESS) {

                //
                // Have kernel-mode pnp manager start the driver/device now.
                // If kernel-mode doesn't have a pdo for this device then it's
                // probably either a Win32 service or a phantom devnode.
                //

                memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
                RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
                ControlData.Flags = 0;

                if (ulFlags == CM_SETUP_DEVNODE_READY) {

                    ntStatus = NtPlugPlayControl(PlugPlayControlStartDevice,
                                                 &ControlData,
                                                 sizeof(ControlData));

                } else {

                    ntStatus = NtPlugPlayControl(PlugPlayControlResetDevice,
                                                 &ControlData,
                                                 sizeof(ControlData));
                }
            }

            break;

         case CM_SETUP_PROP_CHANGE:
             //
             // Not sure what Win9x does with this, but it ain't implemented on
             // NT.  Let fall through to the default (invalid flag) case...
             //

         default:
             Status = CR_INVALID_FLAG;
      }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }

   return Status;

} // SetupDevInst



CONFIGRET
EnableDevInst(
    IN PCWSTR   pszDeviceID
    )

/*++

Routine Description:

    This routine performs the server-side work for CM_Enable_DevNode.  It
    disables the specified device ID

Arguments:

    pszDeviceID    String that contains the device id to enable

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       RegStr[MAX_PATH];
    ULONG       ulDisableCount, ulProblem = 0, ulStatus = 0, ulSize;


    try {

        //
        // Verify it isn't the root, can't disable/enable the root. We can
        // probably get rid of this test once we're sure that the root
        // devnode is always marded as not disablable.
        //

        if (IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Open a key to the specified device instances volatile control key.
        // This is also a partial check whether the device is really present
        // (if so then it has a Control key).
        //

        wsprintf(RegStr, TEXT("%s\\%s"),
                 pszDeviceID,
                 pszRegKeyDeviceControl);

        if (RegOpenKeyEx(ghEnumKey, RegStr, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            //
            // NTRAID #174944-2000/08/30-jamesca:
            // Remove dependence on the presence of volatile Control subkey
            // for present devices.
            //

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Get the current disable count from the registry
        //

        ulSize = sizeof(ulDisableCount);
        if (RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                            (LPBYTE)&ulDisableCount, &ulSize) != ERROR_SUCCESS) {

            //
            // disable count not set yet, assume zero
            //

            ulDisableCount = 0;
        }

        //
        // if the DisableCount is zero, then we're already enabled
        //

        if (ulDisableCount > 0) {
            //
            // Decrement disable count.  If the disable count is greater than one,
            // then just return (disable count must drop to zero in order to
            // actually reenable)
            //

            ulDisableCount--;

            RegSetValueEx(hKey, pszRegValueDisableCount, 0, REG_DWORD,
                         (LPBYTE)&ulDisableCount, sizeof(ulDisableCount));

            if (ulDisableCount > 0) {
                goto Clean0;   // success
            }
        }

        //
        // Retrieve the problem and status values
        //

        if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

            //
            // If the problem is only that the device instance is disabled,
            // then reenable it now
            //

            if ((ulStatus & DN_HAS_PROBLEM) && (ulProblem == CM_PROB_DISABLED)) {

                Status = SetupDevInst(pszDeviceID, CM_SETUP_DEVNODE_READY);
            }
        } else {

            //
            // The device isn't currently active or it is a service.
            //

            Status = CR_SUCCESS;
        }


        //
        // For now I'm not doing anything if there was a problem other than
        // not being enabled.
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // EnableDevInst



CONFIGRET
DisableDevInst(
    IN  PCWSTR          pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR          pszVetoName,
    IN  ULONG           ulNameLength
    )

/*++

Routine Description:

    This routine performs the server-side work for CM_Disable_DevNode.  It
    disables the specified device ID.

Arguments:

    pszDeviceID    String that contains the device id to disable

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       RegStr[MAX_PATH];
    ULONG       ulDisableCount=0, ulProblem=0, ulStatus=0, ulSize=0;
    PNP_VETO_TYPE VetoType;


    try {

        //
        // Verify it isn't the root, can't disable/enable the root. We can
        // probably get rid of this test once we're sure that the root
        // devnode is always marded as not disablable.
        //

        if (IsRootDeviceID(pszDeviceID)) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Open a key to the specified device instances volatile control key.
        // This is also a partial check whether the device is really present
        // (if so then it has a Control key).
        //

        wsprintf(RegStr, TEXT("%s\\%s"),
                 pszDeviceID,
                 pszRegKeyDeviceControl);

        if (RegOpenKeyEx(ghEnumKey, RegStr, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            //
            // NTRAID #174944-2000/08/30-jamesca:
            // Remove dependence on the presence of volatile Control subkey
            // for present devices.
            //

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Get the current disable count from the registry.
        //

        ulSize = sizeof(ulDisableCount);
        if (RegQueryValueEx(hKey, pszRegValueDisableCount, NULL, NULL,
                            (LPBYTE)&ulDisableCount, &ulSize) != ERROR_SUCCESS) {

            //
            // disable count not set yet, assume zero
            //

            ulDisableCount = 0;
        }

        //
        // If the disable count is currently zero, then this is the first
        // disable, so there's work to do.  Otherwise, we just increment the
        // disable count and resave it in the registry.
        //

        if (ulDisableCount == 0) {

            //
            // determine if the device instance is stopable
            //

            if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

                if (!(ulStatus & DN_DISABLEABLE)) {
                    Status = CR_NOT_DISABLEABLE;
                    goto Clean0;
                }

                //
                // Attempt to query remove and remove this device instance.
                //

                VetoType = PNP_VetoTypeUnknown;
                Status = QueryAndRemoveSubTree( pszDeviceID,
                                                &VetoType,
                                                pszVetoName,
                                                ulNameLength,
                                                PNP_QUERY_AND_REMOVE_DISABLE);
                if(pVetoType != NULL) {
                    *pVetoType = VetoType;
                }
                if (Status != CR_SUCCESS) {
                    if (VetoType == PNP_VetoNonDisableable) {
                        //
                        // specially handle this Veto case
                        // this case is unlikely to occur unless something becomes
                        // non-disableable between the status-check and when we
                        // try to remove it
                        //
                        Status = CR_NOT_DISABLEABLE;
                    }
                    goto Clean0;
                }
            } else {

                //
                // The device isn't active or it is a service.
                //

                Status = CR_SUCCESS;
            }
        }

        //
        // update and save the disable count
        //

        ulDisableCount++;
        RegSetValueEx(hKey, pszRegValueDisableCount, 0, REG_DWORD,
                      (LPBYTE)&ulDisableCount, sizeof(ulDisableCount));

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // DisableDevInst



CONFIGRET
ReenumerateDevInst(
    IN PCWSTR   pszDeviceID,
    IN BOOL     EnumSubTree,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

   This routine performs the server-side work for CM_Reenumerate_DevNode.  It
   reenumerates the specified device instance.

Arguments:

   pszDeviceID    String that contains the device id to reenumerate.

   EnumSubTree    Specifies whether to reenumerate the entire device subtree.

   ulFlags        Any enumeration control flags.

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA ControlData;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    ULONG       ulEnumFlags = 0;
    QI_CONTEXT  qiContext;

    //
    // NOTE: For Windows 95, the devnode is marked as needing to be
    // reenumerating (by or'ing StatusFlags with DN_NEED_TO_ENUM), then
    // sometime later, after the initial flurry of reenumeration requests,
    // the whole tree is processed
    //

    if (INVALID_FLAGS(ulFlags, CM_REENUMERATE_BITS)) {
        return CR_INVALID_FLAG;
    }

    try {

        //
        // Attempt to handle this via kernel-mode, if kernel-mode
        // doesn't have a pdo for this device then it's probably either a
        // Win32 service or a phantom devnode.
        //

        if (!EnumSubTree) {
            ulEnumFlags |= PNP_ENUMERATE_DEVICE_ONLY;
        }

        if (ulFlags & CM_REENUMERATE_ASYNCHRONOUS) {
            ulEnumFlags |= PNP_ENUMERATE_ASYNCHRONOUS;
        }

        if (ulFlags & CM_REENUMERATE_RETRY_INSTALLATION) {

            qiContext.HeadNodeSeen = FALSE;
            qiContext.SingleLevelEnumOnly = !EnumSubTree;
            qiContext.Status = CR_SUCCESS;

            Status = EnumerateSubTreeTopDownBreadthFirst(
                NULL,
                pszDeviceID,
                QueueInstallationCallback,
                (PVOID) &qiContext
                );

            if (Status != CR_SUCCESS) {

                return Status;
            }

            if (qiContext.Status != CR_SUCCESS) {

                return qiContext.Status;
            }
        }

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.Flags = ulEnumFlags;

        ntStatus = NtPlugPlayControl(PlugPlayControlEnumerateDevice,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            if (ntStatus == STATUS_NO_SUCH_DEVICE) {
                Status = CR_INVALID_DEVNODE;    // probably a win32 service
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // ReenumerateDevInst



CONFIGRET
QueryAndRemoveSubTree(
   IN  PCWSTR           pszDeviceID,
   OUT PPNP_VETO_TYPE   pVetoType,
   OUT LPWSTR           pszVetoName,
   IN  ULONG            ulNameLength,
   IN  ULONG            ulFlags
   )

/*++

Routine Description:

   This routine performs the server-side work for CM_Query_Remove_Subtree.  It
   determines whether subtree can be removed.

Arguments:

   pszDeviceID    String that contains the device id to query remove

   ulFlags        Specifies flags for PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA
                  May be one of:
                    PNP_QUERY_AND_REMOVE_NO_RESTART
                    PNP_QUERY_AND_REMOVE_DISABLE
                    PNP_QUERY_AND_REMOVE_UNINSTALL
                    PNP_QUERY_AND_REMOVE_EJECT_DEVICE

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA ControlData;
    NTSTATUS    ntStatus = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(pVetoType)) {
        *pVetoType = 0;
    }

    if (ARGUMENT_PRESENT(pszVetoName) && (ulNameLength > 0)) {
        *pszVetoName = L'\0';
    }

    //---------------------------------------------------------------------
    // Attempt to handle this via kernel-mode first, if kernel-mode
    // doesn't have a pdo for this device then it's probably either a
    // Win32 service or a phantom devnode, so we'll do the old default
    // Windows NT 4.0 behaviour for now.
    //---------------------------------------------------------------------

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_QUERY_AND_REMOVE_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Flags = ulFlags;
    ControlData.VetoType = PNP_VetoTypeUnknown;
    ControlData.VetoName = pszVetoName;
    ControlData.VetoNameLength = ulNameLength;

    ntStatus = NtPlugPlayControl(PlugPlayControlQueryAndRemoveDevice,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        if (ntStatus == STATUS_NO_SUCH_DEVICE) {
            Status = CR_INVALID_DEVNODE;    // probably a win32 service or legacy driver
        } else if (ntStatus == STATUS_PLUGPLAY_QUERY_VETOED) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_WARNINGS,
                       "Query vetoed: Type = %d, Name = %ws\n",
                       ControlData.VetoType,
                       ControlData.VetoName));

            if (pVetoType != NULL) {
                *pVetoType = ControlData.VetoType;
            }

            if (ARGUMENT_PRESENT(pszVetoName) &&
                (ulNameLength > ControlData.VetoNameLength)) {
                pszVetoName[ControlData.VetoNameLength] = L'\0';
            }
            Status = CR_REMOVE_VETOED;
        } else {
            Status = MapNtStatusToCmError(ntStatus);
        }
    }

    return Status;

} // QueryRemoveSubTree



CONFIGRET
CreateDefaultDeviceInstance(
    IN PCWSTR   pszDeviceID,
    IN PCWSTR   pszParentID,
    IN BOOL     bPhantom,
    IN BOOL     bMigrated
    )

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey1 = NULL, hKey2 = NULL;
    WCHAR       szBase[MAX_DEVICE_ID_LEN];
    WCHAR       szDevice[MAX_DEVICE_ID_LEN];
    WCHAR       szInstance[MAX_DEVICE_ID_LEN];
    WCHAR       RegStr[MAX_DEVICE_ID_LEN];
    ULONG       ulValue=0, ulDisposition=0, i=0;

    UNREFERENCED_PARAMETER(pszParentID);

    //
    // make sure we were specified a valid instance path.
    //
    if (!IsLegalDeviceId(pszDeviceID)) {
        Status = CR_INVALID_DEVNODE;
        goto Clean0;
    }

    //
    // split the supplied instance path into enumerator, device, and instance
    //
    SplitDeviceInstanceString(pszDeviceID, szBase, szDevice, szInstance);

    //
    // open a key to base enumerator (create if doesn't already exist)
    //
    RegStatus = RegCreateKeyEx(ghEnumKey, szBase, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey2, NULL);

    if (RegStatus != ERROR_SUCCESS) {
        Status = CR_REGISTRY_ERROR;
        goto Clean0;
    }

    //
    // open a key to device (create if doesn't already exist)
    //
    RegStatus = RegCreateKeyEx(hKey2, szDevice, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey1, NULL);

    if (RegStatus != ERROR_SUCCESS) {
        Status = CR_REGISTRY_ERROR;
        goto CleanupOnFailure;
    }

    RegCloseKey(hKey2);           // done with Base Key
    hKey2 = NULL;

    //
    // open a key to instance (if already exists)
    //
    RegStatus = RegOpenKeyEx(hKey1, szInstance, 0, KEY_SET_VALUE, &hKey2);

    //
    // if the key was migrated, an existing instance id should have been
    // supplied.  for non-migrated instances, the key should not exist yet.
    //
    if (bMigrated) {
        ASSERT(RegStatus == ERROR_SUCCESS);
    } else {
        ASSERT(RegStatus != ERROR_SUCCESS);
    }

    //
    // if the specified key exists, but the instance is not migrated, find an
    // unused instance value.  if a migrated instance was specified, don't
    // bother finding an unused instance - we can just use this one.
    //
    if ((RegStatus == ERROR_SUCCESS) && (!bMigrated)) {
        //
        // find a new instance id to use
        //
        RegCloseKey(hKey2);     // done with Instance key
        hKey2 = NULL;
        i = 0;

        while (i <= 9999) {
            wsprintf(szInstance, TEXT("%04u"), i);
            RegStatus = RegOpenKeyEx(hKey1, szInstance, 0, KEY_SET_VALUE, &hKey2);

            if (RegStatus != ERROR_SUCCESS) {
                break;  // instance key does not exist, use this instance
            }

            // instance key exists, try next one
            RegCloseKey(hKey2);
            hKey2 = NULL;
            i++;
        }

        if (i > 9999) {
            Status = CR_FAILURE;     // we ran out of instances (unlikely)
            goto CleanupOnFailure;
        }
    }

    //
    // open the device instance key
    //
    RegStatus = RegCreateKeyEx(hKey1, szInstance, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                               NULL, &hKey2, &ulDisposition);

    if (RegStatus != ERROR_SUCCESS) {
        Status = CR_REGISTRY_ERROR;
        goto CleanupOnFailure;
    }

    RegCloseKey(hKey1);           // done with device key
    hKey1 = NULL;

    //
    // set the default device instance values
    //

    if (bPhantom) {
        //
        // phantoms are not present by definition
        //
        MarkDevicePhantom(hKey2, TRUE);
    }

    //
    // go ahead and create the volatile Control key at this point.
    //

    RegCreateKeyEx(hKey2, pszRegKeyDeviceControl, 0, NULL,
                   REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                   NULL, &hKey1, &ulDisposition);

    RegCloseKey(hKey2);           // done with instance key
    hKey2 = NULL;

    goto Clean0;    // success


CleanupOnFailure:

    //
    // attempt to cleanup the device instance (don't delete device or base if
    // other subkeys under it).
    //

    RegDeleteKey(ghEnumKey, pszDeviceID);       // delete instance

    wsprintf(RegStr, TEXT("%s\\%s"), szBase, szDevice);
    RegDeleteKey(ghEnumKey, RegStr);


 Clean0:

    if (hKey1 != NULL) {
        RegCloseKey(hKey1);
    }
    if (hKey2 != NULL) {
        RegCloseKey(hKey2);
    }

    return Status;

} // CreateDefaultDeviceInstance



ULONG
GetCurrentConfigFlag(
   IN PCWSTR   pDeviceID
   )
{
   HKEY     hKey;
   WCHAR    RegStr[MAX_PATH];
   ULONG    ulSize = 0, ulCSConfigFlag = 0;


   //
   // open a key to the current hardware profile for this device instance
   //
   wsprintf(RegStr, TEXT("%s\\%s\\%s\\%s"),
            pszRegPathHwProfiles,      // System\CCC\Hardware Profiles
            pszRegKeyCurrent,          // Current
            pszRegPathEnum,            // System\Enum
            pDeviceID);

   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_QUERY_VALUE, &hKey)
            != ERROR_SUCCESS) {
      return 0;
   }

   //
   // retrieve the config specific flag
   //
   ulSize = sizeof(ulCSConfigFlag);

   if (RegQueryValueEx(
         hKey, pszRegValueCSConfigFlags, NULL, NULL,
         (LPBYTE)&ulCSConfigFlag, &ulSize) != ERROR_SUCCESS) {
      //
      // status flags not set yet, assume zero
      //
      ulCSConfigFlag = 0;
   }

   RegCloseKey(hKey);
   return ulCSConfigFlag;

} // GetCurrentConfigFlag



BOOL
MarkDevicePhantom(
   IN HKEY     hKey,
   IN ULONG    ulValue
   )
{
   //
   // a phantom device should have a Phantom value of TRUE
   //
   RegSetValueEx(
         hKey, pszRegValuePhantom, 0, REG_DWORD,
         (LPBYTE)&ulValue, sizeof(ULONG));

   return TRUE;

} // MarkDevicePhantom



CONFIGRET
GenerateDeviceInstance(
   OUT LPWSTR   pszFullDeviceID,
   IN  LPWSTR   pszDeviceID,
   IN  ULONG    ulDevIdLen
   )
{
   LONG     RegStatus = ERROR_SUCCESS;
   WCHAR    RegStr[MAX_PATH];
   HKEY     hKey;
   ULONG    ulInstanceID = 0;
   LPWSTR   p;

   //
   // validate the device id component (can't have invalid character or a
   // backslash)
   //
   for (p = pszDeviceID; *p; p++) {
      if (*p <= TEXT(' ')  ||
          *p > (WCHAR)0x7F ||
          *p == TEXT('\\')) {

          return CR_INVALID_DEVICE_ID;
      }
   }

   //
   // make sure the supplied buffer is large enough to hold the name of the ROOT
   // enumerator, the supplied device id, a generated instance id ('0000'), two
   // path separator characters, plus a terminating NULL character.
   //
   if (ulDevIdLen < (ULONG)(lstrlen(pszRegKeyRootEnum) +
                            lstrlen(pszDeviceID) + 7)) {
       return CR_BUFFER_SMALL;
   }

   lstrcpy(pszFullDeviceID, pszRegKeyRootEnum);

   CharUpper(pszFullDeviceID);

   lstrcat(pszFullDeviceID, TEXT("\\"));

   lstrcat(pszFullDeviceID, pszDeviceID);

   //
   // try opening instance ids until we find one that doesn't already exist
   //
   while (RegStatus == ERROR_SUCCESS && ulInstanceID < 10000) {

      wsprintf(RegStr, TEXT("%s\\%04u"),
               pszFullDeviceID,
               ulInstanceID);

      RegStatus = RegOpenKeyEx(ghEnumKey, RegStr, 0, KEY_QUERY_VALUE, &hKey);

      if (RegStatus == ERROR_SUCCESS) {

          RegCloseKey(hKey);

          ulInstanceID++;
      }
   }

   if (ulInstanceID > 9999) {
      return CR_FAILURE;     // instances all used up, seems unlikely
   }

   ASSERT((ULONG)lstrlen(RegStr) < ulDevIdLen);

   lstrcpy(pszFullDeviceID, RegStr);

   return CR_SUCCESS;

} // GenerateDeviceInstance



CONFIGRET
UninstallRealDevice(
   IN LPCWSTR  pszDeviceID
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH];
   ULONG       ulCount = 0, ulProfile = 0;


   //---------------------------------------------------------------------
   // This is the case where a real device id couldn't be stopped, so we
   // cannot really safely delete the device id at this point since the
   // service may still try to use it. Instead, I'll make this device
   // id registry key volatile so that it will eventually go away when
   // the system is shutdown.  To make the key volatile, I have to copy
   // it to a temporary spot, delete the original key and recreate it
   // as a volatile key and copy everything back.
   //---------------------------------------------------------------------


   //
   // first, convert the device instance key under the main Enum
   // branch to volatile
   //

   Status = MakeKeyVolatile(pszRegPathEnum, pszDeviceID);
   if (Status != CR_SUCCESS) {
      goto Clean0;
   }

   //
   // next, check each hardware profile and delete any entries for this
   // device instance.
   //

   Status = GetProfileCount(&ulCount);
   if (Status != CR_SUCCESS) {
      goto Clean0;
   }

   for (ulProfile = 1; ulProfile <= ulCount; ulProfile++) {

      wsprintf(RegStr, TEXT("%s\\%04u\\%s"),
               pszRegPathHwProfiles,
               ulProfile,
               pszRegPathEnum);

      //
      // Ignore the status for profile-specific keys since they may
      // not exist.
      //

      MakeKeyVolatile(RegStr, pszDeviceID);
   }

   //
   // finally, mark the device as being removed
   //

   SetDeviceStatus(pszDeviceID, DN_WILL_BE_REMOVED, 0);

 Clean0:

   return Status;

} // UninstallRealDevice



CONFIGRET
UninstallPhantomDevice(
    IN  LPCWSTR  pszDeviceID
    )
{
   CONFIGRET   Status = CR_SUCCESS;
   NTSTATUS    NtStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA  ControlData;
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   WCHAR       RegStr[MAX_CM_PATH];
   ULONG       ulCount = 0, ulProfile = 0;


   //
   // 1. Deregister the original device id (only on phantoms)
   //

   memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
   RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
   ControlData.Flags = 0;

   NtStatus = NtPlugPlayControl(PlugPlayControlDeregisterDevice,
                                &ControlData,
                                sizeof(ControlData));

   //
   // Don't bother with the status here, the device might not have
   // been registered which would cause the previous call to fail.
   // Keep trying to clean (uninstall) this device instance.
   //

   //
   // 2. Remove the instance under the main enum branch.  If this is the
   // only instance, then the device will be removed as well. The parent
   // key to DeletePrivateKey is the registry path up to the enumerator
   // and the child key is the device and instance.
   //

   //
   // Get the device id's component parts.
   //

   SplitDeviceInstanceString(pszDeviceID,
                             szEnumerator,
                             szDevice,
                             szInstance);

   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegPathEnum,
            szEnumerator);

   lstrcat(szDevice, TEXT("\\"));
   lstrcat(szDevice, szInstance);



   //
   // delete the device instance key
   //

   Status = DeletePrivateKey(HKEY_LOCAL_MACHINE, RegStr, szDevice);
   if (Status != CR_SUCCESS) {
       goto Clean0;
   }

   //
   // 3. Now check each hardware profile and delete any entries for this
   // device instance.
   //

   Status = GetProfileCount(&ulCount);
   if (Status != CR_SUCCESS) {
       goto Clean0;
   }

   for (ulProfile = 1; ulProfile <= ulCount; ulProfile++) {

       wsprintf(RegStr, TEXT("%s\\%04u\\%s\\%s"),
                pszRegPathHwProfiles,
                ulProfile,
                pszRegPathEnum,
                szEnumerator);

       //
       // Ignore the status for profile-specific keys since they may
       // not exist. RemoveDeviceInstance() will remove the instance
       // and the device if this is the only instance.
       //
       DeletePrivateKey(HKEY_LOCAL_MACHINE, RegStr, szDevice);
   }

 Clean0:

   return Status;

} // UninstallPhantomDevice



BOOL
IsDeviceRootEnumerated(
    IN LPCWSTR  pszDeviceID
    )
{
    WCHAR  szEnumerator[MAX_DEVICE_ID_LEN],
           szDevice[MAX_DEVICE_ID_LEN],
           szInstance[MAX_DEVICE_ID_LEN];

    if (!SplitDeviceInstanceString(pszDeviceID,
                                   szEnumerator,
                                   szDevice,
                                   szInstance)) {
        return FALSE;
    }

    return (_wcsicmp(szEnumerator, pszRegKeyRootEnum) == 0);

} // IsDeviceRootEnumerated



BOOL
IsDeviceRegistered(
    IN LPCWSTR  pszDeviceID,
    IN LPCWSTR  pszService
    )
{
    WCHAR   RegStr[MAX_PATH], szData[MAX_DEVICE_ID_LEN], szValue[MAX_PATH];
    HKEY    hKey = NULL;
    LONG    RegStatus = ERROR_SUCCESS;
    ULONG   ulIndex = 0, ulDataSize = 0, ulValueSize = 0, i = 0;
    BOOL    Status = FALSE;


    //
    // open the service's volatile enum registry key
    //
    wsprintf(RegStr, TEXT("%s\\%s"),
             pszService,
             pszRegKeyEnum);

    if (RegOpenKeyEx(ghServicesKey, RegStr, 0, KEY_READ, &hKey)
                     == ERROR_SUCCESS) {

        //
        //  Enumerate all the values under this key
        //
        while (RegStatus == ERROR_SUCCESS) {

            ulDataSize = MAX_DEVICE_ID_LEN * sizeof(WCHAR);
            ulValueSize = MAX_PATH;

            RegStatus = RegEnumValue(hKey, ulIndex, szValue, &ulValueSize,
                                     NULL, &i, (LPBYTE)szData, &ulDataSize);

            if (RegStatus == ERROR_SUCCESS) {

                ulIndex++;

                if (lstrcmpi(pszDeviceID, szData) == 0) {
                    Status = TRUE;
                    break;
                }
            }
        }
        RegCloseKey(hKey);
    }

    return Status;

} // IsDeviceRegistered



BOOL
IsPrivatePhantomFromFirmware(
    IN HKEY hKey
    )
/*++

Routine Description:

   This routine checks to see if the supplied device instance registry key is
   for a firmware mapper-created private phantom.

Arguments:

    hKey - Supplied the handle to the registry key for the device instance to
        be examined.

Return value:

    If the device instance registry key represents a firmware mapper-reported
    phantom, the return value is TRUE.  Otherwise, it is FALSE.

--*/
{
    ULONG ValueSize, Value;
    HKEY hControlKey;
    BOOL b = FALSE;

    //
    // First, make sure that this is indeed a phantom
    //
    ValueSize = sizeof(Value);
    Value = 0;

    if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         pszRegValuePhantom,
                                         NULL,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &ValueSize))
       || !Value)
    {
        //
        // Not a phantom
        //
        goto clean0;
    }

    //
    // OK, we have a phantom--did it come from the firmware mapper?
    //
    ValueSize = sizeof(Value);
    Value = 0;

    if((ERROR_SUCCESS != RegQueryValueEx(hKey,
                                         pszRegValueFirmwareIdentified,
                                         NULL,
                                         NULL,
                                         (LPBYTE)&Value,
                                         &ValueSize))
       || !Value)
    {
        //
        // This phantom didn't come from the firmware mapper.
        //
        goto clean0;
    }

    //
    // Finally, we need to check to see whether the device is actually present
    // on this boot.  If not, we want to return FALSE, because we don't want
    // detection modules to be registering devnodes for non-existent hardware.
    //
    if(ERROR_SUCCESS == RegOpenKeyEx(hKey,
                                     pszRegKeyDeviceControl,
                                     0,
                                     KEY_READ,
                                     &hControlKey)) {

        ValueSize = sizeof(Value);
        Value = 0;

        if((ERROR_SUCCESS == RegQueryValueEx(hControlKey,
                                             pszRegValueFirmwareMember,
                                             NULL,
                                             NULL,
                                             (LPBYTE)&Value,
                                             &ValueSize))
           && Value)
        {
            b = TRUE;
        }

        RegCloseKey(hControlKey);
    }

clean0:

    return b;

} // IsPrivatePhantomFromFirmware


CONFIGRET
EnumerateSubTreeTopDownBreadthFirst(
    IN      handle_t        BindingHandle,
    IN      LPCWSTR         DevInst,
    IN      PFN_ENUMTREE    CallbackFunction,
    IN OUT  PVOID           Context
    )
/*++

Routine Description:

    This routine walks a subtree in a breadth-first nonrecursive manner.

Arguments:

    BindingHandle       RPC Binding handle

    DevInst             InstancePath of device to begin with. It is assumed
                        that this InstancePath is valid.

    CallbackFunction    Function to call for each node in the subtree (DevInst
                        included)

    Context             Context information to pass to the callback function.


Return Value:

    CONFIGRET (Success if walk progressed through every node specified by the
               CallbackFunction, failure due to low memory, bad instance path,
               or other problems)

--*/
{
    PENUM_ELEMENT   enumElement;
    ENUM_ACTION     enumAction;
    LIST_ENTRY      subTreeHead;
    PLIST_ENTRY     listEntry;
    CONFIGRET       status;

    //
    // This algorithm is a nonrecursive tree walk. It works by building a list.
    // Parents are removed from the head of the list and their children are
    // added to the end of the list. This enforces a breadth-first downward
    // tree walk.
    //
    InitializeListHead(&subTreeHead);

    //
    // This walk includes the head node as well, so insert it into the list.
    //
    enumElement = HeapAlloc(
        ghPnPHeap,
        0,
        sizeof(ENUM_ELEMENT) + lstrlen(DevInst)*sizeof(WCHAR)
        );

    if (enumElement == NULL) {

        return CR_OUT_OF_MEMORY;
    }

    lstrcpy(enumElement->DevInst, DevInst);
    InsertTailList(&subTreeHead, &enumElement->ListEntry);

    //
    // Remove each entry from the head of the list on downwards.
    //
    status = CR_SUCCESS;
    while(!IsListEmpty(&subTreeHead)) {

        listEntry = RemoveHeadList(&subTreeHead);
        enumElement = CONTAINING_RECORD(listEntry, ENUM_ELEMENT, ListEntry);

        enumAction = CallbackFunction(enumElement->DevInst, Context);

        if (enumAction == EA_STOP_ENUMERATION) {

            HeapFree(ghPnPHeap, 0, enumElement);
            break;
        }

        if (enumAction != EA_SKIP_SUBTREE) {

            status = EnumerateSubTreeTopDownBreadthFirstWorker(
                BindingHandle,
                enumElement->DevInst,
                &subTreeHead
                );

            if (status != CR_SUCCESS) {

                HeapFree(ghPnPHeap, 0, enumElement);
                break;
            }
        }

        HeapFree(ghPnPHeap, 0, enumElement);
    }

    //
    // There might be entries left in the list if we bailed prematurely. Clean
    // them out here.
    //
    while(!IsListEmpty(&subTreeHead)) {

        listEntry = RemoveHeadList(&subTreeHead);
        enumElement = CONTAINING_RECORD(listEntry, ENUM_ELEMENT, ListEntry);
        HeapFree(ghPnPHeap, 0, enumElement);
    }

    return status;
}


CONFIGRET
EnumerateSubTreeTopDownBreadthFirstWorker(
    IN      handle_t    BindingHandle,
    IN      LPCWSTR     DevInst,
    IN OUT  PLIST_ENTRY ListHead
    )
/*++

Routine Description:

    This routine inserts all the child relations of DevInst onto the passed in
    list.

Arguments:

    BindingHandle   RPC Binding handle

    DevInst         InstancePath to enumerate.

    ListHead        List to append children to.

Return Value:

    CONFIGRET

--*/
{
    CONFIGRET       status;
    ULONG           ulLen;
    LPWSTR          pszRelations, pszCurEntry;
    PENUM_ELEMENT   enumElement;

    status = PNP_GetDeviceListSize(
        BindingHandle,
        DevInst,
        &ulLen,
        CM_GETIDLIST_FILTER_BUSRELATIONS
        );

    if ((status != CR_SUCCESS) || (ulLen == 0)) {

        return status;
    }

    //
    // Allocate an element for the first entry.
    //
    pszRelations = HeapAlloc(
        ghPnPHeap,
        HEAP_ZERO_MEMORY,
        (ulLen+2)*sizeof(WCHAR)
        );

    if (pszRelations == NULL) {

        return CR_OUT_OF_MEMORY;
    }

    status = PNP_GetDeviceList(
        BindingHandle,
        DevInst,
        pszRelations,
        &ulLen,
        CM_GETIDLIST_FILTER_BUSRELATIONS
        );

    if (status != CR_SUCCESS) {

        HeapFree(ghPnPHeap, 0, pszRelations);
        return status;
    }

    for(pszCurEntry = pszRelations;
        *pszCurEntry;
        pszCurEntry = pszCurEntry + lstrlen(pszCurEntry)+1) {

        enumElement = HeapAlloc(
            ghPnPHeap,
            0,
            sizeof(ENUM_ELEMENT) + lstrlen(pszCurEntry)*sizeof(WCHAR)
            );

        if (enumElement == NULL) {

            HeapFree(ghPnPHeap, 0, pszRelations);
            return CR_OUT_OF_MEMORY;
        }

        //
        // Insert it into the end of the tree.
        //
        lstrcpy(enumElement->DevInst, pszCurEntry);
        InsertTailList(ListHead, &enumElement->ListEntry);
    }

    HeapFree(ghPnPHeap, 0, pszRelations);
    return CR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rresdes.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rresdes.c

Abstract:

    This module contains the server-side resource description APIs.

                  PNP_AddResDes
                  PNP_FreeResDes
                  PNP_GetNextResDes
                  PNP_GetResDesData
                  PNP_GetResDesDataSize
                  PNP_ModifyResDes
                  PNP_DetectResourceConflict

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"


//
// private prototypes
//

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    );

BOOL
FindResDes(
    IN  LPBYTE     pList,
    IN  ULONG      RegDataType,
    IN  ULONG      ulLogConfTag,
    IN  ULONG      ulResTag,
    IN  RESOURCEID ResType,
    OUT LPBYTE     *ppRD,
    OUT LPBYTE     *ppLogConf,
    OUT PULONG     pulSubIndex      OPTIONAL
    );

PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    );

ULONG
RANGE_COUNT(
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr
    );

ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    );

ULONG
GetReqDesSize(
    IN ULONG                   ResourceID,
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr,
    IN ULONG                   ulFlags
    );

CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceID,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

CONFIGRET
ResDesToNtRequirements(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PIO_RESOURCE_DESCRIPTOR          pReqDes,
    IN OUT PULONG                           pulResCount,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    );

CONFIGRET
NtResourceToResDes(
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    );

CONFIGRET
NtRequirementsToResDes(
    IN     PIO_RESOURCE_DESCRIPTOR         pReqDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    );

UCHAR
NT_RES_TYPE(
   IN RESOURCEID    ResourceID
   );

ULONG
CM_RES_TYPE(
   IN UCHAR    ResourceType
   );

USHORT    MapToNtMemoryFlags(IN DWORD);
DWORD     MapFromNtMemoryFlags(IN USHORT);
USHORT    MapToNtPortFlags(IN DWORD, IN DWORD);
DWORD     MapFromNtPortFlags(IN USHORT);
DWORD     MapAliasFromNtPortFlags(IN USHORT);
ULONG     MapToNtAlignment(IN DWORDLONG);
DWORDLONG MapFromNtAlignment(IN ULONG);
USHORT    MapToNtDmaFlags(IN DWORD);
DWORD     MapFromNtDmaFlags(IN USHORT);
USHORT    MapToNtIrqFlags(IN DWORD);
DWORD     MapFromNtIrqFlags(IN USHORT);
UCHAR     MapToNtIrqShare(IN DWORD);
DWORD     MapFromNtIrqShare(IN UCHAR);

//
// prototypes from rlogconf.c
//
CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    );

PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    );

PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    );


//
// global data
//
#define HIDWORD(x)   ((DWORD)(((DWORDLONG)(x) >> 32) & 0xFFFFFFFF))
#define LODWORD(x)   ((DWORD)(x))
#define MAKEDWORDLONG(x,y)  ((DWORDLONG)(((DWORD)(x)) | ((DWORDLONG)((DWORD)(y))) << 32))



CONFIGRET
PNP_AddResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   OUT PULONG     pResourceTag,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine adds
  a res des to the specified log conf.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    ResourceData  Resource data (of ResourceID type) to add to log conf.

    ResourceLen   Size of ResourceData in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, i = 0, ulSize = 0, ulOffset = 0,
                ulAddListSize = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pTemp = NULL;

    //
    // Always add the res des to the end, except in the case where a
    // class-specific res des has already been added. The class-specific
    // res des always MUST be last so add any new (non-class specific)
    // res des just before the class specific. Note that there can be
    // only one class-specific res des.
    //

    try {
        //
        // verify client access
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pResourceTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pResourceTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(ResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, LogConfTag)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes = NULL;

            //
            // determine size required to hold the new res des
            //
            ulAddListSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (ResourceID == ResType_ClassSpecific) {

                PCS_RESOURCE pCsRes = (PCS_RESOURCE)ResourceData;

                //
                // first make sure there isn't already a cs (only one per lc)
                //
                if (pRes->PartialResourceList.Count != 0 &&
                    pRes->PartialResourceList.PartialDescriptors[pRes->PartialResourceList.Count-1].Type
                          == CmResourceTypeDeviceSpecific) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // account for any extra class specific data in res list
                //
                ulAddListSize += sizeof(GUID) +
                                 pCsRes->CS_Header.CSD_SignatureLength +
                                 pCsRes->CS_Header.CSD_LegacyDataSize;
            }

            //
            // reallocate the resource buffers to hold the new res des
            //
            ulOffset = (DWORD)((ULONG_PTR)pRes - (ULONG_PTR)pResList);   // for restoring later

            pResList = HeapReAlloc(ghPnPHeap, 0, pResList, ulListSize + ulAddListSize);
            if (pResList == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }
            pList = (LPBYTE)pResList;
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)((LPBYTE)pResList + ulOffset);

            //
            // Find location for new res des (make a hole if necessary)
            //
            // If the following conditions are true, then can just append the
            // new data to the end of the rsource list:
            // - The selected LogConf is the last LogConf, and
            // - No ClassSpecific resource has been added yet (or no resource period)
            //
            i = pRes->PartialResourceList.Count;

            if ((LogConfTag == pResList->Count - 1) &&
                (i == 0 ||
                pRes->PartialResourceList.PartialDescriptors[i-1].Type !=
                CmResourceTypeDeviceSpecific)) {

                *pResourceTag = i;
                pResDes = &pRes->PartialResourceList.PartialDescriptors[i];

            } else {
                //
                // Need to make a hole for the new data before copying it.
                // Find the spot to add the new res des data at - either as the
                // last res des for this log conf or just before the class
                // specific res des if it exists.
                //
                if (i == 0) {
                    *pResourceTag = 0;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[0];

                } else if (pRes->PartialResourceList.PartialDescriptors[i-1].Type ==
                           CmResourceTypeDeviceSpecific) {

                    *pResourceTag = i-1;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[i-1];

                } else {
                    *pResourceTag = i;
                    pResDes = &pRes->PartialResourceList.PartialDescriptors[i];
                }

                //
                // Move any data after this point down a notch to make room for
                // the new res des
                //
                ulSize = ulListSize - (DWORD)((ULONG_PTR)pResDes - (ULONG_PTR)pResList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pResDes, ulSize);
                memcpy((LPBYTE)((LPBYTE)pResDes + ulAddListSize), pTemp, ulSize);
            }

            if (ResourceID == ResType_ClassSpecific) {
                *pResourceTag = RESDES_CS_TAG;
            }

            //
            // Add res des to the log conf
            //
            Status = ResDesToNtResource(ResourceData, ResourceID, ResourceLen,
                                        pResDes, *pResourceTag, ulFlags);

            //
            // update the lc and res header
            //
            pRes->PartialResourceList.Count += 1;  // added a single res des (_DES)
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = NULL;
            PGENERIC_RESOURCE              pGenRes = (PGENERIC_RESOURCE)ResourceData;

            //
            // validate res des type - ClassSpecific not allowed in
            // requirements list (only resource list)
            //
            if (ResourceID == ResType_ClassSpecific ||
                pGenRes->GENERIC_Header.GENERIC_Count == 0) {

                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // determine size required to hold the new res des
            //
            ulAddListSize = pGenRes->GENERIC_Header.GENERIC_Count *
                            sizeof(IO_RESOURCE_DESCRIPTOR);

            //
            // reallocate the resource buffers to hold the new res des
            //
            ulOffset = (DWORD)((ULONG_PTR)pReq - (ULONG_PTR)pReqList);   // for restoring later

            pReqList = HeapReAlloc(ghPnPHeap, 0, pReqList, ulListSize + ulAddListSize);
            if (pReqList == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }
            pList = (LPBYTE)pReqList;
            pReq = (PIO_RESOURCE_LIST)((LPBYTE)pReqList + ulOffset);

            //
            // Find location for new res des - the new res des always ends
            // up being added as the last res des for this log conf.
            //
            *pResourceTag = pReq->Count;
            pReqDes = &pReq->Descriptors[*pResourceTag];

            //
            // If the selected LogConf is the last LogConf then can just
            // append the new res des data to the end of the requirements
            // list. Otherwise, need to make a whole for the new data
            // before copying it.
            //
            if (LogConfTag != pReqList->AlternativeLists - 1) {

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pReqDes - (ULONG_PTR)pReqList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pReqDes, ulSize);
                memcpy((LPBYTE)((LPBYTE)pReqDes + ulAddListSize), pTemp, ulSize);
            }

            //
            // Add res des to the log conf.
            //
            Status = ResDesToNtRequirements(ResourceData, ResourceID, ResourceLen,
                                            pReqDes, &i, *pResourceTag, ulFlags);

            //
            // update the lc and res header
            //
            pReq->Count += i;                      // _RANGES added
            pReqList->ListSize = ulListSize + ulAddListSize;
        }

        //
        // Write out the new/updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize + ulAddListSize)
                         != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
         HeapFree(ghPnPHeap, 0, pTemp);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_AddResDes



CONFIGRET
PNP_FreeResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT PULONG     pulPreviousResType,
   OUT PULONG     pulPreviousResTag,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine frees
  a res des to the specified log conf.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Specifies the resource within a given type.

    pulPreviousResType  Receives the previous resource type.

    pulPreviousResTag   Receives the previous resource within a given type.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType=0, RdCount=0, ulCount=0, ulListSize=0, ulSize=0;
    LPBYTE      pList=NULL, pLogConf=NULL, pRD=NULL, pTemp=NULL, pNext=NULL;

    try {
        //
        // verify client access
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // If this is the last log conf and last res des, then don't
            // need to do anything except truncate it by writing less data
            // back into the registry.
            //
            if ((LogConfTag == pResList->Count - 1)  &&
                ((ResourceTag == pRes->PartialResourceList.Count - 1) ||
                (ResourceTag == RESDES_CS_TAG))) {

                pRes->PartialResourceList.Count -= 1;
                ulListSize = (DWORD)((ULONG_PTR)(pResDes) - (ULONG_PTR)(pResList));

            } else {
                //
                // If the res des is not at the end of the structure, then
                // migrate the remainder of the structure up to keep the
                // struct contiguous when removing a res des.
                //
                // pResDes points to the beginning of the res des to remove,
                // pNext points to the byte just after the res des to remove
                //
                pNext = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                if (pResDes->Type == CmResourceTypeDeviceSpecific) {
                    pNext += pResDes->u.DeviceSpecificData.DataSize;
                }

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResDes);   // new lc list size

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);
                memcpy((LPBYTE)pResDes, pTemp, ulSize);

                pRes->PartialResourceList.Count -= 1;
            }

            //
            // if no more res des's in this log conf, then return that
            // status (the client side will return a handle to the lc)
            //
            if (pRes->PartialResourceList.Count == 0) {
                Status = CR_NO_MORE_RES_DES;
            } else {
                //
                // return the previous res des type and tag
                //
                *pulPreviousResType =
                    CM_RES_TYPE(pRes->PartialResourceList.PartialDescriptors[ResourceTag-1].Type);

                if (*pulPreviousResType == ResType_ClassSpecific) {
                    *pulPreviousResTag = RESDES_CS_TAG;     // special tag for cs
                } else {
                    *pulPreviousResTag = ResourceTag - 1;
                }
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;

            //
            // If this is the last log conf and last res des, then don't
            // need to do anything except truncate it by writing less data
            // back into the registry.
            //
            RdCount = RANGE_COUNT(pReqDes, (LPBYTE)pReqList + ulListSize - 1);

            if ((LogConfTag == pReqList->AlternativeLists - 1)  &&
                (RdCount + ulCount == pReq->Count - 1)) {

                ulListSize = (DWORD)((ULONG_PTR)(pReqDes) - (ULONG_PTR)pReqList);

            } else {
                //
                // If the res des is not at the end of the structure, then
                // migrate the remainder of the structure up to keep the
                // struct contiguous when removing a res des.
                //
                // pReqDes points to the beginning of the res des(s) to remove,
                // pNext points to the byte just after the res des(s) to remove
                //
                pNext = (LPBYTE)((LPBYTE)pReqDes +
                                  RdCount * sizeof(IO_RESOURCE_DESCRIPTOR));

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqDes);   // new lc list size

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);
                memcpy((LPBYTE)pReqDes, pTemp, ulSize);
            }

            pReqList->ListSize = ulListSize;
            pReq->Count -= RdCount;

            //
            // if no more res des's in this log conf, then return that status
            // (the client side will return a handle to the log conf)
            //
            if (pReq->Count == 0) {
                Status = CR_NO_MORE_RES_DES;
            } else {
                //
                // return the previous res des type and tag
                //
                pReqDes = AdvanceRequirementsDescriptorPtr(&pReq->Descriptors[0],
                                                           ResourceTag-1, pReq->Count, NULL);

                //
                // Double check whether this is the first ConfigData res des,
                // skip it if so.
                //
                if (pReqDes == NULL || pReqDes->Type == CmResourceTypeConfigData) {
                    Status = CR_NO_MORE_RES_DES;
                } else {
                    *pulPreviousResType = CM_RES_TYPE(pReqDes->Type);
                    *pulPreviousResTag = ResourceTag - 1;
                }
            }
        }


        //
        // Write out the updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_INVALID_RES_DES;     // mostly likely reason we got here
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

   return Status;

} // PNP_FreeResDes



CONFIGRET
PNP_GetNextResDes(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT PULONG     pulNextResDesTag,
   OUT PULONG     pulNextResDesType,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine gets the
  next res des in the specified log conf.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Specifies current resource descriptor (if any).

    pulNextResDesTag   Receives the next resource type.

    pulNextResDesType  Receives the next resource within a given type.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, i = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulNextResDesTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulNextResDesTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, LogConfTag)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // find the next res des. A resource tag of max indicates that we want
        // a find first operation.
        //
        if (ResourceTag == MAX_RESDES_TAG) {
            //
            // This is essentially a Get-First operation
            //
            *pulNextResDesTag = 0;

        } else if (ResourceTag == RESDES_CS_TAG) {
            //
            // By definition, if the resource type is classspecific, it's last,
            // so there aren't any more after this.
            //
            Status = CR_NO_MORE_RES_DES;
            goto Clean0;

        } else {
            *pulNextResDesTag = ResourceTag + 1;      // we want the "next" res des
        }


        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            ULONG                           ulTmpResDesTag, ulTmpLogConfTag;

            ulTmpResDesTag = *pulNextResDesTag;
            ulTmpLogConfTag = LogConfTag;

            for ( ; ; ) {

                while (ulTmpResDesTag >= pRes->PartialResourceList.Count)  {

                    ulTmpResDesTag -= pRes->PartialResourceList.Count;
                    ulTmpLogConfTag++;

                    //
                    // Seek to the log conf that matches the log conf tag
                    //
                    if (!FindLogConf(pList, &pLogConf, RegDataType, ulTmpLogConfTag)) {

                        Status = CR_NO_MORE_RES_DES;    // there is no "next"
                        goto Clean0;
                    }

                    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
                }

                //
                // Not done yet, if a specific resource type was specified, then
                // we may need to keep looking.
                //
                if (ResourceID != ResType_All) {

                    UCHAR NtResType = NT_RES_TYPE(ResourceID);

                    if (pRes->PartialResourceList.PartialDescriptors[ulTmpResDesTag].Type
                           != NtResType) {

                        (*pulNextResDesTag)++;
                        ulTmpResDesTag++;
                        continue;
                    }
                }

                break;
            }

            //
            // Return the type and tag of the "next" res des
            //
            *pulNextResDesType = CM_RES_TYPE(pRes->PartialResourceList.
                                             PartialDescriptors[ulTmpResDesTag].Type);

            if (*pulNextResDesType == ResType_ClassSpecific) {
                *pulNextResDesTag = RESDES_CS_TAG;     // special tag for cs
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes;

            //
            // Point pResDes at the first possible "next" res des
            //

            if (*pulNextResDesTag == 0) {
                if (pReq->Count == 0) {
                    Status = CR_NO_MORE_RES_DES;    // there is no "next"
                    goto Clean0;
                }

                if (pReq->Descriptors[0].Type == CmResourceTypeConfigData) {
                    //
                    // This one doesn't count, it's privately created and maintained,
                    // skip to the next rd
                    //
                    *pulNextResDesTag = 1;
                }
            }

            if (*pulNextResDesTag > 0) {
                pReqDes = AdvanceRequirementsDescriptorPtr(&pReq->Descriptors[0], *pulNextResDesTag, pReq->Count, &ulCount); // current

                if (pReqDes == NULL) {
                    Status = CR_NO_MORE_RES_DES;    // there is no "next"
                    goto Clean0;
                }
            } else {
                ulCount = 0;
                pReqDes = &pReq->Descriptors[0];
            }

            //
            // Not done yet, if a specific resource type was specified, then
            // we may need to keep looking.
            //
            if (ResourceID != ResType_All) {

                UCHAR NtResType = NT_RES_TYPE(ResourceID);

                while (pReqDes->Type != NtResType) {

                    if (ulCount >= pReq->Count) {
                        Status = CR_NO_MORE_RES_DES;
                        goto Clean0;
                    }
                    pReqDes = AdvanceRequirementsDescriptorPtr(pReqDes, 1, pReq->Count - ulCount, &i);

                    if (pReqDes == NULL) {
                        Status = CR_NO_MORE_RES_DES;
                        goto Clean0;
                    }

                    ulCount += i;
                    *pulNextResDesTag += 1;
                }
            }

            *pulNextResDesType = CM_RES_TYPE(pReqDes->Type);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetNextResDes



CONFIGRET
PNP_GetResDesData(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  ULONG      LogConfTag,
   IN  ULONG      LogConfType,
   IN  RESOURCEID ResourceID,
   IN  ULONG      ResourceTag,
   OUT LPBYTE     Buffer,
   IN  ULONG      BufferLen,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  the data for the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    Buffer        Returns resource data (of ResourceID type) from log conf.

    BufferLen     Size of Buffer in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data expected is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pRD = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // map the NT-style info into ConfigMgr-style structures
            //
            Status = NtResourceToResDes(pResDes, Buffer, BufferLen,
                                        (LPBYTE)pResList + ulListSize - 1, ulFlags);
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;

            //
            // map the NT-style info into ConfigMgr-style structures
            //
            Status = NtRequirementsToResDes(pReqDes, Buffer, BufferLen,
                                            (LPBYTE)pReqList + ulListSize - 1, ulFlags);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
       HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetResDesData



CONFIGRET
PNP_GetResDesDataSize(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      LogConfTag,
    IN  ULONG      LogConfType,
    IN  RESOURCEID ResourceID,
    IN  ULONG      ResourceTag,
    OUT PULONG     pulSize,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine retrieves
  the data size for the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceTag   Returns with resource within a given type.

    pulSize       Returns size of buffer in bytes required to hold the
                  resource data (of ResourceID type) from log conf.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data expected is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, ulCount = 0;
    LPBYTE      pList = NULL, pLogConf = NULL, pRD = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate/initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulSize)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulSize = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, ResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // calculate data size required (in terms of ConfigMgr structures)
            //
            *pulSize = GetResDesSize(ResourceID, ulFlags);

            if (ResourceID == ResType_ClassSpecific) {
                //
                // the Reserved fields should not exceed DataSize. if so, they
                // may have been incorrectly initialized, so set them 0.
                // we expect DataSize to be correct in all cases.
                //
                if (pResDes->u.DeviceSpecificData.Reserved1 > pResDes->u.DeviceSpecificData.DataSize) {
                    pResDes->u.DeviceSpecificData.Reserved1 = 0;
                }

                if (pResDes->u.DeviceSpecificData.Reserved2 > pResDes->u.DeviceSpecificData.DataSize) {
                    pResDes->u.DeviceSpecificData.Reserved2 = 0;
                }

                //
                // add space for legacy and signature data but not the
                // GUID - it's already included in the CM structures
                //
                if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                    //
                    // no legacy data or class-specific data
                    //
                    ;
                } else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                    //
                    // add space for legacy data
                    //
                    *pulSize += pResDes->u.DeviceSpecificData.DataSize - 1;
                } else {
                    //
                    // add space for class-specific data and/or legacy data
                    //
                    *pulSize += pResDes->u.DeviceSpecificData.Reserved1 +
                                pResDes->u.DeviceSpecificData.Reserved2 - 1;
                }
            }
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;
            LPBYTE                         pLastReqAddr = (LPBYTE)pList + ulListSize - 1;

            //
            // calculate data size required (in terms of ConfigMgr structures)
            //
            *pulSize = GetReqDesSize(ResourceID, pReqDes, pLastReqAddr, ulFlags);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetResDesDataSize



CONFIGRET
PNP_ModifyResDes(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      LogConfTag,
    IN ULONG      LogConfType,
    IN RESOURCEID CurrentResourceID,
    IN RESOURCEID NewResourceID,
    IN ULONG      ResourceTag,
    IN LPBYTE     ResourceData,
    IN ULONG      ResourceLen,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine modifies
  the specified res des.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    LogConfTag    Specifies the log conf within a given type.

    LogConfType   Specifies the log conf type.

    ResourceID    Specifies the resource type.

    ResourceIndex Returns with resource within a given type.

    ResourceData  New resource data (of ResourceID type).

    ResourceLen   Size of ResourceData in bytes.

    ulFlags       Specifies the width of certain variable-size resource
                  descriptor structure fields, where applicable.

                  Currently, the following flags are defined:

                    CM_RESDES_WIDTH_32 or
                    CM_RESDES_WIDTH_64

                  If no flags are specified, the width of the variable-sized
                  resource data supplied is assumed to be that native to the
                  platform of the caller.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       ulListSize = 0, ulOldSize = 0, ulNewSize = 0, ulSize = 0,
                ulOldCount = 0, ulNewCount = 0, RegDataType = 0, ulCount = 0;
    LONG        AddSize = 0;
    LPBYTE      pList = NULL, pRD = NULL, pLogConf = NULL,
                pTemp = NULL, pNext = NULL;


    try {
        //
        // verify client access
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_RESDES_WIDTH_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // validate res des size
        //
        if (ResourceLen < GetResDesSize(NewResourceID, ulFlags)) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, LogConfType, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, LogConfType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_RES_DES;        // log conf doesn't exist
            goto Clean0;
        }

        //
        // seek to the res des that matches the resource tag.
        //
        if (!FindResDes(pList, RegDataType, LogConfTag,
                        ResourceTag, CurrentResourceID, &pRD, &pLogConf, &ulCount)) {

            Status = CR_INVALID_RES_DES;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-------------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR    pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)pLogConf;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)pRD;

            //
            // If new res des type is ClassSpecific, then it must be the last
            // res des that is attempting to be modified (only last res des can
            // be class specific).
            //
            if (NewResourceID == ResType_ClassSpecific  &&
                ResourceTag != RESDES_CS_TAG) {

                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // calculate the current size and the new size of the res des data
            //
            ulNewSize = ulOldSize = sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

            if (CurrentResourceID == ResType_ClassSpecific) {
                ulOldSize += pResDes->u.DeviceSpecificData.DataSize;
            }

            if (NewResourceID == ResType_ClassSpecific) {

                PCS_RESOURCE pCsRes = (PCS_RESOURCE)ResourceData;

                ulNewSize += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                             sizeof(GUID) +
                             pCsRes->CS_Header.CSD_SignatureLength +
                             pCsRes->CS_Header.CSD_LegacyDataSize;
            }

            //
            // How much does data need to grow/shrink to accomodate the change?
            //
            AddSize = ulNewSize - ulOldSize;

            //
            // reallocate the buffers and shrink/expand the contents as
            // necessary
            //
            if (AddSize != 0) {

                if (AddSize > 0) {
                    //
                    // only bother reallocating if the buffer size is growing
                    //
                    ULONG ulOffset = (ULONG)((ULONG_PTR)pResDes - (ULONG_PTR)pResList);

                    pResList = HeapReAlloc(ghPnPHeap, 0, pResList, ulListSize + AddSize);
                    if (pResList == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }
                    pList = (LPBYTE)pResList;
                    pResDes = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)((LPBYTE)pResList + ulOffset);
                }

                //
                // if not the last lc and rd, then need to move the following data
                // either up or down to account for changed res des data size
                //
                if ((LogConfTag != pResList->Count - 1)  ||
                    ((ResourceTag != pRes->PartialResourceList.Count - 1) &&
                     ResourceTag != RESDES_CS_TAG)) {

                    pNext = (LPBYTE)((LPBYTE)pResDes + ulOldSize);
                    ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);

                    pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                    if (pTemp == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    memcpy(pTemp, pNext, ulSize);
                    memcpy((LPBYTE)((LPBYTE)pResDes + ulNewSize), pTemp, ulSize);
                }
            }

            //
            // write out modified data
            //
            Status = ResDesToNtResource(ResourceData, NewResourceID, ResourceLen,
                                        pResDes, ResourceTag, ulFlags);
        }

        //-------------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-------------------------------------------------------------

        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = (PIO_RESOURCE_LIST)pLogConf;
            PIO_RESOURCE_DESCRIPTOR        pReqDes = (PIO_RESOURCE_DESCRIPTOR)pRD;
            LPBYTE pLastReqAddr = (LPBYTE)pReqList + ulListSize - 1;
            PGENERIC_RESOURCE pGenRes = (PGENERIC_RESOURCE)ResourceData;

            //
            // Can't add class specific resdes to this type of log conf
            //
            if (NewResourceID == ResType_ClassSpecific) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // calculate the current size and the new size of the res des data
            //
            ulOldCount = RANGE_COUNT(pReqDes, pLastReqAddr);
            ulOldSize  = sizeof(IO_RESOURCE_DESCRIPTOR) * ulOldCount;

            ulNewSize  = sizeof(IO_RESOURCE_DESCRIPTOR) *
                         pGenRes->GENERIC_Header.GENERIC_Count;

            //
            // How much does data need to grow/shrink to accomodate the change?
            //
            AddSize = ulNewSize - ulOldSize;

            //
            // reallocate the buffers and shrink/expand the contents as
            // necessary
            //
            if (AddSize != 0) {

                if (AddSize > 0) {
                    //
                    // only bother reallocating if the buffer size is growing
                    //
                    ULONG ulOffset = (ULONG)((ULONG_PTR)pReqDes - (ULONG_PTR)pReqList);

                    pReqList = HeapReAlloc(ghPnPHeap, 0, pReqList, ulListSize + AddSize);
                    if (pReqList == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }
                    pList = (LPBYTE)pReqList;
                    pReqDes = (PIO_RESOURCE_DESCRIPTOR)((LPBYTE)pReqList + ulOffset);
                }

                //
                // set to last index for this res des (whole)
                //
                ulCount += RANGE_COUNT(pReqDes, (LPBYTE)((ULONG_PTR)pList + ulListSize));

                //
                // if not the last lc and rd, then need to move the following data
                // either up or down to account for changed res des data size
                //
                if (LogConfTag != pReqList->AlternativeLists - 1  ||
                    ulCount != pReq->Count - 1) {

                    pNext = (LPBYTE)((LPBYTE)pReqDes + ulOldSize);
                    ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);

                    pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                    if (pTemp == NULL) {
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    memcpy(pTemp, pNext, ulSize);
                    memcpy((LPBYTE)((LPBYTE)pReqDes + ulNewSize), pTemp, ulSize);
                }
            }

            //
            // write out modified data
            //
            Status = ResDesToNtRequirements(ResourceData, NewResourceID, ResourceLen,
                                            pReqDes, &ulNewCount, ResourceTag, ulFlags);

            if (Status == CR_SUCCESS) {
                //
                // update the requirements header (changes will be zero if CS)
                //
                pReq->Count += ulNewCount - ulOldCount;
                pReqList->ListSize = ulListSize + AddSize;
            }
        }

        if (Status == CR_SUCCESS) {

            //
            // Write out the new/updated log conf list to the registry
            //
            if (RegSetValueEx(hKey, szValueName, 0, RegDataType, pList,
                              ulListSize + AddSize) != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }

    return Status;

} // PNP_ModifyResDes



CONFIGRET
PNP_DetectResourceConflict(
   IN  handle_t   hBinding,
   IN  LPWSTR     pDeviceID,
   IN  RESOURCEID ResourceID,
   IN  LPBYTE     ResourceData,
   IN  ULONG      ResourceLen,
   OUT PBOOL      pbConflictDetected,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine detects
  conflicts with the specified res des.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ResourceID    Specifies the resource type.

    ResourceData  Specifies resource data (of ResourceID type).

    ResourceLen   Size of ResourceData in bytes.

    pbConflictDetected  Returns whether a conflict was detected.

    ulFlags       Not used, must be zero.

Return Value:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

Note:

    This routine is currently not implemented.  It initializes
    pbConflictDetected to FALSE, and returns CR_CALL_NOT_IMPLEMENTED.

 --*/

{
    UNREFERENCED_PARAMETER(hBinding);
    UNREFERENCED_PARAMETER(pDeviceID);
    UNREFERENCED_PARAMETER(ResourceID);
    UNREFERENCED_PARAMETER(ResourceData);
    UNREFERENCED_PARAMETER(ResourceLen);
    UNREFERENCED_PARAMETER(ulFlags);

    try {
        //
        // initialize output parameters
        //
        if (ARGUMENT_PRESENT(pbConflictDetected)) {
            *pbConflictDetected = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    return CR_CALL_NOT_IMPLEMENTED;

} // PNP_DetectResourceConflict



//------------------------------------------------------------------------
// Private Utility Functions
//------------------------------------------------------------------------

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    )
{

    ULONG   Index = 0;

    //
    // Input data is a Resource List
    //
    if (RegDataType == REG_RESOURCE_LIST) {

        PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
        PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

        if (ulTag >= pResList->Count) {
            return FALSE;
        }

        pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
        for (Index = 0; Index < ulTag; Index++) {
            pRes = AdvanceResourcePtr(pRes);      // next lc
        }

        *ppLogConf = (LPBYTE)pRes;
    }

    //
    // Input data is a Requirments List
    //
    else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

        PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
        PIO_RESOURCE_LIST              pReq = NULL;

        if (ulTag >= pReqList->AlternativeLists) {
            return FALSE;
        }

        pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]);    // first lc
        for (Index = 0; Index < ulTag; Index++) {
            pReq = AdvanceRequirementsPtr(pReq);           // next lc
        }

        *ppLogConf = (LPBYTE)pReq;

    } else {
        return FALSE;
    }

    return TRUE;

} // FindLogConf



BOOL
FindResDes(
    IN  LPBYTE     pList,
    IN  ULONG      RegDataType,
    IN  ULONG      ulLogConfTag,
    IN  ULONG      ulResTag,
    IN  RESOURCEID ResType,
    OUT LPBYTE     *ppRD,
    OUT LPBYTE     *ppLogConf,
    OUT PULONG     pulSubIndex      OPTIONAL
    )
{
    ULONG       ulIndex;

    //
    // Input data is a Resource List
    //
    if (RegDataType == REG_RESOURCE_LIST) {

        PCM_RESOURCE_LIST               pResList = (PCM_RESOURCE_LIST)pList;
        PCM_FULL_RESOURCE_DESCRIPTOR    pRes = NULL;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes = NULL;
        ULONG                           ulSubIndex;
        ULONG                           ulResTagOffset;

        if (ulLogConfTag != 0) {
            return FALSE;
        }

        if (pResList->Count == 0) {
            return FALSE;
        }

        //
        // The tag is just the res des index with the exception of a
        // DeviceSpecificData type which has a unique tag. This is
        // necessary because new res des's will always get placed at
        // the end unless there's already a device specific res des,
        // in which case new res des get added just before it.
        //
        if (ulResTag == RESDES_CS_TAG) {
            //
            // If there is a devicespecific res des, it will be the last.
            //
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)&pResList->List[0]; // first lc

            ulSubIndex = 0;

            for (ulIndex = 0; ulIndex < (pResList->Count - 1); ulIndex++) {
                ulSubIndex += pRes->PartialResourceList.Count;
                pRes = AdvanceResourcePtr(pRes);      // next lc
            }

            ulResTagOffset = pRes->PartialResourceList.Count - 1;
            pResDes = &pRes->PartialResourceList.PartialDescriptors[ulResTagOffset];

            if (pResDes->Type != CmResourceTypeDeviceSpecific) {
                return FALSE;
            }

            if (pulSubIndex) {
                *pulSubIndex = ulSubIndex + ulResTagOffset; // for res list, subindex = index
            }

        } else {

            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)&pResList->List[0]; // first lc

            ulResTagOffset = ulResTag;

            for (ulIndex = 0; ulIndex < pResList->Count; ulIndex++) {

                if (ulResTagOffset >= pRes->PartialResourceList.Count) {

                    ulResTagOffset -= pRes->PartialResourceList.Count;
                    pRes = AdvanceResourcePtr(pRes);      // next lc

                } else {

                    break;

                }
            }

            if (ulResTagOffset >= pRes->PartialResourceList.Count) {
                return FALSE;
            }

            if (pulSubIndex) {
                *pulSubIndex = ulResTag;  // for res list, subindex = index = tag
            }
            pResDes = &pRes->PartialResourceList.PartialDescriptors[ulResTagOffset];
        }

        //
        // Validate against res des type
        //
        if (pResDes->Type != NT_RES_TYPE(ResType)) {
            return FALSE;
        }

        *ppLogConf = (LPBYTE)pRes;
        *ppRD = (LPBYTE)pResDes;
    }

    //
    // Input data is a Requirments List
    //
    else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

        LPBYTE                          pLogConf = NULL;
        PIO_RESOURCE_LIST               pReq = NULL;
        PIO_RESOURCE_DESCRIPTOR         pReqDes = NULL;
        ULONG                           Index, i = 0, Count = 0;


        if (!FindLogConf(pList, &pLogConf, RegDataType, ulLogConfTag)) {
            return FALSE;
        }

        pReq = (PIO_RESOURCE_LIST)pLogConf;

        if (pReq == NULL || pReq->Count == 0 || ulResTag >= pReq->Count) {
            return FALSE;
        }

        //
        // Find the res des that matches the specified tag. In this case the
        // tag is the index based on res des groupings.
        //
        pReqDes = AdvanceRequirementsDescriptorPtr(&pReq->Descriptors[0], ulResTag, pReq->Count, &Count);

        if (pReqDes == NULL) {
            return FALSE;
        }

        if (pulSubIndex) {
            *pulSubIndex = Count;
        }

        //
        // Validate against res des type
        //
        if (pReqDes->Type != NT_RES_TYPE(ResType)) {
            return FALSE;
        }

        *ppLogConf = (LPBYTE)pReq;
        *ppRD = (LPBYTE)pReqDes;
    }

    return TRUE;

} // FindResDes



PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    )
{
    PIO_RESOURCE_DESCRIPTOR     pReqDes = NULL;
    ULONG                       i = 0, Count = 0;

    //
    // Advance requirements descriptor pointer by number passed
    // in ulIncrement parameter. Return the actual index to the
    // first range in this descriptor list and range count if
    // desired. This routine assumes there is at least one more
    // requirements descriptor in the list.
    //

    if (pReqDesStart == NULL) {
        return NULL;
    }

    try {

        pReqDes = pReqDesStart;

        for (i = 0; i < ulIncrement; i++) {
            //
            // skip to next "whole" res des
            //
            if (Count < ulRemainingRanges &&
                (pReqDes->Option == 0 ||
                pReqDes->Option == IO_RESOURCE_PREFERRED ||
                pReqDes->Option == IO_RESOURCE_DEFAULT)) {
                //
                // This is a valid Option, there may be one or more alternate
                // descriptor in the set associated with this descriptor,
                // treat the set as "one" descriptor. (loop through the
                // descriptors until I find another non-alternative descriptor)
                //
                pReqDes++;                  // next range
                Count++;

                while (Count < ulRemainingRanges &&
                       (pReqDes->Option == IO_RESOURCE_ALTERNATIVE ||
                       pReqDes->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_PREFERRED ||
                       pReqDes->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_DEFAULT)) {
                    pReqDes++;              // next range
                    Count++;
                }

                if (Count >= ulRemainingRanges) {
                    pReqDes = NULL;
                    Count = 0;
                    break;
                }
            } else {

                //
                // invalid Option value
                //
                pReqDes = NULL;
                Count = 0;
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        pReqDes = NULL;
        Count = 0;
    }

    if (pulRangeCount) {
        *pulRangeCount = Count;
    }

    return pReqDes;
} // AdvanceRequirementsDescriptorPtr



ULONG
RANGE_COUNT(
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr
    )
{
    ULONG ulRangeCount = 0;

    try {

        if (pReqDes == NULL) {
            goto Clean0;
        }

        ulRangeCount++;

        if (pReqDes->Option == 0 ||
            pReqDes->Option == IO_RESOURCE_PREFERRED ||
            pReqDes->Option == IO_RESOURCE_DEFAULT) {

            PIO_RESOURCE_DESCRIPTOR p = pReqDes;
            p++;

            while (((LPBYTE)p < pLastReqAddr)  &&
                   (p->Option == IO_RESOURCE_ALTERNATIVE ||
                    p->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_PREFERRED ||
                    p->Option == IO_RESOURCE_ALTERNATIVE + IO_RESOURCE_DEFAULT)) {

                ulRangeCount++;
                p++;            // skip to next res des
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ulRangeCount = 0;
    }

    return ulRangeCount;

} // RANGE_COUNT



ULONG
GetResDesSize(
    IN  ULONG   ResourceID,
    IN  ULONG   ulFlags
    )
{
    switch (ResourceID) {

        case ResType_Mem:
            return sizeof(MEM_RESOURCE);

        case ResType_IO:
            return sizeof(IO_RESOURCE);

        case ResType_DMA:
            return sizeof(DMA_RESOURCE);

        case ResType_IRQ:
            if (ulFlags & CM_RESDES_WIDTH_64) {
                return sizeof(IRQ_RESOURCE_64);
            } else {
                return sizeof(IRQ_RESOURCE_32);
            }

        case ResType_ClassSpecific:
            return sizeof(CS_RESOURCE);

        case ResType_DevicePrivate:
            return sizeof(DEVPRIVATE_RESOURCE);

        case ResType_BusNumber:
            return sizeof(BUSNUMBER_RESOURCE);

        case ResType_PcCardConfig:
            return sizeof(PCCARD_RESOURCE);

        case ResType_MfCardConfig:
            return sizeof(MFCARD_RESOURCE);

        default:
            return 0;
    }

} // GetResDesSize



ULONG
GetReqDesSize(
    IN ULONG                   ResourceID,
    IN PIO_RESOURCE_DESCRIPTOR pReqDes,
    IN LPBYTE                  pLastReqAddr,
    IN ULONG                   ulFlags
    )
{
    ULONG ulSize = 0;

    switch (ResourceID) {

        case ResType_Mem:
            ulSize = sizeof(MEM_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(MEM_RANGE);
            break;

        case ResType_IO:
            ulSize = sizeof(IO_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(IO_RANGE);
            break;

        case ResType_DMA:
            ulSize = sizeof(DMA_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(DMA_RANGE);
            break;

        case ResType_IRQ:
            if (ulFlags & CM_RESDES_WIDTH_64) {
                ulSize = sizeof(IRQ_RESOURCE_64);
            } else {
                ulSize = sizeof(IRQ_RESOURCE_32);
            }
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(IRQ_RANGE);
            break;

        case ResType_DevicePrivate:
            ulSize = sizeof(DEVPRIVATE_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(DEVPRIVATE_RANGE);
            break;

        case ResType_BusNumber:
            ulSize = sizeof(BUSNUMBER_RESOURCE);
            ulSize += (RANGE_COUNT(pReqDes, pLastReqAddr) - 1) * sizeof(BUSNUMBER_RANGE);
            break;

        case ResType_PcCardConfig:
            //
            // Non-arbitrated types don't have a range side in the user-mode structs
            //
            ulSize = sizeof(PCCARD_RESOURCE);
            break;

        case ResType_MfCardConfig:
            //
            // Non-arbitrated types don't have a range side in the user-mode structs
            //
            ulSize = sizeof(MFCARD_RESOURCE);
            break;

        default:
            break;
    }

    return ulSize;

} // GetReqDesSize



UCHAR
NT_RES_TYPE(
   IN RESOURCEID    ResourceID
   )
{
    ULONG resid = 0;

    if ((ResourceID < 0x06)) {

        //
        // First handle the divergent cases that can only be mapped
        // on a case by case basis. These are the values from zero
        // through five plus the special class specific case.
        //
        switch(ResourceID) {

            case ResType_None:
                return CmResourceTypeNull;
                break;

            case ResType_Mem:
                return CmResourceTypeMemory;

            case ResType_IO:
                return CmResourceTypePort;

            case ResType_DMA:
                return CmResourceTypeDma;

            case ResType_IRQ:
                return CmResourceTypeInterrupt;

            case ResType_DoNotUse:
                return (UCHAR)-1;

            DEFAULT_UNREACHABLE;
        }

    } else if (ResourceID == ResType_ClassSpecific) {

        //
        // ResType_ClassSpecific is another special case.
        //
        return CmResourceTypeDeviceSpecific;

    } else {

        //
        // For all other cases, rules apply as to how to map a kernel-mode
        // resource type id to a user-mode resource type id.
        //

        if (ResourceID >= 0x8080) {

            //
            // Anything larger this can't be mapped to the kernel-mode USHORT
            // values so it's invalid.
            //

            return (UCHAR)-1;

        } else if (!(ResourceID & ResType_Ignored_Bit)) {

            //
            // Values in the range [0x6,0x8000] use the same values
            // for ConfigMgr as for kernel-mode.
            //
            return (UCHAR)ResourceID;

        } else if (ResourceID & ResType_Ignored_Bit) {

            //
            // For the non arbitrated types (0x8000 bit set), do special
            // mapping to get the kernel-mode resource id type.
            //

            resid = ResourceID;
            resid &= ~(ResType_Ignored_Bit);        // clear um non-arbitrated bit
            resid |= CmResourceTypeNonArbitrated;   // set km non-arbitrated bit
            return (UCHAR)resid;

        } else {
            return (CHAR)-1;
        }
    }

} // NT_RES_TYPE



ULONG
CM_RES_TYPE(
   IN UCHAR    ResourceType
   )
{
    ULONG resid = 0;

    if ((ResourceType < 0x06)) {

        //
        // First handle the divergent cases that can only be mapped
        // on a case by case basis. These are the values from zero
        // through five plus the special class specific case.
        //

        switch(ResourceType) {

            case CmResourceTypeNull:
                return ResType_None;

            case CmResourceTypePort:
                return ResType_IO;

            case CmResourceTypeInterrupt:
                return ResType_IRQ;

            case CmResourceTypeMemory:
                return ResType_Mem;

            case CmResourceTypeDma:
                return ResType_DMA;

            case CmResourceTypeDeviceSpecific:
                return ResType_ClassSpecific;

            DEFAULT_UNREACHABLE;
        }

    } else {

        //
        // For all other cases, rules apply as to how to map a kernel-mode
        // resource type id to a user-mode resource type id.
        //

        if (!(ResourceType & CmResourceTypeNonArbitrated)) {

            //
            // Values in the range [0x6,0x80] use the same values
            // for ConfigMgr as for kernel-mode.
            //
            return (ULONG)ResourceType;

        } else if (ResourceType & CmResourceTypeNonArbitrated) {

            //
            // For the non arbitrated types (0x80 bit set), do special
            // mapping to get the user-mode resource id type.
            //

            resid = (ULONG)ResourceType;
            resid &= ~(CmResourceTypeNonArbitrated); // clear km non-arbitrated bit
            resid |= ResType_Ignored_Bit;            // set um non-arbitrated bit
            return resid;

        } else {
            return (ULONG)-1;
        }
    }

} // NT_RES_TYPE



CONFIGRET
ResDesToNtResource(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR  pResDes,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    )
{
    CONFIGRET Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(ulTag);

    //
    // fill in resource type specific info
    //
    switch (ResourceType) {

        case ResType_Mem:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MEM_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pMemData->MEM_Header.MD_Type != MType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy MEM_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeMemory;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pMemData->MEM_Header.MD_Flags, 0);
            pResDes->Flags            = MapToNtMemoryFlags(pMemData->MEM_Header.MD_Flags);

            pResDes->u.Memory.Start.HighPart = HIDWORD(pMemData->MEM_Header.MD_Alloc_Base);
            pResDes->u.Memory.Start.LowPart  = LODWORD(pMemData->MEM_Header.MD_Alloc_Base);

            pResDes->u.Memory.Length = (DWORD)(pMemData->MEM_Header.MD_Alloc_End -
                                               pMemData->MEM_Header.MD_Alloc_Base + 1);
            break;
        }


        case ResType_IO: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //
            // NOTE: alias info lost during this conversion process
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(IO_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pIoData->IO_Header.IOD_Type != IOType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy IO_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypePort;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pIoData->IO_Header.IOD_DesFlags, 0);
            pResDes->Flags            = MapToNtPortFlags(pIoData->IO_Header.IOD_DesFlags, 0);

            pResDes->u.Port.Start.HighPart = HIDWORD(pIoData->IO_Header.IOD_Alloc_Base);
            pResDes->u.Port.Start.LowPart  = LODWORD(pIoData->IO_Header.IOD_Alloc_Base);

            pResDes->u.Port.Length         = (DWORD)(pIoData->IO_Header.IOD_Alloc_End -
                                                     pIoData->IO_Header.IOD_Alloc_Base + 1);
            break;
        }


        case ResType_DMA: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DMA_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pDmaData->DMA_Header.DD_Type != DType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy DMA_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDma;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            //pResDes->ShareDisposition = MapToNtDisposition(pDmaData->DMA_Header.DD_Flags, 0);
            pResDes->Flags            = MapToNtDmaFlags(pDmaData->DMA_Header.DD_Flags);

            pResDes->u.Dma.Channel   = pDmaData->DMA_Header.DD_Alloc_Chan;
            pResDes->u.Dma.Port      = 0;
            pResDes->u.Dma.Reserved1 = 0;

            break;
        }


        case ResType_IRQ: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // copy IRQ_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
                //
                pResDes->Type             = CmResourceTypeInterrupt;
                pResDes->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Header.IRQD_Flags);
                //pResDes->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Header.IRQD_Flags, 1);
                pResDes->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Header.IRQD_Flags);

                pResDes->u.Interrupt.Level    = pIrqData->IRQ_Header.IRQD_Alloc_Num;
                pResDes->u.Interrupt.Vector   = pIrqData->IRQ_Header.IRQD_Alloc_Num;

#ifdef _WIN64
                pResDes->u.Interrupt.Affinity = pIrqData->IRQ_Header.IRQD_Affinity;
#else  // !_WIN64
                pResDes->u.Interrupt.Affinity = (ULONG)pIrqData->IRQ_Header.IRQD_Affinity;
#endif // !_WIN64

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }

                //
                // copy IRQ_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
                //
                pResDes->Type             = CmResourceTypeInterrupt;
                pResDes->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Header.IRQD_Flags);
                //pResDes->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Header.IRQD_Flags, 1);
                pResDes->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Header.IRQD_Flags);

                pResDes->u.Interrupt.Level    = pIrqData->IRQ_Header.IRQD_Alloc_Num;
                pResDes->u.Interrupt.Vector   = pIrqData->IRQ_Header.IRQD_Alloc_Num;

                pResDes->u.Interrupt.Affinity = pIrqData->IRQ_Header.IRQD_Affinity;
            }

            break;
        }

        case ResType_DevicePrivate: {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pPrvData->PRV_Header.PD_Type != PType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy DEVICEPRIVATE_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDevicePrivate;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pPrvData->PRV_Header.PD_Flags;

            pResDes->u.DevicePrivate.Data[0] = pPrvData->PRV_Header.PD_Data1;
            pResDes->u.DevicePrivate.Data[1] = pPrvData->PRV_Header.PD_Data2;
            pResDes->u.DevicePrivate.Data[2] = pPrvData->PRV_Header.PD_Data3;
            break;
        }


        case ResType_BusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pBusData->BusNumber_Header.BUSD_Type != BusNumberType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // copy BUSNUMBER_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeBusNumber;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pBusData->BusNumber_Header.BUSD_Flags;

            pResDes->u.BusNumber.Start = pBusData->BusNumber_Header.BUSD_Alloc_Base;
            pResDes->u.BusNumber.Length = pBusData->BusNumber_Header.BUSD_Alloc_End;
            pResDes->u.BusNumber.Reserved = 0;
            break;
        }


        case ResType_PcCardConfig: {

            //-------------------------------------------------------
            // PcCarConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)ResourceData;
            ULONG index;
            ULONG flags;
            ULONG waitstate[2];

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pResDes->u.DevicePrivate.Data[0] = 0;
            pResDes->u.DevicePrivate.Data[1] = 0;
            pResDes->u.DevicePrivate.Data[2] = 0;

            //
            // copy PCCARD_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            PCMRES_SET_DESCRIPTOR_TYPE(pResDes, DPTYPE_PCMCIA_CONFIGURATION);
            PCMRES_SET_CONFIG_INDEX(pResDes, pPcData->PcCard_Header.PCD_ConfigIndex);
            PCMRES_SET_MEMORY_CARDBASE(pResDes, 0, pPcData->PcCard_Header.PCD_MemoryCardBase1);
            PCMRES_SET_MEMORY_CARDBASE(pResDes, 1, pPcData->PcCard_Header.PCD_MemoryCardBase2);
            
            flags = pPcData->PcCard_Header.PCD_Flags;

            if (flags & (fPCD_MEM_16 | fPCD_MEM1_16)) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_16BIT_ACCESS);
            }                
            if (flags & (fPCD_MEM_16 | fPCD_MEM2_16)) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 1, PCMRESF_MEM_16BIT_ACCESS);
            }
                
            if (flags & fPCD_MEM1_A) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_ATTRIBUTE);
            }
            if (flags & fPCD_MEM2_A) {
                PCMRES_SET_MEMORY_FLAG(pResDes, 1, PCMRESF_MEM_ATTRIBUTE);
            }

            if (flags & fPCD_ATTRIBUTES_PER_WINDOW) {
                waitstate[0] = flags & mPCD_MEM1_WS;
                waitstate[1] = flags & mPCD_MEM2_WS;
            } else {
                waitstate[0] = waitstate[1] = flags & mPCD_MEM_WS;
            }
            
            for (index = 0; index < 2; index++) {
                switch (waitstate[index]) {

                case fPCD_MEM_WS_ONE:
                case fPCD_MEM1_WS_ONE:
                case fPCD_MEM2_WS_ONE:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_1);
                    break;
                  
                case fPCD_MEM_WS_TWO:
                case fPCD_MEM1_WS_TWO:
                case fPCD_MEM2_WS_TWO:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_2);
                    break;
                  
                case fPCD_MEM_WS_THREE:
                case fPCD_MEM1_WS_THREE:
                case fPCD_MEM2_WS_THREE:
                    PCMRES_SET_MEMORY_WAITSTATES(pResDes, index, PCMRESF_MEM_WAIT_3);
                    break;
                }
            }                
 
            if (flags & (fPCD_IO_16 | fPCD_IO1_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_16BIT_ACCESS);
            }                    
            if (flags & (fPCD_IO_16 | fPCD_IO2_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_16BIT_ACCESS);
            }
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO1_ZW_8)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_ZERO_WAIT_8);
            }                
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO2_ZW_8)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_ZERO_WAIT_8);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO1_SRC_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO2_SRC_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_WS_16 | fPCD_IO1_WS_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 0, PCMRESF_IO_WAIT_16);
            }                
            if (flags & (fPCD_IO_WS_16 | fPCD_IO2_WS_16)) {
                PCMRES_SET_IO_FLAG(pResDes, 1, PCMRESF_IO_WAIT_16);
            }

            break;
        }

        case ResType_MfCardConfig: {

            //-------------------------------------------------------
            // MfCardConfig Resource Type
            //-------------------------------------------------------

            PMFCARD_RESOURCE  pMfData = (PMFCARD_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MFCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pResDes->u.DevicePrivate.Data[0] = 0;
            pResDes->u.DevicePrivate.Data[1] = 0;
            pResDes->u.DevicePrivate.Data[2] = 0;

            //
            // copy MFCARD_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            PCMRES_SET_DESCRIPTOR_TYPE(pResDes, DPTYPE_PCMCIA_MF_CONFIGURATION);
            PCMRES_SET_CONFIG_OPTIONS(pResDes, pMfData->MfCard_Header.PMF_ConfigOptions);
            PCMRES_SET_PORT_RESOURCE_INDEX(pResDes, pMfData->MfCard_Header.PMF_IoResourceIndex);
            PCMRES_SET_CONFIG_REGISTER_BASE(pResDes, pMfData->MfCard_Header.PMF_ConfigRegisterBase);

            if ((pMfData->MfCard_Header.PMF_Flags & mPMF_AUDIO_ENABLE) == fPMF_AUDIO_ENABLE) {
                PCMRES_SET_AUDIO_ENABLE(pResDes);
            }
            break;
        }


        case ResType_ClassSpecific: {

            //-------------------------------------------------------
            // Class Specific Resource Type
            //-------------------------------------------------------

            PCS_RESOURCE   pCsData = (PCS_RESOURCE)ResourceData;
            LPBYTE         ptr = NULL;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(CS_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // copy CS_DES info to CM_PARTIAL_RESOURCE_DESCRIPTOR format
            //
            pResDes->Type             = CmResourceTypeDeviceSpecific;
            pResDes->ShareDisposition = CmResourceShareUndetermined;
            pResDes->Flags            = (USHORT)pCsData->CS_Header.CSD_Flags; // none defined

            pResDes->u.DeviceSpecificData.DataSize  = pCsData->CS_Header.CSD_LegacyDataSize +
                                                      sizeof(GUID) +
                                                      pCsData->CS_Header.CSD_SignatureLength;

            pResDes->u.DeviceSpecificData.Reserved1 = pCsData->CS_Header.CSD_LegacyDataSize;
            pResDes->u.DeviceSpecificData.Reserved2 = pCsData->CS_Header.CSD_SignatureLength;

            //
            // copy the legacy and class-specific signature data
            //
            ptr = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

            memcpy(ptr,
                   pCsData->CS_Header.CSD_Signature + pCsData->CS_Header.CSD_LegacyDataOffset,
                   pCsData->CS_Header.CSD_LegacyDataSize);      // copy legacy data first...

            ptr += pCsData->CS_Header.CSD_LegacyDataSize;

            memcpy(ptr,
                   pCsData->CS_Header.CSD_Signature,
                   pCsData->CS_Header.CSD_SignatureLength);     // then copy signature...

            ptr += pCsData->CS_Header.CSD_SignatureLength;

            memcpy(ptr,
                   &pCsData->CS_Header.CSD_ClassGuid,
                   sizeof(GUID));                               // then copy GUID
            break;
        }

        default:
            Status = CR_INVALID_RESOURCEID;
            break;
   }

   Clean0:

   return Status;

} // ResDesToNtResource



CONFIGRET
ResDesToNtRequirements(
    IN     PCVOID                           ResourceData,
    IN     RESOURCEID                       ResourceType,
    IN     ULONG                            ResourceLen,
    IN     PIO_RESOURCE_DESCRIPTOR          pReqDes,
    IN OUT PULONG                           pulResCount,
    IN     ULONG                            ulTag,
    IN     ULONG                            ulFlags
    )
{
    CONFIGRET               Status = CR_SUCCESS;
    ULONG                   i = 0;
    PIO_RESOURCE_DESCRIPTOR pCurrent = NULL;

    UNREFERENCED_PARAMETER(ulTag);

    //
    // fill in resource type specific info
    //
    switch (ResourceType) {

        case ResType_Mem:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MEM_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pMemData->MEM_Header.MD_Type != MType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pMemData->MEM_Header.MD_Count;

            //
            // copy MEM_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeMemory;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pMemData->MEM_Data[i].MR_Flags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags = MapToNtMemoryFlags(pMemData->MEM_Data[i].MR_Flags);

                pCurrent->u.Memory.Length    = pMemData->MEM_Data[i].MR_nBytes;
                pCurrent->u.Memory.Alignment = MapToNtAlignment(pMemData->MEM_Data[i].MR_Align);

                pCurrent->u.Memory.MinimumAddress.HighPart = HIDWORD(pMemData->MEM_Data[i].MR_Min);
                pCurrent->u.Memory.MinimumAddress.LowPart  = LODWORD(pMemData->MEM_Data[i].MR_Min);

                pCurrent->u.Memory.MaximumAddress.HighPart = HIDWORD(pMemData->MEM_Data[i].MR_Max);
                pCurrent->u.Memory.MaximumAddress.LowPart  = LODWORD(pMemData->MEM_Data[i].MR_Max);
            }
            break;
        }


        case ResType_IO: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(IO_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pIoData->IO_Header.IOD_Type != IOType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pIoData->IO_Header.IOD_Count;

            //
            // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypePort;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pIoData->IO_Data[i].IOR_RangeFlags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags  = MapToNtPortFlags(pIoData->IO_Data[i].IOR_RangeFlags,
                                                    (DWORD)pIoData->IO_Data[i].IOR_Alias);

                pCurrent->u.Port.Length = pIoData->IO_Data[i].IOR_nPorts;

                pCurrent->u.Port.Alignment = MapToNtAlignment(pIoData->IO_Data[i].IOR_Align);

                pCurrent->u.Port.MinimumAddress.HighPart = HIDWORD(pIoData->IO_Data[i].IOR_Min);
                pCurrent->u.Port.MinimumAddress.LowPart  = LODWORD(pIoData->IO_Data[i].IOR_Min);

                pCurrent->u.Port.MaximumAddress.HighPart = HIDWORD(pIoData->IO_Data[i].IOR_Max);
                pCurrent->u.Port.MaximumAddress.LowPart  = LODWORD(pIoData->IO_Data[i].IOR_Max);
            }
            break;
        }


        case ResType_DMA: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DMA_RESOURCE)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            if (pDmaData->DMA_Header.DD_Type != DType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pDmaData->DMA_Header.DD_Count;

            //
            // copy DMA_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeDma;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                //pCurrent->ShareDisposition = MapToNtDisposition(pDmaData->DMA_Data[i].DR_Flags, 0);
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;

                pCurrent->Flags = MapToNtDmaFlags(pDmaData->DMA_Data[i].DR_Flags);

                pCurrent->u.Dma.MinimumChannel = pDmaData->DMA_Data[i].DR_Min;
                pCurrent->u.Dma.MaximumChannel = pDmaData->DMA_Data[i].DR_Max;
            }
            break;
        }


        case ResType_IRQ: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }


                *pulResCount = pIrqData->IRQ_Header.IRQD_Count;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (i = 0, pCurrent = pReqDes;
                     i < *pulResCount;
                     i++, pCurrent++) {

                    if (i == 0) {
                        pCurrent->Option = 0;
                    } else {
                        pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                    }

                    pCurrent->Type   = CmResourceTypeInterrupt;
                    pCurrent->Spare1 = 0;
                    pCurrent->Spare2 = 0;

                    pCurrent->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Data[i].IRQR_Flags);
                    //pCurrent->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Data[i].IRQR_Flags, 1);
                    pCurrent->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Data[i].IRQR_Flags);

                    pCurrent->u.Interrupt.MinimumVector = pIrqData->IRQ_Data[i].IRQR_Min;
                    pCurrent->u.Interrupt.MaximumVector = pIrqData->IRQ_Data[i].IRQR_Max;
                }

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)ResourceData;

                //
                // validate resource data
                //
                if (ResourceLen < GetResDesSize(ResourceType, ulFlags)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                if (pIrqData->IRQ_Header.IRQD_Type != IRQType_Range) {
                    Status = CR_INVALID_RES_DES;
                    goto Clean0;
                }


                *pulResCount = pIrqData->IRQ_Header.IRQD_Count;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (i = 0, pCurrent = pReqDes;
                     i < *pulResCount;
                     i++, pCurrent++) {

                    if (i == 0) {
                        pCurrent->Option = 0;
                    } else {
                        pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                    }

                    pCurrent->Type   = CmResourceTypeInterrupt;
                    pCurrent->Spare1 = 0;
                    pCurrent->Spare2 = 0;

                    pCurrent->ShareDisposition = MapToNtIrqShare(pIrqData->IRQ_Data[i].IRQR_Flags);
                    //pCurrent->ShareDisposition = MapToNtDisposition(pIrqData->IRQ_Data[i].IRQR_Flags, 1);
                    pCurrent->Flags            = MapToNtIrqFlags(pIrqData->IRQ_Data[i].IRQR_Flags);

                    pCurrent->u.Interrupt.MinimumVector = pIrqData->IRQ_Data[i].IRQR_Min;
                    pCurrent->u.Interrupt.MaximumVector = pIrqData->IRQ_Data[i].IRQR_Max;
                }
            }
            break;
        }


        case ResType_DevicePrivate:    {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pPrvData->PRV_Header.PD_Type != PType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pPrvData->PRV_Header.PD_Count;

            //
            // copy DEVICEPRIVATE_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeDevicePrivate;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;
                pCurrent->Flags            = (USHORT)pPrvData->PRV_Header.PD_Flags;

                pCurrent->u.DevicePrivate.Data[0] = pPrvData->PRV_Data[i].PR_Data1;
                pCurrent->u.DevicePrivate.Data[1] = pPrvData->PRV_Data[i].PR_Data2;
                pCurrent->u.DevicePrivate.Data[2] = pPrvData->PRV_Data[i].PR_Data3;
            }
            break;
        }


        case ResType_BusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            if (pBusData->BusNumber_Header.BUSD_Type != BusNumberType_Range) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = pBusData->BusNumber_Header.BUSD_Count;

            //
            // copy BUSNUMBER_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < *pulResCount;
                 i++, pCurrent++) {

                if (i == 0) {
                    pCurrent->Option = 0;
                } else {
                    pCurrent->Option = IO_RESOURCE_ALTERNATIVE;
                }

                pCurrent->Type             = CmResourceTypeBusNumber;
                pCurrent->ShareDisposition = CmResourceShareUndetermined;
                pCurrent->Spare1           = 0;
                pCurrent->Spare2           = 0;
                pCurrent->Flags            = (USHORT)pBusData->BusNumber_Data[i].BUSR_Flags;

                pCurrent->u.BusNumber.Length       = pBusData->BusNumber_Data[i].BUSR_nBusNumbers;
                pCurrent->u.BusNumber.MinBusNumber = pBusData->BusNumber_Data[i].BUSR_Min;
                pCurrent->u.BusNumber.MaxBusNumber = pBusData->BusNumber_Data[i].BUSR_Max;
                pCurrent->u.BusNumber.Reserved     = 0;
            }
            break;
        }


        case ResType_PcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)ResourceData;
            ULONG index;
            ULONG flags;
            ULONG waitstate[2];

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = 1;

            //
            // copy PCCARD_DES info to IO_RESOURCE_DESCRIPTOR format
            //
            pReqDes->Option = 0;
            pReqDes->Type             = CmResourceTypeDevicePrivate;
            pReqDes->ShareDisposition = CmResourceShareUndetermined;
            pReqDes->Spare1           = 0;
            pReqDes->Spare2           = 0;
            pReqDes->Flags            = 0;

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pReqDes->u.DevicePrivate.Data[0] = 0;
            pReqDes->u.DevicePrivate.Data[1] = 0;
            pReqDes->u.DevicePrivate.Data[2] = 0;

            PCMRES_SET_DESCRIPTOR_TYPE(pReqDes, DPTYPE_PCMCIA_CONFIGURATION);
            PCMRES_SET_CONFIG_INDEX(pReqDes, pPcData->PcCard_Header.PCD_ConfigIndex);
            PCMRES_SET_MEMORY_CARDBASE(pReqDes, 0, pPcData->PcCard_Header.PCD_MemoryCardBase1);
            PCMRES_SET_MEMORY_CARDBASE(pReqDes, 1, pPcData->PcCard_Header.PCD_MemoryCardBase2);
            
            flags = pPcData->PcCard_Header.PCD_Flags;

            if (flags & (fPCD_MEM_16 | fPCD_MEM1_16)) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_16BIT_ACCESS);
            }                
            if (flags & (fPCD_MEM_16 | fPCD_MEM2_16)) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 1, PCMRESF_MEM_16BIT_ACCESS);
            }
                
            if (flags & fPCD_MEM1_A) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_ATTRIBUTE);
            }
            if (flags & fPCD_MEM2_A) {
                PCMRES_SET_MEMORY_FLAG(pReqDes, 1, PCMRESF_MEM_ATTRIBUTE);
            }

            if (flags & fPCD_ATTRIBUTES_PER_WINDOW) {
                waitstate[0] = flags & mPCD_MEM1_WS;
                waitstate[1] = flags & mPCD_MEM2_WS;
            } else {
                waitstate[0] = waitstate[1] = flags & mPCD_MEM_WS;
            }
            
            for (index = 0; index < 2; index++) {
                switch (waitstate[index]) {

                case fPCD_MEM_WS_ONE:
                case fPCD_MEM1_WS_ONE:
                case fPCD_MEM2_WS_ONE:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_1);
                    break;
                  
                case fPCD_MEM_WS_TWO:
                case fPCD_MEM1_WS_TWO:
                case fPCD_MEM2_WS_TWO:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_2);
                    break;
                  
                case fPCD_MEM_WS_THREE:
                case fPCD_MEM1_WS_THREE:
                case fPCD_MEM2_WS_THREE:
                    PCMRES_SET_MEMORY_WAITSTATES(pReqDes, index, PCMRESF_MEM_WAIT_3);
                    break;
                }
            }                
 
            if (flags & (fPCD_IO_16 | fPCD_IO1_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_16BIT_ACCESS);
            }                    
            if (flags & (fPCD_IO_16 | fPCD_IO2_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_16BIT_ACCESS);
            }
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO1_ZW_8)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_ZERO_WAIT_8);
            }                
            if (flags & (fPCD_IO_ZW_8 | fPCD_IO2_ZW_8)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_ZERO_WAIT_8);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO1_SRC_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_SRC_16 | fPCD_IO2_SRC_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_SOURCE_16);
            }
            if (flags & (fPCD_IO_WS_16 | fPCD_IO1_WS_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 0, PCMRESF_IO_WAIT_16);
            }                
            if (flags & (fPCD_IO_WS_16 | fPCD_IO2_WS_16)) {
                PCMRES_SET_IO_FLAG(pReqDes, 1, PCMRESF_IO_WAIT_16);
            }

            break;
        }

        case ResType_MfCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PMFCARD_RESOURCE  pMfData = (PMFCARD_RESOURCE)ResourceData;

            //
            // validate resource data
            //
            if (ResourceLen < sizeof(MFCARD_RESOURCE)) {
                Status = CR_INVALID_RES_DES;
                goto Clean0;
            }

            *pulResCount = 1;

            //
            // copy PCCARD_DES info to IO_RESOURCE_DESCRIPTOR format
            //
            pReqDes->Option = 0;
            pReqDes->Type             = CmResourceTypeDevicePrivate;
            pReqDes->ShareDisposition = CmResourceShareUndetermined;
            pReqDes->Spare1           = 0;
            pReqDes->Spare2           = 0;
            pReqDes->Flags            = 0;

            //
            // The following macros use bit manipulation, initialize data
            // fields first.
            //

            pReqDes->u.DevicePrivate.Data[0] = 0;
            pReqDes->u.DevicePrivate.Data[1] = 0;
            pReqDes->u.DevicePrivate.Data[2] = 0;

            PCMRES_SET_DESCRIPTOR_TYPE(pReqDes, DPTYPE_PCMCIA_MF_CONFIGURATION);
            PCMRES_SET_CONFIG_OPTIONS(pReqDes, pMfData->MfCard_Header.PMF_ConfigOptions);
            PCMRES_SET_PORT_RESOURCE_INDEX(pReqDes, pMfData->MfCard_Header.PMF_IoResourceIndex);
            PCMRES_SET_CONFIG_REGISTER_BASE(pReqDes, pMfData->MfCard_Header.PMF_ConfigRegisterBase);

            if ((pMfData->MfCard_Header.PMF_Flags & mPMF_AUDIO_ENABLE) == fPMF_AUDIO_ENABLE) {
                PCMRES_SET_AUDIO_ENABLE(pReqDes);
            }
            break;
        }

        default:
            Status = CR_INVALID_RESOURCEID;
            break;
   }

   Clean0:

   return Status;

} // ResDesToNtRequirements



CONFIGRET
NtResourceToResDes(
    IN     PCM_PARTIAL_RESOURCE_DESCRIPTOR pResDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    )
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize = 0;

    UNREFERENCED_PARAMETER(pLastAddr);

    //
    // fill in resource type specific info
    //
    switch (pResDes->Type) {

        case CmResourceTypeMemory:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(MEM_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pMemData->MEM_Header.MD_Count    = 0;
            pMemData->MEM_Header.MD_Type     = MType_Range;
            pMemData->MEM_Header.MD_Flags    = MapFromNtMemoryFlags(pResDes->Flags);
            //pMemData->MEM_Header.MD_Flags   |= MapFromNtDisposition(pResDes->ShareDisposition, 0);
            pMemData->MEM_Header.MD_Reserved = 0;

            if (pResDes->u.Memory.Length != 0) {

                pMemData->MEM_Header.MD_Alloc_Base = MAKEDWORDLONG(pResDes->u.Memory.Start.LowPart,
                                                                   pResDes->u.Memory.Start.HighPart);

                pMemData->MEM_Header.MD_Alloc_End  = pMemData->MEM_Header.MD_Alloc_Base +
                                                    (DWORDLONG)pResDes->u.Memory.Length - 1;
            } else {

                pMemData->MEM_Header.MD_Alloc_Base = 1;
                pMemData->MEM_Header.MD_Alloc_End  = 0;
            }
            break;
        }

        case CmResourceTypePort: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //
            // NOTE: alias info lost during this conversion process
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(IO_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IO_DES format
            //
            pIoData->IO_Header.IOD_Count     = 0;
            pIoData->IO_Header.IOD_Type      = IOType_Range;

            pIoData->IO_Header.IOD_DesFlags   = MapFromNtPortFlags(pResDes->Flags);
            //pIoData->IO_Header.IOD_DesFlags  |= MapFromNtDisposition(pResDes->ShareDisposition, 0);

            if (pResDes->u.Port.Length) {

                pIoData->IO_Header.IOD_Alloc_Base = MAKEDWORDLONG(pResDes->u.Port.Start.LowPart,
                                                                  pResDes->u.Port.Start.HighPart);

                pIoData->IO_Header.IOD_Alloc_End  = pIoData->IO_Header.IOD_Alloc_Base +
                                                    (DWORDLONG)pResDes->u.Port.Length - 1;
            } else {

                pIoData->IO_Header.IOD_Alloc_Base = 1;
                pIoData->IO_Header.IOD_Alloc_End  = 0;
            }
            break;
        }


        case CmResourceTypeDma: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(DMA_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DMA_DES format
            //
            pDmaData->DMA_Header.DD_Count      = 0;
            pDmaData->DMA_Header.DD_Type       = DType_Range;
            pDmaData->DMA_Header.DD_Flags      = MapFromNtDmaFlags(pResDes->Flags);
            //pDmaData->DMA_Header.DD_Flags     |= MapFromNtDisposition(pResDes->ShareDisposition, 0);
            pDmaData->DMA_Header.DD_Alloc_Chan = pResDes->u.Dma.Channel;

            break;
        }

        case CmResourceTypeInterrupt: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)Buffer;

                //
                // verify passed in buffer size
                //
                if (BufferLen < GetResDesSize(ResType_IRQ, ulFlags)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count  = 0;
                pIrqData->IRQ_Header.IRQD_Type   = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags  = MapFromNtIrqFlags(pResDes->Flags) |
                                                   MapFromNtIrqShare(pResDes->ShareDisposition);
                //pIrqData->IRQ_Header.IRQD_Flags |= MapFromNtDisposition(pResDes->ShareDisposition, 1);

                pIrqData->IRQ_Header.IRQD_Alloc_Num = pResDes->u.Interrupt.Level;

                pIrqData->IRQ_Header.IRQD_Affinity = pResDes->u.Interrupt.Affinity;
            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)Buffer;

                //
                // verify passed in buffer size
                //
                if (BufferLen < GetResDesSize(ResType_IRQ, ulFlags)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count  = 0;
                pIrqData->IRQ_Header.IRQD_Type   = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags  = MapFromNtIrqFlags(pResDes->Flags) |
                                                   MapFromNtIrqShare(pResDes->ShareDisposition);
                //pIrqData->IRQ_Header.IRQD_Flags |= MapFromNtDisposition(pResDes->ShareDisposition, 1);

                pIrqData->IRQ_Header.IRQD_Alloc_Num = pResDes->u.Interrupt.Level;

#ifdef _WIN64
                pIrqData->IRQ_Header.IRQD_Affinity = (ULONG)((pResDes->u.Interrupt.Affinity >> 32) |
                                                             pResDes->u.Interrupt.Affinity);
#else  // !_WIN64
                pIrqData->IRQ_Header.IRQD_Affinity = pResDes->u.Interrupt.Affinity;
#endif // !_WIN64
            }
            break;
        }

        case CmResourceTypeDevicePrivate: {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE   pPrvData = (PDEVPRIVATE_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(DEVPRIVATE_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DEVICEPRIVATE_DES format
            //
            pPrvData->PRV_Header.PD_Count = 0;
            pPrvData->PRV_Header.PD_Type  = PType_Range;

            pPrvData->PRV_Header.PD_Data1 = pResDes->u.DevicePrivate.Data[0];
            pPrvData->PRV_Header.PD_Data2 = pResDes->u.DevicePrivate.Data[1];
            pPrvData->PRV_Header.PD_Data3 = pResDes->u.DevicePrivate.Data[2];

            pPrvData->PRV_Header.PD_Flags = pResDes->Flags;
            break;
        }


        case CmResourceTypeBusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE   pBusData = (PBUSNUMBER_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(BUSNUMBER_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to BUSNUMBER_DES format
            //
            pBusData->BusNumber_Header.BUSD_Count = 0;
            pBusData->BusNumber_Header.BUSD_Type  = BusNumberType_Range;
            pBusData->BusNumber_Header.BUSD_Flags = pResDes->Flags;
            pBusData->BusNumber_Header.BUSD_Alloc_Base = pResDes->u.BusNumber.Start;
            pBusData->BusNumber_Header.BUSD_Alloc_End = pResDes->u.BusNumber.Start +
                                                        pResDes->u.BusNumber.Length - 1;
            break;
        }

        case CmResourceTypePcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE   pPcData = (PPCCARD_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            if (BufferLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to PCCARD_DES format
            //
            pPcData->PcCard_Header.PCD_Reserved[0] = 0;
            pPcData->PcCard_Header.PCD_Reserved[1] = 0;
            pPcData->PcCard_Header.PCD_Reserved[2] = 0;
            pPcData->PcCard_Header.PCD_ConfigIndex = PCMRES_GET_CONFIG_INDEX(pResDes);
            pPcData->PcCard_Header.PCD_MemoryCardBase1 = PCMRES_GET_MEMORY_CARDBASE(pResDes, 0);
            pPcData->PcCard_Header.PCD_MemoryCardBase2 = PCMRES_GET_MEMORY_CARDBASE(pResDes, 1);

            if (PCMRES_GET_IO_FLAG(pResDes, 0, PCMRESF_IO_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_8;
            }
            if (PCMRES_GET_MEMORY_FLAG(pResDes, 0, PCMRESF_MEM_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_8;
            }
            break;
        }


        case CmResourceTypeDeviceSpecific: {

            //-------------------------------------------------------
            // Class Specific Resource Type
            //-------------------------------------------------------

            PCS_RESOURCE   pCsData = (PCS_RESOURCE)Buffer;
            LPBYTE         ptr1 = NULL, ptr2 = NULL;
            ULONG          ulRequiredSize = sizeof(CS_RESOURCE);

            //
            // the Reserved fields should not exceed DataSize. if so, they
            // may have been incorrectly initialized, so set them 0.
            // we expect DataSize to be correct in all cases.
            //
            if (pResDes->u.DeviceSpecificData.Reserved1 > pResDes->u.DeviceSpecificData.DataSize) {
                pResDes->u.DeviceSpecificData.Reserved1 = 0;
            }
            if (pResDes->u.DeviceSpecificData.Reserved2 > pResDes->u.DeviceSpecificData.DataSize) {
                pResDes->u.DeviceSpecificData.Reserved2 = 0;
            }

            //
            // verify passed in buffer size
            //
            if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                //
                // there is no legacy data and no class-specific data
                //
                ;
            } else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                //
                // add space for legacy data
                //
                ulRequiredSize += pResDes->u.DeviceSpecificData.DataSize - 1;
            } else {
                //
                // add space for legacy and signature data, as necessary
                //
                ulRequiredSize += pResDes->u.DeviceSpecificData.Reserved1 +
                                  pResDes->u.DeviceSpecificData.Reserved2 - 1;
            }

            if (BufferLen < ulRequiredSize) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to CS_DES format
            //
            pCsData->CS_Header.CSD_Flags = (DWORD)pResDes->Flags;  // none defined


            if (pResDes->u.DeviceSpecificData.DataSize == 0) {
                //
                // There is no legacy data and no class-specific data
                //
                pCsData->CS_Header.CSD_SignatureLength  = 0;
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   = 0;
                pCsData->CS_Header.CSD_Signature[0]     = 0x0;

                memset(&pCsData->CS_Header.CSD_ClassGuid, 0, sizeof(GUID));
            }

            else if (pResDes->u.DeviceSpecificData.Reserved2 == 0) {
                //
                // There is only legacy data
                //
                pCsData->CS_Header.CSD_SignatureLength  = 0;
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   =
                                    pResDes->u.DeviceSpecificData.DataSize;
                pCsData->CS_Header.CSD_Signature[0] = 0x0;

                memset(&pCsData->CS_Header.CSD_ClassGuid, 0, sizeof(GUID));

                ptr1 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(&pCsData->CS_Header.CSD_Signature, ptr1,
                       pResDes->u.DeviceSpecificData.DataSize);
            }

            else if (pResDes->u.DeviceSpecificData.Reserved1 == 0) {
                //
                // There is only class-specific data
                //
                pCsData->CS_Header.CSD_LegacyDataOffset = 0;
                pCsData->CS_Header.CSD_LegacyDataSize   = 0;

                pCsData->CS_Header.CSD_SignatureLength  =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                ptr1 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(pCsData->CS_Header.CSD_Signature, ptr1,
                       pResDes->u.DeviceSpecificData.Reserved2);

                ptr1 += pResDes->u.DeviceSpecificData.Reserved2;

                memcpy((LPBYTE)&pCsData->CS_Header.CSD_ClassGuid, ptr1, sizeof(GUID));
            }

            else {
                //
                // There is both legacy data and class-specific data
                //

                //
                // copy legacy data
                //
                pCsData->CS_Header.CSD_LegacyDataOffset =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                pCsData->CS_Header.CSD_LegacyDataSize   =
                                        pResDes->u.DeviceSpecificData.Reserved1;

                ptr1 = pCsData->CS_Header.CSD_Signature +
                       pCsData->CS_Header.CSD_LegacyDataOffset;

                ptr2 = (LPBYTE)((LPBYTE)pResDes + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                memcpy(ptr1, ptr2, pResDes->u.DeviceSpecificData.Reserved1);

                //
                // copy signature and class guid
                //
                pCsData->CS_Header.CSD_SignatureLength  =
                                        pResDes->u.DeviceSpecificData.Reserved2;

                ptr2 += pResDes->u.DeviceSpecificData.Reserved1;

                memcpy(pCsData->CS_Header.CSD_Signature, ptr2,
                       pResDes->u.DeviceSpecificData.Reserved2);

                ptr2 += pResDes->u.DeviceSpecificData.Reserved2;

                memcpy((LPBYTE)&pCsData->CS_Header.CSD_ClassGuid, ptr2, sizeof(GUID));
            }
            break;
        }

        default:
            break;
   }

   Clean0:

   return Status;

} // NtResourceToResDes



CONFIGRET
NtRequirementsToResDes(
    IN     PIO_RESOURCE_DESCRIPTOR         pReqDes,
    IN OUT LPBYTE                          Buffer,
    IN     ULONG                           BufferLen,
    IN     LPBYTE                          pLastAddr,
    IN     ULONG                           ulFlags
    )
{
    CONFIGRET               Status = CR_SUCCESS;
    ULONG                   ulSize = 0, count = 0, i = 0, ReqPartialCount = 0;
    PIO_RESOURCE_DESCRIPTOR pCurrent = NULL;

    //
    // fill in resource type specific info
    //
    switch (pReqDes->Type) {

        case CmResourceTypeMemory:    {

            //-------------------------------------------------------
            // Memory Resource Type
            //-------------------------------------------------------

            //
            // NOTE: pMemData->MEM_Header.MD_Reserved is not mapped
            //       pMemData->MEM_Data.MR_Reserved is not mapped
            //

            PMEM_RESOURCE  pMemData = (PMEM_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(MEM_RESOURCE) +
                            sizeof(MEM_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pMemData->MEM_Header.MD_Count      = ReqPartialCount;
            pMemData->MEM_Header.MD_Type       = MType_Range;
            pMemData->MEM_Header.MD_Flags      = 0;
            pMemData->MEM_Header.MD_Reserved   = 0;
            pMemData->MEM_Header.MD_Alloc_Base = 0;
            pMemData->MEM_Header.MD_Alloc_End  = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypeMemory) {
                    pMemData->MEM_Data[i].MR_Align    = MapFromNtAlignment(pCurrent->u.Memory.Alignment);
                    pMemData->MEM_Data[i].MR_nBytes   = pCurrent->u.Memory.Length;

                    pMemData->MEM_Data[i].MR_Min      = MAKEDWORDLONG(
                                                        pCurrent->u.Memory.MinimumAddress.LowPart,
                                                        pCurrent->u.Memory.MinimumAddress.HighPart);

                    pMemData->MEM_Data[i].MR_Max      = MAKEDWORDLONG(
                                                        pCurrent->u.Memory.MaximumAddress.LowPart,
                                                        pCurrent->u.Memory.MaximumAddress.HighPart);

                    pMemData->MEM_Data[i].MR_Flags    = MapFromNtMemoryFlags(pCurrent->Flags);
                    //pMemData->MEM_Data[i].MR_Flags   |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    pMemData->MEM_Data[i].MR_Reserved = 0;
                    i++;
                }
            }
            pMemData->MEM_Header.MD_Count = i;
            break;
        }

        case CmResourceTypePort: {

            //-------------------------------------------------------
            // IO Port Resource Type
            //-------------------------------------------------------

            PIO_RESOURCE   pIoData = (PIO_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(IO_RESOURCE) +
                            sizeof(IO_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IO_DES format
            //
            pIoData->IO_Header.IOD_Count        = ReqPartialCount;
            pIoData->IO_Header.IOD_Type         = IOType_Range;
            pIoData->IO_Header.IOD_Alloc_Base   = 0;
            pIoData->IO_Header.IOD_Alloc_End    = 0;
            pIoData->IO_Header.IOD_DesFlags     = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to IO_RANGE format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypePort) {
                    pIoData->IO_Data[i].IOR_Align       = MapFromNtAlignment(pCurrent->u.Port.Alignment);
                    pIoData->IO_Data[i].IOR_nPorts      = pCurrent->u.Port.Length;
                    pIoData->IO_Data[i].IOR_Min         = MAKEDWORDLONG(
                                                              pCurrent->u.Port.MinimumAddress.LowPart,
                                                              pCurrent->u.Port.MinimumAddress.HighPart);
                    pIoData->IO_Data[i].IOR_Max         = MAKEDWORDLONG(
                                                              pCurrent->u.Port.MaximumAddress.LowPart,
                                                              pCurrent->u.Port.MaximumAddress.HighPart);

                    pIoData->IO_Data[i].IOR_RangeFlags  = MapFromNtPortFlags(pCurrent->Flags);
                    //pIoData->IO_Data[i].IOR_RangeFlags |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    pIoData->IO_Data[i].IOR_Alias       = MapAliasFromNtPortFlags(pCurrent->Flags);
                    i++;
                }
            }
            pIoData->IO_Header.IOD_Count = i;
            break;
        }

        case CmResourceTypeDma: {

            //-------------------------------------------------------
            // DMA Resource Type
            //-------------------------------------------------------

            //
            // Note: u.Dma.Port is not mapped
            //       u.Dma.Reserved is not mapped
            //

            PDMA_RESOURCE  pDmaData = (PDMA_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(DMA_RESOURCE) +
                            sizeof(DMA_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to DMA_DES format
            //
            pDmaData->DMA_Header.DD_Count      = ReqPartialCount;
            pDmaData->DMA_Header.DD_Type       = DType_Range;
            pDmaData->DMA_Header.DD_Flags      = 0;
            pDmaData->DMA_Header.DD_Alloc_Chan = 0;

            //
            // copy DMA_RANGE info to IO_RESOURCE_DESCRIPTOR format
            //
            for (count = 0, i = 0, pCurrent = pReqDes;
                 count < ReqPartialCount;
                 count++, pCurrent++) {

                if (pCurrent->Type == CmResourceTypeDma) {
                    pDmaData->DMA_Data[i].DR_Min    = pCurrent->u.Dma.MinimumChannel;
                    pDmaData->DMA_Data[i].DR_Max    = pCurrent->u.Dma.MaximumChannel;
                    pDmaData->DMA_Data[i].DR_Flags  = MapFromNtDmaFlags(pCurrent->Flags);
                    //pDmaData->DMA_Data[i].DR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 0);
                    i++;
                }
            }
            pDmaData->DMA_Header.DD_Count = i;
            break;
        }

        case CmResourceTypeInterrupt: {

            //-------------------------------------------------------
            // IRQ Resource Type
            //-------------------------------------------------------

            if (ulFlags & CM_RESDES_WIDTH_64) {
                //
                // CM_RESDES_WIDTH_64
                //

                PIRQ_RESOURCE_64  pIrqData = (PIRQ_RESOURCE_64)Buffer;

                //
                // verify passed in buffer size
                //
                ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

                if (BufferLen < sizeof(IRQ_RESOURCE_64) +
                                sizeof(IRQ_RANGE) * (ReqPartialCount - 1)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count     = ReqPartialCount;
                pIrqData->IRQ_Header.IRQD_Type      = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags     = 0;
                pIrqData->IRQ_Header.IRQD_Alloc_Num = 0;
                pIrqData->IRQ_Header.IRQD_Affinity  = 0;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (count = 0, i = 0, pCurrent = pReqDes;
                     count < ReqPartialCount;
                     count++, pCurrent++) {

                    if (pCurrent->Type == CmResourceTypeInterrupt) {
                        pIrqData->IRQ_Data[i].IRQR_Min    = pCurrent->u.Interrupt.MinimumVector;
                        pIrqData->IRQ_Data[i].IRQR_Max    = pCurrent->u.Interrupt.MaximumVector;
                        pIrqData->IRQ_Data[i].IRQR_Flags  = MapFromNtIrqFlags(pCurrent->Flags) |
                                                            MapFromNtIrqShare(pCurrent->ShareDisposition);
                        //pIrqData->IRQ_Data[i].IRQR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 1);
                        i++;
                    }
                }
                pIrqData->IRQ_Header.IRQD_Count = i;

            } else {
                //
                // CM_RESDES_WIDTH_32
                //

                PIRQ_RESOURCE_32  pIrqData = (PIRQ_RESOURCE_32)Buffer;

                //
                // verify passed in buffer size
                //
                ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

                if (BufferLen < sizeof(IRQ_RESOURCE_32) +
                                sizeof(IRQ_RANGE) * (ReqPartialCount - 1)) {
                    Status = CR_BUFFER_SMALL;
                    goto Clean0;
                }

                //
                // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to IRQ_DES format
                //
                pIrqData->IRQ_Header.IRQD_Count     = ReqPartialCount;
                pIrqData->IRQ_Header.IRQD_Type      = IRQType_Range;
                pIrqData->IRQ_Header.IRQD_Flags     = 0;
                pIrqData->IRQ_Header.IRQD_Alloc_Num = 0;
                pIrqData->IRQ_Header.IRQD_Affinity  = 0;

                //
                // copy IO_RANGE info to IO_RESOURCE_DESCRIPTOR format
                //
                for (count = 0, i = 0, pCurrent = pReqDes;
                     count < ReqPartialCount;
                     count++, pCurrent++) {

                    if (pCurrent->Type == CmResourceTypeInterrupt) {
                        pIrqData->IRQ_Data[i].IRQR_Min    = pCurrent->u.Interrupt.MinimumVector;
                        pIrqData->IRQ_Data[i].IRQR_Max    = pCurrent->u.Interrupt.MaximumVector;
                        pIrqData->IRQ_Data[i].IRQR_Flags  = MapFromNtIrqFlags(pCurrent->Flags) |
                                                            MapFromNtIrqShare(pCurrent->ShareDisposition);
                        //pIrqData->IRQ_Data[i].IRQR_Flags |= MapFromNtDisposition(pCurrent->ShareDisposition, 1);
                        i++;
                    }
                }
                pIrqData->IRQ_Header.IRQD_Count = i;
            }
            break;
        }

        case CmResourceTypeDevicePrivate:    {

            //-------------------------------------------------------
            // Device Private Resource Type
            //-------------------------------------------------------

            PDEVPRIVATE_RESOURCE  pPrvData = (PDEVPRIVATE_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(DEVPRIVATE_RESOURCE) +
                            sizeof(DEVPRIVATE_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to MEM_DES format
            //
            pPrvData->PRV_Header.PD_Count = ReqPartialCount;
            pPrvData->PRV_Header.PD_Type  = PType_Range;
            pPrvData->PRV_Header.PD_Data1 = 0;
            pPrvData->PRV_Header.PD_Data2 = 0;
            pPrvData->PRV_Header.PD_Data3 = 0;
            pPrvData->PRV_Header.PD_Flags = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < ReqPartialCount;
                 i++, pCurrent++) {

                pPrvData->PRV_Data[i].PR_Data1 = pCurrent->u.DevicePrivate.Data[0];
                pPrvData->PRV_Data[i].PR_Data2 = pCurrent->u.DevicePrivate.Data[1];
                pPrvData->PRV_Data[i].PR_Data3 = pCurrent->u.DevicePrivate.Data[2];
            }
            break;
        }


        case CmResourceTypeBusNumber: {

            //-------------------------------------------------------
            // Bus Number Resource Type
            //-------------------------------------------------------

            PBUSNUMBER_RESOURCE  pBusData = (PBUSNUMBER_RESOURCE)Buffer;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(BUSNUMBER_RESOURCE) +
                            sizeof(BUSNUMBER_RANGE) * (ReqPartialCount - 1)) {

                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy CM_PARTIAL_RESOURCE_DESCRIPTOR info to BUSNUMBER_DES format
            //
            pBusData->BusNumber_Header.BUSD_Count      = ReqPartialCount;
            pBusData->BusNumber_Header.BUSD_Type       = BusNumberType_Range;
            pBusData->BusNumber_Header.BUSD_Flags      = 0;
            pBusData->BusNumber_Header.BUSD_Alloc_Base = 0;
            pBusData->BusNumber_Header.BUSD_Alloc_End  = 0;

            //
            // copy IO_RESOURCE_DESCRIPTOR info to MEM_RANGE format
            //
            for (i = 0, pCurrent = pReqDes;
                 i < ReqPartialCount;
                 i++, pCurrent++) {

                pBusData->BusNumber_Data[i].BUSR_Min         = pCurrent->u.BusNumber.MinBusNumber;
                pBusData->BusNumber_Data[i].BUSR_Max         = pCurrent->u.BusNumber.MaxBusNumber;
                pBusData->BusNumber_Data[i].BUSR_nBusNumbers = pCurrent->u.BusNumber.Length;
                pBusData->BusNumber_Data[i].BUSR_Flags       = pCurrent->Flags;
            }
            break;
        }


        case CmResourceTypePcCardConfig: {

            //-------------------------------------------------------
            // PcCardConfig Resource Type
            //-------------------------------------------------------

            PPCCARD_RESOURCE  pPcData = (PPCCARD_RESOURCE)Buffer;
            ULONG index;

            //
            // verify passed in buffer size
            //
            ReqPartialCount = RANGE_COUNT(pReqDes, pLastAddr);

            if (BufferLen < sizeof(PCCARD_RESOURCE)) {
                Status = CR_BUFFER_SMALL;
                goto Clean0;
            }

            //
            // copy IO_RESOURCE_DESCRIPTOR info to PCCARD_DES format
            //
            pPcData->PcCard_Header.PCD_Reserved[0] = 0;
            pPcData->PcCard_Header.PCD_Reserved[1] = 0;
            pPcData->PcCard_Header.PCD_Reserved[2] = 0;
            pPcData->PcCard_Header.PCD_ConfigIndex = PCMRES_GET_CONFIG_INDEX(pReqDes);
            pPcData->PcCard_Header.PCD_MemoryCardBase1 = PCMRES_GET_MEMORY_CARDBASE(pReqDes, 0);
            pPcData->PcCard_Header.PCD_MemoryCardBase2 = PCMRES_GET_MEMORY_CARDBASE(pReqDes, 1);

            if (PCMRES_GET_IO_FLAG(pReqDes, 0, PCMRESF_IO_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags = fPCD_IO_8;
            }

            if (PCMRES_GET_MEMORY_FLAG(pReqDes, 0, PCMRESF_MEM_16BIT_ACCESS)) {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_16;
            } else {
                pPcData->PcCard_Header.PCD_Flags |= fPCD_MEM_8;
            }            
            break;
        }

        default:
            break;
   }

   Clean0:

   return Status;

} // NtRequirementsToResDes



//-------------------------------------------------------------------
// Routines to map flags between ConfigMgr and NT types
//-------------------------------------------------------------------

USHORT MapToNtMemoryFlags(IN DWORD CmMemoryFlags)
{
   USHORT NtMemoryFlags = 0x0;

   if (((CmMemoryFlags & mMD_MemoryType) == fMD_ROM) &&
       ((CmMemoryFlags & mMD_Readable) == fMD_ReadAllowed)) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_READ_ONLY;
   }
   else if (((CmMemoryFlags & mMD_MemoryType) == fMD_RAM) &&
            ((CmMemoryFlags & mMD_Readable) == fMD_ReadDisallowed)) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_WRITE_ONLY;
   }
   else {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_READ_WRITE;
   }

   if ((CmMemoryFlags & mMD_32_24) == fMD_24) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_24;
   }

   if ((CmMemoryFlags & mMD_Prefetchable) == fMD_PrefetchAllowed) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
   }

   if ((CmMemoryFlags & mMD_CombinedWrite) == fMD_CombinedWriteAllowed) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_COMBINEDWRITE;
   }

   if ((CmMemoryFlags & mMD_Cacheable) == fMD_Cacheable) {
      NtMemoryFlags |= CM_RESOURCE_MEMORY_CACHEABLE;
   }

   return NtMemoryFlags;
}



DWORD MapFromNtMemoryFlags(IN USHORT NtMemoryFlags)
{
   DWORD CmMemoryFlags = 0x0;

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_READ_ONLY) {
      CmMemoryFlags |= (fMD_ReadAllowed | fMD_ROM);
   }
   else if (NtMemoryFlags & CM_RESOURCE_MEMORY_WRITE_ONLY) {
      CmMemoryFlags |= (fMD_ReadDisallowed | fMD_RAM);
   }
   else {
      CmMemoryFlags |= (fMD_ReadAllowed | fMD_RAM);
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
      CmMemoryFlags |= fMD_PrefetchAllowed;
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_COMBINEDWRITE) {
      CmMemoryFlags |= fMD_CombinedWriteAllowed;
   }

   if (NtMemoryFlags & CM_RESOURCE_MEMORY_CACHEABLE) {
      CmMemoryFlags |= fMD_Cacheable;
   }

   if (!(NtMemoryFlags & CM_RESOURCE_MEMORY_24)) {
       CmMemoryFlags |= fMD_32;
   }

   return CmMemoryFlags;
}



USHORT MapToNtPortFlags(IN DWORD CmPortFlags, IN DWORD CmAlias)
{
    USHORT NtFlags = 0;

    if ((CmPortFlags & fIOD_PortType) == fIOD_Memory) {
        NtFlags |= CM_RESOURCE_PORT_MEMORY;
    } else {
        NtFlags |= CM_RESOURCE_PORT_IO;
    }

    //
    // CmAlias uses the following rule:
    //
    // Positive Decode = 0xFF
    // 10-bit decode   = 0x0004 (2 ^ 2)
    // 12-bit decode   = 0x0010 (2 ^ 4)
    // 16-bit decode   = 0x0000 (2 ^ 8 = 0x0100, but since it's a byte, use 0)
    //
    // if CmAlias is zero, use flags to specify decode (new method)
    //

    if (CmAlias == 0) {
        //
        // use CM_RESOURCE_PORT_xxx related flags
        //
        // note that we need to mirror *ALL* flags from
        // CM_RESOURCE_PORT_xxxx to fIOD_xxxx
        // however bits need not be same
        // not doing this will cause at least resource conflicts to fail
        // see also MapFromNtPortFlags
        //
        if (CmPortFlags & fIOD_10_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_10_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_12_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_12_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_16_BIT_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_16_BIT_DECODE;
        }
        if (CmPortFlags & fIOD_POSITIVE_DECODE) {
            NtFlags |= CM_RESOURCE_PORT_POSITIVE_DECODE;
        }
    }
    else if (CmAlias == IO_ALIAS_POSITIVE_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_POSITIVE_DECODE;
    } else if (CmAlias == IO_ALIAS_10_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_10_BIT_DECODE;
    } else if (CmAlias == IO_ALIAS_12_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_12_BIT_DECODE;
    } else if (CmAlias == IO_ALIAS_16_BIT_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_16_BIT_DECODE;
    }
    //
    // these have no mirror in cmAlias, and can be combined
    //
    if (CmPortFlags & fIOD_PASSIVE_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_PASSIVE_DECODE;
    }
    if (CmPortFlags & fIOD_WINDOW_DECODE) {
        NtFlags |= CM_RESOURCE_PORT_WINDOW_DECODE;
    }

    return NtFlags;
}



DWORD MapFromNtPortFlags(IN USHORT NtPortFlags)
{
    DWORD Flags = 0;

    if ((NtPortFlags & (CM_RESOURCE_PORT_MEMORY|CM_RESOURCE_PORT_IO)) == CM_RESOURCE_PORT_MEMORY) {
        Flags |=fIOD_Memory;
    } else {
        Flags |=fIOD_IO;
    }

    //
    // note that we need to mirror *ALL* flags from
    // CM_RESOURCE_PORT_xxxx to fIOD_xxxx
    // however bits need not be same
    // not doing this will cause at least resource conflicts to fail
    // see also MapToNtPortFlags
    //
    if (NtPortFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        Flags |= fIOD_10_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        Flags |= fIOD_12_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_16_BIT_DECODE) {
        Flags |= fIOD_16_BIT_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        Flags |= fIOD_POSITIVE_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_PASSIVE_DECODE) {
        Flags |= fIOD_PASSIVE_DECODE;
    }
    if (NtPortFlags & CM_RESOURCE_PORT_WINDOW_DECODE) {
        Flags |= fIOD_WINDOW_DECODE;
    }
    return Flags;
}



DWORD MapAliasFromNtPortFlags(IN USHORT NtPortFlags)
{
    DWORD Alias = 0;
    if (NtPortFlags & CM_RESOURCE_PORT_10_BIT_DECODE) {
        Alias = IO_ALIAS_10_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_12_BIT_DECODE) {
        Alias = IO_ALIAS_12_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_16_BIT_DECODE) {
        Alias = IO_ALIAS_16_BIT_DECODE;
    } else if (NtPortFlags & CM_RESOURCE_PORT_POSITIVE_DECODE) {
        Alias = IO_ALIAS_POSITIVE_DECODE;
    }
    return Alias;
}



ULONG MapToNtAlignment(IN DWORDLONG CmPortAlign)
{
   return (ULONG)(~CmPortAlign + 1);
}



DWORDLONG MapFromNtAlignment(IN ULONG NtPortAlign)
{
   return (DWORDLONG)(~((DWORDLONG)NtPortAlign - 1));
}



USHORT MapToNtDmaFlags(IN DWORD CmDmaFlags)
{
    USHORT NtDmaFlags;

    if ((CmDmaFlags & mDD_Width) == fDD_DWORD) {
        NtDmaFlags = CM_RESOURCE_DMA_32;
    } else if ((CmDmaFlags & mDD_Width) == fDD_WORD) {
        NtDmaFlags = CM_RESOURCE_DMA_16;
    } else if ((CmDmaFlags & mDD_Width) == fDD_BYTE_AND_WORD) {
        NtDmaFlags = CM_RESOURCE_DMA_8_AND_16;
    } else {
        NtDmaFlags = CM_RESOURCE_DMA_8;   //default
    }

    if ((CmDmaFlags & mDD_BusMaster) == fDD_BusMaster) {
        NtDmaFlags |= CM_RESOURCE_DMA_BUS_MASTER;
    }

    if ((CmDmaFlags & mDD_Type) == fDD_TypeA) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_A;
    } else if ((CmDmaFlags & mDD_Type) == fDD_TypeB) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_B;
    } else if ((CmDmaFlags & mDD_Type) == fDD_TypeF) {
        NtDmaFlags |= CM_RESOURCE_DMA_TYPE_F;
    }

    return NtDmaFlags;
}



DWORD MapFromNtDmaFlags(IN USHORT NtDmaFlags)
{
    DWORD CmDmaFlags;

    if (NtDmaFlags & CM_RESOURCE_DMA_32) {
        CmDmaFlags = fDD_DWORD;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_8_AND_16) {
        CmDmaFlags = fDD_BYTE_AND_WORD;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_16) {
        CmDmaFlags = fDD_WORD;
    } else {
        CmDmaFlags = fDD_BYTE;
    }

    if (NtDmaFlags & CM_RESOURCE_DMA_BUS_MASTER) {
        CmDmaFlags |= fDD_BusMaster;
    }

    if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_A) {
        CmDmaFlags |= fDD_TypeA;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_B) {
        CmDmaFlags |= fDD_TypeB;
    } else if (NtDmaFlags & CM_RESOURCE_DMA_TYPE_F) {
        CmDmaFlags |= fDD_TypeF;
    }

    return CmDmaFlags;
}






USHORT MapToNtIrqFlags(IN DWORD CmIrqFlags)
{
   if ((CmIrqFlags & mIRQD_Edge_Level) == fIRQD_Level) {
      return CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
   } else {
      return CM_RESOURCE_INTERRUPT_LATCHED;
   }
}



DWORD MapFromNtIrqFlags(IN USHORT NtIrqFlags)
{
   if (NtIrqFlags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE) {
      return fIRQD_Level;
   } else {
      return fIRQD_Edge;
   }
}

#if 0
UCHAR MapToNtDisposition(IN DWORD CmFlags, IN BOOL bIrq)
{
    UCHAR disposition;
    DWORD flag = CmFlags & mD_ShareDisposition;

    if (flag == fD_ShareDeviceExclusive) {
        disposition = CmResourceShareDeviceExclusive;
    } else if (flag == fD_ShareDriverExclusive) {
        disposition = CmResourceShareDriverExclusive;
    } else if (flag == fD_ShareShared) {
        disposition = CmResourceShareShared;
    } else if (flag == fD_ShareUndetermined) {
        //
        // if undetermined, also check for the old irq specific
        // share flags
        //
        if ((CmFlags & mIRQD_Share) == fIRQD_Share) {
            disposition = CmResourceShareShared;
        } else {
            disposition = CmResourceShareUndetermined;
        }
    }

    return disposition;
}


DWORD MapFromNtDisposition(IN UCHAR NtDisposition, IN BOOL bIrq)
{
    DWORD flag = 0;

    if (NtDisposition == CmResourceShareUndetermined) {
        flag = fD_ShareUndetermined;
    } else if (NtDisposition == CmResourceShareDeviceExclusive) {
        flag = fD_ShareDeviceExclusive;
    } else if (NtDisposition == CmResourceShareDriverExclusive) {
        flag = fD_ShareDriverExclusive;
    } else if (NtDisposition == CmResourceShareShared) {
        flag = fD_ShareShared;
    }

    if (bIrq) {
        //
        // also set the irq specific shared/exclusive bit, this is for
        // backwards compatibility, new apps should look at the new bits.
        //
        if (flag == fD_ShareShared) {
            flag |= fIRQD_Share;
        } else {
            flag |= fIRQD_Exclusive;
        }
    }

    return flag;
}
#endif


UCHAR MapToNtIrqShare(IN DWORD CmIrqFlags)
{
   if ((CmIrqFlags & mIRQD_Share) == fIRQD_Exclusive) {
      return CmResourceShareDeviceExclusive;
   } else {
      return CmResourceShareShared;
   }
}

DWORD MapFromNtIrqShare(IN UCHAR NtIrqShare)
{
   if (NtIrqShare == CmResourceShareDeviceExclusive) {
      return fIRQD_Exclusive;
   }
   else if (NtIrqShare == CmResourceShareDriverExclusive) {
      return fIRQD_Exclusive;
   }
   else return fIRQD_Share;
}



#define CM_RESOURCE_BUSNUMBER_SUBALLOCATE_FIRST_VALUE   0x0001

#define mBUSD_SubAllocFirst             (0x1)   // Bitmask, whether SubAlloc first value allowed
#define fBUSD_SubAllocFirst_Allowed     (0x0)   // Suballoc from first value
#define fBUSD_SubAllocFirst_Disallowed  (0x1)   // Don't suballoc from first value
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rregprop.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    rregprop.c

Abstract:

    This module contains the server-side registry property routines.

         PNP_GetDeviceRegProp
         PNP_SetDeviceRegProp
         PNP_GetClassRegProp
         PNP_SetClassRegProp
         PNP_GetClassInstance
         PNP_CreateKey
         PNP_DeleteRegistryKey
         PNP_GetClassCount
         PNP_GetClassName
         PNP_DeleteClassKey
         PNP_GetInterfaceDeviceAlias
         PNP_GetInterfaceDeviceList
         PNP_GetInterfaceDeviceListSize
         PNP_RegisterDeviceClassAssociation
         PNP_UnregisterDeviceClassAssociation
         PNP_GetCustomDevProp

    This module contains the privately exported registry property routines.

         DeleteServicePlugPlayRegKeys

Author:

    Paula Tomlinson (paulat) 6-23-1995

Environment:

    User-mode only.

Revision History:

    23-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"
#include "accctrl.h"
#include "aclapi.h"


//
// private prototypes
//

LPWSTR
MapPropertyToString(
      ULONG ulProperty
      );

ULONG
MapPropertyToNtProperty(
      ULONG ulProperty
      );

HKEY
FindMostAppropriatePerHwIdSubkey(
    IN  HKEY    hDevKey,
    IN  REGSAM  samDesired,
    OUT LPWSTR  PerHwIdSubkeyName,
    OUT LPDWORD PerHwIdSubkeyLen
    );

//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghClassKey;     // Key to HKLM\CCC\System\Class - DO NOT MODIFY
extern HKEY ghPerHwIdKey;   // Key to HKLM\Software\Microsoft\Windows NT\CurrentVersion\PerHwIdStorage - DO NOT MODIFY


BYTE bDeviceReadPropertyFlags[] = {
    0,    // zero-index not used
    1,    // CM_DRP_DEVICEDESC
    1,    // CM_DRP_HARDWAREID
    1,    // CM_DRP_COMPATIBLEIDS
    0,    // CM_DRP_UNUSED0
    1,    // CM_DRP_SERVICE
    0,    // CM_DRP_UNUSED1
    0,    // CM_DRP_UNUSED2
    1,    // CM_DRP_CLASS
    1,    // CM_DRP_CLASSGUID
    1,    // CM_DRP_DRIVER
    1,    // CM_DRP_CONFIGFLAGS
    1,    // CM_DRP_MFG
    1,    // CM_DRP_FRIENDLYNAME
    1,    // CM_DRP_LOCATION_INFORMATION
    1,    // CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    1,    // CM_DRP_CAPABILITIES
    1,    // CM_DRP_UI_NUMBER
    1,    // CM_DRP_UPPERFILTERS
    1,    // CM_DRP_LOWERFILTERS
    1,    // CM_DRP_BUSTYPEGUID
    1,    // CM_DRP_LEGACYBUSTYPE
    1,    // CM_DRP_BUSNUMBER
    1,    // CM_DRP_ENUMERATOR_NAME
    1,    // CM_DRP_SECURITY
    0,    // CM_DRP_SECURITY_SDS - shouldn't get this far
    1,    // CM_DRP_DEVTYPE
    1,    // CM_DRP_EXCLUSIVE
    1,    // CM_DRP_CHARACTERISTICS
    1,    // CM_DRP_ADDRESS
    1,    // CM_DRP_UI_NUMBER_DESC_FORMAT
    1,    // CM_DRP_DEVICE_POWER_DATA
    1,    // CM_DRP_REMOVAL_POLICY
    1,    // CM_DRP_REMOVAL_POLICY_HW_DEFAULT
    1,    // CM_DRP_REMOVAL_POLICY_OVERRIDE
    1,    // CM_DRP_INSTALL_STATE
};

BYTE bDeviceWritePropertyFlags[] = {
    0,    // zero-index not used
    1,    // CM_DRP_DEVICEDESC
    1,    // CM_DRP_HARDWAREID
    1,    // CM_DRP_COMPATIBLEIDS
    0,    // CM_DRP_UNUSED0
    1,    // CM_DRP_SERVICE
    0,    // CM_DRP_UNUSED1
    0,    // CM_DRP_UNUSED2
    1,    // CM_DRP_CLASS
    1,    // CM_DRP_CLASSGUID
    1,    // CM_DRP_DRIVER
    1,    // CM_DRP_CONFIGFLAGS
    1,    // CM_DRP_MFG
    1,    // CM_DRP_FRIENDLYNAME
    1,    // CM_DRP_LOCATION_INFORMATION
    0,    // CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME
    0,    // CM_DRP_CAPABILITIES
    0,    // CM_DRP_UI_NUMBER
    1,    // CM_DRP_UPPERFILTERS
    1,    // CM_DRP_LOWERFILTERS
    0,    // CM_DRP_BUSTYPEGUID
    0,    // CM_DRP_LEGACYBUSTYPE
    0,    // CM_DRP_BUSNUMBER
    0,    // CM_DRP_ENUMERATOR_NAME
    1,    // CM_DRP_SECURITY
    0,    // CM_DRP_SECURITY_SDS - shouldn't get this far
    1,    // CM_DRP_DEVTYPE
    1,    // CM_DRP_EXCLUSIVE
    1,    // CM_DRP_CHARACTERISTICS
    0,    // CM_DRP_ADDRESS
    1,    // CM_DRP_UI_NUMBER_DESC_FORMAT
    0,    // CM_DRP_DEVICE_POWER_DATA
    0,    // CM_DRP_REMOVAL_POLICY
    0,    // CM_DRP_REMOVAL_POLICY_HW_DEFAULT
    1,    // CM_DRP_REMOVAL_POLICY_OVERRIDE
    0,    // CM_DRP_INSTALL_STATE
};

BYTE bClassReadPropertyFlags[] = {
    0,    // zero-index not used
    0,    // (CM_DRP_DEVICEDESC)
    0,    // (CM_DRP_HARDWAREID)
    0,    // (CM_DRP_COMPATIBLEIDS)
    0,    // (CM_DRP_UNUSED0)
    0,    // (CM_DRP_SERVICE)
    0,    // (CM_DRP_UNUSED1)
    0,    // (CM_DRP_UNUSED2)
    0,    // (CM_DRP_CLASS)
    0,    // (CM_DRP_CLASSGUID)
    0,    // (CM_DRP_DRIVER)
    0,    // (CM_DRP_CONFIGFLAGS)
    0,    // (CM_DRP_MFG)
    0,    // (CM_DRP_FRIENDLYNAME)
    0,    // (CM_DRP_LOCATION_INFORMATION)
    0,    // (CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME)
    0,    // (CM_DRP_CAPABILITIES)
    0,    // (CM_DRP_UI_NUMBER)
    0,    // (CM_DRP_UPPERFILTERS)
    0,    // (CM_DRP_LOWERFILTERS)
    0,    // (CM_DRP_BUSTYPEGUID)
    0,    // (CM_DRP_LEGACYBUSTYPE)
    0,    // (CM_DRP_BUSNUMBER)
    0,    // (CM_DRP_ENUMERATOR_NAME)
    1,    // CM_CRP_SECURITY
    0,    // CM_CRP_SECURITY_SDS - shouldn't get this far
    1,    // CM_CRP_DEVTYPE
    1,    // CM_CRP_EXCLUSIVE
    1,    // CM_CRP_CHARACTERISTICS
    0,    // (CM_DRP_ADDRESS)
    0,    // (CM_DRP_UI_NUMBER_DESC_FORMAT)
    0,    // (CM_DRP_DEVICE_POWER_DATA)
    0,    // (CM_DRP_REMOVAL_POLICY)
    0,    // (CM_DRP_REMOVAL_POLICY_HW_DEFAULT)
    0,    // (CM_DRP_REMOVAL_POLICY_OVERRIDE)
    0,    // (CM_DRP_INSTALL_STATE)
};

BYTE bClassWritePropertyFlags[] = {
    0,    // zero-index not used
    0,    // (CM_DRP_DEVICEDESC)
    0,    // (CM_DRP_HARDWAREID)
    0,    // (CM_DRP_COMPATIBLEIDS)
    0,    // (CM_DRP_UNUSED0)
    0,    // (CM_DRP_SERVICE)
    0,    // (CM_DRP_UNUSED1)
    0,    // (CM_DRP_UNUSED2)
    0,    // (CM_DRP_CLASS)
    0,    // (CM_DRP_CLASSGUID)
    0,    // (CM_DRP_DRIVER)
    0,    // (CM_DRP_CONFIGFLAGS)
    0,    // (CM_DRP_MFG)
    0,    // (CM_DRP_FRIENDLYNAME)
    0,    // (CM_DRP_LOCATION_INFORMATION)
    0,    // (CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME)
    0,    // (CM_DRP_CAPABILITIES)
    0,    // (CM_DRP_UI_NUMBER)
    0,    // (CM_DRP_UPPERFILTERS)
    0,    // (CM_DRP_LOWERFILTERS)
    0,    // (CM_DRP_BUSTYPEGUID)
    0,    // (CM_DRP_LEGACYBUSTYPE)
    0,    // (CM_DRP_BUSNUMBER)
    0,    // (CM_DRP_ENUMERATOR_NAME)
    1,    // CM_CRP_SECURITY
    0,    // CM_CRP_SECURITY_SDS - shouldn't get this far
    1,    // CM_CRP_DEVTYPE
    1,    // CM_CRP_EXCLUSIVE
    1,    // CM_CRP_CHARACTERISTICS
    0,    // (CM_DRP_ADDRESS)
    0,    // (CM_DRP_UI_NUMBER_DESC_FORMAT)
    0,    // (CM_DRP_DEVICE_POWER_DATA)
    0,    // (CM_DRP_REMOVAL_POLICY)
    0,    // (CM_DRP_REMOVAL_POLICY_HW_DEFAULT)
    0,    // (CM_DRP_REMOVAL_POLICY_OVERRIDE)
    0,    // (CM_DRP_INSTALL_STATE)
};



CONFIGRET
PNP_GetDeviceRegProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  pDeviceID,
    IN     ULONG    ulProperty,
    OUT    PULONG   pulRegDataType,
    OUT    LPBYTE   Buffer,
    IN OUT PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be read from.

   ulProperty        ID specifying which property (the registry value)
                     to get.

   pulRegDataType    Supplies the address of a variable that will receive
                     the registry data type for this property (i.e., the REG_*
                     constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulSize = 0;
    HKEY        hKey = NULL;
    LPWSTR      pPropertyName;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_PROPERTY_DATA ControlData;
    LPCWSTR     pSeparatorChar;
    ULONG       bufferLength, guidType;
    WCHAR       szClassGuid[GUID_STRING_LEN];
    GUID        guid;
    PWCHAR      unicodeIDs;

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);
        *pulTransferLen = 0;

        //
        // consistancy checks
        //
        ASSERT(ARRAY_SIZE(bDeviceReadPropertyFlags) == (CM_DRP_MAX+1));
        ASSERT(sizeof(bDeviceReadPropertyFlags) == sizeof(bDeviceWritePropertyFlags));
        ASSERT(sizeof(bDeviceReadPropertyFlags) == sizeof(bClassReadPropertyFlags));

        //
        // validate property is readable
        //
        if (ulProperty > CM_DRP_MAX || !bDeviceReadPropertyFlags[ulProperty]) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        switch (ulProperty) {
        //
        // for some fields, we need to ask from kernel-mode
        //
        case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:

            //
            // This property has special checking in kernel-mode to make
            // sure the supplied buffer length is even so round it down.
            //

            *pulLength &= ~1;
            // fall through

        case CM_DRP_BUSTYPEGUID:
        case CM_DRP_LEGACYBUSTYPE:
        case CM_DRP_BUSNUMBER:
        case CM_DRP_ADDRESS:
        case CM_DRP_DEVICE_POWER_DATA:
        case CM_DRP_REMOVAL_POLICY:
        case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        case CM_DRP_INSTALL_STATE:

            if (ulProperty == CM_DRP_DEVICE_POWER_DATA ||
                ulProperty == CM_DRP_BUSTYPEGUID) {

                *pulRegDataType = REG_BINARY;

            } else if (ulProperty == CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME) {

                *pulRegDataType = REG_SZ;

            } else {
                //
                // CM_DRP_LEGACYBUSTYPE, CM_DRP_BUSNUMBER, CM_DRP_ADDRESS,
                // removal policy properties, and install state are all DWORDs
                //
                *pulRegDataType = REG_DWORD;
            }

            //
            // For these properties, we zero out unfilled space. This ensures
            // deterministic downlevel behavior if we expand any returned
            // structures in a later release.
            //
            bufferLength = *pulLength;

            //
            // Fill in a control structure for the device list info.
            //

            memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_PROPERTY_DATA));
            RtlInitUnicodeString(&ControlData.DeviceInstance, pDeviceID);
            ControlData.PropertyType = MapPropertyToNtProperty(ulProperty);
            ControlData.Buffer = Buffer;
            ControlData.BufferSize = bufferLength;

            //
            // Call kernel-mode to get the device property.
            //

            ntStatus = NtPlugPlayControl(PlugPlayControlProperty,
                                         &ControlData,
                                         sizeof(ControlData));
            if (NT_SUCCESS(ntStatus)) {

                ASSERT(bufferLength >= ControlData.BufferSize);
                if (bufferLength > ControlData.BufferSize) {

                    RtlZeroMemory(
                        Buffer + ControlData.BufferSize,
                        bufferLength - ControlData.BufferSize
                        );
                }

                *pulLength = ControlData.BufferSize;      // size in bytes
                *pulTransferLen = bufferLength; // size in bytes

            } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

                *pulLength = ControlData.BufferSize;
                *pulTransferLen = 0;
                Status = CR_BUFFER_SMALL;
            } else {
                *pulLength = 0;
                *pulTransferLen = 0;
                Status = MapNtStatusToCmError(ntStatus);
            }
            break;

        case CM_DRP_ENUMERATOR_NAME:

            *pulRegDataType = REG_SZ;

            pSeparatorChar = wcschr(pDeviceID, L'\\');
            ASSERT(pSeparatorChar);
            if (!pSeparatorChar) {
                Status=CR_INVALID_DATA;
            } else {
                ulSize = (ULONG)((PBYTE)pSeparatorChar - (PBYTE)pDeviceID) + sizeof(WCHAR);

                //
                // Fill in the caller's buffer, if it's large enough
                //
                if (*pulLength >= ulSize) {
                    lstrcpyn((LPWSTR)Buffer, pDeviceID, ulSize / sizeof(WCHAR));
                    *pulTransferLen = ulSize;
                } else {
                    *pulTransferLen = 0;    // no output data to marshal
                    Status = CR_BUFFER_SMALL;
                }
                *pulLength = ulSize;
            }
            break;

        default:
            //
            // for all the other fields, just get them from the registry
            // open a key to the specified device id
            //
            if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ,
                                &hKey) != ERROR_SUCCESS) {

                hKey = NULL;            // ensure hKey stays NULL so we don't
                                        // erroneously try to close it.
                *pulLength = 0;         // no size info for caller
                Status = CR_INVALID_DEVINST;
                goto Clean0;
            }
            //
            // retrieve the string form of the property
            //
            pPropertyName = MapPropertyToString(ulProperty);
            if (pPropertyName) {
                //
                // retrieve property setting
                //
                if (*pulLength == 0) {
                    //
                    // if length of buffer passed in is zero, just looking
                    // for how big a buffer is needed to read the property
                    //
                    if (RegQueryValueEx(hKey, pPropertyName, NULL, pulRegDataType,
                                        NULL, pulLength) != ERROR_SUCCESS) {

                        *pulLength = 0;
                        Status = CR_NO_SUCH_VALUE;
                        goto Clean0;
                    }
                    Status = CR_BUFFER_SMALL;  // According to spec
                } else {
                    //
                    // retrieve the real property value, not just the size
                    //
                    RegStatus = RegQueryValueEx(hKey, pPropertyName, NULL,
                                                pulRegDataType, Buffer, pulLength);

                    if (RegStatus != ERROR_SUCCESS) {

                        if (RegStatus == ERROR_MORE_DATA) {

                            Status = CR_BUFFER_SMALL;
                            goto Clean0;
                        } else {

                            *pulLength = 0;         // no size info for caller
                            Status = CR_NO_SUCH_VALUE;
                            goto Clean0;
                        }
                    }
                }
            } else {

                Status = CR_NO_SUCH_VALUE;
                goto Clean0;
            }
        }

    Clean0:
        //
        // Data only needs to be transferred on CR_SUCCESS.
        //
        if (Status == CR_SUCCESS) {
            *pulTransferLen = *pulLength;
        } else if (ARGUMENT_PRESENT(pulTransferLen)) {
            *pulTransferLen = 0;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetDeviceRegProp



CONFIGRET
PNP_SetDeviceRegProp(
    IN handle_t   hBinding,
    IN LPCWSTR    pDeviceID,
    IN ULONG      ulProperty,
    IN ULONG      ulDataType,
    IN LPBYTE     Buffer,
    IN ULONG      ulLength,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Set_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be written to.

   ulProperty        ID specifying which property (the registry value)
                     to set.

   ulDataType        Supplies the registry data type for the specified
                     property (i.e., REG_SZ, etc).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    LPWSTR      pPropertyName, p;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    GUID        guid;
    ULONG       drvInst;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // consistancy checks
        //
        ASSERT(ARRAY_SIZE(bDeviceWritePropertyFlags) == (CM_DRP_MAX+1));
        ASSERT(sizeof(bDeviceWritePropertyFlags) == sizeof(bDeviceReadPropertyFlags));
        ASSERT(sizeof(bDeviceWritePropertyFlags) == sizeof(bClassWritePropertyFlags));

        //
        // validate property is readable
        //
        if (ulProperty > CM_DRP_MAX || !bDeviceWritePropertyFlags[ulProperty]) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // Currently the only writable fields are in the registry
        // however do any validation of bits
        // this isn't foolproof but can catch some common errors
        //

        switch(ulProperty) {
            case CM_DRP_CONFIGFLAGS: {

                DWORD flags = 0;
                ULONG ulStatus = 0;
                ULONG ulProblem = 0;

                //
                // DWORD value
                // try to catch setting CSCONFIGFLAG_DISABLED on a non-disableable device
                // although we should have validated the size stuff elsewhere, it was at
                // client-side so double-check here
                //
                if (ulDataType != REG_DWORD || ulLength != sizeof(DWORD) || Buffer == NULL) {
                    Status = CR_INVALID_DATA;
                    goto Clean0;
                }
                flags = *(DWORD*)Buffer;
                if(flags & CONFIGFLAG_DISABLED) {
                    //
                    // we're interested in checking this decision to disable device
                    //

                    if (IsRootDeviceID(pDeviceID)) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "UMPNPMGR: Cannot set CONFIGFLAG_DISABLED for root device - did caller try to disable device first?\n"));

                        Status = CR_NOT_DISABLEABLE;
                        goto Clean0;
                    }

                    if((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem)==CR_SUCCESS)
                        && !(ulStatus & DN_DISABLEABLE)) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS,
                                   "UMPNPMGR: Cannot set CONFIGFLAG_DISABLED for non-disableable device - did caller try to disable device first?\n"));

                        Status = CR_NOT_DISABLEABLE;
                        goto Clean0;
                    }
                    //
                    // ok, looks like we can proceed to disable device
                    //
                }
                break;
            }

            default:
                //
                // No special handling on other properties
                //
                break;
        }

        //
        // open a key to the specified device id
        //
        if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ | KEY_WRITE,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);
        if (pPropertyName) {
            //
            // set (or delete) the property value
            //
            if (ulLength == 0) {

                RegStatus = RegDeleteValue(hKey, pPropertyName);
            }
            else {

                RegStatus = RegSetValueEx(hKey, pPropertyName, 0, ulDataType,
                                          Buffer, ulLength);
            }
            if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        } else {

            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // note that changes do not get applied until a reboot / query-remove-remove
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_SetDeviceRegProp



CONFIGRET
PNP_GetClassRegProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  ClassGuid,
    IN     ULONG    ulProperty,
    OUT    PULONG   pulRegDataType  OPTIONAL,
    OUT    LPBYTE   Buffer,
    IN OUT PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle, not used.

   ClassGuid         Supplies a string containing the Class Guid
                     whose property will be read from (Get) or written
                     to (Set).

   ulProperty        ID specifying which property (the registry value)
                     to get or set.

   pulRegDataType    Optionally, supplies the address of a variable that
                     will receive the registry data type for this property
                     (i.e., the REG_* constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulSize = 0;
    HKEY        hKeyClass = NULL;
    HKEY        hKeyProps = NULL;
    LPWSTR      pPropertyName;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    LPCWSTR     pSeparatorChar;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);
        *pulTransferLen = 0;

        //
        // consistancy checks
        //
        ASSERT(ARRAY_SIZE(bClassReadPropertyFlags) == (CM_CRP_MAX+1));
        ASSERT(sizeof(bClassReadPropertyFlags) == sizeof(bClassWritePropertyFlags));
        ASSERT(sizeof(bClassReadPropertyFlags) == sizeof(bDeviceReadPropertyFlags));

        //
        // validate property is readable
        //
        if (ulProperty > CM_CRP_MAX || !bClassReadPropertyFlags[ulProperty]) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // open a key to the specified GUID - this should have already been created
        //
        if (RegOpenKeyEx(ghClassKey, ClassGuid, 0, KEY_READ,
                         &hKeyClass) != ERROR_SUCCESS) {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller

            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }
        //
        // open a key to parameters - if not created, there's no params
        //
        if (RegOpenKeyEx(hKeyClass, pszRegKeyProperties, 0, KEY_READ,
                         &hKeyProps) != ERROR_SUCCESS) {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller

            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);
        if (pPropertyName) {
            //
            // retrieve property setting
            //
            if (*pulLength == 0) {
                //
                // if length of buffer passed in is zero, just looking
                // for how big a buffer is needed to read the property
                //
                *pulTransferLen = 0;

                if (RegQueryValueEx(hKeyProps, pPropertyName, NULL, pulRegDataType,
                                    NULL, pulLength) != ERROR_SUCCESS) {
                    *pulLength = 0;
                    Status = CR_NO_SUCH_VALUE;
                    goto Clean0;
                }

                Status = CR_BUFFER_SMALL;  // According to spec
            } else {
                //
                // retrieve the real property value, not just the size
                //
                RegStatus = RegQueryValueEx(hKeyProps, pPropertyName, NULL,
                                            pulRegDataType, Buffer, pulLength);

                if (RegStatus != ERROR_SUCCESS) {

                    if (RegStatus == ERROR_MORE_DATA) {
                        *pulTransferLen = 0;    // no output data to marshal
                        Status = CR_BUFFER_SMALL;
                        goto Clean0;
                    }
                    else {
                        *pulTransferLen = 0;    // no output data to marshal
                        *pulLength = 0;         // no size info for caller
                        Status = CR_NO_SUCH_VALUE;
                        goto Clean0;
                    }
                }
                *pulTransferLen = *pulLength;
            }
        } else {

            *pulTransferLen = 0;    // no output data to marshal
            *pulLength = 0;         // no size info for caller
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyProps = hKeyProps;
        hKeyClass = hKeyClass;
    }

    if (hKeyProps != NULL) {
        RegCloseKey(hKeyProps);
    }

    if (hKeyClass != NULL) {
        RegCloseKey(hKeyClass);
    }

    return Status;

} // PNP_GetClassRegProp



CONFIGRET
PNP_SetClassRegProp(
    IN handle_t   hBinding,
    IN LPCWSTR    ClassGuid,
    IN ULONG      ulProperty,
    IN ULONG      ulDataType,
    IN LPBYTE     Buffer,
    IN ULONG      ulLength,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Set_DevNode_Registry_Property
  routine.

Arguments:

   hBinding          RPC binding handle.

   ClassGuid         Supplies a string containing the Class Guid
                     whose property will be read from (Get) or written
                     to (Set).

   ulProperty        ID specifying which property (the registry value)
                     to get or set.

   ulDataType        Supplies the registry data type for the specified
                     property (i.e., REG_SZ, etc).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  Can be NULL when simply retrieving
                     data size.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKeyClass = NULL;
    HKEY        hKeyProps = NULL;
    LPWSTR      pPropertyName;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    DWORD       dwError;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // consistancy checks
        //
        ASSERT(ARRAY_SIZE(bClassWritePropertyFlags) == (CM_CRP_MAX+1));
        ASSERT(sizeof(bClassWritePropertyFlags) == sizeof(bClassReadPropertyFlags));
        ASSERT(sizeof(bClassWritePropertyFlags) == sizeof(bDeviceWritePropertyFlags));
        //
        // validate property is readable
        //
        if (ulProperty > CM_CRP_MAX || !bDeviceWritePropertyFlags[ulProperty]) {
            Status = CR_INVALID_PROPERTY;
            goto Clean0;
        }

        //
        // Currently the only writable fields are in the registry
        //

        //
        // open a key to the specified GUID - this should have already been created
        //
        if (RegOpenKeyEx(ghClassKey, ClassGuid, 0, KEY_READ,
                         &hKeyClass) != ERROR_SUCCESS) {

            Status = CR_NO_SUCH_REGISTRY_KEY;
            goto Clean0;
        }
        //
        // open a key to parameters - if not created, we need to create it with priv permissions
        // this is harmless for a delete, since we "need" it anyway
        //
        if (RegOpenKeyEx(hKeyClass, pszRegKeyProperties, 0, KEY_ALL_ACCESS,
                         &hKeyProps) != ERROR_SUCCESS) {

            //
            // properties key doesn't exist
            // we need to create it with secure access (system-only access)
            // we don't expect to do this often
            //
            PSID                pSystemSid = NULL;
            PACL                pSystemAcl = NULL;
            SECURITY_DESCRIPTOR SecDesc;
            SECURITY_ATTRIBUTES SecAttrib;
            BOOL                bSuccess;
            SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
            EXPLICIT_ACCESS     ExplicitAccess;

            bSuccess = AllocateAndInitializeSid( &NtAuthority,
                                                 1, // one authority - SYSTEM
                                                 SECURITY_LOCAL_SYSTEM_RID, // access to system only
                                                 0, 0, 0, 0, 0, 0, 0,  // unused authority locations
                                                 &pSystemSid);

            if (bSuccess) {
                ExplicitAccess.grfAccessMode = SET_ACCESS;
                ExplicitAccess.grfInheritance = CONTAINER_INHERIT_ACE;
                ExplicitAccess.Trustee.pMultipleTrustee = NULL;
                ExplicitAccess.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
                ExplicitAccess.Trustee.TrusteeForm = TRUSTEE_IS_SID;
                ExplicitAccess.Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                ExplicitAccess.grfAccessPermissions = KEY_ALL_ACCESS;
                ExplicitAccess.Trustee.ptstrName = (LPTSTR)pSystemSid;

                dwError = SetEntriesInAcl( 1,
                                           &ExplicitAccess,
                                           NULL,
                                           &pSystemAcl );
                if (dwError != ERROR_SUCCESS) {
                    bSuccess = FALSE;
                }
            }

            if (bSuccess) {
                bSuccess = InitializeSecurityDescriptor( &SecDesc, SECURITY_DESCRIPTOR_REVISION );
            }
            if (bSuccess) {
                bSuccess = SetSecurityDescriptorDacl( &SecDesc,
                                                      TRUE,
                                                      pSystemAcl,
                                                      FALSE);
            }
            //
            // mostly a setup requirement, but good to have
            // effectively is a pruning point in the security tree
            // child keys inherit our permissions, but not our parents permissions
            //
            if (bSuccess) {
                if(!SetSecurityDescriptorControl(&SecDesc,
                                            SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED,
                                            SE_DACL_PROTECTED | SE_DACL_AUTO_INHERITED)) {
                    DWORD LocalErr = GetLastError();
                    //
                    // non fatal if this fails
                    //
                }
            }
            if (bSuccess) {
                bSuccess = IsValidSecurityDescriptor( &SecDesc );
            }

            if (bSuccess) {
                SecAttrib.nLength = sizeof(SecAttrib);
                SecAttrib.bInheritHandle = FALSE;
                SecAttrib.lpSecurityDescriptor = &SecDesc;

                if(RegCreateKeyEx(hKeyClass, pszRegKeyProperties, 0, NULL, REG_OPTION_NON_VOLATILE,
                         KEY_ALL_ACCESS, &SecAttrib, &hKeyProps, NULL) != ERROR_SUCCESS) {
                    bSuccess = FALSE;
                }
            }

            //
            // now cleanup
            //
            if (pSystemAcl) {
                LocalFree(pSystemAcl);
            }
            if (pSystemSid) {
                FreeSid(pSystemSid);
            }

            if (bSuccess == FALSE) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }
        //
        // retrieve the string form of the property
        //
        pPropertyName = MapPropertyToString(ulProperty);
        if (pPropertyName) {
            //
            // set (or delete) the property value
            //
            if (ulLength == 0) {

                RegStatus = RegDeleteValue(hKeyProps, pPropertyName);
            }
            else {
                RegStatus = RegSetValueEx(hKeyProps, pPropertyName, 0, ulDataType,
                                          Buffer, ulLength);
            }
            if (RegStatus != ERROR_SUCCESS) {

                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        } else {

            Status = CR_FAILURE;
            goto Clean0;
        }
        //
        // note that changes do not get applied until a reboot / query-remove-remove
        //

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyProps = hKeyProps;
        hKeyClass = hKeyClass;
    }

    if (hKeyProps != NULL) {
        RegCloseKey(hKeyProps);
    }

    if (hKeyClass != NULL) {
        RegCloseKey(hKeyClass);
    }

    return Status;

} // PNP_SetClassRegProp



CONFIGRET
PNP_GetClassInstance(
   IN  handle_t hBinding,
   IN  LPCWSTR  pDeviceID,
   OUT LPWSTR   pszClassInstance,
   IN  ULONG    ulLength
   )

/*++

Routine Description:

  This is the RPC private server entry point, it doesn't not directly
  map one-to-one to any CM routine.

Arguments:

   hBinding          RPC binding handle.

   pDeviceID         Supplies a string containing the device instance

   pszClassInstance  String to return the class instance in

   ulLength          Size of the pszClassInstance string in chars

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR.

--*/

{
    CONFIGRET   Status;
    WCHAR       szInstanceStr[MAX_PATH], szClassGuid[GUID_STRING_LEN];
    DWORD       disposition;
    ULONG       ulType, ulTransferLength, guidLength, ulInstance;
    HKEY        hClassKey = NULL, hInstanceKey = NULL;


    try {
        //
        // Validate parameters
        //
        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Get the class instance key name, if one exists.
        //
        ulTransferLength = ulLength;

        Status = PNP_GetDeviceRegProp(hBinding,
                                      pDeviceID,
                                      CM_DRP_DRIVER,
                                      &ulType,
                                      (LPBYTE)pszClassInstance,
                                      &ulTransferLength,
                                      &ulLength,
                                      0);
        if (Status == CR_SUCCESS) {
            //
            // Successfully retrieved class instance key name.
            //
            goto Clean0;
        }


        //
        // Create the class instance since one does not already exist.
        //

        //
        // Verify client privilege before creating any registry keys, because
        // we'll need it to set the driver devnode property anyways (but didn't
        // require it above to check for an existing value).  This is better for
        // synchronization than creating the key and deleting it later when we
        // fail to set the devnode property.
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Get the class GUID property for the key to create the instance under.
        //
        guidLength = sizeof(szClassGuid);
        ulTransferLength = guidLength;

        Status = PNP_GetDeviceRegProp(hBinding,
                                      pDeviceID,
                                      CM_DRP_CLASSGUID,
                                      &ulType,
                                      (LPBYTE)szClassGuid,
                                      &ulTransferLength,
                                      &guidLength,
                                      0);

        if (Status == CR_SUCCESS) {
            //
            // Open the class key.
            //
            if (RegOpenKeyEx(ghClassKey,
                             szClassGuid,
                             0,
                             KEY_READ | KEY_WRITE,
                             &hClassKey) == ERROR_SUCCESS) {

                for (ulInstance = 0; ulInstance < 9999; ulInstance++) {
                    //
                    // Find the first available class instance key.
                    //
                    wsprintf(szInstanceStr,
                             TEXT("%04u"),
                             ulInstance);

                    if (RegCreateKeyEx(hClassKey,
                                       szInstanceStr,
                                       0,
                                       NULL,
                                       REG_OPTION_NON_VOLATILE,
                                       KEY_ALL_ACCESS,
                                       NULL,
                                       &hInstanceKey,
                                       &disposition) == ERROR_SUCCESS) {

                        RegCloseKey(hInstanceKey);
                        hInstanceKey = NULL;

                        if (disposition == REG_CREATED_NEW_KEY) {
                            //
                            // Set the instance and return.
                            //
                            wsprintf(pszClassInstance,
                                     TEXT("%s\\%s"),
                                     szClassGuid,
                                     szInstanceStr);

                            ulLength = (lstrlen(pszClassInstance) + 1) * sizeof(WCHAR);

                            Status = PNP_SetDeviceRegProp(hBinding,
                                                          pDeviceID,
                                                          CM_DRP_DRIVER,
                                                          REG_SZ,
                                                          (LPBYTE)pszClassInstance,
                                                          ulLength,
                                                          0);
                            //
                            // If we failed to set the devnode property, delete
                            // the registry key we just created, or else we'll end
                            // up orphaning it.
                            //
                            if (Status != CR_SUCCESS) {
                                RegDeleteKey(hClassKey, szInstanceStr);
                            }

                            break;
                        }
                    }
                }

                if (ulInstance == 9999) {
                    Status = CR_FAILURE;
                }

                RegCloseKey(hClassKey);
                hClassKey = NULL;

            } else {
                //
                // Unable to open class key.
                //
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hClassKey = hClassKey;
        hInstanceKey = hInstanceKey;
    }

    if (hClassKey != NULL) {
        RegCloseKey(hClassKey);
    }

    if (hInstanceKey != NULL) {
        RegCloseKey(hInstanceKey);
    }

    return Status;

} // PNP_GetClassInstance



CONFIGRET
PNP_CreateKey(
    IN handle_t hBinding,
    IN LPCWSTR  pszDeviceID,
    IN REGSAM   samDesired,
    IN ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Open_DevNode_Key_Ex
  routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   samDesired        Not used.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_REGISTRY_ERROR, or
      CR_BUFFER_SMALL.

--*/

{
    CONFIGRET                  Status = CR_SUCCESS;
    LONG                       RegStatus = ERROR_SUCCESS;
    HKEY                       hKeyDevice = NULL, hKey = NULL;
    ULONG                      ulSize = 0, i = 0;
    BOOL                       bHasDacl, bStatus;
    SECURITY_DESCRIPTOR        NewSecDesc;
    ACL_SIZE_INFORMATION       AclSizeInfo;
    SID_IDENTIFIER_AUTHORITY   Authority = SECURITY_NT_AUTHORITY;
    PSECURITY_DESCRIPTOR       pSecDesc = NULL;
    PACL                       pDacl = NULL, pNewDacl = NULL;
    PSID                       pAdminSid = NULL;
    PACCESS_ALLOWED_ACE        pAce = NULL;

    UNREFERENCED_PARAMETER(samDesired);

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the specified device id
        //
        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ, &hKeyDevice);

        if (RegStatus != ERROR_SUCCESS) {

            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // create the key with security inherited from parent key. Note
        // that I'm not using passed in access mask, in order to set the
        // security later, it must be created with KEY_ALL_ACCESS.
        //
        RegStatus = RegCreateKeyEx( hKeyDevice, pszRegKeyDeviceParam, 0,
                                    NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                    NULL, &hKey, NULL);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //-------------------------------------------------------------
        // add admin-full privilege to the inherited security info
        //-------------------------------------------------------------
        //
        //
        // NOTE: we don't need to do this unless the key was newly created.  In
        // theory we only get here when the key doesn't already exist.  However
        // there is a remote chance of two threads getting here simultaneously.  If
        // this happens we would end up with two admin full control ACEs.
        //


        //
        // create the admin-full SID
        //
        if (!AllocateAndInitializeSid( &Authority, 2,
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0, 0, 0, 0, 0, 0,
                                       &pAdminSid)) {
            Status = CR_FAILURE;
            goto Clean0;
        }


        //
        // get the current security descriptor for the key
        //
        RegStatus = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       NULL, &ulSize);


        if (RegStatus != ERROR_INSUFFICIENT_BUFFER &&
            RegStatus != ERROR_SUCCESS) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        pSecDesc = HeapAlloc(ghPnPHeap, 0, ulSize);

        if (pSecDesc == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        RegStatus = RegGetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       pSecDesc, &ulSize);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // get the current DACL
        //
        if (!GetSecurityDescriptorDacl(pSecDesc, &bHasDacl, &pDacl, &bStatus)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // create a new absolute security descriptor and DACL
        //
        if (!InitializeSecurityDescriptor( &NewSecDesc,
                                           SECURITY_DESCRIPTOR_REVISION)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // calculate the size of the new DACL
        //
        if (bHasDacl) {
            if (!GetAclInformation( pDacl, &AclSizeInfo,
                                    sizeof(ACL_SIZE_INFORMATION),
                                    AclSizeInformation)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            ulSize = AclSizeInfo.AclBytesInUse;
        } else {
            ulSize = sizeof(ACL);
        }

        ulSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAdminSid) - sizeof(DWORD);

        //
        // create and initialize the new DACL
        //
        pNewDacl = HeapAlloc(ghPnPHeap, 0, ulSize);

        if (pNewDacl == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        if (!InitializeAcl(pNewDacl, ulSize, ACL_REVISION2)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // copy the current (original) DACL into this new one
        //
        if (bHasDacl) {

            for (i = 0; i < AclSizeInfo.AceCount; i++) {

                if (!GetAce(pDacl, i, (LPVOID *)&pAce)) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

                //
                // We need to skip copying any ACEs which refer to the Administrator
                // to ensure that our full control ACE is the one and only.
                //
                if ((pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE &&
                    pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE) ||
                    !EqualSid((PSID)&pAce->SidStart, pAdminSid)) {

                    if (!AddAce( pNewDacl, ACL_REVISION2, (DWORD)~0U, pAce,
                                pAce->Header.AceSize)) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }
                }
            }
        }

        //
        // and my new admin-full ace to this new DACL
        //
        if (!AddAccessAllowedAceEx( pNewDacl, ACL_REVISION2,
                                    CONTAINER_INHERIT_ACE, KEY_ALL_ACCESS,
                                    pAdminSid)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Set the new DACL in the absolute security descriptor
        //
        if (!SetSecurityDescriptorDacl(&NewSecDesc, TRUE, pNewDacl, FALSE)) {
            Status = CR_FAILURE;
            goto Clean0;
        }
        //
        // validate the new security descriptor
        //
        if (!IsValidSecurityDescriptor(&NewSecDesc)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // apply the new security back to the registry key
        //
        RegStatus = RegSetKeySecurity( hKey, DACL_SECURITY_INFORMATION,
                                       &NewSecDesc);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKeyDevice = hKeyDevice;
        hKey = hKey;
        pAdminSid = pAdminSid;
        pNewDacl = pNewDacl;
        pSecDesc = pSecDesc;
    }

    if (hKeyDevice != NULL) {
        RegCloseKey(hKeyDevice);
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pAdminSid != NULL) {
        FreeSid(pAdminSid);
    }

    if (pNewDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pNewDacl);
    }

    if (pSecDesc != NULL) {
        HeapFree(ghPnPHeap, 0, pSecDesc);
    }

    return Status;

} // PNP_CreateKey



CONFIGRET
PNP_DeleteRegistryKey(
      IN handle_t    hBinding,
      IN LPCWSTR     pszDeviceID,
      IN LPCWSTR     pszParentKey,
      IN LPCWSTR     pszChildKey,
      IN ULONG       ulFlags
      )
/*++

Routine Description:

  This is the RPC server entry point for the CM_Delete_DevNode_Key
  routine.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   pszParentKey      Supplies the parent registry path of the key to be
                     deleted.

   pszChildKey       Supplies the subkey to be deleted.

   ulFlags           If 0xFFFFFFFF then delete for all profiles


Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_DEVNODE,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_NO_SUCH_VALUE,
      CR_REGISTRY_ERROR.

--*/

{
    CONFIGRET   Status = ERROR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szProfile[MAX_PROFILE_ID_LEN];
    PWCHAR      pszRegStr = NULL, pszRegKey1 = NULL, pszRegKey2 = NULL;
    ULONG       ulIndex = 0, ulSize = 0;
    BOOL        bPhantom = FALSE;
    ULONG       ulStatus, ulProblem;
    PWCHAR      pszFormatString = NULL;


    //
    // Note, the service currently cannot access the HKCU branch, so I
    // assume the keys specified are under HKEY_LOCAL_MACHINE.
    //

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        // (currently, 0 and -1 are the only accepted flags.)
        //
        if ((ulFlags != 0) &&
            (ulFlags != 0xFFFFFFFF)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // pszParentKey is a registry path to the pszChildKey parameter.
        // pszChildKey may be a single path or a compound path, a compound
        // path is specified if all those subkeys should be deleted (or
        // made volatile). Note that for real keys we never modify anything
        // but the lowest level private key.
        //
        if (!ARGUMENT_PRESENT(pszParentKey) ||
            !ARGUMENT_PRESENT(pszChildKey)  ||
            ((lstrlen(pszParentKey) + 1) > MAX_CM_PATH) ||
            ((lstrlen(pszChildKey)  + 1) > MAX_CM_PATH)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Allocate registry path buffers.
        //
        pszRegStr = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegStr == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegKey1 = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegKey1 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        pszRegKey2 = HeapAlloc(ghPnPHeap, 0, 2*MAX_CM_PATH * sizeof(WCHAR));
        if (pszRegKey2 == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // Is the device a phantom?
        //
        bPhantom = IsDevicePhantom((LPWSTR)pszDeviceID) ||
                   GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) != CR_SUCCESS ||
                   !(ulStatus & DN_DRIVER_LOADED);

        if (!bPhantom) {
            //
            // for a real key, we never modify anything but the key
            // where private info is so split if compound. This may
            // end up leaving a dead device key around in some cases
            // but another instance of that device could show at any
            // time so we can't make it volatile.
            //
            if (Split1(pszChildKey, pszRegStr, pszRegKey2)) {
                //
                // compound key, only the last subkey will be affected,
                // tack the rest on as part of the parent key
                //
                wsprintf(pszRegKey1, TEXT("%s\\%s"), pszParentKey, pszRegStr);
            }
            else {
                //
                // wasn't compound so use the whole child key
                //
                lstrcpy(pszRegKey1, pszParentKey);
                lstrcpy(pszRegKey2, pszChildKey);
            }
        }


        //-------------------------------------------------------------
        // SPECIAL CASE: If ulHardwareProfile == -1, then need to
        // delete the private key for all profiles.
        //-------------------------------------------------------------

        if (ulFlags == 0xFFFFFFFF) {

            wsprintf(pszRegStr, TEXT("%s\\%s"),
                     pszRegPathIDConfigDB,
                     pszRegKeyKnownDockingStates);

            RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, pszRegStr, 0,
                                      KEY_ALL_ACCESS, &hKey);

            //
            // enumerate the hardware profile keys
            //
            for (ulIndex = 0; RegStatus == ERROR_SUCCESS; ulIndex++) {

                ulSize = MAX_PROFILE_ID_LEN;
                RegStatus = RegEnumKeyEx( hKey, ulIndex, szProfile, &ulSize,
                                          NULL, NULL, NULL, NULL);

                if (RegStatus == ERROR_SUCCESS) {
                    //
                    // if phantom, go ahead and delete it
                    //
                    if (bPhantom) {
                        //
                        // pszParentKey contains replacement symbol for the profile id, %s
                        //
                        pszFormatString = wcschr(pszParentKey, L'%');

                        ASSERT(pszFormatString && (pszFormatString[1] == L's'));

                        if (pszFormatString && (pszFormatString[1] == L's')) {

                            wsprintf(pszRegStr, pszParentKey, szProfile);

                            Status = DeletePrivateKey( HKEY_LOCAL_MACHINE, pszRegStr,
                                                       pszChildKey);
                        } else {
                            Status = CR_FAILURE;
                        }
                    }

                    //
                    // if real, just make it volatile
                    //
                    else {
                        //
                        // pszRegKey1 contains replacement symbol for the profile id, %s
                        //
                        pszFormatString = wcschr(pszRegKey1, L'%');

                        ASSERT(pszFormatString && (pszFormatString[1] == L's'));

                        if (pszFormatString && (pszFormatString[1] == L's')) {

                            wsprintf(pszRegStr, pszRegKey1, szProfile);

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_REGISTRY,
                                       "UMPNPMGR: PNP_DeleteRegistryKey make key %ws\\%ws volatile\n",
                                       pszRegStr,
                                       pszRegKey2));

                            Status = MakeKeyVolatile(pszRegStr, pszRegKey2);

                        } else {
                            Status = CR_FAILURE;
                        }
                    }

                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }
                }
            }
        }

        //------------------------------------------------------------------
        // not deleting for all profiles, so just delete the specified key
        //------------------------------------------------------------------

        else {

            if (bPhantom) {
                //
                // if phantom, go ahead and delete it
                //
                Status = DeletePrivateKey( HKEY_LOCAL_MACHINE, pszParentKey,
                                           pszChildKey);
            }
            else {
                //
                // if real, just make it volatile
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_REGISTRY,
                           "UMPNPMGR: PNP_DeleteRegistryKey make key %ws\\%ws volatile\n",
                           pszRegKey1,
                           pszRegKey2));

                Status = MakeKeyVolatile(pszRegKey1, pszRegKey2);
            }

            if (Status != CR_SUCCESS) {
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hKey = hKey;
        pszRegStr = pszRegStr;
        pszRegKey1 = pszRegKey1;
        pszRegKey2 = pszRegKey2;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    if (pszRegStr != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegStr);
    }

    if (pszRegKey1 != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegKey1);
    }

    if (pszRegKey2 != NULL) {
        HeapFree(ghPnPHeap, 0, pszRegKey2);
    }

    return Status;

} // PNP_DeleteRegistryKey



CONFIGRET
PNP_GetClassCount(
      IN  handle_t   hBinding,
      OUT PULONG     pulClassCount,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Class_Count routine.
  It returns the number of valid classes currently installed (listed in
  the registry).

Arguments:

   hBinding          RPC binding handle, not used.

   pulClassCount     Supplies the address of a variable that will
                     receive the number of classes installed.

   ulFlags           Not used.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

Notes:

   ** PRESENTLY, ALWAYS RETURNS CR_CALL_NOT_IMPLEMENTED **

    No corresponding CM_Get_Class_Count routine is implemented.
    This routine currently returns CR_CALL_NOT_IMPLEMENTED.

--*/

{
   UNREFERENCED_PARAMETER(hBinding);
   UNREFERENCED_PARAMETER(pulClassCount);
   UNREFERENCED_PARAMETER(ulFlags);

   return CR_CALL_NOT_IMPLEMENTED;

} // PNP_GetClassCount



CONFIGRET
PNP_GetClassName(
      IN  handle_t   hBinding,
      IN  PCWSTR     pszClassGuid,
      OUT PWSTR      Buffer,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Class_Name routine.
  It returns the name of the class represented by the GUID.

Arguments:

   hBinding       RPC binding handle, not used.

   pszClassGuid   String containing the class guid to retrieve a
                  class name for.

   Buffer         Supplies the address of the buffer that receives the
                  class name.

   pulLength      On input, this specifies the size of the Buffer in
                  characters.  On output it contains the number of
                  characters actually copied to Buffer.

   ulFlags        Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_BUFFER_SMALL, or
      CR_REGISTRY_ERROR

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH];
   HKEY        hKey = NULL;
   ULONG       ulLength;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // Validate parameters
      //
      if (INVALID_FLAGS(ulFlags, 0)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if ((!ARGUMENT_PRESENT(pulLength)) ||
          (!ARGUMENT_PRESENT(Buffer) && *pulLength != 0)) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      //
      // Open the key for the specified class guid
      //
      if ((lstrlen (pszRegPathClass) + lstrlen (pszClassGuid) + sizeof (TEXT("\\"))) > MAX_CM_PATH) {
          Status = CR_BUFFER_SMALL;
          goto Clean0;
      }
      wsprintf(RegStr, TEXT("%s\\%s"),
               pszRegPathClass,
               pszClassGuid);

      RegStatus = RegOpenKeyEx(
               HKEY_LOCAL_MACHINE, RegStr, 0, KEY_QUERY_VALUE, &hKey);

      if (RegStatus != ERROR_SUCCESS) {
         Status = CR_REGISTRY_ERROR;
         goto Clean0;
      }

      //
      // Retrieve the class name string value
      //
      ulLength = *pulLength;

      *pulLength *= sizeof(WCHAR);              // convert to size in bytes
      RegStatus = RegQueryValueEx(
               hKey, pszRegValueClass, NULL, NULL,
               (LPBYTE)Buffer, pulLength);
      *pulLength /= sizeof(WCHAR);              // convert back to chars

      if (RegStatus == ERROR_SUCCESS) {
         Status = CR_SUCCESS;
      }
      else if (RegStatus == ERROR_MORE_DATA) {
          Status = CR_BUFFER_SMALL;
          if ((ARGUMENT_PRESENT(Buffer)) &&
              (ulLength > 0)) {
              *Buffer = L'\0';
          }
      }
      else {
          Status = CR_REGISTRY_ERROR;
          if ((ARGUMENT_PRESENT(Buffer)) &&
              (ulLength > 0)) {
              *Buffer = L'\0';
              *pulLength = 1;
          }
      }

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
       //
       // force compiler to respect statement ordering w.r.t. assignments
       // for these variables...
       //
       hKey = hKey;
   }

   if (hKey != NULL) {
       RegCloseKey(hKey);
   }

   return Status;

} // PNP_GetClassName



CONFIGRET
PNP_DeleteClassKey(
      IN  handle_t   hBinding,
      IN  PCWSTR     pszClassGuid,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Delete_Class_Key routine.
  It deletes the corresponding registry key.

Arguments:

   hBinding       RPC binding handle.

   pszClassGuid   String containing the class guid to retrieve a
                  class name for.

   ulFlags        Either CM_DELETE_CLASS_ONLY or CM_DELETE_CLASS_SUBKEYS.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER,
      CR_REGISTRY_ERROR, or
      CR_FAILURE

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_DELETE_CLASS_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (ulFlags == CM_DELETE_CLASS_SUBKEYS) {
            //
            // Delete the class key and any subkeys under it
            //
            if (!RegDeleteNode(ghClassKey, pszClassGuid)) {
                Status = CR_REGISTRY_ERROR;
            }

        } else if (ulFlags == CM_DELETE_CLASS_ONLY) {
            //
            // only delete the class key itself (just attempt to delete
            // using the registry routine, it will fail if any subkeys
            // exist)
            //
            if (RegDeleteKey(ghClassKey, pszClassGuid) != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_DeleteClassKey



CONFIGRET
PNP_GetInterfaceDeviceAlias(
   IN     handle_t hBinding,
   IN     PCWSTR   pszInterfaceDevice,
   IN     LPGUID   AliasInterfaceGuid,
   OUT    PWSTR    pszAliasInterfaceDevice,
   IN OUT PULONG   pulLength,
   IN OUT PULONG   pulTransferLen,
   IN     ULONG    ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Interface_Device_Alias routine.
  It returns an alias string for the specified guid and interface device.

Arguments:

   hBinding          RPC binding handle, not used.

   pszInterfaceDevice  Specifies the interface device to find an alias for.

   AliasInterfaceGuid  Supplies the interface class GUID.

   pszAliasInterfaceDevice  Supplies the address of a variable that will
                     receive the device interface alias of the specified device
                     interface, that is a member of the specified alias
                     interface class GUID.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(pszInterfaceDevice) ||
            !ARGUMENT_PRESENT(AliasInterfaceGuid) ||
            !ARGUMENT_PRESENT(pszAliasInterfaceDevice) ||
            !ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that AliasInterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceAlias
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_ALIAS_DATA));
        RtlInitUnicodeString(&ControlData.SymbolicLinkName, pszInterfaceDevice);
        ControlData.AliasClassGuid = AliasInterfaceGuid;
        ControlData.AliasSymbolicLinkName = pszAliasInterfaceDevice;
        ControlData.AliasSymbolicLinkNameLength = *pulLength; // chars

        //
        // Call kernel-mode to get the device interface alias.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceAlias,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.AliasSymbolicLinkNameLength;
            *pulTransferLen = *pulLength + 1;
        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulLength = ControlData.AliasSymbolicLinkNameLength;
            Status = CR_BUFFER_SMALL;
        } else {
            *pulLength = 0;
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:

        //
        // Initialize output parameters
        //
        if ((Status != CR_SUCCESS) &&
            ARGUMENT_PRESENT(pulTransferLen) &&
            ARGUMENT_PRESENT(pszAliasInterfaceDevice) &&
            (*pulTransferLen > 0)) {
            *pszAliasInterfaceDevice = L'\0';
            *pulTransferLen = 1;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceAlias



CONFIGRET
PNP_GetInterfaceDeviceList(
    IN  handle_t  hBinding,
    IN  LPGUID    InterfaceGuid,
    IN  LPCWSTR   pszDeviceID,
    OUT LPWSTR    Buffer,
    IN OUT PULONG pulLength,
    IN  ULONG     ulFlags
   )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Device_Interface_List routine.
  It returns a multi_sz interface device list.

Arguments:

   hBinding          RPC binding handle, not used.

   InterfaceGuid     Supplies the interface class GUID.

   pszDeviceID       Supplies the device instance string.

   Buffer            Supplies the address of the buffer that receives the
                     registry data.

   pulLength         Specifies the size, in bytes, of the buffer.

   ulFlags           Flags specifying which device interfaces to return.
                     Currently, may be either:
                       CM_GET_DEVICE_INTERFACE_LIST_PRESENT, or
                       CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_DEVNODE,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_LIST_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pulLength) ||
            !ARGUMENT_PRESENT(Buffer) ||
            (*pulLength == 0)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceList
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.InterfaceList = Buffer;
        ControlData.InterfaceListSize = *pulLength;

        if (ulFlags == CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES) {
            ControlData.Flags = 0x1; // DEVICE_INTERFACE_INCLUDE_NONACTIVE (ntos\inc\pnp.h)
        } else {
            ControlData.Flags = 0;
        }

        //
        // Call kernel-mode to get the device interface list.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.InterfaceListSize;
        } else {
            *pulLength = 0;
            if (ntStatus == STATUS_BUFFER_TOO_SMALL)  {
                Status = CR_BUFFER_SMALL;
            } else {
                Status = CR_FAILURE;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceList



CONFIGRET
PNP_GetInterfaceDeviceListSize(
    IN  handle_t   hBinding,
    OUT PULONG     pulLen,
    IN  LPGUID     InterfaceGuid,
    IN  LPCWSTR    pszDeviceID,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_Device_Interface_List_Size
  routine. It returns the size (in chars) of a multi_sz interface device list.

Arguments:

   hBinding          RPC binding handle, not used.

   pulLen            Supplies the address of a variable that, upon successful
                     return, receives the the size of buffer required to hold
                     the multi_sz interface device list.

   InterfaceGuid     Supplies the interface class GUID.

   pszDeviceID       Supplies the device instance string.

   ulFlags           Flags specifying which device interfaces to return.
                     Currently, may be either:
                       CM_GET_DEVICE_INTERFACE_LIST_PRESENT, or
                       CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_INTERFACE_LIST_DATA ControlData;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_GET_DEVICE_INTERFACE_LIST_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pulLen)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Initialize the returned output length
        //
        *pulLen = 0;

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlGetInterfaceDeviceList
        // control, and is probed unconditionally by kernel-mode.  Better to
        // fail the call above with a useful status than to return the generic
        // CR_FAILURE after an exception/error from kernel-mode, below.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_INTERFACE_LIST_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.InterfaceList = NULL;
        ControlData.InterfaceListSize = 0;

        if (ulFlags == CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES) {
            ControlData.Flags = 0x1; // DEVICE_INTERFACE_INCLUDE_NONACTIVE (ntos\inc\pnp.h)
        } else {
            ControlData.Flags = 0;
        }

        //
        // Call kernel-mode to get the device interface list size.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlGetInterfaceDeviceList,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLen = ControlData.InterfaceListSize;
        } else {
            Status = CR_FAILURE;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetInterfaceDeviceListSize



CONFIGRET
PNP_RegisterDeviceClassAssociation(
    IN handle_t   hBinding,
    IN LPCWSTR    pszDeviceID,
    IN LPGUID     InterfaceGuid,
    IN LPCWSTR    pszReference  OPTIONAL,
    OUT PWSTR     pszSymLink,
    IN OUT PULONG pulLength,
    IN OUT PULONG pulTransferLen,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Register_Device_Interface
  routine.  It registers a device interface for the specified device and device
  interface class, and returns the symbolic link name for the device interface.

Arguments:

   hBinding          RPC binding handle.

   pszDeviceID       Supplies the device instance string.

   InterfaceGuid     Supplies the interface class guid.

   pszReference      Optionally, supplies the reference string name.

   pszSymLink        Receives the symbolic link name.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occured) or else the size of buffer
                     required to hold the property data.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_INVALID_FLAG,
      CR_INVALID_POINTER, or
      CR_REGISTRY_ERROR

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA ControlData;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        ASSERT(pulTransferLen != pulLength);

        if (!ARGUMENT_PRESENT(InterfaceGuid) ||
            !ARGUMENT_PRESENT(pszSymLink) ||
            !ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Make sure we use no more than either what the caller specified or
        // what was allocated by RPC, based on the transfer length.
        //
        *pulLength = min(*pulLength, *pulTransferLen);

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that InterfaceGuid was already validated above because this
        // buffer is required for the PlugPlayControlDeviceClassAssociation
        // control, for Registration only.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        RtlInitUnicodeString(&ControlData.Reference, pszReference);
        ControlData.InterfaceGuid = InterfaceGuid;
        ControlData.Register = TRUE;
        ControlData.SymLink = pszSymLink;
        ControlData.SymLinkLength = *pulLength;

        //
        // Call kernel-mode to register the device association.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlDeviceClassAssociation,
                                     &ControlData,
                                     sizeof(ControlData));

        if (NT_SUCCESS(ntStatus)) {
            *pulLength = ControlData.SymLinkLength;
            *pulTransferLen = *pulLength;
        } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
            *pulLength = ControlData.SymLinkLength;
            Status = CR_BUFFER_SMALL;
        } else {
            *pulLength = 0;
            Status = MapNtStatusToCmError(ntStatus);
        }

    Clean0:

        //
        // Initialize output parameters
        //
        if ((Status != CR_SUCCESS) &&
            ARGUMENT_PRESENT(pszSymLink) &&
            ARGUMENT_PRESENT(pulTransferLen) &&
            (*pulTransferLen > 0)) {
            *pszSymLink = L'\0';
            *pulTransferLen = 1;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_RegisterDeviceClassAssociation



CONFIGRET
PNP_UnregisterDeviceClassAssociation(
    IN handle_t   hBinding,
    IN LPCWSTR    pszInterfaceDevice,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Unregister_Device_Interface
  routine.

Arguments:

   hBinding             RPC binding handle.

   pszInterfaceDevice   Specifies the interface device to unregister

   ulFlags              Not used, must be zero.

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_ACCESS_DENIED,
      CR_DEVICE_INTERFACE_ACTIVE, or
      CR_FAILURE.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA ControlData;

    try {
        //
        // Verify client privilege
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // Validate parameters
        //
        if (!ARGUMENT_PRESENT(pszInterfaceDevice)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Fill in a control structure for the device list info.
        //

        //
        // Note that the DeviceInstance, Reference, and InterfaceGuid members
        // are not required for the PlugPlayControlDeviceClassAssociation
        // control, for unregistration only.  Only the symbolic link name is
        // required to unregister the device interface.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_CLASS_ASSOCIATION_DATA));
        ControlData.Register = FALSE;
        ControlData.SymLink = (LPWSTR)pszInterfaceDevice;
        ControlData.SymLinkLength = lstrlen(pszInterfaceDevice) + 1;

        //
        // Call kernel-mode to deregister the device association.
        //

        ntStatus = NtPlugPlayControl(PlugPlayControlDeviceClassAssociation,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            if (ntStatus == STATUS_ACCESS_DENIED) {
                Status = CR_DEVICE_INTERFACE_ACTIVE;
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_UnregisterDeviceClassAssociation


//-------------------------------------------------------------------
// Private export for the Service Controller
//-------------------------------------------------------------------



CONFIGRET
DeleteServicePlugPlayRegKeys(
    IN  LPWSTR   pszService
    )
/*++

Routine Description:

    This routine is called directly and privately by the Service Controller
    whenever a service has been deleted.  It allows the SCM to delete any Plug
    and Play registry keys that may have been created for a service.

Arguments:

    pszService - Specifies the name of the service.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Note:

    This routine is privately exported, and is to be called only by the
    Service Control Manager, during service deletion.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulSize, ulFlags, ulHardwareProfile, ulPass;
    LPWSTR      pDeviceList = NULL, pDeviceID;
    WCHAR       szParentKey[MAX_CM_PATH], szChildKey[MAX_DEVICE_ID_LEN];
    BOOL        RootEnumerationRequired = FALSE;
    ULONG       ulProblem, ulStatus;

    try {
        //
        // validate parameters
        //
        if (!ARGUMENT_PRESENT(pszService)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // retreive the maximum size required for a buffer to receive the list
        // of devices that this service is controlling
        //
        Status = PNP_GetDeviceListSize(NULL,
                                       pszService,
                                       &ulSize,
                                       CM_GETIDLIST_FILTER_SERVICE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
        if (pDeviceList == NULL) {
            Status = CR_OUT_OF_MEMORY;
            goto Clean0;
        }

        //
        // retrieve the list of devices that this service is controlling, make
        // sure that we don't generate one if none already exist
        //
        Status = PNP_GetDeviceList(NULL,
                                   pszService,
                                   pDeviceList,
                                   &ulSize,
                                   CM_GETIDLIST_FILTER_SERVICE |
                                   CM_GETIDLIST_DONOTGENERATE);

        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        //
        // delete the registry keys for each device instance for this service
        //
        for (pDeviceID = pDeviceList;
             *pDeviceID;
             pDeviceID += lstrlen(pDeviceID) + 1) {

            for (ulPass = 0; ulPass < 4; ulPass++) {
                //
                // delete the registry keys for all hardware profiles, followed
                // by the system global registry keys
                //
                if (ulPass == 0) {
                    ulFlags = CM_REGISTRY_HARDWARE | CM_REGISTRY_CONFIG;
                    ulHardwareProfile = 0xFFFFFFFF;
                } else if (ulPass == 1) {
                    ulFlags = CM_REGISTRY_SOFTWARE | CM_REGISTRY_CONFIG;
                    ulHardwareProfile = 0xFFFFFFFF;
                } else if (ulPass == 2) {
                    ulFlags = CM_REGISTRY_HARDWARE;
                    ulHardwareProfile = 0;
                } else if (ulPass == 3) {
                    ulFlags = CM_REGISTRY_SOFTWARE;
                    ulHardwareProfile = 0;
                }

                //
                // form the registry path based on the device id and the flags
                //
                if (GetDevNodeKeyPath(NULL,
                                      pDeviceID,
                                      ulFlags,
                                      ulHardwareProfile,
                                      szParentKey,
                                      szChildKey) == CR_SUCCESS) {

                    //
                    // remove the specified registry key
                    //
                    PNP_DeleteRegistryKey(
                        NULL,                   // rpc binding handle (NULL)
                        pDeviceID,              // device id
                        szParentKey,            // parent of key to delete
                        szChildKey,             // key to delete
                        ulHardwareProfile);     // flags, not used
                }
            }

            //
            // Uninstall the device instance (see also PNP_UninstallDevInst).
            //

            //------------------------------------------------------------------
            // Uninstall deletes instance key (and all subkeys) for all
            // the hardware keys (this means the main Enum branch, the
            // config specific keys under HKLM, and the Enum branch under
            // HKCU). In the case of the user hardware keys (under HKCU),
            // I delete those whether it's a phantom or not, but since
            // I can't access the user key from the service side, I have
            // to do that part on the client side. For the main hw Enum key
            // and the config specific hw keys, I only delete them outright
            // if they are phantoms. If not a phantom, then I just make the
            // device instance volatile (by saving the original key, deleting
            // old key, creating new volatile key and restoring the old
            // contents) so at least it will go away during the next boot
            //------------------------------------------------------------------

            if ((GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) &&
                (ulStatus & DN_DRIVER_LOADED)) {

                //-------------------------------------------------------------
                // device is not a phantom
                //-------------------------------------------------------------

                if ((ulStatus & DN_ROOT_ENUMERATED) &&
                    !(ulStatus & DN_DISABLEABLE)) {
                    //
                    // if a device is root enumerated, but not disableable, it is not uninstallable
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: DeleteServicePlugPlayRegKeys: "
                               "failed uninstall of %ws (this root device is not disableable)\n",
                               pDeviceID));
                } else {
                    //
                    // do the volatile-copy-thing
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: DeleteServicePlugPlayRegKeys: "
                               "doing volatile key thing on %ws\n",
                               pDeviceID));

                    UninstallRealDevice(pDeviceID);
                }

            } else {

                //-------------------------------------------------------------
                // device is a phantom so actually delete it
                //-------------------------------------------------------------

                if (UninstallPhantomDevice(pDeviceID) != CR_SUCCESS) {
                    continue;
                }

                //
                // if it is a root enumerated device, we need to reenumerate the
                // root (if not planning to do so already) so that the PDO will
                // go away, otherwise a new device could be created and the root
                // enumerator would get very confused.
                //
                if ((!RootEnumerationRequired) &&
                    (IsDeviceRootEnumerated(pDeviceID))) {
                    RootEnumerationRequired = TRUE;
                }
            }
        }

        //
        // Now that we're done processing all devices, see if we need to
        // reenumerate the root.
        //
        if (RootEnumerationRequired) {

            //
            // Reenumerate the root devnode asynchronously so that the service
            // controller does not block waiting for this routine to complete!!
            // (If we were processing device events at this time, the SCM would
            // be blocked here and not be able to deliver any events for us.
            // That would stall the event queue, preventing a synchronous device
            // enumeration from completing).
            //

            ReenumerateDevInst(pszRegRootEnumerator,
                               FALSE,
                               CM_REENUMERATE_ASYNCHRONOUS);
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        pDeviceList = pDeviceList;
    }

    if (pDeviceList) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }

    return Status;

} // DeleteServicePlugPlayRegKeys



//-------------------------------------------------------------------
// Private utility routines
//-------------------------------------------------------------------



LPWSTR
MapPropertyToString(
   ULONG ulProperty
   )
{
    switch (ulProperty) {

    case CM_DRP_DEVICEDESC:
        return pszRegValueDeviceDesc;

    case CM_DRP_HARDWAREID:
        return pszRegValueHardwareIDs;

    case CM_DRP_COMPATIBLEIDS:
        return pszRegValueCompatibleIDs;

    case CM_DRP_SERVICE:
        return pszRegValueService;

    case CM_DRP_CLASS:
        return pszRegValueClass;

    case CM_DRP_CLASSGUID:
        return pszRegValueClassGuid;

    case CM_DRP_DRIVER:
        return pszRegValueDriver;

    case CM_DRP_CONFIGFLAGS:
        return pszRegValueConfigFlags;

    case CM_DRP_MFG:
        return pszRegValueMfg;

    case CM_DRP_FRIENDLYNAME:
        return pszRegValueFriendlyName;

    case CM_DRP_LOCATION_INFORMATION:
        return pszRegValueLocationInformation;

    case CM_DRP_CAPABILITIES:
        return pszRegValueCapabilities;

    case CM_DRP_UI_NUMBER:
        return pszRegValueUiNumber;

    case CM_DRP_UPPERFILTERS:
        return pszRegValueUpperFilters;

    case CM_DRP_LOWERFILTERS:
        return pszRegValueLowerFilters;

    case CM_DRP_SECURITY: // and CM_CRP_SECURITY
        return pszRegValueSecurity;

    case CM_DRP_DEVTYPE: // and CM_DRP_DEVTYPE
        return pszRegValueDevType;

    case CM_DRP_EXCLUSIVE: // and CM_DRP_EXCLUSIVE
        return pszRegValueExclusive;

    case CM_DRP_CHARACTERISTICS: // and CM_DRP_CHARACTERISTICS
        return pszRegValueCharacteristics;

    case CM_DRP_UI_NUMBER_DESC_FORMAT:
        return pszRegValueUiNumberDescFormat;

    case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        return pszRegValueRemovalPolicyOverride;

    default:
        return NULL;
    }

} // MapPropertyToString



ULONG
MapPropertyToNtProperty(
    ULONG ulProperty
    )
{
    switch (ulProperty) {

    case CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME:
        return PNP_PROPERTY_PDONAME;

    case CM_DRP_BUSTYPEGUID:
        return PNP_PROPERTY_BUSTYPEGUID;

    case CM_DRP_LEGACYBUSTYPE:
        return PNP_PROPERTY_LEGACYBUSTYPE;

    case CM_DRP_BUSNUMBER:
        return PNP_PROPERTY_BUSNUMBER;

    case CM_DRP_ADDRESS:
        return PNP_PROPERTY_ADDRESS;

    case CM_DRP_DEVICE_POWER_DATA:
        return PNP_PROPERTY_POWER_DATA;

    case CM_DRP_REMOVAL_POLICY:
        return PNP_PROPERTY_REMOVAL_POLICY;

    case CM_DRP_REMOVAL_POLICY_HW_DEFAULT:
        return PNP_PROPERTY_REMOVAL_POLICY_HARDWARE_DEFAULT;

    case CM_DRP_REMOVAL_POLICY_OVERRIDE:
        return PNP_PROPERTY_REMOVAL_POLICY_OVERRIDE;

    case CM_DRP_INSTALL_STATE:
        return PNP_PROPERTY_INSTALL_STATE;

    default:
        return 0;
    }
} // MapPropertyToNtProperty



CONFIGRET
PNP_GetCustomDevProp(
    IN     handle_t hBinding,
    IN     LPCWSTR  pDeviceID,
    IN     LPCWSTR  CustomPropName,
    OUT    PULONG   pulRegDataType,
    OUT    LPBYTE   Buffer,
    OUT    PULONG   pulTransferLen,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags
    )

/*++

Routine Description:

  This is the RPC server entry point for the CM_Get_DevNode_Custom_Property
  routine.

Arguments:

   hBinding          RPC binding handle, not used.

   pDeviceID         Supplies a string containing the device instance
                     whose property will be read from.

   CustomPropName    Supplies a string identifying the name of the property
                     (registry value entry name) to be retrieved.

   pulRegDataType    Supplies the address of a variable that will receive
                     the registry data type for this property (i.e., the REG_*
                     constants).

   Buffer            Supplies the address of the buffer that receives the
                     registry data.  If the caller is simply retrieving the
                     required size, pulLength will be zero.

   pulTransferLen    Used by stubs, indicates how much data to copy back
                     into user buffer.

   pulLength         Parameter passed in by caller, on entry it contains
                     the size, in bytes, of the buffer, on exit it contains
                     either the amount of data copied to the caller's buffer
                     (if a transfer occurred) or else the size of buffer
                     required to hold the property data.

   ulFlags           May be a combination of the following values:

                     CM_CUSTOMDEVPROP_MERGE_MULTISZ : merge the
                     devnode-specific REG_SZ or REG_MULTI_SZ property (if
                     present) with the per-hardware-id REG_SZ or REG_MULTI_SZ
                     property (if present).  The result will always be a
                     REG_MULTI_SZ.

                     Note: REG_EXPAND_SZ data is not merged in this manner, as
                     there is no way to indicate that the resultant list needs
                     environment variable expansion (i.e., there's no such
                     registry datatype as REG_EXPAND_MULTI_SZ).

Return Value:

   If the function succeeds, the return value is CR_SUCCESS.
   If the function fails, the return value is one of the following:
      CR_INVALID_DEVNODE,
      CR_REGISTRY_ERROR,
      CR_BUFFER_SMALL,
      CR_NO_SUCH_VALUE, or
      CR_FAILURE.

Remarks:

   The pointer passed in as the pulTransferLen argument must *NOT* be the same
   as the pointer passed in for the pulLength argument.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus;
    HKEY        hDevKey = NULL;
    HKEY        hDevParamsKey = NULL;
    HKEY        hPerHwIdSubKey = NULL;
    WCHAR       PerHwIdSubkeyName[MAX_DEVNODE_ID_LEN];
    ULONG       RequiredSize = 0;
    FILETIME    CacheDate, LastUpdateTime;
    DWORD       RegDataType, RegDataSize;
    LPBYTE      PerHwIdBuffer;
    DWORD       PerHwIdBufferLen;
    LPWSTR      pCurId;
    BOOL        MergeMultiSzResult = FALSE;

    UNREFERENCED_PARAMETER(hBinding);

    try {

        //
        // Validate parameters
        //

        if (!ARGUMENT_PRESENT(pulTransferLen) ||
            !ARGUMENT_PRESENT(pulLength)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // We should never have both arguments pointing to the same memory...
        //
        ASSERT(pulTransferLen != pulLength);

        //
        // ...but if we do, fail the call.
        //
        if (pulTransferLen == pulLength) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        *pulTransferLen = 0;

        if (INVALID_FLAGS(ulFlags, CM_CUSTOMDEVPROP_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if(!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // First, open the device instance key.  We'll then open the "Device
        // Parameters" subkey off of that.  We do this in two steps, because
        // we're likely to need a handle to the device instance key in order
        // to track down the per-hw-id property.
        //
        if(ERROR_SUCCESS != RegOpenKeyEx(ghEnumKey,
                                         pDeviceID,
                                         0,
                                         KEY_READ | KEY_WRITE,
                                         &hDevKey)) {

            hDevKey = NULL;         // ensure hDevKey is still NULL so we
                                    // won't erroneously try to close it.

            RequiredSize = 0;       // no size info for caller

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        if(ERROR_SUCCESS == RegOpenKeyEx(hDevKey,
                                         pszRegKeyDeviceParam,
                                         0,
                                         KEY_READ,
                                         &hDevParamsKey)) {

            RequiredSize = *pulLength;

            RegStatus = RegQueryValueEx(hDevParamsKey,
                                        CustomPropName,
                                        NULL,
                                        pulRegDataType,
                                        Buffer,
                                        &RequiredSize
                                       );

            if(RegStatus == ERROR_SUCCESS) {
                //
                // We need to distinguish between the case where we succeeded
                // because the caller supplied a zero-length buffer (we call it
                // CR_BUFFER_SMALL) and the "real" success case.
                //
                if((*pulLength == 0) && (RequiredSize != 0)) {
                    Status = CR_BUFFER_SMALL;
                }

            } else {

                if(RegStatus == ERROR_MORE_DATA) {
                    Status = CR_BUFFER_SMALL;
                } else {
                    RequiredSize = 0;
                    Status = CR_NO_SUCH_VALUE;
                }
            }

            //
            // At this point, Status is one of the following:
            //
            // CR_SUCCESS       : we found the value and our buffer was
            //                    sufficiently-sized to hold it,
            // CR_BUFFER_SMALL  : we found the value and our buffer wasn't
            //                    large enough to hold it, or
            // CR_NO_SUCH_VALUE : we didn't find the value.
            //
            // If we found a value (whether or not our buffer was large enough
            // to hold it), we're done, except for cases where the caller
            // has asked us to append the per-hw-id string(s) with the
            // per-devnode string(s).
            //
            if(Status == CR_NO_SUCH_VALUE) {
                //
                // No devnode-specific property, so we use the same buffer and
                // length for retrieval of per-hw-id property...
                //
                PerHwIdBuffer = Buffer;
                PerHwIdBufferLen = *pulLength;

            } else {
                //
                // Figure out if we need to worry about appending results
                // together into a multi-sz list...
                //
                if((ulFlags & CM_CUSTOMDEVPROP_MERGE_MULTISZ) &&
                   ((*pulRegDataType == REG_MULTI_SZ) || (*pulRegDataType == REG_SZ))) {

                    MergeMultiSzResult = TRUE;

                    //
                    // Ensure that the size of our string(s) buffer is at least
                    // one Unicode character.  If we have a buffer of one
                    // character, ensure that character is a null.
                    //
                    if(RequiredSize < sizeof(WCHAR)) {
                        RequiredSize = sizeof(WCHAR);
                        if(RequiredSize > *pulLength) {
                            Status = CR_BUFFER_SMALL;
                        } else {
                            ASSERT(Status == CR_SUCCESS);
                            *(PWSTR)Buffer = L'\0';
                        }
                    }
                }

                if(!MergeMultiSzResult) {
                    //
                    // We're outta here!
                    //
                    if(Status == CR_SUCCESS) {
                        //
                        // We have data to transfer.
                        //
                        *pulTransferLen = RequiredSize;
                    }

                    goto Clean0;

                } else {
                    //
                    // We're supposed to merge our per-devnode string(s) with
                    // any per-hw-id string(s) we find.  Make sure our buffer
                    // and length reflect a properly-formatted multi-sz list,
                    // then setup our per-hw-id buffer info so that we'll
                    // append to this list later on...
                    //
                    if(Status == CR_BUFFER_SMALL) {
                        //
                        // We won't even try to retrieve any actual data from
                        // a per-hw-id key (all we'll get is the additional
                        // size requirement).
                        //
                        PerHwIdBuffer = NULL;
                        PerHwIdBufferLen = 0;

                        if(*pulRegDataType == REG_SZ) {
                            //
                            // The data we retrieved from the devnode's "Device
                            // Parameters" subkey was a REG_SZ.  Add one
                            // character width to the required length to
                            // reflect the size of the string after conversion
                            // to multi-sz (unless the size is 1 character,
                            // indicating an empty string, which is also the
                            // size of an empty multi-sz list).
                            //
                            if(RequiredSize > sizeof(WCHAR)) {
                                RequiredSize += sizeof(WCHAR);
                            }

                            *pulRegDataType = REG_MULTI_SZ;
                        }

                    } else {
                        //
                        // We actually retrieved a REG_SZ or REG_MULTI_SZ value
                        // into our caller-supplied buffer.  Ensure that the
                        // string(s) contained therein is(are) in proper
                        // multi-sz format, and that the size is correct.
                        //
                        if(*pulRegDataType == REG_SZ) {

                            RegDataSize = lstrlen((LPWSTR)Buffer) + 1;

                            if((RegDataSize * sizeof(WCHAR)) > RequiredSize) {
                                //
                                // The string we retrieved is longer than the
                                // buffer--this indicates the string wasn't
                                // properly null-terminated.  Discard this
                                // string.
                                //
                                Status = CR_NO_SUCH_VALUE;
                                RequiredSize = 0;
                                PerHwIdBuffer = Buffer;
                                PerHwIdBufferLen = *pulLength;

                            } else {
                                //
                                // The string was large enough to fit in the
                                // buffer.  Add another null character to
                                // turn this into a multi-sz (if there's room).
                                // (Again, we don't need to do increase the
                                // length if this is an empty string.)
                                //
                                if(RegDataSize == 1) {
                                    RequiredSize = sizeof(WCHAR);
                                    PerHwIdBuffer = Buffer;
                                    PerHwIdBufferLen = *pulLength;
                                    //
                                    // Assuming no per-hw-id data is found
                                    // later, this is the size of the data
                                    // we'll be handing back to the caller.
                                    //
                                    *pulTransferLen = RequiredSize;

                                } else {
                                    RequiredSize = (RegDataSize + 1) * sizeof(WCHAR);

                                    if(RequiredSize > *pulLength) {
                                        //
                                        // Oops--while the string fits nicely into
                                        // the caller-supplied buffer, adding an
                                        // extra null char pushes it over the limit.
                                        // Turn this into a CR_BUFFER_SMALL case.
                                        //
                                        Status = CR_BUFFER_SMALL;
                                        PerHwIdBuffer = NULL;
                                        PerHwIdBufferLen = 0;

                                    } else {
                                        //
                                        // We've got room to add the extra null
                                        // character.  Do so, and setup our
                                        // per-hw-id buffer to start at the end of
                                        // our existing (single string) list...
                                        //
                                        PerHwIdBuffer =
                                            (LPBYTE)((LPWSTR)Buffer + RegDataSize);

                                        PerHwIdBufferLen =
                                            *pulLength - (RegDataSize * sizeof(WCHAR));

                                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                                        //
                                        // Assuming no per-hw-id data is found
                                        // later, this is the size of the data
                                        // we'll be handing back to the caller.
                                        //
                                        *pulTransferLen = RequiredSize;
                                    }
                                }

                                *pulRegDataType = REG_MULTI_SZ;
                            }

                        } else {
                            //
                            // We retrieved a multi-sz list.  Step through it
                            // to find the end of the list.
                            //
                            RegDataSize = 0;

                            for(pCurId = (LPWSTR)Buffer;
                                *pCurId;
                                pCurId = (LPWSTR)(Buffer + RegDataSize)) {

                                RegDataSize +=
                                    (lstrlen(pCurId) + 1) * sizeof(WCHAR);

                                if(RegDataSize < RequiredSize) {
                                    //
                                    // This string fits in the buffer, and
                                    // there's still space left over (i.e., for
                                    // at least a terminating null).  Move on
                                    // to the next string in the list.
                                    //
                                    continue;

                                } else if(RegDataSize > RequiredSize) {
                                    //
                                    // This string extends past the end of the
                                    // buffer, indicating that it wasn't
                                    // properly null-terminated.  This could've
                                    // caused an exception, in which case we'd
                                    // have discarded any contents of this
                                    // value.  For consistency, we'll discard
                                    // the contents anyway.  (Note: a multi-sz
                                    // list that simply ommitted the final
                                    // terminating NULL will not fall into this
                                    // category--we deal with that correctly
                                    // and "fix it up".)
                                    //
                                    Status = CR_NO_SUCH_VALUE;
                                    RequiredSize = 0;
                                    PerHwIdBuffer = Buffer;
                                    PerHwIdBufferLen = *pulLength;
                                    break;

                                } else {
                                    //
                                    // This string exactly fits into the
                                    // remaining buffer space, indicating that
                                    // the multi-sz list wasn't properly
                                    // double-null terminated.  We'll go ahead
                                    // and do that now...
                                    //
                                    RequiredSize = RegDataSize + sizeof(WCHAR);

                                    if(RequiredSize > *pulLength) {
                                        //
                                        // Oops--while the string fits nicely
                                        // into the caller-supplied buffer,
                                        // adding an extra null char pushes it
                                        // over the limit. Turn this into a
                                        // CR_BUFFER_SMALL case.
                                        //
                                        Status = CR_BUFFER_SMALL;
                                        PerHwIdBuffer = NULL;
                                        PerHwIdBufferLen = 0;

                                    } else {
                                        //
                                        // We've got room to add the extra null
                                        // character.  Do so, and setup our
                                        // per-hw-id buffer to start at the end
                                        // of our existing list...
                                        //
                                        PerHwIdBuffer = Buffer + RegDataSize;

                                        PerHwIdBufferLen =
                                            *pulLength - RegDataSize;

                                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                                        //
                                        // Assuming no per-hw-id data is found
                                        // later, this is the size of the data
                                        // we'll be handing back to the caller.
                                        //
                                        *pulTransferLen = RequiredSize;
                                    }

                                    //
                                    // We've reached the end of the list, so we
                                    // can break out of the loop.
                                    //
                                    break;
                                }
                            }

                            //
                            // We've now processed all (valid) strings in the
                            // multi-sz list we retrieved.  If there was a
                            // problem (either unterminated string or
                            // unterminated list), we fixed that up (and
                            // adjusted RequiredSize accordingly).  However,
                            // if the list was valid, we need to compute
                            // RequiredSize (e.g., the buffer might've been
                            // larger than the multi-sz list).
                            //
                            // We can recognize a properly-formatted multi-sz
                            // list, because that's the only time we'd have
                            // exited the loop with pCurId pointing to a null
                            // character...
                            //
                            if(!*pCurId) {
                                ASSERT(RequiredSize >= (RegDataSize + sizeof(WCHAR)));
                                RequiredSize = RegDataSize + sizeof(WCHAR);

                                PerHwIdBuffer = Buffer + RegDataSize;
                                PerHwIdBufferLen = *pulLength - RegDataSize;

                                //
                                // Assuming no per-hw-id data is found later,
                                // this is the size of the data we'll be
                                // handing back to the caller.
                                //
                                *pulTransferLen = RequiredSize;
                            }
                        }
                    }
                }
            }

        } else {
            //
            // We couldn't open the devnode's "Device Parameters" subkey.
            // Ensure hDevParamsKey is still NULL so we won't erroneously try
            // to close it.
            //
            hDevParamsKey = NULL;

            //
            // Setup our pointer for retrieval of per-hw-id value...
            //
            PerHwIdBuffer = Buffer;
            PerHwIdBufferLen = *pulLength;

            //
            // Setup our default return values in case no per-hw-id data is
            // found...
            //
            Status = CR_NO_SUCH_VALUE;
            RequiredSize = 0;
        }

        //
        // From this point on use PerHwIdBuffer/PerHwIdBufferLen instead of
        // caller-supplied Buffer/pulLength, since we may be appending results
        // to those retrieved from the devnode's "Device Parameters" subkey...
        //

        //
        // If we get to here, then we need to go look for the value under
        // the appropriate per-hw-id registry key.  First, figure out whether
        // the per-hw-id information has changed since we last cached the
        // most appropriate key.
        //
        RegDataSize = sizeof(LastUpdateTime);

        if((ERROR_SUCCESS != RegQueryValueEx(ghPerHwIdKey,
                                             pszRegValueLastUpdateTime,
                                             NULL,
                                             &RegDataType,
                                             (PBYTE)&LastUpdateTime,
                                             &RegDataSize))
           || (RegDataType != REG_BINARY)
           || (RegDataSize != sizeof(FILETIME))) {

            //
            // We can't ascertain when (or even if) the per-hw-id database was
            // last populated.  At this point, we bail with whatever status we
            // had after our attempt at retrieving the per-devnode property.
            //
            goto Clean0;
        }

        //
        // (RegDataSize is already set appropriately, no need to initialize it
        // again)
        //
        if(ERROR_SUCCESS == RegQueryValueEx(hDevKey,
                                            pszRegValueCustomPropertyCacheDate,
                                            NULL,
                                            &RegDataType,
                                            (PBYTE)&CacheDate,
                                            &RegDataSize)) {
            //
            // Just to be extra paranoid...
            //
            if((RegDataType != REG_BINARY) || (RegDataSize != sizeof(FILETIME))) {
                ZeroMemory(&CacheDate, sizeof(CacheDate));
            }

        } else {
            ZeroMemory(&CacheDate, sizeof(CacheDate));
        }

        if(CompareFileTime(&CacheDate, &LastUpdateTime) == 0) {
            //
            // The Per-Hw-Id database hasn't been updated since we cached away
            // the most-appropriate hardware id subkey.  We can now use this
            // subkey to see if there's a per-hw-id value entry contained
            // therein for the requested property.
            //
            RegDataSize = sizeof(PerHwIdSubkeyName);

            if(ERROR_SUCCESS != RegQueryValueEx(hDevKey,
                                                pszRegValueCustomPropertyHwIdKey,
                                                NULL,
                                                &RegDataType,
                                                (PBYTE)PerHwIdSubkeyName,
                                                &RegDataSize)) {
                //
                // The value entry wasn't present, indicating there is no
                // applicable per-hw-id key.
                //
                goto Clean0;

            } else if(RegDataType != REG_SZ) {
                //
                // The data isn't a REG_SZ, like we expected.  This should never
                // happen, but if it does, go ahead and re-assess the key we
                // should be using.
                //
                *PerHwIdSubkeyName = L'\0';

            } else {
                //
                // We have a per-hw-id subkey to use.  Go ahead and attempt to
                // open it up here.  If we find someone has tampered with the
                // database and deleted this subkey, then we can at least go
                // re-evaluate below to see if we can find a new key that's
                // applicable for this devnode.
                //
                if(ERROR_SUCCESS != RegOpenKeyEx(ghPerHwIdKey,
                                                 PerHwIdSubkeyName,
                                                 0,
                                                 KEY_READ,
                                                 &hPerHwIdSubKey)) {

                    hPerHwIdSubKey = NULL;



                    *PerHwIdSubkeyName = L'\0';
                }
            }

        } else {
            //
            // Per-Hw-Id database has been updated since we last cached away
            // our custom property default key.  (Note: The only time CacheDate
            // could be _newer than_ LastUpdateTime would be when a previous
            // update was (re-)applied to the per-hw-id database.  In this case,
            // we'd want to re-assess the key we're using, since we always want
            // to be exactly in-sync with the current state of the database.
            //
            *PerHwIdSubkeyName = L'\0';
        }

        if(!(*PerHwIdSubkeyName)) {
            //
            // We need to look for a (new) per-hw-id key from which to retrieve
            // properties applicable for this device.
            //
            hPerHwIdSubKey = FindMostAppropriatePerHwIdSubkey(hDevKey,
                                                              KEY_READ,
                                                              PerHwIdSubkeyName,
                                                              &RegDataSize
                                                             );

            if(hPerHwIdSubKey) {

                RegStatus = RegSetValueEx(hDevKey,
                                          pszRegValueCustomPropertyHwIdKey,
                                          0,
                                          REG_SZ,
                                          (PBYTE)PerHwIdSubkeyName,
                                          RegDataSize * sizeof(WCHAR)  // need size in bytes
                                         );
            } else {

                RegStatus = RegDeleteKey(hDevKey,
                                         pszRegValueCustomPropertyHwIdKey
                                        );
            }

            if(RegStatus == ERROR_SUCCESS) {
                //
                // We successfully updated the cached per-hw-id key name.  Now
                // update the CustomPropertyCacheDate to reflect the date
                // associated with the per-hw-id database.
                //
                RegSetValueEx(hDevKey,
                              pszRegValueCustomPropertyCacheDate,
                              0,
                              REG_BINARY,
                              (PBYTE)&LastUpdateTime,
                              sizeof(LastUpdateTime)
                             );
            }

            if(!hPerHwIdSubKey) {
                //
                // We couldn't find an applicable per-hw-id key for this
                // devnode.
                //
                goto Clean0;
            }
        }

        //
        // If we get to here, we have a handle to the per-hw-id subkey from
        // which we can query the requested property.
        //
        RegDataSize = PerHwIdBufferLen; // remember buffer size prior to call

        RegStatus = RegQueryValueEx(hPerHwIdSubKey,
                                    CustomPropName,
                                    NULL,
                                    &RegDataType,
                                    PerHwIdBuffer,
                                    &PerHwIdBufferLen
                                   );

        if(RegStatus == ERROR_SUCCESS) {
            //
            // Again, we need to distinguish between the case where we
            // succeeded because we supplied a zero-length buffer (we call it
            // CR_BUFFER_SMALL) and the "real" success case.
            //
            if(RegDataSize == 0) {

                if(PerHwIdBufferLen != 0) {
                    Status = CR_BUFFER_SMALL;
                } else if(MergeMultiSzResult) {
                    //
                    // We already have the multi-sz results we retrieved from
                    // the devnode's "Device Parameters" subkey ready to return
                    // to the caller...
                    //
                    ASSERT(*pulRegDataType == REG_MULTI_SZ);
                    ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
                    ASSERT(RequiredSize >= sizeof(WCHAR));
                    ASSERT((Status != CR_SUCCESS) || (*pulTransferLen >= sizeof(WCHAR)));

                    goto Clean0;
                }

            } else {
                //
                // Our success was genuine.
                //
                Status = CR_SUCCESS;
            }

            //
            // It's possible that we're supposed to be merging results into a
            // multi-sz list, but didn't find a value under the devnode's
            // "Device Parameters" subkey.  Now that we have found a value
            // under the per-hw-id subkey, we need to ensure the data returned
            // is in multi-sz format.
            //
            if(!MergeMultiSzResult && (RequiredSize == 0)) {

                if((ulFlags & CM_CUSTOMDEVPROP_MERGE_MULTISZ) &&
                   ((RegDataType == REG_MULTI_SZ) || (RegDataType == REG_SZ))) {

                    MergeMultiSzResult = TRUE;
                    *pulRegDataType = REG_MULTI_SZ;
                    RequiredSize = sizeof(WCHAR);

                    if(RequiredSize > *pulLength) {
                        Status = CR_BUFFER_SMALL;
                    }
                }
            }

        } else {

            if(RegStatus == ERROR_MORE_DATA) {
                Status = CR_BUFFER_SMALL;
            } else {
                //
                // If we were merging results into our multi-sz list, ensure
                // that our list-terminating null didn't get blown away.
                //
                if(MergeMultiSzResult) {

                    if(RegDataSize != 0) {
                        *((LPWSTR)PerHwIdBuffer) = L'\0';
                    }

                    //
                    // We already have the multi-sz results we retrieved from
                    // the devnode's "Device Parameters" subkey ready to return
                    // to the caller...
                    //
                    ASSERT(*pulRegDataType == REG_MULTI_SZ);
                    ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
                    ASSERT(RequiredSize >= sizeof(WCHAR));
                    ASSERT((Status != CR_SUCCESS) || (*pulTransferLen >= sizeof(WCHAR)));

                } else {
                    ASSERT(Status == CR_NO_SUCH_VALUE);
                    ASSERT(*pulTransferLen == 0);
                }

                goto Clean0;
            }
        }

        if(!MergeMultiSzResult) {

            *pulRegDataType = RegDataType;
            RequiredSize = PerHwIdBufferLen;

            if(Status == CR_SUCCESS) {
                //
                // We have data to transfer.
                //
                *pulTransferLen = RequiredSize;
            }

        } else {

            ASSERT(*pulRegDataType == REG_MULTI_SZ);
            ASSERT((Status == CR_SUCCESS) || (Status == CR_BUFFER_SMALL));
            ASSERT(RequiredSize >= sizeof(WCHAR));

            //
            // Unless the buffer size we retrieved is greater than one Unicode
            // character, it isn't going to affect the resultant size of our
            // multi-sz list.
            //
            if(PerHwIdBufferLen <= sizeof(WCHAR)) {
                ASSERT((Status != CR_BUFFER_SMALL) || (*pulTransferLen == 0));
                goto Clean0;
            }

            if(Status == CR_BUFFER_SMALL) {
                //
                // We might've previously believed that we could return data to
                // the caller (e.g., because the data retrieved  from the
                // devnode's "Device Parameters" subkey fit into our buffer.
                // Now that we see the data isn't going to fit, we need to
                // ensure that *pulTransferLen is zero to indicate no data is
                // being returned.
                //
                *pulTransferLen = 0;

                if(RegDataType == REG_MULTI_SZ) {
                    //
                    // Just want the lengths of the string(s) plus
                    // their terminating nulls, excluding list-
                    // terminating null char.
                    //
                    RequiredSize += (PerHwIdBufferLen - sizeof(WCHAR));

                } else if(RegDataType == REG_SZ) {
                    //
                    // We can just add the size of this string into our
                    // total requirement (unless it's an empty string,
                    // in which case we don't need to do anything at
                    // all).
                    //
                    RequiredSize += PerHwIdBufferLen;

                } else {
                    //
                    // per-hw-id data wasn't a REG_SZ or REG_MULTI_SZ, so
                    // ignore it.
                    //
                    goto Clean0;
                }

            } else {
                //
                // We succeeded in retrieving more data into our multi-sz list.
                // If the data we retrieved is multi-sz, then we don't have any
                // additional work to do.  However, if we retrieved a simple
                // REG_SZ, then we need to find the end of the string, and add
                // a second list-terminating null.
                //
                if(RegDataType == REG_MULTI_SZ) {

                    RequiredSize += (PerHwIdBufferLen - sizeof(WCHAR));

                } else if(RegDataType == REG_SZ) {

                    RegDataSize = lstrlen((LPWSTR)PerHwIdBuffer) + 1;

                    if((RegDataSize == 1) ||
                       ((RegDataSize * sizeof(WCHAR)) > PerHwIdBufferLen)) {
                        //
                        // The string we retrieved is either (a) empty or
                        // (b) longer than the buffer (the latter indicating
                        // that the string wasn't properly null-terminated).
                        // In either case, we don't want to append anything to
                        // our existing result, but we do need to ensure our
                        // list-terminating null character is still there...
                        //
                        *((LPWSTR)PerHwIdBuffer) = L'\0';

                    } else {
                        //
                        // Compute total size requirement..
                        //
                        RequiredSize += (RegDataSize * sizeof(WCHAR));

                        if(RequiredSize > *pulLength) {
                            //
                            // Adding the list-terminating null character
                            // pushed us over the size of the caller-
                            // supplied buffer. :-(
                            //
                            Status = CR_BUFFER_SMALL;
                            *pulTransferLen = 0;
                            goto Clean0;

                        } else {
                            //
                            // Add list-terminating null character...
                            //
                            *((LPWSTR)PerHwIdBuffer + RegDataSize) = L'\0';
                        }
                    }

                } else {
                    //
                    // per-hw-id data wasn't a REG_SZ or a REG_MULTI_SZ, so
                    // ignore it.  (Make sure, though, that we still have our
                    // final terminating null character.)
                    //
                    *((LPWSTR)PerHwIdBuffer) = L'\0';
                }

                *pulTransferLen = RequiredSize;
            }
        }

    Clean0:

        if (ARGUMENT_PRESENT(pulLength)) {
            *pulLength = RequiredSize;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
        //
        // force compiler to respect statement ordering w.r.t. assignments
        // for these variables...
        //
        hDevKey = hDevKey;
        hDevParamsKey = hDevParamsKey;
        hPerHwIdSubKey = hPerHwIdSubKey;
    }

    if(hDevKey != NULL) {
        RegCloseKey(hDevKey);
    }
    if(hDevParamsKey != NULL) {
        RegCloseKey(hDevParamsKey);
    }
    if(hPerHwIdSubKey != NULL) {
        RegCloseKey(hPerHwIdSubKey);
    }

    return Status;

} // PNP_GetCustomDevProp



HKEY
FindMostAppropriatePerHwIdSubkey(
    IN  HKEY    hDevKey,
    IN  REGSAM  samDesired,
    OUT LPWSTR  PerHwIdSubkeyName,
    OUT LPDWORD PerHwIdSubkeyLen
    )

/*++

Routine Description:

    This routine finds the subkey in the per-hw-id database that is most
    appropriate for the device whose instance key was passed as input.  This
    determination is made by taking each of the device's hardware and
    compatible ids, in turn, and forming a subkey name by replacing backslashes
    (\) with hashes (#).  An attempt is made to open that subkey under the
    per-hw-id key, and the first such id to succeed, if any, is the most
    appropriate (i.e., most-specific) database entry.

    Note: we must consider both hardware and compatible ids, because some buses
    (such as PCI) may shift hardware ids down into the compatible id list under
    certain circumstances (e.g., PCI\VENxxxxDEVyyyy gets moved into the
    compatible list in the presence of subsys info).

Arguments:

    hDevKey           Supplies a handle to the device instance key for whom the
                      most-appropriate per-hw-id subkey is to be ascertained.

    samDesired        Supplies an access mask indicating the desired access
                      rights to the per-hw-id key being returned.

    PerHwIdSubkeyName Supplies a buffer (that must be at least
                      MAX_DEVNODE_ID_LEN characters in length) that, upon
                      success, receives the most-appropriate per-hw-id subkey
                      name.

    PerHwIdSubkeyLen  Supplies the address of a variable that, upon successful
                      return, receives the length of the subkey name (in
                      characters), including terminating NULL, stored into the
                      PerHwIdSubkeyName buffer.

Return Value:

   If the function succeeds, the return value is a handle to the most-
   appropriate per-hw-id subkey.

   If the function fails, the return value is NULL.

--*/

{
    DWORD i;
    DWORD RegDataType;
    PWCHAR IdList;
    HKEY hPerHwIdSubkey;
    PWSTR pCurId, pSrcChar, pDestChar;
    DWORD CurIdLen;
    DWORD idSize;
    WCHAR ids[REGSTR_VAL_MAX_HCID_LEN];

    //
    // Note:  we don't need to use structured exception handling in this
    // routine, since if we crash here (e.g., due to retrieval of a bogus
    // hardware or compatible id list), we won't leak any resource.  Thus, the
    // caller's try/except is sufficient.
    //

    //
    // First process the hardware id list, and if no appropriate match
    // found there, then examine the compatible id list.
    //
    for(i = 0; i < 2; i++) {

        idSize = sizeof(ids);
        if((ERROR_SUCCESS != RegQueryValueEx(hDevKey,
                                            (i ? pszRegValueCompatibleIDs
                                               : pszRegValueHardwareIDs),
                                            NULL,
                                            &RegDataType,
                                            (PBYTE)ids,
                                            &idSize))
           || (RegDataType != REG_MULTI_SZ)) {

            //
            // Missing or invalid id list--bail now.
            //
            return NULL;
        }
        IdList = ids;
        //
        // Now iterate through each id in our list, trying to open each one
        // in turn under the per-hw-id database key.
        //
        for(pCurId = IdList; *pCurId; pCurId += CurIdLen) {

            CurIdLen = lstrlen(pCurId) + 1;

            if(CurIdLen > MAX_DEVNODE_ID_LEN) {
                //
                // Bogus id in the list--skip it.
                //
                continue;
            }

            //
            // Transfer id into our subkey name buffer, converting path
            // separator characters ('\') to hashes ('#').
            //
            pSrcChar = pCurId;
            pDestChar = PerHwIdSubkeyName;

            do {
                *pDestChar = (*pSrcChar != L'\\') ? *pSrcChar : L'#';
                pDestChar++;
            } while(*(pSrcChar++));

            if(ERROR_SUCCESS == RegOpenKeyEx(ghPerHwIdKey,
                                             PerHwIdSubkeyName,
                                             0,
                                             samDesired,
                                             &hPerHwIdSubkey)) {
                //
                // We've found our key!
                //
                *PerHwIdSubkeyLen = CurIdLen;
                return hPerHwIdSubkey;
            }
        }
    }

    //
    // If we get to here, we didn't find an appropriate per-hw-id subkey to
    // return to the caller.
    //
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\revent.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    revent.c

Abstract:

    This module contains the server-side misc configuration manager routines.

Author:

    Paula Tomlinson (paulat) 6-28-1995

Environment:

    User-mode only.

Revision History:

    28-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"
#include "pnpipc.h"
#include "pnpmsg.h"
#include "setupapi.h"
#include "spapip.h"

#include <wtsapi32.h>
#include <winsta.h>
#include <userenv.h>
#include <syslib.h>

#include <initguid.h>
#include <winioctl.h>
#include <ntddpar.h>
#include <pnpmgr.h>
#include <wdmguid.h>
#include <ioevent.h>
#include <devguid.h>
#include <winsvcp.h>

//
// Maximum number of times (per pass) we will reenumerate the device tree during 
// GUI setup in an attempt to find and install new devices.
//
#define MAX_REENUMERATION_COUNT 128

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


//
// Private interface device class that is used to register for all devnode change
// notifications. This is no longer supported, but we want to fail anyone who registers
// this GUID.
//
DEFINE_GUID(GUID_DEVNODE_CHANGE, 0xfa1fb208L, 0xf892, 0x11d0, 0x8a, 0x2e, 0x00, 0x00, 0xf8, 0x75, 0x3f, 0x55);


//
// Private interface device class that is assigned to entries registered for
// device interface change notifications, using the
// DEVICE_NOTIFY_ALL_INTERFACE_CLASSES flag.  For internal use only.
//
DEFINE_GUID(GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
            0x2121db68, 0x0993, 0x4a29, 0xb8, 0xe0, 0x1e, 0x51, 0x9c, 0x43, 0x72, 0xe6);


//
// SessionId 0 is the main session, and is always created during system startup
// and remains until system shutdown, whether or not terminal services is
// running.  This session always hosts services.exe and all services, so it is
// the only session that our ConsoleCtrlHandler can receive events for.
//
#define MAIN_SESSION      ((ULONG) 0)
#define INVALID_SESSION   ((ULONG)-1)

//
// The active console session is the session currently connected to the physical
// Console.  We store this value in a global variable, whose access is
// controlled by an event.  The routine GetActiveConsoleSessionId() is used to
// retrieve the value when it is safe to do so.
//
// Note that SessionId 0 is the initial console session, and that the
// SessionNotificationHandler is responsible for maintaining state.
//
ULONG   gActiveConsoleSessionId     = MAIN_SESSION; // system always starts with session 0
HANDLE  ghActiveConsoleSessionEvent = NULL;         // nonsignaled while session change is in progress


//
// We always use DeviceEventWorker and BroadcastSystemMessage to deliver
// notification to windows in SessionId 0.  For all other sessions, we use
// WinStationSendWindowMessage and WinStationBroadcastSystemMessage.
// These are the timeout period (in seconds) for messages sent and broadcast to
// sessions other than SessionId 0.  These times should be the same as those
// implemented by their SessionId 0 counterparts.
//
#define DEFAULT_SEND_TIME_OUT     30 // same as DeviceEventWorker
#define DEFAULT_BROADCAST_TIME_OUT 5 // same as BroadcastSystemMessage


//
// Notification list structure.
//
typedef struct _PNP_NOTIFY_LIST {
    PVOID    Next;
    PVOID    Previous;
    LOCKINFO Lock;
} PNP_NOTIFY_LIST, *PPNP_NOTIFY_LIST;

//
// Notification entry structure.
//
typedef struct _PNP_NOTIFY_ENTRY {
    PVOID   Next;
    PVOID   Previous;
    BOOL    Unregistered;
    ULONG   Signature;
    HANDLE  Handle;
    DWORD   Flags;
    ULONG   SessionId;
    ULONG   Freed;
    ULONG64 ClientCtxPtr;
    LPWSTR  ClientName;

    union {
        struct {
            GUID ClassGuid;
        } Class;

        struct {
            HANDLE FileHandle;
            WCHAR  DeviceId[MAX_DEVICE_ID_LEN];
        } Target;

        struct {
            DWORD Reserved;
        } Devnode;

        struct {
            DWORD scmControls;
        } Service;

    } u;

} PNP_NOTIFY_ENTRY, *PPNP_NOTIFY_ENTRY;


//
// Deferred operation list structure.
//
typedef struct _PNP_DEFERRED_LIST {
    PVOID       Next;
    handle_t    hBinding;
    PPNP_NOTIFY_ENTRY Entry;
} PNP_DEFERRED_LIST, *PPNP_DEFERRED_LIST;


//
// Signatures describing which notification list an entry currently belongs to.
//
#define CLASS_ENTRY_SIGNATURE       (0x07625100)
#define TARGET_ENTRY_SIGNATURE      (0x17625100)
#define SERVICE_ENTRY_SIGNATURE     (0x37625100)
#define LIST_ENTRY_SIGNATURE_MASK   (0xFFFFFF00)
#define LIST_ENTRY_INDEX_MASK       (~LIST_ENTRY_SIGNATURE_MASK)

#define MarkEntryWithList(ent,value) { ent->Signature &= LIST_ENTRY_SIGNATURE_MASK;\
                                       ent->Signature |= value; }


//
// Device event notification lists.
//
#define TARGET_HASH_BUCKETS         13
#define CLASS_GUID_HASH_BUCKETS     13
#define SERVICE_NUM_CONTROLS        3

#define HashClassGuid(_Guid) \
            ( ( ((PULONG)_Guid)[0] + ((PULONG)_Guid)[1] + ((PULONG)_Guid)[2] \
                + ((PULONG)_Guid)[3]) % CLASS_GUID_HASH_BUCKETS)

PNP_NOTIFY_LIST TargetList[TARGET_HASH_BUCKETS];
PNP_NOTIFY_LIST ClassList[CLASS_GUID_HASH_BUCKETS];
PNP_NOTIFY_LIST ServiceList[SERVICE_NUM_CONTROLS];

PPNP_DEFERRED_LIST UnregisterList;
PPNP_DEFERRED_LIST RegisterList;
PPNP_DEFERRED_LIST RundownList;

CRITICAL_SECTION RegistrationCS;


//
// These are indices into the global ServiceList array of lists containing
// services registered for the corresponding service control events.
//
enum cBitIndex {
    CINDEX_HWPROFILE  = 0,
    CINDEX_POWEREVENT = 1
};

//
// These are a bit mask for the above lists.
// (the two enums should match! One is 0,1,2,...n. The other 2^n.)
//
enum cBits {
    CBIT_HWPROFILE  = 1,
    CBIT_POWEREVENT = 2
};


//
// Properties describing how a notification entry was freed.
//

// (the entry has been removed from the notification list)
#define DEFER_NOTIFY_FREE   0x80000000

// (used for debugging only)
#define PNP_UNREG_FREE      0x00000100
#define PNP_UNREG_CLASS     0x00000200
#define PNP_UNREG_TARGET    0x00000400
#define PNP_UNREG_DEFER     0x00000800
#define PNP_UNREG_WIN       0x00001000
#define PNP_UNREG_SERVICE   0x00002000
#define PNP_UNREG_CANCEL    0x00004000
#define PNP_UNREG_RUNDOWN   0x00008000


//
// List of devices to be installed.
//
typedef struct _PNP_INSTALL_LIST {
    PVOID    Next;
    LOCKINFO Lock;
} PNP_INSTALL_LIST, *PPNP_INSTALL_LIST;

//
// Device install list entry structure.
//
typedef struct _PNP_INSTALL_ENTRY {
    PVOID   Next;
    DWORD   Flags;
    WCHAR   szDeviceId[MAX_DEVICE_ID_LEN];
} PNP_INSTALL_ENTRY, *PPNP_INSTALL_ENTRY;

//
// Install event list.
//
PNP_INSTALL_LIST InstallList;

//
// Flags for PNP_INSTALL_ENTRY nodes
//
#define PIE_SERVER_SIDE_INSTALL_ATTEMPTED    0x00000001
#define PIE_DEVICE_INSTALL_REQUIRED_REBOOT   0x00000002


//
// Device install client information list structure.
//
typedef struct _INSTALL_CLIENT_LIST {
    PVOID    Next;
    LOCKINFO Lock;
} INSTALL_CLIENT_LIST, *PINSTALL_CLIENT_LIST;

//
// Device install client information list entry structure.
//
typedef struct _INSTALL_CLIENT_ENTRY {
    PVOID   Next;
    ULONG   RefCount;
    ULONG   ulSessionId;
    HANDLE  hEvent;
    HANDLE  hPipe;
    HANDLE  hProcess;
    HANDLE  hDisconnectEvent;
    ULONG   ulInstallFlags;
    WCHAR   LastDeviceId[MAX_DEVICE_ID_LEN];
} INSTALL_CLIENT_ENTRY, *PINSTALL_CLIENT_ENTRY;

//
// Device install client list.
//
INSTALL_CLIENT_LIST InstallClientList;

//
// Global BOOL that tracks if a server side device install reboot is needed.
//
BOOL gServerSideDeviceInstallRebootNeeded = FALSE;


//
// private prototypes
//
DWORD
ThreadProc_DeviceEvent(
    LPDWORD lpParam
    );
DWORD
ThreadProc_DeviceInstall(
    LPDWORD lpParam
    );
DWORD
ThreadProc_GuiSetupDeviceInstall(
    LPDWORD lpThreadParam
    );
DWORD
ThreadProc_FactoryPreinstallDeviceInstall(
    LPDWORD lpThreadParam
    );
DWORD
ThreadProc_ReenumerateDeviceTree(
    LPVOID  lpThreadParam
    );
BOOL
InstallDevice(
    IN     LPWSTR pszDeviceId,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );
DWORD
InstallDeviceServerSide(
    IN     LPWSTR pszDeviceId,
    IN OUT PBOOL  RebootRequired,
    IN OUT PBOOL  DeviceHasProblem,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );
BOOL
CreateDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
ConnectDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
DisconnectDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
PINSTALL_CLIENT_ENTRY
LocateDeviceInstallClient(
    IN  ULONG     SessionId
    );
VOID
ReferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
VOID
DereferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    );
BOOL
DoDeviceInstallClient(
    IN  LPWSTR    DeviceId,
    IN  PULONG    SessionId,
    IN  ULONG     Flags,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    );
BOOL
InitNotification(
    VOID
    );
VOID
TermNotification(
    VOID
    );
ULONG
ProcessDeviceEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN DWORD                 EventBufferSize,
    OUT PPNP_VETO_TYPE       VetoType,
    OUT LPWSTR               VetoName,
    IN OUT PULONG            VetoNameLength
    );

ULONG
NotifyInterfaceClassChange(
    IN DWORD ServiceControl,
    IN DWORD EventId,
    IN DWORD Flags,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    );

ULONG
NotifyTargetDeviceChange(
    IN  DWORD                   ServiceControl,
    IN  DWORD                   EventId,
    IN  DWORD                   Flags,
    IN  PDEV_BROADCAST_HANDLE   HandleData,
    IN  LPWSTR                  DeviceId,
    OUT PPNP_VETO_TYPE          VetoType       OPTIONAL,
    OUT LPWSTR                  VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

ULONG
NotifyHardwareProfileChange(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

ULONG
NotifyPower(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                EventData,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    );

BOOL
SendCancelNotification(
    IN     PPNP_NOTIFY_ENTRY    LastEntry,
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     ULONG                Flags,
    IN     PDEV_BROADCAST_HDR   NotifyData  OPTIONAL,
    IN     LPWSTR               DeviceId    OPTIONAL
    );

VOID
BroadcastCompatibleDeviceMsg(
    IN DWORD EventId,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    );
VOID
BroadcastVolumeNameChange(
    VOID
    );
DWORD
GetAllVolumeMountPoints(
    VOID
    );

BOOL
EventIdFromEventGuid(
    IN CONST GUID *EventGuid,
    OUT LPDWORD   EventId,
    OUT LPDWORD   Flags,
    OUT LPDWORD   ServiceControl
    );

ULONG
SendHotplugNotification(
    IN CONST GUID           *EventGuid,
    IN       PPNP_VETO_TYPE  VetoType      OPTIONAL,
    IN       LPWSTR          MultiSzList,
    IN OUT   PULONG          SessionId,
    IN       ULONG           Flags
    );

BOOL
GuidEqual(
    CONST GUID UNALIGNED *Guid1,
    CONST GUID UNALIGNED *Guid2
    );

VOID
LogErrorEvent(
    DWORD dwEventID,
    DWORD dwError,
    WORD  nStrings,
    ...
    );

VOID
LogWarningEvent(
    DWORD dwEventID,
    WORD  nStrings,
    ...
    );

BOOL
LockNotifyList(
    IN LOCKINFO *Lock
    );
VOID
UnlockNotifyList(
    IN LOCKINFO *Lock
    );
PPNP_NOTIFY_LIST
GetNotifyListForEntry(
    IN PPNP_NOTIFY_ENTRY entry
    );
BOOL
DeleteNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN BOOLEAN RpcNotified
    );
VOID
AddNotifyEntry(
    IN PPNP_NOTIFY_LIST  NotifyList,
    IN PPNP_NOTIFY_ENTRY NewEntry
    );
ULONG
HashString(
    IN LPWSTR String,
    IN ULONG  Buckets
    );
DWORD
MapQueryEventToCancelEvent(
    IN DWORD QueryEventId
    );
VOID
FixUpDeviceId(
    IN OUT LPTSTR  DeviceId
    );

ULONG
MapSCMControlsToControlBit(
    IN ULONG scmControls
    );

DWORD
GetFirstPass(
    IN BOOL     bQuery
    );

DWORD
GetNextPass(
    IN DWORD    curPass,
    IN BOOL     bQuery
    );

BOOL
NotifyEntryThisPass(
    IN     PPNP_NOTIFY_ENTRY    Entry,
    IN     DWORD                Pass
    );

DWORD
GetPassFromEntry(
    IN     PPNP_NOTIFY_ENTRY    Entry
    );

BOOL
GetClientName(
    IN  PPNP_NOTIFY_ENTRY entry,
    OUT LPWSTR  lpszClientName,
    IN OUT PULONG  pulClientNameLength
    );

BOOL
GetWindowsExeFileName(
    IN  HWND      hWnd,
    OUT LPWSTR    lpszFileName,
    IN OUT PULONG pulFileNameLength
    );

PPNP_NOTIFY_ENTRY
GetNextNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN DWORD Flags
    );

PPNP_NOTIFY_ENTRY
GetFirstNotifyEntry(
    IN PPNP_NOTIFY_LIST List,
    IN DWORD Flags
    );

BOOL
InitializeHydraInterface(
    VOID
    );

DWORD
LoadDeviceInstaller(
    VOID
    );

VOID
UnloadDeviceInstaller(
    VOID
    );

BOOL
PromptUser(
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    );

VOID
DoRunOnce(
    VOID
    );

BOOL
GetSessionUserToken(
    IN  ULONG     ulSessionId,
    OUT LPHANDLE  lphUserToken
    );

BOOL
IsUserLoggedOnSession(
    IN  ULONG     ulSessionId
    );

BOOL
IsSessionConnected(
    IN  ULONG     ulSessionId
    );

BOOL
IsSessionLocked(
    IN  ULONG    ulSessionId
    );

BOOL
IsConsoleSession(
    IN  ULONG     ulSessionId
    );

DWORD
CreateUserSynchEvent(
    IN  LPCWSTR lpName,
    OUT HANDLE *phEvent
    );

BOOL
CreateNoPendingInstallEvent(
    VOID
    );

ULONG
CheckEjectPermissions(
    IN      LPWSTR          DeviceId,
    OUT     PPNP_VETO_TYPE  VetoType            OPTIONAL,
    OUT     LPWSTR          VetoName            OPTIONAL,
    IN OUT  PULONG          VetoNameLength      OPTIONAL
    );

VOID
LogSurpriseRemovalEvent(
    IN  LPWSTR  MultiSzList
    );

PWCHAR
BuildFriendlyName(
    IN  LPWSTR   InstancePath
    );

CONFIGRET
DevInstNeedsInstall(
    IN  LPCWSTR     DevInst,
    OUT BOOL       *NeedsInstall
    );

PWSTR
BuildBlockedDriverList(
    IN OUT LPGUID  GuidList,
    IN     ULONG   GuidCount
    );

//
// global data
//

extern HANDLE ghInst;         // Module handle
extern HKEY   ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY   ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern HKEY   ghClassKey;     // Key to HKLM\CCC\System\Class - DO NOT MODIFY
extern DWORD  CurrentServiceState;  // PlugPlay service state - DO NOT MODIFY

HANDLE        ghInitMutex = NULL;
HANDLE        ghUserToken = NULL;
LOCKINFO      gTokenLock;
BOOL          gbMainSessionLocked = FALSE;

ULONG         gNotificationInProg = 0; // 0 -> No notification or unregister underway.
DWORD         gAllDrivesMask = 0;      // bitmask of all physical volume mountpoints.
BOOL          gbSuppressUI = FALSE;    // TRUE if PNP should never display UI (newdev, hotplug).
BOOL          gbOobeInProgress = FALSE;// TRUE if the OOBE is running during this boot.



const TCHAR RegMemoryManagementKeyName[] =
      TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

const TCHAR RegVerifyDriverLevelValueName[] =
      TEXT("VerifyDriverLevel");


//
// Device Installer instance handle and necessary entrypoints.
// This data is only referenced by the (non-GUI setup) device install thread
// (ThreadProc_DeviceInstall).
//

typedef HDEVINFO (WINAPI *FP_CREATEDEVICEINFOLIST)(CONST GUID *, HWND);
typedef BOOL     (WINAPI *FP_OPENDEVICEINFO)(HDEVINFO, PCWSTR, HWND, DWORD, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_BUILDDRIVERINFOLIST)(HDEVINFO, PSP_DEVINFO_DATA, DWORD);
typedef BOOL     (WINAPI *FP_DESTROYDEVICEINFOLIST)(HDEVINFO);
typedef BOOL     (WINAPI *FP_CALLCLASSINSTALLER)(DI_FUNCTION, HDEVINFO, PSP_DEVINFO_DATA);
typedef BOOL     (WINAPI *FP_INSTALLCLASS)(HWND, PCWSTR, DWORD, HSPFILEQ);
typedef BOOL     (WINAPI *FP_GETSELECTEDDRIVER)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA);
typedef BOOL     (WINAPI *FP_GETDRIVERINFODETAIL)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA, PSP_DRVINFO_DETAIL_DATA, DWORD, PDWORD);
typedef BOOL     (WINAPI *FP_GETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_SETDEVICEINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DEVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_GETDRIVERINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_DRVINFO_DATA, PSP_DRVINSTALL_PARAMS);
typedef BOOL     (WINAPI *FP_SETCLASSINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_CLASSINSTALL_HEADER, DWORD);
typedef BOOL     (WINAPI *FP_GETCLASSINSTALLPARAMS)(HDEVINFO, PSP_DEVINFO_DATA, PSP_CLASSINSTALL_HEADER, DWORD, PDWORD);
typedef HINF     (WINAPI *FP_OPENINFFILE)(PCWSTR, PCWSTR, DWORD, PUINT);
typedef VOID     (WINAPI *FP_CLOSEINFFILE)(HINF);
typedef BOOL     (WINAPI *FP_FINDFIRSTLINE)(HINF, PCWSTR, PCWSTR, PINFCONTEXT);
typedef BOOL     (WINAPI *FP_FINDNEXTMATCHLINE)(PINFCONTEXT, PCWSTR, PINFCONTEXT);
typedef BOOL     (WINAPI *FP_GETSTRINGFIELD)(PINFCONTEXT, DWORD, PWSTR, DWORD, PDWORD);

typedef VOID              (*FP_SETGLOBALFLAGS)(DWORD);
typedef DWORD             (*FP_GETGLOBALFLAGS)(VOID);
typedef PPSP_RUNONCE_NODE (*FP_ACCESSRUNONCENODELIST)(VOID);
typedef VOID              (*FP_DESTROYRUNONCENODELIST)(VOID);

HINSTANCE ghDeviceInstallerLib = NULL;

FP_CREATEDEVICEINFOLIST   fpCreateDeviceInfoList;
FP_OPENDEVICEINFO         fpOpenDeviceInfo;
FP_BUILDDRIVERINFOLIST    fpBuildDriverInfoList;
FP_DESTROYDEVICEINFOLIST  fpDestroyDeviceInfoList;
FP_CALLCLASSINSTALLER     fpCallClassInstaller;
FP_INSTALLCLASS           fpInstallClass;
FP_GETSELECTEDDRIVER      fpGetSelectedDriver;
FP_GETDRIVERINFODETAIL    fpGetDriverInfoDetail;
FP_GETDEVICEINSTALLPARAMS fpGetDeviceInstallParams;
FP_SETDEVICEINSTALLPARAMS fpSetDeviceInstallParams;
FP_GETDRIVERINSTALLPARAMS fpGetDriverInstallParams;
FP_SETCLASSINSTALLPARAMS  fpSetClassInstallParams;
FP_GETCLASSINSTALLPARAMS  fpGetClassInstallParams;
FP_OPENINFFILE            fpOpenInfFile;
FP_CLOSEINFFILE           fpCloseInfFile;
FP_FINDFIRSTLINE          fpFindFirstLine;
FP_FINDNEXTMATCHLINE      fpFindNextMatchLine;
FP_GETSTRINGFIELD         fpGetStringField;
FP_SETGLOBALFLAGS         fpSetGlobalFlags;
FP_GETGLOBALFLAGS         fpGetGlobalFlags;
FP_ACCESSRUNONCENODELIST  fpAccessRunOnceNodeList;
FP_DESTROYRUNONCENODELIST fpDestroyRunOnceNodeList;

//
// typdef for comctl32's DestroyPropertySheetPage API, needed in cases where
// class-/co-installers supply wizard pages (that need to be destroyed).
//
typedef BOOL (WINAPI *FP_DESTROYPROPERTYSHEETPAGE)(HPROPSHEETPAGE);

//
// typedefs for ANSI and Unicode variants of rundll32 proc entrypoint.
//
typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hInstance, LPSTR pszCmdLine, int nCmdShow);
typedef void (WINAPI *RUNDLLPROCW)(HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow);

//
// typedefs for Terminal Services message dispatch routines, in winsta.dll.
//

typedef LONG (*FP_WINSTABROADCASTSYSTEMMESSAGE)(
    HANDLE  hServer,
    BOOL    sendToAllWinstations,
    ULONG   sessionID,
    ULONG   timeOut,
    DWORD   dwFlags,
    DWORD   *lpdwRecipients,
    ULONG   uiMessage,
    WPARAM  wParam,
    LPARAM  lParam,
    LONG    *pResponse
    );

typedef LONG (*FP_WINSTASENDWINDOWMESSAGE)(
    HANDLE  hServer,
    ULONG   sessionID,
    ULONG   timeOut,
    ULONG   hWnd,
    ULONG   Msg,
    WPARAM  wParam,
    LPARAM  lParam,
    LONG    *pResponse
    );

typedef BOOLEAN (WINAPI * FP_WINSTAQUERYINFORMATIONW)(
    HANDLE  hServer,
    ULONG   LogonId,
    WINSTATIONINFOCLASS WinStationInformationClass,
    PVOID   pWinStationInformation,
    ULONG   WinStationInformationLength,
    PULONG  pReturnLength
    );


HINSTANCE ghWinStaLib = NULL;
FP_WINSTASENDWINDOWMESSAGE fpWinStationSendWindowMessage = NULL;
FP_WINSTABROADCASTSYSTEMMESSAGE fpWinStationBroadcastSystemMessage = NULL;
FP_WINSTAQUERYINFORMATIONW fpWinStationQueryInformationW = NULL;

//
// typedefs for Terminal Services support routines, in wtsapi32.dll.
//

typedef BOOL (*FP_WTSQUERYSESSIONINFORMATION)(
    IN HANDLE hServer,
    IN DWORD SessionId,
    IN WTS_INFO_CLASS WTSInfoClass,
    OUT LPWSTR * ppBuffer,
    OUT DWORD * pBytesReturned
    );

typedef VOID (*FP_WTSFREEMEMORY)(
    IN PVOID pMemory
    );

HINSTANCE ghWtsApi32Lib = NULL;
FP_WTSQUERYSESSIONINFORMATION fpWTSQuerySessionInformation = NULL;
FP_WTSFREEMEMORY fpWTSFreeMemory = NULL;


//
// Service controller callback routines for authentication and notification to
// services.
//

PSCMCALLBACK_ROUTINE pServiceControlCallback;
PSCMAUTHENTICATION_CALLBACK pSCMAuthenticate;


//
// Device install events
//

#define NUM_INSTALL_EVENTS      2
#define LOGGED_ON_EVENT         0
#define NEEDS_INSTALL_EVENT     1

HANDLE InstallEvents[NUM_INSTALL_EVENTS] = {NULL, NULL};
HANDLE ghNoPendingInstalls = NULL;


//
// Veto definitions
//

#define UnknownVeto(t,n,l) { *(t) = PNP_VetoTypeUnknown; }

#define WinBroadcastVeto(h,t,n,l) { *(t) = PNP_VetoWindowsApp;\
                         GetWindowsExeFileName(h,n,l); }

#define WindowVeto(e,t,n,l) { *(t) = PNP_VetoWindowsApp;\
                         GetClientName(e,n,l); }

#define ServiceVeto(e,t,n,l) { *(t) = PNP_VetoWindowsService;\
                         GetClientName(e,n,l); }

//
// Sentinel for event loop control
//
#define PASS_COMPLETE 0x7fffffff


//---------------------------------------------------------------------------
// Debugging interface - initiate detection through private debug interface
//---------------------------------------------------------------------------

CONFIGRET
PNP_InitDetection(
    handle_t   hBinding
    )

/*++

Routine Description:

    This routine is a private debugging interface to initiate device detection.

Arguments:

    hBinding - RPC binding handle, not used.

Return Value:

    Currently returns CR_SUCCESS.

Notes:

    Previously, this routine would kick off the InitializePnPManager thread on
    checked builds only.

    Presumably, this dates way back to a time when this routine actually sought
    out non-configured devices and initiated installation on them (as is
    currently done at the start of the ThreadProc_DeviceInstall thread procedure
    routine).

    Since InitializePnPManager no longer does this, so this behavior has been
    removed altogether.  It is currently never valid to perform initialization
    more than once, however this routine may be used to implement detection of
    non-configured devices.

--*/

{
    UNREFERENCED_PARAMETER(hBinding);

    return CR_SUCCESS;

} // PNP_InitDetection



BOOL
PnpConsoleCtrlHandler(
    DWORD dwCtrlType
    )
/*++

Routine Description:

    This routine handles control signals received by the process for the
    session the process is associated with.

Arguments:

    dwCtrlType - Indicates the type of control signal received by the handler.
                 This value is one of the following:  CTRL_C_EVENT, CTRL_BREAK_EVENT,
                 CTRL_CLOSE_EVENT, CTRL_LOGOFF_EVENT, CTRL_SHUTDOWN_EVENT


Return Value:

    If the function handles the control signal, it should return TRUE. If it
    returns FALSE, the next handler function in the list of handlers for this
    process is used.

--*/
{
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient;

    switch (dwCtrlType) {

    case CTRL_LOGOFF_EVENT:
        //
        // The system sends the logoff event to the registered console ctrl
        // handlers for a console process when a user is logging off from the
        // session associated with that process.  Since UMPNPMGR runs within the
        // context of the services.exe process, which always resides in session
        // 0, that is the only session for which this handler will receive
        // logoff events.
        //
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: PnpConsoleCtrlHandler: CTRL_LOGOFF_EVENT: Session %d\n",
                   MAIN_SESSION));

        //
        // Close the handle to the user access token for the main session.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken) {
            CloseHandle(ghUserToken);
            ghUserToken = NULL;
        }
        UnlockPrivateResource(&gTokenLock);

        //
        // If the main session was the active Console session, (or should be
        // treated as the active console session because Fast User Switching is
        // disabled) when the user logged off, reset the "logged on" event.
        //
        if (IsConsoleSession(MAIN_SESSION)) {
            if (InstallEvents[LOGGED_ON_EVENT]) {
                ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_EVENT,
                           "UMPNPMGR: PnpConsoleCtrlHandler: CTRL_LOGOFF_EVENT: ResetEvent LOGGED_ON_EVENT\n"));
            }
        }

        //
        // If we currently have a device install UI client on this session,
        // we should attempt to close it now, before logging off.
        //
        LockNotifyList(&InstallClientList.Lock);
        pDeviceInstallClient = LocateDeviceInstallClient(MAIN_SESSION);
        if (pDeviceInstallClient) {
            DereferenceDeviceInstallClient(pDeviceInstallClient);
        }
        UnlockNotifyList(&InstallClientList.Lock);

        break;

    default:
        //
        // No special processing for any other events.
        //
        break;

    }

    //
    // Returning FALSE passes this control to the next registered CtrlHandler in
    // the list of handlers for this process (services.exe), so that other
    // services will get a chance to look at this.
    //
    return FALSE;

} // PnpConsoleCtrlHandler



DWORD
InitializePnPManager(
   LPDWORD lpParam
   )
/*++

Routine Description:

  This thread routine is created from srventry.c when services.exe
  attempts to start the plug and play service. The init routine in
  srventry.c does critical initialize then creates this thread to
  do pnp initialization so that it can return back to the service
  controller before pnp init completes.

Arguments:

   lpParam - Not used.


Return Value:

   Currently returns TRUE/FALSE.

--*/
{
    DWORD       dwStatus = TRUE;
    DWORD       ThreadID = 0;
    HANDLE      hThread = NULL, hEventThread = NULL;
    HKEY        hKey = NULL;
    LONG        status;
    BOOL        bGuiModeSetup = FALSE, bFactoryPreInstall = FALSE;
    ULONG       ulSize, ulValue;

    UNREFERENCED_PARAMETER(lpParam);

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_EVENT,
               "UMPNPMGR: InitializePnPManager\n"));

    //
    // Initialize events that will control when to install devices later.
    //
    InstallEvents[LOGGED_ON_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (InstallEvents[LOGGED_ON_EVENT] == NULL) {
        LogErrorEvent(ERR_CREATING_LOGON_EVENT, GetLastError(), 0);
    }

    InstallEvents[NEEDS_INSTALL_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (InstallEvents[NEEDS_INSTALL_EVENT] == NULL) {
        LogErrorEvent(ERR_CREATING_INSTALL_EVENT, GetLastError(), 0);
    }

    //
    // Create the pending install event.
    //
    if (!CreateNoPendingInstallEvent()) {
        LogErrorEvent(ERR_CREATING_PENDING_INSTALL_EVENT, GetLastError(), 0);
    }

    ASSERT(ghNoPendingInstalls != NULL);

    //
    // Initialize event to control access to the current session during session
    // change events.  The event state is initially signalled since this service
    // initializes when only session 0 exists (prior to the initialization of
    // termsrv, or the creation of any other sessions).
    //
    ghActiveConsoleSessionEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (ghActiveConsoleSessionEvent == NULL) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: Failed to initialize ghActiveConsoleSessionEvent!!, error = %d\n",
                   GetLastError()));
    }

    //
    // Setup a console control handler so that I can keep track of logoffs to
    // the main session (SessionId 0).  This is still necessary because Terminal
    // Services may not always be available. (see PNP_ReportLogOn).
    // (I only get logoff notification via this handler so I still
    // rely on the kludge in userinit.exe to tell me about logons).
    //
    if (!SetConsoleCtrlHandler(PnpConsoleCtrlHandler, TRUE)) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT | DBGF_ERRORS,
                   "UMPNPMGR: SetConsoleCtrlHandler failed, error = %d\n",
                   GetLastError()));
    }

    //
    // acquire a mutex now to make sure I get through this
    // initialization task before getting pinged by a logon
    //
    ghInitMutex = CreateMutex(NULL, TRUE, PNP_INIT_MUTEX);
    if (ghInitMutex == NULL) {
        ASSERT(0);
        return FALSE;
    }

    try {
        //
        // Check if we're running during one of the assorted flavors of setup.
        //
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\Setup"),
                              0,
                              KEY_READ,
                              &hKey);

        if (status == ERROR_SUCCESS) {
            //
            // Determine if factory pre-install is in progress.
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     TEXT("FactoryPreInstallInProgress"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                bFactoryPreInstall = TRUE;
                gbSuppressUI = TRUE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_EVENT,
                           "UMPNPMGR: Will suppress all UI in Factory Mode\n"));
                LogWarningEvent(WRN_FACTORY_UI_SUPPRESSED, 0, NULL);
            }

            if (!bFactoryPreInstall) {
                //
                // Determine if Gui Mode Setup is in progress (but not mini-setup).
                //
                ulValue = 0;
                ulSize = sizeof(ulValue);
                status = RegQueryValueEx(hKey,
                                         TEXT("SystemSetupInProgress"),
                                         NULL,
                                         NULL,
                                         (LPBYTE)&ulValue,
                                         &ulSize);

                if (status == ERROR_SUCCESS) {
                    bGuiModeSetup = (ulValue == 1);
                }

                if (bGuiModeSetup) {
                    //
                    // Well, we're in GUI-mode setup, but we need to make sure
                    // we're not in mini-setup, or factory pre-install.  We
                    // treat mini-setup like any other boot of the system, and
                    // factory pre-install is a delayed version of a normal
                    // boot.
                    //
                    ulValue = 0;
                    ulSize = sizeof(ulValue);
                    status = RegQueryValueEx(hKey,
                                             TEXT("MiniSetupInProgress"),
                                             NULL,
                                             NULL,
                                             (LPBYTE)&ulValue,
                                             &ulSize);

                    if ((status == ERROR_SUCCESS) && (ulValue == 1)) {
                        //
                        // Well, we're in mini-setup, but we need to make sure
                        // that he doesn't want us to do PnP re-enumeration.
                        //
                        ulValue = 0;
                        ulSize = sizeof(ulValue);
                        status = RegQueryValueEx(hKey,
                                                 TEXT("MiniSetupDoPnP"),
                                                 NULL,
                                                 NULL,
                                                 (LPBYTE)&ulValue,
                                                 &ulSize);

                        if ((status != ERROR_SUCCESS) || (ulValue == 0)) {
                            //
                            // Nope.  Treat this like any other boot of the
                            // system.
                            //
                            bGuiModeSetup = FALSE;
                        }
                    }
                }
            }

            //
            // Determine if this is an OOBE boot.
            //
            ulValue = 0;
            ulSize = sizeof(ulValue);
            status = RegQueryValueEx(hKey,
                                     TEXT("OobeInProgress"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize);

            if (status == ERROR_SUCCESS) {
                gbOobeInProgress = (ulValue == 1);
            }

            //
            // Close the SYSTEM\Setup key.
            //
            RegCloseKey(hKey);
            hKey = NULL;

        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: Failure opening key SYSTEM\\Setup (%d)\n",
                       status));
        }

        //
        // If this is EmbeddedNT, check whether PNP should display UI.
        // Note that this is only checked once per system boot, when the
        // service is initialized.
        //
        if (IsEmbeddedNT()) {
            if (RegOpenKeyEx(ghServicesKey,
                             pszRegKeyPlugPlayServiceParams,
                             0,
                             KEY_READ,
                             &hKey) == ERROR_SUCCESS) {

                ulValue = 0;
                ulSize = sizeof(ulValue);

                if ((RegQueryValueEx(hKey,
                                     TEXT("SuppressUI"),
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize) == ERROR_SUCCESS) && (ulValue == 1)) {
                    gbSuppressUI = TRUE;
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_EVENT,
                               "UMPNPMGR: Will suppress all UI on EmbeddedNT\n"));
                    LogWarningEvent(WRN_EMBEDDEDNT_UI_SUPPRESSED, 0, NULL);
                }
                RegCloseKey(hKey);
            }
        }

        //
        // Initialize the interfaces to Hydra, if Hydra is running on this system.
        //
        if (IsTerminalServer()) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: Initializing interfaces to Terminal Services.\n"));
            if (!InitializeHydraInterface()) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_EVENT,
                           "UMPNPMGR: Failed to initialize interfaces to Terminal Services!\n"));
            }
        }

        //
        // Initialize the global drive letter mask
        //
        gAllDrivesMask = GetAllVolumeMountPoints();

        //
        // Create a thread that monitors device events.
        //
        hEventThread = CreateThread(NULL,
                                    0,
                                    (LPTHREAD_START_ROUTINE)ThreadProc_DeviceEvent,
                                    NULL,
                                    0,
                                    &ThreadID);

        //
        // Create the appropriate thread to handle the device installation.
        // The two cases are when gui mode setup is in progress and for
        // a normal user boot case.
        //

        if (bFactoryPreInstall)  {
            //
            // FactoryPreInstallInProgress
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_FactoryPreinstallDeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        } else if (bGuiModeSetup) {
            //
            // SystemSetupInProgress,
            // including MiniSetupInProgress with MiniSetupDoPnP
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_GuiSetupDeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        } else {
            //
            // Standard system boot, or
            // SystemSetupInProgress with MiniSetupInProgress (but not MiniSetupDoPnP)
            //
            hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_DeviceInstall,
                                   NULL,
                                   0,
                                   &ThreadID);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in InitializePnPManager!\n"));
        ASSERT(0);
        dwStatus = FALSE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        hThread = hThread;
        hEventThread = hEventThread;
    }

    //
    // signal the init mutex so that logon init activity can procede
    //
    ReleaseMutex(ghInitMutex);

    if (hThread != NULL) {
        CloseHandle(hThread);
    }
    if (hEventThread != NULL) {
        CloseHandle(hEventThread);
    }

    return dwStatus;

} // InitializePnPManager



//------------------------------------------------------------------------
// Post Log-On routines
//------------------------------------------------------------------------



CONFIGRET
PNP_ReportLogOn(
    IN handle_t   hBinding,
    IN BOOL       bAdmin,
    IN DWORD      ProcessID
    )
/*++

Routine Description:

    This routine is used to report logon events.  It is called from the
    userinit.exe process during logon, via CMP_Report_LogOn.

Arguments:

    hBinding  - RPC binding handle.

    bAdmin    - Not used.

    ProcessID - Process ID of the userinit.exe process that will be used to
                retrieve the access token for the user associated with this
                logon.

Return Value:

    Return CR_SUCCESS if the function succeeds, CR_FAILURE otherwise.

Notes:

    When a user logs on to the console session, we signal the "logged on" event,
    which will wake the device installation thread to perform any pending
    client-side device install events.

    Client-side device installation, requires the user access token to create a
    rundll32 process in the logged on user's security context.

    Although Terminal Services is now always running on all flavors of Whistler,
    it is not started during safe mode.  It may also not be started by the time
    session 0 is available for logon as the Console session.  For those reasons,
    SessionId 0 is still treated differently from the other sessions.

    Since Terminal Services may not be available during a logon to session 0, we
    cache a handle to the access token associated with the userinit.exe process.
    The handle is closed when we receive a logoff event for our process's
    session (SessionId 0), via PnpConsoleCtrlHandler.

    Handles to user access tokens for all other sessions are retrieved on
    demand, using GetWinStationUserToken, since Terminal Services must
    necessarily be available for the creation of those sessions.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    HANDLE      hUserProcess = NULL;
    RPC_STATUS  rpcStatus;
    DWORD       dwWait;
    ULONG       ulSessionId;
    PWSTR       MultiSzGuidList = NULL;

    UNREFERENCED_PARAMETER(bAdmin);

    //
    // Wait for the init mutex - this ensures that the pnp init
    // routine (called when the service starts) has had a chance
    // to complete first.
    //
    if (ghInitMutex != NULL) {

        dwWait = WaitForSingleObject(ghInitMutex, 180000);  // 3 minutes

        if (dwWait != WAIT_OBJECT_0) {
            //
            // mutex was abandoned or timed out during the wait,
            // don't attempt any further init activity
            //
            return CR_FAILURE;
        }
    }

    try {
        //
        // Make sure that the caller is a member of the interactive group.
        //
        if (!IsClientInteractive(hBinding)) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Impersonate the client and retrieve the SessionId.
        //
        rpcStatus = RpcImpersonateClient(hBinding);
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: PNP_ReportLogOn: RpcImpersonateClient failed, error = %d\n",
                       rpcStatus));
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Keep track of the client's session.
        //
        ulSessionId = GetClientLogonId();

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: PNP_ReportLogOn: SessionId %d\n",
                   ulSessionId));

        //
        // NTRAID #181685-2000/09/11-jamesca:
        //
        //   Currently, terminal services send notification of logons to
        //   "remote" sessions before the server's process creation thread is
        //   running.  If we set the logged on event, and there are devices
        //   waiting to be installed, we will immediately call
        //   CreateProcessAsUser on that session, which will fail.  As a
        //   (temporary?) workaround, we'll continue to use PNP_ReportLogOn to
        //   receive logon notification from userinit.exe, now for all sessions.
        //

        //
        // If this is a logon to SessionId 0, save a handle to the access token
        // associated with the userinit.exe process.  We need this later to
        // create a rundll32 process in the logged on user's security context
        // for client-side device installation and hotplug notifications.
        //
        if (ulSessionId == MAIN_SESSION) {

            ASSERT(gTokenLock.LockHandles);
            LockPrivateResource(&gTokenLock);

            //
            // We should have gotten rid of the cached user token during logoff,
            // so if we still have one, ignore this spurious logon report.
            //
            //ASSERT(ghUserToken == NULL);

            if (ghUserToken == NULL) {
                //
                // While still impersonating the client, open a handle to the user
                // access token of the calling process (userinit.exe).
                //
                hUserProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, ProcessID);

                if (hUserProcess) {
                    OpenProcessToken(hUserProcess, TOKEN_ALL_ACCESS, &ghUserToken);
                    CloseHandle(hUserProcess);
                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: PNP_ReportLogOn: OpenProcess failed, error = %d\n",
                               rpcStatus));
                    ASSERT(0);
                }
            }

            ASSERT(ghUserToken);
            UnlockPrivateResource(&gTokenLock);
        }

        //
        // Stop impersonating.
        //
        rpcStatus = RpcRevertToSelf();

        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: PNP_ReportLogOn: RpcRevertToSelf failed, error = %d\n",
                       rpcStatus));
            ASSERT(0);
        }

        //
        // If this is a logon to the "Console" session, signal the event that
        // indicates a Console user is currently logged on.
        //
        if (IsConsoleSession(ulSessionId)) {
            if (InstallEvents[LOGGED_ON_EVENT]) {
                SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT | DBGF_INSTALL,
                           "UMPNPMGR: PNP_ReportLogOn: SetEvent LOGGED_ON_EVENT\n"));
            }
        }

        //
        // For every logon to every session, send a generic blocked driver
        // notification if the system has blocked any drivers from loading so
        // far this boot.
        //
        MultiSzGuidList = BuildBlockedDriverList((LPGUID)NULL, 0);
        if (MultiSzGuidList != NULL) {
            SendHotplugNotification((LPGUID)&GUID_DRIVER_BLOCKED,
                                    NULL,
                                    MultiSzGuidList,
                                    &ulSessionId,
                                    0);
            HeapFree(ghPnPHeap, 0, MultiSzGuidList);
            MultiSzGuidList = NULL;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in PNP_ReportLogOn\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        ghInitMutex = ghInitMutex;
        MultiSzGuidList = MultiSzGuidList;
    }

    if (ghInitMutex != NULL) {
        ReleaseMutex(ghInitMutex);
    }

    if (MultiSzGuidList != NULL) {
        HeapFree(ghPnPHeap, 0, MultiSzGuidList);
    }

    return Status;

} // PNP_ReportLogon


typedef struct _DEVICE_INSTALL_ENTRY {
    SIZE_T  Index;
    ULONG   Depth;
}DEVICE_INSTALL_ENTRY, *PDEVICE_INSTALL_ENTRY;

int
__cdecl
compare_depth(
    const void *a,
    const void *b
    )
{
    PDEVICE_INSTALL_ENTRY entry1, entry2;

    entry1 = (PDEVICE_INSTALL_ENTRY)a;
    entry2 = (PDEVICE_INSTALL_ENTRY)b;

    if (entry1->Depth > entry2->Depth) {

        return -1;
    } else if (entry1->Depth < entry2->Depth) {

        return 1;
    }
    return 0;
}



DWORD
ThreadProc_GuiSetupDeviceInstall(
    LPDWORD lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is only active during GUI-mode setup
    and passes device notifications down a pipe to setup.
    There are two passes, which *must* match exactly with the two passes in GUI-setup
    Once the passes are complete, we proceed to Phase-2 of normal serverside install

Arguments:

   lpThreadParam - Not used.

Return Value:

   Not used, currently returns result of ThreadProc_DeviceInstall - which will normally not return

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    LPWSTR      pDeviceList = NULL, pszDevice = NULL;
    ULONG       ulSize = 0, ulProblem = 0, ulStatus = 0, ulConfig, Pass, threadID;
    ULONG       ulPostSetupSkipPhase1 = TRUE;
    HANDLE      hPipeEvent = NULL, hPipe = NULL, hBatchEvent = NULL, hThread = NULL;
    PPNP_INSTALL_ENTRY entry = NULL;
    PDEVICE_INSTALL_ENTRY pSortArray = NULL;
    LONG        lCount;
    BOOL        needsInstall;
    ULONG       ulReenumerationCount;

    UNREFERENCED_PARAMETER(lpThreadParam);

    try {

        //
        // 2 Passes, must match up with the 2 passes in SysSetup.
        // generally, most, if not all devices, will be picked up
        // and installed by syssetup
        //

        for (Pass = 1; Pass <= 2; Pass++) {

            ulReenumerationCount = 0;
            //
            // If Gui mode setup is in progress, we don't need to wait for a logon
            // event. Just wait on the event that indicates when gui mode setup
            // has opened the pipe and is ready to recieve device names. Attempt to
            // create the event first (in case I beat setup to it), if it exists
            // already then just open it by name. This is a manual reset event.
            //

            hPipeEvent = CreateEvent(NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT);
            if (!hPipeEvent) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    hPipeEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_CREATE_PIPE_EVENT);
                    if (!hPipeEvent) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                } else {
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }

            if (WaitForSingleObject(hPipeEvent, INFINITE) != WAIT_OBJECT_0) {
                Status = CR_FAILURE;
                goto Clean0;    // event must have been abandoned
            }

            //
            // Reset the manual-reset event back to the non-signalled state.
            //

            ResetEvent(hPipeEvent);

            hBatchEvent = CreateEvent(NULL, TRUE, FALSE, PNP_BATCH_PROCESSED_EVENT);
            if (!hBatchEvent) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    hBatchEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_BATCH_PROCESSED_EVENT);
                    if (!hBatchEvent) {
                        Status = CR_FAILURE;
                        goto Clean0;
                    }

                } else {
                    Status = CR_FAILURE;
                    goto Clean0;
                }
            }

            //
            // Open the client side of the named pipe, the server side was opened
            // by gui mode setup.
            //

            if (!WaitNamedPipe(PNP_NEW_HW_PIPE, PNP_PIPE_TIMEOUT)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: ThreadProc_GuiSetupDeviceInstall: WaitNamedPipe failed!\n"));
                Status = CR_FAILURE;
                goto Clean0;
            }

            hPipe = CreateFile(PNP_NEW_HW_PIPE,
                               GENERIC_WRITE,
                               0,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL);

            if (hPipe == INVALID_HANDLE_VALUE) {
                LogErrorEvent(ERR_CREATING_SETUP_PIPE, GetLastError(), 0);
                Status = CR_FAILURE;
                goto Clean0;
            }


            //
            // Retreive the list of all devices for all enumerators
            // Start out with a reasonably-sized buffer (16K characters) in
            // hopes of avoiding 2 calls to get the device list.
            //
            ulSize = 16384;

            for ( ; ; ) {

                pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
                if (pDeviceList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                Status = PNP_GetDeviceList(NULL, NULL, pDeviceList, &ulSize, 0);
                if (Status == CR_SUCCESS) {
                    break;
                } else if(Status == CR_BUFFER_SMALL) {
                    //
                    // Our initial buffer wasn't large enough.  Free the current
                    // buffer.
                    //
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = NULL;

                    //
                    // Now, go ahead and make the call to retrieve the actual
                    // size required.
                    //
                    Status = PNP_GetDeviceListSize(NULL, NULL, &ulSize, 0);
                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }
                } else {
                    //
                    // We failed for some reason other than buffer-too-small.
                    // Bail now.
                    //
                    goto Clean0;
                }
            }

            //
            // Count the number of devices we are installing.
            //
            for (pszDevice = pDeviceList, lCount = 0;
                *pszDevice;
                pszDevice += lstrlen(pszDevice) + 1, lCount++) {
            }

            pSortArray = HeapAlloc(ghPnPHeap, 0, lCount * sizeof(DEVICE_INSTALL_ENTRY));
            if (pSortArray) {

                NTSTATUS    ntStatus;
                PLUGPLAY_CONTROL_DEPTH_DATA depthData;
                LPWSTR      pTempList;

                //
                // Initialize all the information we need to sort devices.
                //
                for (pszDevice = pDeviceList, lCount = 0;
                    *pszDevice;
                    pszDevice += lstrlen(pszDevice) + 1, lCount++) {

                    pSortArray[lCount].Index = pszDevice - pDeviceList;
                    depthData.DeviceDepth = 0;
                    RtlInitUnicodeString(&depthData.DeviceInstance, pszDevice);
                    ntStatus = NtPlugPlayControl(PlugPlayControlGetDeviceDepth,
                                                 &depthData,
                                                 sizeof(depthData));
                    pSortArray[lCount].Depth = depthData.DeviceDepth;
                }

                //
                // Sort the array so that deeper devices are ahead.
                //
                qsort(pSortArray, lCount, sizeof(DEVICE_INSTALL_ENTRY), compare_depth);

                //
                // Copy the data so that the device instance strings are sorted.
                //
                pTempList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
                if (pTempList) {

                    for (pszDevice = pTempList, lCount--; lCount >= 0; lCount--) {

                        lstrcpy(pszDevice, &pDeviceList[pSortArray[lCount].Index]);
                        pszDevice += lstrlen(pszDevice) + 1;
                    }
                    *pszDevice = TEXT('\0');
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = pTempList;
                }
                HeapFree(ghPnPHeap, 0, pSortArray);
            }
            //
            // PHASE 1
            //
            // Search the registry for devices to install.
            //

            for (pszDevice = pDeviceList;
                *pszDevice;
                pszDevice += lstrlen(pszDevice) + 1) {

                //
                // Is device present?
                //
                if (IsDeviceIdPresent(pszDevice)) {

                    if (Pass == 1) {

                        //
                        // First time through, pass everything in the registry to
                        // guimode setup via the pipe, whether they are marked as
                        // needing to be installed or not.
                        //

                        if (!WriteFile(hPipe,
                                       pszDevice,
                                       (lstrlen(pszDevice)+1) * sizeof(WCHAR),
                                       &ulSize,
                                       NULL)) {

                            LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                        }

                    } else {

                        //
                        // Second time through, only pass along anything
                        // that is marked as needing to be installed.
                        //
                        DevInstNeedsInstall(pszDevice, &needsInstall);

                        if (needsInstall) {

                            if (!WriteFile(hPipe,
                                           pszDevice,
                                           (lstrlen(pszDevice)+1) * sizeof(WCHAR),
                                           &ulSize,
                                           NULL)) {

                                LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                            }
                        }
                    }
                } else if (Pass == 1) {
                    //
                    // device ID is not present
                    // we should have marked this as needs re-install
                    //
                    ulConfig = GetDeviceConfigFlags(pszDevice, NULL);

                    if ((ulConfig & CONFIGFLAG_REINSTALL)==0) {

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_INSTALL | DBGF_WARNINGS,
                                   "UMPNPMGR: Setup - %ws not present and not marked as needing reinstall - setting CONFIGFLAG_REINSTALL\n",
                                   pszDevice));

                        ulConfig |= CONFIGFLAG_REINSTALL;

                        PNP_SetDeviceRegProp(NULL,
                                             pszDevice,
                                             CM_DRP_CONFIGFLAGS,
                                             REG_DWORD,
                                             (LPBYTE)&ulConfig,
                                             sizeof(ulConfig),
                                             0
                                            );

                    }
                }
            }

            //
            // PHASE 2
            //

            do {

                //
                // Write a NULL ID to indicate end of this batch.
                //

                if (!WriteFile(hPipe,
                               TEXT(""),
                               sizeof(WCHAR),
                               &ulSize,
                               NULL)) {

                    LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                }

                //
                // Wait for gui mode setup to complete processing of the last
                // batch.
                //

                if (WaitForSingleObject(hBatchEvent,
                                        PNP_GUISETUP_INSTALL_TIMEOUT) != WAIT_OBJECT_0) {

                    //
                    // The event was either abandoned or timed out, give up.
                    //
                    goto Clean1;
                }
                ResetEvent(hBatchEvent);

                //
                // Reenumerate the tree from the ROOT on a separate thread.
                //

                hThread = CreateThread(NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)ThreadProc_ReenumerateDeviceTree,
                                   (LPVOID)pszRegRootEnumerator,
                                   0,
                                   &threadID);
                if (hThread == NULL) {

                    goto Clean1;
                }
                if (WaitForSingleObject(hThread,
                                        PNP_GUISETUP_INSTALL_TIMEOUT) != WAIT_OBJECT_0) {

                    //
                    // The event was either abandadoned or timed out, give up.
                    //
                    goto Clean1;
                }

                //
                // Check if we have reenumerated for too long.
                //

                if (++ulReenumerationCount >= MAX_REENUMERATION_COUNT) {
                    //
                    // Either something is wrong with one of the enumerators in 
                    // the system (more likely) or this device tree is 
                    // unreasonably deep. In the latter case, the remaining 
                    // devices will get installed post setup.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: ThreadProc_GuiSetupDeviceInstall: Reenumerated %d times, some enumerator is misbehaving!\n", ulReenumerationCount));
                    ASSERT(ulReenumerationCount < MAX_REENUMERATION_COUNT);

                    goto Clean1;
                }
                //
                // If we dont have any devices in the install list, we are done.
                //

                if (InstallList.Next == NULL) {
                    break;
                }

                //
                // Install any new devices found as a result of setting up the
                // previous batch of devices.
                //
                lCount = 0;
                LockNotifyList(&InstallList.Lock);
                while (InstallList.Next != NULL) {
                    //
                    // Retrieve and remove the first (oldest) entry in the
                    // install device list.
                    //
                    entry = (PPNP_INSTALL_ENTRY)InstallList.Next;
                    InstallList.Next = entry->Next;
                    UnlockNotifyList(&InstallList.Lock);

                    ASSERT(!(entry->Flags & (PIE_SERVER_SIDE_INSTALL_ATTEMPTED | PIE_DEVICE_INSTALL_REQUIRED_REBOOT)));

                    //
                    // Should we install this device?
                    //
                    DevInstNeedsInstall(entry->szDeviceId, &needsInstall);

                    if (needsInstall) {

                        //
                        // Give this device name to gui mode setup via the pipe
                        //
                        if (!WriteFile(hPipe,
                                       entry->szDeviceId,
                                       (lstrlen(entry->szDeviceId)+1) * sizeof(WCHAR),
                                       &ulSize,
                                       NULL)) {

                            LogErrorEvent(ERR_WRITING_SETUP_PIPE, GetLastError(), 0);
                        } else {

                            lCount++;
                        }
                    }
                    HeapFree(ghPnPHeap, 0, entry);

                    LockNotifyList(&InstallList.Lock);
                }

                UnlockNotifyList(&InstallList.Lock);

            } while (lCount > 0);

        Clean1:

            CloseHandle(hPipe);
            hPipe = INVALID_HANDLE_VALUE;

            CloseHandle(hPipeEvent);
            hPipeEvent = NULL;

            CloseHandle(hBatchEvent);
            hBatchEvent = NULL;

            if (hThread) {
                CloseHandle(hThread);
                hThread = NULL;
            }

            HeapFree(ghPnPHeap, 0, pDeviceList);
            pDeviceList = NULL;

        } // for

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_GuiSetupDeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        hPipe = hPipe;
        hPipeEvent = hPipeEvent;
        hBatchEvent = hBatchEvent;
        hThread = hThread;
        pDeviceList = pDeviceList;
    }

    if (hPipe != INVALID_HANDLE_VALUE) {
        CloseHandle(hPipe);
    }
    if (hPipeEvent != NULL) {
        CloseHandle(hPipeEvent);
    }
    if (hBatchEvent != NULL) {
        CloseHandle(hBatchEvent);
    }
    if (hThread) {
        CloseHandle(hThread);
    }
    if (pDeviceList != NULL) {
        HeapFree(ghPnPHeap, 0, pDeviceList);
    }

    //
    // will typically never return
    //
    return ThreadProc_DeviceInstall(&ulPostSetupSkipPhase1);

} // ThreadProc_GuiSetupDeviceInstall



DWORD
ThreadProc_FactoryPreinstallDeviceInstall(
    LPDWORD lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is only active during
    GUI-mode setup when we are doing a factory preinstall.

    This function simply creates and event, and then waits before kicking off
    normal pnp device install

Arguments:

   lpThreadParam - Not used.

Return Value:

   Not used, currently returns result of ThreadProc_DeviceInstall - which will
   normally not return.

--*/
{
    HANDLE      hEvent = NULL;
    CONFIGRET   Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(lpThreadParam);

    try {
        hEvent = CreateEvent(NULL, TRUE, FALSE, PNP_CREATE_PIPE_EVENT);
        if (!hEvent) {
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, PNP_CREATE_PIPE_EVENT);
                if (!hEvent) {
                    Status = CR_FAILURE;
                    goto Clean0;
                }

            } else {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }

        if (WaitForSingleObject(hEvent, INFINITE) != WAIT_OBJECT_0) {
            Status = CR_FAILURE;
            goto Clean0;    // event must have been abandoned
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_FactoryPreinstallDeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        hEvent = hEvent;
    }

    if (hEvent != NULL) {
        CloseHandle(hEvent);
    }

    //
    // will typically never return
    //
    return ThreadProc_DeviceInstall(NULL);

} // ThreadProc_FactoryPreinstallDeviceInstall



//-----------------------------------------------------------------------------
// Device enumeration thread - created on demand
//-----------------------------------------------------------------------------

DWORD
ThreadProc_ReenumerateDeviceTree(
    LPVOID  lpThreadParam
    )
/*++

Routine Description:

    This routine is a thread procedure. This thread is created dynamically to
    perform a synchronous device re-enumeration.

    This thread can be waited on and abandoned after a specified timeout, if
    necessary.

Arguments:

    lpThreadParam - Specifies a pointer to the device instance path that should
                    be re-enumerated.

Return Value:

    Not used, currently returns 0.

--*/
{
    PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA controlData;

    //
    // Reenumerate the tree from the root specified.
    //

    memset(&controlData, 0 , sizeof(PLUGPLAY_CONTROL_DEVICE_CONTROL_DATA));
    controlData.Flags = 0;
    RtlInitUnicodeString(&controlData.DeviceInstance, (PCWSTR)lpThreadParam);

    NtPlugPlayControl(PlugPlayControlEnumerateDevice,
                      &controlData,
                      sizeof(controlData));

    return 0;

} // ThreadProc_ReenumerateDeviceTree



//-----------------------------------------------------------------------------
// Device installation thread
//-----------------------------------------------------------------------------

DWORD
ThreadProc_DeviceInstall(
    LPDWORD lpParam
    )
/*++

Routine Description:

    This routine is a thread procedure.
    It is invoked during a normal boot, or after the GUI-setup special case has finished
    During Phase-1, all devices are checked
    During Phase-2, all new devices are checked as they arrive.

Arguments:

   lpParam - if given and non-zero (currently only when called from ThreadProc_GuiSetupDeviceInstall)
             skips Phase-1, will never prompt for reboot

Return Value:

   Not used, currently returns Status failure code, should typically not return

--*/
{
    CONFIGRET Status = CR_SUCCESS;
    LPWSTR    pDeviceList = NULL, pszDevice = NULL;
    ULONG     ulSize = 0, ulProblem = 0, ulStatus, ulConfig;
    DWORD     InstallDevStatus, WaitResult;
    PPNP_INSTALL_ENTRY InstallEntry = NULL;
    PPNP_INSTALL_ENTRY current, TempInstallList, CurDupeNode, PrevDupeNode;
    BOOL InstallListLocked = FALSE;
    BOOL RebootRequired, needsInstall;
    BOOL DeviceHasProblem = FALSE, SingleDeviceHasProblem;
    BOOL bStillInGuiModeSetup = lpParam ? (BOOL)lpParam[0] : FALSE;
    ULONG ulClientSessionId = INVALID_SESSION;
    ULONG ulFlags = 0;
    HANDLE hAutoStartEvent;

    if (!bStillInGuiModeSetup) {

        //
        // If the OOBE is not running, wait until the service control manager
        // has begun starting autostart services before we attempt to install
        // any devices.  When the OOBE is running, we don't wait for anything
        // because the OOBE waits on us (via CMP_WaitNoPendingInstallEvents) to
        // finish server-side installing any devices that we can before it lets
        // the SCM autostart services and set this event.
        //
        if (!gbOobeInProgress) {

            hAutoStartEvent = OpenEvent(SYNCHRONIZE,
                                        FALSE,
                                        SC_AUTOSTART_EVENT_NAME);

            if (hAutoStartEvent) {
                //
                // Wait until the service controller allows other services to
                // start before we try to install any devices in phases 1 and 2,
                // below.
                //
                WaitResult = WaitForSingleObject(hAutoStartEvent, INFINITE);
                ASSERT(WaitResult == WAIT_OBJECT_0);

                CloseHandle(hAutoStartEvent);

            } else {
                //
                // The service controller always creates this event, so it must
                // exist by the time our service is started.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: Failed to open %ws event, error = %d\n",
                           SC_AUTOSTART_EVENT_NAME,
                           GetLastError()));
                ASSERT(0);
            }
        }


        try {
            //
            // Phase 1:
            //
            // Check the enum branch in the registry and attempt to install, one
            // right after the other, any devices that need to be installed right
            // now.  Typically these devices showed up during boot.
            //
            // Retrieve the list of devices that currently need to be installed.
            // Start out with a reasonably-sized buffer (16K characters) in hopes
            // of avoiding 2 calls to get the device list.
            //
            // this phase is skipped during GUI-mode setup, and is handled by ThreadProc_GuiSetupDeviceInstall
            //
            ulSize = 16384;

            for ( ; ; ) {

                pDeviceList = HeapAlloc(ghPnPHeap, 0, ulSize * sizeof(WCHAR));
                if (pDeviceList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean1;
                }

                Status = PNP_GetDeviceList(NULL, NULL, pDeviceList, &ulSize, 0);
                if (Status == CR_SUCCESS) {
                    break;
                } else if(Status == CR_BUFFER_SMALL) {
                    //
                    // Our initial buffer wasn't large enough.  Free the current
                    // buffer.
                    //
                    HeapFree(ghPnPHeap, 0, pDeviceList);
                    pDeviceList = NULL;

                    //
                    // Now, go ahead and make the call to retrieve the actual size
                    // required.
                    //
                    Status = PNP_GetDeviceListSize(NULL, NULL, &ulSize, 0);
                    if (Status != CR_SUCCESS) {
                        goto Clean1;
                    }
                } else {
                    //
                    // We failed for some reason other than buffer-too-small.  Bail
                    // now.
                    //
                    goto Clean1;
                }
            }

            //
            // Make sure we have the device installer APIs at our disposal
            // before starting server-side install.
            //
            InstallDevStatus = LoadDeviceInstaller();
            ASSERT(InstallDevStatus == NO_ERROR);
            if (InstallDevStatus != NO_ERROR) {
                goto Clean1;
            }

            //
            // Get the config flag for each device, and install any that need to be
            // installed.
            //
            for (pszDevice = pDeviceList;
                 *pszDevice;
                 pszDevice += lstrlen(pszDevice) + 1) {

                //
                // Should the device be installed?
                //
                if (DevInstNeedsInstall(pszDevice, &needsInstall) == CR_SUCCESS) {

                    if (needsInstall) {

                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_INSTALL,
                                   "UMPNPMGR: Installing device (%ws) server-side\n",
                                   pszDevice));

                        RebootRequired = FALSE;

                        //
                        // Make sure we have the device installer APIs at our disposal
                        // before starting server-side install.
                        //
                        InstallDevStatus = LoadDeviceInstaller();
                        ASSERT(InstallDevStatus == NO_ERROR);

                        if (InstallDevStatus == NO_ERROR) {

                            if (IsFastUserSwitchingEnabled()) {
                                ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                            } else {
                                ulClientSessionId = MAIN_SESSION;
                                ulFlags = 0;
                            }

                            //
                            // Attempt server-side installation of this device.
                            //
                            InstallDevStatus = InstallDeviceServerSide(pszDevice,
                                                                       &RebootRequired,
                                                                       &SingleDeviceHasProblem,
                                                                       &ulClientSessionId,
                                                                       ulFlags);

                        }

                        if(InstallDevStatus == NO_ERROR) {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Installing device (%ws), Server-side installation succeeded!\n",
                                       pszDevice));

                            if (SingleDeviceHasProblem) {
                                DeviceHasProblem = TRUE;
                            }

                        } else {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Installing device (%ws), Server-side installation failed (Status = 0x%08X)\n",
                                       pszDevice,
                                       InstallDevStatus));
                        }

                        if((InstallDevStatus != NO_ERROR) || RebootRequired) {
                            //
                            // Allocate and initialize a new device install entry
                            // block.
                            //
                            InstallEntry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_INSTALL_ENTRY));
                            if(!InstallEntry) {
                                Status = CR_OUT_OF_MEMORY;
                                goto Clean1;
                            }

                            InstallEntry->Next = NULL;
                            InstallEntry->Flags = PIE_SERVER_SIDE_INSTALL_ATTEMPTED;
                            if(InstallDevStatus == NO_ERROR) {
                                //
                                // We didn't get here because the install failed,
                                // so it must've been because the installation
                                // requires a reboot.
                                //
                                ASSERT(RebootRequired);
                                InstallEntry->Flags |= PIE_DEVICE_INSTALL_REQUIRED_REBOOT;

                                //
                                // Set the global server side device install
                                // reboot needed bool to TRUE.
                                //
                                gServerSideDeviceInstallRebootNeeded = TRUE;
                            }
                            lstrcpy(InstallEntry->szDeviceId, pszDevice);

                            //
                            // Insert this entry in the device install list.
                            //
                            LockNotifyList(&InstallList.Lock);
                            InstallListLocked = TRUE;

                            current = (PPNP_INSTALL_ENTRY)InstallList.Next;
                            if(!current) {
                                InstallList.Next = InstallEntry;
                            } else {
                                while((PPNP_INSTALL_ENTRY)current->Next) {
                                    current = (PPNP_INSTALL_ENTRY)current->Next;
                                }
                                current->Next = InstallEntry;
                            }

                            //
                            // Newly-allocated entry now added to the list--NULL
                            // out the pointer so we won't try to free it if we
                            // happen to encounter an exception later.
                            //
                            InstallEntry = NULL;

                            UnlockNotifyList(&InstallList.Lock);
                            InstallListLocked = FALSE;

                            SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);
                        }
                    }
                } else {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL,
                               "UMPNPMGR: Ignoring not present device (%ws)\n",
                               pszDevice));
                }
            }

        Clean1:
            //
            // Up to this point, we have only attempted server-side installation
            // of devices, so any device install clients we might have launched
            // would have been for UI only.  Since we are done installing
            // devices for the time being, we should unload the device installer
            // APIs, and get rid of any device install clients that currently
            // exist.
            //
            UnloadDeviceInstaller();

        } except(EXCEPTION_EXECUTE_HANDLER) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_INSTALL,
                       "UMPNPMGR: Exception in ThreadProc_DeviceInstall\n"));
            ASSERT(0);
            Status = CR_FAILURE;

            //
            // Reference the following variables so the compiler will respect
            // statement ordering w.r.t. assignment.
            //
            pDeviceList = pDeviceList;
            InstallListLocked = InstallListLocked;
            InstallEntry = InstallEntry;
        }

        if(InstallEntry) {
            HeapFree(ghPnPHeap, 0, InstallEntry);
            InstallEntry = NULL;
        }

        if(InstallListLocked) {
            UnlockNotifyList(&InstallList.Lock);
            InstallListLocked = FALSE;
        }

        if(pDeviceList != NULL) {
            HeapFree(ghPnPHeap, 0, pDeviceList);
        }
    }

    //
    // NOTE: We should remove this line if we ever hook up the 'finished
    // installing hardware' balloon so that it comes up if we install devices
    // before a user logs on.
    //
    DeviceHasProblem = FALSE;

    //
    // Maintain a temporary list of PNP_INSTALL_ENTRY nodes that we needed to
    // initiate client-side installation for, but couldn't these nodes get
    // re-added to the master InstallList once all entries have been processed.
    // Also, keep a pointer to the end of the list for efficient appending of
    // nodes to the queue.
    //
    current = TempInstallList = NULL;

    try {
        //
        // Phase 2: Hang around and be prepared to install any devices
        //          that come on line for the first time while we're
        //          running.
        //          we may come into Phase 2 (skipping Phase 1) in GUI-Setup
        //
        for ( ; ; ) {

            //
            // Before starting an indefinite wait, test the event state and set
            // the ghNoPendingInstalls event accordingly.  This event is just a
            // backdoor way for device manager (and others) to see if we're
            // still installing things.
            //
            if(WaitForSingleObject(InstallEvents[NEEDS_INSTALL_EVENT], 0) != WAIT_OBJECT_0) {
                //
                // There's nothing waiting to be installed--set the event.
                //
                SetEvent(ghNoPendingInstalls);
            }

            //
            // Wait until the device event thread tells us we need to
            // dynamically install a new device (or until somebody logs on).
            //
            WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                   InstallEvents,
                                   FALSE,           // wake up on either event
                                   INFINITE         // I can wait all day
                                   );

            //
            // After I empty the list, this thread can sleep until another new
            // device needs to be installed...
            //
            ResetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

            //
            // ...or until a user logs in (note that we only want to awake once
            // per log-in.
            //
            ResetEvent(InstallEvents[LOGGED_ON_EVENT]);

            //
            // We now have something to do, so reset the event that lets folks
            // like DevMgr know when we're idle.
            //
            ResetEvent(ghNoPendingInstalls);

#if DBG
            RtlValidateHeap(ghPnPHeap,0,NULL);
#endif
            //
            // Process each device that needs to be installed.
            //
            while (InstallList.Next != NULL) {
                //
                // Retrieve and remove the first (oldest) entry in the
                // install device list.
                //
                LockNotifyList(&InstallList.Lock);
                InstallListLocked = TRUE;

                InstallEntry = (PPNP_INSTALL_ENTRY)InstallList.Next;
                InstallList.Next = InstallEntry->Next;

                //
                // Now, scan the rest of the list looking for additional nodes
                // related to this same device.  If we find any, OR their flags
                // into our 'master' node, and remove the duplicated nodes from
                // the list.  We can get duplicates due to the fact that both
                // the event thread and this thread can be placing items in the
                // list.  We don't want to be attempting (failing) server-side
                // installations multiple times.
                //
                CurDupeNode = (PPNP_INSTALL_ENTRY)InstallList.Next;
                PrevDupeNode = NULL;

                while(CurDupeNode) {

                    if(!lstrcmpi(InstallEntry->szDeviceId, CurDupeNode->szDeviceId)) {
                        //
                        // We have a duplicate!  OR the flags into those of
                        // the install entry we retrieved from the head of
                        // the list.
                        //
                        InstallEntry->Flags |= CurDupeNode->Flags;

                        //
                        // Now remove this duplicate node from the list.
                        //
                        if(PrevDupeNode) {
                            PrevDupeNode->Next = CurDupeNode->Next;
                        } else {
                            InstallList.Next = CurDupeNode->Next;
                        }

                        HeapFree(ghPnPHeap, 0, CurDupeNode);

                        if(PrevDupeNode) {
                            CurDupeNode = (PPNP_INSTALL_ENTRY)PrevDupeNode->Next;
                        } else {
                            CurDupeNode = (PPNP_INSTALL_ENTRY)InstallList.Next;
                        }

                    } else {
                        PrevDupeNode = CurDupeNode;
                        CurDupeNode = (PPNP_INSTALL_ENTRY)CurDupeNode->Next;
                    }
                }

                UnlockNotifyList(&InstallList.Lock);
                InstallListLocked = FALSE;

                if(InstallEntry->Flags & PIE_DEVICE_INSTALL_REQUIRED_REBOOT) {
                    //
                    // We've already performed a (successful) server-side
                    // installation on this device.  Remember the fact that a
                    // reboot is needed, so we'll prompt after processing this
                    // batch of new hardware.
                    //
                    // This will be our last chance to prompt for reboot on this
                    // node, because the next thing we're going to do is free
                    // this install entry!
                    //
                    gServerSideDeviceInstallRebootNeeded = TRUE;

                } else {
                    //
                    // Verify that device really needs to be installed
                    //

                    ulConfig = GetDeviceConfigFlags(InstallEntry->szDeviceId, NULL);
                    Status = GetDeviceStatus(InstallEntry->szDeviceId, &ulStatus, &ulProblem);

                    if (Status == CR_SUCCESS) {
                        //
                        // Note that we must explicitly check below for the
                        // presence of the CONFIGFLAG_REINSTALL config flag. We
                        // can't simply rely on the CM_PROB_REINSTALL problem
                        // being set, because we may have encountered a device
                        // during our phase 1 processing whose installation was
                        // deferred because it provided finish-install wizard
                        // pages.  Since we only discover that this is the case
                        // _after_ successful completion of DIF_INSTALLDEVICE,
                        // it's too late to set the problem (kernel-mode PnP
                        // manager only allows us to set a problem of needs-
                        // reboot for a running devnode).
                        //
                        if((ulConfig & CONFIGFLAG_FINISH_INSTALL) ||
                           (ulConfig & CONFIGFLAG_REINSTALL) ||
                            ((ulStatus & DN_HAS_PROBLEM) &&
                             ((ulProblem == CM_PROB_REINSTALL) || (ulProblem == CM_PROB_NOT_CONFIGURED)))) {

                            if(!(InstallEntry->Flags & PIE_SERVER_SIDE_INSTALL_ATTEMPTED)) {
                                //
                                // We haven't tried to install this device
                                // server-side yet, so try that now.
                                //
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_INSTALL,
                                           "UMPNPMGR: Installing device (%ws) server-side\n\t  Status = 0x%08X\n\t  Problem = %d\n\t  ConfigFlags = 0x%08X\n",
                                           InstallEntry->szDeviceId,
                                           ulStatus,
                                           ulProblem,
                                           ulConfig));

                                //
                                // Make sure we have the device installer APIs at our disposal
                                // before starting server-side install.
                                //
                                InstallDevStatus = LoadDeviceInstaller();
                                ASSERT(InstallDevStatus == NO_ERROR);

                                if (InstallDevStatus == NO_ERROR) {

                                    if (IsFastUserSwitchingEnabled()) {
                                        ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                                    } else {
                                        ulClientSessionId = MAIN_SESSION;
                                        ulFlags = 0;
                                    }

                                    InstallDevStatus = InstallDeviceServerSide(
                                        InstallEntry->szDeviceId,
                                        &gServerSideDeviceInstallRebootNeeded,
                                        &SingleDeviceHasProblem,
                                        &ulClientSessionId,
                                        ulFlags);
                                }

                                if(InstallDevStatus == NO_ERROR) {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_INSTALL,
                                               "UMPNPMGR: Installing device (%ws), Server-side installation succeeded!\n",
                                               InstallEntry->szDeviceId));

                                    if (SingleDeviceHasProblem) {
                                        DeviceHasProblem = TRUE;
                                    }

                                } else {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_INSTALL,
                                               "UMPNPMGR: Installing device (%ws), Server-side installation failed (Status = 0x%08X)\n",
                                               InstallEntry->szDeviceId,
                                               InstallDevStatus));

                                    InstallEntry->Flags |= PIE_SERVER_SIDE_INSTALL_ATTEMPTED;
                                }

                            } else {
                                //
                                // Set some bogus error so we'll drop into the
                                // non-server install codepath below.
                                //
                                InstallDevStatus = ERROR_INVALID_DATA;
                            }

                            if(InstallDevStatus != NO_ERROR) {

                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_INSTALL,
                                           "UMPNPMGR: Installing device (%ws) client-side\n\t  Status = 0x%08X\n\t  Problem = %d\n\t  ConfigFlags = 0x%08X\n",
                                           InstallEntry->szDeviceId,
                                           ulStatus,
                                           ulProblem,
                                           ulConfig));

                                if (IsFastUserSwitchingEnabled()) {
                                    ulFlags = DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                                } else {
                                    ulClientSessionId = MAIN_SESSION;
                                    ulFlags = 0;
                                }

                                if (!InstallDevice(InstallEntry->szDeviceId,
                                                   &ulClientSessionId,
                                                   ulFlags)) {
                                    //
                                    // We weren't able to kick off a device
                                    // install on the client side (probably
                                    // because no one was logged in).  Stick
                                    // this PNP_INSTALL_ENTRY node into a
                                    // temporary list that we'll re-add into
                                    // the InstallList queue once we've emptied
                                    // it.
                                    //
                                    if(current) {
                                        current->Next = InstallEntry;
                                        current = InstallEntry;
                                    } else {
                                        ASSERT(!TempInstallList);
                                        TempInstallList = current = InstallEntry;
                                    }

                                    //
                                    // NULL out the InstallEntry pointer so we
                                    // don't try to free it later.
                                    //
                                    InstallEntry = NULL;
                                }
                            }

                        } else if((ulStatus & DN_HAS_PROBLEM) &&
                                  (ulProblem == CM_PROB_NEED_RESTART)) {
                            //
                            // This device was percolated up from kernel-mode
                            // for the sole purpose of requesting a reboot.
                            // This presently only happens when we encounter a
                            // duplicate devnode, and we then "unique-ify" it
                            // to keep from bugchecking.  We don't want the
                            // unique-ified devnode to actually be installed/
                            // used.  Instead, we just want to give the user a
                            // prompt to reboot, and after they reboot, all
                            // should be well.  The scenario where this has
                            // arisen is in relation to a USB printer (with a
                            // serial number) that is moved from one port to
                            // another during a suspend.  When we resume, we
                            // have both an arrival and a removal to process,
                            // and if we process the arrival first, we think
                            // we've found a dupe.
                            //
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_INSTALL,
                                       "UMPNPMGR: Duplicate device detected (%ws), need to prompt user to reboot!\n",
                                       InstallEntry->szDeviceId));

                            //
                            // Stick this entry into our temporary list to deal
                            // with later...
                            //
                            if(current) {
                                current->Next = InstallEntry;
                                current = InstallEntry;
                            } else {
                                ASSERT(!TempInstallList);
                                TempInstallList = current = InstallEntry;
                            }

                            //
                            // If possible, we want to prompt for reboot right
                            // away (that is, after all install events are
                            // drained)...
                            //
                            gServerSideDeviceInstallRebootNeeded = TRUE;

                            //
                            // If no user is logged in yet, flag this install
                            // entry so we'll try to prompt for reboot the next
                            // time we're awakened (which hopefully will be due
                            // to a user logging in).
                            //
                            InstallEntry->Flags |= PIE_DEVICE_INSTALL_REQUIRED_REBOOT;

                            //
                            // NULL out the InstallEntry pointer so we
                            // don't try to free it later.
                            //
                            InstallEntry = NULL;
                        }
                    }
                }

                if(InstallEntry) {
                    HeapFree(ghPnPHeap, 0, InstallEntry);
                    InstallEntry = NULL;
                }
            }

            //
            // We've processed all device install events known to us at this
            // time.  If we encountered any device whose installation requires
            // a reboot, prompt the logged-in user (if any) to reboot now.
            //
            if (gServerSideDeviceInstallRebootNeeded) {

                ulFlags = DEVICE_INSTALL_FINISHED_REBOOT;

                if (IsFastUserSwitchingEnabled()) {
                    ulFlags |= DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                } else {
                    ulClientSessionId = MAIN_SESSION;
                }

                if (bStillInGuiModeSetup) {
                    //
                    // if we're still in GUI setup, we're going to suppress
                    // any reboot prompts
                    //
                    gServerSideDeviceInstallRebootNeeded = FALSE;
                } else if (PromptUser(&ulClientSessionId,
                                      ulFlags)) {
                    //
                    // We successfully delivered the reboot prompt, so if the
                    // user chose to ignore it, we don't want to prompt again
                    // for reboot the next time new hardware shows up (unless
                    // that hardware also requires a reboot).
                    //
                    gServerSideDeviceInstallRebootNeeded = FALSE;
                }
            }

            if(TempInstallList) {
                //
                // Add our temporary list of PNP_INSTALL_ENTRY nodes back into
                // the InstallList queue.  We _do not_ set the event that says
                // there's more to do, so these nodes will be seen again only
                // if (a) somebody logs in or (b) more new hardware shows up.
                //
                // Note: we cannot assume that the list is empty, because there
                // may have been an insertion after the last time we checked it
                // above.  We want to add our stuff to the beginning of the
                // InstallList queue, since the items we just finished
                // processing appeared before any new entries that might be
                // there now.
                //
                LockNotifyList(&InstallList.Lock);
                InstallListLocked = TRUE;

                ASSERT(current);

                current->Next = InstallList.Next;
                InstallList.Next = TempInstallList;

                //
                // Null out our temporary install list pointers to indicate
                // that the list is now empty.
                //
                current = TempInstallList = NULL;

                UnlockNotifyList(&InstallList.Lock);
                InstallListLocked = FALSE;

            }

            //
            // Before starting an indefinite wait, test the InstallEvents to see
            // if there any new devices to install, or there are still devices
            // to be installed in the InstallList.  If neither of these is the
            // case after waiting a few seconds, we'll notify the user that
            // we're done installing devices for now, unload setupapi, and close
            // all device install clients.
            //
            WaitResult = WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                                InstallEvents,
                                                FALSE,
                                                DEVICE_INSTALL_COMPLETE_WAIT_TIME);
            if ((WaitResult != (WAIT_OBJECT_0 + NEEDS_INSTALL_EVENT)) &&
                (InstallList.Next == NULL)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: ThreadProc_DeviceInstall: no more devices to install.\n"));

                //
                // There's nothing waiting to be installed--set the event.
                //
                SetEvent(ghNoPendingInstalls);

                //
                // Notify the user (if any), that we think we're done installing
                // devices for now.  Note that if we never used a device install
                // client at any time in this pass (all server-side or silent
                // installs), then we won't prompt about this.
                //
                ulFlags = DEVICE_INSTALL_BATCH_COMPLETE;

                if (DeviceHasProblem) {
                    ulFlags |= DEVICE_INSTALL_PROBLEM;
                }

                if (IsFastUserSwitchingEnabled()) {
                    ulFlags |= DEVICE_INSTALL_DISPLAY_ON_CONSOLE;
                } else {
                    ulClientSessionId = MAIN_SESSION;
                }

                PromptUser(&ulClientSessionId,
                           ulFlags);

                //
                // Clear the DeviceHasProblem boolean since we just notified the
                // user.
                //
                DeviceHasProblem = FALSE;

                //
                // We notified the user, now wait around for 10 more seconds
                // from the time of prompting before closing the client to make
                // sure that some new device doesn't arrive, in which case we
                // would just immediately load the installer again.
                //
                WaitResult = WaitForMultipleObjects(NUM_INSTALL_EVENTS,
                                                    InstallEvents,
                                                    FALSE,
                                                    DEVICE_INSTALL_COMPLETE_DISPLAY_TIME);
                if ((WaitResult != (WAIT_OBJECT_0 + NEEDS_INSTALL_EVENT)) &&
                    (InstallList.Next == NULL)) {
                    //
                    // Unload the device installer, and get rid of any device
                    // install clients that currently exist on any sessions.
                    // Note that closing the device install client will make the
                    // above prompt go away.
                    //
                    UnloadDeviceInstaller();
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in ThreadProc_DeviceInstall\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        InstallListLocked = InstallListLocked;
        InstallEntry = InstallEntry;
        TempInstallList = TempInstallList;
    }

    if(InstallListLocked) {
        UnlockNotifyList(&InstallList.Lock);
    }

    if(InstallEntry) {
        HeapFree(ghPnPHeap, 0, InstallEntry);
    }

    while(TempInstallList) {
        current = (PPNP_INSTALL_ENTRY)(TempInstallList->Next);
        HeapFree(ghPnPHeap, 0, TempInstallList);
        TempInstallList = current;
    }

    //
    // meaningless return value, since this thread should never exit.
    //
    return (DWORD)Status;

} // ThreadProc_DeviceInstall



BOOL
InstallDevice(
    IN     LPWSTR pszDeviceId,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine initiates a device installation with the device install client
    (newdev.dll) on the current active console session, creating one if
    necessary.  This routine waits for the client to signal completion, the
    process to signal that it has terminated, or this service to signal that we
    have disconnected ourselves from the client.

Arguments:

    pszDeviceId - device instance ID of the devnode to be installed.

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the session on which the device install client
        process was launched.  Otherwise, will contain an invalid SessionId,
        INVALID_SESSION (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.  The
           SessionId of the current active console session will be returned in
           the SessionId.

Return Value:

    Returns TRUE is the device installation was completed by the device install
    client, FALSE otherwise.

--*/
{
    BOOL b;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    DWORD dwWait;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;

    //
    // Assume failure
    //
    b = FALSE;

    //
    // Validate parameters
    //
    ASSERT(SessionId);
    if (SessionId == NULL) {
        return FALSE;
    }

    try {
        //
        // Calling DoDeviceInstallClient will create the newdev.dll process and open a named
        // pipe if it isn't already been done earlier.  It will then send the Device Id to
        // newdev.dll over the pipe.
        //
        if (DoDeviceInstallClient(pszDeviceId,
                                  SessionId,
                                  Flags,
                                  &pDeviceInstallClient)) {

            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->ulSessionId == *SessionId);

            //
            // Keep track of the device id last sent to this client before we
            // disconnected from it.  This will avoid duplicate popups if we
            // reconnect to this session again, and attempt to client-side
            // install the same device.
            //
            lstrcpy(pDeviceInstallClient->LastDeviceId, pszDeviceId);

            //
            // Wait for the device install to be signaled from newdev.dll
            // to let us know that it has completed the installation.
            //
            // Wait on the client's process as well, to catch the case
            // where the process crashes (or goes away) without signaling the
            // device install event.
            //
            // Also wait on the disconnect event in case we have explicitly
            // disconnected from the client while switching sessions.
            //
            hFinishEvents[0] = pDeviceInstallClient->hProcess;
            hFinishEvents[1] = pDeviceInstallClient->hEvent;
            hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

            dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, INFINITE);

            if (dwWait == WAIT_OBJECT_0) {
                //
                // If the return is WAIT_OBJECT_0 then the newdev.dll
                // process has gone away.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: process signalled, closing device install client!\n"));

            } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
                //
                // If the return is WAIT_OBJECT_0 + 1 then the device
                // installer successfully received the request.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: device install succeeded\n"));
                b = TRUE;

                //
                // This device install client is no longer processing any
                // devices, so clear the device id.
                //
                *pDeviceInstallClient->LastDeviceId = L'\0';

            } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
                //
                // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
                // disconnected from the device install client.  Consider the
                // device install unsuccessful so that this device remains in
                // the install list.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: InstallDevice: device install client disconnected\n"));

            } else {
                //
                // The wait was satisfied for some reason other than the
                // specified objects.  This should never happen, but just in
                // case, we'll close the client.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_ERRORS,
                           "UMPNPMGR: InstallDevice: wait completed unexpectedly!\n"));
            }

            //
            // Remove the reference placed on the client while it was in use.
            //
            LockNotifyList(&InstallClientList.Lock);

            DereferenceDeviceInstallClient(pDeviceInstallClient);

            if ((dwWait != (WAIT_OBJECT_0 + 1)) &&
                (dwWait != (WAIT_OBJECT_0 + 2))) {
                //
                // Unless the client signalled successful receipt of the
                // request, or the client's session was disconnected from the
                // console, the attempt to use this client was unsuccessful.
                // Remove the initial reference so all associated handles will
                // be closed and the entry will be freed when it is no longer in
                // use.
                //

                //
                // Note that if we were unsuccessful because of a
                // logoff, we would have already dereferenced the
                // client then, in which case the above dereference
                // was the final one, and pDeviceInstallClient would
                // be invalid.  Instead, attempt to re-locate the
                // client by the session id.
                //
                pDeviceInstallClient = LocateDeviceInstallClient(*SessionId);
                if (pDeviceInstallClient) {
                    ASSERT(pDeviceInstallClient->RefCount == 1);
                    DereferenceDeviceInstallClient(pDeviceInstallClient);
                }
            }

            UnlockNotifyList(&InstallClientList.Lock);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception in InstallDevice!\n"));
        ASSERT(0);
        b = FALSE;
    }

    return b;

} // InstallDevice


//-----------------------------------------------------------------------------
// Device event server-side rpc routines
//-----------------------------------------------------------------------------


CONFIGRET
PNP_RegisterNotification(
    IN  handle_t hBinding,
    IN  ULONG_PTR  hRecipient,
    IN  LPWSTR   ServiceName,
    IN  LPBYTE   NotificationFilter,
    IN  ULONG    ulSize,
    IN  DWORD    Flags,
    OUT PNP_NOTIFICATION_CONTEXT *Context,
    IN  ULONG    ProcessId,
    IN  ULONG64  *ClientContext
    )

/*++

Routine Description:

    This routine is the rpc server-side of the CMP_RegisterNotification routine.
    It performs the remaining parameter validation and actually registers the
    notification request appropriately.

Arguments:

   hBinding     - RPC binding handle.

   hRecipient   - The Flags value specifies what type of handle this is,
                  currently it's either a window handle or a service handle.

   NotificationFilter - Specifies a pointer to one of the DEV_BROADCAST_XXX
                  structures.

   ulSize       - Specifies the size of the NotificationFilter structure.

   Flags        - Specifies additional paramters used to describe the client or
                  the supplied parameters.  The Flags parameter is subdivided
                  into multiple fields that are interpreted separately, as
                  described below.

               ** The Flags parameter contains a field that describes the type
                  of the hRecipient handle passed in.  This field should be
                  interpreted as an enum, and can be extracted from the Flags
                  parameter using the following mask:

                      DEVICE_NOTIFY_HANDLE_MASK

                  Currently one of the following values must be specified by
                  this field:

                  DEVICE_NOTIFY_WINDOW_HANDLE - hRecipient is a window handle
                      (HWND) for a window whose WNDPROC will be registered to
                      receive WM_DEVICECHANGE window messages for the filtered
                      events specified by the supplied NotificationFilter.

                  DEVICE_NOTIFY_SERVICE_HANDLE - hRecipient is a service status
                      handle (SERVICE_STATUS_HANDLE) for a service whose
                      HandlerEx routine will be registered to receive
                      SERVICE_CONTROL_DEVICEEVENT service controls for the
                      filtered events specified by the supplied
                      NotificationFilter.

                      NOTE: in reality - hRecipient is just the name of the
                      service, as resolved by the cfgmgr32 client.  the SCM will
                      actually resolve this name for us to the true
                      SERVICE_STATUS_HANDLE for this service.

                  DEVICE_NOTIFY_COMPLETION_HANDLE - not currently implemented.


               ** The Flags parameter contains a field that described additional
                  properties for the notification.  This field should be
                  interpreted as a bitmask, and can be extracted from the Flags
                  parameter using the following mask:

                      DEVICE_NOTIFY_PROPERTY_MASK

                  Currently, the following flags are defined for this field:

                  DEVICE_NOTIFY_ALL_INTERFACE_CLASSES - This flag is only valid
                      when a DBT_DEVTYP_DEVICEINTERFACE type notification filter
                      is supplied.  This flag specifies that the caller wishes
                      to receive notification of events for device interfaces of
                      all classes.  If this flag is specified, the
                      dbcc_classguid member of the NotificationFilter structure
                      is ignored.

               ** The Flags parameter also contains a "Reserved" field, that is
                  reserved for use by the cfgmgr32 client to this interface
                  only.  This field should be interpreted as a bitmask, and can
                  be extracted from the Flags parameter using the following
                  mask:

                      DEVICE_NOTIFY_RESERVED_MASK

                  Currently, the following flags are defined for this field:

                  DEVICE_NOTIFY_WOW64_CLIENT - Specifies to a 64-bit server
                      caller is a 32-bit process running on WOW64.  The 64-bit
                      server uses this information to construct 32-bit
                      compatible notification filters for the client.

   Context      - On return, this value returns the server notification context
                  to the client, that is supplied when unregistering this
                  notification request.

   hProcess     - Process Id of the calling application.

   ClientContext - Specifies a pointer to a 64-bit value that contains the
                  client-context pointer.  This value is the HDEVNOTIFY
                  notification handle returned to caller upon successful
                  registration.  It is actually a pointer to the client memory
                  that will reference the returned server-notification context
                  pointer - but is never used as a pointer here on the
                  server-side.  It is only used by the server to be specified as
                  the dbch_hdevnotify member of the DEV_BROADCAST_HANDLE
                  notification structure, supplied to the caller on
                  DBT_DEVTYP_HANDLE notification events.

                  NOTE: This value is truncated to 32-bits on 32-bit platforms,
                  but is always transmitted as a 64-bit value by the RPC
                  interface - for consistent marshalling of the data by RPC for
                  all 32-bit / 64-bit client / server combinations.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    This RPC server interface is used by local RPC clients only; it is never
    called remotely.

--*/

{
    CONFIGRET Status = CR_SUCCESS;
    RPC_STATUS rpcStatus;
    DEV_BROADCAST_HDR UNALIGNED *p;
    PPNP_NOTIFY_ENTRY entry = NULL;
    ULONG hashValue, ulSessionId;
    HANDLE hProcess = NULL, localHandle = NULL;
    PPNP_NOTIFY_LIST notifyList;
    BOOLEAN bLocked = FALSE, bCritSecHeld = FALSE;

    try {
        //
        // Validate parameters.
        //
        if (!ARGUMENT_PRESENT(Context)) {
            return CR_INVALID_POINTER;
        }

        *Context = NULL;

        if ((!ARGUMENT_PRESENT(NotificationFilter)) ||
            (!ARGUMENT_PRESENT(ClientContext)) ||
            (*ClientContext == 0)) {
            return CR_INVALID_POINTER;
        }

        //
        // DEVICE_NOTIFY_BITS is a private mask, defined specifically for
        // validation by the client and server.  It contains the bitmask for all
        // handle types (DEVICE_NOTIFY_COMPLETION_HANDLE specifically excluded
        // below), and all other flags that are currently defined - both public
        // and reserved.
        //
        if (INVALID_FLAGS(Flags, DEVICE_NOTIFY_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // Completion handles are not currently implemented.
        // DEVICE_NOTIFY_COMPLETION_HANDLE defined privately in winuserp.h,
        // reserved for future use (??).
        //
        if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) ==
            DEVICE_NOTIFY_COMPLETION_HANDLE) {
            return CR_INVALID_FLAG;
        }

        //
        // Make sure the Notification filter is a valid size.
        //
        if ((ulSize < sizeof(DEV_BROADCAST_HDR)) ||
            (((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size < sizeof(DEV_BROADCAST_HDR))) {
            return CR_BUFFER_SMALL;
        }

        ASSERT(ulSize == ((PDEV_BROADCAST_HDR)NotificationFilter)->dbch_size);

        //
        // Impersonate the client and retrieve the SessionId.
        //
        rpcStatus = RpcImpersonateClient(hBinding);
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                       rpcStatus));
            return CR_FAILURE;
        }

        ulSessionId = GetClientLogonId();

        rpcStatus = RpcRevertToSelf();
        if (rpcStatus != RPC_S_OK) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
            ASSERT(0);
        }

        //
        // Handle the different types of notification filters.
        //
        p = (PDEV_BROADCAST_HDR)NotificationFilter;

        switch (p->dbch_devicetype) {

        case DBT_DEVTYP_OEM:
        case DBT_DEVTYP_VOLUME:
        case DBT_DEVTYP_PORT:
        case DBT_DEVTYP_NET:
            //
            // These structures are either obsolete, or used for broadcast-only
            // notifications.
            //
            Status = CR_INVALID_DATA;
            break;


        case DBT_DEVTYP_HANDLE: {
            //
            // DEV_BROADCAST_HANDLE based notification.
            //
            DEV_BROADCAST_HANDLE UNALIGNED *filter = (PDEV_BROADCAST_HANDLE)NotificationFilter;
            PLUGPLAY_CONTROL_TARGET_RELATION_DATA controlData;
            NTSTATUS ntStatus;
#ifdef _WIN64
            DEV_BROADCAST_HANDLE64 UNALIGNED filter64;

            //
            // Check if the client is running on WOW64.
            //
            if (Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                //
                // Convert the 32-bit DEV_BROADCAST_HANDLE notification filter
                // to 64-bit.
                //
                DEV_BROADCAST_HANDLE32 UNALIGNED *filter32 = (PDEV_BROADCAST_HANDLE32)NotificationFilter;

                //
                // Validate the 32-bit input filter data
                //
                ASSERT(filter32->dbch_size >= sizeof(DEV_BROADCAST_HANDLE32));
                if (filter32->dbch_size < sizeof(DEV_BROADCAST_HANDLE32) ||
                    ulSize < sizeof(DEV_BROADCAST_HANDLE32)) {
                    Status = CR_INVALID_DATA;
                    goto Clean0;
                }

                memset(&filter64, 0, sizeof(DEV_BROADCAST_HANDLE64));
                filter64.dbch_size = sizeof(DEV_BROADCAST_HANDLE64);
                filter64.dbch_devicetype = DBT_DEVTYP_HANDLE;
                filter64.dbch_handle = (ULONG64)filter32->dbch_handle;

                //
                // use the converted 64-bit filter and size from now on, instead
                // of the caller supplied 32-bit filter.
                //
                filter = (PDEV_BROADCAST_HANDLE)&filter64;
                ulSize = sizeof(DEV_BROADCAST_HANDLE64);
            }
#endif // _WIN64

            //
            // Validate the input filter data
            //
            if (filter->dbch_size < sizeof(DEV_BROADCAST_HANDLE) ||
                ulSize < sizeof(DEV_BROADCAST_HANDLE)) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // The DEVICE_NOTIFY_INCLUDE_ALL_INTERFACE_CLASSES flag is only
            // valid for the DBT_DEVTYP_DEVICEINTERFACE notification filter
            // type.
            //
            if ((Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                DEVICE_NOTIFY_ALL_INTERFACE_CLASSES) {
                Status = CR_INVALID_FLAG;
                goto Clean0;
            }

            entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
            if (entry == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Find the device id that corresponds to this file handle.
            // In this case, use a duplicated instance of the file handle
            // for this process, not the caller's process.
            //
            rpcStatus = RpcImpersonateClient(hBinding);
            if (rpcStatus != RPC_S_OK) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                           rpcStatus));
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                goto Clean0;
            }

            hProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, ProcessId);
            if (hProcess == NULL) {
                //
                // Last error set by OpenProcess routine
                //
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                rpcStatus = RpcRevertToSelf();
                if (rpcStatus != RPC_S_OK) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                               rpcStatus));
                    ASSERT(0);
                }
                goto Clean0;
            }


            if (!DuplicateHandle(hProcess,
                                 (HANDLE)filter->dbch_handle,
                                 GetCurrentProcess(),
                                 &localHandle,
                                 0,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS)) {
                //
                // Last error set by DuplicateHandle routine
                //
                Status = CR_FAILURE;
                HeapFree(ghPnPHeap, 0, entry);
                CloseHandle(hProcess);
                rpcStatus = RpcRevertToSelf();
                if (rpcStatus != RPC_S_OK) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                               rpcStatus));
                    ASSERT(0);
                }
                goto Clean0;
            }

            rpcStatus = RpcRevertToSelf();
            if (rpcStatus != RPC_S_OK) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                           rpcStatus));
                ASSERT(0);
            }

            memset(&controlData, 0 , sizeof(PLUGPLAY_CONTROL_TARGET_RELATION_DATA));
            controlData.UserFileHandle = localHandle;
            controlData.DeviceInstance = entry->u.Target.DeviceId;
            controlData.DeviceInstanceLen = sizeof(entry->u.Target.DeviceId);

            ntStatus = NtPlugPlayControl(PlugPlayControlTargetDeviceRelation,
                                         &controlData,
                                         sizeof(controlData));

            CloseHandle(localHandle);
            CloseHandle(hProcess);

            if (!NT_SUCCESS(ntStatus)) {
                Status = MapNtStatusToCmError(ntStatus);
                HeapFree(ghPnPHeap, 0, entry);
                goto Clean0;
            }

            //
            // Sanitize the device id
            //
            FixUpDeviceId(entry->u.Target.DeviceId);

            //
            // Copy the client name for the window or service, supplied by
            // ServiceName.
            //
            if (ServiceName) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PNP_RegisterNotification: Registering [%ws]\n",
                           ServiceName));

                entry->ClientName = HeapAlloc(ghPnPHeap,
                                              0,
                                              (lstrlen(ServiceName)+1)*sizeof (WCHAR));
                if (!entry->ClientName) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "UMPNPMGR: PNP_RegisterNotification failed to allocate memory for ClientName!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    HeapFree (ghPnPHeap,0,entry);
                    goto Clean0;
                }

                lstrcpy (entry->ClientName, ServiceName);

            } else {
                entry->ClientName = NULL;
            }

            //
            // Resolve the service status handle from the supplied service name.
            //
            if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

                hRecipient = (ULONG_PTR)NULL;

                if (pSCMAuthenticate && ServiceName) {

                    SERVICE_STATUS_HANDLE serviceHandle;

                    if (pSCMAuthenticate(ServiceName, &serviceHandle) == NO_ERROR) {
                        hRecipient = (ULONG_PTR)serviceHandle;
                    }
                }

                if (!hRecipient) {
                    Status = CR_INVALID_DATA;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    *Context = NULL;
                    goto Clean0;
                }
            }

            //
            // Add this entry to the target list
            //
            entry->Signature = TARGET_ENTRY_SIGNATURE;
            entry->Handle = (HANDLE)hRecipient;
            entry->Flags = Flags;
            entry->Unregistered = FALSE;
            entry->Freed = 0;
            entry->SessionId = ulSessionId;

            //
            // Save the caller's file handle (to pass back to caller
            // during notification).
            //
            entry->u.Target.FileHandle = filter->dbch_handle;

            EnterCriticalSection(&RegistrationCS);
            bCritSecHeld = TRUE;

            if (gNotificationInProg != 0) {
                //
                // If a notification is happening, add this entry to the list of
                // deferred registrations.
                //
                PPNP_DEFERRED_LIST regNode;
                regNode = (PPNP_DEFERRED_LIST)
                    HeapAlloc(ghPnPHeap,
                              0,
                              sizeof (PNP_DEFERRED_LIST));
                if (!regNode) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_WARNINGS,
                               "UMPNPMGR: Error allocating deferred list entry during registration!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    LeaveCriticalSection(&RegistrationCS);
                    bCritSecHeld = FALSE;
                    goto Clean0;
                }
                //
                // Do not notify this entry until after the current
                // notification is finished.
                //
                entry->Unregistered = TRUE;
                regNode->hBinding = 0;
                regNode->Entry = entry;
                regNode->Next = RegisterList;
                RegisterList = regNode;
            }

            hashValue = HashString(entry->u.Target.DeviceId, TARGET_HASH_BUCKETS);
            notifyList = &TargetList[hashValue];
            MarkEntryWithList(entry,hashValue);
            LockNotifyList(&notifyList->Lock);
            bLocked = TRUE;
            AddNotifyEntry(&TargetList[hashValue], entry);
            entry->ClientCtxPtr = (ULONG64)*ClientContext;
            *Context = entry;
            UnlockNotifyList(&notifyList->Lock);
            bLocked = FALSE;

            LeaveCriticalSection(&RegistrationCS);
            bCritSecHeld = FALSE;
            break;
        }


        case DBT_DEVTYP_DEVICEINTERFACE: {

            DEV_BROADCAST_DEVICEINTERFACE UNALIGNED *filter = (PDEV_BROADCAST_DEVICEINTERFACE)NotificationFilter;

            //
            // Validate the input filter data
            //
            if (filter->dbcc_size < sizeof(DEV_BROADCAST_DEVICEINTERFACE) ||
                ulSize < sizeof (DEV_BROADCAST_DEVICEINTERFACE) ) {
                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // We no longer support the private GUID_DEVNODE_CHANGE interface so return
            // CR_INVALID_DATA if this GUID is passed in.
            //
            if (GuidEqual(&GUID_DEVNODE_CHANGE, &filter->dbcc_classguid)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: RegisterDeviceNotification using GUID_DEVNODE_CHANGE is not supported!\n"));

                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            //
            // The GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES interface is
            // not supported directly.  It is for internal use only.  Return
            // CR_INVALID_DATA if this GUID is passed in.
            //
            if (GuidEqual(&GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
                          &filter->dbcc_classguid)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: RegisterDeviceNotification using this class GUID is not supported!\n"));

                Status = CR_INVALID_DATA;
                goto Clean0;
            }

            entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
            if (entry == NULL) {
                Status = CR_OUT_OF_MEMORY;
                goto Clean0;
            }

            //
            // Copy the client name for the window or service, supplied by
            // ServiceName.
            //
            if (ServiceName) {

                entry->ClientName = HeapAlloc(ghPnPHeap,
                                              0,
                                              (lstrlen(ServiceName)+1)*sizeof (WCHAR));
                if (!entry->ClientName) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS,
                               "UMPNPMGR: PNP_RegisterNotification failed to allocate memory for ClientName!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    HeapFree (ghPnPHeap,0,entry);
                    goto Clean0;
                }

                lstrcpy (entry->ClientName, ServiceName);

            } else {
                entry->ClientName = NULL;
            }

            //
            // Resolve the service status handle from the supplied service name.
            //
            if ((Flags & DEVICE_NOTIFY_HANDLE_MASK) == DEVICE_NOTIFY_SERVICE_HANDLE) {

                hRecipient = (ULONG_PTR)NULL;

                if (pSCMAuthenticate && ServiceName) {

                    SERVICE_STATUS_HANDLE serviceHandle;

                    if (pSCMAuthenticate(ServiceName, &serviceHandle) == NO_ERROR) {
                        hRecipient = (ULONG_PTR)serviceHandle;
                    }
                }

                if (!hRecipient) {
                    Status = CR_INVALID_DATA;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    *Context = NULL;
                    goto Clean0;
                }
            }

            //
            // Add this entry to the class list
            //
            entry->Signature = CLASS_ENTRY_SIGNATURE;
            entry->Handle = (HANDLE)hRecipient;
            entry->Flags = Flags;
            entry->Unregistered = FALSE;
            entry->Freed = 0;
            entry->SessionId = ulSessionId;

            //
            // If the caller is registering for all interface class events,
            // ignore the caller supplied class GUID and use a private GUID.
            // Otherwise, copy the caller supplied GUID to the notification list
            // entry.
            //
            if ((Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                DEVICE_NOTIFY_ALL_INTERFACE_CLASSES) {
                memcpy(&entry->u.Class.ClassGuid,
                       &GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES,
                       sizeof(GUID));
            } else {
                memcpy(&entry->u.Class.ClassGuid,
                       &filter->dbcc_classguid,
                       sizeof(GUID));
            }

            EnterCriticalSection(&RegistrationCS);
            bCritSecHeld = TRUE;

            if (gNotificationInProg != 0) {
                //
                // If a notification is happening, add this entry to the list of
                // deferred registrations.
                //
                PPNP_DEFERRED_LIST regNode;
                regNode = (PPNP_DEFERRED_LIST)
                    HeapAlloc(ghPnPHeap,
                              0,
                              sizeof (PNP_DEFERRED_LIST));
                if (!regNode) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_WARNINGS,
                               "UMPNPMGR: Error allocating deferred list entry during registration!\n"));
                    Status = CR_OUT_OF_MEMORY;
                    if (entry->ClientName) {
                        HeapFree(ghPnPHeap, 0, entry->ClientName);
                    }
                    HeapFree(ghPnPHeap, 0, entry);
                    LeaveCriticalSection(&RegistrationCS);
                    bCritSecHeld = FALSE;
                    goto Clean0;
                }
                //
                // Do not notify this entry until after the current
                // notification is finished.
                //
                entry->Unregistered = TRUE;
                regNode->hBinding = 0;
                regNode->Entry = entry;
                regNode->Next = RegisterList;
                RegisterList = regNode;
            }

            hashValue = HashClassGuid(&entry->u.Class.ClassGuid);
            notifyList = &ClassList[hashValue];
            MarkEntryWithList(entry,hashValue);
            LockNotifyList(&notifyList->Lock);
            bLocked = TRUE;
            AddNotifyEntry(&ClassList[hashValue],entry);
            entry->ClientCtxPtr = (ULONG64)*ClientContext;
            *Context = entry;
            UnlockNotifyList(&notifyList->Lock);
            bLocked = FALSE;

            LeaveCriticalSection(&RegistrationCS);
            bCritSecHeld = FALSE;
            break;
        }

        default:
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in PNP_RegisterNotification\n"));
        ASSERT(0);

        Status = CR_FAILURE;

        if (bLocked) {
            UnlockNotifyList(&notifyList->Lock);
        }
        if (bCritSecHeld) {
            LeaveCriticalSection(&RegistrationCS);
        }
    }

    return Status;

} // PNP_RegisterNotification



CONFIGRET
PNP_UnregisterNotification(
    IN handle_t hBinding,
    IN PPNP_NOTIFICATION_CONTEXT Context
    )
/*++

Routine Description:

    This routine is the rpc server-side of the CMP_UnregisterNotification routine.
    It performs the remaining parameter validation and unregisters the
    corresponding notification entry.

Arguments:

    hBinding     - RPC binding handle (not used).

    Context      - Contains the address of a HDEVNOTIFY notification handle that
                   was supplied when this notification request was registered.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    Note that the Context comes in as a PNP_NOTIFICATION_CONTEXT pointer
    It is NOT one of those. The case is correct. This is to work around
    RPC and user.

    This RPC server interface is used by local RPC clients only; it is never
    called remotely.

--*/
{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       hashValue = 0;
    PPNP_DEFERRED_LIST unregNode;
    PPNP_NOTIFY_LIST notifyList;
    BOOLEAN     bLocked = FALSE;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate notification handle
        //
        PPNP_NOTIFY_ENTRY entry = (PPNP_NOTIFY_ENTRY)*Context;

        EnterCriticalSection (&RegistrationCS);
        if (entry == NULL) {
            Status = CR_INVALID_DATA;
            goto Clean0;
        }

        if (gNotificationInProg  != 0) {

            if (RegisterList) {
                //
                // Check to see if this entry is in the deferred RegisterList.
                //
                PPNP_DEFERRED_LIST currReg,prevReg;

                currReg = RegisterList;
                prevReg = NULL;

                while (currReg) {
                    //
                    // Entries in the deferred RegisterList are to be skipped
                    // during notification.
                    //
                    ASSERT(currReg->Entry->Unregistered);
                    if (currReg->Entry == entry) {
                        //
                        // Remove this entry from the deferred RegisterList.
                        //
                        if (prevReg) {
                            prevReg->Next = currReg->Next;
                        } else {
                            RegisterList = currReg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currReg);
                        if (prevReg) {
                            currReg = prevReg->Next;
                        } else {
                            currReg = RegisterList;
                        }
                    } else {
                        prevReg = currReg;
                        currReg = currReg->Next;
                    }
                }
            }


            switch (entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

                case CLASS_ENTRY_SIGNATURE:
                case TARGET_ENTRY_SIGNATURE: {

                    unregNode = (PPNP_DEFERRED_LIST)
                        HeapAlloc(ghPnPHeap,
                                  0,
                                  sizeof (PNP_DEFERRED_LIST));

                    if (!unregNode) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Error allocating deferred list entry during unregistration!\n"));
                        Status = CR_OUT_OF_MEMORY;
                        goto Clean0;
                    }

                    //
                    // This param is not used, if this changes, change this line too.
                    //
                    unregNode->hBinding= 0;

                    notifyList = GetNotifyListForEntry(entry);
                    if (notifyList) {
                        //
                        // The entry is part of a notification list, so make
                        // sure not to notify on it.
                        //
                        LockNotifyList(&notifyList->Lock);
                        bLocked = TRUE;
                        entry->Unregistered = TRUE;
                        UnlockNotifyList(&notifyList->Lock);
                        bLocked = FALSE;
                    }
                    unregNode->Entry = entry;
                    unregNode->Next = UnregisterList;
                    UnregisterList = unregNode;
                    *Context = NULL;
                    break;
                }

                default:
                    Status = CR_INVALID_DATA;
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_WARNINGS | DBGF_ERRORS,
                               "UMPNPMGR: PNP_UnregisterNotification: invalid signature on entry at %x\n",
                               entry));
                    break;
            }
            goto Clean0;
        }

        //
        // Free the notification entry from the appropriate list.
        //
        switch (entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

            case CLASS_ENTRY_SIGNATURE:
                hashValue = HashClassGuid(&entry->u.Class.ClassGuid);
                notifyList = &ClassList[hashValue];
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_CLASS);
                DeleteNotifyEntry(entry,TRUE);
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
                *Context = NULL;
                break;

            case TARGET_ENTRY_SIGNATURE:
                hashValue = HashString(entry->u.Target.DeviceId, TARGET_HASH_BUCKETS);
                notifyList = &TargetList[hashValue];
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_TARGET);
                DeleteNotifyEntry(entry,TRUE);
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
                *Context = NULL;
                break;

            default:
                Status = CR_INVALID_DATA;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS | DBGF_ERRORS,
                           "UMPNPMGR: PNP_UnregisterNotification: invalid signature on entry at %x\n",
                           entry));
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: PNP_UnregisterNotification caused an exception!\n"));
        ASSERT(0);
        SetLastError(ERROR_EXCEPTION_IN_SERVICE);
        Status = CR_FAILURE;

        if (bLocked) {
            UnlockNotifyList(&notifyList->Lock);
        }
        LeaveCriticalSection(&RegistrationCS);
    }

    return Status;

} // PNP_UnregisterNotification




//-----------------------------------------------------------------------------
// Dynamic Event Notification Support
//-----------------------------------------------------------------------------



DWORD
ThreadProc_DeviceEvent(
   LPDWORD lpParam
   )

/*++

Routine Description:

    This routine is a thread procedure. This thread handles all device event
    notification from kernel-mode.

Arguments:

   lpParam - Not used.

Return Value:

   Currently returns TRUE/FALSE.

--*/

{
    DWORD                               status = TRUE, result = 0;
    NTSTATUS                            ntStatus = STATUS_SUCCESS;
    PPLUGPLAY_EVENT_BLOCK               eventBlock = NULL;
    ULONG                               totalSize, variableSize;
    BOOL                                notDone = TRUE;
    PVOID                               p = NULL;
    PNP_VETO_TYPE                       vetoType;
    WCHAR                               vetoName[MAX_VETO_NAME_LENGTH];
    ULONG                               vetoNameLength;
    PLUGPLAY_CONTROL_USER_RESPONSE_DATA userResponse;
    PPNP_NOTIFY_LIST notifyList;
    PPNP_DEFERRED_LIST reg,regFree,unreg,unregFree,rundown,rundownFree;

    UNREFERENCED_PARAMETER(lpParam);


    try {

        //
        // Initialize event buffer used to pass info back from kernel-mode in.
        //

        variableSize = 4096 - sizeof(PLUGPLAY_EVENT_BLOCK);
        totalSize = sizeof(PLUGPLAY_EVENT_BLOCK) + variableSize;

        eventBlock = (PPLUGPLAY_EVENT_BLOCK)HeapAlloc(ghPnPHeap, 0, totalSize);
        if (eventBlock == NULL) {
            LogErrorEvent(ERR_ALLOCATING_EVENT_BLOCK, ERROR_NOT_ENOUGH_MEMORY, 0);
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            status = FALSE;
            ASSERT(0);
            goto Clean0;
        }

        //
        // Retrieve device events synchronously (this is more efficient
        // than using apcs).
        //
        while (notDone) {

            ntStatus = NtGetPlugPlayEvent(NULL,
                                          NULL,     // Context
                                          eventBlock,
                                          totalSize);

            if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
                //
                // Kernel-mode side couldn't transfer the event because
                // my buffer is too small, realloc and attempt to retrieve
                // the event again.
                //
                variableSize += 1024;
                totalSize = variableSize + sizeof(PLUGPLAY_EVENT_BLOCK);

                p = HeapReAlloc(ghPnPHeap, 0, eventBlock, totalSize);
                if (p == NULL) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Couldn't reallocate event block to size %d\n",
                               totalSize));

                    LogErrorEvent(ERR_ALLOCATING_EVENT_BLOCK, ERROR_NOT_ENOUGH_MEMORY, 0);
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    status = FALSE;
                    ASSERT(0);
                    goto Clean0;
                }
                eventBlock = (PPLUGPLAY_EVENT_BLOCK)p;
            }

            if (ntStatus == STATUS_SUCCESS) {
                //
                // An event was retrieved, process it.
                //
                gNotificationInProg = 1;

                vetoType = PNP_VetoTypeUnknown;
                vetoName[0] = L'\0';
                vetoNameLength = MAX_VETO_NAME_LENGTH;

                try {
                    //
                    // Process the device event.
                    //
                    result = ProcessDeviceEvent(eventBlock,
                                                totalSize,
                                                &vetoType,
                                                vetoName,
                                                &vetoNameLength);

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS | DBGF_EVENT,
                               "UMPNPMGR: Exception in ProcessDeviceEvent!\n"));
                    ASSERT(0);

                    //
                    // An exception while processing the event should not be
                    // considered a failure of the event itself.
                    //
                    result = TRUE;
                    vetoType = PNP_VetoTypeUnknown;
                    vetoName[0] = L'\0';
                    vetoNameLength = 0;
                }

                ASSERT(vetoNameLength < MAX_VETO_NAME_LENGTH &&
                       vetoName[vetoNameLength] == L'\0');

                //
                // Notify kernel-mode of the user-mode result.
                //
                userResponse.Response = result;
                userResponse.VetoType = vetoType;
                userResponse.VetoName = vetoName;
                userResponse.VetoNameLength = vetoNameLength;

                NtPlugPlayControl(PlugPlayControlUserResponse,
                                  &userResponse,
                                  sizeof(userResponse));

                EnterCriticalSection (&RegistrationCS);

                if (RegisterList != NULL) {
                    //
                    // Complete Registrations requested during notification.
                    //
                    reg = RegisterList;
                    RegisterList=NULL;
                } else {
                    reg = NULL;
                }
                if (UnregisterList != NULL) {
                    //
                    // Complete Unregistrations requested during notification.
                    //
                    unreg = UnregisterList;
                    UnregisterList = NULL;
                } else {
                    unreg = NULL;
                }
                if (RundownList != NULL) {
                    //
                    // Complete Unregistrations requested during notification.
                    //
                    rundown = RundownList;
                    RundownList = NULL;
                } else {
                    rundown = NULL;
                }
                gNotificationInProg = 0;

                while (reg) {
                    //
                    // This entry has already been added to the appropriate
                    // notification list.  Allow this entry to receive
                    // notifications.
                    //
                    notifyList = GetNotifyListForEntry(reg->Entry);
                    ASSERT(notifyList);
                    if (notifyList) {
                        LockNotifyList(&notifyList->Lock);
                    }
                    reg->Entry->Unregistered = FALSE;
                    if (notifyList) {
                        UnlockNotifyList(&notifyList->Lock);
                    }
                    //
                    // Remove the entry from the deferred registration list.
                    //
                    regFree = reg;
                    reg = reg->Next;
                    HeapFree(ghPnPHeap, 0, regFree);
                }

                while (unreg) {
                    PNP_UnregisterNotification(unreg->hBinding,&unreg->Entry);
                    //
                    // Remove the entry from the deferred unregistration list.
                    //
                    unregFree = unreg;
                    unreg = unreg->Next;
                    HeapFree(ghPnPHeap, 0, unregFree);
                }

                while (rundown) {
                    PNP_NOTIFICATION_CONTEXT_rundown(rundown->Entry);
                    //
                    // Remove the entry from the deferred rundown list.
                    //
                    rundownFree = rundown;
                    rundown = rundown->Next;
                    HeapFree(ghPnPHeap, 0, rundownFree);
                }

                LeaveCriticalSection(&RegistrationCS);
            }

            if (ntStatus == STATUS_NOT_IMPLEMENTED) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: NtGetPlugPlayEvent returned STATUS_NOT_IMPLEMENTED\n"));

                ASSERT(FALSE);
            }

            if (ntStatus == STATUS_USER_APC) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: ThreadProc_DeviceEvent exiting on STATUS_USER_APC\n"));

                ASSERT(FALSE);
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_EVENT,
                   "UMPNPMGR: Exception in ThreadProc_DeviceEvent!\n"));
        ASSERT(0);
        status = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        eventBlock = eventBlock;
    }

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_ERRORS | DBGF_EVENT,
               "UMPNPMGR: Exiting ThreadProc_DeviceEvent!!!!\n"));

    TermNotification();

    if (eventBlock != NULL) {
        HeapFree(ghPnPHeap, 0, eventBlock);
    }

    return status;

} // ThreadProc_DeviceEvent



BOOL
InitNotification(
    VOID
    )

/*++

Routine Description:

    This routine allocates and initializes notification lists, etc.

Arguments:

   Not used.

Return Value:

   Currently returns TRUE/FALSE.

--*/

{
    ULONG i;

    //
    // Initialize the interface device (class) list
    //
    memset(ClassList, 0, sizeof(PNP_NOTIFY_LIST) * CLASS_GUID_HASH_BUCKETS);
    for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {
        ClassList[i].Next = NULL;
        ClassList[i].Previous = NULL;
        InitPrivateResource(&ClassList[i].Lock);
    }

    //
    // Initialize the target device list
    //
    memset(TargetList, 0, sizeof(PNP_NOTIFY_LIST) * TARGET_HASH_BUCKETS);
    for (i = 0; i < TARGET_HASH_BUCKETS; i++) {
        TargetList[i].Next = NULL;
        TargetList[i].Previous = NULL;
        InitPrivateResource(&TargetList[i].Lock);
    }

    //
    // Initialize the install list
    //
    InstallList.Next = NULL;
    InitPrivateResource(&InstallList.Lock);

    //
    // Initialize the install client list
    //
    InstallClientList.Next = NULL;
    InitPrivateResource(&InstallClientList.Lock);

    //
    // Initialize the lock for user token access
    //
    InitPrivateResource(&gTokenLock);

    //
    // Initialize the service handle list
    //
    memset(ServiceList, 0, sizeof(PNP_NOTIFY_LIST) * SERVICE_NUM_CONTROLS);
    for (i = 0; i < SERVICE_NUM_CONTROLS; i++) {
        ServiceList[i].Next = NULL;
        ServiceList[i].Previous = NULL;
        InitPrivateResource(&ServiceList[i].Lock);
    }

    //
    // Initialize Registration/Unregistration CS.
    //
    try {
        InitializeCriticalSection(&RegistrationCS);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        return FALSE;
    }

    //
    // Initialize deferred Registration/Unregistration lists.
    //
    RegisterList = NULL;
    UnregisterList = NULL;
    RundownList = NULL;

    //
    // Initialize gNotificationInProg flag.
    //
    gNotificationInProg = 0;

    return TRUE;

} // InitNotification



VOID
TermNotification(
    VOID
    )
/*++

Routine Description:

    This routine frees notification resources.

Arguments:

   Not used.

Return Value:

   No return.

--*/
{
    ULONG i;

    //
    // Free the interface device (class) list locks
    //
    for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {
        if (LockNotifyList(&ClassList[i].Lock)) {
            DestroyPrivateResource(&ClassList[i].Lock);
        }
    }

    //
    // Free the target device list locks
    //
    for (i = 0; i < TARGET_HASH_BUCKETS; i++) {
        if (LockNotifyList(&TargetList[i].Lock)) {
            DestroyPrivateResource(&TargetList[i].Lock);
        }
    }

    //
    // Free the service notification list locks
    //
    for (i = 0; i < SERVICE_NUM_CONTROLS; i++) {
        if (LockNotifyList(&ServiceList[i].Lock)) {
            DestroyPrivateResource(&ServiceList[i].Lock);
        }
    }

    //
    // Free the install list lock
    //
    if (LockNotifyList(&InstallList.Lock)) {
        DestroyPrivateResource(&InstallList.Lock);
    }

    //
    // Free the lock for user token access
    //
    if (LockNotifyList(&gTokenLock)) {
        DestroyPrivateResource(&gTokenLock);
    }

    //
    // Free the install client list lock
    //
    if (LockNotifyList(&InstallClientList.Lock)) {
        DestroyPrivateResource(&InstallClientList.Lock);
    }

    //
    // Close the handle to winsta.dll
    //
    if (ghWinStaLib) {
        fpWinStationSendWindowMessage = NULL;
        fpWinStationBroadcastSystemMessage = NULL;
        FreeLibrary(ghWinStaLib);
        ghWinStaLib = NULL;
    }

    //
    // Close the handle to wtsapi32.dll
    //
    if (ghWtsApi32Lib) {
        fpWTSQuerySessionInformation = NULL;
        fpWTSFreeMemory = NULL;
        FreeLibrary(ghWtsApi32Lib);
        ghWtsApi32Lib = NULL;
    }

    return;

} // TermNotification



ULONG
ProcessDeviceEvent(
    IN PPLUGPLAY_EVENT_BLOCK EventBlock,
    IN DWORD                 EventBufferSize,
    OUT PPNP_VETO_TYPE       VetoType,
    OUT LPWSTR               VetoName,
    IN OUT PULONG            VetoNameLength
    )
/*++

Routine Description:

    This routine processes device events recieved from the kernel-mode pnp
    manager.

Arguments:

   EventBlock - contains the event data.

   EventBlockSize - specifies the size (in bytes) of EventBlock.

Return Value:

   Returns FALSE if unsuccessful, or in the case of a vetoed query event.
   Returns TRUE otherwise.

Notes:

   This routine takes part in translating kernel mode PnP events into user mode
   notifications. Currently, the notification code is dispersed and duplicated
   throughout several routines. All notifications can be said to have the
   following form though:

   result = DeliverMessage(
       MessageFlags,    // [MSG_POST, MSG_SEND, MSG_QUERY] |
                        // [MSG_WALK_LIST_FORWARD, MSG_WALK_LIST_BACKWARDS]
       Target,          // A local window handle, hydra window handle (with
                        // session ID), service handle, or "broadcast".
                        // Better yet, it could take lists...
       wParam,          // DBT_* (or corresponding SERVICE_CONTROL_* message)
       lParam,          // Appropriate data (note: user has hardcoded knowledge
                        //                   about these via DBT_ type).
       queueTimeout,    // Exceeded if there exists messages in the queue but
                        // no message has been drained in the given time. Note
                        // that this means a message can fail immediately.
       responseTimeout, // Exceeded if *this* message has not been processed in
                        // the elasped time.
       VetoName,        // For queries, the name of the vetoer.
       VetoType         // Type of vetoer component (window, service, ...)
       );

   DeviceEventWorker implements targeted sends and posts (normal exported Win32
     API cannot be used as they won't reach other desktops). Currently User32
     does not allow posts of DBT_* messages with lParam data, mainly because
     a caller might send the message to itself, in which case no copy is made.
     This in theory presents the caller with no opportunity to free that data
     (note that this scenario would never occur with UmPnpMgr however, as we
     have no WndProc). User implements this function with a fixed
     responseTimeout of thirty seconds. This API can but should not be used for
     broadcasts.

   WinStationSendWindowMessage sends messages to windows within Hydra clients
     on a machine. There is no corresponding WinStationPostWindowMessage. All
     the code in this component passes a ResponseTimeout of five seconds. There
     is no queueTimeout.

   BroadcastSystemMessage implements broadcasts to all applications and desktops
     in the non-console (ie non-Hydra) session. As with DeviceEventWorker,
     User32 does not allow posts of DBT_* messages with lParam data (regardless
     of whether you pass in BSF_IGNORECURRENTTASK). All code in this component
     passes a ResponseTimeout of thirty seconds. QueueTimeout is optional,
     fixed five seconds. ResponseTimeout cannot be specified, but the maximum
     value would be five seconds per top level window. There is no information
     returned on which window vetoed a query.

   WinStationBroadcastSystemMessage broadcasts to all applications and desktops
     on a given machine's Hydra sessions. No posts of any kind may be done
     through this API. All code in this component passes a ResponseTimeout of
     five seconds. QueueTimeout is an optional, fixed five seconds. There is no
     information on which window vetoed a query.

   ServiceControlCallback sends messages to registered services. There is no
     posting or timeout facilities of any kind.

   Actually, each queued registration entry should be queued with a callback.
   We implement the callback, and there it hides the underlying complexities.

--*/

{
    DWORD eventId, serviceControl, flags, status = TRUE;
    LPWSTR p = NULL;
    ULONG vetoNameSize;
    DWORD dwLengthIDs;
    ULONG ulLength, ulCustomDataLength, ulClientSessionId;

    UNREFERENCED_PARAMETER(EventBufferSize);

    ASSERT(EventBlock->TotalSize >= sizeof(PLUGPLAY_EVENT_BLOCK));

    //
    // Convert the event guid into a dbt style event id.
    //

    if (!EventIdFromEventGuid(&EventBlock->EventGuid,
                              &eventId,
                              &flags,
                              &serviceControl)) {

        if (VetoNameLength != NULL) {
            *VetoNameLength = 0;
        }
        return FALSE;
    }
    if (VetoNameLength != NULL &&
        !((EventBlock->EventCategory == TargetDeviceChangeEvent) ||
          (EventBlock->EventCategory == CustomDeviceEvent) ||
          (EventBlock->EventCategory == HardwareProfileChangeEvent) ||
          (EventBlock->EventCategory == PowerEvent) ) ){
        *VetoNameLength = 0;
    }

    vetoNameSize = *VetoNameLength;

    //
    // Notify registered callers first (class changes will also send generic
    // broadcast if the type is volume or port).
    //

    switch (EventBlock->EventCategory) {

    case CustomDeviceEvent: {
        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_HANDLE pNotify;
        PLUGPLAY_CUSTOM_NOTIFICATION *pTarget;

        if (*EventBlock->u.CustomNotification.DeviceIds == L'\0') {
            //
            // There are no device IDs, can't do notification in this case
            // just return
            //

            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Ignoring CustomDeviceEvent with no Device IDs\n"));

            return FALSE;
        }

        //
        // Custom events should always be this GUID, and that guid should always
        // be converted into the below eventId.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_PNP_CUSTOM_NOTIFICATION));
        ASSERT(eventId == DBT_CUSTOMEVENT);

        //
        // Handle and Marshall the custom notification.
        //

        //
        // The amount of space allocated for the EventBlock + IDs is always a
        // multiple of sizeof(PVOID) in order to keep the notification structure
        // aligned.
        //
        ulLength = sizeof(PLUGPLAY_EVENT_BLOCK) + (lstrlen(EventBlock->u.CustomNotification.DeviceIds) + 1) * sizeof(WCHAR);

        ulLength += sizeof(PVOID) - 1;
        ulLength &= ~(sizeof(PVOID) - 1);

        //
        // The notification structure follows the Event Block and IDs
        //

        pTarget = (PPLUGPLAY_CUSTOM_NOTIFICATION)((PUCHAR)EventBlock + ulLength);

        ulCustomDataLength = pTarget->HeaderInfo.Size - FIELD_OFFSET(PLUGPLAY_CUSTOM_NOTIFICATION,CustomDataBuffer);

        pNotify = HeapAlloc(ghPnPHeap, 0, sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength);

        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_NOTIFICATION_STRUCTURE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            break;
        }

        memset(pNotify, 0, sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength);

        pNotify->dbch_size = sizeof(DEV_BROADCAST_HANDLE) + ulCustomDataLength;


        pNotify->dbch_devicetype = DBT_DEVTYP_HANDLE;

        pNotify->dbch_nameoffset = pTarget->NameBufferOffset;
        pNotify->dbch_eventguid = pTarget->HeaderInfo.Event;

        memcpy( pNotify->dbch_data, pTarget->CustomDataBuffer, ulCustomDataLength);

        *VetoNameLength = vetoNameSize;

        status = NotifyTargetDeviceChange( serviceControl,
                                           eventId,
                                           flags,
                                           pNotify,
                                           EventBlock->u.CustomNotification.DeviceIds,
                                           VetoType,
                                           VetoName,
                                           VetoNameLength);

        if (GuidEqual(&pNotify->dbch_eventguid, (LPGUID)&GUID_IO_VOLUME_NAME_CHANGE)) {
            //
            // Broadcast compatible volume removal and arrival notifications
            // (if any) after the custom name change event has been sent to
            // all recipients.
            //
            BroadcastVolumeNameChange();
        }

        HeapFree(ghPnPHeap, 0, pNotify);
        break;
    }

    case TargetDeviceChangeEvent: {

        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_HANDLE pNotify;

        if (*EventBlock->u.TargetDevice.DeviceIds == L'\0') {
            //
            // There are no device IDs, can't do notification in this case
            // just return
            //

            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: Ignoring TargetDeviceChangeEvent with no Device IDs\n"));

            return FALSE;
        }

        //
        // If this is a surprise removal event then call HOTPLUG.DLL to display
        // a warning to the user before sending this event to other apps.
        //
        if (GuidEqual(&EventBlock->EventGuid,&GUID_DEVICE_SAFE_REMOVAL)) {

            SendHotplugNotification(
                &EventBlock->EventGuid,
                NULL,
                EventBlock->u.TargetDevice.DeviceIds,
                &ulClientSessionId,
                HOTPLUG_DISPLAY_ON_CONSOLE
                );

        } else if (GuidEqual(&EventBlock->EventGuid, &GUID_DEVICE_KERNEL_INITIATED_EJECT)) {

            *VetoNameLength = vetoNameSize;
            status = CheckEjectPermissions(
                EventBlock->u.TargetDevice.DeviceIds,
                VetoType,
                VetoName,
                VetoNameLength
                );

        } else if (GuidEqual(&EventBlock->EventGuid,&GUID_DEVICE_SURPRISE_REMOVAL)) {

            LogSurpriseRemovalEvent(EventBlock->u.TargetDevice.DeviceIds);

#if 0 // We don't display surpise-removal bubbles anymore...
            SendHotplugNotification(
                &EventBlock->EventGuid,
                NULL,
                EventBlock->u.TargetDevice.DeviceIds,
                &ulClientSessionId,
                HOTPLUG_DISPLAY_ON_CONSOLE
                );
#endif
        }

        if (eventId == 0) {

            //
            // Internal event, no broadcasting should be done.
            //
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }

            break;
        }

        pNotify = HeapAlloc(ghPnPHeap, 0, sizeof(DEV_BROADCAST_HANDLE));
        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_BROADCAST_HANDLE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }
            break;
        }

        memset(pNotify, 0, sizeof(DEV_BROADCAST_HANDLE));

        pNotify->dbch_nameoffset = -1;  // empty except for custom events
        pNotify->dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        pNotify->dbch_devicetype = DBT_DEVTYP_HANDLE;

        for (p = EventBlock->u.TargetDevice.DeviceIds;
             *p;
             p += lstrlen(p) + 1) {

            *VetoNameLength = vetoNameSize;

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: Processing TargetDeviceChangeEvent (0x%lx) for %ws\n",
                       eventId, p));

            status = NotifyTargetDeviceChange(serviceControl,
                                              eventId,
                                              flags,
                                              pNotify,
                                              p,
                                              VetoType,
                                              VetoName,
                                              VetoNameLength);

            if (!status && (flags & BSF_QUERY)) {
                LPWSTR pFail = p;
                DWORD dwCancelEventId;

                //
                // Use the appropriate cancel device event id that corresponds to the
                // original query device event id.
                //

                dwCancelEventId = MapQueryEventToCancelEvent(eventId);

                for (p = EventBlock->u.TargetDevice.DeviceIds;
                    *p && p != pFail;
                    p += lstrlen(p) + 1) {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT,
                               "UMPNPMGR: Processing TargetDeviceChangeEvent (0x%lx) for %ws\n",
                               dwCancelEventId, p));

                    NotifyTargetDeviceChange( serviceControl,
                                              dwCancelEventId,
                                              BSF_NOHANG,
                                              pNotify,
                                              p,
                                              NULL,
                                              NULL,
                                              NULL);

                }
                break;
            }
        }

        HeapFree(ghPnPHeap, 0, pNotify);
        break;
    }

    case DeviceClassChangeEvent: {

        //
        // Convert the pnp event block into a dbt style structure.
        //

        PDEV_BROADCAST_DEVICEINTERFACE pNotify;
        ULONG ulSize = sizeof(DEV_BROADCAST_DEVICEINTERFACE) +
                       lstrlen(EventBlock->u.DeviceClass.SymbolicLinkName) * sizeof(WCHAR);

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing DeviceClassChangeEvent (0x%lx) for %ws\n",
                   eventId, EventBlock->u.DeviceClass.SymbolicLinkName));

        pNotify = HeapAlloc(ghPnPHeap, 0, ulSize);
        if (pNotify == NULL) {
            LogErrorEvent(ERR_ALLOCATING_BROADCAST_INTERFACE, ERROR_NOT_ENOUGH_MEMORY, 0);
            status = FALSE;
            break;
        }

        pNotify->dbcc_size = ulSize;
        pNotify->dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
        pNotify->dbcc_reserved = 0;
        memcpy(&pNotify->dbcc_classguid, &EventBlock->u.DeviceClass.ClassGuid, sizeof(GUID));
        lstrcpy(pNotify->dbcc_name, EventBlock->u.DeviceClass.SymbolicLinkName);

        //
        // Note: the symbolic link name is passed in kernel-mode format (\??\),
        // convert to user-mode format (\\?\) before sending notification.
        // Note that the only difference is the second character.
        //
        pNotify->dbcc_name[1] = L'\\';

        status = NotifyInterfaceClassChange(serviceControl,
                                            eventId,
                                            flags,
                                            pNotify);
        break;
    }

    case HardwareProfileChangeEvent:

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing HardwareProfileChangeEvent (0x%lx)\n",
                   eventId));

        *VetoNameLength = vetoNameSize;
        status = NotifyHardwareProfileChange(serviceControl,
                                             eventId,
                                             flags,
                                             VetoType,
                                             VetoName,
                                             VetoNameLength);
        break;

    case PowerEvent:
        *VetoNameLength = vetoNameSize;

        //
        // Since all power events arrive under a single event GUID,
        // EventIdFromEventGuid cannot correctly determine the event id or query
        // flags from it.  Instead, we get the event id directly from the device
        // event block, and add the BSF_QUERY flag here, if appropriate.
        //
        eventId = EventBlock->u.PowerNotification.NotificationCode;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing PowerEvent (0x%lx)\n",
                   eventId));

        if ((eventId == PBT_APMQUERYSUSPEND) ||
            (eventId == PBT_APMQUERYSTANDBY)) {
            flags |= BSF_QUERY;
        } else {
            flags &= ~BSF_QUERY;
        }

        status = NotifyPower(serviceControl,
                             eventId,
                             EventBlock->u.PowerNotification.NotificationData,
                             flags,
                             VetoType,
                             VetoName,
                             VetoNameLength);
        break;

    case VetoEvent:

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing VetoEvent\n"));

        status = SendHotplugNotification(
            &EventBlock->EventGuid,
            &EventBlock->u.VetoNotification.VetoType,
            EventBlock->u.VetoNotification.DeviceIdVetoNameBuffer,
            &ulClientSessionId,
            HOTPLUG_DISPLAY_ON_CONSOLE
            );

        break;

    case DeviceInstallEvent: {

        //
        // Initiate installation; we can't wait around here for a user, but
        // after installation is complete, kernel-mode will be notified
        // that they can attempt to start the device now.
        //
        PPNP_INSTALL_ENTRY entry = NULL, current = NULL;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing DeviceInstallEvent for %ws\n",
                   EventBlock->u.InstallDevice.DeviceId));

        //
        // Device install events should always be this GUID, and that guid
        // should always be converted into the below eventId, serviceControl and
        // flags.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_DEVICE_ENUMERATED));
        ASSERT((eventId == DBT_DEVICEARRIVAL) && (serviceControl == 0) && (flags == 0));

        //
        // Allocate and initialize a new device install entry block.
        //
        entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_INSTALL_ENTRY));
        if (!entry) {
            break;
        }

        entry->Next = NULL;
        entry->Flags = 0;
        lstrcpy(entry->szDeviceId, EventBlock->u.InstallDevice.DeviceId);

        //
        // Insert this entry in the device install list.
        //
        LockNotifyList(&InstallList.Lock);

        current = (PPNP_INSTALL_ENTRY)InstallList.Next;
        if (current == NULL) {
            InstallList.Next = entry;
        } else {
            while ((PPNP_INSTALL_ENTRY)current->Next != NULL) {
                current = (PPNP_INSTALL_ENTRY)current->Next;
            }
            current->Next = entry;
        }

        UnlockNotifyList(&InstallList.Lock);

        SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

        //
        // Generate a devnode changed message
        //
        NotifyTargetDeviceChange(serviceControl,
                                 eventId,
                                 flags,
                                 NULL,
                                 EventBlock->u.InstallDevice.DeviceId,
                                 NULL,
                                 NULL,
                                 NULL);

        break;
    }

    case BlockedDriverEvent: {

        LPGUID BlockedDriverGuid;
        PWSTR  MultiSzGuidList = NULL;

        //
        // Display notification to the Console session that the system just
        // blocked a driver from loading on the system.
        //
        ASSERT(GuidEqual(&EventBlock->EventGuid, &GUID_DRIVER_BLOCKED));

        //
        // We currently only ever have one blocked driver GUID per event,
        // but SendHotplugNotification and hotplug.dll are setup to deal
        // with multi-sz lists, so we'll just construct one for them.  This
        // keeps hotplug.dll extensible, should we decide in the future to
        // have the kernel-mode pnpmgr "batch" blocked drivers per devnode.
        //
        BlockedDriverGuid = (LPGUID)&EventBlock->u.BlockedDriverNotification.BlockedDriverGuid;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT,
                   "UMPNPMGR: Processing BlockedDriverEvent for GUID = "
                   "{%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
                   BlockedDriverGuid->Data1,
                   BlockedDriverGuid->Data2,
                   BlockedDriverGuid->Data3,
                   BlockedDriverGuid->Data4[0],
                   BlockedDriverGuid->Data4[1],
                   BlockedDriverGuid->Data4[2],
                   BlockedDriverGuid->Data4[3],
                   BlockedDriverGuid->Data4[4],
                   BlockedDriverGuid->Data4[5],
                   BlockedDriverGuid->Data4[6],
                   BlockedDriverGuid->Data4[7]));

        MultiSzGuidList = BuildBlockedDriverList(BlockedDriverGuid, 1);

        if (MultiSzGuidList != NULL) {
            SendHotplugNotification((LPGUID)&GUID_DRIVER_BLOCKED,
                                    NULL,
                                    MultiSzGuidList,
                                    &ulClientSessionId,
                                    HOTPLUG_DISPLAY_ON_CONSOLE);
            HeapFree(ghPnPHeap, 0, MultiSzGuidList);
            MultiSzGuidList = NULL;
        }

        break;
    }

    default:
        break;

    }

    return status;

} // ProcessDeviceEvent



ULONG
NotifyInterfaceClassChange(
    IN DWORD ServiceControl,
    IN DWORD EventId,
    IN DWORD Flags,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    )
/*++

Routine Description:

    This routine notifies registered services and windows of device interface
    change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Unused (Specifies BroadcastSystemMessage BSF_ flags.)

    ClassData      - Pointer to a PDEV_BROADCAST_DEVICEINTERFACE structure that
                     is already filled out with the pertinent data for this
                     event.

Return Value:

    Returns TRUE.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD result;
    ULONG hashValue, pass, i;
    PPNP_NOTIFY_ENTRY classEntry = NULL, nextEntry = NULL;
    PPNP_NOTIFY_LIST  notifyList;
    LPGUID entryGuid[3];

    UNREFERENCED_PARAMETER(Flags);

    //
    // Search the notification lists twice - once to notify entries registered
    // on the device interface class for this device interface, and again to
    // notify entries registered for all device interfaces.
    //
    entryGuid[0] = (LPGUID)&ClassData->dbcc_classguid;
    entryGuid[1] = (LPGUID)&GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES;
    entryGuid[2] = (LPGUID)NULL;

    for (i = 0; entryGuid[i] != NULL; i++) {

        //
        // The list of registered callers is hashed for quicker access and
        // comparison. Walk the list of registered callers and notify anyone
        // that registered an interest in this device interface class guid.
        //
        hashValue = HashClassGuid(entryGuid[i]);
        notifyList = &ClassList[hashValue];
        LockNotifyList(&notifyList->Lock);

        classEntry = GetFirstNotifyEntry(&ClassList[hashValue], 0);
        pass = GetFirstPass(FALSE);
        while (pass != PASS_COMPLETE) {
            while (classEntry) {

                nextEntry = GetNextNotifyEntry(classEntry, 0);

                if (classEntry->Unregistered) {
                    classEntry = nextEntry;
                    continue;
                }

                if (GuidEqual(entryGuid[i], &classEntry->u.Class.ClassGuid)) {

                    if (GuidEqual(&classEntry->u.Class.ClassGuid,
                                  &GUID_DEVINTERFACE_INCLUDE_ALL_INTERFACE_CLASSES)) {
                        //
                        // If the entry is marked with our special GUID, make
                        // sure it is because it was registered with the
                        // appropriate flag.
                        //
                        ASSERT((classEntry->Flags & DEVICE_NOTIFY_PROPERTY_MASK) &
                               DEVICE_NOTIFY_ALL_INTERFACE_CLASSES);
                    }

                    if ((pass == DEVICE_NOTIFY_WINDOW_HANDLE) &&
                        (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_WINDOW_HANDLE)) {

                        //
                        // Note, class changes currently only support non-query type
                        // messages so special processing is not required (PostMessage
                        // only). Unfortunately, the PostMessage call currently fails
                        // if the high bit of the wParam value is set (which it is in
                        // this case), so we are forced to Send the message (rather than
                        // Post it). USER group implemented it this way because the original
                        // Win95 spec doesn't call for the recipient to free the message
                        // so we have to free it and we have no idea when it's safe
                        // with a PostMessage call.
                        //

                        UnlockNotifyList(&notifyList->Lock);
                        if (classEntry->SessionId == MAIN_SESSION) {

                            ntStatus = DeviceEventWorker(classEntry->Handle,
                                                         EventId,
                                                         (LPARAM)ClassData,
                                                         TRUE,
                                                         &result);

                        } else {
                            if (fpWinStationSendWindowMessage) {
                                try {
                                    if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                      classEntry->SessionId,
                                                                      DEFAULT_SEND_TIME_OUT,
                                                                      HandleToUlong(classEntry->Handle),
                                                                      WM_DEVICECHANGE,
                                                                      (WPARAM)EventId,
                                                                      (LPARAM)ClassData,
                                                                      &result)) {
                                        ntStatus = STATUS_SUCCESS;
                                    } else {
                                        ntStatus = STATUS_UNSUCCESSFUL;
                                    }
                                } except (EXCEPTION_EXECUTE_HANDLER) {
                                    KdPrintEx((DPFLTR_PNPMGR_ID,
                                               DBGF_ERRORS,
                                               "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                    ASSERT(0);
                                    ntStatus = STATUS_SUCCESS;
                                }
                            }

                        }
                        LockNotifyList(&notifyList->Lock);

                        if (!NT_SUCCESS(ntStatus)) {
                            if (ntStatus == STATUS_INVALID_HANDLE) {
                                //
                                // window handle no longer exists, cleanup this entry
                                //
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_WARNINGS | DBGF_ERRORS,
                                           "UMPNPMGR: Invalid window handle for '%ws' during DeviceClassChangeEvent, removing entry.\n",
                                           classEntry->ClientName));
                                classEntry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN);
                                DeleteNotifyEntry(classEntry,FALSE);

                            } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_WARNINGS | DBGF_ERRORS,
                                           "UMPNPMGR: Window '%ws' timed out on DeviceClassChangeEvent\n",
                                           classEntry->ClientName));
                                LogWarningEvent(WRN_INTERFACE_CHANGE_TIMED_OUT, 1, classEntry->ClientName);
                            }
                        }
                    } else if ((pass == DEVICE_NOTIFY_SERVICE_HANDLE) &&
                               (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_SERVICE_HANDLE)) {

                        //
                        // Call the services handler routine...
                        //
                        if (pServiceControlCallback) {
                            UnlockNotifyList(&notifyList->Lock);
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)classEntry->Handle,
                                                          ServiceControl,
                                                          EventId,
                                                          (LPARAM)ClassData,
                                                          &result);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                ASSERT(0);
                            }
                            LockNotifyList(&notifyList->Lock);
                        }

                    } else if ((pass == DEVICE_NOTIFY_COMPLETION_HANDLE) &&
                               (GetPassFromEntry(classEntry) == DEVICE_NOTIFY_COMPLETION_HANDLE)) {
                        //
                        // Complete the notification handle.
                        // NOTE: Notification completion handles not implemented.
                        //
                        ;
                    }
                }

                classEntry = nextEntry;
            }

            pass=GetNextPass(pass,FALSE);
            classEntry = GetFirstNotifyEntry (&ClassList[hashValue],0);
        }

        UnlockNotifyList(&notifyList->Lock);
    }

    //
    // Perform Win9x compatible device interface arrival and removal notification.
    //
    BroadcastCompatibleDeviceMsg(EventId, ClassData);

    HeapFree(ghPnPHeap, 0, ClassData);

    //
    // For device interface notification, there are no query type events, by
    // definition, so we always return TRUE from this routine (no veto).
    //
    return TRUE;

} // NotifyInterfaceClassChange



ULONG
NotifyTargetDeviceChange(
    IN  DWORD                   ServiceControl,
    IN  DWORD                   EventId,
    IN  DWORD                   Flags,
    IN  PDEV_BROADCAST_HANDLE   HandleData,
    IN  LPWSTR                  DeviceId,
    OUT PPNP_VETO_TYPE          VetoType       OPTIONAL,
    OUT LPWSTR                  VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies registered services and windows of target device
    change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.
                     Note that BroadcastSystemMessage is not actually used for
                     target device events, but the specified BSF_ flags are used
                     to determine query and cancel event notification ordering.

    HandleData     - Pointer to a PDEV_BROADCAST_HANDLE structure that is
                     already filled out with most of the pertinent data for this
                     event.

    DeviceId       - Supplies the device instance id of the target device for
                     this event.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

Note:

    For DBT_DEVICEARRIVAL, DBT_DEVICEREMOVEPENDING, and DBT_DEVICEREMOVECOMPLETE
    events this routine also broadcasts a WM_DEVICECHANGE / DBT_DEVNODES_CHANGED
    message to all windows.  There is no additional device-specific data for
    this message; it is only used by components like device manager to refresh
    the list of devices in the system.

    Also note that the DBT_DEVNODES_CHANGED message is the only notification
    sent for DBT_DEVICEARRIVAL (kernel GUID_DEVICE_ARRIVAL) events.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    LONG  result = 0;
    ULONG hashValue, pass;
    PPNP_NOTIFY_ENTRY targetEntry, nextEntry;
    PPNP_NOTIFY_LIST  notifyList;
    BOOL              bLocked = FALSE;
    DWORD err;
    BOOL serviceVetoedQuery;
    DWORD recipients = BSM_ALLDESKTOPS | BSM_APPLICATIONS;
    LONG response;
#ifdef _WIN64
    DEV_BROADCAST_HANDLE32 UNALIGNED *HandleData32 = NULL;
    ULONG  ulHandleDataSize;
#endif // _WIN64
    PVOID pHandleData;

    serviceVetoedQuery = FALSE;

    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    //
    // Broadcast the DBT_DEVNODES_CHANGED message before any other notification
    // events, so components listening for those can update themselves in a
    // timely manner, and not be delayed by apps/services hung on their
    // notification event.  This broadcasts is a post, so it will return
    // immediately, and complete asynchronously.
    //
    if ((EventId == DBT_DEVICEARRIVAL) ||
        (EventId == DBT_DEVICEREMOVEPENDING) ||
        (EventId == DBT_DEVICEREMOVECOMPLETE)) {

        BroadcastSystemMessage(BSF_POSTMESSAGE,
                               &recipients,
                               WM_DEVICECHANGE,
                               DBT_DEVNODES_CHANGED,
                               (LPARAM)NULL);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   BSF_NOHANG | BSF_POSTMESSAGE,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)DBT_DEVNODES_CHANGED,
                                                   (LPARAM)NULL,
                                                   &response);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }
    }

    //
    // For target device arrival events, no additional notification is
    // performed.
    //
    if (EventId == DBT_DEVICEARRIVAL) {
        goto Clean0;
    }

#ifdef _WIN64
    //
    // Prepare a 32-bit notification structure, which we'll need to send to any
    // WOW64 clients that are registered.
    //
    ASSERT(sizeof(DEV_BROADCAST_HANDLE) == sizeof(DEV_BROADCAST_HANDLE64));
    ASSERT(HandleData->dbch_size >= sizeof(DEV_BROADCAST_HANDLE64));

    ulHandleDataSize = HandleData->dbch_size -
        sizeof(DEV_BROADCAST_HANDLE64) +
        sizeof(DEV_BROADCAST_HANDLE32);

    ASSERT(ulHandleDataSize >= sizeof(DEV_BROADCAST_HANDLE32));

    HandleData32 = HeapAlloc(ghPnPHeap, 0, ulHandleDataSize);
    if (HandleData32 == NULL) {
        goto Clean0;
    }

    memset(HandleData32, 0, ulHandleDataSize);
    HandleData32->dbch_size = ulHandleDataSize;
    HandleData32->dbch_devicetype = DBT_DEVTYP_HANDLE;
    HandleData32->dbch_nameoffset = HandleData->dbch_nameoffset;

    memcpy(&HandleData32->dbch_eventguid,
           &HandleData->dbch_eventguid,
           sizeof(GUID));

    memcpy(&HandleData32->dbch_data,
           &HandleData->dbch_data,
           (HandleData->dbch_size - FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)));
#endif // _WIN64

    //
    // Sanitize the device id
    //
    FixUpDeviceId(DeviceId);

    //
    // The list of registered callers is hashed for quicker access and
    // comparison. Walk the list of registered callers and notify anyone
    // that registered an interest in this device instance.
    //

    hashValue = HashString(DeviceId, TARGET_HASH_BUCKETS);
    notifyList = &TargetList[hashValue];
    LockNotifyList(&notifyList->Lock);
    bLocked = TRUE;

    pass = GetFirstPass(Flags & BSF_QUERY);

    do {

        targetEntry = GetFirstNotifyEntry (notifyList,Flags);


        while (targetEntry) {

            nextEntry = GetNextNotifyEntry(targetEntry,Flags);

            if (targetEntry->Unregistered) {
                targetEntry = nextEntry;
                continue;
            }

            if (lstrcmpi(DeviceId, targetEntry->u.Target.DeviceId) == 0) {

                if ((pass == DEVICE_NOTIFY_WINDOW_HANDLE) &&
                    (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_WINDOW_HANDLE)) {


                    //
                    // Note: we could get away with only doing a send message
                    // if the Flags has BSF_QUERY set and do a post message in
                    // all other cases. Unfortunately, the PostMessage call currently
                    // fails if the high bit of the wParam value is set (which it is in
                    // this case), so we are forced to Send the message (rather than
                    // Post it). USER group implemented it this way because the original
                    // Win95 spec doesn't call for the recipient to free the message
                    // so we have to free it and we have no idea when it's safe
                    // with a PostMessage call.
                    //
                    HandleData->dbch_handle     = targetEntry->u.Target.FileHandle;
                    HandleData->dbch_hdevnotify = (HDEVNOTIFY)targetEntry->ClientCtxPtr;

                    UnlockNotifyList(&notifyList->Lock);
                    bLocked = FALSE;

                    //
                    // Always send the native DEV_BROADCAST_HANDLE structure to
                    // windows.  If any 64-bit/32-bit conversion needs to be
                    // done for this client, ntuser will do it for us.
                    //
                    pHandleData = HandleData;

                    if (targetEntry->SessionId == MAIN_SESSION ) {

                        ntStatus = DeviceEventWorker(targetEntry->Handle,
                                                     EventId,
                                                     (LPARAM)pHandleData,
                                                     TRUE,
                                                     &result);
                    } else {
                        if (fpWinStationSendWindowMessage) {
                            try {
                                if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                  targetEntry->SessionId,
                                                                  DEFAULT_SEND_TIME_OUT,
                                                                  HandleToUlong(targetEntry->Handle),
                                                                  WM_DEVICECHANGE,
                                                                  (WPARAM)EventId,
                                                                  (LPARAM)pHandleData,
                                                                  &result)) {
                                    ntStatus = STATUS_SUCCESS;
                                } else {
                                    ntStatus = STATUS_UNSUCCESSFUL;
                                }
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                ASSERT(0);
                                ntStatus = STATUS_SUCCESS;
                            }
                        }
                    }
                    LockNotifyList(&notifyList->Lock);
                    bLocked = TRUE;

                    if (NT_SUCCESS(ntStatus)) {

                        //
                        // This call succeeded, if it's a query type call, check
                        // the result returned.
                        //

                        if ((Flags & BSF_QUERY) && (result == BROADCAST_QUERY_DENY)) {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_EVENT,
                                       "UMPNPMGR: Window '%ws' vetoed TargetDeviceChangeEvent\n",
                                       targetEntry->ClientName));

                            WindowVeto(targetEntry, VetoType, VetoName, VetoNameLength);

                            //
                            // Haven't told the services yet.  Note that we
                            // always call this routine with the native
                            // DEV_BROADCAST_HANDLE structure, since it walks
                            // the entire list itself.  It will do the
                            // conversion again, if necessary.
                            //
                            SendCancelNotification(targetEntry,
                                                   ServiceControl,
                                                   EventId,
                                                   BSF_QUERY,
                                                   (PDEV_BROADCAST_HDR)HandleData,
                                                   DeviceId);
                            goto Clean0;
                        }

                    } else if (ntStatus == STATUS_INVALID_HANDLE) {

                        //
                        // window handle no longer exists, cleanup this entry
                        //
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Invalid window handle for '%ws' during TargetDeviceChangeEvent, removing entry.\n",
                                   targetEntry->ClientName));
                        targetEntry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN);
                        DeleteNotifyEntry(targetEntry,FALSE);

                    } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_ERRORS | DBGF_WARNINGS,
                                   "UMPNPMGR: Window '%ws' timed out on TargetDeviceChangeEvent\n",
                                   targetEntry->ClientName));
                        LogWarningEvent(WRN_TARGET_DEVICE_CHANGE_TIMED_OUT, 1, targetEntry->ClientName);
                    }

                } else if ((pass == DEVICE_NOTIFY_SERVICE_HANDLE) &&
                           (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_SERVICE_HANDLE)) {

                    if (pServiceControlCallback) {
                        //
                        // Call the services handler routine...
                        //
                        HandleData->dbch_handle     = targetEntry->u.Target.FileHandle;
                        HandleData->dbch_hdevnotify = (HDEVNOTIFY)targetEntry->ClientCtxPtr;

                        //
                        // Assume we're sending the native DEV_BROADCAST_HANDLE
                        // structure.
                        //
                        pHandleData = HandleData;
#if _WIN64
                        //
                        // If the client is running on WOW64, send it the 32-bit
                        // DEV_BROADCAST_HANDLE structure we created instead.
                        //
                        if (targetEntry->Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                            HandleData32->dbch_handle = (ULONG32)PtrToUlong(targetEntry->u.Target.FileHandle);
                            HandleData32->dbch_hdevnotify = (ULONG32)PtrToUlong((HDEVNOTIFY)targetEntry->ClientCtxPtr);
                            pHandleData = HandleData32;
                        }
#endif // _WIN64

                        try {
                            UnlockNotifyList(&notifyList->Lock);
                            bLocked = FALSE;
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)targetEntry->Handle,
                                                          ServiceControl,
                                                          EventId,
                                                          (LPARAM)pHandleData,
                                                          &err);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                ASSERT(0);
                                err = NO_ERROR;
                            }
                            LockNotifyList(&notifyList->Lock);
                            bLocked = TRUE;
                            //
                            // convert Win32 error into window message-style
                            // return value
                            //
                            if (err == NO_ERROR) {
                                result = TRUE;
                            } else {

                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_EVENT,
                                           "UMPNPMGR: Service %ws responded to TargetDeviceChangeEvent with status=0x%08lx\n",
                                           targetEntry->ClientName,
                                           err));

                                //
                                // This service specifically requested to receive this
                                // notification - it should know how to handle it.
                                //
                                ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                                //
                                // Log the error the service used to veto.
                                //
                                LogWarningEvent(WRN_TARGET_DEVICE_CHANGE_SERVICE_VETO,
                                                1,
                                                targetEntry->ClientName);

                                result = BROADCAST_QUERY_DENY;
                            }

                            if ((Flags & BSF_QUERY) && (result == BROADCAST_QUERY_DENY)) {

                                serviceVetoedQuery = TRUE;

                                ServiceVeto(targetEntry, VetoType, VetoName, VetoNameLength );

                                //
                                // This service vetoed the query, tell everyone
                                // else it was cancelled.  Note that we always
                                // call this routine with the native
                                // DEV_BROADCAST_HANDLE structure, since it
                                // walks the entire list itself.  It will do the
                                // conversion again, if necessary.
                                //
                                SendCancelNotification(targetEntry,
                                                       ServiceControl,
                                                       EventId,
                                                       BSF_QUERY,
                                                       (PDEV_BROADCAST_HDR)HandleData,
                                                       DeviceId);
                            }
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling Service Control Manager!\n"));
                            ASSERT(0);

                            //
                            // Reference the "serviceVetoedQuery" variable to
                            // ensure the compiler will respect statement
                            // ordering w.r.t. this variable.  We want to make
                            // sure we know with certainty whether any service
                            // vetoed the query, even if subsequently sending
                            // the cancel caused an access violation.
                            //
                            serviceVetoedQuery = serviceVetoedQuery;
                        }

                        if (serviceVetoedQuery) {
                            goto Clean0;
                        }
                    }

                } else if ((pass == DEVICE_NOTIFY_COMPLETION_HANDLE) &&
                           (GetPassFromEntry(targetEntry) == DEVICE_NOTIFY_COMPLETION_HANDLE)) {
                    //
                    // Complete the notification handle.
                    // NOTE: Notification completion handles not implemented.
                    //
                    ;
                }
            }

            targetEntry = nextEntry;
        } // while

    } while ((pass = GetNextPass(pass, (Flags & BSF_QUERY))) != PASS_COMPLETE);

    if (VetoNameLength != NULL) {
        *VetoNameLength = 0;
    }

Clean0:

    if (bLocked) {
        UnlockNotifyList(&notifyList->Lock);
    }

#ifdef _WIN64
    //
    // Free the 32-bit DEV_BROADCAST_HANDLE structure, if we allocated one.
    //
    if (HandleData32 != NULL) {
        HeapFree(ghPnPHeap, 0, HandleData32);
    }
#endif // _WIN64

    return (result != BROADCAST_QUERY_DENY);

} // NotifyTargetDeviceChange



ULONG
NotifyHardwareProfileChange(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies registered services and all windows of hardware
    profile change events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined hardware profile change events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

--*/
{
    DWORD   pass;
    DWORD   recipients = BSM_ALLDESKTOPS | BSM_APPLICATIONS;
    BSMINFO bsmInfo;
    ULONG   length;
    PPNP_NOTIFY_ENTRY entry, nextEntry;
    PPNP_NOTIFY_LIST  notifyList;
    BOOL    bLocked = FALSE;
    LONG    response;
    ULONG   successful;
    LONG    result;
    DWORD   err;

    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    notifyList = &ServiceList[CINDEX_HWPROFILE];

    LockNotifyList(&notifyList->Lock);
    bLocked = TRUE;

    successful = TRUE;

    pass = GetFirstPass(Flags & BSF_QUERY);
    try {

        while (pass != PASS_COMPLETE) {

            if (pass == DEVICE_NOTIFY_WINDOW_HANDLE) {
                //
                // Notify the Windows
                //
                UnlockNotifyList (&notifyList->Lock);
                bLocked = FALSE;

                bsmInfo.cbSize = sizeof(BSMINFO);
                result = BroadcastSystemMessageEx(Flags | BSF_RETURNHDESK,
                                                  &recipients,
                                                  WM_DEVICECHANGE,
                                                  EventId,
                                                  (LPARAM)NULL,
                                                  &bsmInfo);
                if ((result <= 0) && (Flags & BSF_QUERY)) {
                    HDESK hDeskService = GetThreadDesktop(GetCurrentThreadId());

                    SetThreadDesktop(bsmInfo.hdesk);
                    WinBroadcastVeto(bsmInfo.hwnd, VetoType, VetoName, VetoNameLength);
                    SetThreadDesktop(hDeskService);
                    CloseDesktop(bsmInfo.hdesk);
                    successful = FALSE;
                    break;
                }

                if ((result > 0) || (!(Flags & BSF_QUERY))) {
                    if (fpWinStationBroadcastSystemMessage) {
                        try {
                            fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                               TRUE,
                                                               0,
                                                               DEFAULT_BROADCAST_TIME_OUT,
                                                               Flags,
                                                               &recipients,
                                                               WM_DEVICECHANGE,
                                                               (WPARAM)EventId,
                                                               (LPARAM)NULL,
                                                               &result);
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                            ASSERT(0);
                            result = 1;
                        }
                    }

                }
                LockNotifyList (&notifyList->Lock);
                bLocked = TRUE;

                if ((result < 0) && (Flags & BSF_QUERY)) {

                    UnknownVeto(VetoType, VetoName, VetoNameLength);
                    successful = FALSE;
                    break;

                } else if ((result == 0) && (Flags & BSF_QUERY)) {

                    WinBroadcastVeto(NULL, VetoType, VetoName, VetoNameLength);
                    successful = FALSE;
                    break;
                }

            } else if (pass == DEVICE_NOTIFY_SERVICE_HANDLE) {
                //
                // Notify the services
                //
                entry = GetFirstNotifyEntry (notifyList,Flags & BSF_QUERY);

                while (entry) {

                    nextEntry = GetNextNotifyEntry(entry,Flags & BSF_QUERY);

                    if (entry->Unregistered) {
                        entry = nextEntry;
                        continue;
                    }

                    ASSERT(GetPassFromEntry(entry) == DEVICE_NOTIFY_SERVICE_HANDLE);

                    //
                    // This is a direct call, not a message via. USER
                    //
                    if (pServiceControlCallback) {

                        UnlockNotifyList (&notifyList->Lock);
                        bLocked = FALSE;
                        try {
                            (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                                      ServiceControl,
                                                      EventId,
                                                      (LPARAM)NULL,
                                                      &err);
                        } except (EXCEPTION_EXECUTE_HANDLER) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_ERRORS,
                                       "UMPNPMGR: Exception calling Service Control Manager!\n"));
                            ASSERT(0);
                            err = NO_ERROR;
                        }
                        LockNotifyList (&notifyList->Lock);
                        bLocked = TRUE;
                        //
                        // convert Win32 error into window message-style return
                        // value.
                        //
                        if (err == NO_ERROR) {
                            result = TRUE;
                        } else {

                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_EVENT,
                                       "UMPNPMGR: Service %ws responded to HardwareProfileChangeEvent with status=0x%08lx\n",
                                       entry->ClientName,
                                       err));

                            //
                            // This service specifically requested to receive this
                            // notification - it should know how to handle it.
                            //
                            ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                            //
                            // Log the error the service used to veto.
                            //
                            LogWarningEvent(WRN_HWPROFILE_CHANGE_SERVICE_VETO,
                                            1,
                                            entry->ClientName);

                            result = BROADCAST_QUERY_DENY;
                        }

                        if ((Flags & BSF_QUERY) &&
                            (result == BROADCAST_QUERY_DENY)) {

                            ServiceVeto(entry,
                                        VetoType,
                                        VetoName,
                                        VetoNameLength);

                            successful = FALSE;
                            break;
                        }
                    }

                    entry = nextEntry;

                }
            }

            if (!successful) {
                break;
            }

            pass = GetNextPass (pass,Flags & BSF_QUERY);
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in service callback in NotifyHardwareProfileChange\n"));
        ASSERT(0);

        if (Flags & BSF_QUERY) {
            UnknownVeto(VetoType, VetoName, VetoNameLength);
            successful = FALSE;
        }
    }

    try {

        if (!successful) {

            ASSERT(Flags & BSF_QUERY);

            //
            // If a service vetoed the query, inform the services and windows,
            // otherwise only the windows know what was coming.
            //
            if (pass == DEVICE_NOTIFY_SERVICE_HANDLE) {

                SendCancelNotification(
                    entry,
                    ServiceControl,
                    EventId,
                    BSF_QUERY,
                    NULL,
                    NULL);
            }

            UnlockNotifyList (&notifyList->Lock);
            bLocked = FALSE;
            BroadcastSystemMessage(Flags & ~BSF_QUERY,
                                   &recipients,
                                   WM_DEVICECHANGE,
                                   MapQueryEventToCancelEvent(EventId),
                                   (LPARAM)NULL);

            if (fpWinStationBroadcastSystemMessage) {
                try {
                    fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                       TRUE,
                                                       0,
                                                       DEFAULT_BROADCAST_TIME_OUT,
                                                       Flags & ~BSF_QUERY,
                                                       &recipients,
                                                       WM_DEVICECHANGE,
                                                       (WPARAM)MapQueryEventToCancelEvent(EventId),
                                                       (LPARAM)NULL,
                                                       &response);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage\n"));
                    ASSERT(0);
                }
            }
            LockNotifyList (&notifyList->Lock);
            bLocked = TRUE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in service callback in NotifyHardwareProfileChange\n"));
        ASSERT(0);

    }

    if (bLocked) {
        UnlockNotifyList (&notifyList->Lock);
    }

    //
    // if successful, we are not returning veto info.
    //
    if (successful && (VetoNameLength != NULL)) {
        *VetoNameLength = 0;
    }

    return successful;

} // NotifyHardwareProfileChange



BOOL
SendCancelNotification(
    IN     PPNP_NOTIFY_ENTRY    LastEntry,
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     ULONG                Flags,
    IN     PDEV_BROADCAST_HDR   NotifyData  OPTIONAL,
    IN     LPWSTR               DeviceId    OPTIONAL
    )
/*++

Routine Description:

    This routine sends a cancel notification to the entries in the range
    specified. This routine assumes the appropriate list is already locked.

Arguments:

    LastEntry      - Specifies the last list entry that received the original
                     query notification, and was responsible for failing the
                     request.  We will stop sending cancel notification events
                     when we get to this one.

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the DBT style event id for the device event.
                     (see sdk\inc\dbt.h for defined device events)

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.
                     Note that BroadcastSystemMessage is not actually used for
                     target device events, but the specified BSF_ flags are used
                     to determine query and cancel event notification ordering.

    NotifyData     - Optionally, supplies a pointer to a PDEV_BROADCAST_Xxx
                     structure that is already filled out with most of the
                     pertinent data for this event.

                     This parameter may be NULL for "global" events that are not
                     associated with any device, such as power and hardware
                     profile change events.

    DeviceId       - Optionally, supplies the device instance id of the target
                     device for this event.

                     This parameter may be NULL for "global" events that are not
                     associated with any device, such as power and hardware
                     profile change events.

Return Value:

    Returns TRUE / FALSE.

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD cancelEventId;
    DWORD result, pass, lastPass;
    PPNP_NOTIFY_ENTRY entry, headEntry;
    PPNP_NOTIFY_LIST notifyList;
#ifdef _WIN64
    DEV_BROADCAST_HANDLE32 UNALIGNED *HandleData32 = NULL;
    ULONG  ulHandleDataSize;
#endif // _WIN64
    PVOID  pNotifyData;

#ifdef _WIN64
    if ((ARGUMENT_PRESENT(NotifyData)) &&
        (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
        //
        // If cancelling a DEV_BROADCAST_HANDLE type event, prepare a 32-bit
        // notification structure, which we'll need to send to any WOW64 clients
        // that are registered.
        //
        ulHandleDataSize = ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_size -
            sizeof(DEV_BROADCAST_HANDLE64) +
            sizeof(DEV_BROADCAST_HANDLE32);

        ASSERT(ulHandleDataSize >= sizeof(DEV_BROADCAST_HANDLE32));

        HandleData32 = HeapAlloc(ghPnPHeap, 0, ulHandleDataSize);
        if (HandleData32 == NULL) {
            return FALSE;
        }

        memset(HandleData32, 0, ulHandleDataSize);
        HandleData32->dbch_size = ulHandleDataSize;
        HandleData32->dbch_devicetype = DBT_DEVTYP_HANDLE;
        HandleData32->dbch_nameoffset = ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_nameoffset;

        memcpy(&HandleData32->dbch_eventguid,
               &((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_eventguid,
               sizeof(GUID));

        memcpy(&HandleData32->dbch_data,
               &((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_data,
               (NotifyData->dbch_size - FIELD_OFFSET(DEV_BROADCAST_HANDLE, dbch_data)));
    }
#endif // _WIN64

    //
    // Use the appropriate cancel device event id that corresponds to the
    // original query device event id.
    //
    cancelEventId = MapQueryEventToCancelEvent(EventId);

    //
    // Get the corresponding notification list
    //
    notifyList = GetNotifyListForEntry(LastEntry);
    ASSERT(notifyList);
    if (notifyList == NULL) {
        return FALSE;
    }

    //
    // Get the pass we vetoed things on
    //
    lastPass = GetPassFromEntry(LastEntry);

    //
    // Get the opposite end of the list
    //
    headEntry = GetFirstNotifyEntry(notifyList, (Flags ^ BSF_QUERY));

    //
    // Walk the list of registered callers backwards(!) and notify anyone that registered
    // an interest in this device instance. Start with the FirstEntry and stop
    // just before the LastEntry (the LastEntry is the one that vetoed the
    // request in the first place).
    //

    for(pass = lastPass;
        pass != PASS_COMPLETE;
        pass = GetNextPass(pass, (Flags ^ BSF_QUERY))) {

        //
        // If this is the pass the request was vetoed on, then start on the
        // vetoer entry itself. Otherwise begin again at the appropriate end
        // of the list.
        //
        for(entry = (pass == lastPass) ? LastEntry : headEntry;
            entry;
            entry = GetNextNotifyEntry(entry, (Flags ^ BSF_QUERY))) {

            if (!NotifyEntryThisPass(entry, pass)) {
                continue;
            }

            switch(pass) {

                case DEVICE_NOTIFY_SERVICE_HANDLE:

                    if ((!DeviceId) || (lstrcmpi(DeviceId, entry->u.Target.DeviceId) == 0)) {

                        if (pServiceControlCallback) {
                            //
                            // Assume we're sending the native structure.
                            //
                            pNotifyData = NotifyData;

                            if ((ARGUMENT_PRESENT(NotifyData)) &&
                                (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
                                //
                                // If it's a DBT_DEVTYP_HANDLE notification, set
                                // the hdevnotify and file handle fields for the
                                // client we're notifying.
                                //
                                ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_handle = entry->u.Target.FileHandle;
                                ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_hdevnotify = (HDEVNOTIFY)entry->ClientCtxPtr;
#if _WIN64
                                //
                                // If the client is running on WOW64, send it the 32-bit
                                // DEV_BROADCAST_HANDLE structure we created instead.
                                //
                                if (entry->Flags & DEVICE_NOTIFY_WOW64_CLIENT) {
                                    HandleData32->dbch_handle = (ULONG32)PtrToUlong(entry->u.Target.FileHandle);
                                    HandleData32->dbch_hdevnotify = (ULONG32)PtrToUlong((HDEVNOTIFY)entry->ClientCtxPtr);
                                    pNotifyData = HandleData32;
                                }
#endif // _WIN64
                            }

                            //
                            // Call the services handler routine...
                            //
                            UnlockNotifyList(&notifyList->Lock);
                            try {
                                (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                                          ServiceControl,
                                                          cancelEventId,
                                                          (LPARAM)pNotifyData,
                                                          &result);
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling Service Control Manager!\n"));
                                ASSERT(0);
                            }
                            LockNotifyList(&notifyList->Lock);
                        }
                    }
                    break;

                case DEVICE_NOTIFY_WINDOW_HANDLE:

                    //
                    // Notify the windows. Note that events with NULL DeviceId's
                    // (for example hardware profile change events) are not
                    // registerable by windows. Luckily for them, we broadcast
                    // such info anyway.
                    //
                    if (DeviceId && (lstrcmpi(DeviceId, entry->u.Target.DeviceId) == 0)) {

                        ASSERT(NotifyData);

                        //
                        // Always send the native DEV_BROADCAST_HANDLE structure to
                        // windows.  If any 64-bit/32-bit conversion needs to be
                        // done for this client, ntuser will do it for us.
                        //
                        pNotifyData = NotifyData;

                        if ((ARGUMENT_PRESENT(NotifyData)) &&
                            (NotifyData->dbch_devicetype == DBT_DEVTYP_HANDLE)) {
                            //
                            // If it's a DBT_DEVTYP_HANDLE notification, set
                            // the hdevnotify and file handle fields for the
                            // client we're notifying.
                            //
                            ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_handle = entry->u.Target.FileHandle;
                            ((PDEV_BROADCAST_HANDLE)NotifyData)->dbch_hdevnotify = (HDEVNOTIFY)entry->ClientCtxPtr;
                        }

                        UnlockNotifyList(&notifyList->Lock);
                        if (entry->SessionId == MAIN_SESSION) {
                            ntStatus = DeviceEventWorker(entry->Handle,
                                                         cancelEventId,
                                                         (LPARAM)pNotifyData,
                                                         TRUE,
                                                         &result    // ignore result
                                                        );

                        } else if (fpWinStationSendWindowMessage) {
                            try {
                                if (fpWinStationSendWindowMessage(SERVERNAME_CURRENT,
                                                                  entry->SessionId,
                                                                  DEFAULT_SEND_TIME_OUT,
                                                                  HandleToUlong(entry->Handle),
                                                                  WM_DEVICECHANGE,
                                                                  (WPARAM)cancelEventId,
                                                                  (LPARAM)pNotifyData,
                                                                  &result)) {
                                    ntStatus = STATUS_SUCCESS;
                                } else {
                                    ntStatus = STATUS_UNSUCCESSFUL;
                                }
                            } except (EXCEPTION_EXECUTE_HANDLER) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_ERRORS,
                                           "UMPNPMGR: Exception calling WinStationSendWindowMessage!\n"));
                                ASSERT(0);
                                ntStatus = STATUS_SUCCESS;
                            }
                        }
                        LockNotifyList(&notifyList->Lock);

                        if (!NT_SUCCESS(ntStatus)) {
                            if (ntStatus == STATUS_INVALID_HANDLE) {
                                //
                                // window handle no longer exists, cleanup this entry
                                //
                                entry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_WIN|PNP_UNREG_CANCEL);
                                DeleteNotifyEntry(entry,FALSE);
                            } else if (ntStatus == STATUS_UNSUCCESSFUL) {
                                KdPrintEx((DPFLTR_PNPMGR_ID,
                                           DBGF_EVENT,
                                           "UMPNPMGR: Window '%ws' timed out on cancel notification event\n",
                                           entry->ClientName));
                                LogWarningEvent(WRN_CANCEL_NOTIFICATION_TIMED_OUT,
                                                1,
                                                entry->ClientName);
                           }
                        }
                    }
                    break;

                case DEVICE_NOTIFY_COMPLETION_HANDLE:
                    //
                    // NOTE: Completion handles not currently implemented.
                    //
                    break;
            }
        }
    }

#ifdef _WIN64
    //
    // Free the 32-bit DEV_BROADCAST_HANDLE structure, if we allocated one.
    //
    if (HandleData32 != NULL) {
        HeapFree(ghPnPHeap, 0, HandleData32);
    }
#endif // _WIN64

    return TRUE;

} // SendCancelNotification



VOID
BroadcastCompatibleDeviceMsg(
    IN DWORD EventId,
    IN PDEV_BROADCAST_DEVICEINTERFACE ClassData
    )
/*++

Routine Description:

    Deliver Win9x compatible event notification for the arrival and removal of
    device interfaces to volume and port class devices.

Arguments:

    EventId   - Specifies the DBT style event id.
                Currently, only DBT_DEVICEARRIVAL and DBT_DEVICEREMOVECOMPLETE
                events are supported.


    ClassData - Pointer to a PDEV_BROADCAST_DEVICEINTERFACE structure that is
                already filled out with the pertinent data.
                Currently, only volume and port class device interfaces are
                supported.

                (For volume class devices, the symbolic link
                ClassData->dbcc_name is OPTIONAL - see Notes below.)

Return Value:

    None.

Notes:

    For volume class device broadcasts only, this routine may also be called
    generically, with no symbolic link information provided.  When no symbolic
    link information to a volume device is supplied, the broadcast mask is
    determined only from the current drive letter mappings and the global drive
    letter mask (gAllDrivesMask) prior to this event.  In this case, the global
    drive letter mask is NOT updated here, and the caller should do so after
    both the removal and arrival broadcasts in response to the name change are
    performed.  Currently, this type of call is only made from
    BroadcastVolumeNameChange.

    For volume class interface DBT_DEVICEREMOVECOMPLETE broadcasts, the drive
    letter mask to be broadcast is always determined only by comparing drive
    letters present prior to the remove of the interface with those present at
    this time.  This is done because the former mount points for this device are
    no longer known when the interface removal event is received.  Even so, it
    is still necessary for the symbolic link corresponding to this interface to
    be supplied to distinguish between the actual removal of the interface
    (where the global drive letter mask is updated), the above case, where it is
    not.

--*/
{
    LONG    status = ERROR_SUCCESS;
    LONG    result = 0;
    DWORD   recipients = BSM_APPLICATIONS | BSM_ALLDESKTOPS;
    DWORD   flags = BSF_IGNORECURRENTTASK | BSF_NOHANG;

    //
    // Validate the input event data.
    //
    if ((ClassData->dbcc_devicetype != DBT_DEVTYP_DEVICEINTERFACE) ||
        (ClassData->dbcc_size < sizeof(DEV_BROADCAST_DEVICEINTERFACE))) {
        status = ERROR_INVALID_DATA;
        goto Clean0;
    }

    if ((EventId != DBT_DEVICEARRIVAL) &&
        (EventId != DBT_DEVICEREMOVECOMPLETE)) {
        //
        // If the requested Event is not DBT_DEVICEARRIVAL or
        // DBT_DEVICEREMOVECOMPLETE, don't broadcast any messages.
        //
        status = ERROR_NOT_SUPPORTED;
        goto Clean0;
    }

    if (GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_VOLUME)) {
        //
        // Volume class device interface events.
        //
        PDEV_BROADCAST_VOLUME   pVolume;
        DWORD   broadcastmask = 0;

        if (EventId == DBT_DEVICEARRIVAL) {

            if (!ClassData->dbcc_name[0]) {
                //
                // If no symbolic link name was supplied, we were asked to
                // broadcast volume device arrivals in response to a volume name
                // change event.  Broadcast any new drive letters found.
                //
                DWORD currentmask;
                currentmask = GetAllVolumeMountPoints();
                broadcastmask = (~gAllDrivesMask & currentmask);

            } else {

                //
                // For volume class device interface arrival events, the volume
                // device name is retrieved from the interface, and is compared to
                // the volume names of all drive letter mountpoints in the system to
                // determine the drive letter(s) corresponding to the arriving
                // volume device interface.
                //
                LPWSTR      devicePath, p;
                WCHAR       thisVolumeName[MAX_PATH];
                WCHAR       enumVolumeName[MAX_PATH];
                WCHAR       driveName[4];
                ULONG       length;
                BOOL        bResult;

                //
                // Allocate a temporary buffer for munging the symbolic link, with
                // enough room for a trailing '\' char (should we need to add one),
                // and the terminating NULL char.
                //
                length = lstrlen(ClassData->dbcc_name);
                devicePath = HeapAlloc(ghPnPHeap, 0,
                                       (length+1)*sizeof(WCHAR)+sizeof(UNICODE_NULL));
                if (devicePath == NULL) {
                    status = ERROR_NOT_ENOUGH_MEMORY;
                    goto Clean0;
                }

                lstrcpyn(devicePath, ClassData->dbcc_name, length+1);

                //
                // Search for the occurence of a refstring (if any) by looking for the
                // next occurance of a '\' char, after the initial "\\?\".
                //
                p = wcschr(&(devicePath[4]), TEXT('\\'));

                if (!p) {
                    //
                    // No refstring is present in the symbolic link; add a trailing
                    // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                    //
                    p = devicePath + length;
                    *p = TEXT('\\');
                }

                //
                // If there is no refstring present, we have added a trailing '\',
                // and placed p at that position.  If a refstring is present, p is
                // at the position of the '\' char that separates the munged device
                // interface name, and the refstring; since we don't need the
                // refstring to reach the parent interface key, we can use the next
                // char for NULL terminating the string in both cases.
                //
                p++;
                *p = UNICODE_NULL;

                //
                // Get the Volume Name for this Mount Point
                //
                thisVolumeName[0] = 0;
                bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                           thisVolumeName,
                                                           MAX_PATH);
                HeapFree(ghPnPHeap, 0, devicePath);
                if (!bResult || !thisVolumeName[0]) {
                    status = ERROR_BAD_PATHNAME;
                    goto Clean0;
                }

                //
                // Initialize the drive name string
                //
                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = UNICODE_NULL;

                //
                // Find the drive letter mount point(s) for this volume device by
                // enumerating all possible volume mount points and comparing each
                // mounted volume name with the name of the volume corresponding to
                // this device interface.
                //
                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = UNICODE_NULL;

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, MAX_PATH);

                    if (!wcscmp(thisVolumeName, enumVolumeName)) {
                        //
                        // Add the corresponding bit for this drive letter to the mask
                        //
                        broadcastmask |= (1 << (driveName[0] - TEXT('A')));
                    }
                }

                //
                // Update the global drive letter mask of volume device mountpoints
                //
                gAllDrivesMask = GetAllVolumeMountPoints();
            }

        } else if (EventId == DBT_DEVICEREMOVECOMPLETE) {

            //
            // For volume class device interface removal events, the volume name
            // (and hence, drive mountpoints) corresponding to this device
            // interface has already been removed, and is no longer available.
            // Instead, the bitmask of all drive letter mountpoints for current
            // physical volumes is compared with that prior to the removal of
            // this device.  All missing drive mountpoints are assumed to have
            // been associated with this volume device interface, and are
            // subsequently broadcasted with this interface removal
            // notification.
            //
            DWORD currentmask;

            //
            // Determine all current volume mount points, and broadcast any
            // missing drive letters.
            //
            currentmask = GetAllVolumeMountPoints();
            broadcastmask = (gAllDrivesMask & ~currentmask);

            if (ClassData->dbcc_name[0]) {
                //
                // Only update the global drive letter in response to the
                // removal of a interface.  For volume name changes, we update
                // outside of this routine.
                //
                gAllDrivesMask = currentmask;
            }
        }

        //
        // If there is nothing to broadcast, then we're done.
        //
        if (!broadcastmask) {
            status = ERROR_SUCCESS;
            goto Clean0;
        }

        //
        // Fill out the volume broadcast structure.
        //
        pVolume = HeapAlloc(ghPnPHeap, 0,
                            sizeof(DEV_BROADCAST_VOLUME));
        if (pVolume == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pVolume->dbcv_size = sizeof(DEV_BROADCAST_VOLUME);
        pVolume->dbcv_devicetype =  DBT_DEVTYP_VOLUME;
        pVolume->dbcv_flags = 0;
        pVolume->dbcv_reserved = 0;
        pVolume->dbcv_unitmask = broadcastmask;

        //
        // Broadcast the message to all components
        //
        result = BroadcastSystemMessage(flags,
                                        &recipients,
                                        WM_DEVICECHANGE,
                                        EventId,
                                        (LPARAM)pVolume);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   flags,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)EventId,
                                                   (LPARAM)pVolume,
                                                   &result);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }

        //
        // Free the broadcast structure.
        //
        HeapFree(ghPnPHeap, 0, pVolume);

    } else if ((GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_PARALLEL)) ||
               (GuidEqual(&ClassData->dbcc_classguid, (LPGUID)&GUID_DEVINTERFACE_COMPORT))) {

        //
        // COM and LPT port class device interface events.
        //
        PDEV_BROADCAST_PORT pPort;
        LPWSTR    p;
        LPWSTR    deviceInterfacePath;
        LPWSTR    deviceInterfaceName;
        LPWSTR    classGuidString;
        LPWSTR    deviceInstance;
        HKEY      hKey;
        WCHAR     szPortName[MAX_PATH];
        ULONG     length, ulSize;

        //
        // Build the complete path to the device interface key for this device.
        //
        length = lstrlen(ClassData->dbcc_name);
        ASSERT(length);
        if (!length) {
            status = ERROR_INVALID_PARAMETER;
            goto Clean0;
        }
        deviceInterfacePath = HeapAlloc(ghPnPHeap, 0,
                                        (lstrlen(pszRegPathDeviceClasses)+1)*sizeof(WCHAR) +
                                        MAX_GUID_STRING_LEN * sizeof(WCHAR) +
                                        length * sizeof(WCHAR) +
                                        sizeof(UNICODE_NULL));
        if (deviceInterfacePath == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        //
        // Place the path to the "DeviceClasses" registry key at the beginning.
        //
        lstrcpyn(deviceInterfacePath, pszRegPathDeviceClasses,
                 lstrlen(pszRegPathDeviceClasses) + 1);

        //
        // Determine the appropriate places in the device interface path for the
        // class GUID and interface names.
        //
        classGuidString = deviceInterfacePath + lstrlen(pszRegPathDeviceClasses) + 1;
        deviceInterfaceName = classGuidString + MAX_GUID_STRING_LEN;

        //
        // Copy the symbolic link name to the device interface position in the
        // path for munging.
        //
        lstrcpyn(deviceInterfaceName, ClassData->dbcc_name, length + 1);

        //
        // Search for the begininng of the refstring (if any, by looking for the
        // next occurance of a '\' char, after the initial "\\?\" in the interface name
        //
        p = wcschr(&(deviceInterfaceName[4]), TEXT('\\'));

        if (!p) {
            //
            // This name has no refstring--set the pointer to the end of the string
            //
            p = deviceInterfaceName + length;
        } else {
            //
            // Separate the refString Component from the deviceInterfaceName with a NULL char
            //
            *p = UNICODE_NULL;
        }

        //
        // Retrieve the interface class of this device.  Since the device path is of
        // the form "\\?\MungedDevInstName#{InterfaceClassGuid}[\RefString]", we can
        // copy the class GUID directly from the interface name, instead of
        // having to convert the given dbcc_classguid.
        //
        // NOTE: The algorithm about how this name is parsed must be kept in
        // sync with other such kernel-mode and user-mode implementations of how
        // this name is generated and parsed.
        //
        if (p < (deviceInterfaceName + 3 + MAX_GUID_STRING_LEN)) {
            //
            // There is not enough room for a GUID to be present in this device
            // interface path.
            //
            status = ERROR_BAD_PATHNAME;
            HeapFree(ghPnPHeap, 0, deviceInterfacePath);
            goto Clean0;
        }

        //
        // Place the class GUID at the appropriate place in the path.
        //
        lstrcpyn(classGuidString, p - (MAX_GUID_STRING_LEN-1), MAX_GUID_STRING_LEN);

        //
        // Place the path seperator characters at the appropriate places.
        //
        *(classGuidString-1) = TEXT('\\');
        *(deviceInterfaceName-1) = TEXT('\\');

        //
        // Munge the symbolic link name to form the interface key name.
        // (Note: The munging process is optimized here; we only have to munge
        // the leading "\\?\" segment since the rest of the given symbolic link
        // is alrady munged, with the exception of the refstring seperator char,
        // if any, which we have just eliminated from the interface name, above.)
        //
        deviceInterfaceName[0] = TEXT('#');
        deviceInterfaceName[1] = TEXT('#');
        deviceInterfaceName[3] = TEXT('#');

        //
        // Open the device interface key
        //
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              deviceInterfacePath,
                              0,
                              KEY_READ,
                              &hKey);

        HeapFree(ghPnPHeap, 0, deviceInterfacePath);

        if (status != ERROR_SUCCESS) {
            hKey=NULL;
            goto Clean0;
        }

        //
        // Determine the size of the DeviceInstance value entry
        //
        status = RegQueryValueEx(hKey,
                                 pszRegValueDeviceInstance,
                                 0,
                                 NULL,
                                 NULL,
                                 &ulSize);

        if (status != ERROR_SUCCESS) {
            RegCloseKey(hKey);
            hKey = NULL;
            goto Clean0;
        }

        //
        // Allocate a string large enough to store the path from the Enum key,
        // to the "\Device Parameters" subkey of this Device Instance's registry
        // key.
        //
        deviceInstance = HeapAlloc(ghPnPHeap, 0,
                                   ulSize + sizeof(WCHAR) +
                                   lstrlen(pszRegKeyDeviceParam)*sizeof(WCHAR));
        if (deviceInstance == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            RegCloseKey(hKey);
            hKey = NULL;
            goto Clean0;
        }

        //
        // Retrieve the device instance that owns this interface.
        //
        status = RegQueryValueEx(hKey,
                                 pszRegValueDeviceInstance,
                                 0,
                                 NULL,
                                 (LPBYTE)deviceInstance,
                                 &ulSize);
        RegCloseKey(hKey);
        hKey=NULL;

        if (status != ERROR_SUCCESS) {
            HeapFree(ghPnPHeap, 0, deviceInstance);
            goto Clean0;
        }

        //
        // Open the "Device Parameters" key under the HKLM\SYSTEM\CCS\Enum
        // subkey for this DeviceInstance.
        //
        p = deviceInstance + (ulSize - sizeof(UNICODE_NULL))/sizeof(WCHAR);
        wsprintf(p, TEXT("\\%s"),
                 pszRegKeyDeviceParam);

        status = RegOpenKeyEx(ghEnumKey,
                              deviceInstance,
                              0,
                              KEY_READ,
                              &hKey);

        HeapFree(ghPnPHeap, 0, deviceInstance);

        if (status != ERROR_SUCCESS) {
            goto Clean0;
        }

        //
        // Query the "PortName" value for the compatible name of this device.
        //
        ulSize = MAX_PATH*sizeof(WCHAR);
        status = RegQueryValueEx(hKey,
                                 pszRegValuePortName,
                                 0,
                                 NULL,
                                 (LPBYTE)szPortName,
                                 &ulSize);
        RegCloseKey(hKey);

        if (status != ERROR_SUCCESS) {
            goto Clean0;
        }

        //
        // Fill out the port broadcast structure.
        //
        pPort = HeapAlloc (ghPnPHeap, 0,
                           sizeof(DEV_BROADCAST_PORT) + ulSize);

        if (pPort == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Clean0;
        }

        pPort->dbcp_size = sizeof(DEV_BROADCAST_PORT) + ulSize;
        pPort->dbcp_devicetype =  DBT_DEVTYP_PORT;
        pPort->dbcp_reserved = 0;
        wsprintf(pPort->dbcp_name, szPortName);

        //
        // Broadcast the message to all components
        //
        result = BroadcastSystemMessage(flags,
                                        &recipients,
                                        WM_DEVICECHANGE,
                                        EventId,
                                        (LPARAM)pPort);

        if (fpWinStationBroadcastSystemMessage) {
            try {
                fpWinStationBroadcastSystemMessage(SERVERNAME_CURRENT,
                                                   TRUE,
                                                   0,
                                                   DEFAULT_BROADCAST_TIME_OUT,
                                                   flags,
                                                   &recipients,
                                                   WM_DEVICECHANGE,
                                                   (WPARAM)EventId,
                                                   (LPARAM)pPort,
                                                   &result);
            } except (EXCEPTION_EXECUTE_HANDLER) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: Exception calling WinStationBroadcastSystemMessage!\n"));
                ASSERT(0);
            }
        }

        //
        // Free the broadcast structure.
        //
        HeapFree(ghPnPHeap, 0, pPort);

    }

 Clean0:

    return;

} // BroadcastCompatibleDeviceMsg



VOID
BroadcastVolumeNameChange(
    VOID
    )
/*++

Routine Description:

    Perform Win9x compatible volume removal and arrival messages, to be called
    in reponse to a volume name change event.

Arguments:

    None.

Return Value:

    None.

Notes:

    The drive mask to be broadcast will be determined by comparing the current
    drive letter mask with that prior to the event.  The global drive letter
    mask is also updated here, after all removal and arrival notifications have
    been sent.

--*/
{
    DEV_BROADCAST_DEVICEINTERFACE volumeNotify;

    //
    // Fill out a DEV_BROADCAST_DEVICEINTERFACE structure.
    //
    ZeroMemory(&volumeNotify, sizeof(DEV_BROADCAST_DEVICEINTERFACE));
    volumeNotify.dbcc_size       = sizeof(DEV_BROADCAST_DEVICEINTERFACE);
    volumeNotify.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
    volumeNotify.dbcc_reserved   = 0;
    memcpy(&volumeNotify.dbcc_classguid, &GUID_DEVINTERFACE_VOLUME, sizeof(GUID));

    //
    // A null symbolic link name for dbcc_name designates that
    // BroadcastCompatibleDeviceMsg is to determine the drive mask to
    // broadcast by checking differences between the last broadcast drive
    // mask (gAllDrivesMask), and the current drive mask.
    //
    // When broadcasting in response to a volume name change, we must wait until
    // both removal and arrival messages have been sent before we can update the
    // global drive letter mask.  A null symbolic link name specifies that
    // BroadcastCompatibleDeviceMsg should not update the global mask; this will
    // be done here, after all broadcasts are complete.
    //
    volumeNotify.dbcc_name[0]    = L'\0';

    //
    // Broadcast volume removal notification for any drive letter moint points
    // no longer in use, followed by volume arrival notification for new
    //
    BroadcastCompatibleDeviceMsg(DBT_DEVICEREMOVECOMPLETE, &volumeNotify);
    BroadcastCompatibleDeviceMsg(DBT_DEVICEARRIVAL, &volumeNotify);

    //
    // Now that both removal and arrival messages have been sent, update the
    // global drive letter mask to reflect what we just broadcast.
    //
    gAllDrivesMask = GetAllVolumeMountPoints();

    return;

} // BroadcastVolumeNameChange



DWORD
GetAllVolumeMountPoints(
    VOID
    )
/*++

Routine Description:

    Queries all drive letter mountpoints ('A'-'Z') and returns a bitmask
    representing all such mount points currently in use by physical volume
    devices.

Arguments:

    None.

Return Value:

    Returns a bit mask representing drive letter mount points ('A'-'Z') in use
    by physical volume devices.

Note:

    The returned bit mask includes only mount points for physical volume class
    devices.  Network mounted drives are not included.


--*/
{
    WCHAR    driveName[4];
    WCHAR    volumeName[MAX_PATH];
    DWORD    driveLetterMask=0;

    //
    // Initialize drive name and mask
    //
    driveName[1] = TEXT(':');
    driveName[2] = TEXT('\\');
    driveName[3] = UNICODE_NULL;

    //
    // Compare the name of this volume with those of all mounted volumes in the system
    //
    for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {
        volumeName[0] = UNICODE_NULL;

        if (!GetVolumeNameForVolumeMountPoint(driveName,
                                              volumeName,
                                              MAX_PATH)) {
            continue;
        }

        if (volumeName[0] != UNICODE_NULL) {
            //
            // Add the corresponding bit for this drive letter to the mask
            //
            driveLetterMask |= (1 << (driveName[0] - TEXT('A')));
        }
    }

    return driveLetterMask;

} // GetAllVolumeMountPoints



ULONG
NotifyPower(
    IN     DWORD                ServiceControl,
    IN     DWORD                EventId,
    IN     DWORD                EventData,
    IN     DWORD                Flags,
    OUT    PPNP_VETO_TYPE       VetoType       OPTIONAL,
    OUT    LPWSTR               VetoName       OPTIONAL,
    IN OUT PULONG               VetoNameLength OPTIONAL
    )
/*++

Routine Description:

    This routine notifies services of system-wide power events.

Arguments:

    ServiceControl - Specifies class of service event (power, device, hwprofile
                     change).

    EventId        - Specifies the PBT style event id for the power event.
                     (see sdk\inc\pbt.h for defined power events)

    EventData      - Specifies additional data for the event.

    Flags          - Specifies BroadcastSystemMessage BSF_ flags.

    VetoType       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the type of the component responsible
                     for vetoing the request.

    VetoName       - For query-type events, supplies the address of a variable to
                     receive, upon failure, the name of the component
                     responsible for vetoing the request.

    VetoNameLength - For query-type events, supplies the address of a variable
                     specifying the size of the of buffer specified by the
                     VetoName parameter.  Upon failure, this address will specify
                     the length of the string stored in that buffer by this
                     routine.

Return Value:

    Returns FALSE in the case of a vetoed query event, TRUE otherwise.

Notes:

    This routine currently only notifies services of power events.  Notification
    to windows is handled directly by USER.

    Power events are placed in the plug and play event queue via a private call
    from USER, for the explicit purpose of notifying services of system-wide
    power events, done here.

--*/
{
    NTSTATUS status=STATUS_SUCCESS;
    PPNP_NOTIFY_ENTRY entry, nextEntry;
    PPNP_NOTIFY_LIST  notifyList;
    BOOL  bLocked = FALSE;
    DWORD err;
    LONG result;

    //
    // NOTE: Services are not currently sent EventData for power events.  The
    // SCM currently ASSERTs that this will always be zero.
    //
    // The SDK states that WM_POWERBROADCAST "RESUME" type messages may contain
    // the PBTF_APMRESUMEFROMFAILURE flag in the LPARAM field, and that "QUERY"
    // type messages may contain a single bit in the LPARAM field specifying
    // whether user interaction is allowed.
    //
    // Although these don't currently seem to be used much (even for window
    // messages, as stated), shouldn't EventData also be valid for service power
    // event notification?
    //
    UNREFERENCED_PARAMETER(EventData);


    //
    // If we're doing a query, then VetoType, VetoName, and VetoNameLength must
    // all be specified.
    //
    ASSERT(!(Flags & BSF_QUERY) || (VetoType && VetoName && VetoNameLength));

    if (!(Flags & BSF_QUERY) && (VetoNameLength != NULL)) {
        //
        // Not vetoable.
        //
        *VetoNameLength = 0;
    }

    notifyList = &ServiceList[CINDEX_POWEREVENT];
    LockNotifyList (&notifyList->Lock);
    bLocked = TRUE;

    //
    //Services only. User sends out messages to apps
    //
    try {
        //
        //Notify the services
        //
        entry = GetFirstNotifyEntry(notifyList,0);

        if (!entry) {
            //
            // can't veto if no one registered.
            //
            if (VetoNameLength != NULL) {
                *VetoNameLength = 0;
            }
        }

        while (entry) {

            nextEntry = GetNextNotifyEntry(entry,0);

            if (entry->Unregistered) {
                entry = nextEntry;
                continue;
            }

            //
            // This is a direct call, not a message via. USER
            //
            if (pServiceControlCallback) {
                UnlockNotifyList (&notifyList->Lock);
                bLocked = FALSE;
                try {
                    (pServiceControlCallback)((SERVICE_STATUS_HANDLE)entry->Handle,
                                              ServiceControl,
                                              EventId,
                                              (LPARAM)NULL, // Currently, no EventData allowed for services
                                              &err);
                } except (EXCEPTION_EXECUTE_HANDLER) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_ERRORS,
                               "UMPNPMGR: Exception calling Service Control Manager!\n"));
                    ASSERT(0);
                }
                LockNotifyList (&notifyList->Lock);
                bLocked = TRUE;

                //
                // convert Win32 error into window message-style return
                // value.
                //
                if (err == NO_ERROR) {
                    result = TRUE;
                } else {

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT,
                               "UMPNPMGR: Service %ws responded to PowerEvent, with status=0x%08lx\n",
                               entry->ClientName,
                               err));

                    //
                    // This service specifically requested to receive this
                    // notification - it should know how to handle it.
                    //
                    ASSERT(err != ERROR_CALL_NOT_IMPLEMENTED);

                    //
                    // Log the error the service used to veto.
                    //
                    LogWarningEvent(WRN_POWER_EVENT_SERVICE_VETO,
                                    1,
                                    entry->ClientName);

                    result = BROADCAST_QUERY_DENY;
                }

                //
                // Check if one of the QUERY messages was denied
                //
                if ((Flags & BSF_QUERY) &&
                    (result == BROADCAST_QUERY_DENY)) {

                    ServiceVeto(entry, VetoType, VetoName, VetoNameLength );

                    //
                    // This service vetoed the query, tell everyone else
                    // it was cancelled.
                    //
                    SendCancelNotification(entry,
                                           ServiceControl,
                                           EventId,
                                           0,
                                           NULL,
                                           NULL);
                    status = STATUS_UNSUCCESSFUL;
                    break;

                }
            }

            entry = nextEntry;
        }
    } except (EXCEPTION_EXECUTE_HANDLER){
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception delivering Power Notification to Service Control Manager\n"));
        ASSERT(0);
    }

    if (bLocked) {
        UnlockNotifyList (&notifyList->Lock);
    }

    //
    // if successful, we are not returning veto info.
    //
    if (NT_SUCCESS(status) && (VetoNameLength != NULL)) {
        *VetoNameLength = 0;
    }

    return (NT_SUCCESS(status));

} // NotifyPower



CONFIGRET
RegisterServiceNotification(
    IN  SERVICE_STATUS_HANDLE hService,
    IN  LPWSTR pszService,
    IN  DWORD scmControls,
    IN  BOOL bServiceStopped
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.
    It allows the SCM to register or unregister services for events sent by this
    service.

Arguments:

    hService        - Specifies the service handle.

    pszService      - Specifies the name of the service.

    scmControls     - Specifies the messages that SCM wants to listen to.

    bServiceStopped - Specifies whether the service is stopped.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one
    of the CR_* errors.

Notes:

    This routine is called anytime a service changes the state of the
    SERVICE_ACCEPT_POWEREVENT or SERVICE_ACCEPT_HARDWAREPROFILECHANGE flags in
    its list of accepted controls.

    This routine is also called by the SCM whenever any service has stopped, to
    make sure that the specified service status handle is no longer registered
    to receive SERVICE_CONTROL_DEVICEEVENT events.

    Although it is the responsibility of the service to unregister for any
    device event notifications that it has registered to receive before it is
    stopped, its service status handle may be reused by the service controller,
    so we must clean up any remaining device event registrations so that other
    services will not receive them instead.

    This is necessary for shared process services, since RPC rundown on the
    notification handle will not occur until the service's process exits, which
    may be long after the service has stopped.

--*/
{
    ULONG cBits, i=0, lenName=0;
    CONFIGRET Status = CR_SUCCESS;
    PPNP_NOTIFY_ENTRY entry = NULL, curentry, nextentry;
    PLOCKINFO LockHeld = NULL;

    //
    // Filter out the accepted controls we care about.
    //
    cBits = MapSCMControlsToControlBit(scmControls);

    //
    // If we were called because the service was stopped, make sure that we
    // always unregister for all notifications.
    //
    if (bServiceStopped) {
        ASSERT(cBits == 0);
        cBits = 0;
    }

    try {
        EnterCriticalSection(&RegistrationCS);

        //
        // Add or remove an entry in the array for each control bits.
        //
        for (i = 0;i< SERVICE_NUM_CONTROLS;i++) {

            if (LockNotifyList(&ServiceList[i].Lock)) {
                LockHeld = &ServiceList[i].Lock;
            } else {
                //
                // Couldn't acquire the lock.  Just move on to the next control
                // bit.
                //
                continue;
            }

            //
            // Check to see if an entry for this service handle already exists
            // in our list.
            //
            for (curentry = GetFirstNotifyEntry(&ServiceList[i],0);
                 curentry;
                 curentry = GetNextNotifyEntry(curentry,0)) {
                if (curentry->Handle == (HANDLE)hService) {
                    break;
                }
            }

            //
            // At this point, if curentry is non-NULL, then the service
            // handle is already in our list, otherwise, it is not.
            //
            if (cBits & (1 << i)) {
                //
                // If entry isn't already in the list, then add it.
                //
                if (!curentry) {

                    entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_NOTIFY_ENTRY));
                    if (NULL == entry) {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        Status = CR_OUT_OF_MEMORY;
                        UnlockNotifyList(LockHeld);
                        LockHeld = NULL;
                        goto Clean0;

                    }

                    RtlZeroMemory (entry,sizeof (PNP_NOTIFY_ENTRY));

                    entry->Handle = (HANDLE)hService;
                    entry->Signature = SERVICE_ENTRY_SIGNATURE;
                    entry->Freed = 0;
                    entry->Flags = DEVICE_NOTIFY_SERVICE_HANDLE;
                    entry->ClientName = NULL;

                    if (pszService) {

                        lenName = lstrlen(pszService);
                        entry->ClientName = HeapAlloc(ghPnPHeap,
                                                      0,
                                                      (lenName+1)*sizeof(WCHAR));

                        if (entry->ClientName == NULL) {
                            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                            Status = CR_OUT_OF_MEMORY;
                            HeapFree(ghPnPHeap,0,entry);
                            UnlockNotifyList(LockHeld);
                            LockHeld = NULL;
                            goto Clean0;
                        }

                        lstrcpy(entry->ClientName, pszService);
                    }

                    entry->u.Service.scmControls = scmControls;
                    MarkEntryWithList(entry,i);
                    AddNotifyEntry(&ServiceList[i], entry);

                    //
                    // Now reset entry pointer to NULL so we won't try to free
                    // it if we encounter an exception
                    //
                    entry = NULL;
                }
            } else {
                //
                // If entry is in the list, then remove it.
                //
                if (curentry) {
                    curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_DEFER|PNP_UNREG_SERVICE);
                    DeleteNotifyEntry(curentry,TRUE);
                }
            }

            UnlockNotifyList(LockHeld);
            LockHeld = NULL;
        }

        //
        // If the service is being stopped, unregister all outstanding device
        // event registrations.
        //
        if (bServiceStopped) {

            //
            // If a notification is currently in progress, check to see if there
            // are any entries for this service in the deferred RegisterList or
            // UnregisterList.
            //
            if (gNotificationInProg  != 0) {

                if (RegisterList) {
                    PPNP_DEFERRED_LIST currReg, prevReg;

                    currReg = RegisterList;
                    prevReg = NULL;

                    while (currReg) {

                        ASSERT(currReg->Entry->Unregistered);

                        if (currReg->Entry->Handle == (HANDLE)hService) {
                            if (prevReg) {
                                prevReg->Next = currReg->Next;
                            } else {
                                RegisterList = currReg->Next;
                            }
                            HeapFree(ghPnPHeap, 0, currReg);
                            if (prevReg) {
                                currReg = prevReg->Next;
                            } else {
                                currReg = RegisterList;
                            }
                        } else {
                            prevReg = currReg;
                            currReg = currReg->Next;
                        }
                    }
                }

                if (UnregisterList) {
                    PPNP_DEFERRED_LIST currUnreg, prevUnreg;

                    currUnreg = UnregisterList;
                    prevUnreg = NULL;

                    while (currUnreg) {

                        ASSERT(currUnreg->Entry->Unregistered);

                        if (currUnreg->Entry->Handle == (HANDLE)hService) {
                            if (prevUnreg) {
                                prevUnreg->Next = currUnreg->Next;
                            } else {
                                UnregisterList = currUnreg->Next;
                            }
                            HeapFree(ghPnPHeap, 0, currUnreg);
                            if (prevUnreg) {
                                currUnreg = prevUnreg->Next;
                            } else {
                                currUnreg = UnregisterList;
                            }
                        } else {
                            prevUnreg = currUnreg;
                            currUnreg = currUnreg->Next;
                        }
                    }
                }
            }

            //
            // Check for any target device notification entries for this
            // service.
            //
            for (i = 0; i < TARGET_HASH_BUCKETS; i++) {

                if (LockNotifyList(&TargetList[i].Lock)) {
                    LockHeld = &TargetList[i].Lock;
                } else {
                    //
                    // Couldn't acquire the lock.  Just move on to the next list.
                    //
                    continue;
                }

                //
                // Check to see if an entry for this service handle exists in
                // this list.
                //
                curentry = GetFirstNotifyEntry(&TargetList[i],0);
                while(curentry) {

                    nextentry = GetNextNotifyEntry(curentry,0);

                    if (curentry->Unregistered) {
                        curentry = nextentry;
                        continue;
                    }

                    if (curentry->Handle == (HANDLE)hService) {
                        //
                        // Remove the entry from the notification list.
                        //
                        curentry->Unregistered = TRUE;
                        curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_TARGET);
                        DeleteNotifyEntry(curentry,FALSE);

                        //
                        // Only log a warning if the PlugPlay service has not
                        // already stopped.  Otherwise, the client may actually
                        // have tried to unregister after we were shut down.
                        //
                        if (CurrentServiceState != SERVICE_STOPPED &&
                            CurrentServiceState != SERVICE_STOP_PENDING) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_WARNINGS | DBGF_EVENT,
                                       "UMPNPMGR: Service '%ws' may have stopped without unregistering for TargetDeviceChange notification.\n",
                                       curentry->ClientName));
                            LogWarningEvent(WRN_STOPPED_SERVICE_REGISTERED,
                                            1,
                                            curentry->ClientName);
                        }
                    }

                    curentry = nextentry;
                }
                UnlockNotifyList(LockHeld);
                LockHeld = NULL;
            }

            //
            // Check for any device interface notification entries for this
            // service.
            //
            for (i = 0; i < CLASS_GUID_HASH_BUCKETS; i++) {

                if (LockNotifyList(&ClassList[i].Lock)) {
                    LockHeld = &ClassList[i].Lock;
                } else {
                    //
                    // Couldn't acquire the lock.  Just move on to the next list.
                    //
                    continue;
                }

                //
                // Check to see if an entry for this service handle exists in
                // this list.
                //
                curentry = GetFirstNotifyEntry(&ClassList[i],0);
                while(curentry) {

                    nextentry = GetNextNotifyEntry(curentry,0);

                    if (curentry->Unregistered) {
                        curentry = nextentry;
                        continue;
                    }

                    if (curentry->Handle == (HANDLE)hService) {
                        //
                        // Remove the entry from the notification list.
                        //
                        curentry->Unregistered = TRUE;
                        curentry->Freed |= (PNP_UNREG_FREE|PNP_UNREG_CLASS);
                        DeleteNotifyEntry(curentry,FALSE);

                        //
                        // Only log a warning if the PlugPlay service has not
                        // already stopped.  Otherwise, the client may actually
                        // have tried to unregister after we were shut down.
                        //
                        if (CurrentServiceState != SERVICE_STOPPED &&
                            CurrentServiceState != SERVICE_STOP_PENDING) {
                            KdPrintEx((DPFLTR_PNPMGR_ID,
                                       DBGF_WARNINGS | DBGF_EVENT,
                                       "UMPNPMGR: Service '%ws' may have stopped without unregistering for DeviceInterfaceChange notification.\n",
                                       curentry->ClientName));
                            LogWarningEvent(WRN_STOPPED_SERVICE_REGISTERED,
                                            1,
                                            curentry->ClientName);
                        }
                    }

                    curentry = nextentry;
                }
                UnlockNotifyList(LockHeld);
                LockHeld = NULL;
            }
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except (EXCEPTION_EXECUTE_HANDLER){
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in RegisterServiceNotification!!\n"));
        ASSERT(0);
        SetLastError(ERROR_EXCEPTION_IN_SERVICE);
        Status = CR_FAILURE;

        if (LockHeld) {
            UnlockNotifyList(LockHeld);
        }
        LeaveCriticalSection(&RegistrationCS);

        if (entry) {
            if (entry->ClientName) {
                HeapFree(ghPnPHeap, 0, entry->ClientName);
            }
            HeapFree(ghPnPHeap, 0, entry);
        }
    }

    return Status;

} // RegisterServiceNotification



CONFIGRET
RegisterScmCallback(
    IN  PSCMCALLBACK_ROUTINE pScCallback,
    IN  PSCMAUTHENTICATION_CALLBACK pScAuthCallback
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.  It
    allows the SCM to dynamically provide this service with callback routines.

Arguments:

    pScCallback     - Specifies the entrypoint for the routine that should be used
                      to have the service controller send special controls to a
                      service (which ControlService would block), on behalf of
                      the user-mode plug and play manager.

    pScAuthCallback - Specifies the entrypoint for the routine that should be
                      used to retrieve the service status for a service.

Return Value:

    Returns CR_SUCCESS.

--*/
{
    ASSERT(pScCallback);
    ASSERT(pScAuthCallback);

    pServiceControlCallback = pScCallback;
    pSCMAuthenticate = pScAuthCallback;

    return CR_SUCCESS;
}



CONFIGRET
UnRegisterScmCallback(
    VOID
    )
/*++

Routine Description:

    This routine is called directly and privately by the service controller.  It
    allows the SCM to unregister the callback routines previously registered by
    RegisterScmCallback.

Arguments:

    None.

Return Value:

    Returns CR_SUCCESS.

--*/
{
    pServiceControlCallback = NULL;
    pSCMAuthenticate = NULL;

    return CR_SUCCESS;
}



ULONG
MapSCMControlsToControlBit(
    IN ULONG scmControls
    )
/*++

Routine Description:

    Returns a bitmask of control bits specifying ServiceList lists to which a
    service should be added or removed from, based on the controls currently
    accepted by the service.

Arguments:

    scmControls - Specifies the service controls currently accepted by a
                  service.

Return Value:

    Returns a bitmask of control bits corresponding to entries in the
    ServiceList array of lists to which a service should be added or removed
    from, based on the controls currently accepted by the service.

Notes:

    Services are added or removed from a ServiceList notification list by adding
    or removing the corresponding SERVICE_ACCEPT_* control from its list of
    accepted controls when calling SetServiceStatus().  The service control
    manager calls RegisterServiceNotification() as appropriate to register or
    unregister the service to receive that control.  Currently, only
    SERVICE_ACCEPT_HARDWAREPROFILECHANGE and SERVICE_ACCEPT_POWEREVENT are
    supported.

    A service registers to receive the SERVICE_CONTROL_DEVICEEVENT control by
    calling RegisterDeviceNotification, and is stored in the appropriate
    TargetList or ClassList entry.

--*/
{
    ULONG retBits=0;

    if (scmControls & SERVICE_ACCEPT_HARDWAREPROFILECHANGE) {
        retBits |= CBIT_HWPROFILE;
    }

    if (scmControls & SERVICE_ACCEPT_POWEREVENT) {
        retBits |= CBIT_POWEREVENT;
    }

    return retBits;

} // MapSCMControlsToControlBit



DWORD
GetFirstPass(
    IN BOOL bQuery
    )
/*++

Routine Description:

  This routine retrieves the first class of handles to notify. The subsequent
  class of handles to notify should be retrieved by calling GetNextPass(...);

Arguments:

   bQuery - If TRUE, starts with window handles, otherwise service handles.

Return Value:

   Returns the first class of handles to notify.

Notes:

   See GetNextPass() for the notification pass progression.

--*/
{
    //
    // Since services are generally less likely to veto device event queries, we
    // first make sure that all windows succeed the query before notifying any
    // services.  For non-query events, services should be the first to know.
    //
    return (bQuery) ? DEVICE_NOTIFY_WINDOW_HANDLE : DEVICE_NOTIFY_SERVICE_HANDLE;
}



DWORD
GetNextPass(
    IN  DWORD   curPass,
    IN  BOOL    bQuery
    )
/*++

Routine Description:

  This routine retrieves the next class of handles to notify. If there is no
  subsequent class of handles to notify, PASS_COMPLETE is returned.

Arguments:

   curPass      Current pass.

   bQuery       If TRUE, proceed from window handles to completion handles to
                service handles. Otherwise process in reverse.

Return Value:

   Returns the subsequent pass.

Notes:

   For query events, the notification pass progression is:

      DEVICE_NOTIFY_WINDOW_HANDLE,
      DEVICE_NOTIFY_COMPLETION_HANDLE,
      DEVICE_NOTIFY_SERVICE_HANDLE,
      PASS_COMPLETE

   For non-query events, the notification pass progression is:

      DEVICE_NOTIFY_SERVICE_HANDLE,
      DEVICE_NOTIFY_COMPLETION_HANDLE,
      DEVICE_NOTIFY_WINDOW_HANDLE,
      PASS_COMPLETE

--*/
{
    if (bQuery) {
        if (curPass == DEVICE_NOTIFY_WINDOW_HANDLE ) {
            curPass = DEVICE_NOTIFY_COMPLETION_HANDLE;
        } else if (curPass == DEVICE_NOTIFY_COMPLETION_HANDLE) {
            curPass = DEVICE_NOTIFY_SERVICE_HANDLE;
        } else {
            curPass = PASS_COMPLETE;
        }
    } else {
        if (curPass == DEVICE_NOTIFY_SERVICE_HANDLE ) {
            curPass = DEVICE_NOTIFY_COMPLETION_HANDLE;
        } else if (curPass == DEVICE_NOTIFY_COMPLETION_HANDLE) {
            curPass = DEVICE_NOTIFY_WINDOW_HANDLE;
        } else {
            curPass = PASS_COMPLETE;
        }
    }

    return curPass;
}



BOOL
NotifyEntryThisPass(
    IN     PPNP_NOTIFY_ENTRY    Entry,
    IN     DWORD                Pass
    )
{
    ASSERT(Pass != PASS_COMPLETE);
    return ((!(Entry->Unregistered)) && (GetPassFromEntry(Entry) == Pass));
}

DWORD
GetPassFromEntry(
    IN     PPNP_NOTIFY_ENTRY    Entry
    )
{
    return (Entry->Flags & DEVICE_NOTIFY_HANDLE_MASK);
}



BOOL
EventIdFromEventGuid(
    IN CONST GUID *EventGuid,
    OUT LPDWORD   EventId,
    OUT LPDWORD   Flags,
    OUT LPDWORD   ServiceControl
    )

/*++

Routine Description:

  This thread routine converts an event guid into the corresponding event id
  that user-mode code expects (used in BroadcastSystemMessage).

Arguments:

   EventGuid    Specifies an event guid.

   EventId      Returns the id form (from dbt.h) of the guid in EventGuid.

   Flags        Returns the flags that should be used when broadcasting this
                event.
                NOTE: device ARRIVAL and event CANCEL are considered "Queries"
                since the bottom level drivers need to be told first.

Return Value:

   Currently returns TRUE/FALSE.


Notes:

   Most users of this function call it mainly to retrieve the EventId. Those
   functions typically examine the returned flags only to check the BSF_QUERY
   flag (ie, they don't call BroadcastSystemMessage). Depending on whether
   BSF_QUERY is set, the notification lists will be walked forwards or
   backwards.

   We should really return something generic such as:
   [MSG_POST, MSG_QUERY, MSG_SEND] | [MSG_FORWARDS, MSG_BACKWARDS]
   Then we should implement a BsmFlagsFromMsgFlags function.

--*/

{
    //
    // BSF_IGNORECURRENTTASK  - Sent messages do not appear in the sending
    //                          processes message queue.
    //
    // BSF_QUERY              - If any recipient vetoes the message by returning
    //                          the appropriate value, the broadcast is failed
    //                          (ie, BroadcastSystemMessage returns 0).
    //
    // BSF_NOHANG             - Non-posted messages are automatically failed if
    //                          the window has not processed any available
    //                          messages within a system defined time (as of
    //                          04/20/1999 this is 5 seconds).
    //                          (SendMessageTimeout: SMTO_ABORTIFHUNG)
    //
    // BSF_FORCEIFHUNG        - Failures due to timeouts or hangs are instead
    //                          treated as successes.
    //
    // BSF_NOTIMEOUTIFNOTHUNG - If a window has not responded to the passed in
    //                          notification, but is actively processing
    //                          subsequent messages, then it is assumed to be
    //                          interacting with the user, in which case the
    //                          timeout is on hold.
    //                          (SendMessageTimeout: SMTO_NOTIMEOUTIFNOTHUNG)
    //
    // BSF_POSTMESSAGE        - Message is posted, results ignored. Note that
    //                          a notification with private data in the lParam
    //                          *cannot* be posted - the OS does not make a
    //                          private copy, but rather treats the broadcast
    //                          as if it were a SendMessage if you try.
    //
    // BSF_ALLOWSFW           - Windows that receive the broadcast are allowed
    //                          to become foreground windows.
    //
    // Also, DBT messages >= 0x8000 have lParams pointing to blocks of data that
    // need to be marshalled around. As user doesn't support "snapshotting" the
    // data for posts, we can't pass in BSF_POSTMESSAGE.
    //

    *Flags = BSF_IGNORECURRENTTASK;

    //
    // Standard (well-known) event guids.
    //
    if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_QUERY_CHANGE)) {

        *Flags |= BSF_QUERY | BSF_ALLOWSFW |
                  BSF_FORCEIFHUNG | BSF_NOHANG;
        *EventId = DBT_QUERYCHANGECONFIG;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_CANCELLED)) {

        *Flags |= BSF_POSTMESSAGE;
        *EventId = DBT_CONFIGCHANGECANCELED;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_HWPROFILE_CHANGE_COMPLETE)) {

        *Flags |= BSF_POSTMESSAGE;
        *EventId = DBT_CONFIGCHANGED;
        *ServiceControl = SERVICE_CONTROL_HARDWAREPROFILECHANGE;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INTERFACE_ARRIVAL)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_INTERFACE_REMOVAL)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVECOMPLETE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        *Flags |= BSF_QUERY | BSF_ALLOWSFW |
                  BSF_FORCEIFHUNG | BSF_NOHANG;
        *EventId = DBT_DEVICEQUERYREMOVE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_CANCELLED)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEQUERYREMOVEFAILED;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVE_PENDING)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVEPENDING;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_TARGET_DEVICE_REMOVE_COMPLETE)) {

        //
        // NOTE - BSF_QUERY is set so that we run the list backwards. No actual
        // broadcasts are done on this Id.
        //
        *Flags |= BSF_NOHANG | BSF_QUERY;
        *EventId = DBT_DEVICEREMOVECOMPLETE;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_ARRIVAL)) {

        *Flags |= BSF_NOHANG;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_ENUMERATED)) {

        *Flags = 0;
        *EventId = DBT_DEVICEARRIVAL;
        *ServiceControl = 0;

    //
    // Private event guids (kernel-mode pnp to user-mode pnp communication).
    // Setting EventId to zero causes ProcessDeviceEvent to swallow these
    // TargetDeviceChangeEvent events.
    //

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SAFE_REMOVAL) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_EJECT_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVAL_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_WARM_EJECT_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_STANDBY_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_HIBERNATE_VETOED) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_KERNEL_INITIATED_EJECT) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SURPRISE_REMOVAL) ||
               GuidEqual(EventGuid, (LPGUID)&GUID_DRIVER_BLOCKED)) {

        *Flags = 0;
        *EventId = 0;
        *ServiceControl = 0;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_PNP_CUSTOM_NOTIFICATION)) {

        //
        // Custom events cannot be failed (ie they aren't queries)
        //
        *EventId = DBT_CUSTOMEVENT;
        *Flags |= BSF_NOHANG;
        *ServiceControl = SERVICE_CONTROL_DEVICEEVENT;

    } else if (GuidEqual(EventGuid, (LPGUID)&GUID_PNP_POWER_NOTIFICATION)) {

        //
        // These are treated as custom too.
        //
        *EventId = DBT_CUSTOMEVENT;
        *Flags |= BSF_NOHANG;
        *ServiceControl = SERVICE_CONTROL_POWEREVENT;

    } else {

        //
        // Anything that makes it here is a bug.
        //
        ASSERT(GuidEqual(EventGuid, (LPGUID)&GUID_PNP_CUSTOM_NOTIFICATION));
        *EventId = 0;
        *Flags = 0;
        *ServiceControl = 0;
    }

    return TRUE;

} // EventIdFromEventGuid



ULONG
SendHotplugNotification(
    IN CONST GUID           *EventGuid,
    IN       PPNP_VETO_TYPE  VetoType      OPTIONAL,
    IN       LPWSTR          MultiSzList,
    IN OUT   PULONG          SessionId,
    IN       ULONG           Flags
    )
/*++

Routine Description:

    This routine kicks off a hotplug.dll process (if someone is logged in).
    We use a named pipe to comunicate with the user mode process and have it
    display the requested UI.

Arguments:

    EventGuid   - Specifies an event GUID.

    VetoType    - For events requiring a vetoer, supplies the address of a
                  variable containing the type of the component responsible for
                  vetoing the request.

    MultiSzList - Supplies the MultiSz list to be sent to hotplu.dll.  This is
                  usually a device ID, possibly followed by a list of vetoers
                  (which may or may not be device ID's).

    SessionId -   Supplies the address of a variable containing the SessionId on
                  which the hotplug dialog is to be displayed.  If successful,
                  the SessionId will contain the id of the session in which the
                  device install client process was launched.  Otherwise, will
                  contain an invalid session id, INVALID_SESSION (0xFFFFFFFF).

    Flags       - Specifies flags describing the behavior of the hotplug dialog.
                  The following flags are currently defined:

        HOTPLUG_DISPLAY_ON_CONSOLE - if specified, the value in the SessionId
           variable will be ignored, and the hotplug dialog will always be
           displayed on the current active console session.

Return Value:

    Currently returns TRUE/FALSE.

Return Value:

    If the process was successfully created, the return value is TRUE.  This
    routine doesn't wait until the process terminates.

    If we couldn't create the process (e.g., because no user was logged in),
    the return value is FALSE.

--*/
{
    BOOL bStatus;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR szCmdLine[MAX_PATH];
    WCHAR szHotPlugDllEntryPoint[80];
    HANDLE hHotPlugPipe = NULL;
    HANDLE hHotPlugEvent = NULL;
    HANDLE hFinishEvents[2] = { NULL, NULL };
    HANDLE hTemp, hUserToken = NULL;
    RPC_STATUS rpcStatus = RPC_S_OK;
    GUID  newGuid;
    WCHAR szGuidString[MAX_GUID_STRING_LEN];
    WCHAR szHotPlugPipeName[MAX_PATH];
    WCHAR szHotPlugEventName[MAX_PATH];
    ULONG ulHotPlugEventNameSize;
    ULONG ulMultiSzListSize;
    ULONG ulSize, ulSessionId;
    WIN32_FIND_DATA findData;
    LPWSTR pszName = NULL;
    PVOID lpEnvironment = NULL;
    OVERLAPPED overlapped;
    DWORD dwError, dwWait, dwBytes;


    //
    // Check if we should skip client side UI.
    //
    if (gbSuppressUI) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_WARNINGS,
                   "UMPNPMGR: SendHotplugNotification: "
                   "UI has been suppressed, exiting.\n"));
        LogWarningEvent(WRN_HOTPLUG_UI_SUPPRESSED, 1, MultiSzList);
        return FALSE;
    }

    //
    // Assume failure
    //
    bStatus = FALSE;

    try {
        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & HOTPLUG_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        //
        // Before doing anything, check that hotplug.dll is actually present on
        // the system.
        //
        szCmdLine[0] = L'\0';
        ulSize = GetSystemDirectory(szCmdLine, MAX_PATH);
        if ((ulSize == 0) || ((ulSize + 2 + ARRAY_SIZE(HOTPLUG_DLL)) > MAX_PATH)) {
            return FALSE;
        }
        lstrcat(szCmdLine, TEXT("\\"));
        lstrcat(szCmdLine, HOTPLUG_DLL);

        hTemp = FindFirstFile(szCmdLine, &findData);
        if(hTemp != INVALID_HANDLE_VALUE) {
            FindClose(hTemp);
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_WARNINGS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: %ws not found, error = %d, exiting\n",
                       szCmdLine,
                       GetLastError()));
            LogWarningEvent(WRN_HOTPLUG_NOT_PRESENT, 1, szCmdLine);
            return FALSE;
        }

        //
        // Get the user access token for the active console session user.
        //
        if (!GetSessionUserToken(ulSessionId, &hUserToken)) {
            return FALSE;
        }

        //
        // Create a named pipe and event for communication and synchronization
        // with HotPlug.  The event and named pipe must be global so that
        // UMPNPMGR can interact with a HotPlug client in a different session,
        // but it must still be unique for that session.  Add a generated GUID
        // so the names are not entirely well-known.
        //
        rpcStatus = UuidCreate(&newGuid);

        if ((rpcStatus != RPC_S_OK) &&
            (rpcStatus != RPC_S_UUID_LOCAL_ONLY)) {
            goto clean0;
        }

        if (StringFromGuid((LPGUID)&newGuid,
                           szGuidString,
                           MAX_GUID_STRING_LEN) != NO_ERROR) {
            goto clean0;
        }

        wsprintf(szHotPlugPipeName,
                 TEXT("%ws_%d.%ws"),
                 PNP_HOTPLUG_PIPE,
                 ulSessionId,
                 szGuidString);

        wsprintf(szHotPlugEventName,
                 TEXT("Global\\%ws_%d.%ws"),
                 PNP_HOTPLUG_EVENT,
                 ulSessionId,
                 szGuidString);

        ulHotPlugEventNameSize = (lstrlen(szHotPlugEventName) + 1) * sizeof(WCHAR);

        //
        // Initialize process, startup and overlapped structures, since we
        // depend on them being NULL during cleanup here on out.
        //
        memset(&ProcessInfo, 0, sizeof(ProcessInfo));
        memset(&StartupInfo, 0, sizeof(StartupInfo));
        memset(&overlapped,  0, sizeof(overlapped));

        //
        // Get the length of the multi-sz list. This is usually a device ID
        // possibly followed by a list of vetoers which may or may not be device
        // Id's
        //
        ulMultiSzListSize = 0;
        for (pszName = MultiSzList;
             *pszName;
             pszName += lstrlen(pszName) + 1) {

            ulMultiSzListSize += (lstrlen(pszName) + 1) * sizeof(WCHAR);
        }
        ulMultiSzListSize += sizeof(WCHAR);

        //
        // The approximate size of the named pipe output buffer should be large
        // enough to hold the greater of either:
        // - The name and size of the named event string, OR
        // - The type, size and contents of the multi-sz list.
        //
        ulSize = max(sizeof(ulHotPlugEventNameSize) +
                     ulHotPlugEventNameSize,
                     sizeof(PNP_VETO_TYPE) +
                     sizeof(ulMultiSzListSize) +
                     ulMultiSzListSize);

        //
        // Open up a named pipe to communicate with hotplug.dll.
        //
        hHotPlugPipe = CreateNamedPipe(szHotPlugPipeName,
                                       PIPE_ACCESS_OUTBOUND | // outbound data only
                                       FILE_FLAG_OVERLAPPED | // use overlapped structure
                                       FILE_FLAG_FIRST_PIPE_INSTANCE, // make sure we are the creator of the pipe
                                       PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                       1,                 // only one instance is allowed, and we are its creator
                                       ulSize,            // out buffer size
                                       0,                 // in buffer size
                                       PNP_PIPE_TIMEOUT,  // default timeout
                                       NULL               // default security
                                       );
        if (hHotPlugPipe == INVALID_HANDLE_VALUE) {
            hHotPlugPipe = NULL;
            goto clean0;
        }

        //
        // Create an event that a user-client can synchronize with and set, and
        // that we will block on after we send all the device IDs to
        // hotplug.dll.
        //
        if (CreateUserSynchEvent(szHotPlugEventName,
                                 &hHotPlugEvent) != NO_ERROR) {
            goto clean0;
        }


        if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_EJECT_VETOED)) {
            //
            // GUID_DEVICE_EJECT_VETOED : HotPlugEjectVetoed
            // Expects veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugEjectVetoed"));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_REMOVAL_VETOED)) {
            //
            // GUID_DEVICE_REMOVAL_VETOED : HotPlugRemovalVetoed
            // Expects veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugRemovalVetoed"));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_STANDBY_VETOED)) {
            //
            // GUID_DEVICE_STANDBY_VETOED : HotPlugStandbyVetoed
            // Expects veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugStandbyVetoed"));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_HIBERNATE_VETOED)) {
            //
            // GUID_DEVICE_HIBERNATE_VETOED : HotPlugHibernateVetoed
            // Expects veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugHibernateVetoed"));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_WARM_EJECT_VETOED)) {
            //
            // GUID_DEVICE_WARM_EJECT_VETOED : HotPlugWarmEjectVetoed
            // Expects veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugWarmEjectVetoed"));
            ASSERT(VetoType);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SAFE_REMOVAL)) {
            //
            // GUID_DEVICE_SAFE_REMOVAL : HotPlugSafeRemovalNotification
            // No veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugSafeRemovalNotification"));
            ASSERT(VetoType == NULL);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DEVICE_SURPRISE_REMOVAL)) {
            //
            // GUID_DEVICE_SURPRISE_REMOVAL : HotPlugSurpriseWarn
            // No veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugSurpriseWarn"));
            ASSERT(VetoType == NULL);

        } else if (GuidEqual(EventGuid, (LPGUID)&GUID_DRIVER_BLOCKED)) {
            //
            // GUID_DRIVER_BLOCKED : HotPlugDriverBlocked
            // No veto information.
            //
            lstrcpy(szHotPlugDllEntryPoint, TEXT("HotPlugDriverBlocked"));
            ASSERT(VetoType == NULL);

        } else {
            //
            // Unknown device event.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: Unknown device event!\n"));
            ASSERT(0);
            goto clean0;
        }

        //
        // Attempt to create the user's environment block.  If for some reason we
        // can't, we'll just have to create the process without it.
        //
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hUserToken,
                                    FALSE)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_EVENT,
                       "UMPNPMGR: SendHotplugNotification: "
                       "Failed to allocate environment block, error = %d!\n",
                       GetLastError()));
            lpEnvironment = NULL;
        }

        //
        // Launch hotplug.dll using rundll32.exe, passing it the pipe name.
        // "rundll32.exe hotplug.dll,<hotplug-entry-point> <hotplug-pipe-name>"
        //
        if (ARRAY_SIZE(szCmdLine) < (ARRAY_SIZE(RUNDLL32_EXE)   +
                                     1 +   // ' '
                                     ARRAY_SIZE(HOTPLUG_DLL)    +
                                     1 +   // ','
                                     lstrlen(szHotPlugDllEntryPoint) +
                                     1 +   // ' '
                                     lstrlen(szHotPlugPipeName) +
                                     1)) { // '\0'
            goto clean0;
        }

        wsprintf(szCmdLine,
                 TEXT("%ws %ws,%ws %ws"),
                 RUNDLL32_EXE, HOTPLUG_DLL,
                 szHotPlugDllEntryPoint,
                 szHotPlugPipeName);

        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.lpDesktop = DEFAULT_INTERACTIVE_DESKTOP; // WinSta0\Default

        //
        // CreateProcessAsUser will create the process in the session
        // specified by the by user-token.
        //
        if (!CreateProcessAsUser(hUserToken,        // hToken
                                 NULL,              // lpApplicationName
                                 szCmdLine,         // lpCommandLine
                                 NULL,              // lpProcessAttributes
                                 NULL,              // lpThreadAttributes
                                 FALSE,             // bInheritHandles
                                 CREATE_UNICODE_ENVIRONMENT |
                                 DETACHED_PROCESS,  // dwCreationFlags
                                 lpEnvironment,     // lpEnvironment
                                 NULL,              // lpDirectory
                                 &StartupInfo,      // lpStartupInfo
                                 &ProcessInfo       // lpProcessInfo
                                 )) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_ERRORS,
                       "UMPNPMGR: SendHotplugNotification: "
                       "Create rundll32 process failed, error = %d\n",
                       GetLastError()));
            goto clean0;
        }

        ASSERT(ProcessInfo.hProcess);
        ASSERT(ProcessInfo.hThread);

        //
        // Create an event for use with overlapped I/O - no security, manual
        // reset, not signalled, no name.
        //
        overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (overlapped.hEvent == NULL) {
            goto clean0;
        }

        //
        // Connect to the newly created named pipe.  If hotplug is not already
        // connected to the named pipe, then ConnectNamedPipe() will fail with
        // ERROR_IO_PENDING, and we will wait on the overlapped event.  If
        // newdev is already connected, it will fail with ERROR_PIPE_CONNECTED.
        // Note however that neither of these is an error condition.
        //
        if (!ConnectNamedPipe(hHotPlugPipe, &overlapped)) {
            //
            // Overlapped ConnectNamedPipe should always return FALSE on
            // success.  Check the last error to see what really happened.
            //
            dwError = GetLastError();

            if (dwError == ERROR_IO_PENDING) {
                //
                // I/O is pending, wait up to one minute for the client to
                // connect, also wait on the process in case it terminates
                // unexpectedly.
                //
                hFinishEvents[0] = overlapped.hEvent;
                hFinishEvents[1] = ProcessInfo.hProcess;

                dwWait = WaitForMultipleObjects(2, hFinishEvents,
                                                FALSE,
                                                PNP_PIPE_TIMEOUT); // 60 seconds

                if (dwWait == WAIT_OBJECT_0) {
                    //
                    // The overlapped I/O operation completed.  Check the status
                    // of the operation.
                    //
                    if (!GetOverlappedResult(hHotPlugPipe,
                                             &overlapped,
                                             &dwBytes,
                                             FALSE)) {
                        goto clean0;
                    }

                } else {
                    //
                    // Either the connection timed out, or the client process
                    // exited.  Cancel pending I/O against the pipe, and quit.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: SendHotPlugNotification: "
                               "Connect timed out, or client process exited!\n"));
                    CancelIo(hHotPlugPipe);
                    goto clean0;
                }

            } else if (dwError != ERROR_PIPE_CONNECTED) {
                //
                // If the last error indicates anything other than pending I/O,
                // or that The client is already connected to named pipe, fail.
                //
                goto clean0;
            }

        } else {
            //
            // ConnectNamedPipe should not return anything but FALSE in
            // overlapped mode.
            //
            goto clean0;
        }

        //
        // The client is now connected to the named pipe.
        // Close the overlapped event.
        //
        CloseHandle(overlapped.hEvent);
        overlapped.hEvent = NULL;

        //
        // The first data in the pipe will be the length of the name of the
        // event that will be used to sync up umpnpmgr.dll and hotplug.dll.
        //
        if (!WriteFile(hHotPlugPipe,
                       &ulHotPlugEventNameSize,
                       sizeof(ulHotPlugEventNameSize),
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // The next data in the pipe will be the name of the event that will
        // be used to sync up umpnpmgr.dll and hotplug.dll.
        //
        if (!WriteFile(hHotPlugPipe,
                       (LPCVOID)szHotPlugEventName,
                       ulHotPlugEventNameSize,
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }


        if (ARGUMENT_PRESENT(VetoType)) {
            //
            // For the notification types expecting veto information,
            // send the Veto type to the client.
            //
            if (!WriteFile(hHotPlugPipe,
                           (LPCVOID)VetoType,
                           sizeof(PNP_VETO_TYPE),
                           &ulSize,
                           NULL)) {
                LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
                goto clean0;
            }
        }

        //
        // Send the string length to the client
        //
        if (!WriteFile(hHotPlugPipe,
                       (LPCVOID)&ulMultiSzListSize,
                       sizeof(ulMultiSzListSize),
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // Now send over the entire string
        //
        if (!WriteFile(hHotPlugPipe,
                       MultiSzList,
                       ulMultiSzListSize,
                       &ulSize,
                       NULL)) {
            LogErrorEvent(ERR_WRITING_SURPRISE_REMOVE_PIPE, GetLastError(), 0);
            goto clean0;
        }

        //
        // When we are done writing, we need to close the pipe handles so that
        // the client will get a ReadFile error and know that we are finished.
        //
        if (hHotPlugPipe) {
            CloseHandle(hHotPlugPipe);
            hHotPlugPipe = NULL;
        }

        //
        // Wait for hotplug.dll to respond by setting the event before before
        // returning.  Also wait on the process as well, to catch the case where
        // the process crashes (or goes away) without signaling the device
        // install event.
        //
        hFinishEvents[0] = hHotPlugEvent;
        hFinishEvents[1] = ProcessInfo.hProcess;
        WaitForMultipleObjects(2, hFinishEvents, FALSE, INFINITE);

        bStatus = TRUE;

    clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in SendHotPlugNotification!!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        lpEnvironment = lpEnvironment;
        ProcessInfo.hThread = ProcessInfo.hThread;
        ProcessInfo.hProcess = ProcessInfo.hProcess;
        hUserToken = hUserToken;
        hHotPlugPipe = hHotPlugPipe;
        hHotPlugEvent = hHotPlugEvent;
    }

    if (lpEnvironment) {
        DestroyEnvironmentBlock(lpEnvironment);
    }

    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }

    if (ProcessInfo.hProcess) {
        CloseHandle(ProcessInfo.hProcess);
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    if (hHotPlugPipe) {
        CloseHandle(hHotPlugPipe);
    }

    if (hHotPlugEvent) {
        CloseHandle(hHotPlugEvent);
    }

    if (!bStatus) {
        *SessionId = INVALID_SESSION;
    } else {
        *SessionId = ulSessionId;
    }

    return bStatus;

} // SendHotplugNotification



ULONG
CheckEjectPermissions(
    IN      LPWSTR          DeviceId,
    OUT     PPNP_VETO_TYPE  VetoType            OPTIONAL,
    OUT     LPWSTR          VetoName            OPTIONAL,
    IN OUT  PULONG          VetoNameLength      OPTIONAL
    )
/*++

Routine Description:

   Checks that the user has eject permissions for the specified device.

Arguments:

    DeviceId       - Specifies the device instance id of the device for which
                     eject permissions are to be checked.

    VetoType       - Supplies the address of a variable to receive, upon
                     failure, the type of the component responsible for vetoing
                     the request.

    VetoName       - Supplies the address of a variable to receive, upon
                     failure, the name of the component responsible for vetoing
                     the request.

    VetoNameLength - Supplies the address of a variable specifying the size of
                     the of buffer specified by the VetoName parameter.  Upon
                     failure, this address will specify the length of the string
                     stored in that buffer by this routine.


Return Value:

   FALSE if the eject should be blocked, TRUE otherwise.

Note:

    This routine is called while processing a kernel-initiated ejection event.
    On this side of the event, we are NOT in the context of the user who
    initiated the ejection, but since only the active console user was allowed
    to initiate the request that triggered this event, we use the access token
    of the active console user for the check on this side also.  (should the
    active console user change between the request and this event, this would
    check that the user that the current active console user has eject
    permissions; this is still a valid thing to do since it is the console user
    who will receive the ejected hardware)

--*/
{
    BOOL    bResult, bDockDevice;
    ULONG   ulPropertyData, ulDataSize, ulDataType;
    ULONG   ulTransferLen, ulConsoleSessionId;
    HANDLE  hUserToken = NULL;

    //
    // Is this a dock?
    //
    bDockDevice = FALSE;
    ulDataSize = ulTransferLen = sizeof(ULONG);
    if (CR_SUCCESS == PNP_GetDeviceRegProp(NULL,
                                           DeviceId,
                                           CM_DRP_CAPABILITIES,
                                           &ulDataType,
                                           (LPBYTE)&ulPropertyData,
                                           &ulTransferLen,
                                           &ulDataSize,
                                           0)) {

        if (ulPropertyData & CM_DEVCAP_DOCKDEVICE) {

            //
            // Undocking (ie ejecting a dock) uses a special privilege.
            //
            bDockDevice = TRUE;
        }
    } else {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: PNP_GetDeviceRegProp failed, error = %d\n",
                   GetLastError()));

        return FALSE;
    }

    ulConsoleSessionId = GetActiveConsoleSessionId();

    if ((IsSessionLocked(ulConsoleSessionId)) ||
        (!GetSessionUserToken(ulConsoleSessionId, &hUserToken))) {
        //
        // If the console session is locked or no user is logged in, supply no
        // user token, and verify strictly against the policy permissions
        // required to eject the dock or device, absent a user.
        //
        hUserToken = NULL;
    }

    bResult = VerifyKernelInitiatedEjectPermissions(hUserToken, bDockDevice);

    if (bResult == FALSE) {

        if (ARGUMENT_PRESENT(VetoType)) {
            *VetoType = PNP_VetoInsufficientRights;
        }

        if (ARGUMENT_PRESENT(VetoNameLength)) {

            //
            // VetoNameLength is in characters.
            //
            if (ARGUMENT_PRESENT(VetoName) && *VetoNameLength) {
                *VetoName = UNICODE_NULL;
            }
            *VetoNameLength = 0;
        }
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    return bResult;

} // CheckEjectPermissions


//---------------------------------------------------------------------------
// Private Utility Routines
//---------------------------------------------------------------------------

BOOL
GuidEqual(
    CONST GUID UNALIGNED *Guid1,
    CONST GUID UNALIGNED *Guid2
    )
{
    RPC_STATUS rpcStatus;
    return UuidEqual((LPGUID)Guid1, (LPGUID)Guid2, &rpcStatus);
} // GuidEqual


VOID
LogErrorEvent(
    DWORD dwEventID,
    DWORD dwError,
    WORD  nStrings,
    ...
    )
{
    HANDLE  hEventLog;
    LPTSTR  *paStrings;
    va_list pArg;
    DWORD   index;

    hEventLog = RegisterEventSource(NULL, TEXT("PlugPlayManager"));

    if (hEventLog == NULL) {
        return;
    }

    if (nStrings) {

        paStrings = HeapAlloc(ghPnPHeap, 0, nStrings * sizeof(LPTSTR));

        if (paStrings != NULL) {
            va_start(pArg, nStrings);

            for (index = 0; index < nStrings; index++) {
                paStrings[index] = va_arg(pArg, LPTSTR);
            }

            va_end(pArg);

            ReportEvent( hEventLog,
                         EVENTLOG_ERROR_TYPE,
                         0,                     // wCategory
                         dwEventID,             // dwEventID
                         NULL,                  // lpUserSID
                         nStrings,              // wNumStrings
                         sizeof(dwError),       // dwDataSize
                         paStrings,             // lpStrings
                         &dwError);             // lpRawData

            HeapFree(ghPnPHeap, 0, paStrings);
        }

    } else {

        ReportEvent( hEventLog,
                     EVENTLOG_ERROR_TYPE,
                     0,                     // wCategory
                     dwEventID,             // dwEventID
                     NULL,                  // lpUserSID
                     0,                     // wNumStrings
                     sizeof(dwError),       // dwDataSize
                     NULL,                  // lpStrings
                     &dwError);             // lpRawData
    }

    DeregisterEventSource(hEventLog);
}

VOID
LogWarningEvent(
    DWORD dwEventID,
    WORD  nStrings,
    ...
    )
{
    HANDLE  hEventLog;
    LPTSTR  *paStrings;
    va_list pArg;
    DWORD   index;

    hEventLog = RegisterEventSource(NULL, TEXT("PlugPlayManager"));

    if (hEventLog == NULL) {
        return;
    }

    paStrings = HeapAlloc(ghPnPHeap, 0, nStrings * sizeof(LPTSTR));

    if (paStrings != NULL) {
        va_start(pArg, nStrings);

        for (index = 0; index < nStrings; index++) {
            paStrings[index] = va_arg(pArg, LPTSTR);
        }

        va_end(pArg);

        ReportEvent( hEventLog,
                     EVENTLOG_WARNING_TYPE,
                     0,                     // wCategory
                     dwEventID,             // dwEventID
                     NULL,                  // lpUserSID
                     nStrings,              // wNumStrings
                     0,                     // dwDataSize
                     paStrings,             // lpStrings
                     NULL);                 // lpRawData

        HeapFree(ghPnPHeap, 0, paStrings);
    }

    DeregisterEventSource(hEventLog);
}

BOOL
LockNotifyList(
    IN LOCKINFO *Lock
    )
{
    return LockPrivateResource(Lock);
}


VOID
UnlockNotifyList(
    IN LOCKINFO *Lock
    )
{
    UnlockPrivateResource(Lock);
}



PPNP_NOTIFY_LIST
GetNotifyListForEntry(
    IN PPNP_NOTIFY_ENTRY Entry
    )
/*++

Routine Description:

    This routine retrives the notification list that the given entry is in,
    based on the list entry signature.  If this entry has been removed from a
    notification list (via DeleteNotifyEntry), NULL is returned.

Arguments:

    Entry - Specifies a notification entry for the coresponding notification
            list is to be found.

Return Value:

    Returns the notification list this entry is a member of, or NULL if the
    entry is not in any notification list.

--*/
{
    PPNP_NOTIFY_LIST notifyList;

    if (!Entry) {
        return NULL;
    }

    //
    // Retrieve the list pointer from the entry signature.
    // The signature contains two pieces of data.
    //
    // It is a ULONG, with byte 0 being a list index and
    // bytes 1,2,3 being the signature
    // We mask and compare the top 3 bytes to find which list
    // then return the address of the list to lock based on the
    // index in the bottom byte.
    //

    switch (Entry->Signature & LIST_ENTRY_SIGNATURE_MASK) {

        case TARGET_ENTRY_SIGNATURE:
            notifyList = &TargetList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case CLASS_ENTRY_SIGNATURE:
            notifyList = &ClassList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case SERVICE_ENTRY_SIGNATURE:
            notifyList = &ServiceList[Entry->Signature & LIST_ENTRY_INDEX_MASK];
            break;

        case 0:
            //
            // If the entry Signature is 0, this entry has been removed from it's
            // notification list.
            //
            notifyList = NULL;
            break;

        default:
            //
            // Should never get here!
            //
            ASSERT (FALSE);
            notifyList = NULL;
            break;
    }
    return notifyList;

} // GetNotifyListForEntry



BOOL
DeleteNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN BOOLEAN RpcNotified
    )
/*++

Routine Description:

    This routine removes an entry from a notification list and frees the
    memory for that entry.

Arguments:

   Entry - Specifies an entry in one of the notification lists that is
           to be deleted.

Return Value:

   Returns TRUE or FALSE.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = Entry->Previous;

    if (!(Entry->Freed & DEFER_NOTIFY_FREE)) {
        if (previousEntry == NULL) {
            return FALSE;
        }

        //
        // hook up the forward and backwards pointers
        //
        previousEntry->Next = Entry->Next;

        if (Entry->Next) {
            ((PPNP_NOTIFY_ENTRY)(Entry->Next))->Previous = previousEntry;
        }

        //
        // Clear the entry signature now that it is no longer part of any list.
        //
        Entry->Signature = 0;
    }

    if (RpcNotified || (Entry->Freed & DEFER_NOTIFY_FREE)) {
        if (Entry->ClientName) {
            HeapFree (ghPnPHeap,0,Entry->ClientName);
            Entry->ClientName = NULL;
        }
        HeapFree(ghPnPHeap, 0, Entry);
    }else {
        //
        //Let the entry dangle until the RPC rundown
        //
        Entry->Freed |= DEFER_NOTIFY_FREE;
    }

    return TRUE;

} // DeleteNotifyEntry;



VOID
AddNotifyEntry(
    IN PPNP_NOTIFY_LIST  NotifyList,
    IN PPNP_NOTIFY_ENTRY NewEntry
    )
/*++

Routine Description:

    This routine inserts an entry at the tail of a notification list.

Arguments:

   Entry - Specifies an entry to be added to a notification list

Return Value:

   None.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = NULL, currentEntry = NULL;
    //
    // Skip to the last entry in this list.
    //
    previousEntry = (PPNP_NOTIFY_ENTRY)NotifyList;
    currentEntry = previousEntry->Next;

    while (currentEntry) {
        previousEntry = currentEntry;
        currentEntry = currentEntry->Next;
    }

    //
    // Attach this entry to the end of the list.
    //
    previousEntry->Next = NewEntry;
    NewEntry->Previous = previousEntry;
    NewEntry->Next = NULL;

    return;

} // AddNotifyEntry;



PPNP_NOTIFY_ENTRY
GetNextNotifyEntry(
    IN PPNP_NOTIFY_ENTRY Entry,
    IN DWORD Flags
    )
/*++

Routine Description:

    Returns the next entry in the notification list for the entry specified, in
    the direction specified by the Flags.

Arguments:

    Entry - Specified a notification list entry.

    Flags - Specifies BSF_* flags indicating the direction the list is to be
            traversed.  If BSF_QUERY is specified, the previous list entry is
            returned, otherwise returns the next entry forward in the list.

Return Value:

    Returns the next entry in the notification list, or NULL if no such entry
    exists.

--*/
{
    PPNP_NOTIFY_ENTRY nextEntry = NULL;

    if (Entry == NULL) {
        return Entry;
    }

    //
    // Determine if this is a QUERY (or a resume). In which case
    // we go back -> front.
    //
    if (Flags & BSF_QUERY) {
        nextEntry = Entry->Previous;
        //
        // If the previous entry is the list head, there is no next entry.
        //
        if ((nextEntry == NULL) ||
            (nextEntry->Previous == NULL)) {
            return NULL;
        }

    } else {
        nextEntry = Entry->Next;
    }
    return nextEntry;
}



PPNP_NOTIFY_ENTRY
GetFirstNotifyEntry(
    IN PPNP_NOTIFY_LIST List,
    IN DWORD Flags
    )
/*++

Routine Description:

    Returns the first entry in the specified notification list, starting from
    the direction specified by the Flags.

Arguments:

    List  - Specified a notification list.

    Flags - Specifies BSF_* flags indicating the end of the list from which the
            first entry is to be retrieved.  If BSF_QUERY is specified, the last
            list entry is returned, otherwise returns the first entry in the
            list.

Return Value:

    Returns the first entry in the notification list, or NULL if no such entry
    exists.

--*/
{
    PPNP_NOTIFY_ENTRY previousEntry = NULL, currentEntry = NULL, firstEntry = NULL;

    //
    // Determine if this is a QUERY (or a resume). In which case
    // we go back -> front.
    //
    if (Flags & BSF_QUERY) {

        //
        // Skip to the last entry in this list.
        //
        previousEntry = (PPNP_NOTIFY_ENTRY)List;
        currentEntry = previousEntry->Next;

        while (currentEntry) {
            previousEntry = currentEntry;
            currentEntry = currentEntry->Next;
        }
        if (!previousEntry->Previous) {
            //
            // If the list is empty, there is no first entry.
            //
            firstEntry = NULL;
        } else {
            firstEntry = previousEntry;
        }

    } else {
        firstEntry = (PPNP_NOTIFY_ENTRY)List->Next;
    }
    return firstEntry;
}



ULONG
HashString(
    IN LPWSTR String,
    IN ULONG  Buckets
    )
/*++

Routine Description:

    This routine performs a quick and dirty hash of a unicode string.

Arguments:

   String - Null-terminated unicode string to perform hash on.

   Buckets - Number of hashing buckets.

Return Value:

   Returns a hash value between 0 and Buckets.

--*/
{
    LPWSTR p = String;
    ULONG hash = 0;

    while (*p) {
        hash ^= *p;
        p++;
    }

    hash = hash % Buckets;

    return hash;

} // HashString



DWORD
MapQueryEventToCancelEvent(
    IN DWORD QueryEventId
    )
/*++

Routine Description:

    This routine maps a query device event id (such as query remove) to the
    corresponding cancel device event id (such as cancel remove). The event
    ids are based on DBT_Xxx values from DBT.H.

Arguments:

   QueryEventId - A DBT_Xxx query type device event id.


Return Value:

   Returns the corresponding cancel device event id or -1 if it fails.

--*/
{
    DWORD cancelEventId;

    switch (QueryEventId) {

        case DBT_QUERYCHANGECONFIG:
            cancelEventId = DBT_CONFIGCHANGECANCELED;
            break;

        case DBT_DEVICEQUERYREMOVE:
            cancelEventId = DBT_DEVICEQUERYREMOVEFAILED;
            break;

        case PBT_APMQUERYSUSPEND:
            cancelEventId = PBT_APMQUERYSUSPENDFAILED;
            break;

        case PBT_APMQUERYSTANDBY:
            cancelEventId = PBT_APMQUERYSTANDBYFAILED;

        default:
            cancelEventId = -1;
            break;
    }

    return cancelEventId;

} // MapQueryEventToCancelEvent



VOID
FixUpDeviceId(
    IN OUT LPTSTR  DeviceId
    )
/*++

Routine Description:

    This routine copies a device id, fixing it up as it does the copy.
    'Fixing up' means that the string is made upper-case, and that the
    following character ranges are turned into underscores (_):

    c <= 0x20 (' ')
    c >  0x7F
    c == 0x2C (',')

    (NOTE: This algorithm is also implemented in the Config Manager APIs,
    and must be kept in sync with that routine. To maintain device identifier
    compatibility, these routines must work the same as Win95.)

Arguments:

Return Value:

    None.

--*/
{
    PTCHAR p;

    CharUpper(DeviceId);
    p = DeviceId;
    while (*p) {
        if ((*p <= TEXT(' '))  || (*p > (TCHAR)0x7F) || (*p == TEXT(','))) {
            *p = TEXT('_');
        }
        p++;
    }

} // FixUpDeviceId


BOOL
GetWindowsExeFileName(
    IN  HWND      hWnd,
    OUT LPWSTR    lpszFileName,
    IN OUT PULONG pulFileNameLength
    )
/*++

Routine Description:

    This routine retrieves the module file name for the process that the
    specified window belongs to.

Arguments:

    hWnd              - Supplies the handle to the window whose process module
                        file name is to be retrieved.

    lpszFileName      - Supplies the address of a variable to receive, upon
                        success, the module file name of the window's process.

    pulFileNameLength - Supplies the address of a variable specifying the size of
                        the of buffer specified by the lpszFileName parameter.
                        Upon success, this address will specify the length of
                        the string stored in that buffer by this routine.

Return Value:

    Returns TRUE if the module file name was retrieved, FALSE otherwise.

Notes:

    GetWindowThreadProcessId will fail unless UMPNPMGR has set the Desktop this
    thread is executing on to the same as the application.  Note that this is
    only possible for Desktops in SessionId 0.

--*/
{
    DWORD                   pidApp;
    HANDLE                  hProcess;
    HMODULE                 hPSAPI;
    DWORD                   dwLength;

    dwLength = 0;

    if (GetWindowThreadProcessId(hWnd, &pidApp)) {

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
                               FALSE,
                               pidApp);

        if (hProcess != NULL) {

            hPSAPI = LoadLibrary(TEXT("psapi.dll"));

            if (hPSAPI != NULL) {

                typedef DWORD (WINAPI *FP_GETMODULEFILENAMEEXW)(
                    HANDLE hProcess,
                    HMODULE hModule,
                    LPWSTR lpFilename,
                    DWORD nSize);

                FP_GETMODULEFILENAMEEXW fpGetModuleFileNameExW;

                fpGetModuleFileNameExW = (FP_GETMODULEFILENAMEEXW)
                    GetProcAddress(hPSAPI,
                                   "GetModuleFileNameExW");

                if (fpGetModuleFileNameExW != NULL) {
                    dwLength = fpGetModuleFileNameExW(hProcess,
                                                      NULL,
                                                      lpszFileName,
                                                      *pulFileNameLength);

                }

                FreeLibrary(hPSAPI);
            }
            CloseHandle(hProcess);

        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: OpenProcess returned error = %d\n",
                       GetLastError()));
        }

    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: GetWindowThreadProcessId returned error = %d\n",
                   GetLastError()));
    }

    if ((dwLength == 0) && (*pulFileNameLength)) {
        lpszFileName[0] = UNICODE_NULL;
    }

    *pulFileNameLength = dwLength;

    return TRUE;

} // GetWindowsExeFileName



BOOL
InitializeHydraInterface(
    VOID
    )
/*++

Routine Description:

    This routine loads the terminal services support libraries and locates
    required function entrypoints.

Arguments:

    None.

Return Value:

    Returns TRUE if the terminal services support libraries were successfully
    loaded, and entrypoints located.

--*/
{
    BOOL Status = FALSE;

    //
    // Load the base library that contains the user message dispatch routines
    // for Terminal Services.
    //
    ghWinStaLib = LoadLibrary(WINSTA_DLL);
    if (!ghWinStaLib) {
        return FALSE;
    }

    fpWinStationSendWindowMessage =
        (FP_WINSTASENDWINDOWMESSAGE)GetProcAddress(
            ghWinStaLib,
            "WinStationSendWindowMessage");

    fpWinStationBroadcastSystemMessage =
        (FP_WINSTABROADCASTSYSTEMMESSAGE)GetProcAddress(
            ghWinStaLib,
            "WinStationBroadcastSystemMessage");

    fpWinStationQueryInformationW =
        (FP_WINSTAQUERYINFORMATIONW)GetProcAddress(
            ghWinStaLib,
            "WinStationQueryInformationW");

    if (!fpWinStationSendWindowMessage ||
        !fpWinStationBroadcastSystemMessage ||
        !fpWinStationQueryInformationW) {
        goto Clean0;
    }


    //
    // Load the library that contains Terminal Services support routines.
    //
    ghWtsApi32Lib = LoadLibrary(WTSAPI32_DLL);
    if (!ghWtsApi32Lib) {
        goto Clean0;
    }

    fpWTSQuerySessionInformation =
        (FP_WTSQUERYSESSIONINFORMATION)GetProcAddress(
            ghWtsApi32Lib,
            "WTSQuerySessionInformationW");

    fpWTSFreeMemory =
        (FP_WTSFREEMEMORY)GetProcAddress(
            ghWtsApi32Lib,
            "WTSFreeMemory");

    if (!fpWTSQuerySessionInformation ||
        !fpWTSFreeMemory) {
        goto Clean0;
    }

    Status = TRUE;

Clean0:

    ASSERT(Status == TRUE);

    if (!Status) {
        //
        // Something failed.  Unload all libraries.
        //
        fpWinStationSendWindowMessage = NULL;
        fpWinStationBroadcastSystemMessage = NULL;
        fpWinStationQueryInformationW = NULL;

        if (ghWinStaLib) {
            FreeLibrary(ghWinStaLib);
            ghWinStaLib = NULL;
        }

        fpWTSQuerySessionInformation = NULL;
        fpWTSFreeMemory = NULL;

        if (ghWtsApi32Lib) {
            FreeLibrary(ghWtsApi32Lib);
            ghWtsApi32Lib = NULL;
        }
    }

    return Status;

} // InitializeHydraInterface



BOOL
GetClientName(
    IN  PPNP_NOTIFY_ENTRY entry,
    OUT LPWSTR  lpszClientName,
    IN OUT PULONG  pulClientNameLength
    )
/*++

Routine Description:

    This routine retrieves the client name for the specified notification list
    entry.

Arguments:

    entry                - Specifies a notification list entry.

    lpszClientName       - Supplies the address of a variable to receive, the
                           client name of the window's process.

    pulClientrNameLength - Supplies the address of a variable specifying the size of
                           the of buffer specified by the lpszFileName parameter.
                           Upon return, this address will specify the length of
                           the string stored in that buffer by this routine.

Return Value:

    Returns TRUE.

--*/
{
    DWORD dwLength;

    dwLength = lstrlen(entry->ClientName)+1;

    ASSERT (dwLength <= (*pulClientNameLength));

    dwLength = min((*pulClientNameLength), dwLength);

    lstrcpyn(lpszClientName,
             entry->ClientName,
             dwLength);

    *pulClientNameLength = dwLength-1;

    return TRUE;

} // GetClientName



void __RPC_USER
PNP_NOTIFICATION_CONTEXT_rundown(
    PPNP_NOTIFICATION_CONTEXT hEntry
    )
/*++

Routine Description:

    Rundown routine for RPC.  This will get called if a client/server pipe
    breaks without unregistering a notification.  If a notification is in
    progress when rundown is called, the entry is kept in a deferred list, and
    this routines is explicitly called again for the deferred entry, after
    notification is complete.

    This routine frees the memory associated with the notification entry that is
    no longer needed.

Arguments:

    hEntry - Specifies a notification entry for which RPC has requested rundown.

Return Value:

    None.

--*/
{
    PPNP_NOTIFY_LIST notifyList;
    PPNP_NOTIFY_ENTRY node;
    PPNP_DEFERRED_LIST rundownNode;
    BOOLEAN bLocked = FALSE;

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_WARNINGS | DBGF_EVENT,
               "UMPNPMGR: Cleaning up broken pipe\n"));

    try {
        EnterCriticalSection(&RegistrationCS);
        node = (PPNP_NOTIFY_ENTRY) hEntry;

        if (gNotificationInProg != 0) {
            //
            // Before freeing the entry, we need to make sure that it's not sitting
            // around in the deferred RegisterList or UnregisterList.
            //

            if (RegisterList != NULL) {
                //
                // Check to see if this entry is in the deferred RegisterList.
                //
                PPNP_DEFERRED_LIST currReg,prevReg;

                currReg = RegisterList;
                prevReg = NULL;

                while (currReg) {
                    ASSERT(currReg->Entry->Unregistered);
                    if (currReg->Entry == node) {
                        //
                        // Remove this entry from the deferred RegisterList.
                        //
                        if (prevReg) {
                            prevReg->Next = currReg->Next;
                        } else {
                            RegisterList = currReg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currReg);
                        if (prevReg) {
                            currReg = prevReg->Next;
                        } else {
                            currReg = RegisterList;
                        }
                    } else {
                        prevReg = currReg;
                        currReg = currReg->Next;
                    }
                }
            }
            if (UnregisterList != NULL) {
                //
                // Check to see if this entry is in the deferred UnregisterList.
                //
                PPNP_DEFERRED_LIST currUnreg,prevUnreg;
                currUnreg = UnregisterList;
                prevUnreg = NULL;

                while (currUnreg) {
                    ASSERT(currUnreg->Entry->Unregistered);
                    if (currUnreg->Entry == node) {
                        //
                        // Remove this entry from the deferred UnregisterList.
                        //
                        if (prevUnreg) {
                            prevUnreg->Next = currUnreg->Next;
                        } else {
                            UnregisterList = currUnreg->Next;
                        }
                        HeapFree(ghPnPHeap, 0, currUnreg);
                        if (prevUnreg) {
                            currUnreg = prevUnreg->Next;
                        } else {
                            currUnreg = UnregisterList;
                        }
                    } else {
                        prevUnreg = currUnreg;
                        currUnreg = currUnreg->Next;
                    }
                }
            }

            //
            // If the entry to be rundown is part of a notification list, make
            // sure it does not get notified.
            //
            notifyList = GetNotifyListForEntry(node);
            if (notifyList) {
                LockNotifyList(&notifyList->Lock);
                bLocked = TRUE;
                node->Unregistered = TRUE;
                UnlockNotifyList(&notifyList->Lock);
                bLocked = FALSE;
            }

            //
            // Delay rundown of this entry until after the notification in
            // progress is complete.
            //
            rundownNode = (PPNP_DEFERRED_LIST)
                HeapAlloc(ghPnPHeap,
                          0,
                          sizeof (PNP_DEFERRED_LIST));

            if (!rundownNode) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS | DBGF_WARNINGS,
                           "UMPNPMGR: Error allocating deferred list entry during RPC rundown!\n"));
                goto Clean0;
            }
            rundownNode->hBinding = 0;
            rundownNode->Entry = node;
            rundownNode->Next = RundownList;
            RundownList = rundownNode;

        } else {

            if (!(node->Freed & DEFER_NOTIFY_FREE)) {
                //
                // This entry is still in a notification list.
                //
                notifyList = GetNotifyListForEntry(node);
                ASSERT(notifyList);
                if (notifyList) {
                    //
                    // Lock the notification list and delete this entry.
                    //
                    LockNotifyList (&notifyList->Lock);
                    bLocked = TRUE;
                }
                node->Freed |= (PNP_UNREG_FREE|PNP_UNREG_RUNDOWN);
                DeleteNotifyEntry (node,TRUE);
                if (notifyList) {
                    UnlockNotifyList (&notifyList->Lock);
                    bLocked = FALSE;
                }

            } else {
                //
                // This node has been removed from the list, and should just be deleted
                //
                DeleteNotifyEntry (node,TRUE);
            }
        }

    Clean0:

        LeaveCriticalSection(&RegistrationCS);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during PNP_NOTIFICATION_CONTEXT_rundown!\n"));
        ASSERT(0);

        if (bLocked) {
            UnlockNotifyList (&notifyList->Lock);
        }
        LeaveCriticalSection(&RegistrationCS);
    }

    return;

} // PNP_NOTIFICATION_CONTEXT_rundown



DWORD
LoadDeviceInstaller(
    VOID
    )
/*++

Routine Description:

    This routine loads setupapi.dll and retrieves the necessary device install
    entrypoints.  It also creates two named events used to communicate with the
    client-side UI in the case where there's a user logged in.

    If setupapi.dll is already loaded, it simply returns success.

Arguments:

    None

Return Value:

    If successful, NO_ERROR is returned.  Otherwise, a Win32 error code is
    returned indicating the cause of failure.

--*/
{
    DWORD Err = NO_ERROR;
    DWORD SetupGlobalFlags;

    if(ghDeviceInstallerLib) {
        return NO_ERROR;
    }

    ghDeviceInstallerLib = LoadLibrary(SETUPAPI_DLL);
    if(!ghDeviceInstallerLib) {
        return GetLastError();
    }

    try {

        if(!(fpCreateDeviceInfoList  = (FP_CREATEDEVICEINFOLIST)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiCreateDeviceInfoList"))) {
            goto HitFailure;
        }

        if(!(fpOpenDeviceInfo        = (FP_OPENDEVICEINFO)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiOpenDeviceInfoW"))) {
            goto HitFailure;
        }

        if(!(fpBuildDriverInfoList   = (FP_BUILDDRIVERINFOLIST)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiBuildDriverInfoList"))) {
            goto HitFailure;
        }

        if(!(fpDestroyDeviceInfoList = (FP_DESTROYDEVICEINFOLIST)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiDestroyDeviceInfoList"))) {
            goto HitFailure;
        }

        if(!(fpCallClassInstaller    = (FP_CALLCLASSINSTALLER)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiCallClassInstaller"))) {
            goto HitFailure;
        }

        if(!(fpInstallClass          = (FP_INSTALLCLASS)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiInstallClassW"))) {
            goto HitFailure;
        }

        if(!(fpGetSelectedDriver     = (FP_GETSELECTEDDRIVER)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiGetSelectedDriverW"))) {
            goto HitFailure;
        }

        if(!(fpGetDriverInfoDetail   = (FP_GETDRIVERINFODETAIL)GetProcAddress(
                                          ghDeviceInstallerLib,
                                          "SetupDiGetDriverInfoDetailW"))) {
            goto HitFailure;
        }

        if(!(fpGetDeviceInstallParams = (FP_GETDEVICEINSTALLPARAMS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupDiGetDeviceInstallParamsW"))) {
            goto HitFailure;
        }

        if(!(fpSetDeviceInstallParams = (FP_SETDEVICEINSTALLPARAMS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupDiSetDeviceInstallParamsW"))) {
            goto HitFailure;
        }

        if(!(fpGetDriverInstallParams = (FP_GETDRIVERINSTALLPARAMS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupDiGetDriverInstallParamsW"))) {
            goto HitFailure;
        }

        if(!(fpSetClassInstallParams  = (FP_SETCLASSINSTALLPARAMS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupDiSetClassInstallParamsW"))) {
            goto HitFailure;
        }

        if(!(fpGetClassInstallParams  = (FP_GETCLASSINSTALLPARAMS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupDiGetClassInstallParamsW"))) {
            goto HitFailure;
        }

        if(!(fpOpenInfFile            = (FP_OPENINFFILE)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupOpenInfFileW"))) {
            goto HitFailure;
        }

        if(!(fpCloseInfFile           = (FP_CLOSEINFFILE)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupCloseInfFile"))) {
            goto HitFailure;
        }

        if(!(fpFindFirstLine          = (FP_FINDFIRSTLINE)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupFindFirstLineW"))) {
            goto HitFailure;
        }

        if(!(fpFindNextMatchLine      = (FP_FINDNEXTMATCHLINE)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupFindNextMatchLineW"))) {
            goto HitFailure;
        }

        if(!(fpGetStringField         = (FP_GETSTRINGFIELD)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "SetupGetStringFieldW"))) {
            goto HitFailure;
        }

        if(!(fpSetGlobalFlags         = (FP_SETGLOBALFLAGS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "pSetupSetGlobalFlags"))) {
            goto HitFailure;
        }

        if(!(fpGetGlobalFlags         = (FP_GETGLOBALFLAGS)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "pSetupGetGlobalFlags"))) {
            goto HitFailure;
        }

        if(!(fpAccessRunOnceNodeList  = (FP_ACCESSRUNONCENODELIST)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "pSetupAccessRunOnceNodeList"))) {
            goto HitFailure;
        }

        if(!(fpDestroyRunOnceNodeList = (FP_DESTROYRUNONCENODELIST)GetProcAddress(
                                           ghDeviceInstallerLib,
                                           "pSetupDestroyRunOnceNodeList"))) {
            goto HitFailure;
        }

        //
        // Now configure setupapi for server-side installation
        //
        SetupGlobalFlags = fpGetGlobalFlags();

        //
        // We want to run non-interactive and do RunOnce entries server-side
        //
        SetupGlobalFlags |= (PSPGF_NONINTERACTIVE | PSPGF_SERVER_SIDE_RUNONCE);

        //
        // Make sure we _aren't_ skipping backup--it is essential that we be
        // able to completely back-out of an installation half-way through if
        // we encounter a failure (e.g., an unsigned file).
        //
        SetupGlobalFlags &= ~PSPGF_NO_BACKUP;

        fpSetGlobalFlags(SetupGlobalFlags);

        //
        // If we get to here, we succeeded.
        //
        goto clean0;

    HitFailure:
        //
        // Failed to retrieve some entrypoint.
        //
        Err = GetLastError();

    clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during LoadDeviceInstaller!\n"));
        ASSERT(0);
        Err = ERROR_INVALID_DATA;
    }

    if(Err != NO_ERROR) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: failed to load device installer, error = %d\n",
                   Err));
        FreeLibrary(ghDeviceInstallerLib);
        ghDeviceInstallerLib = NULL;
    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Loaded device installer\n",
                   Err));
    }

    return Err;

} // LoadDeviceInstaller



VOID
UnloadDeviceInstaller(
    VOID
    )
/*++

Routine Description:

    This unloads setupapi.dll if it's presently loaded.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient, pNextDeviceInstallClient;

    //
    // Unload setupapi.dll.
    //
    if(ghDeviceInstallerLib) {

        FreeLibrary(ghDeviceInstallerLib);
        ghDeviceInstallerLib = NULL;

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Unloaded device installer\n"));
    }

    //
    // Close any device install clients that exist.
    //
    LockNotifyList(&InstallClientList.Lock);
    pDeviceInstallClient = InstallClientList.Next;
    while (pDeviceInstallClient) {
        ASSERT(pDeviceInstallClient->RefCount == 1);
        pNextDeviceInstallClient = pDeviceInstallClient->Next;
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        pDeviceInstallClient = pNextDeviceInstallClient;
    }
    UnlockNotifyList(&InstallClientList.Lock);

    return;

} // UnloadDeviceInstaller



DWORD
InstallDeviceServerSide(
    IN     LPWSTR pszDeviceId,
    IN OUT PBOOL  RebootRequired,
    IN OUT PBOOL  DeviceHasProblem,
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine attempts to install the specified device in the context of
    umpnpmgr (i.e., on the server-side of the ConfigMgr interface).

Arguments:

    pszDeviceId - device instance ID of the devnode to be installed.

    RebootRequired - Supplies the address of a boolean variable that will be
        set to TRUE if the (successful) installation of this device requires a
        reboot.  Note, the existing value of this variable is preserved if
        either (a) the installation fails or (b) no reboot was required.
        
    DeviceHasProblem - Supplies the address of a boolean variable that will be
        set to TRUE if the device has a CM_PROB_Xxx code after the drivers
        were installed. Note, this value is only set if the installation 
        succeedes.          

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the id of the session in which the device install
        client UI process was launched.  Otherwise, will contain an invalid
        session id INVALID_SESSION, (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.

Return Value:

    If the device installation was successful, the return value is NO_ERROR.
    Otherwise, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    DWORD Err;
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    LPWSTR pszClassGuid;
    WCHAR szBuffer[MAX_PATH];
    HKEY hKey;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    BOOL b, bDoClientUI = FALSE;
    LPWSTR p;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DRVINFO_DATA DriverInfoData;
    ULONG ulType;
    ULONG ulSize;
    ULONG DeviceIdSize;
    DWORD Capabilities;
    SP_NEWDEVICEWIZARD_DATA NewDevWizData;
    BOOL RemoveNewDevDescValue = FALSE;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData = NULL;
    DWORD DriverInfoDetailDataSize;
    HINF hInf;
    INFCONTEXT InfContext;
    DWORD i, dwWait;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;
    ULONG ulSessionId = INVALID_SESSION;
    ULONG ulTransferLen;
    ULONG ulStatus, ulProblem;

    //
    // Now create a container set for our device information element.
    //
    DeviceInfoSet = fpCreateDeviceInfoList(NULL, NULL);
    if(DeviceInfoSet == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    if(!fpOpenDeviceInfo(DeviceInfoSet, pszDeviceId, NULL, 0, &DeviceInfoData)) {
        goto clean1;
    }

    //
    // OK, it looks like we're going to be able to attempt a server-side
    // install.  Next up is the (potentially time-consuming) driver search.
    // Before we start that, we want to fire up some UI on the client side (if
    // somebody is logged in) letting them know we've found their hardware and
    // are working on installing it.
    //
    // NOTE: We don't fire up client-side UI if the device has the SilentInstall
    // capability.
    //
    ulSize = ulTransferLen = sizeof(Capabilities);
    if ((CR_SUCCESS != PNP_GetDeviceRegProp(NULL,
                                            pszDeviceId,
                                            CM_DRP_CAPABILITIES,
                                            &ulType,
                                            (LPBYTE)&Capabilities,
                                            &ulTransferLen,
                                            &ulSize,
                                            0))
        || !(Capabilities & CM_DEVCAP_SILENTINSTALL)) {
        //
        // Either we couldn't retrieve the capabilities property (shouldn't
        // happen, or we did retrieve it but the silent-install bit wasn't set.
        //
        bDoClientUI = TRUE;

        //
        // If we're not going to determine the session to use for UI, use the
        // SessionId supplied by the caller.
        //
        if ((Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0) {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        //
        // Go ahead and fire up the client-side UI.
        //
        DoDeviceInstallClient(pszDeviceId,
                              &ulSessionId,
                              Flags | DEVICE_INSTALL_UI_ONLY | DEVICE_INSTALL_PLAY_SOUND,
                              &pDeviceInstallClient);
    }

    //
    // Do a default driver search for this device.
    //
    if(!fpBuildDriverInfoList(DeviceInfoSet, &DeviceInfoData, SPDIT_COMPATDRIVER)) {
        goto clean1;
    }

    //
    // Select the best driver from the list we just built.
    //
    if(!fpCallClassInstaller(DIF_SELECTBESTCOMPATDRV, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    b = fpGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    //
    // NOTE: the multi-port serial class has some buggy co-installers that
    // always popup UI, without using the finish-install wizard page mechanism,
    // and without regard to the DI_QUIETINSTALL flag.  Until they clean up
    // their act, we must disallow server-side installation of those devices
    // as well.
    //
    if(GuidEqual(&GUID_DEVCLASS_MULTIPORTSERIAL, &(DeviceInfoData.ClassGuid))) {
        Err = ERROR_DI_DONT_INSTALL;
        goto clean0;
    }

    //
    // Kludge to allow INFs to force client-side (i.e., interactive)
    // installation for certain devices.  They do this by referencing a
    // hardware or compatible ID in an "InteractiveInstall" entry in the INF's
    // [ControlFlags] section.  The format of one of these lines is:
    //
    //     InteractiveInstall = <ID1> [, <ID2>... ]
    //
    // and there may be any number of these lines.
    //

    //
    // First, retrieve the driver info detail data (this contains the hardware
    // ID and any compatible IDs specified by this INF driver entry).
    //
    b = fpGetDriverInfoDetail(DeviceInfoSet,
                              &DeviceInfoData,
                              &DriverInfoData,
                              NULL,
                              0,
                              &DriverInfoDetailDataSize
                             );
    Err = GetLastError();

    //
    // The above call to get driver info detail data should never succeed
    // because the buffer will alwyas be too small (we're just interested in
    // sizing the buffer at this point).
    //
    ASSERT(!b && (Err == ERROR_INSUFFICIENT_BUFFER));

    if(b || (Err != ERROR_INSUFFICIENT_BUFFER)) {
        Err = ERROR_INVALID_DATA;
        goto clean0;
    }

    //
    // Now that we know how big of a buffer we need to hold the driver info
    // details, allocate the buffer and retrieve the information.
    //
    pDriverInfoDetailData = HeapAlloc(ghPnPHeap, 0, DriverInfoDetailDataSize);

    if(!pDriverInfoDetailData) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if(!fpGetDriverInfoDetail(DeviceInfoSet,
                              &DeviceInfoData,
                              &DriverInfoData,
                              pDriverInfoDetailData,
                              DriverInfoDetailDataSize,
                              NULL)) {
        Err = GetLastError();
        ASSERT(FALSE);          // we should never fail this call.
        goto clean0;
    }

    //
    // OK, we have all the hardware and compatible IDs for this driver node.
    // Now we need to open up the INF and see if any of them are referenced in
    // an "InteractiveInstall" control flag entry.
    //
    hInf = fpOpenInfFile(pDriverInfoDetailData->InfFileName,
                         NULL,
                         INF_STYLE_WIN4,
                         NULL
                        );
    if(hInf == INVALID_HANDLE_VALUE) {
        //
        // For some reason, we couldn't open the INF!
        //
        goto clean1;
    }

    b = FALSE;

    //
    // Look at each InteractiveInstall line in the INF's [ControlFlags]
    // section...
    //
    if(fpFindFirstLine(hInf, pszControlFlags, pszInteractiveInstall, &InfContext)) {

        do {
            //
            // and within each line, examine each value...
            //
            for(i = 1;
                fpGetStringField(&InfContext, i, szBuffer, sizeof(szBuffer) / sizeof(WCHAR), NULL);
                i++) {

                //
                // Check to see if this ID matches up with one of the driver
                // node's hardware or compatible IDs.
                //
                for(p = pDriverInfoDetailData->HardwareID; *p; p += (lstrlen(p) + 1)) {

                    if(!lstrcmpi(p, szBuffer)) {
                        //
                        // We found a match!  We must defer the installation to
                        // the client-side.
                        //
                        b = TRUE;
                        goto InteractiveInstallSearchDone;
                    }
                }
            }

        } while(fpFindNextMatchLine(&InfContext, pszInteractiveInstall, &InfContext));
    }

InteractiveInstallSearchDone:

    //
    // We're done with the INF--close it.
    //
    fpCloseInfFile(hInf);

    if(b) {
        Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
        goto clean0;
    }

    //
    // Check to see if it's OK to install this driver.
    //
    if(!fpCallClassInstaller(DIF_ALLOW_INSTALL, DeviceInfoSet, &DeviceInfoData) &&
       ((Err = GetLastError()) != ERROR_DI_DO_DEFAULT)) {

        goto clean0;
    }

    //
    // Tell our client-side UI (if any) it's time to update the device's
    // description and class icon.
    //
    if (pDeviceInstallClient) {
        //
        // Retrieve the device description from the driver node we're about to
        // install.  We don't want to write this out as the devnode's DeviceDesc
        // property, because some class installers have dependencies upon being
        // able to retrieve the unaltered description as reported by the
        // enumerator.  So instead, we write this out as the REG_SZ
        // NewDeviceDesc value entry to the devnode's hardware key.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        b = fpGetSelectedDriver(DeviceInfoSet, &DeviceInfoData, &DriverInfoData);
        ASSERT(b);  // the above call shouldn't fail

        if(b) {
            //
            // Make sure that the hardware key is created (with the right
            // security).
            //
            PNP_CreateKey(NULL,
                          pszDeviceId,
                          KEY_READ,
                          0
                         );

            //
            // Now, open the Device Parameters subkey so we can write out the
            // device's new description.
            //
            wsprintf(szBuffer, TEXT("%s\\%s"), pszDeviceId, pszRegKeyDeviceParam);

            if(ERROR_SUCCESS == RegOpenKeyEx(ghEnumKey,
                                             szBuffer,
                                             0,
                                             KEY_READ | KEY_WRITE,
                                             &hKey)) {

                if(ERROR_SUCCESS == RegSetValueEx(
                                        hKey,
                                        pszRegValueNewDeviceDesc,
                                        0,
                                        REG_SZ,
                                        (LPBYTE)(DriverInfoData.Description),
                                        (lstrlen(DriverInfoData.Description) + 1) * sizeof(WCHAR))) {

                    RemoveNewDevDescValue = TRUE;
                }

                RegCloseKey(hKey);
            }
        }

        //
        // Wait for the device install to be signaled from newdev.dll to let us
        // know that it has completed displaying the UI request.
        //
        // Wait on the client's process as well, to catch the case
        // where the process crashes (or goes away) without signaling the
        // device install event.
        //
        // Also wait on the disconnect event in case we have explicitly
        // disconnected from the client while switching sessions.
        //
        // We don't want to wait forever in case NEWDEV.DLL hangs for some
        // reason.  So we will give it 5 seconds to complete the UI only
        // install and then continue on without it.
        //
        // Note that the client is still referenced for our use, and should be
        // dereferenced when we're done with it.
        //
        hFinishEvents[0] = pDeviceInstallClient->hProcess;
        hFinishEvents[1] = pDeviceInstallClient->hEvent;
        hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

        dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, 5000);

        if (dwWait == WAIT_OBJECT_0) {
            //
            // If the return is WAIT_OBJECT_0 then the newdev.dll process has
            // gone away.  Close the device install client and clean up all of
            // the associated handles.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: process signalled, closing device install client!\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
            //
            // If the return is WAIT_OBJECT_0 + 1 then the device installer
            // successfully received the request.  This is the only case where
            // we don't want to close the client, since we may want to reuse it
            // later.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client succeeded\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
            //
            // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
            // disconnected from the device install client.  For server-side
            // installation, we don't need to keep the client UI around on the
            // disconnected session, so we should close it here also.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client disconnected\n"));

        } else if (dwWait == WAIT_TIMEOUT) {
            //
            // Timed out while waiting for the device install client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: InstallDeviceServerSide: timed out waiting for device install client!\n"));

        } else {
            //
            // The wait was satisfied for some reason other than the
            // specified objects.  This should never happen, but just in
            // case, we'll close the client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: InstallDeviceServerSide: wait completed unexpectedly!\n"));
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (dwWait != (WAIT_OBJECT_0 + 1)) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
            ulSessionId = INVALID_SESSION;
        }
        pDeviceInstallClient = NULL;

        UnlockNotifyList(&InstallClientList.Lock);
    }

    //
    // If we're doing client side UI for this device, attempt to refresh the UI again.
    //
    if (bDoClientUI) {
        //
        // When we attempt to refresh the client-side UI, if we display the
        // refreshed UI on a different session than the one we had previously,
        // close the previous device install client.
        //
        ULONG ulPrevSessionId = ulSessionId;

        //
        // If we're not going to determine the session to use for UI, use the
        // SessionId supplied by the caller.
        //
        if ((Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0) {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        DoDeviceInstallClient(pszDeviceId,
                              &ulSessionId,
                              Flags | DEVICE_INSTALL_UI_ONLY,
                              &pDeviceInstallClient);

        if ((ulPrevSessionId != INVALID_SESSION) &&
            (ulPrevSessionId != ulSessionId)) {
            PINSTALL_CLIENT_ENTRY pPrevDeviceInstallClient;
            LockNotifyList(&InstallClientList.Lock);
            pPrevDeviceInstallClient = LocateDeviceInstallClient(ulPrevSessionId);
            if (pPrevDeviceInstallClient) {
                ASSERT(pPrevDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pPrevDeviceInstallClient);
            }
            UnlockNotifyList(&InstallClientList.Lock);
        }
    }

    //
    // OK, everything looks good for installing this driver.  Check to see if
    // this INF's class is already installed--if not, then we need to install
    // it before proceeding.
    //
    if(RPC_S_OK != UuidToString(&(DeviceInfoData.ClassGuid), &pszClassGuid)) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    wsprintf(szBuffer, TEXT("{%s}"), pszClassGuid);
    RpcStringFree(&pszClassGuid);

    if(ERROR_SUCCESS != RegOpenKeyEx(ghClassKey,
                                     szBuffer,
                                     0,
                                     KEY_READ,
                                     &hKey)) {

        if(!fpInstallClass(NULL,
                           pDriverInfoDetailData->InfFileName,
                           0,
                           NULL)) {

            goto clean1;
        }

    } else {
        //
        // The class key already exists--assume that the class has previously
        // been installed.
        //
        RegCloseKey(hKey);
    }

    //
    // Now we're ready to install the device.  First, install the files.
    //
    if(!fpCallClassInstaller(DIF_INSTALLDEVICEFILES, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    //
    // Set a flag in the device install parameters so that we don't try to
    // re-copy the files during subsequent DIF operations.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    b = fpGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    DeviceInstallParams.Flags |= DI_NOFILECOPY;

    b = fpSetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(!b) {
        goto clean1;
    }

    //
    // Now finish up the installation.
    //
    if(!fpCallClassInstaller(DIF_REGISTER_COINSTALLERS, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    if(!fpCallClassInstaller(DIF_INSTALLINTERFACES, DeviceInfoSet, &DeviceInfoData)) {
        goto clean1;
    }

    if(!fpCallClassInstaller(DIF_INSTALLDEVICE, DeviceInfoSet, &DeviceInfoData)) {

        ULONG ulConfig;

        //
        // Before we do anything to blow away last error, retrieve it.
        //
        Err = GetLastError();

        //
        // It's possible that the installation got far enough to have cleared
        // any problems on the device (i.e., SetupDiInstallDevice succeeded,
        // but the class installer or co-installer subsequently failed during
        // some post-processing).
        //
        // We want to make sure that the devnode is marked as needing re-install
        // because we might lose the client-side install request (e.g., the
        // user reboots without logging in).
        //
        ulConfig = GetDeviceConfigFlags(pszDeviceId, NULL);

        ulConfig |= CONFIGFLAG_REINSTALL;

        PNP_SetDeviceRegProp(NULL,
                             pszDeviceId,
                             CM_DRP_CONFIGFLAGS,
                             REG_DWORD,
                             (LPBYTE)&ulConfig,
                             sizeof(ulConfig),
                             0
                            );

        goto clean0;
    }

    //
    // We're not quite out of the woods yet.  We need to check if the class-/
    // co-installers want to display finish-install wizard pages.  If so, then
    // we need to set the CONFIGFLAG_REINSTALL flag for this devnode and report
    // failure so that we'll re-attempt the install as a client-side
    // installation (where a wizard can actually be displayed).
    //
    ZeroMemory(&NewDevWizData, sizeof(NewDevWizData));

    NewDevWizData.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    NewDevWizData.ClassInstallHeader.InstallFunction = DIF_NEWDEVICEWIZARD_FINISHINSTALL;

    b = fpSetClassInstallParams(DeviceInfoSet,
                                &DeviceInfoData,
                                (PSP_CLASSINSTALL_HEADER)&NewDevWizData,
                                sizeof(NewDevWizData)
                               );
    ASSERT(b);  // the above call shouldn't fail

    if(b) {
        b = fpCallClassInstaller(DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                 DeviceInfoSet,
                                 &DeviceInfoData
                                );

        if(b || (ERROR_DI_DO_DEFAULT == GetLastError())) {
            //
            // Retrieve the install params
            //
            b = (fpGetClassInstallParams(DeviceInfoSet,
                                         &DeviceInfoData,
                                         (PSP_CLASSINSTALL_HEADER)&NewDevWizData,
                                         sizeof(NewDevWizData),
                                         NULL)
                 && (NewDevWizData.ClassInstallHeader.InstallFunction == DIF_NEWDEVICEWIZARD_FINISHINSTALL)
                );

            if(b) {
                //
                // Are there any pages?
                //
                if(!NewDevWizData.NumDynamicPages) {
                    b = FALSE;
                } else {
                    //
                    // b is already TRUE if we made it here so no need to set
                    //
                    HMODULE hComCtl32;
                    FP_DESTROYPROPERTYSHEETPAGE fpDestroyPropertySheetPage;

                    //
                    // We don't want to link to comctl32, nor do we want to
                    // always explicitly load it every time we load the device
                    // installer.  (The number of devices that request finish-
                    // install pages should be small.)  Thus, we load it on-
                    // demand right here, retrieve the entrypoint to the
                    // DestroyPropertySheetPage routine, and then unload the
                    // DLL once we've destroyed all the property pages.
                    //
                    // NOTE: (lonnym): If we can't load comctl32 or get the
                    // entrypont for DestroyPropertySheetPage, then we'll leak
                    // these wizard pages!
                    //
                    hComCtl32 = LoadLibrary(TEXT("comctl32.dll"));

                    if(hComCtl32) {

                        fpDestroyPropertySheetPage = (FP_DESTROYPROPERTYSHEETPAGE)GetProcAddress(
                                                         hComCtl32,
                                                         "DestroyPropertySheetPage"
                                                        );

                        if(fpDestroyPropertySheetPage) {

                            for(i = 0; i < NewDevWizData.NumDynamicPages; i++) {
                                fpDestroyPropertySheetPage(NewDevWizData.DynamicPages[i]);
                            }
                        }

                        FreeLibrary(hComCtl32);
                    }
                }
            }
        }
    }

    if(b) {

        ULONG ulConfig;
        CONFIGRET cr;

        //
        // One or more finish-install wizard pages were provided--we must defer
        // this installation to the client-side.
        //
        ulConfig = GetDeviceConfigFlags(pszDeviceId, NULL);

        ulConfig |= CONFIGFLAG_REINSTALL;

        cr = PNP_SetDeviceRegProp(NULL,
                                  pszDeviceId,
                                  CM_DRP_CONFIGFLAGS,
                                  REG_DWORD,
                                  (LPBYTE)&ulConfig,
                                  sizeof(ulConfig),
                                  0
                                 );
        ASSERT(cr == CR_SUCCESS);

        Err = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
        goto clean0;
    }

    //
    // The installation was a success!  Check to see if a reboot is needed.
    //
    b = fpGetDeviceInstallParams(DeviceInfoSet, &DeviceInfoData, &DeviceInstallParams);
    ASSERT(b);  // the above call shouldn't fail
    if(b) {
        if(DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            *RebootRequired = TRUE;
        }
    }

    //
    // Process any RunOnce (RunDll32) entries that may have been queued up
    // during this installation.
    //
    DoRunOnce();

    //
    // Check to see if the device has a problem.
    //
    if ((GetDeviceStatus(pszDeviceId, &ulStatus, &ulProblem) != CR_SUCCESS) ||
        (ulStatus & DN_HAS_PROBLEM)) {
        *DeviceHasProblem = TRUE;
    } else {
        *DeviceHasProblem = FALSE;
    }

    Err = NO_ERROR;
    goto clean0;

clean1:
    //
    // Failures where error is in GetLastError() can come here.
    //
    Err = GetLastError();

clean0:
    fpDestroyDeviceInfoList(DeviceInfoSet);

    if(pDriverInfoDetailData) {
        HeapFree(ghPnPHeap, 0, pDriverInfoDetailData);
    }

    //
    // Clear out our list of RunOnce work items (note that the list will
    // already be empty if the device install succeeded and we called
    // DoRunOnce() above).
    //
    fpDestroyRunOnceNodeList();

    //
    // If we stored out a NewDeviceDesc value to the devnode's hardware key
    // above, go and remove that turd now.
    //
    if(RemoveNewDevDescValue) {
        //
        // Open the Device Parameters subkey so we can delete the value.
        //
        wsprintf(szBuffer, TEXT("%s\\%s"), pszDeviceId, pszRegKeyDeviceParam);

        if(ERROR_SUCCESS == RegOpenKeyEx(ghEnumKey,
                                         szBuffer,
                                         0,
                                         KEY_READ | KEY_WRITE,
                                         &hKey)) {

            RegDeleteValue(hKey, pszRegValueNewDeviceDesc);
            RegCloseKey(hKey);
        }
    }

    if (pDeviceInstallClient) {
        //
        // Wait for the device install to be signaled from newdev.dll to let us
        // know that it has completed displaying the UI request.
        //
        // Wait on the client's process as well, to catch the case
        // where the process crashes (or goes away) without signaling the
        // device install event.
        //
        // Also wait on the disconnect event in case we have explicitly
        // disconnected from the client while switching sessions.
        //
        // We don't want to wait forever in case NEWDEV.DLL hangs for some
        // reason.  So we will give it 5 seconds to complete the UI only
        // install and then continue on without it.
        //
        // Note that the client is still referenced for our use, and should be
        // dereferenced when we're done with it.
        //
        hFinishEvents[0] = pDeviceInstallClient->hProcess;
        hFinishEvents[1] = pDeviceInstallClient->hEvent;
        hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

        dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, 5000);

        if (dwWait == WAIT_OBJECT_0) {
            //
            // If the return is WAIT_OBJECT_0 then the newdev.dll process has
            // gone away.  Close the device install client and clean up all of
            // the associated handles.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: process signalled, closing device install client!\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
            //
            // If the return is WAIT_OBJECT_0 + 1 then the device installer
            // successfully received the request.  This is the only case where
            // we don't want to close the client, since we may want to reuse it
            // later.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client succeeded\n"));

        } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
            //
            // If the return is WAIT_OBJECT_0 + 2 then we were explicitly
            // disconnected from the device install client.  For server-side
            // installation, we don't need to keep the client UI around on the
            // disconnected session, so we should close it here also.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: InstallDeviceServerSide: device install client disconnected\n"));

        } else if (dwWait == WAIT_TIMEOUT) {
            //
            // Timed out while waiting for the device install client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: InstallDeviceServerSide: timed out waiting for device install client!\n"));

        } else {
            //
            // The wait was satisfied for some reason other than the
            // specified objects.  This should never happen, but just in
            // case, we'll close the client.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: InstallDeviceServerSide: wait completed unexpectedly!\n"));
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (dwWait != (WAIT_OBJECT_0 + 1)) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
            ulSessionId = INVALID_SESSION;
        }
        pDeviceInstallClient = NULL;

        UnlockNotifyList(&InstallClientList.Lock);
    }

    if (bDoClientUI) {
        //
        // Note that if client-side UI was created during the server-side device
        // install, it will still exist when we are done.  The caller should
        // dereference it when it is done installing all devices to make it go
        // away.
        //
        *SessionId = ulSessionId;
    } else {
        //
        // There was never any client-side UI for this device install.
        //
        *SessionId = INVALID_SESSION;
    }

    return Err;

} // InstallDeviceServerSide



BOOL
PromptUser(
    IN OUT PULONG SessionId,
    IN     ULONG  Flags
    )
/*++

Routine Description:

    This routine will notify the logged-on user (if any) with a specified
    message.

Arguments:

    SessionId - Supplies the address of a variable containing the SessionId on
        which the device install client is to be displayed.  If successful, the
        SessionId will contain the id of the session in which the reboot dialog
        process was launched.  Otherwise, will contain an invalid session id,
        INVALID_SESSION, (0xFFFFFFFF).

    Flags - Specifies flags describing the behavior of the reboot dialog
        displayed by the device install client.
        The following flags are currently defined:

        DEVICE_INSTALL_FINISHED_REBOOT - if specified, the user should be
           prompted to reboot.

        DEVICE_INSTALL_BATCH_COMPLETE - if specified, the user should be
           prompted that the plug and play manager is finished installing a
           batch of devices.

        DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value in the
           SessionId variable will be ignored, and the device installclient will
           always be displayed on the current active console session.

Return Value:

    If the user is successfully notified, the return value is TRUE.

    If we couldn't ask the user (i.e., no user was logged in), the return
    value is FALSE.

Notes:

    If the user was prompted for a reboot, this doesn't necessarily mean that a
    reboot is in progress.

--*/
{
    BOOL bStatus = FALSE;
    ULONG ulValue, ulSize, ulSessionId;
    HANDLE hFinishEvents[3] = { NULL, NULL, NULL };
    DWORD dwWait;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;

    try {
        //
        // Check if we should skip client side UI.
        //
        if (gbSuppressUI) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_WARNINGS,
                       "UMPNPMGR: PromptUser: Client-side UI has been suppressed, exiting.\n"));
            LogWarningEvent(WRN_REBOOT_UI_SUPPRESSED, 0, NULL);
            *SessionId = INVALID_SESSION;
            return FALSE;
        }

        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        ASSERT(ulSessionId != INVALID_SESSION);

        //
        // If the specified session is not currently connected anywhere, don't
        // bother creating any UI.
        //
        if (!IsSessionConnected(ulSessionId)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: PromptUser: SessionId %d not connected, exiting\n",
                       ulSessionId));
            return FALSE;
        }

        //
        // If a device install client is already running on this session,
        // connect to it.  Otherwise, create a new one.
        //
        LockNotifyList(&InstallClientList.Lock);

        //
        // First, try to connect to an existing client already running on this
        // session.
        //
        bStatus = ConnectDeviceInstallClient(ulSessionId,
                                             &pDeviceInstallClient);

        if (bStatus) {
            if ((Flags & DEVICE_INSTALL_BATCH_COMPLETE) &&
                (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_BATCH_COMPLETE)) {
                //
                // If there is an existing client, and we're sending it the
                // "we're done" message, and the last thing this client did was
                // display that message, don't bother sending it again.
                //
                pDeviceInstallClient = NULL;
                bStatus = FALSE;
            }
        } else if (!(Flags & DEVICE_INSTALL_BATCH_COMPLETE)) {
            //
            // If there isn't an existing client for this session, and we're not
            // launching one just to say "we're done", then go ahead and create
            // a new device install client for this session.
            //
            bStatus = CreateDeviceInstallClient(ulSessionId,
                                                &pDeviceInstallClient);
        }

        if (bStatus) {
            //
            // Whether we are using an existing client, or created a
            // new one, the client should only have the initial
            // reference from when it was added to the list, since any
            // use of the client is done on this single install
            // thread.
            //
            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->RefCount == 1);

            //
            // Reference the device install client while it is in use.
            // We'll remove this reference when we're done with it.
            //
            ReferenceDeviceInstallClient(pDeviceInstallClient);
        }

        UnlockNotifyList(&InstallClientList.Lock);

        if (!bStatus) {
            *SessionId = INVALID_SESSION;
            return FALSE;
        }

        ASSERT(pDeviceInstallClient);

        //
        // Don't send newdev the display on console flag, if it was specified.
        //
        ulValue = Flags & ~DEVICE_INSTALL_DISPLAY_ON_CONSOLE;

        //
        // Send newdev.dll the specified signal.
        //
        if (WriteFile(pDeviceInstallClient->hPipe,
                      &ulValue,
                      sizeof(ulValue),
                      &ulSize,
                      NULL
                      )) {

            //
            // newdev.dll expects two DWORDs to be sent over the pipe each time.  The second
            // DWORD should just be set to 0 in this case.
            //
            ulValue = 0;
            if (WriteFile(pDeviceInstallClient->hPipe,
                          &ulValue,
                          sizeof(ulValue),
                          &ulSize,
                          NULL
                          )) {
                bStatus = TRUE;
            } else {
                bStatus = FALSE;
                LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            }

        } else {
            bStatus = FALSE;
            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
        }

        if (bStatus) {

            bStatus = FALSE;

            //
            // Wait for the event to be signaled from newdev.dll
            // to let us know that it has received the information.
            //
            // Wait on the process as well, to catch the case where the process
            // crashes (or goes away) without signaling the event.
            //
            // Also wait on the disconnect event in case we have just
            // disconnected from the device install client, in which case the
            // event and process handles are no longer valid.
            //
            hFinishEvents[0] = pDeviceInstallClient->hProcess;
            hFinishEvents[1] = pDeviceInstallClient->hEvent;
            hFinishEvents[2] = pDeviceInstallClient->hDisconnectEvent;

            dwWait = WaitForMultipleObjects(3, hFinishEvents, FALSE, INFINITE);

            if (dwWait == WAIT_OBJECT_0) {
                //
                // If the return is WAIT_OBJECT_0 then the newdev.dll
                // process has gone away.  Consider the request unsuccessful
                // so that we will retry again at a later time.  Orphan the
                // device install client and clean up all of the associated
                // handles.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: process signalled, orphaning device install client!\n"));

            } else if (dwWait == (WAIT_OBJECT_0 + 1)) {
                //
                // If the return is WAIT_OBJECT_0 + 1 then the request was
                // received successfully.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: device install client succeeded\n"));

                //
                // Remember the last request serviced by this client.
                //
                pDeviceInstallClient->ulInstallFlags = Flags;

                bStatus = TRUE;

            } else if (dwWait == (WAIT_OBJECT_0 + 2)) {
                //
                // If the return is WAIT_OBJECT_0 + 2 then the device
                // install client was explicitly disconnected before
                // the request was received.  Consider the request
                // unsuccessful so that we will retry again at a later
                // time.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT,
                           "UMPNPMGR: PromptUser: device install client orphaned!\n"));
            }
        }

        LockNotifyList(&InstallClientList.Lock);

        //
        // Remove the reference placed on the client while it was in use.
        //
        DereferenceDeviceInstallClient(pDeviceInstallClient);
        if (!bStatus) {
            //
            // Unless the client signalled successful receipt of the
            // request, we probably won't be able to use this client
            // anymore.  Remove the initial reference so all
            // associated handles will be closed and the entry will be
            // freed when it is no longer in use.
            //

            //
            // Note that if we were unsuccessful because of a
            // logoff, we would have already dereferenced the
            // client then, in which case the above dereference
            // was the final one, and pDeviceInstallClient would
            // be invalid.  Instead, attempt to re-locate the
            // client by the session id.
            //
            pDeviceInstallClient = LocateDeviceInstallClient(ulSessionId);
            if (pDeviceInstallClient) {
                ASSERT(pDeviceInstallClient->RefCount == 1);
                DereferenceDeviceInstallClient(pDeviceInstallClient);
            }
        }
        UnlockNotifyList(&InstallClientList.Lock);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during PromptUser!\n"));
        ASSERT(0);
        bStatus = FALSE;
    }

    if (!bStatus) {
        *SessionId = INVALID_SESSION;
    } else {
        *SessionId = ulSessionId;
    }

    return bStatus;

} // PromptUser



BOOL
CreateDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    This routine kicks off a newdev.dll process (if someone is logged in).
    We use a named pipe to comunicate with the user mode process
    and have it either display UI for a server side install, or do the install
    itself on the client side.

Arguments:

    SessionId           - Session for which a device install client should be
                          created or connected to.

    DeviceInstallClient - Receives a pointer to receive a pointer to the
                          device install client for this session.

Return Value:

    Returns TRUE if a device install client was created, or if an existing
    device install client was found for the specified session.  This routine
    doesn't wait until the process terminates.  Returns FALSE if a device
    install client could not be created.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    WCHAR szCmdLine[MAX_PATH];
    WCHAR szDeviceInstallPipeName[MAX_PATH];
    WCHAR szDeviceInstallEventName[MAX_PATH];
    ULONG ulDeviceInstallEventNameSize;
    HANDLE hFinishEvents[2] = { NULL, NULL };
    HANDLE hTemp, hUserToken = NULL;
    PINSTALL_CLIENT_ENTRY entry;
    RPC_STATUS rpcStatus = RPC_S_OK;
    GUID  newGuid;
    WCHAR szGuidString[MAX_GUID_STRING_LEN];
    HANDLE hDeviceInstallPipe = NULL, hDeviceInstallEvent = NULL;
    HANDLE hDeviceInstallDisconnectEvent = NULL;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;
    SECURITY_ATTRIBUTES sa;
    ULONG ulSize;
    WIN32_FIND_DATA findData;
    BOOL bStatus;
    PVOID lpEnvironment = NULL;
    OVERLAPPED overlapped = {0,0,0,0,0};
    DWORD dwError, dwWait, dwBytes;


    //
    // Validate output parameter.
    //
    ASSERT(DeviceInstallClient);
    if (!DeviceInstallClient) {
        return FALSE;
    }

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: CreateDeviceInstallClient: Invalid Console SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Assume failure
    //
    bStatus = FALSE;

    try {
        //
        // Before doing anything, check that newdev.dll is actually present on
        // the system.
        //
        szCmdLine[0] = L'\0';
        ulSize = GetSystemDirectory(szCmdLine, MAX_PATH);
        if ((ulSize == 0) || ((ulSize + 2 + ARRAY_SIZE(NEWDEV_DLL)) > MAX_PATH)) {
            return FALSE;
        }
        lstrcat(szCmdLine, TEXT("\\"));
        lstrcat(szCmdLine, NEWDEV_DLL);

        hTemp = FindFirstFile(szCmdLine, &findData);
        if(hTemp != INVALID_HANDLE_VALUE) {
            FindClose(hTemp);
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: %ws not found, error = %d, exiting\n",
                       szCmdLine,
                       GetLastError()));
            LogWarningEvent(WRN_NEWDEV_NOT_PRESENT, 1, szCmdLine);
            return FALSE;
        }

        //
        // Get the user access token for the active console session user.
        //
        if (!GetSessionUserToken(SessionId, &hUserToken) || (hUserToken == NULL)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: CreateDeviceInstallClient: Unable to get user token for Session %d,\n"
                       "          postponing client-side installation, error = %d\n",
                       SessionId,
                       GetLastError()));
            return FALSE;
        }

        //
        // If the user Winstation for this session is locked, and Fast User
        // Switching is enabled, then we're at the welcome screen.  Don't create
        // a device install client, because we don't want to hang the install
        // thread if nobody's actually around to do anything about it.  If the
        // session is locked, but FUS is not disabled, maintain previous
        // behavior, and launch the device install client.  The user will have
        // to unlock or logoff before another user can logon anyways.
        //
        if (IsSessionLocked(SessionId) && IsFastUserSwitchingEnabled()) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL,
                       "UMPNPMGR: CreateDeviceInstallClient: Session %d locked with FUS enabled,\n"
                       "          postponing client-side installation.\n",
                       SessionId));
            CloseHandle(hUserToken);
            return FALSE;
        }

        //
        // Create a named pipe and event for communication and synchronization
        // with the client-side device installer.  The event and named pipe must
        // be global so that UMPNPMGR can interact with a device install client
        // in a different session, but it must still be unique for that session.
        // Add a generated GUID so the names are not entirely well-known.
        //
        rpcStatus = UuidCreate(&newGuid);

        if ((rpcStatus != RPC_S_OK) &&
            (rpcStatus != RPC_S_UUID_LOCAL_ONLY)) {
            goto Clean0;
        }

        if (StringFromGuid((LPGUID)&newGuid,
                           szGuidString,
                           MAX_GUID_STRING_LEN) != NO_ERROR) {
            goto Clean0;
        }

        wsprintf(szDeviceInstallPipeName,
                 TEXT("%ws_%d.%ws"),
                 PNP_DEVICE_INSTALL_PIPE,
                 SessionId,
                 szGuidString);

        wsprintf(szDeviceInstallEventName,
                 TEXT("Global\\%ws_%d.%ws"),
                 PNP_DEVICE_INSTALL_EVENT,
                 SessionId,
                 szGuidString);

        ulDeviceInstallEventNameSize = (lstrlen(szDeviceInstallEventName) + 1) * sizeof(WCHAR);

        //
        // Initialize process, startup and overlapped structures, since we
        // depend on them being NULL during cleanup here on out.
        //
        memset(&ProcessInfo, 0, sizeof(ProcessInfo));
        memset(&StartupInfo, 0, sizeof(StartupInfo));
        memset(&overlapped,  0, sizeof(overlapped));

        //
        // The approximate size of the named pipe output buffer should be large
        // enough to hold the greater of either:
        // - The name and size of the named event string, OR
        // - The install flags, name and device instance id size for at least
        //   one device install.
        //
        ulSize = max(sizeof(ulDeviceInstallEventNameSize) +
                     ulDeviceInstallEventNameSize,
                     2 * sizeof(ULONG) +
                     (MAX_DEVICE_ID_LEN * sizeof(WCHAR)));

        //
        // Open up a named pipe to communicate with newdev.dll to display
        // the device install Ui.  Note that if creating the pipe fails we will just
        // continue the device install with no Ui.
        //
        hDeviceInstallPipe = CreateNamedPipe(szDeviceInstallPipeName,
                                             PIPE_ACCESS_OUTBOUND | // outbound data only
                                             FILE_FLAG_OVERLAPPED | // use overlapped structure
                                             FILE_FLAG_FIRST_PIPE_INSTANCE, // make sure we are the creator of the pipe
                                             PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
                                             1,                 // only one instance is allowed, and we are its creator
                                             ulSize,            // out buffer size
                                             0,                 // in buffer size
                                             PNP_PIPE_TIMEOUT,  // default timeout
                                             NULL               // default security
                                             );
        if (hDeviceInstallPipe == INVALID_HANDLE_VALUE) {
            hDeviceInstallPipe = NULL;
            goto Clean0;
        }

        //
        // Create an event that a user-client can synchronize with and set, and
        // that we will block on after we send a device install to newdev.dll.
        //
        if (CreateUserSynchEvent(szDeviceInstallEventName,
                                 &hDeviceInstallEvent) != NO_ERROR) {
            goto Clean0;
        }

        //
        // Create an event that we can use internally such that waiters can know
        // when to disconnect from the device install client.
        //
        hDeviceInstallDisconnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (!hDeviceInstallDisconnectEvent) {
            goto Clean0;
        }

        //
        // Launch newdev.dll using rundll32.exe, passing it the pipe name.
        // "rundll32.exe newdev.dll,ClientSideInstall <device-install-pipe-name>"
        //
        if (ARRAY_SIZE(szCmdLine) < (ARRAY_SIZE(RUNDLL32_EXE)   +
                                     1 +   // ' '
                                     ARRAY_SIZE(NEWDEV_DLL)     +
                                     1 +   // ','
                                     lstrlen(TEXT("ClientSideInstall")) +
                                     1 +   // ' '
                                     lstrlen(szDeviceInstallPipeName) +
                                     1)) { // '\0'
            goto Clean0;
        }

        wsprintf(szCmdLine,
                 TEXT("%ws %ws,%ws %ws"),
                 RUNDLL32_EXE, NEWDEV_DLL,
                 TEXT("ClientSideInstall"),
                 szDeviceInstallPipeName);

#if DBG
        //
        // Retrieve debugger settings from the service key.
        //
        {
            HKEY hKey;

            if (RegOpenKeyEx(ghServicesKey,
                             pszRegKeyPlugPlayServiceParams,
                             0,
                             KEY_READ,
                             &hKey) == ERROR_SUCCESS) {

                ULONG ulValue = 0;
                WCHAR szDebugCmdLine[MAX_PATH];

                ulSize = sizeof(ulValue);

                if ((RegQueryValueEx(hKey,
                                     pszRegValueDebugInstall,
                                     NULL,
                                     NULL,
                                     (LPBYTE)&ulValue,
                                     &ulSize) == ERROR_SUCCESS) &&(ulValue == 1)) {

                    ulSize = sizeof(szDebugCmdLine);
                    if (RegQueryValueEx(hKey,
                                        pszRegValueDebugInstallCommand,
                                        NULL,
                                        NULL,
                                        (LPBYTE)szDebugCmdLine,
                                        &ulSize) != ERROR_SUCCESS) {
                        //
                        // If no debugger was retrieved, use the default
                        // debugger (ntsd.exe).
                        //
                        lstrcpy(szDebugCmdLine, NTSD_EXE);
                    }

                    lstrcat(szDebugCmdLine, TEXT(" "));
                    lstrcat(szDebugCmdLine, szCmdLine);

                    lstrcpy(szCmdLine, szDebugCmdLine);
                }

                RegCloseKey(hKey);
            }
        }
#endif // DBG

        //
        // Attempt to create the user's environment block.  If for some reason we
        // can't, we'll just have to create the process without it.
        //
        if (!CreateEnvironmentBlock(&lpEnvironment,
                                    hUserToken,
                                    FALSE)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: "
                       "Failed to allocate environment block, error = %d!\n",
                       GetLastError()));
            lpEnvironment = NULL;
        }

        StartupInfo.cb = sizeof(StartupInfo);
        StartupInfo.wShowWindow = SW_SHOW;
        StartupInfo.lpDesktop = DEFAULT_INTERACTIVE_DESKTOP; // WinSta0\Default

        //
        // CreateProcessAsUser will create the process in the session
        // specified by the by user-token.
        //
        if (!CreateProcessAsUser(hUserToken,        // hToken
                                 NULL,              // lpApplicationName
                                 szCmdLine,         // lpCommandLine
                                 NULL,              // lpProcessAttributes
                                 NULL,              // lpThreadAttributes
                                 FALSE,             // bInheritHandles
                                 CREATE_UNICODE_ENVIRONMENT |
                                 DETACHED_PROCESS,  // dwCreationFlags
                                 lpEnvironment,     // lpEnvironment
                                 NULL,              // lpDirectory
                                 &StartupInfo,      // lpStartupInfo
                                 &ProcessInfo       // lpProcessInfo
                                 )) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: CreateDeviceInstallClient: "
                       "Create rundll32 process failed, error = %d\n",
                       GetLastError()));
            goto Clean0;
        }

        ASSERT(ProcessInfo.hProcess);
        ASSERT(ProcessInfo.hThread);

        //
        // Create an event for use with overlapped I/O - no security, manual
        // reset, not signalled, no name.
        //
        overlapped.hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (overlapped.hEvent == NULL) {
            goto Clean0;
        }

        //
        // Connect to the newly created named pipe.  If newdev is not already
        // connected to the named pipe, then ConnectNamedPipe() will fail with
        // ERROR_IO_PENDING, and we will wait on the overlapped event.  If
        // newdev is already connected, it will fail with ERROR_PIPE_CONNECTED.
        // Note however that neither of these is an error condition.
        //
        if (!ConnectNamedPipe(hDeviceInstallPipe, &overlapped)) {
            //
            // Overlapped ConnectNamedPipe should always return FALSE on
            // success.  Check the last error to see what really happened.
            //
            dwError = GetLastError();

            if (dwError == ERROR_IO_PENDING) {
                //
                // I/O is pending, wait up to one minute for the client to
                // connect, also wait on the process in case it terminates
                // unexpectedly.
                //
                hFinishEvents[0] = overlapped.hEvent;
                hFinishEvents[1] = ProcessInfo.hProcess;

                dwWait = WaitForMultipleObjects(2, hFinishEvents,
                                                FALSE,
                                                PNP_PIPE_TIMEOUT); // 60 seconds

                if (dwWait == WAIT_OBJECT_0) {
                    //
                    // The overlapped I/O operation completed.  Check the status
                    // of the operation.
                    //
                    if (!GetOverlappedResult(hDeviceInstallPipe,
                                             &overlapped,
                                             &dwBytes,
                                             FALSE)) {
                        goto Clean0;
                    }

                } else {
                    //
                    // Either the connection timed out, or the client process
                    // exited.  Cancel pending I/O against the pipe, and quit.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_INSTALL | DBGF_ERRORS,
                               "UMPNPMGR: CreateDeviceInstallClient: "
                               "Connect timed out, or client process exited!\n"));
                    CancelIo(hDeviceInstallPipe);
                    goto Clean0;
                }

            } else if (dwError != ERROR_PIPE_CONNECTED) {
                //
                // If the last error indicates anything other than pending I/O,
                // or that The client is already connected to named pipe, fail.
                //
                goto Clean0;
            }

        } else {
            //
            // ConnectNamedPipe should not return anything but FALSE in
            // overlapped mode.
            //
            goto Clean0;
        }

        //
        // The client is now connected to the named pipe.
        // Close the overlapped event.
        //
        CloseHandle(overlapped.hEvent);
        overlapped.hEvent = NULL;

        //
        // The first data in the device install pipe will be the length of
        // the name of the event that will be used to sync up umpnpmgr.dll
        // and newdev.dll.
        //
        if (!WriteFile(hDeviceInstallPipe,
                       &ulDeviceInstallEventNameSize,
                       sizeof(ulDeviceInstallEventNameSize),
                       &ulSize,
                       NULL)) {

            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            goto Clean0;
        }

        //
        // The next data in the device install pipe will be the name of the
        // event that will be used to sync up umpnpmgr.dll and newdev.dll.
        //
        if (!WriteFile(hDeviceInstallPipe,
                       (LPCVOID)szDeviceInstallEventName,
                       ulDeviceInstallEventNameSize,
                       &ulSize,
                       NULL)) {

            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            goto Clean0;
        }

        //
        // Allocate a new device install client entry for the list, and save all
        // the handles with it.
        //
        pDeviceInstallClient = HeapAlloc(ghPnPHeap, 0, sizeof(INSTALL_CLIENT_ENTRY));
        if(!pDeviceInstallClient) {
            goto Clean0;
        }

        pDeviceInstallClient->Next = NULL;
        pDeviceInstallClient->RefCount = 1;
        pDeviceInstallClient->ulSessionId = SessionId;
        pDeviceInstallClient->hEvent = hDeviceInstallEvent;
        pDeviceInstallClient->hPipe = hDeviceInstallPipe;
        pDeviceInstallClient->hProcess = ProcessInfo.hProcess;
        pDeviceInstallClient->hDisconnectEvent = hDeviceInstallDisconnectEvent;
        pDeviceInstallClient->ulInstallFlags = 0;
        pDeviceInstallClient->LastDeviceId[0] = L'\0';

        //
        // Insert the newly created device install client info to our list.
        // The caller must have previously acquired the InstallClientList lock.
        //
        entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
        if (!entry) {
            InstallClientList.Next = pDeviceInstallClient;
        } else {
            while ((PINSTALL_CLIENT_ENTRY)entry->Next) {
                entry = (PINSTALL_CLIENT_ENTRY)entry->Next;
            }
            entry->Next = pDeviceInstallClient;
        }

        bStatus = TRUE;

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_INSTALL,
                   "UMPNPMGR: Exception during CreateDeviceInstallClient!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        lpEnvironment = lpEnvironment;
        ProcessInfo.hThread = ProcessInfo.hThread;
        ProcessInfo.hProcess = ProcessInfo.hProcess;
        hUserToken = hUserToken;
        hDeviceInstallDisconnectEvent = hDeviceInstallDisconnectEvent;
        hDeviceInstallEvent = hDeviceInstallEvent;
        hDeviceInstallPipe = hDeviceInstallPipe;
    }

    if (lpEnvironment) {
        DestroyEnvironmentBlock(lpEnvironment);
    }

    //
    // Close the handle to the thread since we don't need it.
    //
    if (ProcessInfo.hThread) {
        CloseHandle(ProcessInfo.hThread);
    }

    if (hUserToken) {
        CloseHandle(hUserToken);
    }

    if (overlapped.hEvent) {
        CloseHandle(overlapped.hEvent);
    }

    if (!bStatus) {

        ASSERT(!pDeviceInstallClient);

        if (hDeviceInstallDisconnectEvent) {
            CloseHandle(hDeviceInstallDisconnectEvent);
        }

        if (hDeviceInstallEvent) {
            CloseHandle(hDeviceInstallEvent);
        }

        if (hDeviceInstallPipe) {
            CloseHandle(hDeviceInstallPipe);
        }

        if (ProcessInfo.hProcess) {
            CloseHandle(ProcessInfo.hProcess);
        }

        *DeviceInstallClient = NULL;

    } else {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: CreateDeviceInstallClient: created new client for Session %d.\n",
                   SessionId));

        ASSERT(pDeviceInstallClient);
        ASSERT(pDeviceInstallClient->hEvent);
        ASSERT(pDeviceInstallClient->hPipe);
        ASSERT(pDeviceInstallClient->hProcess);
        ASSERT(pDeviceInstallClient->hDisconnectEvent);

        *DeviceInstallClient = pDeviceInstallClient;
    }

    return bStatus;

} // CreateDeviceInstallClient



BOOL
ConnectDeviceInstallClient(
    IN  ULONG     SessionId,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    Retrieves the device install client handles for the specified session,
    if one exists.

Arguments:

    SessionId           - Session for which a device install client should be
                          created or connected to.

    DeviceInstallClient - Receives a pointer to receive the a pointer to the
                          device install client for this session.

Return Value:

    Returns TRUE if an existing device install client was found for the
    specified session, FALSE otherwise.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    PINSTALL_CLIENT_ENTRY entry;
    BOOL bClientFound = FALSE;

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: ConnectDeviceInstallClient: Invalid SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Validate output parameters.
    //
    ASSERT(DeviceInstallClient);
    if (!DeviceInstallClient) {
        return FALSE;
    }

    entry = LocateDeviceInstallClient(SessionId);

    if (entry) {
        //
        // An existing client was found for this session, so we should already
        // have event, pipe, and process handles for it.
        //
        ASSERT(entry->hEvent);
        ASSERT(entry->hPipe);
        ASSERT(entry->hProcess);

        //
        // Make sure the client's process object is in the nonsignalled state,
        // else newdev has already gone away, and we can't use it.
        //
        if (WaitForSingleObject(entry->hProcess, 0) != WAIT_TIMEOUT) {
            //
            // Remove the initial reference to close the handles and remove it
            // from our list.
            //
            ASSERT(entry->RefCount == 1);
            DereferenceDeviceInstallClient(entry);
        } else {
            //
            // If we are reconnecting to a client that was last used during a
            // previous connection to this session, we will not have a disconnect
            // event for it yet, so create one here.  If we just created this client
            // during the current connection to this session, we will already have a
            // disconnect event for it.
            //
            if (!entry->hDisconnectEvent) {
                entry->hDisconnectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            }

            //
            // Either way, make sure we have a disconnect event by now.
            //
            ASSERT(entry->hDisconnectEvent);

            if (entry->hDisconnectEvent) {

                bClientFound = TRUE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: ConnectDeviceInstallClient: found existing client on Session %d.\n",
                           SessionId));
                *DeviceInstallClient = entry;
            }
        }
    }

    if (!bClientFound) {
        *DeviceInstallClient = NULL;
    }

    return bClientFound;

} // ConnectDeviceInstallClient



BOOL
DisconnectDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine disconnects from the current client-side install process (if
    one exists) by signalling the appropriate hDisconnectEvent and closing the
    handle.

Arguments:

    DeviceInstallClient - Receives a pointer to the device install client that
                          should be disconnected.

Return Value:

    Returns TRUE if successful, FALSE otherwise.

Notes:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    PINSTALL_CLIENT_ENTRY entry;
    BOOL bStatus = FALSE;

    ASSERT(DeviceInstallClient);

    if (DeviceInstallClient) {
        ASSERT(DeviceInstallClient->hEvent);
        ASSERT(DeviceInstallClient->hPipe);
        ASSERT(DeviceInstallClient->hProcess);

        //
        // We may or may not have a handle to a diconnect event because we may
        // have an existing client for this session, but not reconnected to it.
        //
        // If we do have an hDisconnectEvent, set the event now since we
        // will otherwise block waiting for newdev.dll to set the
        // hDeviceInstallEvent.  Setting the hDisconnectEvent alerts the
        // waiter that the device install was NOT successful, and that it
        // should preserve the device in the install list.
        //
        if (DeviceInstallClient->hDisconnectEvent) {
            SetEvent(DeviceInstallClient->hDisconnectEvent);
            CloseHandle(DeviceInstallClient->hDisconnectEvent);
            DeviceInstallClient->hDisconnectEvent = NULL;
        }

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL,
                   "UMPNPMGR: Disconnected from device install client on Console SessionId %d\n",
                   DeviceInstallClient->ulSessionId));

        bStatus = TRUE;
    }

    return bStatus;

} // DisconnectDeviceInstallClient



PINSTALL_CLIENT_ENTRY
LocateDeviceInstallClient(
    IN  ULONG     SessionId
    )
/*++

Routine Description:

    This routine locates the client-side install process for a given session (if
    one exists).

Arguments:

    SessionId - Session whose device install client should be located.

Return Value:

    Returns a device install client entry if successful, NULL otherwise.

Note:

    The InstallClientList lock must be acquired by the caller of this routine.

--*/
{
    PINSTALL_CLIENT_ENTRY entry, foundEntry = NULL;
    BOOL bClientFound = FALSE;

    //
    // Make sure the specified SessionId is valid.
    //
    ASSERT(SessionId != INVALID_SESSION);
    if (SessionId == INVALID_SESSION) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_INSTALL | DBGF_ERRORS,
                   "UMPNPMGR: LocateDeviceInstallClient: Invalid Console SessionId %d, exiting!\n",
                   SessionId));
        return FALSE;
    }

    //
    // Search for a client on the specified session.
    //
    for (entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
         entry != NULL;
         entry = entry->Next) {

        if (entry->ulSessionId == SessionId) {
            //
            // Make sure we only have one entry per session.
            //
            ASSERT(!bClientFound);
            bClientFound = TRUE;
            foundEntry = entry;
        }
    }

    return foundEntry;

} // LocateDeviceInstallClient



VOID
ReferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine increments the reference count for a device install client
    entry.

Parameters:

    DeviceInstallClient - Supplies a pointer to the device install client to be
                          referenced.

Return Value:

    None.

Note:

    The appropriate synchronization lock must be held on the device install
    client list before this routine can be called

--*/
{
    ASSERT(DeviceInstallClient);
    ASSERT(((LONG)DeviceInstallClient->RefCount) > 0);

    KdPrintEx((DPFLTR_PNPMGR_ID,
               DBGF_EVENT | DBGF_INSTALL,
               "UMPNPMGR: ---------------- ReferenceDeviceInstallClient  : Session %d [%d --> %d]\n",
               DeviceInstallClient->ulSessionId,
               DeviceInstallClient->RefCount,
               DeviceInstallClient->RefCount + 1));

    DeviceInstallClient->RefCount++;

    return;

} // ReferenceDeviceInstallClient



VOID
DereferenceDeviceInstallClient(
    IN  PINSTALL_CLIENT_ENTRY  DeviceInstallClient
    )
/*++

Routine Description:

    This routine decrements the reference count for a device install client
    entry, removing the entry from the list and freeing the associated memory if
    there are no outstanding reference counts.

Parameters:

    DeviceInstallClient - Supplies a pointer to the device install client to be
                          dereferenced.

Return Value:

    None.

Note:

    The appropriate synchronization lock must be held on the device install
    client list before this routine can be called

--*/
{
    ASSERT(DeviceInstallClient);
    ASSERT(((LONG)DeviceInstallClient->RefCount) > 0);

    //
    // Avoid over-dereferencing the client.
    //
    if (((LONG)DeviceInstallClient->RefCount) > 0) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_EVENT | DBGF_INSTALL,
                   "UMPNPMGR: ---------------- DereferenceDeviceInstallClient: Session %d [%d --> %d]\n",
                   DeviceInstallClient->ulSessionId,
                   DeviceInstallClient->RefCount,
                   DeviceInstallClient->RefCount - 1));

        DeviceInstallClient->RefCount--;

    } else {

        return;
    }

    //
    // If the refcount is zero then the entry no longer needs to be in the list
    // so remove and free it.
    //
    if (DeviceInstallClient->RefCount == 0) {
        BOOL bClientFound = FALSE;
        PINSTALL_CLIENT_ENTRY entry, prev;

        entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
        prev = NULL;

        while (entry) {
            if (entry == DeviceInstallClient) {

                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_EVENT | DBGF_INSTALL,
                           "UMPNPMGR: ---------------- DereferenceDeviceInstallClient: Removing client for Session %d\n",
                           entry->ulSessionId));

                //
                // We should have handles to the pipe, event and process objects for
                // the client, because we will close them here.
                //
                ASSERT(entry->hPipe);
                ASSERT(entry->hEvent);
                ASSERT(entry->hProcess);

                //
                // We may or may not have a handle to a diconnect event because we
                // may have an existing client for this session, but not yet
                // connected to it.
                //
                // If we do have an hDisconnectEvent, set the event now since we
                // will otherwise block waiting for newdev.dll to set the
                // hDeviceInstallEvent.  Setting the hDisconnectEvent alerts the
                // waiter that the device install was NOT successful, and that it
                // should preserve the device in the install list.
                //
                if (entry->hDisconnectEvent) {
                    SetEvent(entry->hDisconnectEvent);
                    CloseHandle(entry->hDisconnectEvent);
                }

                //
                // Close the pipe and event handles so that the client will get a
                // ReadFile error and know that we are finished.  Close the process
                // handle as well.
                //
                if (entry->hPipe) {
                    CloseHandle(entry->hPipe);
                }

                if (entry->hEvent) {
                    CloseHandle(entry->hEvent);
                }

                if (entry->hProcess) {
                    CloseHandle(entry->hProcess);
                }

                //
                // Remove the device install client entry from the list, and free it
                // now.
                //
                if (prev) {
                    prev->Next = entry->Next;
                } else {
                    InstallClientList.Next = entry->Next;
                }

                HeapFree(ghPnPHeap, 0, entry);

                if(prev) {
                    entry = (PINSTALL_CLIENT_ENTRY)prev->Next;
                } else {
                    entry = (PINSTALL_CLIENT_ENTRY)InstallClientList.Next;
                }

                bClientFound = TRUE;

                break;
            }

            prev = entry;
            entry = (PINSTALL_CLIENT_ENTRY)entry->Next;
        }
        ASSERT(bClientFound);
    }

    return;

} // DereferenceDeviceInstallClient



BOOL
DoDeviceInstallClient(
    IN  LPWSTR    DeviceId,
    IN  PULONG    SessionId,
    IN  ULONG     Flags,
    OUT PINSTALL_CLIENT_ENTRY *DeviceInstallClient
    )
/*++

Routine Description:

    This routine kicks off a newdev.dll process (if someone is logged in) that
    displays UI informing the user of the status of the server-side device
    installation.

Arguments:

    DeviceId  - Supplies the devnode ID of the device being installed.

    SessionId - Specifies the session that the newdev client is to be launched
                on.  If the DEVICE_INSTALL_DISPLAY_ON_CONSOLE flag is
                specified, the specified SessionId is ignored.

                Upon successful return, the SessionId for the the session where
                the device install client was created is returned.
                If unsuccessful, the returned SessionId is INVALID_SESSION,
                (0xFFFFFFFF).

    Flags     - Specifies flags describing the behavior of the device install client.
                The following flags are currently defined:

                DEVICE_INSTALL_UI_ONLY - tells newdev.dll whether to do a full
                    install or just show UI while umpnpmgr.dll is doing a server
                    side install.

                DEVICE_INSTALL_PLAY_SOUND - tells newdev.dll whether to play a
                    sound.

                DEVICE_INSTALL_DISPLAY_ON_CONSOLE - if specified, the value
                    specified in SessionId will be ignored, and the client will
                    always be displayed on the current active console session.

    DeviceInstallClient - Supplies the address of a variable to receive, upon
                success, a pointer to a pointer to a device install client.

Return Value:

    If the process was successfully created, the return value is TRUE.  This
    routine doesn't wait until the process terminates.

    If we couldn't create the process (e.g., because no user was logged in),
    the return value is FALSE.

Notes:

    None.

--*/
{
    BOOL  bStatus, bSameDevice = FALSE;
    ULONG DeviceIdSize, ulSize, ulSessionId;
    ULONG InstallFlags;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient = NULL;

    //
    // Assume failure.
    //
    bStatus = FALSE;

    //
    // Validate output parameters.
    //
    if (!DeviceInstallClient || !SessionId) {
        return FALSE;
    }

    try {
        //
        // Check if we should skip all client side UI.
        //
        if (gbSuppressUI) {
            //
            // If we were launching newdev for client-side installation, log an
            // event to let someone know that we didn't.
            //
            if (!(Flags & DEVICE_INSTALL_UI_ONLY)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL | DBGF_WARNINGS,
                           "UMPNPMGR: DoDeviceInstallClient: Client-side newdev UI has been suppressed, exiting.\n"));
                LogWarningEvent(WRN_NEWDEV_UI_SUPPRESSED, 1, DeviceId);
            }
            goto Clean0;
        }

        //
        // Determine the session to use, based on the supplied flags.
        //
        if (Flags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) {
            ulSessionId = GetActiveConsoleSessionId();
        } else {
            ASSERT(*SessionId != INVALID_SESSION);
            ulSessionId = *SessionId;
        }

        ASSERT(ulSessionId != INVALID_SESSION);

        //
        // If the specified session is not currently connected anywhere, don't
        // bother creating any UI.
        //
        if (!IsSessionConnected(ulSessionId)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT,
                       "UMPNPMGR: DoDeviceInstallClient: SessionId %d not connected, exiting\n",
                       ulSessionId));
            goto Clean0;
        }

        //
        // Lock the client list while we retrieve / create a client to use.
        //
        LockNotifyList(&InstallClientList.Lock);

        //
        // First, try to connect to an existing client already running on this
        // session.
        //
        bStatus = ConnectDeviceInstallClient(ulSessionId,
                                             &pDeviceInstallClient);
        if (bStatus) {
            //
            // If the client we just reconnected to was client-side installing
            // this same device when it was last disconnected, don't send it
            // again.
            //
            if (!(Flags & DEVICE_INSTALL_UI_ONLY) && (lstrcmpi(pDeviceInstallClient->LastDeviceId, DeviceId) == 0)) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_INSTALL,
                           "UMPNPMGR: DoDeviceInstallClient: Session %d already installing %ws\n",
                           ulSessionId,
                           DeviceId));
                bSameDevice = TRUE;
            }
        } else {
            //
            // Create a new device install client for this session.
            //
            bStatus = CreateDeviceInstallClient(ulSessionId,
                                                &pDeviceInstallClient);
        }

        if (bStatus) {
            //
            // The client should only have the initial reference from when it
            // was added to the list, since any use of the client is done on
            // this single install thread.
            //
            ASSERT(pDeviceInstallClient);
            ASSERT(pDeviceInstallClient->RefCount == 1);

            //
            // Keep track of both client and server flags.
            //
            pDeviceInstallClient->ulInstallFlags = Flags;

            //
            // Reference the device install client while it is in use.  The
            // caller must remove this reference when it is done with it.
            //
            ReferenceDeviceInstallClient(pDeviceInstallClient);
        }

        UnlockNotifyList(&InstallClientList.Lock);

        if (!bStatus || bSameDevice) {
            //
            // If we don't have a client, or we don't need to resend the device
            // instance to install, we're done.
            //
            goto Clean0;
        }

        //
        // Filter out the install flags that the client doesn't know about.
        //
        InstallFlags = (Flags & DEVICE_INSTALL_CLIENT_MASK);

        DeviceIdSize = (lstrlen(DeviceId) + 1) * sizeof(WCHAR);

        //
        // Make sure we reset the device install event since we will block waiting for
        // newdev.dll to set this event to let us know that it is finished with the current
        // installation.
        //
        if (pDeviceInstallClient->hEvent) {
            ResetEvent(pDeviceInstallClient->hEvent);
        }

        //
        // When sending stuff to newdev.dll over the device install pipe it expects
        // two ULONGs followed by the DeviceID.  The first ULONG is the Flags which
        // tells newdev whether we are doing a UI only install or a full install.
        // The next ULONG is the size of the Device ID and then we send the DeviceID.
        //
        if (WriteFile(pDeviceInstallClient->hPipe,
                      &InstallFlags,
                      sizeof(InstallFlags),
                      &ulSize,
                      NULL
                      )) {
            if (WriteFile(pDeviceInstallClient->hPipe,
                          &DeviceIdSize,
                          sizeof(DeviceIdSize),
                          &ulSize,
                          NULL
                          )) {
                if (WriteFile(pDeviceInstallClient->hPipe,
                              DeviceId,
                              DeviceIdSize,
                              &ulSize,
                              NULL
                              )) {
                    bStatus = TRUE;
                } else {
                    LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
                }
            } else {
                LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
            }
        } else {
            LogErrorEvent(ERR_WRITING_SERVER_INSTALL_PIPE, GetLastError(), 0);
        }

        //
        // Note that we don't remove the reference placed on the install client
        // entry while it was in use, because it will be handed back to the
        // caller, who will wait on the client's event and process handles.  The
        // caller should remove the reference when it is no longer using these.
        // Removing the final reference will cause the client to be closed.
        //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS | DBGF_WARNINGS,
                   "UMPNPMGR: Exception during DoDeviceInstallClient!\n"));
        ASSERT(0);
        bStatus = FALSE;

        //
        // Reference the following variable so the compiler will respect
        // statement ordering w.r.t. its assignment.
        //
        pDeviceInstallClient = pDeviceInstallClient;
    }

 Clean0:

    if (!bStatus) {
        //
        // If we had a device install client at some point, but failed to send
        // it the request, remove the reference we placed on it.
        //
        if (pDeviceInstallClient) {
            LockNotifyList(&InstallClientList.Lock);
            DereferenceDeviceInstallClient(pDeviceInstallClient);
            UnlockNotifyList(&InstallClientList.Lock);
        }

        //
        // Let the caller know there isn't a device install client handling
        // this request.
        //
        *SessionId = INVALID_SESSION;
        *DeviceInstallClient = NULL;

    } else {
        //
        // Make sure we're returning valid client information.
        //
        ASSERT(pDeviceInstallClient);
        ASSERT(pDeviceInstallClient->hEvent);
        ASSERT(pDeviceInstallClient->hPipe);
        ASSERT(pDeviceInstallClient->hProcess);
        ASSERT(pDeviceInstallClient->hDisconnectEvent);
        ASSERT(pDeviceInstallClient->ulSessionId != INVALID_SESSION);

        *SessionId = pDeviceInstallClient->ulSessionId;
        *DeviceInstallClient = pDeviceInstallClient;
    }

    return bStatus;

} // DoDeviceInstallClient



VOID
DoRunOnce(
    VOID
    )
/*++

Routine Description:

    This routine performs server-side processing of the RunOnce entries that
    have been accumulated by setupapi.  The RunOnce node list will be empty
    upon return.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PPSP_RUNONCE_NODE RunOnceNode;
    HINSTANCE hLib;
    CHAR AnsiBuffer[MAX_PATH * 2];
    PSTR EndPtr;
    RUNDLLPROCA fpRunDllProcA;
    RUNDLLPROCW fpRunDllProcW;

    RunOnceNode = fpAccessRunOnceNodeList();

    //
    // Process each node in the list.
    //
    while(RunOnceNode) {

        hLib = NULL;

        try {
            //
            // First, load the DLL (setupapi already did the signature
            // verification for us, so this should be safe).
            //
            hLib = LoadLibrary(RunOnceNode->DllFullPath);
            if(!hLib) {
                goto clean0;
            }

            //
            // First, try to retrieve the 'W' (Unicode) version of the entrypoint.
            //
            lstrcpyA(AnsiBuffer, RunOnceNode->DllEntryPointName);
            EndPtr = AnsiBuffer + lstrlenA(AnsiBuffer);
            *EndPtr = 'W';
            *(EndPtr+1) = '\0';

            fpRunDllProcW = (RUNDLLPROCW)GetProcAddress(hLib, AnsiBuffer);

            if(!fpRunDllProcW) {
                //
                // Could't find unicode entrypt, try 'A' decorated one
                //
                *EndPtr = 'A';
                fpRunDllProcA = (RUNDLLPROCA)GetProcAddress(hLib, AnsiBuffer);

                if(!fpRunDllProcA) {
                    //
                    // Couldn't find 'A' decorated entrypt, try undecorated name
                    // undecorated entrypts are assumed to be ANSI
                    //
                    *EndPtr = '\0';
                    fpRunDllProcA = (RUNDLLPROCA)GetProcAddress(hLib, AnsiBuffer);
                }
            }

            //
            // We shoulda found one of these...
            //
            ASSERT(fpRunDllProcW || fpRunDllProcA);

            if(fpRunDllProcW) {
                //
                // Re-use our ANSI buffer to hold a writeable copy of our
                // DLL argument string.
                //
                lstrcpy((LPWSTR)AnsiBuffer, RunOnceNode->DllParams);

                fpRunDllProcW(NULL, ghInst, (LPWSTR)AnsiBuffer, SW_HIDE);

            } else if(fpRunDllProcA) {
                //
                // Need to convert the arg string to ANSI first...
                //
                WideCharToMultiByte(CP_ACP,
                                    0,      // default composite char behavior
                                    RunOnceNode->DllParams,
                                    -1,
                                    AnsiBuffer,
                                    sizeof(AnsiBuffer),
                                    NULL,
                                    NULL
                                    );

                fpRunDllProcA(NULL, ghInst, AnsiBuffer, SW_HIDE);
            }

        clean0:
            NOTHING;

        } except(EXCEPTION_EXECUTE_HANDLER) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS | DBGF_INSTALL,
                       "UMPNPMGR: Exception during DoRunOnce!\n"));
            ASSERT(0);

            //
            // Reference the following variable so the compiler will respect
            // statement ordering w.r.t. its assignment.
            //
            hLib = hLib;
        }

        if(hLib) {
            FreeLibrary(hLib);
        }

        RunOnceNode = RunOnceNode->Next;
    }

    //
    // Free all the members in the list.
    //
    fpDestroyRunOnceNodeList();

    return;

} // DoRunOnce



DWORD
SessionNotificationHandler(
    IN  DWORD EventType,
    IN  PWTSSESSION_NOTIFICATION SessionNotification
    )
/*++

Routine Description:

    This routine handles console switch events.

Arguments:

    EventType           - The type of event that has occurred.

    SessionNotification - Additional event information.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    failure.

Notes:

    Session change notification events are used to determine when there is a
    session with a logged on user currently connected to the Console.  When a
    user session is connected to the Console, we signal the "logged on" event,
    which will wake the device installation thread to perform any pending
    client-side device install events.  When there is no user session connected
    to the Console, the "logged on" event is reset.  The "logged on" event may
    also be set/reset for logon/logoff events to session 0 by PNP_ReportLogOn /
    PnpConsoleCtrlHandler, in the event that Terminal Services are not
    available.

--*/
{
    HANDLE hUserToken = INVALID_HANDLE_VALUE;
    LPTSTR pszUserName = NULL;
    DWORD  dwSize = 0;
    PINSTALL_CLIENT_ENTRY pDeviceInstallClient;

    //
    // Validate the session change notification structure.
    //
    ASSERT(SessionNotification);
    ASSERT(SessionNotification->cbSize >= sizeof(WTSSESSION_NOTIFICATION));

    if ((!ARGUMENT_PRESENT(SessionNotification)) ||
        (SessionNotification->cbSize < sizeof(WTSSESSION_NOTIFICATION))) {
        return ERROR_INVALID_PARAMETER;
    }

    switch (EventType) {

        case WTS_CONSOLE_CONNECT:
            //
            // The notification was sent because the specified session was
            // connected to the Console.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_CONSOLE_CONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            //
            // Keep track globally of the current active console session, and
            // signal that it's safe to access it.
            //
            // NOTE - we must set the ghActiveConsoleSessionEvent here, prior to
            // calling IsConsoleSession below, which waits on it, else we will
            // deadlock out service's control handler.
            //
            gActiveConsoleSessionId = (ULONG)SessionNotification->dwSessionId;
            if (ghActiveConsoleSessionEvent) {
                SetEvent(ghActiveConsoleSessionEvent);
            }

            //
            // If the session just connected to the Console already has a logged
            // on user, signal the "logged on" event.
            //
            if (IsConsoleSession((ULONG)SessionNotification->dwSessionId) &&
                IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) {
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_CONSOLE_CONNECT: "
                               "SetEvent LOGGED_ON_EVENT\n"));
                }
            }
            break;

        case WTS_CONSOLE_DISCONNECT:
            //
            // The notification was sent because the specified session
            // was disconnected from the Console.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_CONSOLE_DISCONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            //
            // Check if the session just disconnected from the "Console" has a
            // logged on user.
            //
            if (IsConsoleSession((ULONG)SessionNotification->dwSessionId) &&
                IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) {
                //
                // Reset the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_CONSOLE_DISCONNECT: "
                               "ResetEvent LOGGED_ON_EVENT\n"));
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                }

                //
                // Since this is a console switch event, only do something with
                // a device install client on the console session if it's
                // behavior was specifically designated for the console (i.e. -
                // it was put on this session because it was the active console
                // session at the time).
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if ((pDeviceInstallClient) &&
                    (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE)) {
                    if (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_UI_ONLY) {
                        //
                        // If it was just for UI only, dereference it to make it
                        // go away when it's no longer in use.
                        //
                        DereferenceDeviceInstallClient(pDeviceInstallClient);
                    } else {
                        //
                        // Otherwise, it is a legitimate client-side
                        // installation in progress, so just disconnect from it.
                        // This does not remove a reference because we want it
                        // to stay around in case the session is reconnected to
                        // and the device still needs to be installed, - or
                        // until we find out that there are no more devices to
                        // install, in which case we'll close it.
                        //
                        DisconnectDeviceInstallClient(pDeviceInstallClient);
                    }
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }

            //
            // The current active console session is invalid until we receive a
            // subsequent console connect event.  Reset the event.
            //
            // NOTE - we must reset the ghActiveConsoleSessionEvent here, after
            // calling IsConsoleSession above, which waits on it, else we will
            // deadlock out service's control handler.
            //
            if (ghActiveConsoleSessionEvent) {
                ResetEvent(ghActiveConsoleSessionEvent);
            }
            gActiveConsoleSessionId = INVALID_SESSION;

            break;

        case WTS_REMOTE_CONNECT:
            //
            // The specified session was connected remotely.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_REMOTE_CONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId == MAIN_SESSION) &&
                (IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) &&
                (!IsFastUserSwitchingEnabled())) {
                //
                // If the remote session that was just connected from the "Console"
                // has a logged on user, signal the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_REMOTE_CONNECT: "
                               "SetEvent LOGGED_ON_EVENT\n"));
                }
            }
            break;

        case WTS_REMOTE_DISCONNECT:
            //
            // The specified session was disconnected remotely.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_REMOTE_DISCONNECT: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId == MAIN_SESSION) &&
                (IsUserLoggedOnSession((ULONG)SessionNotification->dwSessionId)) &&
                (!IsFastUserSwitchingEnabled())) {
                //
                // If the remote session that was disconnected from the "Console"
                // has a logged on user, reset the "logged on" event.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_REMOTE_DISCONNECT: "
                               "ResetEvent LOGGED_ON_EVENT\n"));
                }

                //
                // Since this remote session is being treated as the console,
                // only do something with a device install client if it's
                // behavior was NOT specifically designated for the console
                // (i.e. - it was put on this session because it was the active
                // console session at the time).
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if ((pDeviceInstallClient) &&
                    ((pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_DISPLAY_ON_CONSOLE) == 0)) {
                    if (pDeviceInstallClient->ulInstallFlags & DEVICE_INSTALL_UI_ONLY) {
                        //
                        // If it was just for UI only, dereference it to make it
                        // go away when it's no longer in use.
                        //
                        DereferenceDeviceInstallClient(pDeviceInstallClient);
                    } else {
                        //
                        // Otherwise, it is a legitimate client-side
                        // installation in progress, so just disconnect from it.
                        // This does not remove a reference because we want it
                        // to stay around in case the session is reconnected to
                        // and the device still needs to be installed, - or
                        // until we find out that there are no more devices to
                        // install, in which case we'll close it.
                        //
                        DisconnectDeviceInstallClient(pDeviceInstallClient);
                    }
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }
            break;

        case WTS_SESSION_UNLOCK:
            //
            // The interactive windowstation on the specified session was unlocked.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_UNLOCK: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (SessionNotification->dwSessionId == MAIN_SESSION) {
                //
                // For the main session, Terminal Services may or may not be
                // available, so we keep track of this state ourselves.
                //
                gbMainSessionLocked = FALSE;
            }

            if (IsFastUserSwitchingEnabled()) {
                //
                // When Fast User Switching is enabled, unlocking the windowstation
                // is a return from the "Welcome" desktop, so we treat it as a
                // logon ...
                //

                //
                // If this is a logon to the "Console" session, signal the event that
                // indicates a Console user is currently logged on.
                //
                // NOTE: we check gActiveConsoleSessionId directly here, without
                // waiting on the corresponding event because this unlock may
                // happen during a Console session change for another session,
                // in which case we will hang here in the service control
                // handler, waiting for the event to be set - and not be able to
                // receive the service control that actually lets us set the
                // event!!!  Synchronization is not so important here because we
                // are not using the session for anything, just comparing
                // against it.  If a session change really is in progress, this
                // session can't be the Console session anyways.
                //
                // Also, since Fast User Switching is enabled, we can just
                // compare against the active Console session id, and not bother
                // with the session 0 thing.
                //
                if (SessionNotification->dwSessionId == gActiveConsoleSessionId) {
                    if (InstallEvents[LOGGED_ON_EVENT]) {
                        SetEvent(InstallEvents[LOGGED_ON_EVENT]);
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_EVENT | DBGF_INSTALL,
                                   "UMPNPMGR: WTS_SESSION_UNLOCK with FUS: "
                                   "SetEvent LOGGED_ON_EVENT\n"));
                    }
                }

            } else {
                //
                // When Fast User Switching is not enabled, we don't do anything
                // special when the winstation is unlocked.
                //

                // No-FUS, no-muss.
                NOTHING;
            }
            break;

        case WTS_SESSION_LOGON:
            //
            // NTRAID #181685-2000/09/11-jamesca:
            //
            //   Currently, terminal services sends notification of logons to
            //   "remote" sessions before the server's process creation thread
            //   is running.  If we set the logged on event, and there are
            //   devices waiting to be installed, we will immediately call
            //   CreateProcessAsUser on that session, which will fail.  As a
            //   (temporary?) workaround, we'll continue to use PNP_ReportLogOn
            //   to receive logon notification from userinit.exe, now for all
            //   sessions.
            //
            break;

        case WTS_SESSION_LOCK:
            //
            // The interactive windowstation on the specified session was locked.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_LOCK: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (SessionNotification->dwSessionId == MAIN_SESSION) {
                //
                // For the main session, Terminal Services may or may not be
                // available, so we keep track of this state ourselves.
                //
                gbMainSessionLocked = TRUE;
            }

            if (IsFastUserSwitchingEnabled()) {
                //
                // When Fast User Switching is enabled, locking the windowstation
                // displays the "Welcome" desktop, potentially allowing a different
                // user to logon, so we treat it as a logoff ...
                //

                //
                // If this is a "logoff" from the "Console" session, reset the event
                // that indicates a Console user is currently logged on.
                //
                //
                // NOTE: we check gActiveConsoleSessionId directly here, without
                // waiting on the corresponding event because this lock may
                // happen during a Console session change for another session,
                // in which case we will hang here in the service control
                // handler, waiting for the event to be set - and not be able to
                // receive the service control that actually lets us set the
                // event!!!  Synchronization is not so important here because we
                // are not using the session for anything, just comparing
                // against it.  If a session change really is in progress, this
                // session can't be the Console session anyways.
                //
                // Also, since Fast User Switching is enabled, we can just
                // compare against the active Console session id, and not bother
                // with the session 0 thing.
                //
                if (SessionNotification->dwSessionId == gActiveConsoleSessionId) {
                    if (InstallEvents[LOGGED_ON_EVENT]) {
                        ResetEvent(InstallEvents[LOGGED_ON_EVENT]);
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_EVENT | DBGF_INSTALL,
                                   "UMPNPMGR: WTS_SESSION_LOCK with FUS: "
                                   "ResetEvent LOGGED_ON_EVENT\n"));
                    }
                }

            } else {
                //
                // When Fast User Switching is not enabled, we don't do anything
                // special when the winstation is locked.
                //

                // No-FUS, no-muss.
                NOTHING;
            }
            break;

        case WTS_SESSION_LOGOFF:
            //
            // A user logged off from the specified session.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL,
                       "UMPNPMGR: WTS_SESSION_LOGOFF: "
                       "SessionId %d\n",
                       SessionNotification->dwSessionId));

            if (((ULONG)SessionNotification->dwSessionId != MAIN_SESSION) &&
                ((ULONG)SessionNotification->dwSessionId == gActiveConsoleSessionId)) {
                //
                // If the logoff occurred on the Console session (but not
                // session 0), reset the "logged on" event.
                // Session 0 logoffs are still handled by PnpConsoleCtrlHandler.
                //
                if (InstallEvents[LOGGED_ON_EVENT]) {
                    ResetEvent(InstallEvents[LOGGED_ON_EVENT]);

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_EVENT | DBGF_INSTALL,
                               "UMPNPMGR: WTS_SESSION_LOGOFF: "
                               "ResetEvent LOGGED_ON_EVENT\n",
                               SessionNotification->dwSessionId));
                }

                //
                // If we currently have a device install UI client on this session,
                // we should attempt to close it now, before logging off.
                //
                LockNotifyList(&InstallClientList.Lock);
                pDeviceInstallClient = LocateDeviceInstallClient((ULONG)SessionNotification->dwSessionId);
                if (pDeviceInstallClient) {
                    DereferenceDeviceInstallClient(pDeviceInstallClient);
                }
                UnlockNotifyList(&InstallClientList.Lock);
            }
            break;

        default:
            //
            // Unrecognized session change notification event.
            //
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_EVENT | DBGF_INSTALL | DBGF_ERRORS,
                       "UMPNPMGR: Unknown SERVICE_CONTROL_SESSIONCHANGE event type (%d) "
                       "received for SessionId %d!!\n",
                       EventType,
                       SessionNotification->dwSessionId));
            break;

    }

    return NO_ERROR;

} // SessionNotificationHandler



BOOL
IsUserLoggedOnSession(
    IN  ULONG    ulSessionId
    )
/*++

Routine Description:

    Checks to see if a user is logged on to the specified session.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if a user is currently logged on to the specified session,
    FALSE otherwise.

--*/
{
    BOOL   bResult = FALSE;
    LPTSTR pszUserName;
    DWORD  dwSize;

    if (ulSessionId == MAIN_SESSION) {
        //
        // For the main session, Terminal Services may or may not be available,
        // so we just check if we currently have a handle to the user token.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken != NULL) {
            bResult = TRUE;
        }
        UnlockPrivateResource(&gTokenLock);

    } else {

        //
        // If the specified session is not the main session,
        // query the session information to see if there is already a
        // user logged on.
        //
        if (fpWTSQuerySessionInformation && fpWTSFreeMemory) {

            pszUserName = NULL;
            dwSize = 0;

            if (fpWTSQuerySessionInformation((HANDLE)WTS_CURRENT_SERVER_HANDLE,
                                             (DWORD)ulSessionId,
                                             (WTS_INFO_CLASS)WTSUserName,
                                             (LPWSTR*)&pszUserName,
                                             &dwSize)) {
                if ((pszUserName != NULL) && (lstrlen(pszUserName) != 0)) {
                    bResult = TRUE;
                }

                //
                // Free the supplied buffer
                //
                if (pszUserName) {
                    fpWTSFreeMemory((PVOID)pszUserName);
                }

            } else {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: WTSQuerySessionInformation failed for SessionId %d, "
                           "error = %d\n",
                           ulSessionId, GetLastError()));
            }
        }
    }

    return bResult;

} // IsUserLoggedOnSession



BOOL
IsSessionConnected(
    IN  ULONG     ulSessionId
    )
/*++

Routine Description:

    Checks if the specified session is connected.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the specified session is currently connected, FALSE
    otherwise.

Notes:

    This routine assumes that the specified session is connected, unless we can
    poitively determine that it is not.  i.e., if Terminal Services are not
    available, it is assumed that the specified session is connected.

--*/
{
    BOOL   bResult = TRUE;
    LPTSTR pBuffer;
    DWORD  dwSize;

    //
    // Query the specified session.
    //
    if (fpWTSQuerySessionInformation && fpWTSFreeMemory) {

        pBuffer = NULL;
        dwSize = 0;

        if (fpWTSQuerySessionInformation((HANDLE)WTS_CURRENT_SERVER_HANDLE,
                                         (DWORD)ulSessionId,
                                         (WTS_INFO_CLASS)WTSConnectState,
                                         (LPWSTR*)&pBuffer,
                                         &dwSize)) {
            //
            // The session state must be either Active or Connected.
            //
            if ((pBuffer == NULL) ||
                ((((INT)*pBuffer) != WTSActive) &&
                 (((INT)*pBuffer) != WTSConnected))) {
                //
                // The specified session is not currently connected.
                //
                bResult = FALSE;
            }

            //
            // Free the supplied buffer
            //
            if (pBuffer) {
                fpWTSFreeMemory((PVOID)pBuffer);
            }

        }

    } else {
        //
        // If the above TS entrypoints are not set, terminal services is not
        // enabled.  This must be session 0, and it must be connected.
        //
        ASSERT(ulSessionId == MAIN_SESSION);
    }

    return bResult;

} // IsSessionConnected



BOOL
IsSessionLocked(
    IN  ULONG    ulSessionId
    )
/*++

Routine Description:

    Checks to see if the interactive windowstation for the specified session is
    locked.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the interactive windowstation for the specified session is
    locked, FALSE otherwise.

--*/
{
    BOOL   bLocked = FALSE;
    DWORD  dwReturnLength;

    if (ulSessionId == MAIN_SESSION) {
        //
        // For the main session, Terminal Services may or may not be available,
        // so we just check our internal state variable.
        //
        bLocked = gbMainSessionLocked;

    } else {
        //
        // If the specified session is not the main session, query Terminal
        // Services for that session's WinStation information.
        //

        try {

            if (!fpWinStationQueryInformationW(SERVERNAME_CURRENT,
                                               ulSessionId,
                                               WinStationLockedState,
                                               (PVOID)&bLocked,
                                               sizeof(bLocked),
                                               &dwReturnLength)) {
                bLocked = FALSE;
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: WinStationQueryInformation failed for SessionId %d, "
                           "error = %d\n",
                           ulSessionId, GetLastError()));
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            bLocked = FALSE;
        }
    }

    return bLocked;

} // IsSessionLocked



BOOL
IsConsoleSession(
    IN  ULONG     ulSessionId
    )
/*++

Routine Description:

    Checks to see if the specified session is the "Console" session.

    When Terminal Services Fast User Switching is enabled, this means that the
    session is the session connected to the physical display.  When Fast User
    Switching is disabled, this means that the session is Session 0.

Arguments:

    ulSessionId - The session to be checked.

Return Value:

    Returns TRUE if the specified session should currently be considered the
    "Console" session.

Notes:

   Note that this routine may potentially wait in GetActiveConsoleSessionId(),
   on the event we use to guard access to the active console session.  Because
   of that, this routine should not be called in cases where it prevents a
   console connect or console disconnect from taking place, unless the event is
   known to be set appropriately.

--*/
{
    BOOL bFusEnabled;

    bFusEnabled = IsFastUserSwitchingEnabled();

    if ((!bFusEnabled && (ulSessionId == MAIN_SESSION)) ||
        ( bFusEnabled && (ulSessionId == GetActiveConsoleSessionId()))) {
        return TRUE;
    } else {
        return FALSE;
    }

} // IsConsoleSession



ULONG
GetActiveConsoleSessionId(
    VOID
    )
/*++

Routine Description:

    This routine returns the session id for the current active Console session.
    If a Console session switch event is in progress, it will wait until it is
    complete before returning.

Arguments:

    None.

Return Value:

    Session Id of the current active Console session.

--*/
{
    DWORD dwWait;

    ASSERT(ghActiveConsoleSessionEvent);

    dwWait = WaitForSingleObject(ghActiveConsoleSessionEvent, INFINITE);
    ASSERT(dwWait == WAIT_OBJECT_0);

    ASSERT(gActiveConsoleSessionId != INVALID_SESSION);

    return gActiveConsoleSessionId;

} // GetActiveConsoleSessionId



BOOL
GetSessionUserToken(
    IN  ULONG     ulSessionId,
    OUT LPHANDLE  lphUserToken
    )
/*++

Routine Description:

    This routine returns a handle to the user access token for the user at the
    Console session.

Arguments:

   lphUserToken - Specifies the address to receive the handle to the user access
                  token.  Note that if this routine was successful, the caller is
                  responsible for closing this handle.

Return Value:

   Returns TRUE if successful, FALSE otherwise.

--*/
{
    BOOL   bResult = FALSE;
    HANDLE hImpersonationToken = INVALID_HANDLE_VALUE;
    RPC_STATUS rpcStatus;

    //
    // Verify that we were supplied a location to store the user token handle.
    //
    if (lphUserToken == NULL) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: NULL lphUserToken supplied to GetSessionUserToken!\n"));
        return FALSE;
    }

    if (ulSessionId == MAIN_SESSION) {
        //
        // A logon to session 0 can't be dependent on termsrv.exe, so we always
        // cache a handle to the user access token for that session during the
        // call to PNP_ReportLogon for session 0.  If we currently have a handle
        // to the token, return it.
        //
        ASSERT(gTokenLock.LockHandles);
        LockPrivateResource(&gTokenLock);
        if (ghUserToken) {
            //
            // Duplicate the handle so that the caller can always safely close
            // it, no matter where it came from.
            //
            bResult = DuplicateHandle(GetCurrentProcess(),
                                      ghUserToken,
                                      GetCurrentProcess(),
                                      lphUserToken,
                                      0,
                                      TRUE,
                                      DUPLICATE_SAME_ACCESS);
            if (!bResult) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: DuplicateHandle failed for ghUserToken for SessionId %d, error = %d\n",
                           ulSessionId, GetLastError()));
            }

        } else {
            //
            // If we don't have a handle to a user access token for session 0,
            // there is probably not any user logged on to that session.
            //
            bResult = FALSE;
        }
        UnlockPrivateResource(&gTokenLock);

    } else {
        //
        // If the specified session is some session other than session 0,
        // Terminal Services must necessarily be available.  Call
        // GetWinStationUserToken to retrieve a handle to the user access token
        // for this session.
        //
        bResult = GetWinStationUserToken(ulSessionId, &hImpersonationToken);

        if (bResult) {
            //
            // The token retrieved by GetWinStationUserToken is an impersonation
            // token.  CreateProcessAsUser requires a primary token, so we must
            // duplicate the impersonation token to get one.  Create a primary
            // token with the same access rights as the original token.
            //
            bResult = DuplicateTokenEx(hImpersonationToken,
                                       0,
                                       NULL,
                                       SecurityImpersonation,
                                       TokenPrimary,
                                       lphUserToken);

            //
            // Close the handle to the impersonation token.
            //
            CloseHandle(hImpersonationToken);

            if (!bResult) {
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: DuplicateTokenEx failed, error = %d\n",
                           GetLastError()));
            }

        } else {

            //
            // Find out what the problem was.
            //
            rpcStatus = GetLastError();

            if (rpcStatus == RPC_S_INVALID_BINDING) {
                //
                // This is some error related to the service not being
                // available.  Since we only call this for sessions other than
                // the main session, termsrv should definitely be available.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_ERRORS,
                           "UMPNPMGR: GetWinStationUserToken returned error = %d for SessionId %d!!\n",
                           rpcStatus, ulSessionId));

                ASSERT(FALSE);

            } else {
                //
                // Some other error, the service may never be avaiable so bail
                // out now.
                //
                KdPrintEx((DPFLTR_PNPMGR_ID,
                           DBGF_WARNINGS,
                           "UMPNPMGR: GetWinStationUserToken failed for SessionId %d, error = %d\n",
                           ulSessionId, rpcStatus));
            }
        }
    }

    //
    // If successful, we should always be returning a valid handle.
    //
    ASSERT(!bResult || ((*lphUserToken != INVALID_HANDLE_VALUE) && (*lphUserToken != NULL)));

    return bResult;

} // GetSessionUserToken



DWORD
CreateUserSynchEvent(
    IN  LPCWSTR lpName,
    OUT HANDLE *phEvent
    )
/*++

Routine Description:

    This routine creates an event that anyone can synchronize with.  This is
    used so that we can communicate with the UI-only NewDev process running in
    a non-privileged user's context.

Arguments:

    lpName - Name of event to create.

    phEvent - Supplies the address of a variable that will be filled in with
        the event handle created.

Return Value:

    If successful, the return value is NO_ERROR.
    If failure, the return value is a Win32 error code indicating the cause of
    failure.

--*/
{
    DWORD                       Err;
    ULONG                       ulSize = 0;
    SECURITY_DESCRIPTOR         secDesc;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PACL                        pDacl = NULL;
    PSID                        pWorldSid = NULL;
    PSID                        pCreatorSid = NULL;
    SECURITY_ATTRIBUTES         secAttributes;

    //
    // create the World SID
    //
    if (!AllocateAndInitializeSid( &WorldAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pWorldSid)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // create the Creator/Owner SID
    //
    if (!AllocateAndInitializeSid( &CreatorAuthority, 1,
                                   SECURITY_CREATOR_OWNER_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pCreatorSid)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // create a new absolute security descriptor and DACL
    //
    if (!InitializeSecurityDescriptor( &secDesc,
                                       SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    ulSize = sizeof(ACL);
    ulSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pWorldSid) - sizeof(DWORD);
    ulSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pCreatorSid) - sizeof(DWORD);

    //
    // create and initialize the DACL
    //
    pDacl = HeapAlloc(ghPnPHeap, 0, ulSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulSize, ACL_REVISION)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // Add a Creator-full ace to this DACL
    //
    if (!AddAccessAllowedAceEx( pDacl, ACL_REVISION,
                                CONTAINER_INHERIT_ACE, EVENT_ALL_ACCESS,
                                pCreatorSid)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // Add a World-modify/synchronize ace to this DACL
    //
    if (!AddAccessAllowedAceEx( pDacl, ACL_REVISION,
                                CONTAINER_INHERIT_ACE, EVENT_MODIFY_STATE | SYNCHRONIZE,
                                pWorldSid)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // Set the new DACL in the absolute security descriptor
    //
    if (!SetSecurityDescriptorDacl(&secDesc, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    //
    // validate the new security descriptor
    //
    if (!IsValidSecurityDescriptor(&secDesc)) {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
        goto Clean0;
    }

    secAttributes.nLength = sizeof(secAttributes);
    secAttributes.lpSecurityDescriptor = &secDesc;
    secAttributes.bInheritHandle = FALSE;

    //
    // Create the manual-reset event with a nonsignaled initial state.
    //
    *phEvent = CreateEvent(&secAttributes, TRUE, FALSE, lpName);

    if (*phEvent != NULL) {
        Err = NO_ERROR;
    } else {
        Err = GetLastError();
        ASSERT(Err != NO_ERROR);
        if(Err == NO_ERROR) {
            Err = ERROR_INVALID_DATA;
        }
    }

 Clean0:

    if (pWorldSid != NULL) {
        FreeSid(pWorldSid);
    }

    if (pCreatorSid != NULL) {
        FreeSid(pCreatorSid);
    }

    if (pDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pDacl);
    }

    return Err;

} // CreateUserSynchEvent



BOOL
CreateNoPendingInstallEvent(
    VOID
    )
/*++

Routine Description:

    This routine creates the "PnP_No_Pending_Install_Events" global named event,
    which is set and reset by the UMPNPMGR ThreadProc_DeviceInstall server-side
    device install thread, and waited on by the CMP_WaitNoPendingInstalls
    CFGMGR32 API, which allows clients to synchronize with the event to
    determine when PNP is done actively installing any devices.

Arguments:

    None.

Return Value:

    Returns TRUE if successful, FALSE otherwise.

--*/
{
    DWORD                       Err = NO_ERROR;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    PSID                        pLocalSystemSid = NULL;
    PSID                        pAliasAdminsSid = NULL;
    PSID                        pAliasUsersSid = NULL;
    PACL                        pDacl = NULL;
    ULONG                       ulAclSize;
    SECURITY_DESCRIPTOR         sd;
    SECURITY_ATTRIBUTES         sa;


    //
    // Retrieve the LocalSystem SID
    //

    if (!AllocateAndInitializeSid(
            &NtAuthority, 1,
            SECURITY_LOCAL_SYSTEM_RID,
            0, 0, 0, 0, 0, 0, 0,
            &pLocalSystemSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(pLocalSystemSid));

    //
    // Retrieve the Administrators SID
    //

    if (!AllocateAndInitializeSid(
            &NtAuthority, 2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &pAliasAdminsSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(pAliasAdminsSid));

    //
    // Create the Users SID.
    //

    if (!AllocateAndInitializeSid(
            &NtAuthority, 2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_USERS,
            0, 0, 0, 0, 0, 0,
            &pAliasUsersSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSid(pAliasUsersSid));

    //
    // Determine the size required for the DACL
    //

    ulAclSize  = sizeof(ACL);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pLocalSystemSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAliasAdminsSid) - sizeof(DWORD);
    ulAclSize += sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pAliasUsersSid) - sizeof(DWORD);

    //
    // Allocate and initialize the DACL
    //

    pDacl =
        (PACL)HeapAlloc(
            ghPnPHeap, 0, ulAclSize);

    if (pDacl == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto Clean0;
    }

    if (!InitializeAcl(pDacl, ulAclSize, ACL_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for LocalSystem EVENT_ALL_ACCESS
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_ALL_ACCESS,
            pLocalSystemSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for Administrators EVENT_QUERY_STATE and SYNCHRONIZE
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_QUERY_STATE | SYNCHRONIZE,
            pAliasAdminsSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Add an ACE to the DACL for Users EVENT_QUERY_STATE and SYNCHRONIZE
    //

    if (!AddAccessAllowedAceEx(
            pDacl,
            ACL_REVISION,
            0,
            EVENT_QUERY_STATE | SYNCHRONIZE,
            pAliasUsersSid)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidAcl(pDacl));

    //
    // Allocate and initialize the security descriptor
    //

    if (!InitializeSecurityDescriptor(
            &sd, SECURITY_DESCRIPTOR_REVISION)) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Set the new DACL in the security descriptor
    //

    if (!SetSecurityDescriptorDacl(
            &sd, TRUE, pDacl, FALSE)) {
        Err = GetLastError();
        goto Clean0;
    }

    ASSERT(IsValidSecurityDescriptor(&sd));

    //
    // Add the security descriptor to the security attributes
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    //
    // Create the manual-reset event with a nonsignaled initial state.
    //

    ghNoPendingInstalls =
        CreateEvent(&sa, TRUE, FALSE, PNP_NO_INSTALL_EVENTS);

    if (ghNoPendingInstalls == NULL) {
        Err = GetLastError();
        goto Clean0;
    }

    //
    // Check that the named event did not already exist.
    //

    ASSERT(GetLastError() != ERROR_ALREADY_EXISTS);

    if (GetLastError() == ERROR_ALREADY_EXISTS) {
        Err = ERROR_ALREADY_EXISTS;
        CloseHandle(ghNoPendingInstalls);
        ghNoPendingInstalls = NULL;
        goto Clean0;
    }

 Clean0:

    //
    // Cleanup.
    //

    if (pAliasUsersSid != NULL) {
        FreeSid(pAliasUsersSid);
    }

    if (pAliasAdminsSid != NULL) {
        FreeSid(pAliasAdminsSid);
    }

    if (pLocalSystemSid != NULL) {
        FreeSid(pLocalSystemSid);
    }

    if (pDacl != NULL) {
        HeapFree(ghPnPHeap, 0, pDacl);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

} // CreateNoPendingInstallEvent



VOID
LogSurpriseRemovalEvent(
    IN  LPWSTR  MultiSzList
    )
/*++

Routine Description:

    One or more non-SurpriseRemovalOK devices were removed without prior
    warning. Record the removals in the event log.

Arguments:

    MultiSz list of device instance paths.

Return Value:

    None.

--*/
{
    LPWSTR instancePath, friendlyName;
    CONFIGRET configRet;
    ULONG ulRegDataType, ulRemovalPolicy, ulVerifierFlags, ulTransferLen, ulLength;
    HKEY hMmKey = NULL;
    LONG lResult;

    for(instancePath = MultiSzList;
        ((*instancePath) != UNICODE_NULL);
        instancePath += lstrlen(instancePath) + 1) {

        ulTransferLen = ulLength = sizeof(ULONG);

        configRet = PNP_GetDeviceRegProp(
            NULL,
            instancePath,
            CM_DRP_REMOVAL_POLICY,
            &ulRegDataType,
            (LPBYTE) &ulRemovalPolicy,
            &ulTransferLen,
            &ulLength,
            0
            );

        if (configRet != CR_SUCCESS) {

            continue;
        }

        if (ulRemovalPolicy == CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL) {

            //
            // For devices which we expect surprise removal, we look to see if
            // the verifier is enabled.
            //
            lResult = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                RegMemoryManagementKeyName,
                0,
                KEY_QUERY_VALUE,
                &hMmKey
                );

            if ( lResult == ERROR_SUCCESS ) {

                ulLength = sizeof(ULONG);

                lResult = RegQueryValueEx(
                    hMmKey,
                    RegVerifyDriverLevelValueName,
                    0,
                    &ulRegDataType,
                    (LPBYTE) &ulVerifierFlags,
                    &ulLength
                    );

                RegCloseKey(hMmKey);

                //
                // ADRIAO ISSUE 2001/02/14 -
                //    We don't yet have a BIOS verification flag yet, so even
                // though the verifier may be targetted at a specific driver
                // for a WHQL test, we will log an event log here.
                //
                if ((lResult != ERROR_SUCCESS) ||
                    (!(ulVerifierFlags & DRIVER_VERIFIER_ENHANCED_IO_CHECKING))) {

                    continue;
                }
            }
        }

        friendlyName = BuildFriendlyName(instancePath);

        if (friendlyName) {

            LogErrorEvent(
                ERR_SURPRISE_REMOVAL_2,
                0,
                2,
                friendlyName,
                instancePath
                );

            HeapFree(ghPnPHeap, 0, friendlyName);

        } else {

            LogErrorEvent(
                ERR_SURPRISE_REMOVAL_1,
                0,
                1,
                instancePath
                );
        }
    }
}


PWCHAR
BuildFriendlyName(
    IN  LPWSTR   InstancePath
    )
{
    PWCHAR friendlyName;
    CONFIGRET configRet;
    ULONG ulLength, ulTransferLen;
    WCHAR szBuffer[MAX_PATH];
    ULONG ulRegDataType;
    GUID classGuid;
    handle_t hBinding;

    hBinding = NULL;

    //
    // Try the registry for FRIENDLYNAME
    //
    ulLength = ulTransferLen = sizeof(szBuffer);

    configRet = PNP_GetDeviceRegProp(
        hBinding,
        InstancePath,
        CM_DRP_FRIENDLYNAME,
        &ulRegDataType,
        (LPBYTE) szBuffer,
        &ulTransferLen,
        &ulLength,
        0
        );

    if (configRet != CR_SUCCESS || !*szBuffer) {

        //
        // Try the registry for DEVICEDESC
        //
        ulLength = ulTransferLen = sizeof(szBuffer);

        configRet = PNP_GetDeviceRegProp(
            hBinding,
            InstancePath,
            CM_DRP_DEVICEDESC,
            &ulRegDataType,
            (LPBYTE) szBuffer,
            &ulTransferLen,
            &ulLength,
            0
            );

        if (configRet != CR_SUCCESS || !*szBuffer) {

            //
            // Initialize ClassGuid to GUID_NULL
            //
            CopyMemory(&classGuid, &GUID_NULL, sizeof(GUID));

            //
            // Try the registry for CLASSNAME
            //
            ulLength = ulTransferLen = sizeof(szBuffer);

            configRet = PNP_GetDeviceRegProp(
                hBinding,
                InstancePath,
                CM_DRP_CLASSGUID,
                &ulRegDataType,
                (LPBYTE) szBuffer,
                &ulTransferLen,
                &ulLength,
                0
                );

            if (configRet == CR_SUCCESS) {

                GuidFromString(szBuffer, &classGuid);
            }

            if (!IsEqualGUID(&classGuid, &GUID_NULL) &&
                !IsEqualGUID(&classGuid, &GUID_DEVCLASS_UNKNOWN)) {

                ulLength = ulTransferLen = sizeof(szBuffer);

                configRet = PNP_GetDeviceRegProp(
                    hBinding,
                    InstancePath,
                    CM_DRP_CLASS,
                    &ulRegDataType,
                    (LPBYTE) szBuffer,
                    &ulTransferLen,
                    &ulLength,
                    0
                    );

            } else {

                configRet = CR_NO_SUCH_VALUE;
            }
        }
    }

    if (configRet == CR_SUCCESS && *szBuffer) {

        friendlyName = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulLength);
        if (friendlyName) {

            memcpy(friendlyName, szBuffer, ulLength);
        }

    } else {

        friendlyName = NULL;
    }

    return friendlyName;
}

ENUM_ACTION
QueueInstallationCallback(
    IN      LPCWSTR         DevInst,
    IN OUT  PVOID           Context
    )
/*++

Routine Description:

    This routine is called back for each devnode in a given subtree. It places
    each device node in that subtree into the installation queue so that it'll
    be reinstalled *if* appropriate (the installation side code checked the
    state of the devnode.)
    
Arguments:

    DevInst     InstancePath of current devnode.

    Context     A pointer to QI_CONTEXT data (needed to handle the single-level
                enum case.)

Return Value:

    ENUM_ACTION (Either EA_CONTINUE, EA_SKIP_SUBTREE, or EA_STOP_ENUMERATION)

--*/
{
    PQI_CONTEXT pqiContext;
    PPNP_INSTALL_ENTRY entry, current;
    CONFIGRET status;
    BOOL needsReinstall;

    pqiContext = (PQI_CONTEXT) Context;

    status = DevInstNeedsInstall(DevInst, &needsReinstall);

    if (status != CR_SUCCESS) {

        //
        // The devnode disappeared out from under us. Skip it's subtree.
        //
        return EA_SKIP_SUBTREE;
    }

    if (needsReinstall) {

        //
        // This devnode needs installation. Allocate and initialize a new
        // device install entry block.
        //
        entry = HeapAlloc(ghPnPHeap, 0, sizeof(PNP_INSTALL_ENTRY));
        if (!entry) {

            pqiContext->Status = CR_OUT_OF_MEMORY;
            return EA_STOP_ENUMERATION;
        }

        lstrcpy(entry->szDeviceId, DevInst);
        entry->Next = NULL;
        entry->Flags = 0;

        //
        // Insert this entry in the device install list.
        //
        LockNotifyList(&InstallList.Lock);

        current = (PPNP_INSTALL_ENTRY)InstallList.Next;
        if (current == NULL) {
            InstallList.Next = entry;
        } else {
            while ((PPNP_INSTALL_ENTRY)current->Next != NULL) {
                current = (PPNP_INSTALL_ENTRY)current->Next;
            }
            current->Next = entry;
        }

        UnlockNotifyList(&InstallList.Lock);

        SetEvent(InstallEvents[NEEDS_INSTALL_EVENT]);

        //
        // You might think we could skip the children if a parent is going to
        // be reinstalled. However, setupapi might decide not to tear down the
        // stack.
        //
    }

    //
    // If this is a single-level enumeration, we only want to touch the parent
    // and his immediate children.
    //
    if (pqiContext->HeadNodeSeen && pqiContext->SingleLevelEnumOnly) {

        return EA_SKIP_SUBTREE;
    }

    pqiContext->HeadNodeSeen = TRUE;
    return EA_CONTINUE;
}


CONFIGRET
DevInstNeedsInstall(
    IN  LPCWSTR     DevInst,
    OUT BOOL       *NeedsInstall
    )
/*++

Routine Description:

    This routine determines whether a particular DevInst needs to be passed off
    to Setupapi for installation.

Arguments:

    DevInst         InstancePath of devnode to check.

    NeedsInstall    Recieves TRUE if the devnode is present and needs to be
                    installed, FALSE otherwise.

Return Value:

    CONFIGRET (if the devnode isn't present, this will be CR_NO_SUCH_DEVINST.)

--*/
{
    CONFIGRET status;
    ULONG ulStatus, ulProblem, ulConfig;

    //
    // Preinit
    //
    *NeedsInstall = FALSE;

    //
    // Is the device present?
    //
    status = GetDeviceStatus(DevInst, &ulStatus, &ulProblem);

    if (status == CR_SUCCESS) {

        //
        // Implementation note: In kernel-mode when we first process this
        // device instance, if there is no ConfigFlag value present, then we
        // set a problem of CM_PROB_NOT_CONFIGURED (this would always happen
        // for brand new device instances). If there is already a ConfigFlag
        // value of CONFIGFLAG_REINSTALL, then we set a problem of
        // CM_PROB_REINSTALL. Either problem will trigger an installation of
        // this device, the only difference is in how SetupDi routines handle
        // a failed installation: If ConfigFlag is CONFIGFLAG_NOT_CONFIGURED,
        // then a failed install will leave the ConfigFlag alone and set a
        // problem of CM_PROB_FAILED_INSTALL. If there is no ConfigFlag, then
        // ConfigFlag will be set to CONFIGFLAG_DISABLED.
        //
        ulConfig = GetDeviceConfigFlags(DevInst, NULL);

        if((ulConfig & CONFIGFLAG_FINISH_INSTALL) ||
            ((ulStatus & DN_HAS_PROBLEM) &&
             ((ulProblem == CM_PROB_REINSTALL) || (ulProblem == CM_PROB_NOT_CONFIGURED)))) {

            *NeedsInstall = TRUE;
        }
    } else if (!lstrcmpi(DevInst, REGSTR_VAL_ROOT_DEVNODE)) {

        status = CR_SUCCESS;
    }

    return status;
}



PWSTR
BuildBlockedDriverList(
    IN OUT LPGUID  GuidList,
    IN     ULONG   GuidCount
    )
/*++

Routine Description:

    This routine builds a multi-sz list of GUIDs, based on the array of GUIDs
    supplied.  If no GUIDs were supplied, this routine returns a list of all
    drivers currently blocked by the system.

Arguments:

    GuidList - Address of the array of blocked driver GUIDs to create the
               multi-sz list from.  This argument may be NULL to retrieve a
               list of all drivers currently blocked by the system.

    GuidCount - Specifies the number of GUIDs in the array.  If GuidList is
                NULL, this argument must be 0.

Return Value:

    Returns a MultiSz list of blocked driver GUIDs, based on the supplied
    parameters.  Returns NULL if no GUIDs were supplied, and no GUIDs are
    currently being blocked by the system.

    If a multi-sz list was returned, the caller is responsible for freeing the
    associated buffer.

--*/

{
    CONFIGRET Status = STATUS_SUCCESS;
    ULONG ulLength, ulTemp;
    PBYTE Buffer = NULL;
    PWSTR MultiSzList = NULL, p;

    try {
        //
        // Validate parameters.
        //
        if (((!ARGUMENT_PRESENT(GuidList)) && (GuidCount != 0)) ||
            ((ARGUMENT_PRESENT(GuidList))  && (GuidCount == 0))) {
            Status = CR_FAILURE;
            goto Clean0;
        }

        if (GuidCount == 0) {
            //
            // We were called without a list of GUIDs, so we need to get the
            // list ourselves.
            //
            ASSERT(!ARGUMENT_PRESENT(GuidList));

            ulLength = 0;
            ulTemp = 0;

            Status = PNP_GetBlockedDriverInfo(
                NULL,
                NULL,
                &ulTemp,
                &ulLength,
                0);

            //
            // If no drivers are currently being blocked, or we encountered some
            // other failure, we have nothing to display, so just return.
            //
            if ((Status != CR_BUFFER_SMALL) || (ulLength == 0)) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Allocate a buffer to retrieve the list of GUIDs.
            //
            Buffer = HeapAlloc(ghPnPHeap, 0, ulLength);
            if (Buffer == NULL) {
                Status = CR_FAILURE;
                goto Clean0;
            }

            //
            // Get the list of GUIDs for currently blocked drivers.
            //
            ulTemp = 0;

            Status = PNP_GetBlockedDriverInfo(
                NULL,
                Buffer,
                &ulTemp,
                &ulLength,
                0);

            //
            // We thought there was a list when we checked before, so we better
            // have one now.
            //
            ASSERT(Status != CR_BUFFER_SMALL);
            ASSERT(ulLength != 0);
            ASSERT(ulTemp != 0);

            if (Status != CR_SUCCESS) {
                goto Clean0;
            }

            //
            // Use the list we just retrieved.  Note that Buffer is non-NULL
            // when we allocate our own buffer for the array, so make sure we
            // free it below.
            //
            GuidCount = ulLength / sizeof(GUID);
            GuidList = (LPGUID)Buffer;
        }

        //
        // We must have a list of GUIDs to convert by this point.
        //
        ASSERT(GuidCount > 0);
        ASSERT(GuidList != NULL);

        //
        // Allocate a buffer to hold the multi-sz list of stringified GUIDs.
        //
        ulLength = (GuidCount*MAX_GUID_STRING_LEN + 1) * sizeof(WCHAR);

        MultiSzList = HeapAlloc(ghPnPHeap, 0, ulLength);
        if (MultiSzList == NULL) {
            Status = CR_FAILURE;
            goto Clean0;
        }
        ZeroMemory(MultiSzList, ulLength);

        //
        // Traverse the list of GUIDs, converting to strings as we go.
        //
        for (p = MultiSzList, ulTemp = 0;
             ulTemp < GuidCount;
             ulTemp++, p+= lstrlen(p) + 1) {

            if (StringFromGuid(
                (LPGUID)&(GuidList[ulTemp]), p,
                ((ulLength/sizeof(WCHAR)) - (ULONG)(p - MultiSzList))) != NO_ERROR) {
                Status = CR_FAILURE;
                goto Clean0;
            }
        }
        *p = L'\0';

        //
        // Success!!
        //
        Status = CR_SUCCESS;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: Exception in BuildBlockedDriverList!\n"));
        ASSERT(0);
        Status = CR_FAILURE;

        //
        // Reference the following variables so the compiler will respect
        // statement ordering w.r.t. their assignment.
        //
        Buffer = Buffer;
        MultiSzList = MultiSzList;
    }

    //
    // Free the GUID list buffer, if we allocated one.
    //
    if (Buffer != NULL) {
        HeapFree(ghPnPHeap, 0, Buffer);
    }

    //
    // Don't return a list if we were unsuccessful.
    //
    if ((Status != CR_SUCCESS) && (MultiSzList != NULL)) {
        HeapFree(ghPnPHeap, 0, MultiSzList);
        MultiSzList = NULL;
    }

    return MultiSzList;

} // BuildBlockedDriverList

CONFIGRET
PNP_GetServerSideDeviceInstallFlags(
    IN handle_t     hBinding,
    PULONG          pulSSDIFlags,
    ULONG           ulFlags
    )

/*++

Routine Description:

   This is the RPC server entry point for the CMP_GetServerSideDeviceInstallFlags
   routine.

Arguments:

   hBinding        - RPC binding handle, not used.

   pulSSDIFlags    - A ULONG pointer, supplied by the caller.  This is used
                     to pass back the following server side device install
                     flags:
   
                     SSDI_REBOOT_PENDING - A reboot is pending from a server
                                           side device install.
   
   ulFlags           Not used, must be zero.

Return Value:

    Return CR_SUCCESS if the function succeeds, otherwise it returns one of the
    CR_* errors.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Validate parameters
        //
        if (!ARGUMENT_PRESENT(pulSSDIFlags)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        *pulSSDIFlags = 0;

        //
        // SSDI_REBOOT_PENDING
        // Determine if a server side device install reboot is pending.
        //
        if (gServerSideDeviceInstallRebootNeeded) {
            *pulSSDIFlags |= SSDI_REBOOT_PENDING;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
    }

    return Status;
} // PNP_GetServerSideDeviceInstallFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rlogconf.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    rlogconf.c

Abstract:

    This module contains the server-side logical configuration APIs.

                  PNP_AddEmptyLogConf
                  PNP_FreeLogConf
                  PNP_GetFirstLogConf
                  PNP_GetNextLogConf
                  PNP_GetLogConfPriority

Author:

    Paula Tomlinson (paulat) 9-27-1995

Environment:

    User-mode only.

Revision History:

    27-Sept-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"


//
// Prototypes used in this routine and in rresdes.c
//
CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    );

PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    );

PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    );

//
// Prototypes from rresdes.c
//

BOOL
FindLogConf(
    IN  LPBYTE  pList,
    OUT LPBYTE  *ppLogConf,
    IN  ULONG   RegDataType,
    IN  ULONG   ulTag
    );

PIO_RESOURCE_DESCRIPTOR
AdvanceRequirementsDescriptorPtr(
    IN  PIO_RESOURCE_DESCRIPTOR pReqDesStart,
    IN  ULONG                   ulIncrement,
    IN  ULONG                   ulRemainingRanges,
    OUT PULONG                  pulRangeCount
    );

//
// private prototypes
//

BOOL
MigrateObsoleteDetectionInfo(
    IN LPWSTR   pszDeviceID,
    IN HKEY     hLogConfKey
    );


//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY



CONFIGRET
PNP_AddEmptyLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulPriority,
    OUT PULONG     pulTag,
    IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine adds
  an empty logical configuration.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    ulPriority    Priority for new log conf.

    pulTag        Returns tag that identifies which log config this is.

    ulFlags       Describes type of log conf to add.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    LPBYTE      pList = NULL;
    ULONG       Index = 0, ulListSize = 0, ulAddListSize = 0;
    ULONG       RegDataType = 0;

    //------------------------------------------------------------------
    // The BOOT, ALLOC, and FORCED config types are stored in a registry
    // value name of the format XxxConfig and the BASIC, FILTERED, and
    // OVERRIDE configs are stored in a registr value name of the format
    // XxxConfigVector. XxxConfig values contain the actual resource
    // description (REG_RESOURCE_LIST, CM_RESOURCE_LIST) while
    // XxxConfigVector values contain a list of resource requirements
    // (REG_RESOURCE_REQUIREMENTS_LIST, IO_RESOURCE_REQUIREMENTS_LIST).
    //
    // The policy for using the log conf and res des APIs is:
    // - BOOT, ALLOC, and FORCED are defined to only have one log conf.
    // - Although callers always specify a complete XXX_RESOURCE type
    //   structure for the data when adding resource descriptors to
    //   a log conf, I will ignore the resource specific portion of
    //   the XXX_DES structure for FILTERED, BASIC, and OVERRIDE.
    //   Likewise I will ignore any XXX_RANGE structures for ALLOC,
    //   BOOT or FORCED log config types.
    //------------------------------------------------------------------

    try {
        //
        // verify client access
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS | PRIORITY_BIT)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, ulFlags & LOG_CONF_BITS, &hKey);
        if (Status != CR_SUCCESS) {
            goto Clean0;
        }

        MigrateObsoleteDetectionInfo(pDeviceID, hKey);

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulFlags & LOG_CONF_BITS,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        //-----------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-----------------------------------------------------------

        if (RegDataType == REG_RESOURCE_LIST) {

            if (Status != CR_SUCCESS || ulListSize == 0) {
                //
                // This is the first log conf of this type: create a new
                // log conf with an empty res des.
                //
                PCM_RESOURCE_LIST pResList = NULL;

                Status = CR_SUCCESS;
                ulListSize = sizeof(CM_RESOURCE_LIST) -
                             sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                pList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulListSize);
                if (pList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                //
                // initialize the config list header info
                //
                pResList = (PCM_RESOURCE_LIST)pList;
                pResList->Count = 1;
                pResList->List[0].InterfaceType                = InterfaceTypeUndefined;
                pResList->List[0].BusNumber                    = 0;
                pResList->List[0].PartialResourceList.Version  = NT_RESLIST_VERSION;
                pResList->List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
                pResList->List[0].PartialResourceList.Count    = 0;

            } else {
                //
                // There is already at least one log conf of this type, so add
                // a new empty log conf to the log conf list (priority ignored)
                //
                PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
                PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

                //
                // realloc the existing log conf list structs to hold another
                // log conf
                //
                ulAddListSize = sizeof(CM_FULL_RESOURCE_DESCRIPTOR) -
                                sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                pResList = (PCM_RESOURCE_LIST)HeapReAlloc(ghPnPHeap, 0, pResList,
                                                      ulListSize + ulAddListSize);
                if (pResList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pResList;

                //
                // Priorities are ignored for resource lists, so just add any
                // subsequent log confs to the end (they will be ignored by the
                // system anyway).
                //
                pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
                for (Index = 0; Index < pResList->Count; Index++) {
                    pRes = AdvanceResourcePtr(pRes);        // next lc
                }

                //
                // initialize the new empty log config
                //
                pResList->Count++;
                pRes->InterfaceType                = InterfaceTypeUndefined;
                pRes->BusNumber                    = 0;
                pRes->PartialResourceList.Version  = NT_RESLIST_VERSION;
                pRes->PartialResourceList.Revision = NT_RESLIST_REVISION;
                pRes->PartialResourceList.Count    = 0;

                *pulTag = Index;
            }
        }

        //-----------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-----------------------------------------------------------
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            if (Status != CR_SUCCESS || ulListSize == 0) {
                //
                // This is the first log conf of this type: create a new
                // log conf (IO_RESOURCE_LIST) with a single res des
                // (IO_RESOURCE_DESCRIPTOR) for the config data.
                //
                PIO_RESOURCE_REQUIREMENTS_LIST pReqList = NULL;
                PIO_RESOURCE_LIST              pReq = NULL;

                Status = CR_SUCCESS;
                ulListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST);

                pReqList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, ulListSize);
                if (pReqList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pReqList;

                //
                // initialize the config list header info
                //
                // There's room for one IO_RESOURCE_DESCRIPTOR embedded in
                // the IO_RESOURCE_LIST structure and by definition the first
                // one is a ConfigData type descriptor (user-mode always
                // specifies a priority value so we always have a ConfigData
                // struct).
                //
                pReqList->ListSize         = ulListSize;
                pReqList->InterfaceType    = InterfaceTypeUndefined;
                pReqList->BusNumber        = 0;
                pReqList->SlotNumber       = 0;
                pReqList->AlternativeLists = 1;

                pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]); // first lc
                pReq->Version  = NT_REQLIST_VERSION;
                pReq->Revision = NT_REQLIST_REVISION;
                pReq->Count    = 1;

                pReq->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
                pReq->Descriptors[0].Type = CmResourceTypeConfigData;
                pReq->Descriptors[0].u.ConfigData.Priority = ulPriority;

            } else {
                //
                // There is already at least one log conf of this type, so add
                // a new empty log conf to the log conf list (always at the end)
                //
                PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
                PIO_RESOURCE_LIST              pReq = NULL;

                //
                // realloc the existing log conf list structs to hold another
                // log conf
                //
                ulAddListSize = sizeof(IO_RESOURCE_LIST);

                pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)HeapReAlloc(ghPnPHeap, 0, pReqList,
                                                                   ulListSize + ulAddListSize);
                if (pReqList == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }
                pList = (LPBYTE)pReqList;

                //
                // Skip past all the existing log confs to the new space at the
                // end of the reallocated buffer.
                //
                pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]); // first lc
                for (Index = 0; Index < pReqList->AlternativeLists; Index++) {
                    pReq = AdvanceRequirementsPtr(pReq);        // next lc
                }

                //
                // initialize the new empty log config (including the embedded
                // ConfigData structure).
                //
                pReqList->AlternativeLists++;
                pReqList->ListSize = ulListSize + ulAddListSize;

                pReq->Version  = NT_REQLIST_VERSION;
                pReq->Revision = NT_REQLIST_REVISION;
                pReq->Count    = 1;

                memset(&pReq->Descriptors[0], 0, sizeof(IO_RESOURCE_DESCRIPTOR));
                pReq->Descriptors[0].Option = IO_RESOURCE_PREFERRED;
                pReq->Descriptors[0].Type = CmResourceTypeConfigData;
                pReq->Descriptors[0].u.ConfigData.Priority = ulPriority;

                *pulTag = Index;
            }

        } else {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // Write out the new/updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType,
                          pList, ulListSize + ulAddListSize)
                         != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_AddEmptyLogConf



CONFIGRET
PNP_FreeLogConf(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      ulType,
    IN ULONG      ulTag,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine frees a
  logical configuration.

Arguments:

    hBinding      RPC binding handle.

    pDeviceID     Null-terminated device instance id string.

    ulType        Identifies which type of log conf is requested.

    ulTag         Identifies which log conf from the specified type
                  of log conf we want.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    LPBYTE      pList = NULL, pTemp = NULL, pNext = NULL;
    ULONG       RegDataType = 0, Index = 0, ulListSize = 0, ulSize = 0;

    try {
        //
        // verify client access
        //
        if (!VerifyClientAccess(hBinding, &gLuidLoadDriverPrivilege)) {
            Status = CR_ACCESS_DENIED;
            goto Clean0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        //
        // make sure original caller didn't specify root devnode (this
        // can't happen but Win95 does the check anyway)
        //
        if (!IsLegalDeviceId(pDeviceID) || IsRootDeviceID(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            //
            // if the device id or LogConf subkey is not in registry,
            // that's okay, by definition the log conf is freed since it
            // doesn't exist
            //
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // If the log conf to free is the one and only log conf of this
        // type then delete the corresponding registry values
        //
        if ((RegDataType == REG_RESOURCE_LIST &&
            ((PCM_RESOURCE_LIST)pList)->Count <= 1) ||
            (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST &&
            ((PIO_RESOURCE_REQUIREMENTS_LIST)pList)->AlternativeLists <= 1)) {

            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_REGISTRY,
                       "PNP_FreeLogConf: Deleting Value %ws from Device %ws\r\n",
                       szValueName,
                       pDeviceID));

            RegDeleteValue(hKey, szValueName);
            goto Clean0;
        }

        //
        // There are other log confs besides the one to delete, so I'll
        // have to remove the log conf from the data structs and resave
        // to the registry
        //

        //-----------------------------------------------------------
        // Specified log conf type contains Resource Data only
        //-----------------------------------------------------------
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST            pResList = (PCM_RESOURCE_LIST)pList;
            PCM_FULL_RESOURCE_DESCRIPTOR pRes = NULL;

            if (ulTag >= pResList->Count) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // skip to the log conf to be deleted
            //
            pRes = (PCM_FULL_RESOURCE_DESCRIPTOR)(&pResList->List[0]); // first lc
            for (Index = 0; Index < ulTag; Index++) {
                pRes = AdvanceResourcePtr(pRes);      // next lc
            }

            if (ulTag == pResList->Count-1) {
                //
                // If deleting the last log conf in the list, just truncate it
                //
                ulListSize = (ULONG)((ULONG_PTR)pRes - (ULONG_PTR)pResList);

            } else {
                //
                // Shift remaining log confs (after the log conf to be deleted)
                // up in the list, writing over the log conf to be deleted
                //
                pNext = (LPBYTE)AdvanceResourcePtr(pRes);
                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pResList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);     // save in temp buffer
                memcpy(pRes, pTemp, ulSize);      // copy to deleted lc
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pRes);
            }

            //
            // update the log conf list header
            //
            pResList->Count--;
        }

        //-----------------------------------------------------------
        // Specified log conf type contains requirements data only
        //-----------------------------------------------------------
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;
            PIO_RESOURCE_LIST              pReq = NULL;

            if (ulTag >= pReqList->AlternativeLists) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // skip to the log conf to be deleted
            //
            pReq = (PIO_RESOURCE_LIST)(&pReqList->List[0]);    // first lc
            for (Index = 0; Index < ulTag; Index++) {
                pReq = AdvanceRequirementsPtr(pReq);           // next lc
            }

            //
            // If there's any log confs after the log conf that will be deleted,
            // then write them over the top of the log conf we're deleting and
            // truncate any left over data.
            //
            pNext = (LPBYTE)AdvanceRequirementsPtr(pReq);
            if (ulListSize > ((DWORD_PTR)pNext - (DWORD_PTR)pReqList)) {

                ulSize = ulListSize - (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReqList);

                pTemp = HeapAlloc(ghPnPHeap, 0, ulSize);
                if (pTemp == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                memcpy(pTemp, pNext, ulSize);     // save in temp buffer
                memcpy(pReq, pTemp, ulSize);      // copy to deleted lc
                ulListSize -= (DWORD)((ULONG_PTR)pNext - (ULONG_PTR)pReq);

            } else {
                //
                // No log confs trailing the log conf to be deleted so just
                // truncate it.
                //
                ulListSize = (ULONG)((ULONG_PTR)pReq - (ULONG_PTR)pReqList);
            }

            //
            // update the log conf list header
            //
            pReqList->AlternativeLists--;
            pReqList->ListSize = ulListSize;
        }

        //
        // Write out the updated log conf list to the registry
        //
        if (RegSetValueEx(hKey, szValueName, 0, RegDataType, pList,
                          ulListSize) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }
    if (pTemp != NULL) {
        HeapFree(ghPnPHeap, 0, pTemp);
    }

    return Status;

} // PNP_FreeLogConf



CONFIGRET
PNP_GetFirstLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulType,
    OUT PULONG     pulTag,
    IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine finds the
  first log conf of this type for this devnode.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Describes the type of log conf to find.

    pulTag        Returns tag that identifies which log config this is.

    ulFlags       Not used (but may specify LOG_CONF_BITS).

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    LPBYTE      pList = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters. The index of the "first" lc will always
        // be zero as long as at least one lc exists.
        //
        if (!ARGUMENT_PRESENT(pulTag)) {
            Status = CR_INVALID_POINTER;
        } else {
            *pulTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, LOG_CONF_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_NO_MORE_LOG_CONF;
            goto Clean0;
        }

        //
        // Migrate any log conf data that might have been written to
        // registry by NT 4.0 Beta I code.
        //
        MigrateObsoleteDetectionInfo(pDeviceID, hKey);

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
            Status = CR_NO_MORE_LOG_CONF;
            goto Clean0;
        }

        //
        // Specified log conf type contains Resource Data only
        //
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST pResList = (PCM_RESOURCE_LIST)pList;

            if (pResList->Count == 0) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // Specified log conf type contains requirements data only
        //
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;

            if (pReqList->AlternativeLists == 0) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetFirstLogConf



CONFIGRET
PNP_GetNextLogConf(
    IN  handle_t   hBinding,
    IN  LPWSTR     pDeviceID,
    IN  ULONG      ulType,
    IN  ULONG      ulCurrentTag,
    OUT PULONG     pulNextTag,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine finds the
  next log conf of this type for this devnode.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Specifies what type of log conf to retrieve.

    ulCurrent     Specifies current log conf in the enumeration.

    pulNext       Returns next log conf of this type for this device id.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0;
    LPBYTE      pList = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pulNextTag)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pulNextTag = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
           Status = CR_NO_MORE_LOG_CONF;
           goto Clean0;
        }

        //
        // Specified log conf type contains Resource Data only
        //
        if (RegDataType == REG_RESOURCE_LIST) {

            PCM_RESOURCE_LIST pResList = (PCM_RESOURCE_LIST)pList;

            if (ulCurrentTag >= pResList->Count) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // Is the "current" log conf the last log conf?
            //
            if (ulCurrentTag == pResList->Count - 1) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // Specified log conf type contains requirements data only
        //
        else if (RegDataType == REG_RESOURCE_REQUIREMENTS_LIST) {

            PIO_RESOURCE_REQUIREMENTS_LIST pReqList = (PIO_RESOURCE_REQUIREMENTS_LIST)pList;

            if (ulCurrentTag >= pReqList->AlternativeLists) {
                Status = CR_INVALID_LOG_CONF;
                goto Clean0;
            }

            //
            // Is the "current" log conf the last log conf?
            //
            if (ulCurrentTag == pReqList->AlternativeLists - 1) {
                Status = CR_NO_MORE_LOG_CONF;
                goto Clean0;
            }
        }

        //
        // There's at least one more log conf, return the next index value
        //
        *pulNextTag = ulCurrentTag + 1;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetNextLogConf



CONFIGRET
PNP_GetLogConfPriority(
    IN  handle_t hBinding,
    IN  LPWSTR   pDeviceID,
    IN  ULONG    ulType,
    IN  ULONG    ulTag,
    OUT PULONG   pPriority,
    IN  ULONG    ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  priority value assigned to the specified log config.

Arguments:

    hBinding      RPC binding handle, not used.

    pDeviceID     Null-terminated device instance id string.

    ulType        Specifies what type of log conf to retrieve priority for.

    ulCurrent     Specifies current log conf in the enumeration.

    pulNext       Returns priority value of specified log conf.

    ulFlags       Not used, must be zero.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;
    WCHAR       szValueName[64];
    ULONG       RegDataType = 0, ulListSize = 0, index, count;
    LPBYTE      pList = NULL, pLogConf = NULL, pRD = NULL;
    PIO_RESOURCE_REQUIREMENTS_LIST pReqList = NULL;
    PIO_RESOURCE_LIST              pReq = NULL;
    PIO_RESOURCE_DESCRIPTOR        pReqDes = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // Initialize output parameters
        //
        if (!ARGUMENT_PRESENT(pPriority)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        } else {
            *pPriority = 0;
        }

        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the device's LogConf subkey. If the device id is not
        // in the registry, the devnode doesn't exist and therefore neither
        // does the log conf
        //
        Status = OpenLogConfKey(pDeviceID, ulType, &hKey);
        if (Status != CR_SUCCESS) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Retrieve log conf data from the registry
        //
        Status = GetLogConfData(hKey, ulType,
                                &RegDataType, szValueName,
                                &pList, &ulListSize);

        if (Status != CR_SUCCESS) {
           Status = CR_INVALID_LOG_CONF;
           goto Clean0;
        }

        //
        // Priority values are only stored in requirements lists
        //
        if (RegDataType != REG_RESOURCE_REQUIREMENTS_LIST) {
            Status = CR_INVALID_LOG_CONF;
            goto Clean0;
        }

        //
        // Seek to the log conf that matches the log conf tag
        //
        if (!FindLogConf(pList, &pLogConf, RegDataType, ulTag)) {
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }

        //
        // Seek to the ConfigData res des, if any.
        //
        pReq = (PIO_RESOURCE_LIST)pLogConf;
        pReqDes = &pReq->Descriptors[0];        // first rd

        index = 0;
        count = 0;
        while (index < pReq->Count && pReqDes != NULL &&
               pReqDes->Type != CmResourceTypeConfigData) {

            pReqDes = AdvanceRequirementsDescriptorPtr(pReqDes, 1, pReq->Count - index, &count);
            index += count;  // index of actual rd's in the struct
        }

        if (pReqDes == NULL || pReqDes->Type != CmResourceTypeConfigData) {
            //
            // No config data so we can't determine the priority.
            //
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;

        }

        *pPriority = pReqDes->u.ConfigData.Priority;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pList != NULL) {
        HeapFree(ghPnPHeap, 0, pList);
    }

    return Status;

} // PNP_GetLogConfPriority




//------------------------------------------------------------------------
// Private Utility Routines
//------------------------------------------------------------------------


CONFIGRET
GetLogConfData(
    IN  HKEY    hKey,
    IN  ULONG   ulLogConfType,
    OUT PULONG  pulRegDataType,
    OUT LPWSTR  pszValueName,
    OUT LPBYTE  *ppBuffer,
    OUT PULONG  pulBufferSize
    )
{
    switch (ulLogConfType) {
        //
        // BOOT, ALLOC, FORCED only have a Config value
        //
        case BOOT_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueBootConfig);
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        case ALLOC_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueAllocConfig);
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        case FORCED_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueForcedConfig);
            *pulRegDataType = REG_RESOURCE_LIST;
            break;

        //
        // FILTERED, BASIC, OVERRIDE only have a Vector value
        //
        case FILTERED_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueFilteredVector);
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        case BASIC_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueBasicVector);
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        case OVERRIDE_LOG_CONF:
            lstrcpy(pszValueName, pszRegValueOverrideVector);
            *pulRegDataType = REG_RESOURCE_REQUIREMENTS_LIST;
            break;

        default:
            return CR_FAILURE;
    }

    //
    // retrieve the Log Conf registry data
    //
    if (RegQueryValueEx(hKey, pszValueName, NULL, NULL, NULL,
                        pulBufferSize) != ERROR_SUCCESS) {
        return CR_INVALID_LOG_CONF;
    }

    *ppBuffer = HeapAlloc(ghPnPHeap, 0, *pulBufferSize);
    if (*ppBuffer == NULL) {
        return CR_OUT_OF_MEMORY;
    }

    if (RegQueryValueEx(hKey, pszValueName, NULL, NULL,
                        (LPBYTE)*ppBuffer, pulBufferSize) != ERROR_SUCCESS) {
        return CR_INVALID_LOG_CONF;
    }

    return CR_SUCCESS;

} // GetLogConfData



PCM_FULL_RESOURCE_DESCRIPTOR
AdvanceResourcePtr(
    IN  PCM_FULL_RESOURCE_DESCRIPTOR pRes
    )
{
    // Given a resource pointer, this routine advances to the beginning
    // of the next resource and returns a pointer to it. I assume that
    // at least one more resource exists in the resource list.

    LPBYTE  p = NULL;
    ULONG   LastResIndex = 0;


    if (pRes == NULL) {
        return NULL;
    }

    //
    // account for the size of the CM_FULL_RESOURCE_DESCRIPTOR
    // (includes the header plus a single imbedded
    // CM_PARTIAL_RESOURCE_DESCRIPTOR struct)
    //
    p = (LPBYTE)pRes + sizeof(CM_FULL_RESOURCE_DESCRIPTOR);

    //
    // account for any resource descriptors in addition to the single
    // imbedded one I've already accounted for (if there aren't any,
    // then I'll end up subtracting off the extra imbedded descriptor
    // from the previous step)
    //
    p += (pRes->PartialResourceList.Count - 1) *
         sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

    //
    // finally, account for any extra device specific data at the end of
    // the last partial resource descriptor (if any)
    //
    if (pRes->PartialResourceList.Count > 0) {

        LastResIndex = pRes->PartialResourceList.Count - 1;

        if (pRes->PartialResourceList.PartialDescriptors[LastResIndex].Type ==
                  CmResourceTypeDeviceSpecific) {

            p += pRes->PartialResourceList.PartialDescriptors[LastResIndex].
                       u.DeviceSpecificData.DataSize;
        }
    }

    return (PCM_FULL_RESOURCE_DESCRIPTOR)p;

} // AdvanceResourcePtr



PIO_RESOURCE_LIST
AdvanceRequirementsPtr(
    IN  PIO_RESOURCE_LIST   pReq
    )
{
    LPBYTE   p = NULL;

    if (pReq == NULL) {
        return NULL;
    }

    //
    // account for the size of the IO_RESOURCE_LIST (includes header plus
    // a single imbedded IO_RESOURCE_DESCRIPTOR struct)
    //
    p = (LPBYTE)pReq + sizeof(IO_RESOURCE_LIST);

    //
    // account for any requirements descriptors in addition to the single
    // imbedded one I've already accounted for (if there aren't any,
    // then I'll end up subtracting off the extra imbedded descriptor
    // from the previous step)
    //
    p += (pReq->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);

    return (PIO_RESOURCE_LIST)p;

} // AdvanceRequirementsPtr



BOOL
MigrateObsoleteDetectionInfo(
    IN LPWSTR   pszDeviceID,
    IN HKEY     hLogConfKey
    )
{
    LONG    RegStatus = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    ULONG   ulSize = 0;
    LPBYTE  ptr = NULL;
    PCM_RESOURCE_LIST               pResList = NULL;
    PPrivate_Log_Conf               pDetectData = NULL;

    //
    // First, delete any of the log conf pairs that aren't valid any more
    //
    RegDeleteValue(hLogConfKey, TEXT("BootConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("AllocConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("ForcedConfigVector"));
    RegDeleteValue(hLogConfKey, TEXT("BasicConfig"));
    RegDeleteValue(hLogConfKey, TEXT("FilteredConfig"));
    RegDeleteValue(hLogConfKey, TEXT("OverrideConfig"));

    //
    // open the device instance key in the registry
    //
    if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                     KEY_READ | KEY_WRITE, &hKey) != ERROR_SUCCESS) {
        goto Clean0;    // nothing to migrate
    }

    //
    // If there is already a boot log config value then we can't
    // migrate any old detect info
    //
    RegStatus = RegQueryValueEx(hLogConfKey, pszRegValueBootConfig,
                                NULL, NULL, NULL, &ulSize);

    if (RegStatus == ERROR_SUCCESS  &&  ulSize > 0) {
        goto Clean0;    // can't migrate
    }

    //
    // retrieve any old detect signature info
    //
    RegStatus = RegQueryValueEx(hKey, pszRegValueDetectSignature,
                                NULL, NULL, NULL, &ulSize);

    if ((RegStatus != ERROR_SUCCESS) || (ulSize == 0)) {
        goto Clean0;    // nothing to migrate
    }

    pDetectData = (PPrivate_Log_Conf)HeapAlloc(ghPnPHeap, 0, ulSize);

    if (pDetectData == NULL) {
        goto Clean0;    // insufficient memory
    }

    RegStatus = RegQueryValueEx(hKey, pszRegValueDetectSignature,
                                NULL, NULL, (LPBYTE)pDetectData, &ulSize);

    if ((RegStatus != ERROR_SUCCESS) || (ulSize == 0)) {
        goto Clean0;    // nothing to migrate
    }

    //
    // Create an empty boot log conf and add this class specific data
    // to it
    //
    ulSize = pDetectData->LC_CS.CS_Header.CSD_SignatureLength +
             pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize +
             sizeof(GUID);

    pResList = HeapAlloc(ghPnPHeap, HEAP_ZERO_MEMORY, sizeof(CM_RESOURCE_LIST) + ulSize);

    if (pResList == NULL) {
        goto Clean0;    // insufficient memory
    }

    //
    // initialize resource list
    //
    pResList->Count = 1;
    pResList->List[0].InterfaceType                = InterfaceTypeUndefined;
    pResList->List[0].BusNumber                    = 0;
    pResList->List[0].PartialResourceList.Version  = NT_RESLIST_VERSION;
    pResList->List[0].PartialResourceList.Revision = NT_RESLIST_REVISION;
    pResList->List[0].PartialResourceList.Count    = 1;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
                          CmResourceTypeDeviceSpecific;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                          CmResourceShareUndetermined;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                          (USHORT)pDetectData->LC_CS.CS_Header.CSD_Flags;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.DataSize = ulSize;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.Reserved1 =
                          pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize;
    pResList->List[0].PartialResourceList.PartialDescriptors[0].
                      u.DeviceSpecificData.Reserved2 =
                          pDetectData->LC_CS.CS_Header.CSD_SignatureLength;

    //
    // copy the legacy and class-specific signature data
    //
    ptr = (LPBYTE)(&pResList->List[0].PartialResourceList.PartialDescriptors[1]);

    memcpy(ptr,
           pDetectData->LC_CS.CS_Header.CSD_Signature +
           pDetectData->LC_CS.CS_Header.CSD_LegacyDataOffset,
           pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize);  // legacy data

    ptr += pDetectData->LC_CS.CS_Header.CSD_LegacyDataSize;

    memcpy(ptr,
           pDetectData->LC_CS.CS_Header.CSD_Signature,
           pDetectData->LC_CS.CS_Header.CSD_SignatureLength); // signature

    ptr += pDetectData->LC_CS.CS_Header.CSD_SignatureLength;

    memcpy(ptr,
           &pDetectData->LC_CS.CS_Header.CSD_ClassGuid,
           sizeof(GUID));                                     // GUID

    //
    // Write out the new/updated log conf list to the registry
    //
    RegSetValueEx(hLogConfKey, pszRegValueBootConfig, 0,
                  REG_RESOURCE_LIST, (LPBYTE)pResList,
                  ulSize + sizeof(CM_RESOURCE_LIST));

    //
    // Delete the old detect signature info
    //
    RegDeleteValue(hKey, pszRegValueDetectSignature);

 Clean0:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    if (pDetectData != NULL) {
        HeapFree(ghPnPHeap, 0, pDetectData);
    }
    if (pResList != NULL) {
        HeapFree(ghPnPHeap, 0, pResList);
    }

    return TRUE;

} // MigrateObsoleteDetectionInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rtravers.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rtravers.c

Abstract:

    This module contains the server-side hardware tree traversal APIs.

                  PNP_ValidateDeviceInstance
                  PNP_GetRootDeviceInstance
                  PNP_GetRelatedDeviceInstance
                  PNP_EnumerateSubKeys
                  PNP_GetDeviceList
                  PNP_GetDeviceListSize

Author:

    Paula Tomlinson (paulat) 6-19-1995

Environment:

    User-mode only.

Revision History:

    19-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"


//
// private prototypes
//

CONFIGRET
GetInstanceListSize(
    IN  LPCWSTR   pszDevice,
    OUT PULONG    pulLength
    );

CONFIGRET
GetInstanceList(
    IN     LPCWSTR   pszDevice,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    );

CONFIGRET
GetDeviceInstanceListSize(
    IN  LPCWSTR   pszEnumerator,
    OUT PULONG    pulLength
    );

CONFIGRET
GetDeviceInstanceList(
    IN     LPCWSTR   pszEnumerator,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    );

PNP_QUERY_RELATION
QueryOperationCode(
    ULONG ulFlags
    );


//
// global data
//
extern HKEY ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern HKEY ghClassKey;     // Key to HKLM\CCC\System\Class - NO NOT MODIFY




CONFIGRET
PNP_ValidateDeviceInstance(
    IN handle_t   hBinding,
    IN LPWSTR     pDeviceID,
    IN ULONG      ulFlags
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine verifies whether
  the specificed device instance is a valid device instance.

Arguments:

    hBinding         Not used.

    DeviceInstance   Null-terminated string that contains a device instance
                     to be validated.

    ulFlags          One of the CM_LOCATE_DEVNODE_* flags.

Return Value:

   If the specified device instance is valid, it returns CR_SUCCESS,
   otherwise it returns CR_ error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;
    ULONG       ulSize, ulValue, ulStatus = 0, ulProblem = 0;

    UNREFERENCED_PARAMETER(hBinding);

    //
    // assume that the device instance string was checked for proper form
    // before being added to the registry Enum tree
    //

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, CM_LOCATE_DEVNODE_BITS)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // open a key to the specified device id
        //
        if (RegOpenKeyEx(ghEnumKey, pDeviceID, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_NO_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // Will specify for now that a moved devinst cannot be located (we
        // could allow this if we wanted to).
        //
        if (IsDeviceMoved(pDeviceID, hKey)) {
            Status = CR_NO_SUCH_DEVINST;
            goto Clean0;
        }

        //
        // if we're locating a phantom devnode, it just has to exist
        // in the registry (the above check) and not already be a
        // phantom (private) devnode
        //
        if (ulFlags & CM_LOCATE_DEVNODE_PHANTOM) {
            //
            // verify that it's not a private phantom
            //
            ulSize = sizeof(ULONG);
            RegStatus = RegQueryValueEx(hKey, pszRegValuePhantom, NULL, NULL,
                                        (LPBYTE)&ulValue, &ulSize);

            if ((RegStatus == ERROR_SUCCESS) && ulValue) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }

        } else if (ulFlags & CM_LOCATE_DEVNODE_CANCELREMOVE) {
            //
            // In the CANCEL-REMOVE case, if the devnode has been removed,
            // (made volatile) then convert it back to nonvoatile so it
            // can be installed again without disappearing on the next
            // boot. If it's not removed, then just verify that it is
            // present.
            //

            //
            // verify that the device id is actually present
            //
            if (!IsDeviceIdPresent(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }

            //
            // Is this a device that is being removed on the next reboot?
            //
            if (GetDeviceStatus(pDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {

                if (ulStatus & DN_WILL_BE_REMOVED) {

                    ULONG ulProfile = 0, ulCount = 0;
                    WCHAR RegStr[MAX_CM_PATH];

                    //
                    // This device will be removed on the next reboot,
                    // convert to nonvolatile.
                    //
                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws non-volatile\n",
                               pDeviceID));

                    Status = MakeKeyNonVolatile(pszRegPathEnum, pDeviceID);
                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }

                    //
                    // Now make any keys that were "supposed" to be volatile
                    // back to volatile again!
                    //
                    wsprintf(RegStr, TEXT("%s\\%s"),
                             pszRegPathEnum,
                             pDeviceID);

                    KdPrintEx((DPFLTR_PNPMGR_ID,
                               DBGF_REGISTRY,
                               "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws\\%ws volatile\n",
                               RegStr,
                               pszRegKeyDeviceControl));

                    MakeKeyVolatile(RegStr, pszRegKeyDeviceControl);

                    //
                    // Also, convert any profile specific keys to nonvolatile
                    //
                    Status = GetProfileCount(&ulCount);
                    if (Status != CR_SUCCESS) {
                        goto Clean0;
                    }

                    for (ulProfile = 1; ulProfile <= ulCount; ulProfile++) {

                        wsprintf(RegStr, TEXT("%s\\%04u\\%s"),
                                 pszRegPathHwProfiles,
                                 ulProfile,
                                 pszRegPathEnum);

                        //
                        // Ignore the status for profile-specific keys since they may
                        // not exist.
                        //
                        KdPrintEx((DPFLTR_PNPMGR_ID,
                                   DBGF_REGISTRY,
                                   "UMPNPMGR: PNP_ValidateDeviceInstance make key %ws non-volatile\n",
                                   pDeviceID));

                        MakeKeyNonVolatile(RegStr, pDeviceID);
                    }

                    //
                    // clear the DN_WILL_BE_REMOVED flag
                    //
                    ClearDeviceStatus(pDeviceID, DN_WILL_BE_REMOVED, 0);
                }
            }
        }

        //
        // in the normal (non-phantom case), verify that the device id is
        // actually present
        //
        else  {
            //
            // verify that the device id is actually present
            //

            if (!IsDeviceIdPresent(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
                goto Clean0;
            }
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_ValidateDeviceInstance



CONFIGRET
PNP_GetRootDeviceInstance(
    IN  handle_t    hBinding,
    OUT LPWSTR      pDeviceID,
    IN  ULONG       ulLength
    )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  root device instance for the hardware tree.

Arguments:

    hBinding   Not used.

    pDeviceID  Pointer to a buffer that will hold the root device
               instance ID string.

    ulLength   Size of pDeviceID buffer in characters.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    HKEY        hKey = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // first validate that the root device instance exists
        //
        if (RegOpenKeyEx(ghEnumKey, pszRegRootEnumerator, 0, KEY_QUERY_VALUE,
                         &hKey) != ERROR_SUCCESS) {
            //
            // root doesn't exist, create root devinst
            //
            if (!CreateDeviceIDRegKey(ghEnumKey, pszRegRootEnumerator)) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }
        }

        //
        // return the root device instance id
        //
        if (ulLength < (ULONG)lstrlen(pszRegRootEnumerator)+1) {
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        lstrcpy(pDeviceID, pszRegRootEnumerator);

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // PNP_GetRootDeviceInstance



CONFIGRET
PNP_GetRelatedDeviceInstance(
      IN  handle_t   hBinding,
      IN  ULONG      ulRelationship,
      IN  LPWSTR     pDeviceID,
      OUT LPWSTR     pRelatedDeviceID,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns a
  device instance that is related to the specified device instance.

Arguments:

   hBinding          Not used.

   ulRelationship    Specifies the relationship of the device instance to
                     be retrieved (can be PNP_GET_PARENT_DEVICE_INSTANCE,
                     PNP_GET_CHILD_DEVICE_INSTANCE, or
                     PNP_GET_SIBLING_DEVICE_INSTANCE).

   pDeviceID         Pointer to a buffer that contains the base device
                     instance string.

   pRelatedDeviceID  Pointer to a buffer that will receive the related
                     device instance string.

   pulLength         Length (in characters) of the RelatedDeviceInstance
                     buffer.

   ulFlags           Not used, must be zero.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    PLUGPLAY_CONTROL_RELATED_DEVICE_DATA ControlData;
    CONFIGRET   Status = CR_SUCCESS;
    NTSTATUS    ntStatus;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate patameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pRelatedDeviceID) && (*pulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (*pulLength > 0) {
            *pRelatedDeviceID = L'\0';
        }

        if (!IsLegalDeviceId(pDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            if (*pulLength > 0) {
                *pulLength = 1;
            }
            goto Clean0;
        }

        //
        // initialize control data block
        //
        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));

        //
        // special case behavior for certain devices and relationships
        //
        switch (ulRelationship) {

        case PNP_GET_PARENT_DEVICE_INSTANCE:

            if (IsRootDeviceID(pDeviceID)) {
                //
                // This is the root (which has no parent by definition)
                //
                Status = CR_NO_SUCH_DEVINST;

            } else if (IsDevicePhantom(pDeviceID)) {

                //
                // Check if this is a phantom. Phantom devices don't have
                // a kernel-mode device node allocated yet, but during manual
                // install, the process calls for retrieving the parent. So we
                // just fake it out by returning the root in this case. For all
                // other cases, we only return the parent that the kernel-mode
                // device node indicates.
                //

                if ((ULONG)(lstrlen(pszRegRootEnumerator) + 1) > *pulLength) {
                    lstrcpyn(pRelatedDeviceID, pszRegRootEnumerator,*pulLength);
                    Status = CR_BUFFER_SMALL;
                } else {
                    lstrcpy(pRelatedDeviceID, pszRegRootEnumerator);
                }
                *pulLength = lstrlen(pszRegRootEnumerator) + 1;
                goto Clean0;
            }

            ControlData.Relation = PNP_RELATION_PARENT;
            break;

        case PNP_GET_CHILD_DEVICE_INSTANCE:
            ControlData.Relation = PNP_RELATION_CHILD;
            break;

        case PNP_GET_SIBLING_DEVICE_INSTANCE:
            //
            // first verify it isn't the root (which has no siblings by definition)
            //
            if (IsRootDeviceID(pDeviceID)) {
                Status = CR_NO_SUCH_DEVINST;
            }

            ControlData.Relation = PNP_RELATION_SIBLING;
            break;

        default:
            Status = CR_FAILURE;
        }

        if (Status == CR_SUCCESS) {
            //
            // Try to locate the relation from the kernel-mode in-memory
            // devnode tree.
            //

            RtlInitUnicodeString(&ControlData.TargetDeviceInstance, pDeviceID);
            ControlData.RelatedDeviceInstance = pRelatedDeviceID;
            ControlData.RelatedDeviceInstanceLength = *pulLength;

            ntStatus = NtPlugPlayControl(PlugPlayControlGetRelatedDevice,
                                         &ControlData,
                                         sizeof(ControlData));

            if (NT_SUCCESS(ntStatus)) {
                *pulLength = ControlData.RelatedDeviceInstanceLength + 1;
            } else {
                Status = MapNtStatusToCmError(ntStatus);
            }

        } else if (*pulLength > 0) {
            *pulLength = 1;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_GetRelatedDeviceInstance



CONFIGRET
PNP_EnumerateSubKeys(
    IN  handle_t   hBinding,
    IN  ULONG      ulBranch,
    IN  ULONG      ulIndex,
    OUT PWSTR      Buffer,
    IN  ULONG      ulLength,
    OUT PULONG     pulRequiredLen,
    IN  ULONG      ulFlags
    )

/*++

Routine Description:

    This is the RPC server entry point for the CM_Enumerate_Enumerators and
    CM_Enumerate_Classes.  It provides generic subkey enumeration based on
    the specified registry branch.

Arguments:

    hBinding       Not used.

    ulBranch       Specifies which keys to enumerate.

    ulIndex        Index of the subkey key to retrieve.

    Buffer         Supplies the address of the buffer that receives the
                   subkey name.

    ulLength       Specifies the max size of the Buffer in characters.

    pulRequired    On output it contains the number of characters actually
                   copied to Buffer if it was successful, or the number of
                   characters required if the buffer was too small.

    ulFlags        Not used, must be zero.

Return Value:

    If the function succeeds, it returns CR_SUCCESS, otherwise it returns
    a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    HKEY        hKey = NULL;

    UNREFERENCED_PARAMETER(hBinding);

    try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if ((!ARGUMENT_PRESENT(pulRequiredLen)) ||
            (!ARGUMENT_PRESENT(Buffer) && (ulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        if (ulLength > 0) {
            *Buffer = L'\0';
        }

        if (ulBranch == PNP_CLASS_SUBKEYS) {
            //
            // Use the global base CLASS registry key
            //
            hKey = ghClassKey;
        }
        else if (ulBranch == PNP_ENUMERATOR_SUBKEYS) {
            //
            // Use the global base ENUM registry key
            //
            hKey = ghEnumKey;
        }
        else {
            Status = CR_FAILURE;
            goto Clean0;
        }

        //
        // enumerate a subkey based on the passed in index value
        //
        *pulRequiredLen = ulLength;

        RegStatus = RegEnumKeyEx(hKey, ulIndex, Buffer, pulRequiredLen,
                                 NULL, NULL, NULL, NULL);
        *pulRequiredLen += 1;  // returned count doesn't include null terminator

        if (RegStatus == ERROR_MORE_DATA) {
            //
            // This is a special case, the RegEnumKeyEx routine doesn't return
            // the number of characters required to hold this string (just how
            // many characters were copied to the buffer (how many fit). I have
            // to use a different means to return that info back to the caller.
            //
            ULONG ulMaxLen = 0;
            PWSTR p = NULL;

            if (RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, &ulMaxLen,
                                NULL, NULL, NULL, NULL, NULL,
                                NULL) == ERROR_SUCCESS) {

                ulMaxLen += 1;  // returned count doesn't include null terminator

                p = HeapAlloc(ghPnPHeap, 0, ulMaxLen * sizeof(WCHAR));
                if (p == NULL) {
                    Status = CR_OUT_OF_MEMORY;
                    goto Clean0;
                }

                if (RegEnumKeyEx(hKey, ulIndex, p, &ulMaxLen, NULL, NULL, NULL,
                                 NULL) == ERROR_SUCCESS) {
                    *pulRequiredLen = ulMaxLen + 1;
                }

                HeapFree(ghPnPHeap, 0, p);
            }

            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }
        else if (RegStatus == ERROR_NO_MORE_ITEMS) {
            *pulRequiredLen = 0;
            Status = CR_NO_SUCH_VALUE;
            goto Clean0;
        }
        else if (RegStatus != ERROR_SUCCESS) {
            *pulRequiredLen = 0;
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    return Status;

} // PNP_EnumerateSubKeys



CONFIGRET
PNP_GetDeviceList(
      IN  handle_t   hBinding,
      IN  LPCWSTR    pszFilter,
      OUT LPWSTR     Buffer,
      IN OUT PULONG  pulLength,
      IN  ULONG      ulFlags
      )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns a
  list of device instances.

Arguments:

   hBinding          Not used.

   pszFilter         Optional parameter, controls which device ids are
                     returned.

   Buffer            Pointer to a buffer that will contain the multi_sz list
                     of device instance strings.

   pulLength         Size in characters of Buffer on input, size (in chars)
                     transferred on output

   ulFlags           Flag specifying which devices ids to return.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
   WCHAR       RegStr[MAX_CM_PATH];
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   LPWSTR      ptr = NULL;
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if ((!ARGUMENT_PRESENT(pulLength)) ||
          (!ARGUMENT_PRESENT(Buffer) && (*pulLength != 0))) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      if (*pulLength > 0) {
          *Buffer = L'\0';
      }

      //-----------------------------------------------------------
      // Query Device Relations filter - go through kernel-mode
      //-----------------------------------------------------------

      if ((ulFlags & CM_GETIDLIST_FILTER_EJECTRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_REMOVALRELATIONS) ||
          (ulFlags & CM_GETIDLIST_FILTER_POWERRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_BUSRELATIONS)) {

          memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_RELATED_DEVICE_DATA));
          RtlInitUnicodeString(&ControlData.DeviceInstance, pszFilter);
          ControlData.Operation = QueryOperationCode(ulFlags);
          ControlData.BufferLength = *pulLength;
          ControlData.Buffer = Buffer;

          ntStatus = NtPlugPlayControl(PlugPlayControlQueryDeviceRelations,
                                       &ControlData,
                                       sizeof(ControlData));

          if (NT_SUCCESS(ntStatus)) {
              *pulLength = ControlData.BufferLength;
          } else if (ntStatus == STATUS_BUFFER_TOO_SMALL) {
              *pulLength = 0;
              Status = MapNtStatusToCmError(ntStatus);
          }
          goto Clean0;
      }


      //---------------------------------------------------
      // Service filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_SERVICE) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         Status = GetServiceDeviceList(pszFilter, Buffer, pulLength, ulFlags);
         goto Clean0;
      }

      //---------------------------------------------------
      // Enumerator filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_ENUMERATOR) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         SplitDeviceInstanceString(
               pszFilter, szEnumerator, szDevice, szInstance);

         //
         // if both the enumerator and device were specified, retrieve
         // the device instances for this device
         //
         if (*szEnumerator != L'\0' && *szDevice != L'\0') {

            ptr = Buffer;
            Status = GetInstanceList(pszFilter, &ptr, pulLength);
         }

         //
         // if just the enumerator was specified, retrieve all the device
         // instances under this enumerator
         //
         else {
             ptr = Buffer;
             Status = GetDeviceInstanceList(pszFilter, &ptr, pulLength);
         }
      }

      //------------------------------------------------
      // No filtering
      //-----------------------------------------------

      else {

         //
         // return device instances for all enumerators (by enumerating
         // the enumerators)
         //
         // Open a key to the Enum branch
         //
         ulSize = ulBufferLen = *pulLength;     // total Buffer size
         *pulLength = 0;                        // nothing copied yet
         ptr = Buffer;                          // tail of the buffer
         ulIndex = 0;

         //
         //  Enumerate all the enumerators
         //
         while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars
            RegStatus = RegEnumKeyEx(ghEnumKey, ulIndex, RegStr, &ulLen,
                                     NULL, NULL, NULL, NULL);

            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

               Status = GetDeviceInstanceList(RegStr, &ptr, &ulSize);

               if (Status != CR_SUCCESS) {
                  *pulLength = 0;
                  goto Clean0;
               }

               *pulLength += ulSize - 1;            // length copied so far
               ulSize = ulBufferLen - *pulLength;   // buffer length left
            }
         }
         *pulLength += 1;      // now count the double-null
      }


   Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_SUCCESS;
   }

   return Status;

} // PNP_GetDeviceList



CONFIGRET
PNP_GetDeviceListSize(
      IN  handle_t   hBinding,
      IN  LPCWSTR    pszFilter,
      OUT PULONG     pulLen,
      IN  ULONG      ulFlags
      )
/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  size of a list of device instances.

Arguments:

   hBinding          Not used.

   pszEnumerator     Optional parameter, if specified the size will only
                     include device instances of this enumerator.

   pulLen            Returns the worst case estimate of the size of a
                     device instance list.

   ulFlags           Flag specifying which devices ids to return.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   ULONG       ulSize = 0, ulIndex = 0;
   WCHAR       RegStr[MAX_CM_PATH];
   ULONG       RegStatus = ERROR_SUCCESS;
   WCHAR       szEnumerator[MAX_DEVICE_ID_LEN],
               szDevice[MAX_DEVICE_ID_LEN],
               szInstance[MAX_DEVICE_ID_LEN];
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
      //
      // validate parameters
      //
      if (INVALID_FLAGS(ulFlags, CM_GETIDLIST_FILTER_BITS)) {
          Status = CR_INVALID_FLAG;
          goto Clean0;
      }

      if (!ARGUMENT_PRESENT(pulLen)) {
          Status = CR_INVALID_POINTER;
          goto Clean0;
      }

      //
      // initialize output length param
      //
      *pulLen = 0;

      //-----------------------------------------------------------
      // Query Device Relations filter - go through kernel-mode
      //-----------------------------------------------------------

      if ((ulFlags & CM_GETIDLIST_FILTER_EJECTRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_REMOVALRELATIONS) ||
          (ulFlags & CM_GETIDLIST_FILTER_POWERRELATIONS)   ||
          (ulFlags & CM_GETIDLIST_FILTER_BUSRELATIONS)) {

          memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEVICE_RELATIONS_DATA));
          RtlInitUnicodeString(&ControlData.DeviceInstance, pszFilter);
          ControlData.Operation = QueryOperationCode(ulFlags);
          ControlData.BufferLength = 0;
          ControlData.Buffer = NULL;

          ntStatus = NtPlugPlayControl(PlugPlayControlQueryDeviceRelations,
                                       &ControlData,
                                       sizeof(ControlData));

          if (NT_SUCCESS(ntStatus)) {

              //
              // Note - we get here because kernel mode special cases
              // Buffer==NULL and is careful not to return
              // STATUS_BUFFER_TOO_SMALL.
              //
              *pulLen = ControlData.BufferLength;

          } else {

              //
              // ADRIAO ISSUE 02/06/2001 - We aren't returning the proper code
              //                           here. We should fix this in XP+1,
              //                           once we have time to verify no one
              //                           will get an app compat break.
              //
              //Status = MapNtStatusToCmError(ntStatus);
              Status = CR_SUCCESS;
          }
          goto Clean0;
      }


      //---------------------------------------------------
      // Service filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_SERVICE) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         Status = GetServiceDeviceListSize(pszFilter, pulLen);
         goto Clean0;
      }


      //---------------------------------------------------
      // Enumerator filter
      //---------------------------------------------------

      else if (ulFlags & CM_GETIDLIST_FILTER_ENUMERATOR) {

         if (!ARGUMENT_PRESENT(pszFilter)) {
            //
            // the filter string is required for this flag
            //
            Status = CR_INVALID_POINTER;
            goto Clean0;
         }

         SplitDeviceInstanceString(
               pszFilter, szEnumerator, szDevice, szInstance);

         //
         // if both the enumerator and device were specified, retrieve
         // the device instance list size for this device only
         //
         if (*szEnumerator != L'\0' && *szDevice != L'\0') {

            Status = GetInstanceListSize(pszFilter, pulLen);
         }

         //
         // if just the enumerator was specified, retrieve the size of
         // all the device instances under this enumerator
         //
         else {
            Status = GetDeviceInstanceListSize(pszFilter, pulLen);
         }
      }

      //---------------------------------------------------
      // No filtering
      //---------------------------------------------------

      else {

         //
         // no enumerator was specified, return device instance size
         // for all enumerators (by enumerating the enumerators)
         //
         ulIndex = 0;

         while (RegStatus == ERROR_SUCCESS) {

            ulSize = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(ghEnumKey, ulIndex, RegStr, &ulSize,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

               Status = GetDeviceInstanceListSize(RegStr, &ulSize);

               if (Status != CR_SUCCESS) {
                  goto Clean0;
               }
               *pulLen += ulSize;
            }
         }
      }

      *pulLen += 1;     // add extra char for double null term


   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetDeviceListSize



CONFIGRET
PNP_GetDepth(
   IN  handle_t   hBinding,
   IN  LPCWSTR    pszDeviceID,
   OUT PULONG     pulDepth,
   IN  ULONG      ulFlags
   )

/*++

Routine Description:

  This the server-side of an RPC remote call.  This routine returns the
  depth of a device instance.

Arguments:

   hBinding       Not used.

   pszDeviceID    Device instance to find the depth of.

   pulDepth       Returns the depth of pszDeviceID.

   ulFlags        Not used, must be zero.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
   CONFIGRET   Status = CR_SUCCESS;
   NTSTATUS    ntStatus = STATUS_SUCCESS;
   PLUGPLAY_CONTROL_DEPTH_DATA ControlData;

   UNREFERENCED_PARAMETER(hBinding);

   try {
        //
        // validate parameters
        //
        if (INVALID_FLAGS(ulFlags, 0)) {
            Status = CR_INVALID_FLAG;
            goto Clean0;
        }

        if (!ARGUMENT_PRESENT(pulDepth)) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // initialize output depth param
        //
        *pulDepth = 0;

        if (!IsLegalDeviceId(pszDeviceID)) {
            Status = CR_INVALID_DEVNODE;
            goto Clean0;
        }

        //
        // Retrieve the device depth via kernel-mode.
        //

        memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_DEPTH_DATA));
        RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
        ControlData.DeviceDepth = 0;

        ntStatus = NtPlugPlayControl(PlugPlayControlGetDeviceDepth,
                                     &ControlData,
                                     sizeof(ControlData));

        if (!NT_SUCCESS(ntStatus)) {
            Status = MapNtStatusToCmError(ntStatus);
        } else {
            *pulDepth = ControlData.DeviceDepth;
        }

   Clean0:
        NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;
   }

   return Status;

} // PNP_GetDepth




//-------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------

CONFIGRET
GetServiceDeviceListSize(
      IN  LPCWSTR   pszService,
      OUT PULONG    pulLength
      )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszService     service whose device instances are to be listed

   pulLength      On output, specifies the size in characters required to hold
                  the device instance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulType = 0, ulCount = 0, ulMaxValueData = 0, ulSize = 0;
    HKEY        hKey = NULL, hEnumKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszService)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
        }

        //
        // Open a key to the service branch
        //
        if (RegOpenKeyEx(ghServicesKey, pszService, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // check if the service is specialy marked as type
        // PlugPlayServiceSoftware, in which case I will not
        // generate any madeup device ids and fail the call.
        //
        ulSize = sizeof(ulType);
        if (RegQueryValueEx(hKey, pszRegValuePlugPlayServiceType, NULL, NULL,
                            (LPBYTE)&ulType, &ulSize) == ERROR_SUCCESS) {

            if (ulType == PlugPlayServiceSoftware) {

                Status = CR_NO_SUCH_VALUE;
                *pulLength = 0;
                goto Clean0;
            }
        }

        //
        // open the Enum key
        //
        if (RegOpenKeyEx(hKey, pszRegKeyEnum, 0, KEY_READ,
                         &hEnumKey) != ERROR_SUCCESS) {
            //
            // Enum key doesn't exist so one will be generated, estimate
            // worst case device id size for the single generated device id
            //
            *pulLength = MAX_DEVICE_ID_LEN;
            goto Clean0;
        }

        //
        // retrieve the count of device instances controlled by this service
        //
        ulSize = sizeof(ulCount);
        if (RegQueryValueEx(hEnumKey, pszRegValueCount, NULL, NULL,
                            (LPBYTE)&ulCount, &ulSize) != ERROR_SUCCESS) {
            ulCount = 1;      // if empty, I'll generate one
        }

        if (ulCount == 0) {
            ulCount++;        // if empty, I'll generate one
        }

        if (RegQueryInfoKey(hEnumKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
                            NULL, &ulMaxValueData, NULL, NULL) != ERROR_SUCCESS) {

            *pulLength = ulCount * MAX_DEVICE_ID_LEN;
            goto Clean0;
        }

        //
        // worst case estimate is multiply number of device instances time
        // length of the longest one + 2 null terminators
        //
        *pulLength = ulCount * (ulMaxValueData+1)/sizeof(WCHAR) + 2;


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hEnumKey != NULL) {
        RegCloseKey(hEnumKey);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetServiceDeviceListSize



CONFIGRET
GetServiceDeviceList(
      IN  LPCWSTR   pszService,
      OUT LPWSTR    pBuffer,
      IN OUT PULONG pulLength,
      IN  ULONG     ulFlags
      )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszService     Service whose device instances are to be listed

   pBuffer        Pointer to a buffer that will hold the list in multi-sz
                  format

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies the size in characters actually copied
                  to the buffer.

   ulFlags        Specifies CM_GETIDLIST_* flags supplied to
                  PNP_GetDeviceList (CM_GETIDLIST_FILTER_SERVICE
                  must be specified).  This routine only checks for the
                  presence of the CM_GETIDLIST_DONOTGENERATE flag.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH], szDeviceID[MAX_DEVICE_ID_LEN+1];
    ULONG       ulType=0, ulBufferLen=0, ulSize=0, ulCount=0, i=0;
    HKEY        hKey = NULL, hEnumKey = NULL;
    PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA    ControlData;
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOL        ServiceIsPlugPlay = FALSE;

    ASSERT(ulFlags & CM_GETIDLIST_FILTER_SERVICE);

    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszService)) ||
            (!ARGUMENT_PRESENT(pulLength)) ||
            (!ARGUMENT_PRESENT(pBuffer) && (*pulLength != 0))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // the buffer must be at least large enough for a NULL multi-sz list
        //
        if (*pulLength == 0) {
            Status = CR_BUFFER_SMALL;
            goto Clean0;
        }

        *pBuffer = L'\0';
        ulBufferLen = *pulLength;

        //
        // Open a key to the service branch
        //
        if (RegOpenKeyEx(ghServicesKey, pszService, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            *pulLength = 0;
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // check if the service is specialy marked as type
        // PlugPlayServiceSoftware, in which case I will not
        // generate any madeup device ids and fail the call.
        //
        ulSize = sizeof(ulType);
        if (RegQueryValueEx(hKey, pszRegValuePlugPlayServiceType, NULL, NULL,
                            (LPBYTE)&ulType, &ulSize) == ERROR_SUCCESS) {

            if (ulType == PlugPlayServiceSoftware) {
                //
                // for PlugPlayServiceSoftware value, fail the call
                //
                *pulLength = 0;
                Status = CR_NO_SUCH_VALUE;
                goto Clean0;

            }

            ServiceIsPlugPlay = TRUE;
        }

        //
        // open the Enum key
        //
        RegStatus = RegOpenKeyEx(hKey, pszRegKeyEnum, 0, KEY_READ,
                                 &hEnumKey);

        if (RegStatus == ERROR_SUCCESS) {
            //
            // retrieve count of device instances controlled by this service
            //
            ulSize = sizeof(ulCount);
            if (RegQueryValueEx(hEnumKey, pszRegValueCount, NULL, NULL,
                                (LPBYTE)&ulCount, &ulSize) != ERROR_SUCCESS) {
                ulCount = 0;
            }
        }

        //
        // if there are no device instances, create a default one
        //
        if (RegStatus != ERROR_SUCCESS || ulCount == 0) {

            if (ulFlags & CM_GETIDLIST_DONOTGENERATE) {
                //
                // If I'm calling this routine privately, don't generate
                // a new device instance, just give me an empty list
                //
                *pBuffer = L'\0';
                *pulLength = 0;
                goto Clean0;
            }

            if (ServiceIsPlugPlay) {
                //
                // Also, if plugplayservice type set, don't generate a
                // new device instance, just return success with an empty list
                //
                *pBuffer = L'\0';
                *pulLength = 0;
                goto Clean0;
            }

            memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_LEGACY_DEVGEN_DATA));
            RtlInitUnicodeString(&ControlData.ServiceName, pszService);
            ControlData.DeviceInstance = pBuffer;
            ControlData.DeviceInstanceLength = *pulLength - 1;
            NtStatus = NtPlugPlayControl(PlugPlayControlGenerateLegacyDevice,
                                         &ControlData,
                                         sizeof(ControlData));

            if (NtStatus == STATUS_SUCCESS)  {

                *pulLength = ControlData.DeviceInstanceLength;
                pBuffer[*pulLength] = L'\0';    // 1st NUL terminator
                (*pulLength)++;                 // +1 for 1st NUL terminator
                pBuffer[*pulLength] = L'\0';    // double NUL terminate
                (*pulLength)++;                 // +1 for 2nd NUL terminator

            } else {

                *pBuffer = L'\0';
                *pulLength = 0;

                Status = CR_FAILURE;
            }

            goto Clean0;
        }


        //
        // retrieve each device instance
        //
        for (i = 0; i < ulCount; i++) {

            wsprintf(RegStr, TEXT("%d"), i);

            ulSize = MAX_DEVICE_ID_LEN * sizeof(WCHAR);

            RegStatus = RegQueryValueEx(hEnumKey, RegStr, NULL, NULL,
                                        (LPBYTE)szDeviceID, &ulSize);

            if (RegStatus != ERROR_SUCCESS) {
                Status = CR_REGISTRY_ERROR;
                goto Clean0;
            }

            //
            // this string is not always null-terminated when I read it from the
            // registry, even though it's REG_SZ.
            //
            ulSize /= sizeof(WCHAR);

            if (szDeviceID[ulSize-1] != L'\0') {
                szDeviceID[ulSize] = L'\0';
            }

            ulSize = ulBufferLen * sizeof(WCHAR);  // total buffer size in bytes

            if (!MultiSzAppendW(pBuffer, &ulSize, szDeviceID)) {
                Status = CR_BUFFER_SMALL;
                *pulLength = 0;
                goto Clean0;
            }

            *pulLength = ulSize/sizeof(WCHAR);  // chars to transfer
        }


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hEnumKey != NULL) {
        RegCloseKey(hEnumKey);
    }
    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetServiceDeviceList



CONFIGRET
GetInstanceListSize(
    IN  LPCWSTR   pszDevice,
    OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszDevice      device whose instances are to be listed

   pulLength      On output, specifies the size in characters required to hold
                  the device istance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    ULONG       ulCount = 0, ulMaxKeyLen = 0;
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszDevice)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key to the device instance
        //
        if (RegOpenKeyEx(ghEnumKey, pszDevice, 0, KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // how many instance keys are under this device?
        //
        if (RegQueryInfoKey(hKey, NULL, NULL, NULL, &ulCount, &ulMaxKeyLen,
                            NULL, NULL, NULL, NULL, NULL, NULL)
                            != ERROR_SUCCESS) {
            ulCount = 0;
            ulMaxKeyLen = 0;
        }

        //
        // do worst case estimate:
        //    length of the <enumerator>\<root> string +
        //    1 char for the back slash before the instance +
        //    the length of the longest instance key + null term +
        //    multiplied by the number of instances under this device.
        //
        *pulLength = ulCount * (lstrlen(pszDevice) + ulMaxKeyLen + 2) + 1;

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetInstanceListSize



CONFIGRET
GetInstanceList(
    IN     LPCWSTR   pszDevice,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   hEnumKey       Handle to open Enum registry key

   pszDevice      device whose instances are to be listed

   pBuffer        On input, this points to place where the next element
                  should be copied (the buffer tail), on output, it also
                  points to the end of the buffer.

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies how many characters actually copied to
                  the buffer. Includes an extra byte for the double-null term.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    WCHAR       RegStr[MAX_CM_PATH], szInstance[MAX_DEVICE_ID_LEN];
    ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszDevice)) ||
            (!ARGUMENT_PRESENT(*pBuffer))  ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key for this Enumerator\Device branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszDevice, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        ulBufferLen = *pulLength;     // total size of pBuffer
        *pulLength = 0;               // no data copied yet
        ulIndex = 0;

        //
        // enumerate the instance keys
        //
        while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szInstance, &ulLen,
                                     NULL, NULL, NULL, NULL);

            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {

                wsprintf(RegStr, TEXT("%s\\%s"),
                         pszDevice,
                         szInstance);

                if (IsValidDeviceID(RegStr, NULL, 0)) {

                    ulSize = lstrlen(RegStr) + 1;   // size of new element
                    *pulLength += ulSize;           // size copied so far

                    if (*pulLength + 1 > ulBufferLen) {
                        *pulLength = 0;
                        Status = CR_BUFFER_SMALL;
                        goto Clean0;
                    }

                    lstrcpy(*pBuffer, RegStr);      // copy the element
                    *pBuffer += ulSize;             // move to tail of buffer
                }
            }
        }

        **pBuffer = 0x0;                // double-null terminate it
        *pulLength += 1;  // include room for double-null terminator

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetInstanceList



CONFIGRET
GetDeviceInstanceListSize(
    IN  LPCWSTR   pszEnumerator,
    OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   pszEnumerator  Enumerator whose device instances are to be listed

   pulLength      On output, specifies how many characters required to hold
                  the device instance list.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulSize = 0, ulIndex = 0;
    WCHAR       RegStr[MAX_CM_PATH], szDevice[MAX_DEVICE_ID_LEN];
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszEnumerator)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // initialize output length param
        //
        *pulLength = 0;

        //
        // Open a key for this Enumerator branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszEnumerator, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        //
        // Enumerate the device keys
        //
        ulIndex = 0;

        while (RegStatus == ERROR_SUCCESS) {

            ulSize = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szDevice, &ulSize,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {
                //
                // Retreive the size of the instance list for this device
                //
                wsprintf(RegStr, TEXT("%s\\%s"),
                         pszEnumerator,
                         szDevice);

                if ((Status = GetInstanceListSize(RegStr, &ulSize)) != CR_SUCCESS) {
                    *pulLength = 0;
                    goto Clean0;
                }

                *pulLength += ulSize;
            }
        }


    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetDeviceInstanceListSize



CONFIGRET
GetDeviceInstanceList(
    IN     LPCWSTR   pszEnumerator,
    IN OUT LPWSTR    *pBuffer,
    IN OUT PULONG    pulLength
    )

/*++

Routine Description:

  This routine returns the a list of device instances for the specificed
  enumerator.

Arguments:

   hEnumKey       Handle of open Enum (parent) registry key

   pszEnumerator  Enumerator whose device instances are to be listed

   pBuffer        On input, this points to place where the next element
                  should be copied (the buffer tail), on output, it also
                  points to the end of the buffer.

   pulLength      On input, specifies the size in characters of Buffer, on
                  Output, specifies how many characters actuall copied to
                  the buffer. Includes an extra byte for the double-null
                  term.

Return Value:

   If the function succeeds, it returns CR_SUCCESS, otherwise it returns
   a CR_* error code.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    LONG        RegStatus = ERROR_SUCCESS;
    ULONG       ulBufferLen=0, ulSize=0, ulIndex=0, ulLen=0;
    WCHAR       RegStr[MAX_CM_PATH], szDevice[MAX_DEVICE_ID_LEN];
    HKEY        hKey = NULL;


    try {
        //
        // validate parameters
        //
        if ((!ARGUMENT_PRESENT(pszEnumerator)) ||
            (!ARGUMENT_PRESENT(*pBuffer)) ||
            (!ARGUMENT_PRESENT(pulLength))) {
            Status = CR_INVALID_POINTER;
            goto Clean0;
        }

        //
        // Open a key for this Enumerator branch
        //
        if (RegOpenKeyEx(ghEnumKey, pszEnumerator, 0, KEY_ENUMERATE_SUB_KEYS,
                         &hKey) != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
            goto Clean0;
        }

        ulIndex = 0;
        ulSize = ulBufferLen = *pulLength;        // total size of pBuffer
        *pulLength = 0;

        //
        // Enumerate the device keys
        //
        while (RegStatus == ERROR_SUCCESS) {

            ulLen = MAX_DEVICE_ID_LEN;  // size in chars

            RegStatus = RegEnumKeyEx(hKey, ulIndex, szDevice, &ulLen,
                                     NULL, NULL, NULL, NULL);
            ulIndex++;

            if (RegStatus == ERROR_SUCCESS) {
                //
                // Enumerate the Instance keys
                //
                wsprintf(RegStr, TEXT("%s\\%s"),
                         pszEnumerator,
                         szDevice);

                Status = GetInstanceList(RegStr, pBuffer, &ulSize);

                if (Status != CR_SUCCESS) {
                    *pulLength = 0;
                    goto Clean0;
                }

                *pulLength += ulSize - 1;           // data copied so far
                ulSize = ulBufferLen - *pulLength;  // buffer size left over
            }
        }

        *pulLength += 1;  // now add room for second null term

    Clean0:
        NOTHING;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // GetDeviceInstanceList



PNP_QUERY_RELATION
QueryOperationCode(
    ULONG ulFlags
    )

/*++

Routine Description:

  This routine converts the CM_GETIDLIST_FILTER_Xxx query relation type
  flags into the corresponding enum value that NtPlugPlayControl understands.

Arguments:

   ulFlags        CM API CM_GETIDLIST_FILTER_Xxx value

Return Value:

   One of the enum PNP_QUERY_RELATION values.

--*/

{
    switch (ulFlags) {

    case CM_GETIDLIST_FILTER_EJECTRELATIONS:
        return PnpQueryEjectRelations;

    case CM_GETIDLIST_FILTER_REMOVALRELATIONS:
        return PnpQueryRemovalRelations;

    case CM_GETIDLIST_FILTER_POWERRELATIONS:
        return PnpQueryPowerRelations;

    case CM_GETIDLIST_FILTER_BUSRELATIONS:
        return PnpQueryBusRelations;

    default:
        return (ULONG)-1;
    }

} // QueryOperationCode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\rutil.c ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    rutil.c

Abstract:

    This module contains general utility routines used by umpnpmgr.

            PNP_ENTER_SYNCHRONOUS_CALL
            PNP_LEAVE_SYNCHRONOUS_CALL
            IsClientUsingLocalConsole
            IsClientInteractive
            VerifyClientAccess
            SplitClassInstanceString
            CreateDeviceIDRegKey
            IsValidGuid
            IsRootDeviceID
            MultiSzAppendW
            MultiSzFindNextStringW
            MultiSzSearchStringW
            MultiSzSizeW
            MultiSzDeleteStringW
            IsValidDeviceID
            IsDevicePhantom
            GetDeviceStatus
            SetDeviceStatus
            ClearDeviceStatus
            GetProfileCount
            CopyRegistryTree
            PathToString
            IsDeviceMoved
            MakeKeyVolatile
            MakeKeyNonVolatile
            OpenLogConfKey
            GetActiveService
            IsDeviceIdPresent
            GetDeviceConfigFlags
            MapNtStatusToCmError
            VerifyKernelInitiatedEjectPermissions
            GuidFromString
            StringFromGuid

Author:

    Paula Tomlinson (paulat) 7-12-1995

Environment:

    User mode only.

Revision History:

    12-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include "umpnpi.h"
#include "umpnpdat.h"

#include <winsta.h>
#include <syslib.h>


//
// global data
//
extern HKEY   ghEnumKey;      // Key to HKLM\CCC\System\Enum - DO NOT MODIFY
extern HKEY   ghServicesKey;  // Key to HKLM\CCC\System\Services - DO NOT MODIFY
extern CRITICAL_SECTION PnpSynchronousCall;


//
// Declare data used in GUID->string conversion (from ole32\common\ccompapi.cxx).
//
static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");



VOID
PNP_ENTER_SYNCHRONOUS_CALL(
    VOID
    )
{
    EnterCriticalSection(&PnpSynchronousCall);

} // PNP_ENTER_SYNCHRONOUS_CALL


VOID
PNP_LEAVE_SYNCHRONOUS_CALL(
    VOID
    )
{
    LeaveCriticalSection(&PnpSynchronousCall);

} // PNP_LEAVE_SYNCHRONOUS_CALL



BOOL
IsClientUsingLocalConsole(
    IN handle_t     hBinding
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client is using the current active console session.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is using the current active console
    session, FALSE if not or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bResult = FALSE;

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        return FALSE;
    }

    if (GetClientLogonId() == GetActiveConsoleSessionId()) {
        bResult = TRUE;
    }

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
    }

    return bResult;

} // IsClientUsingLocalConsole



BOOL
IsClientLocal(
    IN  handle_t    hBinding
    )

/*++

Routine Description:

    This routine determines if the client associated with hBinding is on the
    local machine.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is local to this machine, FALSE if
    not or if an error occurs.

--*/

{
    RPC_STATUS  RpcStatus;
    UINT        ClientLocalFlag;


    //
    // If the specified RPC binding handle is NULL, this is an internal call so
    // we assume that the privilege has already been checked.
    //

    if (hBinding == NULL) {
        return TRUE;
    }

    //
    // Retrieve the ClientLocalFlags from the RPC binding handle.
    //

    RpcStatus =
        I_RpcBindingIsClientLocal(
            hBinding,
            &ClientLocalFlag);

    if (RpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: I_RpcBindingIsClientLocal failed, RpcStatus=%d\n",
                   RpcStatus));
        return FALSE;
    }

    //
    // If the ClientLocalFlag is not zero, RPC client is local to server.
    //

    if (ClientLocalFlag != 0) {
        return TRUE;
    }

    //
    // Client is not local to this server.
    //

    return FALSE;

} // IsClientLocal



BOOL
IsClientInteractive(
    IN handle_t     hBinding
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client is a member of the INTERACTIVE well-known group.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is interactive, FALSE if not
    or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bIsMember;
    HANDLE          hToken;
    PSID            sidInteractiveGroup;
    BOOL            bResult = FALSE;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (hBinding == NULL) {
        //
        // This is an internal call so we assume that the privilege has already
        // been checked.
        //
        return TRUE;
    }

    if (!AllocateAndInitializeSid( &NtAuthority,
                                   1, // one authority - INTERACTIVE
                                   SECURITY_INTERACTIVE_RID, // interactive logged on users only
                                   0, 0, 0, 0, 0, 0, 0,  // unused authority locations
                                   &sidInteractiveGroup)) {
        return FALSE;
    }

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        FreeSid(sidInteractiveGroup);
        return FALSE;
    }

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

        if (CheckTokenMembership(hToken,
                                 sidInteractiveGroup,
                                 &bIsMember)) {
            if (bIsMember) {
                bResult = TRUE;
            }
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: CheckTokenMembership failed, error = %d\n",
                       GetLastError()));
        }
        CloseHandle(hToken);

    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: OpenThreadToken failed, error = %d\n",
                   GetLastError()));
    }

    FreeSid(sidInteractiveGroup);

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
    }

    return bResult;

} // IsClientInteractive



BOOL
IsClientAdministrator(
    IN handle_t     hBinding
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client is a member of the Local Administrators group.

Arguments:

    hBinding        RPC Binding handle

Return value:

    The return value is TRUE if the client is a Local Administrator, FALSE if
    not or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bIsMember;
    HANDLE          hToken;
    PSID            sidAdministratorsGroup;
    BOOL            bResult = FALSE;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (hBinding == NULL) {
        //
        // This is an internal call so we assume that the privilege has already
        // been checked.
        //
        return TRUE;
    }


    if (!AllocateAndInitializeSid( &NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &sidAdministratorsGroup)) {
        return FALSE;
    }

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcImpersonateClient failed, error = %d\n",
                   rpcStatus));
        FreeSid(sidAdministratorsGroup);
        return FALSE;
    }

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

        if (CheckTokenMembership(hToken,
                                 sidAdministratorsGroup,
                                 &bIsMember)) {
            if (bIsMember) {
                bResult = TRUE;
            }
        } else {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: CheckTokenMembership failed, error = %d\n",
                       GetLastError()));
        }
        CloseHandle(hToken);

    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: OpenThreadToken failed, error = %d\n",
                   GetLastError()));
    }

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
    }

    FreeSid(sidAdministratorsGroup);

    return bResult;

} // IsClientAdministrator



BOOL
VerifyClientAccess(
    IN handle_t     hBinding,
    IN PLUID        pPrivilegeLuid
    )

/*++

Routine Description:

    This routine impersonates the client associated with hBinding and checks
    if the client possesses the specified privilege.

Arguments:

    hBinding        RPC Binding handle
    pPrivilegeLuid  LUID representing privilege to be checked.

Return value:

    The return value is TRUE if the client possesses the privilege, FALSE if not
    or if an error occurs.

--*/

{
    RPC_STATUS      rpcStatus;
    BOOL            bResult;
    HANDLE          hToken;
    PRIVILEGE_SET   privilegeSet;

    if (hBinding == NULL) {
        //
        // This is an internal call so we assume that the privilege has already
        // been checked.
        //

        return TRUE;
    }

    if (pPrivilegeLuid->LowPart == 0 && pPrivilegeLuid->HighPart == 0) {
        //
        // Uninitialized LUID, most likely LookupPrivilegeValue failed during
        // initialization, we'll pretend like they don't have access in this
        // case.
        //

        return FALSE;
    }

    rpcStatus = RpcImpersonateClient(hBinding);

    if (rpcStatus != RPC_S_OK) {
        //
        // Since we can't impersonate the client we better not do the security
        // checks as ourself (they would always succeed).
        //

        return FALSE;
    }

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

        privilegeSet.PrivilegeCount = 1;
        privilegeSet.Control = 0;
        privilegeSet.Privilege[0].Luid = *pPrivilegeLuid;
        privilegeSet.Privilege[0].Attributes = 0;


        if (!PrivilegeCheck(hToken, &privilegeSet, &bResult)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: PrivilegeCheck failed, error = %d\n",
                       GetLastError()));

            bResult = FALSE;
        }

        CloseHandle(hToken);
    } else {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: OpenThreadToken failed, error = %d\n",
                   GetLastError()));

        bResult = FALSE;
    }

    rpcStatus = RpcRevertToSelf();

    if (rpcStatus != RPC_S_OK) {
        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RpcRevertToSelf failed, error = %d\n",
                   rpcStatus));
    }

    return bResult;

} // VerifyClientAccess



BOOL
SplitClassInstanceString(
   IN  LPCWSTR  pszClassInstance,
   OUT LPWSTR   pszClass,
   OUT LPWSTR   pszInstance
   )

/*++

Routine Description:

     This routine parses a class instance string into it's two component parts.

Arguments:


Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
   UINT  ulLength, i;


   ulLength = lstrlen(pszClassInstance);

   //
   // parse the string for the backslash character
   //
   for (i=0; i < ulLength && pszClassInstance[i] != '\0' &&
         pszClassInstance[i] != '\\'; i++);

   if (pszClassInstance[i] != '\\') {
      return FALSE;
   }

   i++;           // increment past the backslash character
   if (i < ulLength && pszClassInstance[i] != '\0') {
      if (pszClass != NULL) {
         lstrcpyn(pszClass, pszClassInstance, i);
      }
      if (pszInstance != NULL) {
         lstrcpy(pszInstance, &pszClassInstance[i]);
      }
   }
   else {
      return FALSE;
   }

   return TRUE;

} // SplitClassInstanceString



BOOL
CreateDeviceIDRegKey(
   HKEY     hParentKey,
   LPCWSTR  pDeviceID
   )

/*++

Routine Description:

     This routine creates the specified device id subkeys in the registry.

Arguments:

   hParentKey     Key under which the device id key will be created

   pDeviceID      Device instance ID string to open

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
   WCHAR    szBase[MAX_DEVICE_ID_LEN];
   WCHAR    szDevice[MAX_DEVICE_ID_LEN];
   WCHAR    szInstance[MAX_DEVICE_ID_LEN];
   HKEY     hBaseKey, hDeviceKey, hInstanceKey;

   if (!SplitDeviceInstanceString(
         pDeviceID, szBase, szDevice, szInstance)) {
      return FALSE;
   }

   //
   // just try creating each component of the device id
   //
   if (RegCreateKeyEx(
            hParentKey, szBase, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hBaseKey, NULL) != ERROR_SUCCESS) {
      return FALSE;
   }

   if (RegCreateKeyEx(
            hBaseKey, szDevice, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hDeviceKey, NULL) != ERROR_SUCCESS) {
      RegCloseKey(hBaseKey);
      return FALSE;
   }

   if (RegCreateKeyEx(
            hDeviceKey, szInstance, 0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hInstanceKey, NULL) != ERROR_SUCCESS) {
      RegCloseKey(hBaseKey);
      RegCloseKey(hDeviceKey);
      return FALSE;
   }

   RegCloseKey(hBaseKey);
   RegCloseKey(hDeviceKey);
   RegCloseKey(hInstanceKey);

   return TRUE;

} // CreateDeviceIDRegKey



BOOL
IsValidGuid(
   LPWSTR   pszGuid
   )

/*++

Routine Description:

     This routine determines whether a string is of the proper Guid form.

Arguments:

     pszGuid   Pointer to a string that will be checked for the standard Guid
               format.

Return value:

    The return value is TRUE if the string is a valid Guid and FALSE if it
    is not.

--*/

{
   //----------------------------------------------------------------
   // NOTE: This may change later, but for now I am just verifying
   // that the string has exactly MAX_GUID_STRING_LEN characters
   //----------------------------------------------------------------

   if (lstrlen(pszGuid) != MAX_GUID_STRING_LEN-1) {
      return FALSE;
   }
   return TRUE;

} // IsValidGuid



BOOL
IsRootDeviceID(
   LPCWSTR pDeviceID
   )

/*++

Routine Description:

     This routine determines whether the specified device id is the root
     device id.

Arguments:

     pDeviceID    Pointer to a device id string

Return value:

    The return value is TRUE if the string is the root device id and
    FALSE if it is not.

--*/

{
   return (lstrcmpi(pDeviceID, pszRegRootEnumerator) == 0);

} // IsRootDeviceID



BOOL
MultiSzAppendW(
      LPWSTR   pszMultiSz,
      PULONG   pulSize,
      LPCWSTR  pszString
      )

/*++

Routine Description:

     Appends a string to a multi_sz string.

Arguments:

     pszMultiSz   Pointer to a multi_sz string

     pulSize      On input, Size of the multi_sz string buffer in bytes,
                  On return, amount copied to the buffer (in bytes)

     pszString    String to append to pszMultiSz

Return value:

    The return value is TRUE if the function succeeded and FALSE if an
    error occured.

--*/

{
   BOOL     bStatus = TRUE;
   LPWSTR   pTail;
   ULONG    ulSize;


    try {
        //
        // if it's an empty string, just copy it
        //
        if (*pszMultiSz == '\0') {

            ulSize = (lstrlen(pszString) + 2) * sizeof(WCHAR);

            if (ulSize > *pulSize) {
                bStatus = FALSE;
                goto Clean0;
            }

            lstrcpy(pszMultiSz, pszString);
            pszMultiSz[lstrlen(pszMultiSz) + 1] = '\0';  // add second NULL term char
            *pulSize = ulSize;
            goto Clean0;
        }

        //
        // first find the end of the multi_sz string
        //
        pTail = pszMultiSz;

        while ((ULONG)(pTail - pszMultiSz) * sizeof(WCHAR) < *pulSize) {

            while (*pTail != '\0') {
                pTail++;
            }
            pTail++;       // skip past the null terminator

            if (*pTail == '\0') {
                break;      // found the double null terminator
            }
        }

        if ((pTail - pszMultiSz + lstrlen(pszString) + 2) * sizeof(WCHAR)
                > *pulSize) {
            bStatus = FALSE;     // the copy would overflow the buffer
            goto Clean0;
        }

        lstrcpy(pTail, pszString);       // copies over the second null terminator
        pTail += lstrlen(pszString) + 1;
        *pTail = '\0';                      // add second null terminator

        //
        // return buffer size in bytes
        //
        *pulSize = (ULONG)((pTail - pszMultiSz + 1)) * sizeof(WCHAR);


    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        bStatus = FALSE;
    }

   return bStatus;

} // MultiSzAppendW



LPWSTR
MultiSzFindNextStringW(
      LPWSTR pMultiSz
      )

/*++

Routine Description:

     Finds next string in a multi_sz string.
     device id.

Arguments:

     pMultiSz  Pointer to a multi_sz string

Return value:

    The return value is a pointer to the next string or NULL.

--*/

{
   LPWSTR   lpNextString = pMultiSz;


   //
   // find the next NULL terminator
   //
   while (*lpNextString != '\0') {
      lpNextString++;
   }
   lpNextString++;      // skip over the NULL terminator

   if (*lpNextString == '\0') {
      //
      // two NULL terminators in a row means we're at the end
      //
      lpNextString = NULL;
   }

   return lpNextString;

} // MultiSzFindNextStringW



BOOL
MultiSzSearchStringW(
   IN LPCWSTR   pString,
   IN LPCWSTR   pSubString
   )
{
   LPCWSTR   pCurrent = pString;


   //
   // compare each string in the multi_sz pString with pSubString
   //
   while (*pCurrent != '\0') {

      if (lstrcmpi(pCurrent, pSubString) == 0) {
         return TRUE;
      }

      //
      // go to the next string
      //
      while (*pCurrent != '\0') {
         pCurrent++;
      }
      pCurrent++;               // skip past the null terminator

      if (*pCurrent == '\0') {
         break;      // found the double null terminator
      }
   }

   return FALSE;  // pSubString match not found within pString

} // MultiSzSearchStringW



ULONG
MultiSzSizeW(
   IN LPCWSTR  pString
   )

{
   LPCWSTR p = NULL;


   if (pString == NULL) {
      return 0;
   }

   for (p = pString; *p; p += lstrlen(p)+1) {
      // this should fall out with p pointing to the
      // second null in double-null terminator
   }

   //
   // returns size in WCHAR
   //
   return (ULONG)(p - pString + 1);

} // MultiSzSizeW



BOOL
MultiSzDeleteStringW(
   IN OUT LPWSTR  pString,
   IN LPCWSTR     pSubString
   )

{
   LPWSTR   p = NULL, pNext = NULL, pBuffer = NULL;
   ULONG    ulSize = 0;


   if (pString == NULL || pSubString == NULL) {
      return FALSE;
   }

   for (p = pString; *p; p += lstrlen(p)+1) {

      if (lstrcmpi(p, pSubString) == 0) {
         //
         // found a match, this is the string to remove.
         //
         pNext = p + lstrlen(p) + 1;

         //
         // If this is the last string then just truncate it
         //
         if (*pNext == '\0') {
            *p = '\0';
            *(++p) = '\0';       // double null-terminator
            return TRUE;
         }

         //
         // retrieve the size of the multi_sz string (in bytes)
         // starting with the substring after the matching substring
         //
         ulSize = MultiSzSizeW(pNext) * sizeof(WCHAR);
         if (ulSize == 0) {
            return FALSE;
         }

         pBuffer = HeapAlloc(ghPnPHeap, 0, ulSize);
         if (pBuffer == NULL) {
            return FALSE;
         }

         //
         // Make a copy of the multi_sz string starting at the
         // substring immediately after the matching substring
         //
         memcpy(pBuffer, pNext, ulSize);

         //
         // Copy that buffer back to the original buffer, but this
         // time copy over the top of the matching substring.  This
         // effectively removes the matching substring and shifts
         // any remaining substrings up in multi_sz string.
         //
         memcpy(p, pBuffer, ulSize);

         HeapFree(ghPnPHeap, 0, pBuffer);
         return TRUE;
      }
   }

   //
   // if we got here, there was no match but I consider this a success
   // since the multi_sz does not contain the substring when we're done
   // (which is the desired goal)
   //

   return TRUE;

} // MultiSzDeleteStringW



BOOL
IsValidDeviceID(
      IN  LPCWSTR pszDeviceID,
      IN  HKEY    hKey,
      IN  ULONG   ulFlags
      )

/*++

Routine Description:

   This routine checks if the given device id is valid (present, not moved,
   not phantom).

Arguments:

   pszDeviceID          Device instance string to validate

   hKey                 Can specify open registry key to pszDeviceID, also

   ulFlag               Controls how much verification to do


Return value:

   The return value is CR_SUCCESS if the function suceeds and one of the
   CR_* values if it fails.

--*/

{
   LONG     RegStatus = ERROR_SUCCESS;
   WCHAR    RegStr[MAX_CM_PATH];
   HKEY     hDevKey;
   ULONG    ulValue = 0, ulSize = sizeof(ULONG);


   //
   // Does the device id exist in the registry?
   //
   if (hKey == NULL) {

      wsprintf(RegStr, TEXT("%s\\%s"),
               pszRegPathEnum,
               pszDeviceID);

      RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ, &hDevKey);
      if (RegStatus != ERROR_SUCCESS) {
         return FALSE;
      }
   }
   else {
      hDevKey = hKey;
   }


   //-----------------------------------------------------------
   // Is the device id present?
   //-----------------------------------------------------------

   if (ulFlags & PNP_PRESENT) {

      if (!IsDeviceIdPresent(pszDeviceID)) {
         if (hKey == NULL && hDevKey != NULL) {
            RegCloseKey(hDevKey);
         }
         return FALSE;
      }
   }


   //-----------------------------------------------------------
   // Is it a phantom device id?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_PHANTOM) {

      RegStatus = RegQueryValueEx(
            hDevKey, pszRegValuePhantom, NULL, NULL,
            (LPBYTE)&ulValue, &ulSize);

      if (RegStatus == ERROR_SUCCESS) {
         if (ulValue) {
            if (hKey == NULL && hDevKey != NULL) {
               RegCloseKey(hDevKey);
            }
            return FALSE;
         }
      }
   }


   //-----------------------------------------------------------
   // Has the device id been moved?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_MOVED) {

      if (IsDeviceMoved(pszDeviceID, hDevKey)) {
         return FALSE;
      }
   }


   //-----------------------------------------------------------
   // Has the device id been removed?
   //-----------------------------------------------------------

   if (ulFlags & PNP_NOT_REMOVED) {

       ULONG ulProblem = 0, ulStatus = 0;

       if (GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS) {
          if (ulStatus & DN_WILL_BE_REMOVED) {
             if (hKey == NULL && hDevKey != NULL) {
                RegCloseKey(hDevKey);
             }
             return FALSE;
          }
       }
   }



   if (hKey == NULL && hDevKey != NULL) {
      RegCloseKey(hDevKey);
   }

   return TRUE;

} // IsValidDeviceID



BOOL
IsDevicePhantom(
    IN LPWSTR   pszDeviceID
    )

/*++

Routine Description:

   In this case, the check is actually really "is this not present?". The
   only comparison is done against FoundAtEnum. UPDATE: for NT 5.0, the
   FoundAtEnum registry value has been obsoleted, it's been replaced by a
   simple check for the presense of the devnode in memory.

Arguments:

   pszDeviceID          Device instance string to validate

Return value:

   Returns TRUE if the device is a phantom and FALSE if it isn't.

--*/

{
    return !IsDeviceIdPresent(pszDeviceID);

} // IsDevicePhantom



CONFIGRET
GetDeviceStatus(
    IN  LPCWSTR pszDeviceID,
    OUT PULONG  pulStatus,
    OUT PULONG  pulProblem
    )

/*++

Routine Description:

   This routine retrieves the status and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Returns the device's status

   pulProblem     Returns the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_GET_STATUS;
    ControlData.DeviceStatus = 0;
    ControlData.DeviceProblem = 0;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (NT_SUCCESS(ntStatus)) {
        *pulStatus = ControlData.DeviceStatus;
        *pulProblem = ControlData.DeviceProblem;
    } else {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // GetDeviceStatus



CONFIGRET
SetDeviceStatus(
    IN LPCWSTR pszDeviceID,
    IN ULONG   ulStatus,
    IN ULONG   ulProblem
    )

/*++

Routine Description:

   This routine sets the status and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Specifies the device's status

   pulProblem     Specifies the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_SET_STATUS;
    ControlData.DeviceStatus = ulStatus;
    ControlData.DeviceProblem = ulProblem;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // SetDeviceStatus



CONFIGRET
ClearDeviceStatus(
    IN LPCWSTR pszDeviceID,
    IN ULONG   ulStatus,
    IN ULONG   ulProblem
    )

/*++

Routine Description:

   This routine clears the followingstatus and problem values for the given
   device instance.

Arguments:

   pszDeviceID    Specifies the device instance to retrieve info for

   pulStatus      Specifies the device's status

   pulProblem     Specifies the device's problem

Return value:

    The return value is CR_SUCCESS if the function suceeds and one of the
    CR_* values if it fails.

--*/

{
    CONFIGRET   Status = CR_SUCCESS;
    PLUGPLAY_CONTROL_STATUS_DATA ControlData;
    NTSTATUS    ntStatus;

    memset(&ControlData, 0, sizeof(PLUGPLAY_CONTROL_STATUS_DATA));
    RtlInitUnicodeString(&ControlData.DeviceInstance, pszDeviceID);
    ControlData.Operation = PNP_CLEAR_STATUS;
    ControlData.DeviceStatus = ulStatus;
    ControlData.DeviceProblem = ulProblem;

    ntStatus = NtPlugPlayControl(PlugPlayControlDeviceStatus,
                                 &ControlData,
                                 sizeof(ControlData));

    if (!NT_SUCCESS(ntStatus)) {
        Status = MapNtStatusToCmError(ntStatus);
    }

    return Status;

} // ClearDeviceStatus



CONFIGRET
GetProfileCount(
   OUT PULONG  pulProfiles
   )

{
   WCHAR       RegStr[MAX_CM_PATH];
   HKEY        hKey = NULL;


   //
   // open the Known Docking States key
   //
   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegPathIDConfigDB,
            pszRegKeyKnownDockingStates);

   if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ,
            &hKey) != ERROR_SUCCESS) {

      *pulProfiles = 0;
      return CR_REGISTRY_ERROR;
   }

   //
   // find out the total number of profiles
   //
   if (RegQueryInfoKey(
            hKey, NULL, NULL, NULL, pulProfiles, NULL, NULL, NULL,
            NULL, NULL, NULL, NULL) != ERROR_SUCCESS) {

      *pulProfiles = 0;
      RegCloseKey(hKey);
      return CR_REGISTRY_ERROR;
   }

   RegCloseKey(hKey);

   return CR_SUCCESS;

} // GetProfileCount



CONFIGRET
CopyRegistryTree(
   IN HKEY     hSrcKey,
   IN HKEY     hDestKey,
   IN ULONG    ulOption
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   HKEY        hSrcSubKey, hDestSubKey;
   WCHAR       RegStr[MAX_PATH];
   ULONG       ulMaxValueName, ulMaxValueData;
   ULONG       ulDataSize, ulLength, ulType, i;
   LPWSTR      pszValueName=NULL;
   LPBYTE      pValueData=NULL;
   PSECURITY_DESCRIPTOR pSecDesc;


   //----------------------------------------------------------------
   // copy all values for this key
   //----------------------------------------------------------------

   //
   // find out the maximum size of any of the value names
   // and value data under the source device instance key
   //
   RegStatus = RegQueryInfoKey(
         hSrcKey, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
         &ulMaxValueName, &ulMaxValueData, NULL, NULL);

   if (RegStatus != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   ulMaxValueName++;       // size doesn't already include null terminator

   //
   // allocate a buffer big enough to hold the largest value name and
   // the largest value data (note that the max value name is in chars
   // (not including the null terminator) and the max value data is
   // in bytes
   //
   pszValueName = HeapAlloc(ghPnPHeap, 0, ulMaxValueName * sizeof(WCHAR));
   if (pszValueName == NULL) {
      Status = CR_OUT_OF_MEMORY;
      goto Clean0;
   }

   pValueData = HeapAlloc(ghPnPHeap, 0, ulMaxValueData);
   if (pValueData == NULL) {
      Status = CR_OUT_OF_MEMORY;
      goto Clean0;
   }

   //
   // enumerate and copy each value
   //
   for (i=0; RegStatus == ERROR_SUCCESS; i++) {

      ulLength = ulMaxValueName;
      ulDataSize = ulMaxValueData;

      RegStatus = RegEnumValue(
                  hSrcKey, i, pszValueName, &ulLength, NULL,
                  &ulType, pValueData, &ulDataSize);

        if (RegStatus == ERROR_SUCCESS) {

           RegSetValueEx(
                  hDestKey, pszValueName, 0, ulType, pValueData,
                  ulDataSize);
        }
    }

    HeapFree(ghPnPHeap, 0, pszValueName);
    pszValueName = NULL;

    HeapFree(ghPnPHeap, 0, pValueData);
    pValueData = NULL;


    //---------------------------------------------------------------
    // recursively call CopyRegistryNode to copy all subkeys
    //---------------------------------------------------------------

    RegStatus = ERROR_SUCCESS;

    for (i=0; RegStatus == ERROR_SUCCESS; i++) {

      ulLength = MAX_PATH;

      RegStatus = RegEnumKey(hSrcKey, i, RegStr, ulLength);

      if (RegStatus == ERROR_SUCCESS) {

         if (RegOpenKey(hSrcKey, RegStr, &hSrcSubKey) == ERROR_SUCCESS) {

            if (RegCreateKeyEx(
                     hDestKey, RegStr, 0, NULL, ulOption, KEY_ALL_ACCESS,
                     NULL, &hDestSubKey, NULL) == ERROR_SUCCESS) {

               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION,
                     NULL, &ulDataSize);

               pSecDesc = HeapAlloc(ghPnPHeap, 0, ulDataSize);
               if (pSecDesc == NULL) {
                  Status = CR_OUT_OF_MEMORY;
                  RegCloseKey(hSrcSubKey);
                  RegCloseKey(hDestSubKey);
                  goto Clean0;
               }

               RegGetKeySecurity(hSrcSubKey, DACL_SECURITY_INFORMATION,
                     pSecDesc, &ulDataSize);

               CopyRegistryTree(hSrcSubKey, hDestSubKey, ulOption);

               RegSetKeySecurity(hDestSubKey, DACL_SECURITY_INFORMATION, pSecDesc);

               HeapFree(ghPnPHeap, 0, pSecDesc);
               RegCloseKey(hDestSubKey);
            }
            RegCloseKey(hSrcSubKey);
         }
      }
   }

   Clean0:

   if (pszValueName != NULL) {
      HeapFree(ghPnPHeap, 0, pszValueName);
   }
   if (pValueData != NULL) {
      pValueData = NULL;
   }

   return Status;

} // CopyRegistryTree



BOOL
PathToString(
   IN LPWSTR   pszString,
   IN LPCWSTR  pszPath,
   IN ULONG    ulLen
   )
{
   LPWSTR p;

   lstrcpyn(pszString, pszPath,ulLen);

   for (p = pszString; *p; p++) {
      if (*p == TEXT('\\')) {
         *p = TEXT('&');
      }
   }

   return TRUE;

} // PathToString



BOOL
IsDeviceMoved(
   IN LPCWSTR  pszDeviceID,
   IN HKEY     hKey
   )
{
   HKEY  hTempKey;
   WCHAR RegStr[MAX_CM_PATH];

   PathToString(RegStr, pszDeviceID,MAX_CM_PATH);

   if (RegOpenKeyEx(
        hKey, RegStr, 0, KEY_READ, &hTempKey) == ERROR_SUCCESS) {
      RegCloseKey(hTempKey);
      return TRUE;
   }

   return FALSE;

} // IsDeviceMoved



CONFIGRET
MakeKeyVolatile(
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH], szTempKey[MAX_CM_PATH];
   HKEY        hParentKey = NULL, hChildKey = NULL, hKey = NULL,
               hTempKey = NULL;


   //---------------------------------------------------------------------
   // Convert the registry key specified by pszChildKey (a subkey of
   // pszParentKey) to a volatile key by copying it to a temporary key
   // and recreating a volatile key, then copying the original
   // registry info back. This also converts and subkeys of pszChildKey.
   //---------------------------------------------------------------------


   //
   // Open a key to the parent
   //
   RegStatus = RegOpenKeyEx(
         HKEY_LOCAL_MACHINE, pszParentKey, 0, KEY_ALL_ACCESS, &hParentKey);

   if (RegStatus != ERROR_SUCCESS) {
      goto Clean0;         // nothing to convert
   }

   //
   // open a key to the child subkey
   //
   RegStatus = RegOpenKeyEx(
         hParentKey, pszChildKey, 0, KEY_ALL_ACCESS, &hChildKey);

   if (RegStatus != ERROR_SUCCESS) {
      goto Clean0;         // nothing to convert
   }

   //
   // 1. Open a unique temporary volatile key under the special Deleted Key.
   // Use the parent key path to form the unique tempory key. There shouldn't
   // already be such a key, but if there is then just overwrite it.
   //
   RegStatus = RegOpenKeyEx(
         HKEY_LOCAL_MACHINE, pszRegPathCurrentControlSet, 0,
         KEY_ALL_ACCESS, &hKey);

   if (RegStatus != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   wsprintf(RegStr, TEXT("%s\\%s"),
         pszParentKey,
         pszChildKey);

   PathToString(szTempKey, RegStr,MAX_CM_PATH);

   wsprintf(RegStr, TEXT("%s\\%s"),
         pszRegKeyDeleted,
         szTempKey);

   RegStatus = RegCreateKeyEx(
         hKey, RegStr, 0, NULL, REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
         NULL, &hTempKey, NULL);

   if (RegStatus != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   //
   // 2. Save the current child key (any any subkeys) to a temporary
   // location
   //
   Status = CopyRegistryTree(hChildKey, hTempKey, REG_OPTION_VOLATILE);

   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   RegCloseKey(hChildKey);
   hChildKey = NULL;

   //
   // 3. Delete the current child key (and any subkeys)
   //
   if (!RegDeleteNode(hParentKey, pszChildKey)) {
      Status = CR_REGISTRY_ERROR;
      goto CleanupTempKeys;
   }

   //
   // 4. Recreate the current child key as a volatile key
   //
   RegStatus = RegCreateKeyEx(
         hParentKey, pszChildKey, 0, NULL, REG_OPTION_VOLATILE,
         KEY_ALL_ACCESS, NULL, &hChildKey, NULL);

   if (RegStatus != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto CleanupTempKeys;
   }

   //
   // 5. Copy the original child key (and any subkeys) back
   // to the new volatile child key
   //
   Status = CopyRegistryTree(hTempKey, hChildKey, REG_OPTION_VOLATILE);

   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   //
   // 6. Remove the temporary volatile instance key (and any subkeys)
   //
   CleanupTempKeys:

   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
      hTempKey = NULL;
   }

   wsprintf(RegStr, TEXT("%s\\%s"),
         pszRegPathCurrentControlSet,
         pszRegKeyDeleted);

   RegStatus = RegOpenKeyEx(
         HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS, &hTempKey);

   if (RegStatus != ERROR_SUCCESS) {
      goto Clean0;
   }

   RegDeleteNode(hTempKey, szTempKey);

   Clean0:

   if (hParentKey != NULL) {
      RegCloseKey(hParentKey);
   }
   if (hChildKey != NULL) {
      RegCloseKey(hChildKey);
   }
   if (hKey != NULL) {
      RegCloseKey(hKey);
   }
   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
   }

   return Status;

} // MakeKeyVolatile



CONFIGRET
MakeKeyNonVolatile(
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )

{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[MAX_CM_PATH], szTempKey[MAX_CM_PATH];
   HKEY        hParentKey = NULL, hChildKey = NULL, hKey = NULL,
               hTempKey = NULL;


   //---------------------------------------------------------------------
   // Convert the registry key specified by pszChildKey (a subkey of
   // pszParentKey) to a non volatile key by copying it to a temporary key
   // and recreating a nonvolatile key, then copying the original
   // registry info back. This also converts any subkeys of pszChildKey.
   //---------------------------------------------------------------------


   //
   // Open a key to the parent
   //
   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszParentKey, 0, KEY_ALL_ACCESS,
                    &hParentKey) != ERROR_SUCCESS) {
      goto Clean0;         // nothing to convert
   }

   //
   // open a key to the child subkey
   //
   if (RegOpenKeyEx(hParentKey, pszChildKey, 0, KEY_ALL_ACCESS,
                    &hChildKey) != ERROR_SUCCESS) {
      goto Clean0;         // nothing to convert
   }

   //
   // 1. Open a unique temporary volatile key under the special Deleted Key.
   // Use the parent key path to form the unique tempory key. There shouldn't
   // already be such a key, but if there is then just overwrite it.
   //
  if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegPathCurrentControlSet, 0,
                   KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   wsprintf(RegStr, TEXT("%s\\%s"),
            pszParentKey,
            pszChildKey);

   PathToString(szTempKey, RegStr,MAX_CM_PATH);

   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegKeyDeleted,
            szTempKey);

   if (RegCreateKeyEx(hKey, RegStr, 0, NULL, REG_OPTION_VOLATILE,
                      KEY_ALL_ACCESS, NULL, &hTempKey, NULL) != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto Clean0;
   }

   //
   // 2. Save the current child key (and any subkeys) to a temporary
   // location
   //
   Status = CopyRegistryTree(hChildKey, hTempKey, REG_OPTION_VOLATILE);
   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   RegCloseKey(hChildKey);
   hChildKey = NULL;

   //
   // 3. Delete the current child key (and any subkeys)
   //
   if (!RegDeleteNode(hParentKey, pszChildKey)) {
      Status = CR_REGISTRY_ERROR;
      goto CleanupTempKeys;
   }

   //
   // 4. Recreate the current child key as a non-volatile key
   //
   if (RegCreateKeyEx(hParentKey, pszChildKey, 0, NULL,
                      REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                      &hChildKey, NULL) != ERROR_SUCCESS) {
      Status = CR_REGISTRY_ERROR;
      goto CleanupTempKeys;
   }

   //
   // 5. Copy the original child key (and any subkeys) back
   // to the new volatile child key
   //
   Status = CopyRegistryTree(hTempKey, hChildKey, REG_OPTION_NON_VOLATILE);
   if (Status != CR_SUCCESS) {
      goto CleanupTempKeys;
   }

   //
   // 6. Remove the temporary volatile instance key (and any subkeys)
   //
   CleanupTempKeys:

   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
      hTempKey = NULL;
   }

   wsprintf(RegStr, TEXT("%s\\%s"),
            pszRegPathCurrentControlSet,
            pszRegKeyDeleted);

   if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
                    &hTempKey) != ERROR_SUCCESS) {
      goto Clean0;
   }

   RegDeleteNode(hTempKey, szTempKey);

   Clean0:

   if (hParentKey != NULL) {
      RegCloseKey(hParentKey);
   }
   if (hChildKey != NULL) {
      RegCloseKey(hChildKey);
   }
   if (hKey != NULL) {
      RegCloseKey(hKey);
   }
   if (hTempKey != NULL) {
      RegCloseKey(hTempKey);
   }

   return Status;

} // MakeKeyNonVolatile



CONFIGRET
OpenLogConfKey(
    IN  LPCWSTR  pszDeviceID,
    IN  ULONG    LogConfType,
    OUT PHKEY    phKey
    )
{
    CONFIGRET      Status = CR_SUCCESS;
    LONG           RegStatus = ERROR_SUCCESS;
    HKEY           hKey = NULL;
    ULONG          ulSize = 0;

    try {

        //
        // Open a key to the device ID
        //

        RegStatus = RegOpenKeyEx(ghEnumKey, pszDeviceID, 0,
                                 KEY_QUERY_VALUE | KEY_SET_VALUE | KEY_CREATE_SUB_KEY,
                                 &hKey);

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_INVALID_DEVINST;
            goto Clean0;
        }

        //
        // Alloc/Filtered configs are the exception, it's stored in the volative Control
        // subkey, all the other log confs are stored under the nonvolatile
        // LogConf subkey.
        //

        if ((LogConfType == ALLOC_LOG_CONF) || (LogConfType == FILTERED_LOG_CONF)) {

            //
            // Try the control key first, if no alloc config value there,
            // then try the log conf key.
            //

            RegStatus = RegCreateKeyEx(hKey, pszRegKeyDeviceControl, 0, NULL,
                                       REG_OPTION_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);

            if (RegStatus == ERROR_SUCCESS) {
                if (RegQueryValueEx(*phKey, pszRegValueAllocConfig, NULL, NULL,
                                    NULL, &ulSize) == ERROR_SUCCESS) {
                    goto Clean0;
                }
                RegCloseKey(*phKey);
            }

            RegStatus = RegCreateKeyEx(hKey, pszRegKeyLogConf, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);

        } else {
            RegStatus = RegCreateKeyEx(hKey, pszRegKeyLogConf, 0, NULL,
                                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                                       NULL, phKey, NULL);
        }

        if (RegStatus != ERROR_SUCCESS) {
            Status = CR_REGISTRY_ERROR;
        }

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = CR_FAILURE;
    }

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }

    return Status;

} // OpenLogConfKey



BOOL
GetActiveService(
    IN  PCWSTR pszDevice,
    OUT PWSTR  pszService
    )
{
    WCHAR   RegStr[MAX_PATH];
    HKEY    hKey = NULL;
    ULONG   ulSize = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);


    if (pszService == NULL || pszDevice == NULL) {
        return FALSE;
    }

    *pszService = TEXT('\0');

    //
    // open the volatile control key under the device instance
    //
    wsprintf(RegStr, TEXT("%s\\%s\\%s"),
         pszRegPathEnum,
         pszDevice,
         pszRegKeyDeviceControl);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ,
                     &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // query the active service value
    //
    if (RegQueryValueEx(hKey, pszRegValueActiveService, NULL, NULL,
                       (LPBYTE)pszService, &ulSize) != ERROR_SUCCESS) {
        RegCloseKey(hKey);
        *pszService = TEXT('\0');
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;

} // GetActiveService



BOOL
IsDeviceIdPresent(
    IN  LPCWSTR pszDeviceID
    )

/*++

Routine Description:

     This routine determines whether the specified device instance is
     considered physically present or not. This used to be based on a check
     of the old "FoundAtEnum" registry setting. Now we just look for the presense
     of an in-memory devnode associated with this device instance to decide whether
     it's present or not.

Arguments:

    pszDeviceID - device instance string to test for presense on

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
    ULONG   ulStatus, ulProblem;

    //
    // If the call failed, then assume the device isn't present
    //

    return GetDeviceStatus(pszDeviceID, &ulStatus, &ulProblem) == CR_SUCCESS;

} // IsDeviceIdPresent



ULONG
GetDeviceConfigFlags(
    IN  LPCWSTR pszDeviceID,
    IN  HKEY    hKey
    )
{
    HKEY     hDevKey = NULL;
    ULONG    ulValue = 0, ulSize = sizeof(ULONG);


    //
    // If hKey is null, then open a key to the device instance.
    //
    if (hKey == NULL) {

        if (RegOpenKeyEx(ghEnumKey, pszDeviceID, 0, KEY_READ,
                         &hDevKey) != ERROR_SUCCESS) {
            goto Clean0;
        }

    } else {
        hDevKey = hKey;
    }

    //
    // Retrieve the configflag value
    //
    if (RegQueryValueEx(hDevKey, pszRegValueConfigFlags, NULL, NULL,
                        (LPBYTE)&ulValue, &ulSize) != ERROR_SUCCESS) {
        ulValue = 0;
    }

    Clean0:

    if ((hKey == NULL) && (hDevKey != NULL)) {
        RegCloseKey(hDevKey);
    }

    return ulValue;

} // GetDeviceConfigFlags



ULONG
MapNtStatusToCmError(
    ULONG NtStatus
    )
{
    switch (NtStatus) {
    case STATUS_BUFFER_TOO_SMALL:
        return CR_BUFFER_SMALL;

    case STATUS_NO_SUCH_DEVICE:
        return CR_NO_SUCH_DEVINST;

    case STATUS_INVALID_PARAMETER:
        return CR_INVALID_DATA;

    case STATUS_NOT_IMPLEMENTED:
        return CR_CALL_NOT_IMPLEMENTED;

    case STATUS_ACCESS_DENIED:
        return CR_ACCESS_DENIED;

    case STATUS_OBJECT_NAME_NOT_FOUND:
        return CR_NO_SUCH_VALUE;

    default:
        return CR_FAILURE;
    }

} // MapNtStatusToCmError



BOOL
VerifyKernelInitiatedEjectPermissions(
    IN  HANDLE  UserToken   OPTIONAL,
    IN  BOOL    DockDevice
    )
/*++

Routine Description:

   Checks that the user has eject permissions for the specified type of
   hardware.

Arguments:

    UserToken - Token of the logged in console user, NULL if no console user
                is logged in.

    DockDevice - TRUE if a dock is being ejected, FALSE if an ordinary device
                 was specified.

Return Value:

   TRUE if the eject should procceed, FALSE otherwise.

--*/
{
    BOOL            bSuccess, bResult;
    PRIVILEGE_SET   privilegeSet;
    WCHAR           regStr[MAX_CM_PATH];
    HKEY            hKey = NULL;
    ULONG           ulSize, ulResult;

    if (!DockDevice) {

        //
        // We do not specify per device ejection security. This is not
        // typically a problem as most devices are in no way secure from
        // removal.
        //
        return TRUE;
    }

    //
    // Not logged in, no user.
    //
    if (UserToken == NULL) {

        //
        // Open the policy key.
        //
        wsprintf(regStr, TEXT("%s\\%s"), pszRegPathPolicies, pszRegKeySystem);

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         regStr,
                         0,
                         KEY_READ,
                         &hKey) != ERROR_SUCCESS) {

           return FALSE;
        }

        //
        // Snarf out the value.
        //
        ulSize = sizeof(ULONG);

        if (RegQueryValueEx(hKey,
                            pszRegValueUndockWithoutLogon,
                            NULL,
                            NULL,
                            (LPBYTE)&ulResult,
                            &ulSize) != ERROR_SUCCESS) {

            //
            // No key means allow any undock.
            //
            bResult = TRUE;

        } else {

            //
            // One means allow any undock, zero means require login.
            //
            bResult = (ulResult != 0);
        }

        RegCloseKey(hKey);
        return bResult;
    }

    if ((gLuidUndockPrivilege.LowPart == 0) &&
        (gLuidUndockPrivilege.HighPart == 0)) {

        //
        // Uninitialized LUID, most likely LookupPrivilegeValue failed
        // during initialization, we'll pretend like they don't have
        // access in this case.
        //
        return FALSE;
    }

    privilegeSet.PrivilegeCount = 1;
    privilegeSet.Control = 0;
    privilegeSet.Privilege[0].Luid = gLuidUndockPrivilege;
    privilegeSet.Privilege[0].Attributes = 0;

    if (!PrivilegeCheck(UserToken, &privilegeSet, &bResult)) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: PrivilegeCheck failed, error = %d\n",
                   GetLastError()));
    }

    return bResult;

} // VerifyKernelInitiatedEjectPermissions



DWORD
GuidFromString(
    IN  PCTSTR GuidString,
    OUT LPGUID Guid
    )
/*++

Routine Description:

    This routine converts the character representation of a GUID into its binary
    form (a GUID struct).  The GUID is in the following form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where 'x' is a hexadecimal digit.

Arguments:

    GuidString - Supplies a pointer to the null-terminated GUID string.  The

    Guid - Supplies a pointer to the variable that receives the GUID structure.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is RPC_S_INVALID_STRING_UUID.

--*/
{
    TCHAR UuidBuffer[GUID_STRING_LEN - 1];

    //
    // Since we're using a RPC UUID routine, we need to strip off the surrounding
    // curly braces first.
    //
    if(*GuidString++ != TEXT('{')) {
        return RPC_S_INVALID_STRING_UUID;
    }

    lstrcpyn(UuidBuffer, GuidString, SIZECHARS(UuidBuffer));

    if((lstrlen(UuidBuffer) != GUID_STRING_LEN - 2) ||
       (UuidBuffer[GUID_STRING_LEN - 3] != TEXT('}'))) {

        return RPC_S_INVALID_STRING_UUID;
    }

    UuidBuffer[GUID_STRING_LEN - 3] = TEXT('\0');

    return ((UuidFromString(UuidBuffer, Guid) == RPC_S_OK) ? NO_ERROR : RPC_S_INVALID_STRING_UUID);

} // GuidFromString



DWORD
StringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    )
/*++

Routine Description:

    This routine converts a GUID into a null-terminated string which represents
    it.  This string is of the form:

    {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}

    where x represents a hexadecimal digit.

    This routine comes from ole32\common\ccompapi.cxx.  It is included here to avoid linking
    to ole32.dll.  (The RPC version allocates memory, so it was avoided as well.)

Arguments:

    Guid - Supplies a pointer to the GUID whose string representation is
        to be retrieved.

    GuidString - Supplies a pointer to character buffer that receives the
        string.  This buffer must be _at least_ 39 (GUID_STRING_LEN) characters
        long.

Return Value:

    If success, the return value is NO_ERROR.
    if failure, the return value is

--*/
{
    CONST BYTE *GuidBytes;
    INT i;

    if(GuidStringSize < GUID_STRING_LEN) {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    GuidBytes = (CONST BYTE *)Guid;

    *GuidString++ = TEXT('{');

    for(i = 0; i < sizeof(GuidMap); i++) {

        if(GuidMap[i] == '-') {
            *GuidString++ = TEXT('-');
        } else {
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *GuidString++ = szDigits[ (GuidBytes[GuidMap[i]] & 0x0F) ];
        }
    }

    *GuidString++ = TEXT('}');
    *GuidString   = TEXT('\0');

    return NO_ERROR;

} // StringFromGuid

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\umpnpdat.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    umpnpdat.h

Abstract:

    This module contains extern declarations for the global strings
    in umpnpdat.c

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include <windows.h>


//
// global strings
//

extern WCHAR pszRegPathCurrentControlSet[];
extern WCHAR pszRegPathEnum[];
extern WCHAR pszRegPathClass[];
extern WCHAR pszRegPathDeviceClasses[];
extern WCHAR pszRegPathServices[];
extern WCHAR pszRegPathHwProfiles[];
extern WCHAR pszRegPathCurrent[];
extern WCHAR pszRegPathIDConfigDB[];
extern WCHAR pszRegPathPerHwIdStorage[];

extern WCHAR pszRegKeySystem[];
extern WCHAR pszRegKeyEnum[];
extern WCHAR pszRegKeyCurrent[];
extern WCHAR pszRegKeyCurrentDockInfo[];
extern WCHAR pszRegKeyKnownDockingStates[];
extern WCHAR pszRegKeyDeviceParam[];
extern WCHAR pszRegKeyRootEnum[];
extern WCHAR pszRegKeyDeleted[];
extern WCHAR pszRegKeyLogConf[];
extern WCHAR pszRegKeyDeviceControl[];
extern WCHAR pszRegKeyProperties[];

extern WCHAR pszRegValueDeviceInstance[];
extern WCHAR pszRegValueDeviceDesc[];
extern WCHAR pszRegValueNewDeviceDesc[];
extern WCHAR pszRegValueSlotNumber[];
extern WCHAR pszRegValuePortName[];
extern WCHAR pszRegValueHardwareIDs[];
extern WCHAR pszRegValueCompatibleIDs[];
extern WCHAR pszRegValueSystemBusNumber[];
extern WCHAR pszRegValueBusDataType[];
extern WCHAR pszRegValueInterfaceType[];
extern WCHAR pszRegValueService[];
extern WCHAR pszRegValueDetectSignature[];
extern WCHAR pszRegValueClass[];
extern WCHAR pszRegValueClassGuid[];
extern WCHAR pszRegValueDriver[];
extern WCHAR pszRegValueInstanceIdentifier[];
extern WCHAR pszRegValueDuplicateOf[];
extern WCHAR pszRegValueCSConfigFlags[];
extern WCHAR pszRegValueConfigFlags[];
extern WCHAR pszRegValueDisableCount[];
extern WCHAR pszRegValueUnknownProblems[];
extern WCHAR pszRegValueCurrentConfig[];
extern WCHAR pszRegValueFriendlyName[];
extern WCHAR pszRegValueDockState[];
extern WCHAR pszRegValueDockingState[];
extern WCHAR pszRegValueEjectableDocks[];
extern WCHAR pszRegValuePreferenceOrder[];
extern WCHAR pszRegValueUserWaitInterval[];
extern WCHAR pszRegValuePhantom[];
extern WCHAR pszRegValueFirmwareIdentified[];
extern WCHAR pszRegValueFirmwareMember[];
extern WCHAR pszRegValueMfg[];
extern WCHAR pszRegValueCount[];
extern WCHAR pszRegValueBootConfig[];
extern WCHAR pszRegValueAllocConfig[];
extern WCHAR pszRegValueForcedConfig[];
extern WCHAR pszRegValueOverrideVector[];
extern WCHAR pszRegValueBasicVector[];
extern WCHAR pszRegValueFilteredVector[];
extern WCHAR pszRegValueActiveService[];
extern WCHAR pszRegValuePlugPlayServiceType[];
extern WCHAR pszRegValueLocationInformation[];
extern WCHAR pszRegValueCapabilities[];
extern WCHAR pszRegValueUiNumber[];
extern WCHAR pszRegValueUiNumberDescFormat[];
extern WCHAR pszRegValueRemovalPolicyOverride[];
extern WCHAR pszRegValueUpperFilters[];
extern WCHAR pszRegValueLowerFilters[];
extern WCHAR pszRegValueSecurity[];
extern WCHAR pszRegValueDevType[];
extern WCHAR pszRegValueExclusive[];
extern WCHAR pszRegValueCharacteristics[];
extern WCHAR pszRegValueMigrated[];

extern WCHAR pszControlFlags[];
extern WCHAR pszInteractiveInstall[];

extern WCHAR pszRegValuePhysicalDeviceObject[];
extern WCHAR pszRegRootEnumerator[];

extern WCHAR pszRegPathPolicies[];
extern WCHAR pszRegValueUndockWithoutLogon[];

extern WCHAR pszRegValueCustomPropertyCacheDate[];
extern WCHAR pszRegValueCustomPropertyHwIdKey[];
extern WCHAR pszRegValueLastUpdateTime[];

extern WCHAR pszRegKeyPlugPlayServiceParams[];
extern WCHAR pszRegValueDebugInstall[];
extern WCHAR pszRegValueDebugInstallCommand[];

#if DBG
extern WCHAR pszRegValueDebugFlags[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\umpnpdat.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    umpnpdat.c

Abstract:

    This module contains global strings.

Author:

    Paula Tomlinson (paulat) 8-20-1995

Environment:

    User mode only.

Revision History:

    6-Jun-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#include <pnpmgr.h>

//
// global registry strings
//
WCHAR pszRegPathCurrentControlSet[] =     REGSTR_PATH_CURRENTCONTROLSET;
WCHAR pszRegPathEnum[] =                  REGSTR_PATH_SYSTEMENUM;
WCHAR pszRegPathClass[] =                 REGSTR_PATH_CLASS_NT;
WCHAR pszRegPathDeviceClasses[] =         REGSTR_PATH_DEVICE_CLASSES;
WCHAR pszRegPathServices[] =              REGSTR_PATH_SERVICES;
WCHAR pszRegPathHwProfiles[] =            REGSTR_PATH_HWPROFILES;
WCHAR pszRegPathCurrent[] =               REGSTR_PATH_HWPROFILESCURRENT;
WCHAR pszRegPathIDConfigDB[] =            REGSTR_PATH_IDCONFIGDB;
WCHAR pszRegPathPerHwIdStorage[] =        REGSTR_PATH_PER_HW_ID_STORAGE;

WCHAR pszRegKeySystem[] =                 REGSTR_KEY_SYSTEM;
WCHAR pszRegKeyEnum[] =                   REGSTR_KEY_ENUM;
WCHAR pszRegKeyCurrent[] =                REGSTR_KEY_CURRENT;
WCHAR pszRegKeyCurrentDockInfo[] =        REGSTR_KEY_CURRENT_DOCK_INFO;
WCHAR pszRegKeyKnownDockingStates[] =     REGSTR_KEY_KNOWNDOCKINGSTATES;
WCHAR pszRegKeyDeviceParam[] =            REGSTR_KEY_DEVICEPARAMETERS;
WCHAR pszRegKeyRootEnum[] =               REGSTR_KEY_ROOTENUM;
WCHAR pszRegKeyDeleted[] =                REGSTR_KEY_DELETEDDEVICE;
WCHAR pszRegKeyLogConf[] =                REGSTR_KEY_LOGCONF;
WCHAR pszRegKeyDeviceControl[] =          REGSTR_KEY_DEVICECONTROL;
WCHAR pszRegKeyProperties[] =             REGSTR_KEY_DEVICE_PROPERTIES;

WCHAR pszRegValueDeviceInstance[] =       REGSTR_VAL_DEVICE_INSTANCE;
WCHAR pszRegValueDeviceDesc[] =           REGSTR_VAL_DEVDESC;
WCHAR pszRegValueNewDeviceDesc[] =        REGSTR_VAL_NEW_DEVICE_DESC;
WCHAR pszRegValueSlotNumber[] =           REGSTR_VAL_SLOTNUMBER;
WCHAR pszRegValuePortName[] =             REGSTR_VAL_PORTNAME;
WCHAR pszRegValueHardwareIDs[] =          REGSTR_VAL_HARDWAREID;
WCHAR pszRegValueCompatibleIDs[] =        REGSTR_VAL_COMPATIBLEIDS;
WCHAR pszRegValueSystemBusNumber[] =      REGSTR_VAL_SYSTEMBUSNUMBER;
WCHAR pszRegValueBusDataType[] =          REGSTR_VAL_BUSDATATYPE;
WCHAR pszRegValueInterfaceType[] =        REGSTR_VAL_INTERFACETYPE;
WCHAR pszRegValueService[] =              REGSTR_VAL_SERVICE;
WCHAR pszRegValueDetectSignature[] =      REGSTR_VAL_DETECTSIGNATURE;
WCHAR pszRegValueClass[] =                REGSTR_VAL_CLASS;
WCHAR pszRegValueClassGuid[] =            REGSTR_VAL_CLASSGUID;
WCHAR pszRegValueDriver[] =               REGSTR_VAL_DRIVER;
WCHAR pszRegValueInstanceIdentifier[] =   REGSTR_VAL_INSTANCEIDENTIFIER;
WCHAR pszRegValueDuplicateOf[] =          REGSTR_VAL_DUPLICATEOF;
WCHAR pszRegValueCSConfigFlags[] =        REGSTR_VAL_CSCONFIGFLAGS;
WCHAR pszRegValueConfigFlags[] =          REGSTR_VAL_CONFIGFLAGS;
WCHAR pszRegValueDisableCount[] =         REGSTR_VAL_DISABLECOUNT;
WCHAR pszRegValueUnknownProblems[] =      REGSTR_VAL_UNKNOWNPROBLEMS;
WCHAR pszRegValueCurrentConfig[] =        REGSTR_VAL_CURCONFIG;
WCHAR pszRegValueFriendlyName[] =         REGSTR_VAL_FRIENDLYNAME;
WCHAR pszRegValueDockState[] =            REGSTR_VAL_DOCKSTATE;
WCHAR pszRegValueDockingState[] =         TEXT("DockingState");
WCHAR pszRegValueEjectableDocks[] =       REGSTR_VAL_EJECTABLE_DOCKS;
WCHAR pszRegValuePreferenceOrder[] =      REGSTR_VAL_PREFERENCEORDER;
WCHAR pszRegValueUserWaitInterval[] =     REGSTR_VAL_USERWAITINTERVAL;
WCHAR pszRegValuePhantom[] =              REGSTR_VAL_PHANTOM;
WCHAR pszRegValueFirmwareIdentified[] =   REGSTR_VAL_FIRMWAREIDENTIFIED;
WCHAR pszRegValueFirmwareMember[] =       REGSTR_VAL_FIRMWAREMEMBER;
WCHAR pszRegValueMfg[] =                  REGSTR_VAL_MFG;
WCHAR pszRegValueCount[] =                REGSTR_VAL_Count;
WCHAR pszRegValueBootConfig[] =           REGSTR_VAL_BOOTCONFIG;
WCHAR pszRegValueAllocConfig[] =          REGSTR_VAL_ALLOCCONFIG;
WCHAR pszRegValueForcedConfig[] =         REGSTR_VAL_FORCEDCONFIG;
WCHAR pszRegValueOverrideVector[] =       REGSTR_VAL_OVERRIDECONFIGVECTOR;
WCHAR pszRegValueBasicVector[] =          REGSTR_VAL_BASICCONFIGVECTOR;
WCHAR pszRegValueFilteredVector[] =       REGSTR_VAL_FILTEREDCONFIGVECTOR;
WCHAR pszRegValueActiveService[] =        REGSTR_VAL_ACTIVESERVICE;
WCHAR pszRegValuePlugPlayServiceType[] =  REGSTR_VAL_PNPSERVICETYPE;
WCHAR pszRegValueLocationInformation[] =  REGSTR_VAL_LOCATION_INFORMATION;
WCHAR pszRegValueCapabilities[] =         REGSTR_VAL_CAPABILITIES;
WCHAR pszRegValueUiNumber[] =             REGSTR_VAL_UI_NUMBER;
WCHAR pszRegValueUiNumberDescFormat[] =   REGSTR_VAL_UI_NUMBER_DESC_FORMAT;
WCHAR pszRegValueRemovalPolicyOverride[]= REGSTR_VAL_REMOVAL_POLICY;
WCHAR pszRegValueUpperFilters[] =         REGSTR_VAL_UPPERFILTERS;
WCHAR pszRegValueLowerFilters[] =         REGSTR_VAL_LOWERFILTERS;
WCHAR pszRegValueSecurity[] =             REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR;
WCHAR pszRegValueDevType[] =              REGSTR_VAL_DEVICE_TYPE;
WCHAR pszRegValueExclusive[] =            REGSTR_VAL_DEVICE_EXCLUSIVE;
WCHAR pszRegValueCharacteristics[] =      REGSTR_VAL_DEVICE_CHARACTERISTICS;
WCHAR pszRegValueMigrated[] =             TEXT("Migrated");

WCHAR pszControlFlags[] =                 INFSTR_CONTROLFLAGS_SECTION;
WCHAR pszInteractiveInstall[] =           INFSTR_KEY_INTERACTIVEINSTALL;

WCHAR pszRegValuePhysicalDeviceObject[] = REGSTR_VAL_PHYSICALDEVICEOBJECT;
WCHAR pszRegRootEnumerator[] =            REGSTR_VAL_ROOT_DEVNODE;

WCHAR pszRegPathPolicies[] =              REGSTR_PATH_POLICIES;
WCHAR pszRegValueUndockWithoutLogon[] =   REGSTR_VAL_UNDOCK_WITHOUT_LOGON;

WCHAR pszRegValueCustomPropertyCacheDate[] = REGSTR_VAL_CUSTOM_PROPERTY_CACHE_DATE;
WCHAR pszRegValueCustomPropertyHwIdKey[]   = REGSTR_VAL_CUSTOM_PROPERTY_HW_ID_KEY;
WCHAR pszRegValueLastUpdateTime[]          = REGSTR_VAL_LAST_UPDATE_TIME;

WCHAR pszRegKeyPlugPlayServiceParams[] =  TEXT("PlugPlay\\Parameters");
WCHAR pszRegValueDebugInstall[] =         TEXT("DebugInstall");
WCHAR pszRegValueDebugInstallCommand[] =  TEXT("DebugInstallCommand");

#if DBG
WCHAR pszRegValueDebugFlags[] =           TEXT("DebugFlags");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\acpitabl.h ===
/*****************************************************************************
 *
 *      (C) Copyright MICROSOFT Corp., 1996
 *
 *      Title:          ACPITABL.H --- Definitions and descriptions of the various BIOS supplied ACPI tables.
 *
 *      Version:        1.00
 *
 *      Date:           6-17-96
 *
 *      Author:         Jason Clark (jasoncl)
 *
 *------------------------------------------------------------------------------
 *
 *      Change log:
 *
 *         DATE     REV DESCRIPTION
 *      ----------- --- -----------------------------------------------------------
 *
 ****************************************************************************/

//      These map to bios provided structures, so turn on 1 byte packing

#ifndef _ACPITABL_H
#define _ACPITABL_H

#ifdef ASL_ASSEMBLER
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS ULONGLONG
#define UNALIGNED
#endif

#include <pshpack1.h>

// Generic Register Address Structure

typedef struct _GEN_ADDR {
    UCHAR               AddressSpaceID;
    UCHAR               BitWidth;
    UCHAR               BitOffset;
    UCHAR               Reserved;
    PHYSICAL_ADDRESS    Address;
} GEN_ADDR, *PGEN_ADDR;

#define RSDP_SIGNATURE 0x2052545020445352       // "RSD PTR "

typedef struct  _RSDP {     // Root System Description Table Pointer Structure
    ULONGLONG       Signature;  // 8 UCHAR table signature 'RSD PTR '
    UCHAR           Checksum;   // checksum for first 20 bytes of table (entire ACPI 1.0 table)
    UCHAR           OEMID[6];   //      String that uniquely ID's the OEM
    UCHAR           Revision;   // 0 - ACPI 1.0;  2 - ACPI 2.0
    ULONG           RsdtAddress;// physical address of Root System Description Table  (1.0 table ended here)
    ULONG           Length;     // Length of the table in bytes
    PHYSICAL_ADDRESS XsdtAddress;// physical address of XSDT
    UCHAR           XChecksum;  // checksum for entire table
    UCHAR           Reserved[3];
} RSDP, *PRSDP;

#define RSDP_SEARCH_RANGE_BEGIN         0xE0000         // physical address where we begin searching for the RSDP
#define RSDP_SEARCH_RANGE_END           0xFFFFF
#define RSDP_SEARCH_RANGE_LENGTH        (RSDP_SEARCH_RANGE_END-RSDP_SEARCH_RANGE_BEGIN+1)
#define RSDP_SEARCH_INTERVAL            16      // search on 16 byte boundaries


typedef struct _DESCRIPTION_HEADER      {       // Header structure appears at the beginning of each ACPI table

ULONG   Signature;                      //      Signature used to identify the type of table
ULONG   Length;                         //      Length of entire table including the DESCRIPTION_HEADER
UCHAR   Revision;                       //      Minor version of ACPI spec to which this table conforms
UCHAR   Checksum;                       //      sum of all bytes in the entire TABLE should = 0
UCHAR   OEMID[6];                       //      String that uniquely ID's the OEM
UCHAR   OEMTableID[8];                  //      String that uniquely ID's this table (used for table patching and replacement).
ULONG   OEMRevision;                    //      OEM supplied table revision number.  Bigger number = newer table.
UCHAR   CreatorID[4];                   //      Vendor ID of utility which created this table.
ULONG   CreatorRev;                     //      Revision of utility that created the table.
}       DESCRIPTION_HEADER;
typedef DESCRIPTION_HEADER      *PDESCRIPTION_HEADER;

// Header constants

#define ACPI_MAX_SIGNATURE       4
#define ACPI_MAX_OEM_ID          6
#define ACPI_MAX_TABLE_ID        8
#define ACPI_MAX_TABLE_STRINGS   ACPI_MAX_SIGNATURE + ACPI_MAX_OEM_ID + ACPI_MAX_TABLE_ID

#define FACS_SIGNATURE  0x53434146      // "FACS"

typedef enum {
    AcpiGenericSpaceMemory = 0,
    AcpiGenericSpaceIO,
    AcpiGenericSpacePciConfig,
    AcpiGenericSpaceEC,
    AcpiGenericSpaceSMBus,
    AcpiGenericSpaceFixedFunction = 0x7F
} ACPI_GENERIC_ADDRESS_TYPE, *PACPI_GENERIC_ADDRESS_TYPE;

typedef struct _FACS    {       // Firmware ACPI Control Structure.  Note that this table does not have a header, it is pointed to by the FADT
    ULONG           Signature;      //      'FACS'
    ULONG           Length;         //      Length of entire firmware ACPI control structure (must be 64 bytes or larger)
    ULONG           HardwareSignature;
    ULONG           pFirmwareWakingVector;  // physical address of location where the OS needs to put the firmware waking vector
    ULONG           GlobalLock;     // 32 bit structure used for sharing Embedded Controller
    ULONG           Flags;
    PHYSICAL_ADDRESS x_FirmwareWakingVector; // 64-bit capable firmware vector
    UCHAR           version;
    UCHAR           Reserved[31];
} FACS, *PFACS;

// FACS.GlobalLock bit field definitions

#define         GL_PENDING_BIT          0x00
#define         GL_PENDING                      (1 << GL_PENDING_BIT)

#define         GL_OWNER_BIT            0x01
#define         GL_OWNER                        (1 << GL_OWNER_BIT)

#define GL_NON_RESERVED_BITS_MASK       (GL_PENDING+GL_OWNED)

// FACS Flags definitions

#define         FACS_S4BIOS_SUPPORTED_BIT   0   // flag indicates whether or not the BIOS will save/restore memory around S4
#define         FACS_S4BIOS_SUPPORTED       (1 << FACS_S4BIOS_SUPPORTED_BIT)


#define FADT_SIGNATURE  0x50434146      // "FACP"

typedef struct _FADT    {               // Fixed ACPI description table

DESCRIPTION_HEADER      Header;

ULONG           facs;                   // Physical address of the Firmware ACPI Control Structure
ULONG           dsdt;                   // Physical address of the Differentiated System Description Table
UCHAR           int_model;              // System's Interrupt mode, 0=Dual PIC, 1=Multiple APIC, >1 reserved
UCHAR           pm_profile;             // System's preferred power profile
USHORT          sci_int_vector;         // Vector of SCI interrupt.
ULONG           smi_cmd_io_port;        // Address in System I/O Space of the SMI Command port, used to enable and disable ACPI.
UCHAR           acpi_on_value;          // Value out'd to smi_cmd_port to activate ACPI
UCHAR           acpi_off_value;         // Value out'd to smi_cmd_port to deactivate ACPI
UCHAR           s4bios_req;             // Value to write to SMI_CMD to enter the S4 state.
UCHAR           pstate_control;         // Value to write to SMI_CMD to assume control of processor performance states
ULONG           pm1a_evt_blk_io_port;   // Address in System I/O Space of the PM1a_EVT_BLK register block
ULONG           pm1b_evt_blk_io_port;   // Address in System I/O Space of the PM1b_EVT_BLK register block
ULONG           pm1a_ctrl_blk_io_port;  // Address in System I/O Space of the PM1a_CNT_BLK register block
ULONG           pm1b_ctrl_blk_io_port;  // Address in System I/O Space of the PM1b_CNT_BLK register block
ULONG           pm2_ctrl_blk_io_port;   // Address in System I/O Space of the PM2_CNT_BLK register block
ULONG           pm_tmr_blk_io_port;     // Address in System I/O Space of the PM_TMR register block
ULONG           gp0_blk_io_port;        // Address in System I/O Space of the GP0 register block
ULONG           gp1_blk_io_port;        // Address in System I/O Space of the GP1 register block
UCHAR           pm1_evt_len;            // number of bytes decoded for PM1_BLK (must be >= 4)
UCHAR           pm1_ctrl_len;           // number of bytes decoded for PM1_CNT (must be >= 2)
UCHAR           pm2_ctrl_len;           // number of bytes decoded for PM1a_CNT (must be >= 1)
UCHAR           pm_tmr_len;             // number of bytes decoded for PM_TMR (must be >= 4)
UCHAR           gp0_blk_len;            // number of bytes decoded for GP0_BLK (must be multiple of 2)
UCHAR           gp1_blk_len;            // number of bytes decoded for GP1_BLK (must be multiple of 2)
UCHAR           gp1_base;               // index at which GP1 based events start
UCHAR           cstate_control;         // Value to write to SMI_CMD to assume control of _CST states
USHORT          lvl2_latency;           // Worst case latency in microseconds required to enter and leave the C2 processor state
USHORT          lvl3_latency;           // Worst case latency in microseconds required to enter and leave the C3 processor state
USHORT          flush_size;             // Ignored if WBINVD flag is 1 -- indicates size of memory read to flush dirty lines from
                                        //      any processors memory caches. A size of zero indicates this is not supported.
USHORT          flush_stride;           // Ignored if WBINVD flag is 1 -- the memory stride width, in bytes, to perform reads to flush
                                        //      the processor's memory caches.
UCHAR           duty_offset;            // zero based index of where the processor's duty cycle setting is within the processor's P_CNT register.
UCHAR           duty_width;             // bit width of the processor's duty cycle setting value in the P_CNT register.
                                        //      a value of zero indicates that processor duty cycle is not supported
UCHAR           day_alarm_index;
UCHAR           month_alarm_index;
UCHAR           century_alarm_index;
USHORT          boot_arch;
UCHAR           reserved3[1];
ULONG           flags;                  // This is the last field if the table Revision is 1
GEN_ADDR        reset_reg;
UCHAR           reset_val;              // This is the last field if the table Revision is 2
UCHAR           reserved4[3];
PHYSICAL_ADDRESS x_firmware_ctrl;
PHYSICAL_ADDRESS x_dsdt;
GEN_ADDR        x_pm1a_evt_blk;
GEN_ADDR        x_pm1b_evt_blk;
GEN_ADDR        x_pm1a_ctrl_blk;
GEN_ADDR        x_pm1b_ctrl_blk;
GEN_ADDR        x_pm2_ctrl_blk;
GEN_ADDR        x_pm_tmr_blk;
GEN_ADDR        x_gp0_blk;
GEN_ADDR        x_gp1_blk;              // This is the last field if the table Revision is 3
} FADT, *PFADT;

#define FADT_REV_1_SIZE   (FIELD_OFFSET(FADT, flags) + sizeof(ULONG))
#define FADT_REV_2_SIZE   (FIELD_OFFSET(FADT, reset_val) + sizeof(UCHAR))
#define FADT_REV_3_SIZE   (FIELD_OFFSET(FADT, x_gp1_blk) + sizeof(GEN_ADDR))


//
// Static Resource Affinity Table
//
// This table describes the static topology of a ccNUMA machine.
//

#define ACPI_SRAT_SIGNATURE  0x54415253 // "SRAT"

typedef struct _ACPI_SRAT {
    DESCRIPTION_HEADER  Header;
    ULONG               TableRevision;
    ULONG               Reserved[2];
} ACPI_SRAT, *PACPI_SRAT;

typedef struct _ACPI_SRAT_ENTRY {
    UCHAR                       Type;
    UCHAR                       Length;
    UCHAR                       ProximityDomain;
    union {
        struct {
            UCHAR               ApicId;
            struct {
                ULONG           Enabled:1;
                ULONG           Reserved:31;
            }                   Flags;
            UCHAR               SApicEid;
            UCHAR               Reserved[7];
        } ApicAffinity;
        struct {
            UCHAR               Reserved[5];
            PHYSICAL_ADDRESS    Base;
            ULONGLONG           Length;
            struct {
                ULONG           Enabled:1;
                ULONG           HotPlug:1;
                ULONG           Reserved:30;
            }                   Flags;
            UCHAR               Reserved2[8];
        } MemoryAffinity;
    };
} ACPI_SRAT_ENTRY, *PACPI_SRAT_ENTRY;

typedef enum {
    SratProcessorLocalAPIC,
    SratMemory
} SRAT_ENTRY_TYPE;


#ifdef _IA64_
// FLUSH WORKS IS FOR IA64
#define         FLUSH_WORKS_BIT           0
#define         FLUSH_WORKS               (1 << FLUSH_WORKS_BIT)
#endif // IA64

// definition of FADT.flags bits

// this one bit flag indicates whether or not the WBINVD instruction works properly,if this bit is not set we can not use S2, S3 states, or
// C3 on MP machines
#define         WRITEBACKINVALIDATE_WORKS_BIT           0
#define         WRITEBACKINVALIDATE_WORKS               (1 << WRITEBACKINVALIDATE_WORKS_BIT)

//  this flag indicates if wbinvd works EXCEPT that it does not invalidate the cache
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT   1
#define         WRITEBACKINVALIDATE_DOESNT_INVALIDATE       (1 << WRITEBACKINVALIDATE_DOESNT_INVALIDATE_BIT)

//  this flag indicates that the C1 state is supported on all processors.
#define         SYSTEM_SUPPORTS_C1_BIT                  2
#define         SYSTEM_SUPPORTS_C1                      (1 << SYSTEM_SUPPORTS_C1_BIT)

// this one bit flag indicates whether support for the C2 state is restricted to uniprocessor machines
#define         P_LVL2_UP_ONLY_BIT                      3
#define         P_LVL2_UP_ONLY                          (1 << P_LVL2_UP_ONLY_BIT)

//      this bit indicates whether the PWR button is treated as a fix feature (0) or a generic feature (1)
#define         PWR_BUTTON_GENERIC_BIT                  4
#define         PWR_BUTTON_GENERIC                      (1 << PWR_BUTTON_GENERIC_BIT)

#define         SLEEP_BUTTON_GENERIC_BIT                5
#define         SLEEP_BUTTON_GENERIC                    (1 << SLEEP_BUTTON_GENERIC_BIT)

//      this bit indicates whether the RTC wakeup status is reported in fix register space (0) or not (1)
#define         RTC_WAKE_GENERIC_BIT                    6
#define         RTC_WAKE_GENERIC                        (1 << RTC_WAKE_GENERIC_BIT)

#define         RTC_WAKE_FROM_S4_BIT                    7
#define         RTC_WAKE_FROM_S4                        (1 << RTC_WAKE_FROM_S4_BIT)

// This bit indicates whether the machine implements a 24 or 32 bit timer.
#define         TMR_VAL_EXT_BIT                         8
#define         TMR_VAL_EXT                             (1 << TMR_VAL_EXT_BIT)

// This bit indicates whether the machine supports docking
#define         DCK_CAP_BIT                             9
#define         DCK_CAP                                 (1 << DCK_CAP_BIT)

// This bit indicates whether the machine supports reset
#define         RESET_CAP_BIT                           10
#define         RESET_CAP                               (1 << RESET_CAP_BIT)

// This bit indicates whether the machine case can be opened
#define         SEALED_CASE_BIT                         11
#define         SEALED_CASE_CAP                         (1 << SEALED_CASE_BIT)

// This bit indicates whether the machine has no video
#define         HEADLESS_BIT                            12
#define         HEADLESS_CAP                            (1 << HEADLESS_BIT)

//      spec defines maximum entry/exit latency values for C2 and C3, if the FADT indicates that these values are
//      exceeded then we do not use that C state.

#define         C2_MAX_LATENCY  100
#define         C3_MAX_LATENCY  1000

//
// Definition of FADT.boot_arch flags
//

#define LEGACY_DEVICES  1
#define I8042           2


#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY   1
#endif

// Multiple APIC description table

typedef struct _MAPIC   {

DESCRIPTION_HEADER  Header;
ULONG               LocalAPICAddress;   // Physical Address at which each processor can access its local APIC
ULONG               Flags;
ULONG               APICTables[ANYSIZE_ARRAY];  // A list of APIC tables.

}       MAPIC;

typedef MAPIC *PMAPIC;

// Multiple APIC structure flags

#define PCAT_COMPAT_BIT 0   // indicates that the system also has a dual 8259 pic setup.
#define PCAT_COMPAT     (1 << PCAT_COMPAT_BIT)

// APIC Structure Types
#define PROCESSOR_LOCAL_APIC                0
#define IO_APIC                             1
#define ISA_VECTOR_OVERRIDE                 2
#define IO_NMI_SOURCE                       3
#define LOCAL_NMI_SOURCE                    4
#define ADDRESS_EXTENSION_STRUCTURE         5
#define IO_SAPIC                            6
#define LOCAL_SAPIC                         7
#define PLATFORM_INTERRUPT_SOURCE           8

#define PROCESSOR_LOCAL_APIC_LENGTH         8
#define IO_APIC_LENGTH                      12
#define ISA_VECTOR_OVERRIDE_LENGTH          10

#define IO_NMI_SOURCE_LENGTH                8
#define LOCAL_NMI_SOURCE_LENGTH             6
#define PLATFORM_INTERRUPT_SOURCE_LENGTH    16
#define IO_SAPIC_LENGTH                     16
#define PROCESSOR_LOCAL_SAPIC_LENGTH        12

// Platform Interrupt Types
#define PLATFORM_INT_PMI  1
#define PLATFORM_INT_INIT 2
#define PLATFORM_INT_CPE  3

// These defines come from the MPS 1.4 spec, section 4.3.4 and they are referenced as
// such in the ACPI spec.
#define PO_BITS                     3
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0
#define EL_BITS                     0xc
#define EL_BIT_SHIFT                2
#define EL_EDGE_TRIGGERED           4
#define EL_LEVEL_TRIGGERED          0xc
#define EL_CONFORMS_WITH_BUS        0

// The shared beginning info in all APIC Structures

typedef struct _APICTABLE {
   UCHAR Type;
   UCHAR Length;
} APICTABLE;

typedef APICTABLE UNALIGNED *PAPICTABLE;

typedef struct _PROCLOCALAPIC   {

    UCHAR   Type;   // should be zero to identify a ProcessorLocalAPIC structure
    UCHAR   Length; // better be 8
    UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
                                // operator.
    UCHAR   APICID; //  The processor's local APIC ID.
    ULONG   Flags;

} PROCLOCALAPIC;

typedef PROCLOCALAPIC UNALIGNED *PPROCLOCALAPIC;

// Processor Local APIC Flags
#define PLAF_ENABLED_BIT    0
#define PLAF_ENABLED        (1 << PLAF_ENABLED_BIT)

typedef struct _IOAPIC  {

    UCHAR   Type;
    UCHAR   Length; // better be 12
    UCHAR   IOAPICID;
    UCHAR   Reserved;
    ULONG   IOAPICAddress; // Physical address at which this IO APIC resides.
    ULONG   SystemVectorBase; // system interrupt vector index for this APIC

} IOAPIC;

typedef IOAPIC UNALIGNED *PIOAPIC;

// Interrupt Source Override
typedef struct _ISA_VECTOR {
    UCHAR   Type;                           // Must be 2
    UCHAR   Length;                         // Must be 10
    UCHAR   Bus;                            // Must be 0
    UCHAR   Source;                         // BusRelative IRQ
    ULONG   GlobalSystemInterruptVector;    // Global IRQ
    USHORT  Flags;                          // Same as MPS INTI Flags
#ifdef _IA64_   // XXTF
    UCHAR   Reserved[6];                    // 6 bytes reserved as per 64 bit
                                            // extensions to ACPI spec v0.7
#endif
} ISA_VECTOR;

typedef ISA_VECTOR UNALIGNED *PISA_VECTOR;

// I/O Non-Maskable Source Interrupt
typedef struct _IO_NMISOURCE {
    UCHAR   Type;                           // must be 3
    UCHAR   Length;                         // better be 8
    USHORT  Flags;                          // Same as MPS INTI Flags
    ULONG   GlobalSystemInterruptVector;    // Interrupt connected to NMI
} IO_NMISOURCE;

typedef IO_NMISOURCE UNALIGNED *PIO_NMISOURCE;

// Local Non-Maskable Interrupt Source
typedef struct _LOCAL_NMISOURCE {
    UCHAR   Type;                           // must be 4
    UCHAR   Length;                         // better be 6
    UCHAR   ProcessorID;                    // which processor?  0xff means all
    USHORT  Flags;
    UCHAR   LINTIN;                         // which LINTIN# signal on the processor
} LOCAL_NMISOURCE;

typedef LOCAL_NMISOURCE UNALIGNED *PLOCAL_NMISOURCE;

typedef struct _PROCLOCALSAPIC   {
    UCHAR   Type;               // PROCESSOR_LOCAL_SAPIC
    UCHAR   Length;             // PROCESSOR_LOCAL_SAPIC_LENGTH
                                //     operator.
    UCHAR   ACPIProcessorID;    // ProcessorID for which this processor is listed in the ACPI processor declaration
    UCHAR   APICID;             //  The processor's local APIC ID.
    UCHAR   APICEID;            //  The processor's local APIC EID.
    UCHAR   Reserved[3];
    ULONG   Flags;
} PROCLOCALSAPIC;

typedef PROCLOCALSAPIC UNALIGNED *PPROCLOCALSAPIC;

typedef struct _IOSAPIC  {
    UCHAR   Type;               // IO_SAPIC
    UCHAR   Length;             // IO_SAPIC_LENGTH
    USHORT  Reserved;
    ULONG   SystemVectorBase;   // system interrupt vector index for this SAPIC
    ULONG_PTR  IOSAPICAddress;   // 64-bit Physical address at which this IO APIC resides.
} IOSAPIC;

typedef IOSAPIC UNALIGNED *PIOSAPIC;

typedef struct _PLATFORM_INTERRUPT {
    UCHAR   Type;               // PLATFORM_INTERRUPT_SOURCE
    UCHAR   Length;             // PLATFORM_INTERRUPT_SOURCE_LENGTH
    USHORT  Flags;              // Same as MPS INTI Flags
    UCHAR   InterruptType;
    UCHAR   APICID;
    UCHAR   ACPIEID;
    UCHAR   IOSAPICVector;
    ULONG   GlobalVector;
    ULONG   Reserved;
} PLATFORM_INTERRUPT;

typedef PLATFORM_INTERRUPT UNALIGNED *PPLATFORM_INTERRUPT;

//
// Smart Battery
//

typedef struct _SMARTBATTTABLE   {

DESCRIPTION_HEADER  Header;
ULONG   WarningEnergyLevel; // mWh at which the OEM suggests we warn the user that the battery is getting low.
ULONG   LowEnergyLevel;     // mWh at which the OEM suggests we put the machine into a sleep state.
ULONG   CriticalEnergyLevel; // mWH at which the OEM suggests we do an emergency shutdown.

}       SMARTBATTTABLE;

typedef SMARTBATTTABLE *PSMARTBATTTABLE;

#define RSDT_SIGNATURE  0x54445352      // "RSDT"
#define XSDT_SIGNATURE  0x54445358      // "XSDT"

typedef struct _RSDT_32    {       // Root System Description Table

DESCRIPTION_HEADER      Header;
ULONG   Tables[ANYSIZE_ARRAY];     // The structure contains an n length array of physical addresses each of which point to another table.
}       RSDT_32;

typedef struct _RSDT_64    {       // Root System Description Table
    DESCRIPTION_HEADER      Header;
    ULONG                   Reserved;               // 4 bytes reserved as per 64 bit extensions to ACPI spec v0.7
    ULONG_PTR               Tables[ANYSIZE_ARRAY];  // The structure contains an n length array of physical addresses each of which point to another table.
} RSDT_64;

#ifdef _IA64_ // XXTF
typedef RSDT_64 RSDT;
#else
typedef RSDT_32 RSDT;
#endif // _IA64_ XXTF

typedef RSDT    *PRSDT;

typedef struct _XSDT {
    DESCRIPTION_HEADER  Header;
    UNALIGNED PHYSICAL_ADDRESS Tables[ANYSIZE_ARRAY];
} XSDT, *PXSDT;


// The below macro uses the min macro to protect against the case where we are running on machine which is compliant with
// a spec prior to .99.  If you had a .92 compliant header and one table pointer we would end of subtracting 32-36 resulting
// in a really big number and hence we would think we had lots and lots of tables...  Using the min macro we end up subtracting
// the length-length getting zero which will be harmless and cause us to fail to load (with a red screen on Win9x) which is
// the best we can do in this case.

#ifndef min
#define min(a,b)    (((a) < (b)) ? (a) : (b))
#endif

//
// BUGBUG John Vert (jvert) 4/26/2000
//   alpha64 machines are still running with 32-bit RSDTs. Once that support is dropped we can
//   remove this hack.
//
#ifdef _IA64_
#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(ULONG_PTR)
#else
#define NumTableEntriesFromRSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(ULONG)
#endif
#define NumTableEntriesFromXSDTPointer(p)   (p->Header.Length-min(p->Header.Length,sizeof(DESCRIPTION_HEADER)))/sizeof(PHYSICAL_ADDRESS)


#define APIC_SIGNATURE  0x43495041      // "APIC"
#define SPIC_SIGNATURE  0x43495053      // "SPIC"  = SAPIC (IA64 extensions to ACPI requirement)
#define DSDT_SIGNATURE  0x54445344      // "DSDT"
#define SSDT_SIGNATURE  0x54445353      // "SSDT"
#define PSDT_SIGNATURE  0x54445350      // "PSDT"
#define SBST_SIGNATURE  0x54534253      // "SBST"
#define DBGP_SIGNATURE  0x50474244      // "DBGP"

typedef struct _DSDT    {       // Differentiated System Description Table

DESCRIPTION_HEADER      Header;
UCHAR                   DiffDefBlock[ANYSIZE_ARRAY];    // this is the AML describing the base system.

}       DSDT;

typedef DSDT            *PDSDT;

//      Resume normal structure packing

#include <poppack.h>

typedef struct _PROC_LOCAL_APIC {
    UCHAR   NamespaceProcID;
    UCHAR   ApicID;
    UCHAR   NtNumber;
    BOOLEAN Started;
    BOOLEAN Enumerated;
} PROC_LOCAL_APIC, *PPROC_LOCAL_APIC;

extern PROC_LOCAL_APIC HalpProcLocalApicTable[];

//
// Debug Port Table
//
#pragma pack(1)
typedef struct _DEBUG_PORT_TABLE {

    DESCRIPTION_HEADER  Header;
    UCHAR               InterfaceType;          // Type of registry interface (0 = full 16550 interface)
    UCHAR               Reserved0[3];           // should be 0
    GEN_ADDR            BaseAddress;            // Base address of the Debug Port register set
                                                // described using the Generic Register Address
                                                // Structure.
                                                // 0   - console redirection disabled.
                                                // e.g. COM1 (0x3F8) would be 0x1800000003F8
                                                //      COM2 (Ox2F8) would be 0x1800000002F8


    UCHAR               InterruptType;          // Interrupt type(s) used by the UART.
                                                // bit 0 = PC-AT-compatible 8259 IRQ interrupt.
                                                // bit 1 = I/O APIC interrupt (Global System INterrupt)
                                                // bit 2 = I/O SAPIC interrupt (Global System Interrupt) (IRQ)
                                                // bit 3:7 = reserved (and must be 0)
                                                // Note: bit == 1 indicates support, bit == 0 indicates no support.
                                                //
                                                // Platforms with both a dual 8259 and an I/O APIC or I/O SAPIC
                                                // must set the IRQ bit (bit 0) and the corresponding Global
                                                // system interrupt bit.  E.g. a system that supported 8259 and
                                                // SAPIC would be 0x5.

    UCHAR               Irq;                    // 0  = none
                                                // 2  = 2
                                                // 3  = 3
                                                // ...
                                                // 16 = 16
                                                // 1, 17-255 reserved

    ULONG               GlobalSystemInterruptVector;
                                                // The I/O APIC or I/O SAPIC Global System Interrupt used
                                                // by the UART.Valid only if Bit[1] or Bit[2] of the
                                                // Interrupt Type field is set.

    UCHAR               BaudRate;               // Baudrate for BIOS redirection
                                                // 3 = 9600
                                                // 4 = 19200
                                                // 6 = 57600
                                                // 7 = 115200
                                                // 0-2,5, 8-255 reserved

    UCHAR               Parity;                 // 0 = no parity
                                                // 1-255 reserved

    UCHAR               StopBits;               // 1 = 1 stop bit
                                                // 0, 2-255 = reserved

    UCHAR               FlowControl;            // 0 = Hadware Flow Control
                                                // 1 - 255 = reserved.

    UCHAR               TerminalType;           // The terminal protocol the BIOS was using for
                                                // console redirection
                                                // 0 = VT100
                                                // 1 = Extended VT100
                                                // 2-255 = reserved

    UCHAR               Language;               // Language which the BIOS was redirecting
                                                // 0 = US Western English (standard ASCII)

    USHORT              PciDeviceId;            // Designates device ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    USHORT              PciVendorId;            // Designates vendor ID of a PCI device that
                                                // contains a UART to be used as a headless
                                                // port.

    UCHAR               PciBusNumber;           // Designates which PCI system bus the PCI device
                                                // resides on.

    UCHAR               PciSlotNumber;          // Designates which PCI slot the PCI device
                                                // resides in.

    UCHAR               PciFunctionNumber;      // Which PCI function number describes the UART.

    ULONG               PciFlags;               // PCI compatibility flags bitmask.  Should be zero
                                                // by default.
                                                // 0x1 indicates operating system should NOT suppress
                                                // PnP device enumeration or disable power management
                                                // for this device.
                                                // bits 1-31 reserved.

    UCHAR               Reserved1[4];           // should be 0

} DEBUG_PORT_TABLE, *PDEBUG_PORT_TABLE;
#pragma pack()

//
// BOOT Table -- based on Simple Boot Flag Specification 1.0
//

typedef struct _BOOT_TABLE {

    DESCRIPTION_HEADER  Header;
    UCHAR               CMOSIndex;
    UCHAR               Reserved[3];
} BOOT_TABLE, *PBOOT_TABLE;

#define BOOT_SIGNATURE  0x544f4f42 // 'BOOT'

//
// Bits in the Boot Register
//

//
// Set by OS to indicate that the bios need only configure boot devices
//

#define SBF_PNPOS_BIT       0
#define SBF_PNPOS           (1 << SBF_PNPOS_BIT)

//
// Set by BIOS to indicate beginning of boot, cleared by OS to indicate a successful boot
//

#define SBF_BOOTING_BIT     1
#define SBF_BOOTING         (1 << SBF_BOOTING_BIT)

//
// Set by BIOS to indicate a diagnostic boot
//

#define SBF_DIAG_BIT        2
#define SBF_DIAG            (1 << SBF_DIAG_BIT)

//
// Set to ensure ODD parity
//

#define SBF_PARITY_BIT      7
#define SBF_PARITY          (1 << SBF_PARITY_BIT)

//
// IPPT Table --  IA64 Platform Properties Table
//

typedef struct _IPPT_TABLE {
    DESCRIPTION_HEADER  Header;
    ULONG               Flags;
    ULONG               Reserved[3];
} IPPT_TABLE, *PIPPT_TABLE;

#define IPPT_DISABLE_WRITE_COMBINING       0x01L
#define IPPT_ENABLE_CROSS_PARTITION_IPI    0x02L
#define IPPT_DISABLE_PTCG_TB_FLUSH         0x04L
#define IPPT_DISABLE_UC_MAIN_MEMORY        0x08L

#define IPPT_SIGNATURE  0x54505049 // 'IPPT'

#endif // _ACPITBL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\srventry.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    srventry.c

Abstract:

    This module contains the main entry for the User-mode Plug-and-Play Service.
    It also contains the service control handler and service status update
    routines.

Author:

    Paula Tomlinson (paulat) 6-8-1995

Environment:

    User-mode only.

Revision History:

    8-June-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//

#include "precomp.h"
#include "umpnpi.h"

#include <svcsp.h>


//
// private prototypes
//

DWORD
PnPControlHandlerEx(
    IN  DWORD  dwControl,
    IN  DWORD  dwEventType,
    IN  LPVOID lpEventData,
    IN  LPVOID lpContext
    );

VOID
PnPServiceStatusUpdate(
    SERVICE_STATUS_HANDLE   hSvcHandle,
    DWORD    dwState,
    DWORD    dwCheckPoint,
    DWORD    dwExitCode
    );


//
// global data
//

PSVCS_GLOBAL_DATA       PnPGlobalData = NULL;
HANDLE                  PnPGlobalSvcRefHandle = NULL;
DWORD                   CurrentServiceState = SERVICE_START_PENDING;
SERVICE_STATUS_HANDLE   hSvcHandle = 0;




VOID
SVCS_ENTRY_POINT(
    DWORD               argc,
    LPWSTR              argv[],
    PSVCS_GLOBAL_DATA   SvcsGlobalData,
    HANDLE              SvcRefHandle
    )
/*++

Routine Description:

    This is the main routine for the User-mode Plug-and-Play Service. It
    registers itself as an RPC server and notifies the Service Controller
    of the PNP service control entry point.

Arguments:

    argc, argv     - Command-line arguments, not used.

    SvcsGlobalData - Global data for services running in services.exe that
                     contains function entry points and pipe name for
                     establishing an RPC server interface for this service.

    SvcRefHandle   - Service reference handle, not used.

Return Value:

    None.

Note:

    None.

--*/
{
    DWORD       Status;
    HANDLE      hThread;
    DWORD       ThreadID;

    UNREFERENCED_PARAMETER(argc);
    UNREFERENCED_PARAMETER(argv);

    //
    // Save the global data and service reference handle in global variables
    //
    PnPGlobalSvcRefHandle = SvcRefHandle;
    PnPGlobalData = SvcsGlobalData;

    //
    // Register our service ctrl handler
    //
    if ((hSvcHandle = RegisterServiceCtrlHandlerEx(L"PlugPlay",
                                                   (LPHANDLER_FUNCTION_EX)PnPControlHandlerEx,
                                                   NULL)) == 0) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: RegisterServiceCtrlHandlerEx failed, error = %d\n",
                   GetLastError()));
        return;
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 1, 0);

    //
    // Initialize the PNP service to recieve RPC requests
    //
    // NOTE:  Now all RPC servers in services.exe share the same pipe name.
    // However, in order to support communication with version 1.0 of WinNt,
    // it is necessary for the Client Pipe name to remain the same as
    // it was in version 1.0.  Mapping to the new name is performed in
    // the Named Pipe File System code.
    //
    if ((Status = PnPGlobalData->StartRpcServer(
        PnPGlobalData->SvcsRpcPipeName,
        pnp_ServerIfHandle)) != NO_ERROR) {

        KdPrintEx((DPFLTR_PNPMGR_ID,
                   DBGF_ERRORS,
                   "UMPNPMGR: StartRpcServer failed with Status = %d\n",
                   Status));
        return;
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 2, 0);

    //
    // Lookup the "LoadDriver" and "Undock" privileges.
    //
    if (gLuidLoadDriverPrivilege.LowPart == 0 && gLuidLoadDriverPrivilege.HighPart == 0) {
        if (!LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &gLuidLoadDriverPrivilege)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: LookupPrivilegeValue failed, error = %d\n",
                       GetLastError()));
        }
    }

    if (gLuidUndockPrivilege.LowPart == 0 && gLuidUndockPrivilege.HighPart == 0) {
        if (!LookupPrivilegeValue(NULL, SE_UNDOCK_NAME, &gLuidUndockPrivilege)) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "UMPNPMGR: LookupPrivilegeValue failed, error = %d\n",
                       GetLastError()));
        }
    }

    //
    // Notify Service Controller that we're alive
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_START_PENDING, 3, 0);

    //
    // Initialize pnp manager
    //
    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)InitializePnPManager,
                           NULL,
                           0,
                           &ThreadID);

    if (hThread != NULL) {
        CloseHandle(hThread);
    }

    //
    // Notify Service Controller that we're now running
    //
    PnPServiceStatusUpdate(hSvcHandle, SERVICE_RUNNING, 0, 0);

    //
    // Service initialization is complete.
    //
    return;

} // SVCS_ENTRY_POINT



DWORD
PnPControlHandlerEx(
    IN  DWORD  dwControl,
    IN  DWORD  dwEventType,
    IN  LPVOID lpEventData,
    IN  LPVOID lpContext
    )
/*++

Routine Description:

    This is the service control handler of the Plug-and-Play service.

Arguments:

    dwControl   - The requested control code.

    dwEventType - The type of event that has occurred.

    lpEventData - Additional device information, if required.

    lpContext   - User-defined data, not used.

Return Value:

    Returns NO_ERROR if sucessful, otherwise returns an error code describing
    the problem.

--*/
{

    UNREFERENCED_PARAMETER(lpContext);

    switch (dwControl) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            //
            // If we aren't already in the middle of a stop, then
            // stop the PNP service now and perform the necessary cleanup.
            //
            if (CurrentServiceState != SERVICE_STOPPED &&
                CurrentServiceState != SERVICE_STOP_PENDING) {

                //
                // Notify Service Controller that we're stopping
                //
                PnPServiceStatusUpdate(hSvcHandle, SERVICE_STOP_PENDING, 1, 0);

                //
                // Stop the RPC server
                //
                PnPGlobalData->StopRpcServer(pnp_ServerIfHandle);

                //
                // Notify Service Controller that we've now stopped
                //
                PnPServiceStatusUpdate(hSvcHandle, SERVICE_STOPPED, 0, 0);
            }
            break;

        case SERVICE_CONTROL_INTERROGATE:
            //
            // Request to immediately notify Service Controller of
            // current status
            //
            PnPServiceStatusUpdate(hSvcHandle, CurrentServiceState, 0, 0);
            break;

        case SERVICE_CONTROL_SESSIONCHANGE:
            //
            // Session change notification.
            //
            SessionNotificationHandler(dwEventType, (PWTSSESSION_NOTIFICATION)lpEventData);
            break;

        default:
            //
            // No special handling for any other service controls.
            //
            break;
    }

    return NO_ERROR;

} // PnPControlHandlerEx



VOID
PnPServiceStatusUpdate(
      SERVICE_STATUS_HANDLE   hSvcHandle,
      DWORD    dwState,
      DWORD    dwCheckPoint,
      DWORD    dwExitCode
      )
/*++

Routine Description:

    This routine notifies the Service Controller of the current status of the
    Plug-and-Play service.

Arguments:

    hSvcHandle   - Supplies the service status handle for the Plug-and-Play service.

    dwState      - Specifies the current state of the service to report.

    dwCheckPoint - Specifies an intermediate checkpoint for operations during
                   which the state is pending.

    dwExitCode   - Specifies a service specific error code.

Return Value:

    None.

Note:

    This routine also updates the set of controls accepted by the service.

    The PlugPlay service currently accepts the following controls when the
    service is running:

      SERVICE_CONTROL_SHUTDOWN      - the system is shutting down.

      SERVICE_CONTROL_SESSIONCHANGE - the state of some remote or console session
                                      has changed.

--*/
{
   SERVICE_STATUS    SvcStatus;

   SvcStatus.dwServiceType = SERVICE_WIN32;
   SvcStatus.dwCurrentState = CurrentServiceState = dwState;
   SvcStatus.dwCheckPoint = dwCheckPoint;

   if (dwState == SERVICE_RUNNING) {
      SvcStatus.dwControlsAccepted = SERVICE_ACCEPT_SHUTDOWN | SERVICE_ACCEPT_SESSIONCHANGE;
   } else {
      SvcStatus.dwControlsAccepted = 0;
   }

   if ((dwState == SERVICE_START_PENDING) ||
       (dwState == SERVICE_STOP_PENDING)) {
      SvcStatus.dwWaitHint = 45000;          // 45 seconds
   } else {
      SvcStatus.dwWaitHint = 0;
   }

   if (dwExitCode != 0) {
      SvcStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
      SvcStatus.dwServiceSpecificExitCode = dwExitCode;
   } else {
      SvcStatus.dwWin32ExitCode = NO_ERROR;
      SvcStatus.dwServiceSpecificExitCode = 0;
   }

   SetServiceStatus(hSvcHandle, &SvcStatus);

   return;

} // PnPServiceStatusUpdate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\apic.inc ===
;/*
;++
;
;   Copyright (c) 1992  Intel Corporation
;   All rights reserved
;
;   INTEL CORPORATION PROPRIETARY INFORMATION
;
;   This software is supplied to Microsoft under the terms
;   of a license agreement with Intel Corporation and may not be
;   copied nor disclosed except in accordance with the terms
;   of that agreement.
;
;
;   Module Name:
;
;       apic.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       APIC interrupt controller and APIC-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Hugh Bynum and Ron Mosgrove Aug-1992
;
;--
if 0        ; Begin C only code        */

typedef volatile ULONG *PVULONG;


//
//  APIC Version Register (both IO Unit and Local Units)
//

struct ApicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1;
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct ApicVersion APIC_VERSION, *PAPIC_VERSION;
//
//  IO Unit definition
//

struct ApicIoUnit {
    volatile ULONG RegisterSelect;  // Write register number to access register
    volatile ULONG Reserved1[3];
    volatile ULONG RegisterWindow;  // Data read/written here
};

typedef struct ApicIoUnit IO_APIC_UNIT, *PIO_APIC_UNIT;
//
// APIC defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

//
//  Default Physical addresses of the APICs in a PC+MP system
//

#define IO_BASE_ADDRESS 0xFEC00000  // Default address of
                                    // 1st IO Apic
#define LU_BASE_ADDRESS 0xFEE00000  // Default address
                                    // of Local Apic
                                    
#define IO_REGISTER_SELECT      0x00000000 //
#define IO_REGISTER_WINDOW      0x00000010 //

#define IO_ID_REGISTER          0x00000000
#define IO_VERS_REGISTER        0x00000001
#define IO_ARB_ID_REGISTER      0x00000002
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define LU_ID_REGISTER          0x00000020 //
#define LU_VERS_REGISTER        0x00000030 //
#define LU_TPR                  0x00000080 //
#define LU_APR                  0x00000090 //
#define LU_PPR                  0x000000A0 //
#define LU_EOI                  0x000000B0 //
#define LU_REMOTE_REGISTER      0x000000C0 //

#define LU_LOGICAL_DEST         0x000000D0 //
#define LU_LOGICAL_DEST_MASK    0xFF000000

#define LU_DEST_FORMAT          0x000000E0 //
#define LU_DEST_FORMAT_MASK     0xF0000000
#define LU_DEST_FORMAT_FLAT     0xFFFFFFFF
#define LU_DEST_FORMAT_CLUSTER  0x0FFFFFFF

#define LU_SPURIOUS_VECTOR      0x000000F0 //
#define LU_FAULT_VECTOR         0x00000370 //
#define LU_UNIT_ENABLED         0x00000100
#define LU_UNIT_DISABLED        0x00000000

#define LU_ISR_0                0x00000100 //
#define LU_TMR_0                0x00000180 //
#define LU_IRR_0                0x00000200 //
#define LU_ERROR_STATUS         0x00000280 //
#define LU_INT_CMD_LOW          0x00000300 //
#define LU_INT_CMD_HIGH         0x00000310 //
#define LU_TIMER_VECTOR         0x00000320 //
#define LU_PERF_VECTOR          0x00000340
#define LU_INT_VECTOR_0         0x00000350 //    TEMPORARY - do not use
#define LU_INT_VECTOR_1         0x00000360 //    TEMPORARY - do not use
#define LU_INITIAL_COUNT        0x00000380 //
#define LU_CURRENT_COUNT        0x00000390 //
#define LU_DIVIDER_CONFIG       0x000003E0 //
#define LU_DIVIDE_BY_1          0x0000000B //

#define APIC_ID_MASK            0xFF000000
#define APIC_ID_SHIFT           24

#define INT_VECTOR_MASK         0x000000FF
#define RESERVED_HIGH_INT       0x000000F8
#define DELIVERY_MODE_MASK      0x00000700
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_REMOTE_READ     0x00000300
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_STARTUP         0x00000600
#define DELIVER_EXTINT          0x00000700
#define PHYSICAL_DESTINATION    0x00000000
#define LOGICAL_DESTINATION     0x00000800
#define DELIVERY_PENDING        0x00001000
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define REMOTE_IRR              0x00004000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000
#define PERIODIC_TIMER          0x00020000

#define ICR_LEVEL_ASSERTED      0x00004000
#define ICR_LEVEL_DEASSERTED    0x00000000
#define ICR_RR_STATUS_MASK      0x00030000
#define ICR_RR_INVALID          0x00000000
#define ICR_RR_IN_PROGRESS      0x00010000
#define ICR_RR_VALID            0x00020000
#define ICR_SHORTHAND_MASK      0x000C0000
#define ICR_USE_DEST_FIELD      0x00000000
#define ICR_SELF                0x00040000
#define ICR_ALL_INCL_SELF       0x00080000
#define ICR_ALL_EXCL_SELF       0x000C0000

//
//  Special ICR request to reset a remote processor
//
#define LU_RESET_ASSERT     ( DELIVER_INIT | LEVEL_TRIGGERED | ICR_LEVEL_ASSERTED | \
                           ICR_USE_DEST_FIELD | PHYSICAL_DESTINATION)
#define LU_RESET_DEASSERT   ( DELIVER_INIT | LEVEL_TRIGGERED | ICR_LEVEL_DEASSERTED | \
                           ICR_USE_DEST_FIELD | PHYSICAL_DESTINATION)
//
//  Special ICR request to reset a remote processor
//
#define LU_INIT_DEASSERT     (DELIVER_INIT | LEVEL_TRIGGERED | \
                              ICR_ALL_INCL_SELF | ICR_LEVEL_DEASSERTED )
//
//  Startup ICR Requset - OR in the VV value needed
//
#define LU_STARTUP_IPI   ( DELIVER_STARTUP | ICR_USE_DEST_FIELD | \
                           PHYSICAL_DESTINATION)

#define DESTINATION_MASK        0xFF000000
#define DESTINATION_SHIFT       24
//
// APIC IO unit redirection table, interrupt destination field: this field
// is 32 bits for the 82489DX APIC; future APIC implementations will put the
// destination field in the upper 8 bits of the entry, not the full 32 bits
//
#define DESTINATION_CPU_0       (ULONG) (1 << DESTINATION_SHIFT)
#define DESTINATION_ALL_CPUS    (ULONG) (0xff << DESTINATION_SHIFT)

//
//  Io Apic Entry definitions
//
//  Interrupt Types Possible in the PC+MP Table
//  valid for both local and Io Apics
//
#define INT_TYPE_INTR           0x0
#define INT_TYPE_NMI            0x1
#define INT_TYPE_SMI            0x2
#define INT_TYPE_EXTINT         0x3

/*
endif

;  APIC defines for assembly code
;  BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

;
;  Default Physical addresses of the APICs in a PC+MP system
;

IO_BASE_ADDRESS equ 0FEC00000H  ; Default address of
                                ; 1st IO Apic
LU_BASE_ADDRESS equ 0FEE00000H  ; Default address
                                ; of Local Apic

IO_REGISTER_SELECT      equ     00000000H  ;
IO_REGISTER_WINDOW      equ     00000010H  ;

IO_ID_REGISTER          equ     00000000H  ;
IO_VERS_REGISTER        equ     00000001H  ;
IO_ARB_ID_REGISTER      equ     00000002H  ;
IO_REDIR_00_LOW         equ     00000010H  ;
IO_REDIR_00_HIGH        equ     00000011H  ;

IO_MAX_REDIR_MASK       equ     00FF0000H  ;
IO_VERSION_MASK         equ     000000FFH  ;

LU_ID_REGISTER          equ     00000020H  ;
LU_VERS_REGISTER        equ     00000030H  ;
LU_TPR                  equ     00000080H  ;
LU_APR                  equ     00000090H  ;
LU_PPR                  equ     000000A0H  ;
LU_EOI                  equ     000000B0H  ;
LU_REMOTE_REGISTER      equ     000000C0H  ;

LU_LOGICAL_DEST         equ     000000D0H  ;
LU_LOGICAL_DEST_MASK    equ    0FF000000H  ;

LU_DEST_FORMAT          equ     000000E0H  ;
LU_DEST_FORMAT_MASK     equ    0F0000000H  ;
LU_DEST_FORMAT_FLAT     equ    0FFFFFFFFH  ;
LU_DEST_FORMAT_CLUSTER  equ     0FFFFFFFH

LU_SPURIOUS_VECTOR      equ     000000F0H  ;
LU_FAULT_VECTOR         equ     00000370H  ;
LU_UNIT_ENABLED         equ     00000100H  ;
LU_UNIT_DISABLED        equ     00000000H  ;

LU_ISR_0                equ     00000100H  ;
LU_TMR_0                equ     00000180H  ;
LU_IRR_0                equ     00000200H  ;
LU_ERROR_STATUS         equ     00000280H  ;
LU_INT_CMD_LOW          equ     00000300H  ;
LU_INT_CMD_HIGH         equ     00000310H  ;
LU_TIMER_VECTOR         equ     00000320H  ;
LU_PERF_VECTOR          equ     00000340H  ;
LU_INT_VECTOR_0         equ     00000350H  ;     TEMPORARY - do not use
LU_INT_VECTOR_1         equ     00000360H  ;     TEMPORARY - do not use
LU_INITIAL_COUNT        equ     00000380H  ;
LU_CURRENT_COUNT        equ     00000390H  ;

LU_DIVIDER_CONFIG       equ     000003E0H  ;
LU_DIVIDE_BY_1          equ     0000000BH  ;
LU_DIVIDE_BY_2          equ     00000000H  ;
LU_DIVIDE_BY_4          equ     00000001H  ;
LU_DIVIDE_BY_8          equ     00000002H  ;
LU_DIVIDE_BY_16         equ     00000003H  ;
LU_DIVIDE_BY_32         equ     00000008H  ;
LU_DIVIDE_BY_64         equ     00000009H  ;
LU_DIVIDE_BY_128        equ     0000000AH  ;

APIC_ID_MASK            equ     0FF000000H ;
APIC_ID_SHIFT           equ     24         ;

INT_VECTOR_MASK         equ     000000FFH  ;
RESERVED_HIGH_INT       equ     000000F8H  ;
DELIVERY_MODE_MASK      equ     00000700H  ;
DELIVER_FIXED           equ     00000000H  ;
DELIVER_LOW_PRIORITY    equ     00000100H  ;
DELIVER_SMI             equ     00000200H  ;
DELIVER_REMOTE_READ     equ     00000300H  ;
DELIVER_NMI             equ     00000400H  ;
DELIVER_INIT            equ     00000500H  ;
DELIVER_STARTUP         equ     00000600H  ;
DELIVER_EXTINT          equ     00000700H  ;
PHYSICAL_DESTINATION    equ     00000000H  ;
LOGICAL_DESTINATION     equ     00000800H  ;
DELIVERY_PENDING        equ     00001000H  ;
ACTIVE_LOW              equ     00002000H  ;
ACTIVE_HIGH             equ     00000000H  ;
REMOTE_IRR              equ     00004000H  ;
LEVEL_TRIGGERED         equ     00008000H  ;
EDGE_TRIGGERED          equ     00000000H  ;
INTERRUPT_MASKED        equ     00010000H  ;
INTERRUPT_MOT_MASKED    equ     00000000H  ;
PERIODIC_TIMER          equ     00020000H  ;

ICR_LEVEL_ASSERTED      equ     00004000H  ;
ICR_LEVEL_DEASSERTED    equ     00000000H  ;
ICR_RR_STATUS_MASK      equ     00030000H  ;
ICR_RR_INVALID          equ     00000000H  ;
ICR_RR_IN_PROGRESS      equ     00010000H  ;
ICR_RR_VALID            equ     00020000H  ;
ICR_SHORTHAND_MASK      equ     000C0000H  ;
ICR_USE_DEST_FIELD      equ     00000000H  ;
ICR_SELF                equ     00040000H  ;
ICR_ALL_INCL_SELF       equ     00080000H  ;
ICR_ALL_EXCL_SELF       equ     000C0000H  ;

DESTINATION_MASK        equ    0FF000000H  ;
DESTINATION_SHIFT       equ     24         ; shift count for dest. mask
;
; APIC IO unit redirection table, interrupt destination field: this field
; is 32 bits for the 82489DX APIC; future APIC implementations will put the
; destination field in the upper 8 bits of the entry, not the full 32 bits
;
DESTINATION_CPU_0   equ     1    SHL DESTINATION_SHIFT
DESTINATION_ALL_CPUS    equ     0FFH SHL DESTINATION_SHIFT

;
;  Interrupt Types Possible in the PC+MP Table
;
INT_TYPE_INTR       equ 0H
INT_TYPE_NMI        equ 01H
INT_TYPE_SMI        equ 02H
INT_TYPE_EXTINT     equ 03H

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\pnp\umpnpmgr\umpnpi.h ===
/*++

Copyright (c) 1995-2001  Microsoft Corporation

Module Name:

    umpnpi.h

Abstract:

    This module contains the internal structure definitions and APIs used by
    the user-mode Plug and Play Manager.

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _UMPNPI_H_
#define _UMPNPI_H_


//
// global data
//

extern HANDLE ghPnPHeap;
extern LUID   gLuidLoadDriverPrivilege;
extern LUID   gLuidUndockPrivilege;


//
// definitions
//

#define GUID_STRING_LEN    39   // size in chars, including terminating NULL

//
// flags for IsValidDeviceID
//
#define PNP_NOT_MOVED                     0x00000001
#define PNP_NOT_PHANTOM                   0x00000002
#define PNP_PRESENT                       0x00000004
#define PNP_NOT_REMOVED                   0x00000008
#define PNP_STRICT                        0xFFFFFFFF


//
// Define the Plug and Play driver types. (from ntos\io\pnpmgr\pnpi.h)
//

typedef enum _PLUGPLAY_SERVICE_TYPE {
    PlugPlayServiceBusExtender,
    PlugPlayServiceAdapter,
    PlugPlayServicePeripheral,
    PlugPlayServiceSoftware,
    MaxPlugPlayServiceType
} PLUGPLAY_SERVICE_TYPE, *PPLUGPLAY_SERVICE_TYPE;


//
// rdevnode.c
//

CONFIGRET
EnableDevInst(
    IN  PCWSTR      pszDeviceID
    );

CONFIGRET
DisableDevInst(
    IN  PCWSTR      pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR      pszVetoName,
    IN  ULONG       ulNameLength
    );

CONFIGRET
UninstallRealDevice(
    IN  LPCWSTR     pszDeviceID
    );

CONFIGRET
UninstallPhantomDevice(
    IN  LPCWSTR     pszDeviceID
    );

BOOL
IsDeviceRootEnumerated(
    IN  LPCWSTR     pszDeviceID
    );

CONFIGRET
QueryAndRemoveSubTree(
    IN  PCWSTR      pszDeviceID,
    OUT PPNP_VETO_TYPE  pVetoType,
    OUT LPWSTR      pszVetoName,
    IN  ULONG       ulNameLength,
    IN  ULONG       ulFlags
    );

CONFIGRET
ReenumerateDevInst(
    IN  PCWSTR      pszDeviceID,
    IN  BOOL        EnumSubTree,
    IN  ULONG       ulFlags
    );

typedef enum {

    EA_CONTINUE,
    EA_SKIP_SUBTREE,
    EA_STOP_ENUMERATION

} ENUM_ACTION;

typedef ENUM_ACTION (*PFN_ENUMTREE)(
    IN      LPCWSTR     DevInst,
    IN OUT  PVOID       Context
    );

CONFIGRET
EnumerateSubTreeTopDownBreadthFirst(
    IN      handle_t        BindingHandle,
    IN      LPCWSTR         DevInst,
    IN      PFN_ENUMTREE    CallbackFunction,
    IN OUT  PVOID           Context
    );

//
// revent.c
//

BOOL
InitNotification(
    VOID
    );

DWORD
InitializePnPManager(
    IN  LPDWORD     lpParam
    );

DWORD
SessionNotificationHandler(
    IN  DWORD       EventType,
    IN  PWTSSESSION_NOTIFICATION SessionNotification
    );

#define PNP_INIT_MUTEX   TEXT("PnP_Init_Mutex")

typedef struct {

    BOOL        HeadNodeSeen;
    BOOL        SingleLevelEnumOnly;
    CONFIGRET   Status;

} QI_CONTEXT, *PQI_CONTEXT;

ENUM_ACTION
QueueInstallationCallback(
    IN      LPCWSTR         DevInst,
    IN OUT  PVOID           Context
    );

//
// rtravers.c
//

CONFIGRET
GetServiceDeviceListSize(
    IN  LPCWSTR     pszService,
    OUT PULONG      pulLength
    );

CONFIGRET
GetServiceDeviceList(
    IN  LPCWSTR     pszService,
    OUT LPWSTR      pBuffer,
    IN OUT PULONG   pulLength,
    IN  ULONG       ulFlags
    );


//
// rutil.c
//

BOOL
MultiSzAppendW(
    IN OUT LPWSTR   pszMultiSz,
    IN OUT PULONG   pulSize,
    IN     LPCWSTR  pszString
    );

BOOL
MultiSzDeleteStringW(
    IN OUT LPWSTR   pString,
    IN LPCWSTR      pSubString
    );

LPWSTR
MultiSzFindNextStringW(
    IN  LPWSTR      pMultiSz
    );

BOOL
MultiSzSearchStringW(
    IN  LPCWSTR     pString,
    IN  LPCWSTR     pSubString
    );

ULONG
MultiSzSizeW(
    IN  LPCWSTR     pString
    );

BOOL
IsValidGuid(
    IN  LPWSTR      pszGuid
    );

DWORD
GuidFromString(
    IN  PCTSTR      GuidString,
    OUT LPGUID      Guid
    );

DWORD
StringFromGuid(
    IN  CONST GUID *Guid,
    OUT PTSTR       GuidString,
    IN  DWORD       GuidStringSize
    );

BOOL
IsValidDeviceID(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey,
    IN  ULONG       ulFlags
    );

BOOL
IsRootDeviceID(
    IN  LPCWSTR     pDeviceID
    );

BOOL
IsDeviceIdPresent(
    IN  LPCWSTR     pszDeviceID
    );

BOOL
IsDevicePhantom(
    IN  LPWSTR      pszDeviceID
    );

BOOL
IsDeviceMoved(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey
    );

ULONG
GetDeviceConfigFlags(
    IN  LPCWSTR     pszDeviceID,
    IN  HKEY        hKey
    );

CONFIGRET
GetDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    OUT PULONG      pulStatus,
    OUT PULONG      pulProblem
    );

CONFIGRET
SetDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       ulStatus,
    IN  ULONG       ulProblem
    );

CONFIGRET
ClearDeviceStatus(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       ulStatus,
    IN  ULONG       ulProblem
    );

BOOL
GetActiveService(
    IN  PCWSTR      pszDevice,
    OUT PWSTR       pszService
    );

BOOL
PathToString(
    IN  LPWSTR      pszString,
    IN  LPCWSTR     pszPath,
    IN  ULONG       ulLength
    );

BOOL
SplitClassInstanceString(
    IN  LPCWSTR     pszClassInstance,
    OUT LPWSTR      pszClass,
    OUT LPWSTR      pszInstance
    );

CONFIGRET
CopyRegistryTree(
    IN  HKEY        hSrcKey,
    IN  HKEY        hDestKey,
    IN  ULONG       ulOption
    );

CONFIGRET
MakeKeyVolatile(
    IN  LPCWSTR     pszParentKey,
    IN  LPCWSTR     pszChildKey
    );

CONFIGRET
MakeKeyNonVolatile(
    IN  LPCWSTR     pszParentKey,
    IN  LPCWSTR     pszChildKey
    );

CONFIGRET
OpenLogConfKey(
    IN  LPCWSTR     pszDeviceID,
    IN  ULONG       LogConfType,
    OUT PHKEY       phKey
    );

BOOL
CreateDeviceIDRegKey(
    IN  HKEY        hParentKey,
    IN  LPCWSTR     pDeviceID
    );

CONFIGRET
GetProfileCount(
    OUT PULONG      pulProfiles
    );

VOID
PNP_ENTER_SYNCHRONOUS_CALL(
    VOID
    );

VOID
PNP_LEAVE_SYNCHRONOUS_CALL(
    VOID
    );

ULONG
MapNtStatusToCmError(
    IN  ULONG       NtStatus
    );

ULONG
GetActiveConsoleSessionId(
    VOID
    );

BOOL
IsClientUsingLocalConsole(
    IN  handle_t    hBinding
    );

BOOL
IsClientLocal(
    IN  handle_t    hBinding
    );

BOOL
IsClientInteractive(
    IN  handle_t    hBinding
    );

BOOL
IsClientAdministrator(
    IN  handle_t    hBinding
    );

BOOL
VerifyClientAccess(
    IN  handle_t    hBinding,
    IN  PLUID       pPrivilegeLuid
    );

BOOL
VerifyKernelInitiatedEjectPermissions(
    IN  HANDLE      UserToken   OPTIONAL,
    IN  BOOL        DockDevice
    );


//
// osver.c
//

BOOL
IsEmbeddedNT(
    VOID
    );

BOOL
IsTerminalServer(
    VOID
    );

BOOL
IsFastUserSwitchingEnabled(
    VOID
    );



#endif // _UMPNPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\evntrace.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    EvnTrace.h

Abstract:

    Public headers for event tracing control applications,
    consumers and providers

--*/

#ifndef _EVNTRACE_
#define _EVNTRACE_

#if defined(_WINNT_) || defined(WINNT)
#ifndef WMIAPI
#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif // _WMI_SOURCE
#endif // MIDL_PASS

#endif // WMIAPI

#include <guiddef.h>

//
// EventTraceGuid is used to identify a event tracing session
//
DEFINE_GUID ( /* 68fdd900-4a3e-11d1-84f4-0000f80464e3 */
    EventTraceGuid,
    0x68fdd900,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );

//
// SystemTraceControlGuid. Used to specify event tracing for kernel
//
DEFINE_GUID ( /* 9e814aad-3204-11d2-9a82-006008a86939 */
    SystemTraceControlGuid,
    0x9e814aad,
    0x3204,
    0x11d2,
    0x9a, 0x82, 0x00, 0x60, 0x08, 0xa8, 0x69, 0x39
  );

//
//EventTraceConfigGuid. Used to report hardware configuration records
//

DEFINE_GUID ( /* 01853a65-418f-4f36-aefc-dc0f1d2fd235 */
    EventTraceConfigGuid,
    0x01853a65,
    0x418f,
    0x4f36,
    0xae, 0xfc, 0xdc, 0x0f, 0x1d, 0x2f, 0xd2, 0x35
  );

#define KERNEL_LOGGER_NAMEW   L"NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEW   L"GlobalLogger"
#define EVENT_LOGGER_NAMEW    L"Event Log"

#define KERNEL_LOGGER_NAMEA   "NT Kernel Logger"
#define GLOBAL_LOGGER_NAMEA   "GlobalLogger"
#define EVENT_LOGGER_NAMEA    "Event Log"

#define MAX_MOF_FIELDS                      16  // Limit of USE_MOF_PTR fields
typedef ULONG64 TRACEHANDLE, *PTRACEHANDLE;

//
// predefined generic event types (0x00 to 0x09 reserved).
//

#define EVENT_TRACE_TYPE_INFO               0x00  // Info or point event
#define EVENT_TRACE_TYPE_START              0x01  // Start event
#define EVENT_TRACE_TYPE_END                0x02  // End event
#define EVENT_TRACE_TYPE_DC_START           0x03  // Collection start marker
#define EVENT_TRACE_TYPE_DC_END             0x04  // Collection end marker
#define EVENT_TRACE_TYPE_EXTENSION          0x05  // Extension/continuation
#define EVENT_TRACE_TYPE_REPLY              0x06  // Reply event
#define EVENT_TRACE_TYPE_DEQUEUE            0x07  // De-queue event
#define EVENT_TRACE_TYPE_CHECKPOINT         0x08  // Generic checkpoint event
#define EVENT_TRACE_TYPE_RESERVED9          0x09

//
// Event types for Process & Threads
//

#define EVENT_TRACE_TYPE_LOAD                  0x0A      // Load image

//
// Event types for IO subsystem
//

#define EVENT_TRACE_TYPE_IO_READ               0x0A
#define EVENT_TRACE_TYPE_IO_WRITE              0x0B

//
// Event types for Memory subsystem
//

#define EVENT_TRACE_TYPE_MM_TF                 0x0A      // Transition fault
#define EVENT_TRACE_TYPE_MM_DZF                0x0B      // Demand Zero fault
#define EVENT_TRACE_TYPE_MM_COW                0x0C      // Copy on Write
#define EVENT_TRACE_TYPE_MM_GPF                0x0D      // Guard Page fault
#define EVENT_TRACE_TYPE_MM_HPF                0x0E      // Hard page fault

//
// Event types for Network subsystem, all protocols
//

#define EVENT_TRACE_TYPE_SEND                  0x0A     // Send
#define EVENT_TRACE_TYPE_RECEIVE               0x0B     // Receive
#define EVENT_TRACE_TYPE_CONNECT               0x0C     // Connect
#define EVENT_TRACE_TYPE_DISCONNECT            0x0D     // Disconnect
#define EVENT_TRACE_TYPE_RETRANSMIT            0x0E     // ReTransmit
#define EVENT_TRACE_TYPE_ACCEPT                0x0F     // Accept
#define EVENT_TRACE_TYPE_RECONNECT             0x10     // ReConnect


//
// Event Types for the Header (to handle internal event headers)
//

#define EVENT_TRACE_TYPE_GUIDMAP                0x0A
#define EVENT_TRACE_TYPE_CONFIG                 0x0B
#define EVENT_TRACE_TYPE_SIDINFO                0x0C
#define EVENT_TRACE_TYPE_SECURITY               0x0D

//
// Event types for Registry subsystem
//

#define EVENT_TRACE_TYPE_REGCREATE              0x0A     // NtCreateKey
#define EVENT_TRACE_TYPE_REGOPEN                0x0B     // NtOpenKey
#define EVENT_TRACE_TYPE_REGDELETE              0x0C     // NtDeleteKey
#define EVENT_TRACE_TYPE_REGQUERY               0x0D     // NtQueryKey
#define EVENT_TRACE_TYPE_REGSETVALUE            0x0E     // NtSetValueKey
#define EVENT_TRACE_TYPE_REGDELETEVALUE         0x0F     // NtDeleteValueKey
#define EVENT_TRACE_TYPE_REGQUERYVALUE          0x10     // NtQueryValueKey
#define EVENT_TRACE_TYPE_REGENUMERATEKEY        0x11     // NtEnumerateKey
#define EVENT_TRACE_TYPE_REGENUMERATEVALUEKEY   0x12     // NtEnumerateValueKey
#define EVENT_TRACE_TYPE_REGQUERYMULTIPLEVALUE  0x13     // NtQueryMultipleValueKey
#define EVENT_TRACE_TYPE_REGSETINFORMATION      0x14     // NtSetInformationKey
#define EVENT_TRACE_TYPE_REGFLUSH               0x15     // NtFlushKey
#define EVENT_TRACE_TYPE_REGKCBDMP              0x16     // KcbDump/create

//
// Event types for system configuration records
//
#define EVENT_TRACE_TYPE_CONFIG_CPU             0x0A     // CPU Configuration
#define EVENT_TRACE_TYPE_CONFIG_PHYSICALDISK    0x0B     // Physical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_LOGICALDISK     0x0C     // Logical Disk Configuration
#define EVENT_TRACE_TYPE_CONFIG_NIC             0x0D     // NIC Configuration
#define EVENT_TRACE_TYPE_CONFIG_VIDEO           0x0E     // Video Adapter Configuration
#define EVENT_TRACE_TYPE_CONFIG_SERVICES        0x0F     // Active Services
#define EVENT_TRACE_TYPE_CONFIG_POWER           0x10     // ACPI Configuration

//
// Enable flags for SystemControlGuid only
//
#define EVENT_TRACE_FLAG_PROCESS            0x00000001  // process start & end
#define EVENT_TRACE_FLAG_THREAD             0x00000002  // thread start & end
#define EVENT_TRACE_FLAG_IMAGE_LOAD         0x00000004  // image load

#define EVENT_TRACE_FLAG_DISK_IO            0x00000100  // physical disk IO
#define EVENT_TRACE_FLAG_DISK_FILE_IO       0x00000200  // requires disk IO

#define EVENT_TRACE_FLAG_MEMORY_PAGE_FAULTS 0x00001000  // all page faults
#define EVENT_TRACE_FLAG_MEMORY_HARD_FAULTS 0x00002000  // hard faults only

#define EVENT_TRACE_FLAG_NETWORK_TCPIP      0x00010000  // tcpip send & receive

#define EVENT_TRACE_FLAG_REGISTRY           0x00020000  // registry calls
#define EVENT_TRACE_FLAG_DBGPRINT           0x00040000  // DbgPrint(ex) Calls
//
// Pre-defined Enable flags for everybody else
//
#define EVENT_TRACE_FLAG_EXTENSION          0x80000000  // indicates more flags
#define EVENT_TRACE_FLAG_FORWARD_WMI        0x40000000  // Can forward to WMI
#define EVENT_TRACE_FLAG_ENABLE_RESERVE     0x20000000  // Reserved

//
// Logger Mode flags
//

#define EVENT_TRACE_FILE_MODE_NONE          0x00000000  // logfile is off
#define EVENT_TRACE_FILE_MODE_SEQUENTIAL    0x00000001  // log sequentially
#define EVENT_TRACE_FILE_MODE_CIRCULAR      0x00000002  // log in circular manner
#define EVENT_TRACE_FILE_MODE_APPEND        0x00000004  // append sequential log
#define EVENT_TRACE_FILE_MODE_NEWFILE       0x00000008  // auto-switch log file

#define EVENT_TRACE_FILE_MODE_PREALLOCATE   0x00000020  // pre-allocate mode

#define EVENT_TRACE_REAL_TIME_MODE          0x00000100  // real time mode on
#define EVENT_TRACE_DELAY_OPEN_FILE_MODE    0x00000200  // delay opening file
#define EVENT_TRACE_BUFFERING_MODE          0x00000400  // buffering mode only
#define EVENT_TRACE_PRIVATE_LOGGER_MODE     0x00000800  // Process Private Logger
#define EVENT_TRACE_ADD_HEADER_MODE         0x00001000  // Add a logfile header
#define EVENT_TRACE_USE_GLOBAL_SEQUENCE     0x00004000  // Use global sequence no.
#define EVENT_TRACE_USE_LOCAL_SEQUENCE      0x00008000  // Use local sequence no.

#define EVENT_TRACE_RELOG_MODE              0x00010000  // Relogger

#define EVENT_TRACE_USE_PAGED_MEMORY        0x01000000  // Use pageable buffers   

//
// internal control codes used.
//
#define EVENT_TRACE_CONTROL_QUERY           0
#define EVENT_TRACE_CONTROL_STOP            1
#define EVENT_TRACE_CONTROL_UPDATE          2
#define EVENT_TRACE_CONTROL_FLUSH           3       // Flushes all the buffers

//
// Flags used by WMI Trace Message
// Note that the order or value of these flags should NOT be changed as they are processed
// in this order.
//
#define TRACE_MESSAGE_SEQUENCE		1           // Message should include a sequence number
#define TRACE_MESSAGE_GUID			2           // Message includes a GUID
#define TRACE_MESSAGE_COMPONENTID   4           // Message has no GUID, Component ID instead
#define	TRACE_MESSAGE_TIMESTAMP		8           // Message includes a timestamp
#define TRACE_MESSAGE_PERFORMANCE_TIMESTAMP 16  // Timestamp is the Performance Counter not the system clock
#define	TRACE_MESSAGE_SYSTEMINFO	32          // Message includes system information TID,PID
#define TRACE_MESSAGE_FLAG_MASK     0xFFFF      // Only the lower 16 bits of flags are placed in the message
                                                // those above 16 bits are reserved for local processing
#define TRACE_MESSAGE_MAXIMUM_SIZE  8*1024      // the maximum size allowed for a single trace message
                                                // longer messages will return ERROR_BUFFER_OVERFLOW
//
// Flags to indicate to consumer which fields
// in the EVENT_TRACE_HEADER are valid
//

#define EVENT_TRACE_USE_PROCTIME   0x0001    // ProcessorTime field is valid
#define EVENT_TRACE_USE_NOCPUTIME  0x0002    // No Kernel/User/Processor Times

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning (disable:4201)
//
// Trace header for all (except kernel) events. This is used to overlay
// to bottom part of WNODE_HEADER to conserve space.
//

typedef struct _EVENT_TRACE_HEADER {        // overlays WNODE_HEADER
    USHORT          Size;                   // Size of entire record
    union {
        USHORT      FieldTypeFlags;         // Indicates valid fields
        struct {
            UCHAR   HeaderType;             // Header type - internal use only
            UCHAR   MarkerFlags;            // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;                   // event type
            UCHAR   Level;                  // trace instrumentation level
            USHORT  Version;                // version of trace record
        } Class;
    };
    ULONG           ThreadId;               // Thread Id
    ULONG           ProcessId;              // Process Id
    LARGE_INTEGER   TimeStamp;              // time when event happens
    union {
        GUID        Guid;                   // Guid that identifies event
        ULONGLONG   GuidPtr;                // use with WNODE_FLAG_USE_GUID_PTR
    };
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
} EVENT_TRACE_HEADER, *PEVENT_TRACE_HEADER;

//
// This header is used to trace and track transaction co-relations
//
typedef struct _EVENT_INSTANCE_HEADER {
    USHORT          Size;
    union {
        USHORT      FieldTypeFlags;     // Indicates valid fields
        struct {
            UCHAR   HeaderType;         // Header type - internal use only
            UCHAR   MarkerFlags;        // Marker - internal use only
        };
    };
    union {
        ULONG       Version;
        struct {
            UCHAR   Type;
            UCHAR   Level;
            USHORT  Version;
        } Class;
    };
    ULONG           ThreadId;
    ULONG           ProcessId;
    LARGE_INTEGER   TimeStamp;
    ULONGLONG       RegHandle;
    ULONG           InstanceId;
    ULONG           ParentInstanceId;
    union {
        struct {
            ULONG   ClientContext;          // Reserved
            ULONG   Flags;                  // Flags for header
        };
        struct {
            ULONG   KernelTime;             // Kernel Mode CPU ticks
            ULONG   UserTime;               // User mode CPU ticks
        };
        ULONG64     ProcessorTime;          // Processor Clock
    };
    ULONGLONG       ParentRegHandle;
} EVENT_INSTANCE_HEADER, *PEVENT_INSTANCE_HEADER;

//
// Following are structures and macros for use with USE_MOF_PTR
//

#define DEFINE_TRACE_MOF_FIELD(MOF, ptr, length, type) \
    (MOF)->DataPtr  = (ULONG64) ptr; \
    (MOF)->Length   = (ULONG) length; \
    (MOF)->DataType = (ULONG) type;

typedef struct _MOF_FIELD {
    ULONG64     DataPtr;    // Pointer to the field. Up to 64-bits only
    ULONG       Length;     // Length of the MOF field
    ULONG       DataType;   // Type of data
} MOF_FIELD, *PMOF_FIELD;

#if !defined(_NTDDK_) || defined(_WMIKM_)
//
// This is the header for every logfile. The memory for LoggerName
// and LogFileName must be contiguous adjacent to this structure
// Allows both user-mode and kernel-mode to understand the header
//
typedef struct _TRACE_LOGFILE_HEADER {
    ULONG           BufferSize;         // Logger buffer size in Kbytes
    union {
        ULONG       Version;            // Logger version
        struct {
            UCHAR   MajorVersion;
            UCHAR   MinorVersion;
            UCHAR   SubVersion;
            UCHAR   SubMinorVersion;
        } VersionDetail;
    };
    ULONG           ProviderVersion;    // defaults to NT version
    ULONG           NumberOfProcessors; // Number of Processors
    LARGE_INTEGER   EndTime;            // Time when logger stops
    ULONG           TimerResolution;    // assumes timer is constant!!!
    ULONG           MaximumFileSize;    // Maximum in Mbytes
    ULONG           LogFileMode;        // specify logfile mode
    ULONG           BuffersWritten;     // used to file start of Circular File
    union {
        GUID LogInstanceGuid;           // For RealTime Buffer Delivery
        struct {
            ULONG   StartBuffers;       // Count of buffers written at start.
            ULONG   PointerSize;        // Size of pointer type in bits
            ULONG   EventsLost;         // Events losts during log session
            ULONG   CpuSpeedInMHz;      // Cpu Speed in MHz
        };
    };
#if defined(_WMIKM_)
    PWCHAR          LoggerName;
    PWCHAR          LogFileName;
    RTL_TIME_ZONE_INFORMATION TimeZone;
#else
    LPWSTR          LoggerName;
    LPWSTR          LogFileName;
    TIME_ZONE_INFORMATION TimeZone;
#endif
    LARGE_INTEGER   BootTime;
    LARGE_INTEGER   PerfFreq;           // Reserved
    LARGE_INTEGER   StartTime;          // Reserved
    ULONG           ReservedFlags;      // Reserved
    ULONG           BuffersLost;
} TRACE_LOGFILE_HEADER, *PTRACE_LOGFILE_HEADER;

#endif // !_NTDDK_ || _WMIKM_


//
// Instance Information to track parent child relationship of Instances.
//
typedef struct EVENT_INSTANCE_INFO {
    HANDLE      RegHandle;
    ULONG       InstanceId;
} EVENT_INSTANCE_INFO, *PEVENT_INSTANCE_INFO;

#if !defined(_WMIKM_) && !defined(_NTDDK_)
//
// Structures that have UNICODE and ANSI versions are defined here
//

//
// Logger configuration and running statistics. This structure is used
// by user-mode callers, such as PDH library
//

typedef struct _EVENT_TRACE_PROPERTIES {
    WNODE_HEADER Wnode;
//
// data provided by caller
    ULONG BufferSize;                   // buffer size for logging (kbytes)
    ULONG MinimumBuffers;               // minimum to preallocate
    ULONG MaximumBuffers;               // maximum buffers allowed
    ULONG MaximumFileSize;              // maximum logfile size (in MBytes)
    ULONG LogFileMode;                  // sequential, circular
    ULONG FlushTimer;                   // buffer flush timer, in seconds
    ULONG EnableFlags;                  // trace enable flags
    LONG  AgeLimit;                     // age decay time, in minutes

// data returned to caller
    ULONG NumberOfBuffers;              // no of buffers in use
    ULONG FreeBuffers;                  // no of buffers free
    ULONG EventsLost;                   // event records lost
    ULONG BuffersWritten;               // no of buffers written to file
    ULONG LogBuffersLost;               // no of logfile write failures
    ULONG RealTimeBuffersLost;          // no of rt delivery failures
    HANDLE LoggerThreadId;              // thread id of Logger
    ULONG LogFileNameOffset;            // Offset to LogFileName
    ULONG LoggerNameOffset;             // Offset to LoggerName
} EVENT_TRACE_PROPERTIES, *PEVENT_TRACE_PROPERTIES;

// NOTE:
// If AgeLimit is 0, default is used
// If AgeLimit is < 0, buffer aging is turned off

typedef struct _TRACE_GUID_PROPERTIES {
    GUID    Guid;
    ULONG   GuidType;
    ULONG   LoggerId;
    ULONG   EnableLevel;
    ULONG   EnableFlags;
    BOOLEAN     IsEnable;
} TRACE_GUID_PROPERTIES, *PTRACE_GUID_PROPERTIES;


//
// Data Provider structures
//
// Used by RegisterTraceGuids()

typedef struct  _TRACE_GUID_REGISTRATION {
    LPCGUID Guid;           // Guid of data block being registered or updated.
    HANDLE RegHandle;      // Guid Registration Handle is returned.
} TRACE_GUID_REGISTRATION, *PTRACE_GUID_REGISTRATION;

//
// Data consumer structures
//

// An EVENT_TRACE consists of a fixed header (EVENT_TRACE_HEADER) and
// optionally a variable portion pointed to by MofData. The datablock
// layout of the variable portion is unknown to the Logger and must
// be obtained from WBEM CIMOM database.
//
typedef struct _EVENT_TRACE {
    EVENT_TRACE_HEADER      Header;             // Event trace header
    ULONG                   InstanceId;         // Instance Id of this event
    ULONG                   ParentInstanceId;   // Parent Instance Id.
    GUID                    ParentGuid;         // Parent Guid;
    PVOID                   MofData;            // Pointer to Variable Data
    ULONG                   MofLength;          // Variable Datablock Length
    ULONG                   ClientContext;      // Reserved
} EVENT_TRACE, *PEVENT_TRACE;


typedef struct _EVENT_TRACE_LOGFILEW
                EVENT_TRACE_LOGFILEW, *PEVENT_TRACE_LOGFILEW;

typedef struct _EVENT_TRACE_LOGFILEA
                EVENT_TRACE_LOGFILEA, *PEVENT_TRACE_LOGFILEA;

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKW)
                (PEVENT_TRACE_LOGFILEW Logfile);

typedef ULONG (WINAPI * PEVENT_TRACE_BUFFER_CALLBACKA)
                (PEVENT_TRACE_LOGFILEA Logfile);

typedef VOID (WINAPI *PEVENT_CALLBACK)( PEVENT_TRACE pEvent );

//
// Prototype for service request callback. Data providers register with WMI
// by passing a service request callback function that is called for all
// wmi requests.

typedef ULONG (
#ifndef MIDL_PASS
WINAPI
#endif
*WMIDPREQUEST)(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *BufferSize,
    IN OUT PVOID Buffer
    );


struct _EVENT_TRACE_LOGFILEW {
    LPWSTR                  LogFileName;    // Logfile Name
    LPWSTR                  LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // Mode of the logfile

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream.
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKW           // callback before each buffer
                            BufferCallback; // is read
    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

struct _EVENT_TRACE_LOGFILEA {
    LPSTR                   LogFileName;    // Logfile Name
    LPSTR                   LoggerName;     // LoggerName
    LONGLONG                CurrentTime;    // timestamp of last event
    ULONG                   BuffersRead;    // buffers read to date
    ULONG                   LogFileMode;    // LogFile Mode.

    EVENT_TRACE             CurrentEvent;   // Current Event from this stream
    TRACE_LOGFILE_HEADER    LogfileHeader;  // logfile header structure
    PEVENT_TRACE_BUFFER_CALLBACKA           // callback before each buffer
                            BufferCallback; // is read

    //
    // following variables are filled for BufferCallback.
    //
    ULONG                   BufferSize;
    ULONG                   Filled;
    ULONG                   EventsLost;
    //
    // following needs to be propaged to each buffer
    //

    PEVENT_CALLBACK         EventCallback;  // callback for every event
    ULONG                   IsKernelTrace;  // TRUE for kernel logfile

    PVOID                   Context;        // reserved for internal use
};

//
// Define generic structures
//

#if defined(_UNICODE) || defined(UNICODE)
#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKW
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEW
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEW
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEW
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEW
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEW

#else

#define PEVENT_TRACE_BUFFER_CALLBACK    PEVENT_TRACE_BUFFER_CALLBACKA
#define EVENT_TRACE_LOGFILE             EVENT_TRACE_LOGFILEA
#define PEVENT_TRACE_LOGFILE            PEVENT_TRACE_LOGFILEA
#define KERNEL_LOGGER_NAME              KERNEL_LOGGER_NAMEA
#define GLOBAL_LOGGER_NAME              GLOBAL_LOGGER_NAMEA
#define EVENT_LOGGER_NAME               EVENT_LOGGER_NAMEA

#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// Logger control APIs
//

//
// Use the routine below to start an event trace session
//

// ULONG
// StartTrace(
//      OUT PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );


EXTERN_C
ULONG
WMIAPI
StartTraceW(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StartTraceA(
    OUT PTRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to stop an event trace session
//

//
// ULONG
// StopTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
StopTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
StopTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );


//
// Use the routine below to query the properties of an event trace session
//

// ULONG
// QueryTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
QueryTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
QueryTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to update certain properties of an event trace session
//

// ULONG
// UpdateTrace(
//      IN (PTRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
UpdateTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
UpdateTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

//
// Use the routine below to request that all active buffers an event trace
// session be "flushed", or written out.
//

#if (WINVER >= 0x0501)
// ULONG
// FlushTrace(
//      IN TRACEHANDLE TraceHandle,
//      IN LPTSTR InstanceName,
//      IN OUT PEVENT_TRACE_PROPERTIES Properties
//      );

EXTERN_C
ULONG
WMIAPI
FlushTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

EXTERN_C
ULONG
WMIAPI
FlushTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties
    );

#endif

//
// Generic trace control routine
//
EXTERN_C
ULONG
WMIAPI
ControlTraceW(
    IN TRACEHANDLE TraceHandle,
    IN LPCWSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

EXTERN_C
ULONG
WMIAPI
ControlTraceA(
    IN TRACEHANDLE TraceHandle,
    IN LPCSTR InstanceName,
    IN OUT PEVENT_TRACE_PROPERTIES Properties,
    IN ULONG ControlCode
    );

//
// ULONG
// QueryAllTraces(
//  OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
//  IN ULONG PropertyArrayCount,
//  OUT PULONG LoggerCount
//  );
//

EXTERN_C
ULONG
WMIAPI
QueryAllTracesW(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );

EXTERN_C
ULONG
WMIAPI
QueryAllTracesA(
    OUT PEVENT_TRACE_PROPERTIES *PropertyArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG LoggerCount
    );


//
// Data Provider APIs
//

EXTERN_C
ULONG
WMIAPI
CreateTraceInstanceId(
    IN HANDLE RegHandle,
    IN OUT PEVENT_INSTANCE_INFO pInstInfo
    );

EXTERN_C
ULONG
WMIAPI
EnableTrace(
    IN ULONG Enable,
    IN ULONG EnableFlag,
    IN ULONG EnableLevel,
    IN LPCGUID ControlGuid,
    IN TRACEHANDLE TraceHandle
    );

//
// Use the routine below to generate and record an event trace
//


EXTERN_C
ULONG
WMIAPI
TraceEvent(
    IN TRACEHANDLE  TraceHandle,
    IN PEVENT_TRACE_HEADER EventTrace
    );

EXTERN_C
ULONG
WMIAPI
TraceEventInstance(
    IN TRACEHANDLE TraceHandle,
    IN PEVENT_INSTANCE_HEADER EventTrace,
    IN PEVENT_INSTANCE_INFO pInstInfo,
    IN PEVENT_INSTANCE_INFO pParentInstInfo
    );

//
// Use the routine below to register a guid for tracing
//

//
// ULONG
// RegisterTraceGuids(
//  IN WMIDPREQUEST  RequestAddress,
//  IN PVOID         RequestContext,
//  IN LPCGUID       ControlGuid,
//  IN ULONG         GuidCount,
//  IN PTRACE_GUID_REGISTRATION TraceGuidReg,
//  IN LPCTSTR       MofImagePath,
//  IN LPCTSTR       MofResourceName,
//  OUT PTRACEHANDLE RegistrationHandle
//  );
//

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsW(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCWSTR       MofImagePath,
    IN LPCWSTR       MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

EXTERN_C
ULONG
WMIAPI
RegisterTraceGuidsA(
    IN WMIDPREQUEST  RequestAddress,
    IN PVOID         RequestContext,
    IN LPCGUID       ControlGuid,
    IN ULONG         GuidCount,
    IN PTRACE_GUID_REGISTRATION TraceGuidReg,
    IN LPCSTR        MofImagePath,
    IN LPCSTR        MofResourceName,
    OUT PTRACEHANDLE RegistrationHandle
    );

#if (WINVER >= 0x0501)
EXTERN_C
ULONG
WMIAPI
EnumerateTraceGuids(
    IN OUT PTRACE_GUID_PROPERTIES *GuidPropertiesArray,
    IN ULONG PropertyArrayCount,
    OUT PULONG GuidCount
    );
#endif

EXTERN_C
ULONG
WMIAPI
UnregisterTraceGuids(
    IN TRACEHANDLE RegistrationHandle
    );

EXTERN_C
TRACEHANDLE
WMIAPI
GetTraceLoggerHandle(
    IN PVOID Buffer
    );

EXTERN_C
UCHAR
WMIAPI
GetTraceEnableLevel(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
GetTraceEnableFlags(
    IN TRACEHANDLE TraceHandle
    );

//
// Data Consumer APIs and structures start here
//

//
// TRACEHANDLE
// OpenTrace(
//  IN OUT PEVENT_TRACE_LOGFILE Logfile
//  );
//

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceA(
    IN OUT PEVENT_TRACE_LOGFILEA Logfile
    );

EXTERN_C
TRACEHANDLE
WMIAPI
OpenTraceW(
    IN OUT PEVENT_TRACE_LOGFILEW Logfile
    );

EXTERN_C
ULONG
WMIAPI
ProcessTrace(
    IN PTRACEHANDLE HandleArray,
    IN ULONG HandleCount,
    IN LPFILETIME StartTime,
    IN LPFILETIME EndTime
    );

EXTERN_C
ULONG
WMIAPI
CloseTrace(
    IN TRACEHANDLE TraceHandle
    );

EXTERN_C
ULONG
WMIAPI
SetTraceCallback(
    IN LPCGUID pGuid,
    IN PEVENT_CALLBACK EventCallback
    );

EXTERN_C
ULONG
WMIAPI
RemoveTraceCallback (
    IN LPCGUID pGuid
    );

//
// The routines for tracing Messages follow
//
EXTERN_C
ULONG 
__cdecl
TraceMessage(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    ...
);

EXTERN_C
ULONG 
TraceMessageVa(
    IN TRACEHANDLE  LoggerHandle,
    IN ULONG        MessageFlags,
    IN LPGUID       MessageGuid,
    IN USHORT       MessageNumber,
    IN va_list      MessageArgList
);

#ifdef __cplusplus
}       // extern "C"
#endif

//
//
// Define the encoding independent routines
//

#if defined(UNICODE) || defined(_UNICODE)
#define RegisterTraceGuids      RegisterTraceGuidsW
#define StartTrace              StartTraceW
#define ControlTrace            ControlTraceW
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceW((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceW
#define QueryTrace              QueryTraceW
#define UpdateTrace             UpdateTraceW
#endif
#if (WINVER >= 0x0501)
#define FlushTrace              FlushTraceW
#endif
#define QueryAllTraces          QueryAllTracesW
#define OpenTrace               OpenTraceW
#else
#define RegisterTraceGuids      RegisterTraceGuidsA
#define StartTrace              StartTraceA
#define ControlTrace            ControlTraceA
#if defined(__TRACE_W2K_COMPATIBLE)
#define StopTrace(a,b,c)        ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_STOP)
#define QueryTrace(a,b,c)       ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_QUERY)
#define UpdateTrace(a,b,c)      ControlTraceA((a),(b),(c), \
                                        EVENT_TRACE_CONTROL_UPDATE)
#else
#define StopTrace               StopTraceA
#define QueryTrace              QueryTraceA
#define UpdateTrace             UpdateTraceA
#endif
#if (WINVER >= 0x0501)
#define FlushTrace              FlushTraceA
#endif
#define QueryAllTraces          QueryAllTracesA
#define OpenTrace               OpenTraceA
#endif  // UNICODE

#endif /* _WMIKM_  && _NTDDK_ */

#endif // WINNT
#endif /* _EVNTRACE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\mce.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    mce.h

Abstract:

    This header file defines the Machine Check Errors definitions.

Author:

    David N. Cutler (davec) 


Revision History:

    Creation: 04-Apr-2001

--*/

#ifndef _MCE_
#define _MCE_

//
// HalMcaLogInformation
//

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// ADDR register for each MCA bank
//

typedef union _MCI_ADDR{
    struct {
        ULONG Address;
        ULONG Reserved;
    };

    ULONGLONG   QuadPart;
} MCI_ADDR, *PMCI_ADDR;


typedef enum {
    HAL_MCE_RECORD,
    HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;


#if defined(_AMD64_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif // _AMD64_

#if defined(_X86_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // _X86_

//
// MCA exception log entry
// Defined as a union to contain MCA specific log or Pentium style MCE info.
//

#define MCA_EXTREG_V2MAX       24  // X86: Max. Number of extended registers

#if defined(_X86_) || defined(_AMD64_)

typedef struct _MCA_EXCEPTION {

    // Begin Version 1 stuff
    ULONG               VersionNumber;      // Version number of this record type
    MCA_EXCEPTION_TYPE  ExceptionType;      // MCA or MCE
    LARGE_INTEGER       TimeStamp;          // exception recording timestamp
    ULONG               ProcessorNumber;
    ULONG               Reserved1;

    union {
        struct {
            UCHAR           BankNumber;
            UCHAR           Reserved2[7];
            MCI_STATS       Status;
            MCI_ADDR        Address;
            ULONGLONG       Misc;
        } Mca;

        struct {
            ULONGLONG       Address;        // physical addr of cycle causing the error
            ULONGLONG       Type;           // cycle specification causing the error
        } Mce;
    } u;
    // End   Version 1 stuff
    // Begin Version 2 stuff
    ULONG                   ExtCnt;
    ULONG                   Reserved3;
    ULONGLONG               ExtReg[MCA_EXTREG_V2MAX];
    // End   Version 2 stuff

} MCA_EXCEPTION, *PMCA_EXCEPTION;

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)

#endif // _X86_ || _AMD64_

#if defined(_IA64_)

#if 0
// FIXFIX: This should not be required for IA64.
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // 0

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION, *PERROR_REVISION;

// For Info:
#define ERROR_REVISION_SAL_03_00 { 2, 0 }

//
// IA64 ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this
// type of enums (UCHAR, __int64) could be defined...
//

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE  {
    ErrorRecoverable = 0,
    ErrorFatal       = 1,
    ErrorCorrected   = 2,
    ErrorOthers      = 3,   // [3,...] values are reserved
} ERROR_SEVERITY_VALUE;

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day
        UCHAR   Month;    // Byte5: Month
        UCHAR   Year;     // Byte6: Year
        UCHAR   Century;  // Byte7: Century
    };
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

//
// IA64 ERRORS: ERROR_GUID definitions
//

typedef struct _ERROR_GUID   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_GUID, *PERROR_GUID;

//
// IA64 ERRORS: ERROR GUIDs definitions
//

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

//
// IA64 ERRORS: ERROR_RECORD_HEADER definitions
//

typedef union _ERROR_RECORD_VALID   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved 
    };
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER { // Offsets:
    ULONGLONG          Id;                //   0: Unique identifier
    ERROR_REVISION     Revision;          //   8: Major and Minor revision number of the record
    ERROR_SEVERITY     ErrorSeverity;     //  10: Error Severity
    ERROR_RECORD_VALID Valid;             //  11: Validation bits
    ULONG              Length;            //  12: Length of this record in bytes, including the header
    ERROR_TIMESTAMP    TimeStamp;         //  16: Timestamp recorded when event occured
    UCHAR              OemPlatformId[16]; //  24: Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER    {
    ERROR_DEVICE_GUID   Guid;         // Unique identifier
    ERROR_REVISION      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO RecoveryInfo; // Recovery Information
    UCHAR               Reserved;
    ULONG               Length;       // Length of this error device section in bytes, 
                                      // including the header.
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//

#if !defined(__midl)
__inline
USHORT
GetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    USHORT lid = (USHORT)((UCHAR)(section->Reserved));
    lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
    return( lid );
} // GetFwMceLogProcessorNumber()
#endif // !__midl

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//
// The MCA architecture supports five different types of error reporting functional units
// with the associated error records and its error severity. 
// At any point in time, a processor could encounter an MCA/CMC event due to errors detected 
// in one or more of the following units:
//  - Cache Check
//  - TLB   Check
//  - Bus   Check
//  - Register File
//  - Micro Architectural
//
// Terminology:
//
//  - Target Address:
//      64-bit integer containing the physical address where the data was to be delivered or
//      obtained. This could also be the incoming address for external snoops and TLB shoot-downs.
//
//  - Requestor Identifier:
//      64-bit integer specifying the bus agent that generated the transaction responsible for
//      the Machine Check event.
//                    
//  - Responder Identifier:
//      64-bit integer specifying the bus agent that responded to a transaction responsible for
//      the Machine Check event.
//                    
//  - Precise Instruction Pointer:
//      64-bit integer specifying the virtual address that points to the IA-64 bundle that 
//      contained the instruction responsible for the Machine Check event.
//                    

#define ERROR_PROCESSOR_GUID \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MODINFO_VALID  {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG CheckInfo: 1;             //       0:
        ULONGLONG RequestorIdentifier: 1;   //       1:
        ULONGLONG ResponderIdentifier: 1;   //       2:
        ULONGLONG TargetIdentifier: 1;      //       3:
        ULONGLONG PreciseIP: 1;             //       4:
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS    {
    isIA64 = 0,
    isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION   {
    CacheUnknownOp = 0,
    CacheLoad  = 1,
    CacheStore = 2,
    CacheInstructionFetch = 3,
    CacheDataPrefetch = 4,
    CacheSnoop = 5,
    CacheCastOut = 6,
    CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI    {
    CacheInvalid = 0,
    CacheHeldShared = 1,
    CacheHeldExclusive = 2,
    CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

typedef union _ERROR_CACHE_CHECK    {
    ULONGLONG CacheCheck;
    struct
    {
        ULONGLONG Operation:4;             // bits  0- 3: Cache operation
        ULONGLONG Level:2;                 //       4- 5: Cache Level
        ULONGLONG Reserved1:2;             //       6- 7
        ULONGLONG DataLine:1;              //       8   : Failure data part of cache line
        ULONGLONG TagLine:1;               //       9   : Failure tag part of cache line
        ULONGLONG DataCache:1;             //      10   : Failure in data cache
        ULONGLONG InstructionCache:1;      //      11   : Failure in instruction cache
        ULONGLONG MESI:3;                  //      12-14:
        ULONGLONG MESIValid:1;             //      15   : MESI field is valid
        ULONGLONG Way:5;                   //      16-20: Failure in Way of Cache
        ULONGLONG WayIndexValid:1;         //      21   : Way and Index fields valid
        ULONGLONG Reserved2:10;            //      22-31
        ULONGLONG Index:20;                //      32-51: Index of cache line
        ULONGLONG Reserved3:2;             //      52-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

typedef enum _ERROR_TLB_CHECK_OPERATION   {
    TlbUnknownOp = 0,
    TlbAccessWithLoad  = 1,
    TlbAccessWithStore = 2,
    TlbAccessWithInstructionFetch = 3,
    TlbAccessWithDataPrefetch = 4,
    TlbShootDown = 5,
    TlbProbe = 6,
    TlbVhptFill = 7,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK  {
    ULONGLONG TlbCheck;
    struct
    {
        ULONGLONG TRSlot:8;                // bits  0- 7: Slot number of Translation Register
        ULONGLONG TRSlotValid:1;           //       8   : TRSlot field is valid
        ULONGLONG Reserved1:1;             //       9
        ULONGLONG Level:2;                 //      10-11: TLB Level
        ULONGLONG Reserved2:4;             //      12-15
        ULONGLONG DataTransReg:1;          //      16   : Error in data translation register
        ULONGLONG InstructionTransReg:1;   //      17   : Error in instruction translation register
        ULONGLONG DataTransCache:1;        //      18   : Error in data translation cache
        ULONGLONG InstructionTransCache:1; //      19   : Error in instruction translation cache
        ULONGLONG Operation:4;             //      20-23: Operation
        ULONGLONG Reserved3:30;            //      24-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION   {
    BusUnknownOp = 0,
    BusPartialRead  = 1,
    BusPartialWrite = 2,
    BusFullLineRead = 3,
    BusFullLineWrite = 4,
    BusWriteBack = 5,
    BusSnoopProbe = 6,
    BusIncomingPtcG = 7,
    BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

typedef union _ERROR_BUS_CHECK  {
    ULONGLONG BusCheck;
    struct
    {
        ULONGLONG Size:5;                  // bits  0- 4: Transaction size
        ULONGLONG Internal:1;              //       5   : Internal bus error
        ULONGLONG External:1;              //       6   : External bus error
        ULONGLONG CacheTransfer:1;         //       7   : Error occured in Cache to Cache Transfer 
        ULONGLONG Type:8;                  //       8-15: Transaction type
        ULONGLONG Severity:5;              //      16-20: Error severity - platform specific
        ULONGLONG Hierarchy:2;             //      21-22: Level or Bus hierarchy
        ULONGLONG Reserved1:1;             //      23
        ULONGLONG Status:8;                //      24-31: Bus error status - processor bus specific
        ULONGLONG Reserved2:22;            //      32-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER   {
    RegFileUnknownId = 0,
    GeneralRegisterBank1 = 1,
    GeneralRegisterBank0 = 2,
    FloatingPointRegister = 3,
    BranchRegister = 4,
    PredicateRegister = 5,
    ApplicationRegister = 6,
    ControlRegister = 7,
    RegionRegister = 8,
    ProtectionKeyRegister = 9,
    DataBreakPointRegister = 10,
    InstructionBreakPointRegister = 11,
    PerformanceMonitorControlRegister = 12,
    PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION   {
    RegFileUnknownOp = 0,
    RegFileRead = 1,
    RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK  {
    ULONGLONG RegFileCheck;
    struct
    {
        ULONGLONG Identifier:4;            // bits  0- 3: Register file identifier
        ULONGLONG Operation:4;             //       4- 7: Operation that causes the MC event
        ULONGLONG RegisterNumber:7;        //       8-14: Register number responsible for MC event
        ULONGLONG RegisterNumberValid:1;   //      15   : Register number field is valid
        ULONGLONG Reserved1:38;            //      16-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG Reserved2:3;             //      60-62
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

typedef enum _ERROR_MS_CHECK_OPERATION   {
    MsUnknownOp = 0,
    MsReadOrLoad = 1,
    MsWriteOrStore = 2,
} ERROR_MS_CHECK_OPERATION;

typedef union _ERROR_MS_CHECK  {
    ULONGLONG MsCheck;
    struct
    {
        ULONGLONG StructureIdentifier:5;   // bits  0- 4: Structure Identifier - impl. specific
        ULONGLONG Level:3;                 //       5- 7: Structure Level where error was generated
        ULONGLONG ArrayId:4;               //       8-11: Identification of the array 
        ULONGLONG Operation:4;             //      12-15: Operation
        ULONGLONG Way:6;                   //      16-21: Way where the error was located
        ULONGLONG WayValid:1;              //      22   : Way field is valid
        ULONGLONG IndexValid:1;            //      23   : Index field is valid
        ULONGLONG Reserved1:8;             //      24-31
        ULONGLONG Index:8;                 //      32-39: Index where the error was located
        ULONGLONG Reserved2:14;            //      40-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO   {
    ULONGLONG             CheckInfo;
    ERROR_CACHE_CHECK     CacheCheck;
    ERROR_TLB_CHECK       TlbCheck;
    ERROR_BUS_CHECK       BusCheck;
    ERROR_REGFILE_CHECK   RegFileCheck;
    ERROR_MS_CHECK        MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO   {
    ERROR_MODINFO_VALID Valid;
    ERROR_CHECK_INFO    CheckInfo;
    ULONGLONG           RequestorId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;      
    };
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
    ULONGLONG   StateParameter;
    struct {
        ULONGLONG reserved0:2;  //   0-1 : reserved
        ULONGLONG rz:1;         //     2 : Rendez-vous successful
        ULONGLONG ra:1;         //     3 : Rendez-vous attempted
        ULONGLONG me:1;         //     4 : Distinct Multiple errors
        ULONGLONG mn:1;         //     5 : Min-state Save Area registered
        ULONGLONG sy:1;         //     6 : Storage integrity synchronized
        ULONGLONG co:1;         //     7 : Continuable
        ULONGLONG ci:1;         //     8 : Machine Check isolated
        ULONGLONG us:1;         //     9 : Uncontained Storage damage
        ULONGLONG hd:1;         //    10 : Hardware damage
        ULONGLONG tl:1;         //    11 : Trap lost
        ULONGLONG mi:1;         //    12 : More Information
        ULONGLONG pi:1;         //    13 : Precise Instruction pointer
        ULONGLONG pm:1;         //    14 : Precise Min-state Save Area
        ULONGLONG dy:1;         //    15 : Processor Dynamic State valid
        ULONGLONG in:1;         //    16 : INIT interruption
        ULONGLONG rs:1;         //    17 : RSE valid
        ULONGLONG cm:1;         //    18 : Machine Check corrected
        ULONGLONG ex:1;         //    19 : Machine Check expected
        ULONGLONG cr:1;         //    20 : Control Registers valid
        ULONGLONG pc:1;         //    21 : Performance Counters valid
        ULONGLONG dr:1;         //    22 : Debug Registers valid
        ULONGLONG tr:1;         //    23 : Translation Registers valid
        ULONGLONG rr:1;         //    24 : Region Registers valid
        ULONGLONG ar:1;         //    25 : Application Registers valid
        ULONGLONG br:1;         //    26 : Branch Registers valid
        ULONGLONG pr:1;         //    27 : Predicate Registers valid
        ULONGLONG fp:1;         //    28 : Floating-Point Registers valid
        ULONGLONG b1:1;         //    29 : Preserved Bank 1 General Registers valid
        ULONGLONG b0:1;         //    30 : Preserved Bank 0 General Registers valid
        ULONGLONG gr:1;         //    31 : General Registers valid
        ULONGLONG dsize:16;     // 47-32 : Processor Dynamic State size
        ULONGLONG reserved1:11; // 48-58 : reserved
        ULONGLONG cc:1;         //    49 : Cache Check
        ULONGLONG tc:1;         //    60 : TLB   Check
        ULONGLONG bc:1;         //    61 : Bus   Check
        ULONGLONG rc:1;         //    62 : Register File Check
        ULONGLONG uc:1;         //    63 : Micro-Architectural Check
    };
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;
    
typedef union _PROCESSOR_LOCAL_ID  {
    ULONGLONG LocalId;
    struct {
        ULONGLONG reserved:16;  //  0-16 : reserved
        ULONGLONG eid:8;        // 16-23 : Extended Id 
        ULONGLONG id:8;         // 24-31 : Id
        ULONGLONG ignored:32;   // 32-63 : ignored
    };
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;                                       

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
    ULONGLONG     Valid;
    struct {                                // Bits
        // Warning: Match the VALID fields with the _ERROR_PROCESSOR_STATIC_INFO members.
        //          KD extensions use the field names to access the PSI structure.
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BR: 1;                    //       1: Branch      Registers valid.
        ULONGLONG CR: 1;                    //       2: Control     Registers valid.
        ULONGLONG AR: 1;                    //       3: Application Registers valid.
        ULONGLONG RR: 1;                    //       4:             Registers valid.
        ULONGLONG FR: 1;                    //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO  {
    ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
    ERROR_SECTION_HEADER              Header;
    ERROR_PROCESSOR_VALID             Valid;
    ERROR_PROCESSOR_ERROR_MAP         ErrorMap;
    ERROR_PROCESSOR_STATE_PARAMETER   StateParameter;
    PROCESSOR_LOCAL_ID                CRLid;
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

//
// IA64 ERROR PROCESSOR State Parameter - GR18 - definitions.
//

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT     60
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK      0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT       61
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT       62
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT   63
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK    0x1

////////////////////////////////////////////////////////////////////
//
// IA64 PLATFORM ERRORS Definitions
//
// We tried to respect the order in which these error devices are 
// presented in the SAL specs.

//
// IA64 ERRORS: _ERR_TYPE definitions
//
// Warning 04/01/01: "ERR_TYPE" or "ERROR_TYPE" are already used in the NT namespace.
//

typedef enum _ERR_TYPES    {
// Generic error types:
    ERR_INTERNAL = 1,         // Error detected internal to the component
    ERR_BUS      = 16,        // Error detected in the bus
// Detailed Internal Error Types:
    ERR_MEM      = 4,         // Storage error in memory (DRAM)
    ERR_TLB      = 5,         // Storage error in TLB
    ERR_CACHE    = 6,         // Storage error in cache
    ERR_FUNCTION = 7,         // Error in one or more functional units
    ERR_SELFTEST = 8,         // Component failed self test
    ERR_FLOW     = 9,         // Overflow or Undervalue of internal queue
// Detailed Bus Error Types:
    ERR_MAP      = 17,        // Virtual address not found on IO-TLB or IO-PDIR
    ERR_IMPROPER = 18,        // Improper access error
    ERR_UNIMPL   = 19,        // Access to a memory address which is not mapped to any component
    ERR_LOL      = 20,        // Loss Of Lockstep
    ERR_RESPONSE = 21,        // Response to which there is no associated request
    ERR_PARITY   = 22,        // Bus parity error
    ERR_PROTOCOL = 23,        // Detection of a protocol error
    ERR_ERROR    = 24,        // Detection of PATH_ERROR
    ERR_TIMEOUT  = 25,        // Bus operation time-out
    ERR_POISONED = 26,        // A read was issued to data which has been poisoned
} _ERR_TYPE;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highest severity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow 
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS, *PERROR_STATUS;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

//
// IA64 ERRORS: Platform ERROR_MEMORY device definitions
//
// With reference to the ACPI Memory Device.
//

#define ERROR_MEMORY_GUID \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MEMORY_VALID    {
    ULONGLONG     Valid;
    struct {                                 // Bits
        ULONGLONG ErrorStatus:1;             //       0: Error Status valid bit
        ULONGLONG PhysicalAddress:1;         //       1: Physical Address valid bit
        ULONGLONG AddressMask:1;             //       2: Address Mask bit
        ULONGLONG Node:1;                    //       3: Node valid bit
        ULONGLONG Card:1;                    //       4: Card valid bit
        ULONGLONG Module:1;                  //       5: Module valid bit
        ULONGLONG Bank:1;                    //       6: Bank valid bit
        ULONGLONG Device:1;                  //       7: Device valid bit
        ULONGLONG Row:1;                     //       8: Row valid bit
        ULONGLONG Column:1;                  //       9: Column valid bit
        ULONGLONG BitPosition:1;             //      10: Bit Position valid bit
        ULONGLONG RequestorId:1;             //      11: Platform Requestor Id valid bit
        ULONGLONG ResponderId:1;             //      12: Platform Respinder Id valid bit
        ULONGLONG TargetId:1;                //      13: Platform Target    Id valid bit
        ULONGLONG BusSpecificData:1;         //      14: Platform Bus specific data valid bit
        ULONGLONG OemId:1;                   //      15: Platform OEM id   valid bit
        ULONGLONG OemData:1;                 //      16: Platform OEM data valid bit
        ULONGLONG Reserved:47;               //   63-17: Reserved
    };
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY    {
    ERROR_SECTION_HEADER  Header;
    ERROR_MEMORY_VALID    Valid;
    ERROR_STATUS          ErrorStatus;         // Memory device error status fields - See ERROR_STATUS defs.
    ULONGLONG             PhysicalAddress;     // Physical Address of the memory error
    ULONGLONG             PhysicalAddressMask; // Valid bits for Physical Address
    USHORT                Node;                // Node identifier in a multi-node system
    USHORT                Card;                // Card   number of the memory error location
    USHORT                Module;              // Module number of the memory error location
    USHORT                Bank;                // Bank   number of the memory error location
    USHORT                Device;              // Device number of the memory error location
    USHORT                Row;                 // Row    number of the memory error location
    USHORT                Column;              // Column number of the memory error location
    USHORT                BitPosition;         // Bit within the word that is in error
    ULONGLONG             RequestorId;         // Hardware address of the device or component initiating transaction
    ULONGLONG             ResponderId;         // Hardware address of the responder to transaction
    ULONGLONG             TargetId;            // Hardware address of intended target of transaction       
    ULONGLONG             BusSpecificData;     // Bus dependent data of the on-board processor. It is a OEM specific field.
    UCHAR                 OemId[16];           // OEM defined identification for memory controller
    ERROR_OEM_DATA        OemData;     // OEM platform specific data. 
} ERROR_MEMORY, *PERROR_MEMORY;

//
// IA64 ERRORS: Platform ERROR_PCI_BUS device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_BUS_GUID \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_BUS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorStatus:1;            //       0: Error Status             valid bit
        ULONGLONG ErrorType:1;              //       1: Error Type               valid bit
        ULONGLONG Id:1;                     //       2: Identifier               valid bit
        ULONGLONG Address:1;                //       3: Address                  valid bit
        ULONGLONG Data:1;                   //       4: Data                     valid bit
        ULONGLONG CmdType:1;                //       5: Command Type             valid bit
        ULONGLONG RequestorId:1;            //       6: Requestor Identifier     valid bit
        ULONGLONG ResponderId:1;            //       7: Responder Identifier     valid bit
        ULONGLONG TargetId:1;               //       8: Target    Identifer      valid bit
        ULONGLONG OemId:1;                  //       9: OEM Identification       valid bit
        ULONGLONG OemData:1;                //      10: OEM Data                 valid bit
        ULONGLONG Reserved:57;              //   11-63: Reserved
    };
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
    UCHAR Type;
    UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)
//      PciOtherErrors           Reserved

typedef struct _ERROR_PCI_BUS_ID    {
    UCHAR BusNumber;         // Bus     Number
    UCHAR SegmentNumber;     // Segment Number
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS    {
    ERROR_SECTION_HEADER  Header;
    ERROR_PCI_BUS_VALID   Valid;
    ERROR_STATUS          ErrorStatus;    // PCI Bus Error Status - See ERROR_STATUS definitions.
    ERROR_PCI_BUS_TYPE    Type;           // PCI Bus Error Type 
    ERROR_PCI_BUS_ID      Id;             // PCI Bus Identifier      
    UCHAR                 Reserved[4];    // Reserved
    ULONGLONG             Address;        // Memory or IO Address on the PCI bus at
                                          // the time of the event
    ULONGLONG             Data;           // Data on the PCI bus at time of the event
    ULONGLONG             CmdType;        // Bus Command or Operation at time of the event
    ULONGLONG             RequestorId;    // Bus Requestor Identifier at time of the event
    ULONGLONG             ResponderId;    // Bus Responder Identifier at time of the event
    ULONGLONG             TargetId;       // Intended Bus Target Identifier at time of the event
    UCHAR                 OemId[16];      // OEM defined identification for pci bus
    ERROR_OEM_DATA        OemData;        // OEM specific data. 
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

//
// IA64 ERRORS: Platform ERROR_PCI_COMPONENT device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_COMPONENT_GUID \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_COMPONENT_VALID   {
    ULONGLONG Valid;
    struct {                                       // Bits:
        ULONGLONG ErrorStatus:1;                   //    0: Error Status valid bit
        ULONGLONG Info:1;                          //    1: Information  valid bit
        ULONGLONG MemoryMappedRegistersPairs:1;    //    2: Number of Memory Mapped Registers Pairs valid bit
        ULONGLONG ProgrammedIORegistersPairs:1;    //    3: Number of Programmed IO Registers Pairs valid bit
        ULONGLONG RegistersDataPairs:1;            //    4: Memory Mapped Registers Pairs valid bit
        ULONGLONG OemData:1;                       //    5: OEM Data valid bit.
        ULONGLONG Reserved:58;                     // 63-6: Reserved
    };
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {  // Bytes:
   USHORT VendorId;                         //   0-1: Vendor Identifier
   USHORT DeviceId;                         //   2-3: Device Identifier
   UCHAR  ClassCodeInterface;               //     4: Class Code.Interface field
   UCHAR  ClassCodeSubClass;                //     5: Class Code.SubClass  field
   UCHAR  ClassCodeBaseClass;               //     6: Class Code.BaseClass field
   UCHAR  FunctionNumber;                   //     7: Function Number
   UCHAR  DeviceNumber;                     //     8: Device Number
   UCHAR  BusNumber;                        //     9: Bus Number
   UCHAR  SegmentNumber;                    //    10: Segment Number
   UCHAR  Reserved0;    
   ULONG  Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT  {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;                 // Component Error Status
     ERROR_PCI_COMPONENT_INFO    Info;                        // Component Information
     ULONG                       MemoryMappedRegistersPairs;  // Number of Memory Mapped Registers Pairs
     ULONG                       ProgrammedIORegistersPairs;  // Number of Programmed IO Registers Pairs
#if 0
     ULONGLONG                   RegistersPairs[/* 2 * (MemoryMappedRegistersPairs + ProgrammedIORegistersPairs) */];
     ERROR_OEM_DATA              OemData;
#endif // 0
 } ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

//
// IA64 ERRORS: Platform ERROR_SYSTEM_EVENT_LOG device definitions
//
// With reference to the IPMI System Event Log.
//

#define ERROR_SYSTEM_EVENT_LOG_GUID \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG RecordId:1;               //       0: Record Identifier     valid bit
        ULONGLONG RecordType:1;             //       1: Record Type           valid bit
        ULONGLONG GeneratorId:1;            //       2: Generator Identifier  valid bit
        ULONGLONG EVMRev:1;                 //       3: Event Format Revision valid bit
        ULONGLONG SensorType:1;             //       4: Sensor Type           valid bit
        ULONGLONG SensorNum:1;              //       5: Sensor Number         valid bit
        ULONGLONG EventDirType:1;           //       6: Event Dir             valid bit
        ULONGLONG EventData1:1;             //       7: Event Data1           valid bit
        ULONGLONG EventData2:1;             //       8: Event Data2           valid bit
        ULONGLONG EventData3:1;             //       9: Event Data3           valid bit
        ULONGLONG Reserved:54;              //   10-63:
    };
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG    {
    ERROR_SECTION_HEADER         Header;
    ERROR_SYSTEM_EVENT_LOG_VALID Valid;
    USHORT                       RecordId;     // Record Identifier used for SEL record access
    UCHAR                        RecordType;   // Record Type:
                                               //   0x02 - System Event Record
                                               //   0xC0 - 0xDF OEM     time stamped, bytes 8-16 OEM defined
                                               //   0xE0 - 0xFF OEM non-time stamped, bytes 4-16 OEM defined
    ULONG                        TimeStamp;    // Time stamp of the event log
    USHORT                       GeneratorId;  // Software ID if event was generated by software
                                               //   Byte 1:
                                               //       Bit 0   - set to 1 when using system software
                                               //       Bit 7:1 - 7-bit system ID
                                               //   Byte 2:
                                               //       Bit 1:0 - IPMB device LUN if byte 1 holds slave
                                               //                 address, 0x0 otherwise
                                               //       Bit 7:2 - Reserved.
    UCHAR                        EVMRevision;  // Error message format version
    UCHAR                        SensorType;   // Sensor Type code of the sensor that generated event
    UCHAR                        SensorNumber; // Number of the sensor that generated event
    UCHAR                        EventDir;     // Event Dir
                                               //   Bit 7 - 0: asserted, 1: desasserted
                                               // Event Type
                                               //   Bit 6:0 - Event Type code
    UCHAR                        Data1;        // Event data field
    UCHAR                        Data2;        // Event data field
    UCHAR                        Data3;        // Event data field
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

//
// IA64 ERRORS: Platform ERROR_SMBIOS device definitions
//
// With reference to the SMBIOS Specifications.
//

#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SMBIOS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG EventType:1;              //       0: Event Type valid bit
        ULONGLONG Length:1;                 //       1: Length     valid bit
        ULONGLONG TimeStamp:1;              //       2: Time Stamp valid bit
        ULONGLONG OemData:1;                //       3: Data       valid bit
        ULONGLONG Reserved:60;              //    4-63:
    };
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

//
// ERROR_SMBIOS.Type definitions
//

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;
// enum values defined in SMBIOS 2.3 - 3.3.16.6.1

typedef struct _ERROR_SMBIOS    {
    ERROR_SECTION_HEADER     Header;
    ERROR_SMBIOS_VALID       Valid;
    ERROR_SMBIOS_EVENT_TYPE  EventType;   // Event Type
    UCHAR                    Length;      // Length of the error information in bytes
    ERROR_TIMESTAMP          TimeStamp;   // Event Time Stamp
    ERROR_OEM_DATA           OemData;     // Optional data validated by SMBIOS.Valid.Data.
} ERROR_SMBIOS, *PERROR_SMBIOS;

//
// IA64 ERRORS: Platform Specific error device definitions
//

#define ERROR_PLATFORM_SPECIFIC_GUID \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC  {
     ERROR_SECTION_HEADER           Header;
     ERROR_PLATFORM_SPECIFIC_VALID  Valid;
     ERROR_STATUS                   ErrorStatus; // Platform Generic Error Status
     ULONGLONG                      RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                      ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                      TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA        BusSpecificData; // OEM specific Bus dependent data
     UCHAR                          OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA                 OemData;         // OEM specific data 
#if 0
     UCHAR                          OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

//
// IA64 ERRORS: Platform Bus error device definitions
//

#define ERROR_PLATFORM_BUS_GUID \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_BUS_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
     ERROR_SECTION_HEADER        Header;
     ERROR_PLATFORM_BUS_VALID    Valid;
     ERROR_STATUS                ErrorStatus;       // Bus Error Status
     ULONGLONG                   RequestorId;       // Bus Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Bus Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

//
// IA64 ERRORS: Platform Host Controller error device definitions
//

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}
    

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;       // Host Controller Error Status
     ULONGLONG                   RequestorId;       // Host controller Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Host controller Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Host controller intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

//
// IA64 ERROR_LOGRECORDS definitions
//
//  MCA_EXCEPTION,
//  CMC_EXCEPTION,
//  CPE_EXCEPTION.
//

// For compatibility with previous versions of the definitions:
typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;

typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;    // Machine Check Abort
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#endif // _IA64_

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#endif // _MCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\loadperf.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    loadperf.h

Abstract:

    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History

    16-Nov-95   Created (a-robw)

--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument

#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR)1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR)2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR)4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR)8)

// note: LOADPERF_FLAGS_LOAD_REGISTRY_ONLY is not a valid flag for
// LoadMofFromInstalledServiceA/W as the service must already be installed

LOADPERF_FUNCTION
LoadMofFromInstalledServiceA (
    IN  LPCSTR  szServiceName,  // service to create mof for
    IN  LPCSTR  szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
LoadMofFromInstalledServiceW (
    IN  LPCWSTR szServiceName,  // service to create mof for
    IN  LPCWSTR szMofFilename,  // name of file to create
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
InstallPerfDllW (
    IN  LPCWSTR szComputerName,
    IN  LPCWSTR lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpIniFile,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
UnInstallPerfDllA (
    IN  LPCSTR  szComputerName,
    IN  LPCSTR  lpServiceName,
    IN  ULONG_PTR   dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW (
    IN  LPWSTR  lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA (
    IN  LPSTR   lpCommandLine,
    IN  BOOL    bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA (
    IN  LPCSTR      szNewCtrFilePath,
    IN  LPCSTR      szNewHlpFilePath,
    IN  LPSTR       szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW (
    IN  LPCWSTR     szNewCtrFilePath,
    IN  LPCWSTR     szNewHlpFilePath,
    IN  LPWSTR      szLanguageID,
    IN  ULONG_PTR   dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA (
    LPCSTR szReserved,
    LPCSTR szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW (
    LPCWSTR szReserved,
    LPCWSTR szServiceName
);


#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define UnInstallPerfDll                UnInstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define LoadMofFromInstalledService     LoadMofFromInstalledServiceW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define UnInstallPerfDll                UnInstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsA
#define LoadMofFromInstalledService     LoadMofFromInstalledServiceA
#define UpdatePerfNameFiles             UpdatePerfNameFilesA
#define SetServiceAsTrusted             SetServiceAsTrustedA
#endif


#ifdef __cplusplus
}
#endif


#endif // _LOADPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\ntacpi.h ===
;/*++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
; Module Name:
;
;   ntacpi.h
;
; Abstract:
;
;
;   This module contains definitions specific to the HAL's
;   ACPI function.
;
; Author:
;
;   Jake Oshins (jakeo) Feb. 18, 1997
;
; Revision History:
;
;-

if 0        ; Begin C only code         */

#ifndef _ACPI_H_
#define _ACPI_H_


#define SLEEP_STATE_FLUSH_CACHE         0x1
#define SLEEP_STATE_FIRMWARE_RESTART    0x2
#define SLEEP_STATE_SAVE_MOTHERBOARD    0x4
#define SLEEP_STATE_OFF                 0x8
#define SLEEP_STATE_RESTART_OTHER_PROCESSORS    0x10

typedef struct {
    union {
        struct {
            ULONG       Pm1aVal:4;
            ULONG       Pm1bVal:4;
            ULONG       Flags:24;
        } bits;
        ULONG   AsULONG;
    };
} SLEEP_STATE_CONTEXT, *PSLEEP_STATE_CONTEXT;


//
// ACPI Register definitions
//

#define P_LVL2          4
#define PBLK_THT_EN                     0x10

//
// Register layout of PM1x_EVT register
// Note also defined in acpiregs.h
//

#define PM1_PWRBTN_STS_BIT      8
#define PM1_PWRBTN_STS          (1 << PM1_PWRBTN_STS_BIT)

//
// Register layout of PM1x_CTL
//

#define SCI_EN              1
#define BM_RLD              2
#define CTL_IGNORE          0x200
#define SLP_TYP_SHIFT       10
#define SLP_EN              0x2000

#define CTL_PRESERVE        (SCI_EN + BM_RLD + CTL_IGNORE)

#define PM_TMR_FREQ     3579545



//
// HAL's table
//

typedef enum {
    HalAcpiTimerInit,
    HalAcpiTimerInterrupt,
    HalAcpiMachineStateInit,
    HalAcpiQueryFlags,
    HalPicStateIntact,
    HalRestorePicState,
    HalPciInterfaceReadConfig,
    HalPciInterfaceWriteConfig,
    HalSetVectorState,
    HalGetIOApicVersion,
    HalSetMaxLegacyPciBusNumber,
    HalIsVectorValid,
    HalAcpiMaxFunction
} HAL_DISPATCH_FUNCTION;

typedef
VOID
(*pHalAcpiTimerInit)(
    IN ULONG    TimerPort,
    IN BOOLEAN  TimerValExt
    );

typedef
VOID
(*pHalAcpiTimerInterrupt)(
    VOID
    );

typedef struct {
    ULONG   Count;
    ULONG   Pblk[1];
} PROCESSOR_INIT, *PPROCESSOR_INIT;

#define HAL_C1_SUPPORTED 0x01
#define HAL_C2_SUPPORTED 0x02
#define HAL_C3_SUPPORTED 0x04
#define HAL_S1_SUPPORTED 0x08
#define HAL_S2_SUPPORTED 0x10
#define HAL_S3_SUPPORTED 0x20
#define HAL_S4_SUPPORTED 0x40
#define HAL_S5_SUPPORTED 0x80

typedef struct {
    BOOLEAN     Supported;
    UCHAR       Pm1aVal;
    UCHAR       Pm1bVal;
} HAL_SLEEP_VAL, *PHAL_SLEEP_VAL;

typedef
VOID
(*pHalAcpiMachineStateInit)(
    IN  PPROCESSOR_INIT ProcInit,
    IN  PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG          PicVal
    );

typedef
ULONG
(*pHalAcpiQueryFlags)(
    VOID
    );

typedef
BOOLEAN
(*pHalPicStateIntact)(
    VOID
    );

typedef
VOID
(*pHalRestorePicState)(
    VOID
    );

typedef
ULONG
(*pHalInterfaceReadWriteConfig)(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

//
// Flags for interrupt vectors
//

#define VECTOR_MODE         1
#define VECTOR_LEVEL        1
#define VECTOR_EDGE         0
#define VECTOR_POLARITY     2
#define VECTOR_ACTIVE_LOW   2
#define VECTOR_ACTIVE_HIGH  0

//
// Vector Type:
//
// VECTOR_SIGNAL = standard edge-triggered or
//		   level-sensitive interrupt vector
//
// VECTOR_MESSAGE = an MSI (Message Signalled Interrupt) vector
//

#define VECTOR_TYPE         4
#define VECTOR_SIGNAL       0
#define VECTOR_MESSAGE      4

#define IS_LEVEL_TRIGGERED(vectorFlags) \
    (vectorFlags & VECTOR_LEVEL)

#define IS_EDGE_TRIGGERED(vectorFlags) \
    !(vectorFlags & VECTOR_LEVEL)

#define IS_ACTIVE_LOW(vectorFlags) \
    (vectorFlags & VECTOR_ACTIVE_LOW)

#define IS_ACTIVE_HIGH(vectorFlags) \
    !(vectorFlags & VECTOR_ACTIVE_LOW)

typedef
VOID
(*pHalSetVectorState)(
    IN ULONG Vector,
    IN ULONG Flags
    );

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    );

#define HAL_ACPI_PCI_RESOURCES    0x01
#define HAL_ACPI_PRT_SUPPORT      0x02

typedef
ULONG
(*pHalGetIOApicVersion)(
    IN ULONG ApicNo
    );

typedef
VOID
(*pHalSetMaxLegacyPciBusNumber)(
    IN ULONG BusNumber
    );

typedef
BOOLEAN
(*pHalIsVectorValid)(
    IN ULONG Vector
    );

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    );

//
//  typedef struct _PM_DISPATCH_TABLE {
//      ULONG   Signature;
//      ULONG   Version;
//      PVOID   Function[1];
//  } PM_DISPATCH_TABLE, *PPM_DISPATCH_TABLE;
//

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pHalAcpiTimerInit               HalpAcpiTimerInit;
    pHalAcpiTimerInterrupt          HalpAcpiTimerInterrupt;
    pHalAcpiMachineStateInit        HalpAcpiMachineStateInit;
    pHalAcpiQueryFlags              HalpAcpiQueryFlags;
    pHalPicStateIntact              HalxPicStateIntact;
    pHalRestorePicState             HalxRestorePicState;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceReadConfig;
    pHalInterfaceReadWriteConfig    HalpPciInterfaceWriteConfig;
    pHalSetVectorState              HalpSetVectorState;
    pHalGetIOApicVersion            HalpGetIOApicVersion;
    pHalSetMaxLegacyPciBusNumber    HalpSetMaxLegacyPciBusNumber;
    pHalIsVectorValid               HalpIsVectorValid;
} HAL_ACPI_DISPATCH_TABLE, *PHAL_ACPI_DISPATCH_TABLE;

#define HAL_ACPI_DISPATCH_SIGNATURE   'HAL '
#define HAL_ACPI_DISPATCH_VERSION     2

#define HalAcpiTimerInit            ((pHalAcpiTimerInit)PmHalDispatchTable->Function[HalAcpiTimerInit])
#define HalAcpiTimerInterrupt       ((pHalAcpiTimerInterrupt)PmHalDispatchTable->Function[HalAcpiTimerInterrupt])
#define HalAcpiMachineStateInit     ((pHalAcpiMachineStateInit)PmHalDispatchTable->Function[HalAcpiMachineStateInit])
#define HalPicStateIntact           ((pHalPicStateIntact)PmHalDispatchTable->Function[HalPicStateIntact])
#define HalRestorePicState          ((pHalRestorePicState)PmHalDispatchTable->Function[HalRestorePicState])
#define HalPciInterfaceReadConfig   ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceReadConfig])
#define HalPciInterfaceWriteConfig  ((pHalInterfaceReadWriteConfig)PmHalDispatchTable->Function[HalPciInterfaceWriteConfig])
#define HalSetVectorState           ((pHalSetVectorState)PmHalDispatchTable->Function[HalSetVectorState])
#define HalGetIOApicVersion         ((pHalGetIOApicVersion)PmHalDispatchTable->Function[HalGetIOApicVersion])
#define HalSetMaxLegacyPciBusNumber ((pHalSetMaxLegacyPciBusNumber)PmHalDispatchTable->Function[HalSetMaxLegacyPciBusNumber])
#define HalIsVectorValid            ((pHalIsVectorValid)PmHalDispatchTable->Function[HalIsVectorValid])

extern PPM_DISPATCH_TABLE PmAcpiDispatchTable;
extern PPM_DISPATCH_TABLE PmHalDispatchTable;

//
// ACPI driver's table
//
typedef enum {
    AcpiEnableDisableGPEvents,
    AcpiInitEnableAcpi,
    AcpiGpeEnableWakeEvents,
    AcpiMaxFunction
} ACPI_DISPATCH_FUNCTION;

typedef
VOID
(*pAcpiEnableDisableGPEvents) (
    IN BOOLEAN Enable
    );

typedef
VOID
(*pAcpiInitEnableAcpi) (
    IN BOOLEAN ReEnable
    );

typedef
VOID
(*pAcpiGpeEnableWakeEvents)(
    VOID
    );

typedef struct {
    ULONG   Signature;
    ULONG   Version;
    pAcpiEnableDisableGPEvents    AcpipEnableDisableGPEvents;
    pAcpiInitEnableAcpi           AcpipInitEnableAcpi;
    pAcpiGpeEnableWakeEvents      AcpipGpeEnableWakeEvents;
} ACPI_HAL_DISPATCH_TABLE, *PACPI_HAL_DISPATCH_TABLE;

#define ACPI_HAL_DISPATCH_SIGNATURE   'ACPI'
#define ACPI_HAL_DISPATCH_VERSION     1

#define AcpiEnableDisableGPEvents       (*(pAcpiEnableDisableGPEvents)PmAcpiDispatchTable->Function[AcpiEnableDisableGPEvents])
#define AcpiInitEnableAcpi              (*(pAcpiInitEnableAcpi)PmAcpiDispatchTable->Function[AcpiInitEnableAcpi])
#define AcpiGpeEnableWakeEvents         (*(pAcpiGpeEnableWakeEvents)PmAcpiDispatchTable->Function[AcpiGpeEnableWakeEvents])

// from detect\i386\acpibios.h
typedef struct {
    PHYSICAL_ADDRESS    Base;
    LARGE_INTEGER       Length;
    ULONGLONG           Type;
} ACPI_E820_ENTRY, *PACPI_E820_ENTRY;

typedef struct _ACPI_BIOS_MULTI_NODE {
    PHYSICAL_ADDRESS    RsdtAddress;    // 64-bit physical address of RSDT
    ULONGLONG           Count;
    ACPI_E820_ENTRY     E820Entry[1];
} ACPI_BIOS_MULTI_NODE;
 
typedef ACPI_BIOS_MULTI_NODE UNALIGNED *PACPI_BIOS_MULTI_NODE;

typedef enum {
    AcpiAddressRangeMemory = 1,
    AcpiAddressRangeReserved,
    AcpiAddressRangeACPI,
    AcpiAddressRangeNVS,
    AcpiAddressRangeMaximum,
} ACPI_BIOS_E820_TYPE, *PACPI_BIOS_E820_TYPE;


NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    );

#endif //_ACPI_H_

/*
endif
;
;  Begin assembly part of the definitions
;


;
; Register layout of ACPI processor register block
;

P_CNT                   equ     0
P_LVL2                  equ     4
P_LVL3                  equ     5


;
; Register layout of PM1x_EVT register
;

BM_STS              equ       10h
WAK_STS             equ     8000h

;
; Register layout of PM1x_Enable
;

TMR_EN              equ     0001h
GBL_EN              equ     0020h
PWRBTN_EN           equ     0100h
SLPBTN_EN           equ     0200h
RTC_EN              equ     0400h

;
; Register layout of PM1x_CTL
;

SCI_EN              equ     1
BM_RLD              equ     2
CTL_IGNORE          equ     200h
SLP_TYP_SHIFT       equ     10
SLP_EN              equ     2000h

CTL_PRESERVE        equ     (SCI_EN + BM_RLD + CTL_IGNORE)

;
; Register layout of PM2_CNT
;

ARB_DIS             equ     1

;
; ACPI registers, as laid out in HalpFixedAcpiDescTable
;

PM1a_EVT        EQU _HalpFixedAcpiDescTable + 56
PM1b_EVT        EQU _HalpFixedAcpiDescTable + 60
PM1_EVT_LEN     EQU _HalpFixedAcpiDescTable + 88

PM1a_CNT        EQU _HalpFixedAcpiDescTable + 64
PM1b_CNT        EQU _HalpFixedAcpiDescTable + 68

PM2_CNT_BLK     EQU _HalpFixedAcpiDescTable + 72

PM_TMR_BLK      EQU _HalpFixedAcpiDescTable + 76
PM_TMR_FREQ     EQU 3579545

GPE0_BLK        EQU _HalpFixedAcpiDescTable + 80
GPE1_BLK        EQU _HalpFixedAcpiDescTable + 84

GPE0_BLK_LEN    EQU _HalpFixedAcpiDescTable + 92
GPE1_BLK_LEN    EQU _HalpFixedAcpiDescTable + 93

FLUSH_SIZE      EQU _HalpFixedAcpiDescTable + 100
FLUSH_STRIDE    EQU _HalpFixedAcpiDescTable + 102

DUTY_OFFSET     EQU _HalpFixedAcpiDescTable + 104

RTC_DAY_ALRM    EQU _HalpFixedAcpiDescTable + 106
RTC_MON_ALRM    EQU _HalpFixedAcpiDescTable + 107
RTC_CENTURY     EQU _HalpFixedAcpiDescTable + 108
FADT_FLAGS      EQU _HalpFixedAcpiDescTable + 112

;
; FADT flag values
;
WBINVD_SUPPORTED    EQU 1
WBINVD_FLUSH        EQU 2

;
GeneralWakeupEnable EQU 0
RtcWakeupEnable     EQU 1

;
; Constants used in the Context parameter to HaliAcpiSleep
;  (must match C code above)
;
SLEEP_STATE_FLUSH_CACHE         EQU 1
SLEEP_STATE_FIRMWARE_RESTART    EQU 2
SLEEP_STATE_SAVE_MOTHERBOARD    EQU 4
SLEEP_STATE_OFF                 EQU 8
SLEEP_STATE_RESTART_OTHER_PROCESSORS    EQU 10h
CONTEXT_FLAG_SHIFT              EQU 8


;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\makefile.inc ===
$(O)\winerror.h : winerror.mc
    $(MC) -h $(PASS0_HEADERDIR) -r $(MC_SOURCEDIR) -d $(MC_FLAGS) $?

$(O)\dpfilter.h : componentid.tab
    genlvl -t $(O)

$(O)\mcaia64.mof: mcaia64.mof
    $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS) mcaia64.mof > $(O)\mcaia64.mof

$(O)\ntrtl.h : ntrtl.w $(O)\dpfilter.h makefile.inc
    type ntrtl.w > $@
    type $(O)\dpfilter.h >> $@
    type << >> $@
// end_ntddk end_wdm end_nthal end_ntifs end_ntndis
#endif // _NTRTL_
<<

$(O)\pooltag.txt : pooltag.w
    copy $? $@

$(O)\pooltag.pri : pooltag.w
    copy $? $@

ZWAPI_DEPENDS = \
    $(SDK_INC_PATH)\ntdsapi.h \
    ntelfapi.w \
    ntexapi_h.w \
    ntioapi.w \
    ntkeapi.w \
    $(SDK_INC_PATH)\ntlpcapi.h \
    $(SDK_INC_PATH)\ntlsapi.h \
    ntmmapi.w \
    $(SDK_INC_PATH)\ntmsapi.h \
    ntobapi.w \
    ntpnpapi.w \
    ntpoapi.w \
    ntpsapi.w \
    ntregapi.w \
    $(SDK_INC_PATH)\ntseapi.h \
    $(SDK_INC_PATH)\ntsecapi.h \
    ntwmi.w \
    ntxcapi.w

$(O)\zwapi.h : $(ZWAPI_DEPENDS)
    -del $@
    zwapi -o $@ $(ZWAPI_DEPENDS)

WINNT_DEPENDS = ntdef.w \
                $(O)\ntstatus.h \
                ntkeapi.w \
!if exist(ntamd64.w)
                ntamd64.w \
!endif
                ntalpha.w \
                nti386.w \
                ntmips.w \
                ntppc.w \
                ntmppc.w \
                ntia64.w \
                ntxcapi.w \
                $(SDK_INC_PATH)\ntseapi.h \
                ntpsapi.w \
                ntexapi_h.w \
                ntmmapi.w \
                ntioapi.w \
                ntobapi.w \
                ntpoapi.w \
                ntimage.w \
                $(O)\ntrtl.h  \
                nturtl.w  \
                ntldr.w  \
                ntelfapi.w \
                ntregapi.w \
                $(SDK_INC_PATH)\ntconfig.h \
                $(SDK_INC_PATH)\ntddtape.h \
                nxalpha.w \
                nxamd64.w \
                nxia64.w \
                nxi386.w \
                sxstypes.w

########################################################################
# winnt.h
#

$(O)\winnt.h: $(WINNT_DEPENDS) makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winnt.h

Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/

#ifndef _WINNT_
#define _WINNT_

#ifdef __cplusplus
extern "C" {
#endif

<<
    hextract -f2 -o $@ -lt winnt -bt begin_winnt end_winnt $(WINNT_DEPENDS)
    type << >> $@

#ifdef __cplusplus
}
#endif

#endif /* _WINNT_ */

<<

########################################################################
# winnt.rh
#

$(O)\winnt.rh: ntdef.w makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    winnt.rh

Abstract:

    This module defines the 32-Bit Windows resource codes from winnt.h

Revision History:

--*/
<<
    hextract -o $@ -lt r_winnt -bt begin_r_winnt end_r_winnt ntdef.w

#
# winbase.h, winbasep.h, wbasek.h, winbase.x, winbasep.x
#

$(O)\winbase.x $(O)\winbasep.x $(O)\wbasek.h : winbase.w
    hsplit -e -x $(O)\wbasek.h userk -o $(O)\winbase.x $(O)\winbasep.x winbase.w

$(O)\winbase.y : $(O)\winbase.x
    wcshdr < $? > $@

$(O)\winbase.inl: $(O)\winbase.h

$(O)\winbase.h : $(O)\winbase.y
    shfusion2 $? > $@ SetStubsFile('$(O)\winbase.inl')

$(O)\winbasep.h : $(O)\winbasep.x
    wcshdr < $? > $@

#
# sxstypes.h
#
$(O)\sxstypes.h : sxstypes.w
    echo. > $@
    hextract -o $@ -xt winnt_only -lt sxstypes -bt begin_sxstypes end_sxstypes $?

#
# winnls.h, winnlsp.h, winnls.x
#

$(O)\winnls.x $(O)\winnlsp.h: winnls.w
    hsplit -e -o $(O)\winnls.x $(O)\winnlsp.h winnls.w

$(O)\winnls.h: $(O)\winnls.x
    wcshdr < $? > $@

#
# winreg.h, winregp.x, winreg.x
#

$(O)\winreg.x $(O)\winregp.x: winreg.w
    hsplit -e -o $(O)\winreg.x $(O)\winregp.x winreg.w

$(O)\winreg.h: $(O)\winreg.x
    wcshdr < $? > $@

#
# wmidata.h, wmicore.bmf, wmicore.mof
#

$(O)\wmicore.bmf: $(O)\wmicore.mof

$(O)\wmidata.h : $(O)\wmicore.bmf
    wmimofck -m -h$@ $?
    
#
# lzexpand.h
#

$(O)\lzexpand.h : lzexpand.x
    wcshdr < $? > $@

#
# strsafe.h, ntstrsafe.h
#

STRSAFE_DEPENDS = strsafe.w

$(O)\ntstrsafe.h : $(STRSAFE_DEPENDS) ntstrsafe.mng
    type << > $@
<<
    hextract -o $@ -bt begin_ntstrsafe end_ntstrsafe $(STRSAFE_DEPENDS)
    -munge ntstrsafe.mng -k -m -i -l -t $@ >> NUL

$(O)\strsafe.h : $(STRSAFE_DEPENDS)
    type << > $@
<<
    hextract -o $@ -bt begin_strsafe end_strsafe $(STRSAFE_DEPENDS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\riname.h ===
#define GENNAME_NO_ERROR            0
#define GENNAME_TEMPLATE_INVALID    1
#define GENNAME_COUNTER_TOO_HIGH    2
#define GENNAME_VARIABLE_MISSING    3
#define GENNAME_NAME_TOO_LONG       4

#define GENNAME_VARIABLE_USERNAME   L"USERNAME"
#define GENNAME_VARIABLE_FIRSTNAME  L"USERFIRSTNAME"
#define GENNAME_VARIABLE_LASTNAME   L"USERLASTNAME"
#define GENNAME_VARIABLE_MAC        L"MAC"

typedef struct _GENNAME_VARIABLES {
    PWSTR UserName;
    PWSTR FirstName;
    PWSTR LastName;
    PWSTR MacAddress;
    DWORD Counter;
    BOOL AllowCounterTruncation;
} GENNAME_VARIABLES, *PGENNAME_VARIABLES;

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\oprghdlr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    oprghdlr.h

Abstract:

    This header file contains the shared structures for the ACPI op region
    registration DLL.
    
Author:

    Vincent Geglia 09-Feb-2000

Environment:

    Kernel mode

Notes:

    
Revision History:


--*/

#include "wdm.h"

//
// Make sure that we define the right calling convention
//

#ifdef EXPORT
  #undef EXPORT
#endif
#define EXPORT  __cdecl

//
// Op region handler and callback function prototypes
//

typedef VOID (EXPORT *PACPI_OP_REGION_CALLBACK)();

typedef
NTSTATUS
(EXPORT *PACPI_OP_REGION_HANDLER) (
    ULONG AccessType,
    PVOID OperationRegionObject,
    ULONG Address,
    ULONG Size,
    PULONG Data,
    ULONG_PTR Context,
    PACPI_OP_REGION_CALLBACK CompletionHandler,
    PVOID CompletionContext
    );

//
// Exposed function prototypes
//

NTSTATUS
RegisterOpRegionHandler (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG AccessType,
    IN ULONG RegionSpace,
    IN PACPI_OP_REGION_HANDLER Handler,
    IN PVOID Context,
    IN ULONG Flags,
    IN OUT PVOID *OperationRegionObject
    );

NTSTATUS
DeRegisterOpRegionHandler (
                           IN PDEVICE_OBJECT DeviceObject,
                           IN PVOID OperationRegionObject
                           );

//
// Exposed definitions
//

//
// Access types for OpRegions
//
#define ACPI_OPREGION_ACCESS_AS_RAW                         0x1
#define ACPI_OPREGION_ACCESS_AS_COOKED                      0x2

//
// Allowable region spaces
//
#define ACPI_OPREGION_REGION_SPACE_MEMORY                   0x0
#define ACPI_OPREGION_REGION_SPACE_IO                       0x1
#define ACPI_OPREGION_REGION_SPACE_PCI_CONFIG               0x2
#define ACPI_OPREGION_REGION_SPACE_EC                       0x3
#define ACPI_OPREGION_REGION_SPACE_SMB                      0x4
#define ACPI_OPREGION_REGION_SPACE_CMOS_CONFIG              0x5
#define ACPI_OPREGION_REGION_SPACE_PCIBARTARGET             0x6

//
// Operation to perform on region
//
#define ACPI_OPREGION_READ                                  0x0
#define ACPI_OPREGION_WRITE                                 0x1

//
// Flag definitions for op region registration
//

#define ACPI_OPREGION_ACCESS_AT_HIGH_LEVEL                  0x1 // Indicates the handler function can be called at HIGH_LEVEL IRQL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\riname.c ===
static PWSTR cszFirst = L"First";
static PWSTR cszLast  = L"Last";
static PWSTR cszUserName = L"Username";
static PWSTR cszMAC   = L"MAC";

static const int iFirst = (sizeof(L"First") / sizeof(WCHAR)) - 1;
static const int iLast  = (sizeof(L"Last" ) / sizeof(WCHAR)) - 1;
static const int iUserName = (sizeof(L"Username") / sizeof(WCHAR)) - 1;
static const int iMAC   = (sizeof(L"MAC"  ) / sizeof(WCHAR)) - 1;

#define STRING_MISSING(_x) (((_x) == NULL) || (*(_x) == 0))

DWORD
GenerateNameFromTemplate (
    IN PWSTR Template,
    IN PGENNAME_VARIABLES Variables,
    IN PWSTR Name,
    IN DWORD NameLength,
    OUT PWSTR *MissingVariable OPTIONAL,
    OUT BOOL *UsedCounter OPTIONAL,
    OUT DWORD *MaximumGeneratedNameLength OPTIONAL
    )
{
    DWORD error;
    DWORD maxLength;
    DWORD fieldLength;
    WCHAR localString[10];
    WCHAR localFormat[10];
    BOOL padding;
    PWSTR pTemplate;
    PWSTR pOutput;
    PWSTR pOutputEnd;
    PWSTR stringToAdd;
    PWSTR pString;
    BOOL usedUserName;

    pTemplate = Template;
    pOutput = Name;
    pOutputEnd = pOutput + NameLength - 1;

    error = GENNAME_NO_ERROR;
    maxLength = 0;
    usedUserName = FALSE;
    if ( UsedCounter != NULL ) {
        *UsedCounter = FALSE;
    }

    while ( *pTemplate != 0 ) {

        if ( *pTemplate == L'%' ) {

            pTemplate++;
            fieldLength = 0;
            padding = FALSE;
            if ( *pTemplate >= L'0' && *pTemplate <= L'9' ) {
                if (*pTemplate == L'0') {
                    padding = TRUE;
                    //
                    // see if this request to do padding is from the "sample"
                    // entrypoint.  If we're doing padding, we want to make
                    // the sample output show that we will actually do some
                    // padding, so we make our counter small enough to show
                    // the padding.
                    //
                    if (Variables->Counter == 123456789 && 
                        Variables->AllowCounterTruncation &&
                        (0 == wcscmp(Variables->UserName, L"JOHNSMI")) &&
                        (0 == wcscmp(Variables->MacAddress, L"123456789012"))) {
                        Variables->Counter = 1;
                    }
                }
                do {
                    fieldLength = (fieldLength * 10) + (*pTemplate - L'0');
                    pTemplate++;
                } while ( *pTemplate >= L'0' && *pTemplate <= L'9' );
            }

            if ( *pTemplate == L'#' ) {

                DWORD maxCounter;
                DWORD counter;
                DWORD i;

                if (fieldLength > 9) {
                    fieldLength = 9;
                }
                if (fieldLength == 0) {
                    fieldLength = 2;
                }
                if(padding){
                    wsprintf(localFormat,L"%s%d%s", L"%0",fieldLength,L"d");
                } else {
                    wcscpy(localFormat,L"%d");
                }
                
                maxCounter = 10;
                for ( i = 1; i < fieldLength; i++ ) {
                    maxCounter *= 10;
                }

                counter = Variables->Counter;
                if ( counter >= maxCounter ) {
                    if ( !Variables->AllowCounterTruncation ) {
                        return GENNAME_COUNTER_TOO_HIGH;
                    }

                    //
                    // Truncate the counter on the right.
                    //

                    while ( counter > maxCounter ) {
                        counter /= 10;
                    }
                }

                if ( UsedCounter != NULL ) {
                    *UsedCounter = TRUE;
                }

                wsprintf( localString, localFormat, counter );
                stringToAdd = localString;

                pTemplate++;

            } else if ( StrCmpNI( pTemplate, cszFirst, iFirst ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->FirstName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_FIRSTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iFirst;
                
            } else if ( StrCmpNI( pTemplate, cszLast, iLast ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                stringToAdd = Variables->LastName;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( !usedUserName ) {
                        stringToAdd = Variables->UserName;
                        if ( STRING_MISSING(stringToAdd) ) {
                            if ( MissingVariable != NULL ) {
                                *MissingVariable = GENNAME_VARIABLE_LASTNAME;
                            }
                            return GENNAME_VARIABLE_MISSING;
                        }
                        usedUserName = TRUE;
                    }
                }

                pTemplate += iLast;

            } else if ( StrCmpNI( pTemplate, cszUserName, iUserName ) == 0 ) {

                if (fieldLength > DNS_MAX_LABEL_LENGTH) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }
                if (fieldLength == 0) {
                    fieldLength = DNS_MAX_LABEL_LENGTH;
                }

                if ( !usedUserName ) {
                    stringToAdd = Variables->UserName;
                    if ( STRING_MISSING(stringToAdd) ) {
                        if ( MissingVariable != NULL ) {
                            *MissingVariable = GENNAME_VARIABLE_USERNAME;
                        }
                        return GENNAME_VARIABLE_MISSING;
                    }
                    usedUserName = TRUE;
                }

                pTemplate += iUserName;

            } else if ( StrCmpNI( pTemplate, cszMAC, iMAC ) == 0 ) {

                if (fieldLength > 12) {
                    fieldLength = 12;
                }
                if (fieldLength == 0) {
                    fieldLength = 12;
                }

                stringToAdd = Variables->MacAddress;
                if ( STRING_MISSING(stringToAdd) ) {
                    if ( MissingVariable != NULL ) {
                        *MissingVariable = GENNAME_VARIABLE_MAC;
                    }
                    return GENNAME_VARIABLE_MISSING;
                }

                pTemplate += iMAC;
                
            } else {

                return GENNAME_TEMPLATE_INVALID;
            }

        } else {

            fieldLength = 1;

            localString[0] = *pTemplate;
            localString[1] = 0;
            stringToAdd = localString;

            pTemplate++;
        }

        maxLength += fieldLength;

        pString = stringToAdd;
        for ( pString = stringToAdd;
              (fieldLength > 0) && (*pString != 0);
              fieldLength--, pString++ ) {
            if ( pOutput < pOutputEnd ) {
                *pOutput++ = *pString;
            } else {
                error = GENNAME_NAME_TOO_LONG;
                break;
            }
        }
    }

    if ( MaximumGeneratedNameLength != NULL ) {
        *MaximumGeneratedNameLength = maxLength;
    }

    *pOutput++ = 0;
    
    return error;

} // GenerateNameFromTemplate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\seopaque.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    seopaque.h

Abstract:

    This module contains definitions of opaque Security data structures.

    These structures are available to user and kernel security routines
    only.

    This file is not included by including "ntos.h".

Author:

    Jim Kelly (Jimk) 23-Mar-1990

Revision History:

--*/

#ifndef _SEOPAQUE_
#define _SEOPAQUE_

///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Private Structures                                                   //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
// Generic ACE structures, to be used for casting ACE's of known types
//

typedef struct _KNOWN_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG SidStart;
} KNOWN_ACE, *PKNOWN_ACE;

typedef struct _KNOWN_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    ULONG Flags;
    // GUID ObjectType;             // Optionally present
    // GUID InheritedObjectType;    // Optionally present
    ULONG SidStart;
} KNOWN_OBJECT_ACE, *PKNOWN_OBJECT_ACE;

typedef struct _KNOWN_COMPOUND_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    USHORT CompoundAceType;
    USHORT Reserved;
    ULONG SidStart;
} KNOWN_COMPOUND_ACE, *PKNOWN_COMPOUND_ACE;

//typedef struct _KNOWN_IMPERSONATION_ACE {
//    ACE_HEADER Header;
//    ACCESS_MASK Mask;
//    USHORT DataType;
//    USHORT Argument;
//    ULONG Operands;
//} KNOWN_IMPERSONATION_ACE, *PKNOWN_IMPERSONATION_ACE;



///////////////////////////////////////////////////////////////////////////
//                                                                       //
//  Miscellaneous support macros                                         //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

//
//  Given a pointer return its word aligned equivalent value
//

#define WordAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 1) & -2)     \
    )

//
//  Given a pointer return its longword aligned equivalent value
//

#define LongAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 3) & -4)     \
    )

//
//  Given a size return its longword aligned equivalent value
//

#define LongAlignSize(Size) (((ULONG)(Size) + 3) & -4)

//
//  Given a size return its sizeof(PVOID) aligned equivalent value
//

#define PtrAlignSize(Size)  \
    (((ULONG)(Size) + sizeof(PVOID) - 1) & ~(sizeof(PVOID)-1))

//
//  Given a pointer return its quadword aligned equivalent value
//

#define QuadAlign(Ptr) (                       \
    (PVOID)((((ULONG_PTR)(Ptr)) + 7) & -8)     \
    )

//
//  This macro returns TRUE if a flag in a set of flags is on and FALSE
//  otherwise
//

#define FlagOn(Flags,SingleFlag) (               \
    ((Flags) & (SingleFlag)) != 0 ? TRUE : FALSE \
    )

//
//  This macro clears a single flag in a set of flags
//

#define ClearFlag(Flags,SingleFlag) { \
    (Flags) &= ~(SingleFlag);         \
    }

//
//  Get a pointer to the first ace in an acl
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Get a pointer to the following ace
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

//
// A "known" ACE is one of the types that existed before the introduction of
// compound ACEs.  While the name is no longer as accurate as it used to be,
// it's convenient.
//

#define IsKnownAceType(Ace) (                                     \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 3 ACE.
//

#define IsV3AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid version 4 ACE.
//

#define IsV4AceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE)        \
    )

//
// Test if the ACE is a valid ACE.
//

#define IsMSAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_ACE_TYPE) &&        \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_ACE_TYPE)           \
    )

//
//  Determine if an ace is a standard ace
//

#define IsCompoundAceType(Ace) (                                           \
    (((PACE_HEADER)(Ace))->AceType == ACCESS_ALLOWED_COMPOUND_ACE_TYPE))

//
// Test if the ACE is an object ACE.
//

#define IsObjectAceType(Ace) (                                              \
    (((PACE_HEADER)(Ace))->AceType >= ACCESS_MIN_MS_OBJECT_ACE_TYPE) && \
    (((PACE_HEADER)(Ace))->AceType <= ACCESS_MAX_MS_OBJECT_ACE_TYPE)    \
    )

//
// Update this macro as new ACL revisions are defined.
//

#define ValidAclRevision(Acl) ((Acl)->AclRevision >= MIN_ACL_REVISION && \
                               (Acl)->AclRevision <= MAX_ACL_REVISION )

//
//  Macro to determine if an ace is to be inherited by a subdirectory
//

#define ContainerInherit(Ace) (                      \
    FlagOn((Ace)->AceFlags, CONTAINER_INHERIT_ACE) \
    )

//
//  Macro to determine if an ace is to be proprogate to a subdirectory.
//  It will if it is inheritable by either a container or non-container
//  and is not explicitly marked for no-propagation.
//

#define Propagate(Ace) (                                              \
    !FlagOn((Ace)->AceFlags, NO_PROPAGATE_INHERIT_ACE)  &&            \
    (FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) ||                 \
     FlagOn(( Ace )->AceFlags, CONTAINER_INHERIT_ACE) )               \
    )

//
//  Macro to determine if an ACE is to be inherited by a sub-object
//

#define ObjectInherit(Ace) (                      \
    FlagOn(( Ace )->AceFlags, OBJECT_INHERIT_ACE) \
    )

//
// Macro to determine if an ACE was inherited.
//

#define AceInherited(Ace) (                      \
    FlagOn(( Ace )->AceFlags, INHERITED_ACE) \
    )

//
// Extract the SID from a object ACE
//
#define RtlObjectAceObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_OBJECT_TYPE_PRESENT) != 0 )
#define RtlObjectAceInheritedObjectTypePresent( Ace ) \
     ((((PKNOWN_OBJECT_ACE)(Ace))->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT) != 0 )

#define RtlObjectAceSid( Ace ) \
    ((PSID)(((PUCHAR)&(((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + \
     (RtlObjectAceObjectTypePresent(Ace) ? sizeof(GUID) : 0 ) + \
     (RtlObjectAceInheritedObjectTypePresent(Ace) ? sizeof(GUID) : 0 )))

#define RtlObjectAceObjectType( Ace ) \
     ((GUID *)(RtlObjectAceObjectTypePresent(Ace) ? \
        &((PKNOWN_OBJECT_ACE)(Ace))->SidStart : \
        NULL ))

#define RtlObjectAceInheritedObjectType( Ace ) \
     ((GUID *)(RtlObjectAceInheritedObjectTypePresent(Ace) ? \
        ( RtlObjectAceObjectTypePresent(Ace) ? \
            (PULONG)(((PUCHAR)(&((PKNOWN_OBJECT_ACE)(Ace))->SidStart)) + sizeof(GUID)) : \
            &((PKNOWN_OBJECT_ACE)(Ace))->SidStart ) : \
        NULL ))

//
// Comparison routine for two GUIDs.
//
#define RtlpIsEqualGuid(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

//
// Macros for mapping DACL/SACL specific security descriptor control bits
//  to generic control bits.
//
// This mapping allows common routines to manipulate control bits generically
//  and have the appropriate bits set in the security descriptor based
//  on whether to ACL is a DACL or a SACL.
//

#define SEP_ACL_PRESENT             SE_DACL_PRESENT
#define SEP_ACL_DEFAULTED           SE_DACL_DEFAULTED
#define SEP_ACL_AUTO_INHERITED      SE_DACL_AUTO_INHERITED
#define SEP_ACL_PROTECTED           SE_DACL_PROTECTED

#define SEP_ACL_ALL ( \
        SEP_ACL_PRESENT | \
        SEP_ACL_DEFAULTED | \
        SEP_ACL_AUTO_INHERITED | \
        SEP_ACL_PROTECTED )

#define SeControlDaclToGeneric( _Dacl ) \
    ((_Dacl) & SEP_ACL_ALL )

#define SeControlGenericToDacl( _Generic ) \
    ((_Generic) & SEP_ACL_ALL )

#define SeControlSaclToGeneric( _Sacl ) ( \
            (((_Sacl) & SE_SACL_PRESENT) ? SEP_ACL_PRESENT : 0 ) | \
            (((_Sacl) & SE_SACL_DEFAULTED) ? SEP_ACL_DEFAULTED : 0 ) | \
            (((_Sacl) & SE_SACL_AUTO_INHERITED) ? SEP_ACL_AUTO_INHERITED : 0 ) | \
            (((_Sacl) & SE_SACL_PROTECTED) ? SEP_ACL_PROTECTED : 0 ) )

#define SeControlGenericToSacl( _Generic ) ( \
            (((_Generic) & SEP_ACL_PRESENT) ? SE_SACL_PRESENT : 0 ) | \
            (((_Generic) & SEP_ACL_DEFAULTED) ? SE_SACL_DEFAULTED : 0 ) | \
            (((_Generic) & SEP_ACL_AUTO_INHERITED) ? SE_SACL_AUTO_INHERITED : 0 ) | \
            (((_Generic) & SEP_ACL_PROTECTED) ? SE_SACL_PROTECTED : 0 ) )




#endif // _SEOPAQUE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\wmiguid.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    wmiguid.h

Abstract:

    Defines GUIDs that represent data blocks that can be retrieved via WMI

--*/

#include <guiddef.h>

//
// This is WMI guid used to return disk performance information from
// diskperf.sys (see DISK_PERFORMANCE data structure)

DEFINE_GUID (DiskPerfGuid, 0xBDD865D1,0xD7C1,0x11d0,0xA5,0x01,0x00,0xA0,0xC9,0x06,0x29,0x10);

//
// This guid will return additional information about a data provider
// {5494DFDC-A98A-11d1-BF43-00A0C9062910}
#define DATA_PROVIDER_INFO_GUID \
   {0x5494dfdc, 0xa98a, 0x11d1, 0xbf, 0x43, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}


//
// This wmi guid is used to return the entire SMBIOS data table
// {8F680850-A584-11d1-BF38-00A0C9062910}
#define SMBIOS_DATA_GUID \
   {0x8f680850, 0xa584, 0x11d1, 0xbf, 0x38, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

//
// This wmi guid is used to return thermal information
// {A1BC18C0-A7C8-11d1-BF3C-00A0C9062910}
DEFINE_GUID(THERMAL_ZONE_GUID,  \
   0xa1bc18c0, 0xa7c8, 0x11d1, 0xbf, 0x3c, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This wmi guid is used to return additional information about the provider
// of an instance name. Note that only QuerySingleInstance is supported.
// {C7BF35D0-AADB-11d1-BF4A-00A0C9062910}
#define INSTANCE_INFO_GUID \
    {0xc7bf35d0, 0xaadb, 0x11d1, 0xbf, 0x4a, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10}

#define BINARY_MOF_GUID \
    {0x05901221, 0xD566, 0x11d1, 0xB2, 0xF0, 0x00, 0xA0, 0xC9, 0x06, 0x29, 0x10}

#define ENUMERATE_GUIDS_GUID \
    {0xe3dff7bd, 0x3915, 0x11d2, 0x91, 0x03, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2}

//
// Global WMI Logger GUID
//

DEFINE_GUID ( /* e8908abc-aa84-11d2-9a93-00805f85d7c6 */
    GlobalLoggerGuid,
    0xe8908abc,
    0xaa84,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

DEFINE_GUID ( /* 44608a51-1851-4456-98b2-b300e931ee41 */
    WmiEventLoggerGuid,
    0x44608a51,
    0x1851,
    0x4456,
    0x98, 0xb2, 0xb3, 0x00, 0xe9, 0x31, 0xee, 0x41
  );
DEFINE_GUID ( /* 8d40301f-ab4a-11d2-9a93-00805f85d7c6 */
    GenericMessageGuid,
    0x8d40301f,
    0xab4a,
    0x11d2,
    0x9a, 0x93, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );

//
// Event Trace GUIDs
//

DEFINE_GUID ( /* 3d6fa8d0-fe05-11d0-9dda-00c04fd7ba7c */
    ProcessGuid,
    0x3d6fa8d0,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d1-fe05-11d0-9dda-00c04fd7ba7c */
    ThreadGuid,
    0x3d6fa8d1,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d2-fe05-11d0-9dda-00c04fd7ba7c */ /* Not used */
    HardFaultGuid,
    0x3d6fa8d2,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d3-fe05-11d0-9dda-00c04fd7ba7c */
    PageFaultGuid,
    0x3d6fa8d3,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 3d6fa8d4-fe05-11d0-9dda-00c04fd7ba7c */
    DiskIoGuid,
    0x3d6fa8d4,
    0xfe05,
    0x11d0,
    0x9d, 0xda, 0x00, 0xc0, 0x4f, 0xd7, 0xba, 0x7c
  );
DEFINE_GUID ( /* 90cbdc39-4a3e-11d1-84f4-0000f80464e3 */
    FileIoGuid,
    0x90cbdc39,
    0x4a3e,
    0x11d1,
    0x84, 0xf4, 0x00, 0x00, 0xf8, 0x04, 0x64, 0xe3
  );
DEFINE_GUID ( /* 9a280ac0-c8e0-11d1-84e2-00c04fb998a2 */
    TcpIpGuid,
    0x9a280ac0,
    0xc8e0,
    0x11d1,
    0x84, 0xe2, 0x00, 0xc0, 0x4f, 0xb9, 0x98, 0xa2
  );
DEFINE_GUID ( /* bf3a50c5-a9c9-4988-a005-2df0b7c80f80 */
    UdpIpGuid,
    0xbf3a50c5,
    0xa9c9,
    0x4988,
    0xa0, 0x05, 0x2d, 0xf0, 0xb7, 0xc8, 0x0f, 0x80
  );

DEFINE_GUID ( /* 2cb15d1d-5fc1-11d2-abe1-00a0c911f518 */
    ImageLoadGuid,
    0x2cb15d1d,
    0x5fc1,
    0x11d2,
    0xab, 0xe1, 0x00, 0xa0, 0xc9, 0x11, 0xf5, 0x18
  );

DEFINE_GUID ( /* AE53722E-C863-11d2-8659-00C04FA321A1 */
    RegistryGuid, 
    0xae53722e,
    0xc863,
    0x11d2,
    0x86, 0x59, 0x0, 0xc0, 0x4f, 0xa3, 0x21, 0xa1
);

DEFINE_GUID( /* 13976D09-A327-438c-950B-7F03192815C7  */
    DbgPrintGuid,
    0x13976d09,
    0xa327,
    0x438c,
    0x95, 0xb, 0x7f, 0x3, 0x19, 0x28, 0x15, 0xc7
    );


//
// Special WMI events
//
DEFINE_GUID ( /* 398191dc-2da7-11d3-8b98-00805f85d7c6 */
    TraceErrorGuid,
    0x398191dc,
    0x2da7,
    0x11d3,
    0x8b, 0x98, 0x00, 0x80, 0x5f, 0x85, 0xd7, 0xc6
  );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\wmistr.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Wmistr.h

Abstract:

    WMI structure definitions

--*/

#ifndef _WMISTR_
#define _WMISTR_

#pragma warning(disable: 4200) // nonstandard extension used : zero-sized array in struct/union
#pragma warning(disable: 4201) // nonstandard extension used : nameless struct/union

//
// WNODE definition
typedef struct _WNODE_HEADER
{
    ULONG BufferSize;        // Size of entire buffer inclusive of this ULONG
    ULONG ProviderId;    // Provider Id of driver returning this buffer
    union
    {
        ULONG64 HistoricalContext;  // Logger use
    	struct
	    {
            ULONG Version;           // Reserved
            ULONG Linkage;           // Linkage field reserved for WMI
    	};
    };

    union
    {
        ULONG CountLost;         // Reserved
        HANDLE KernelHandle;     // Kernel handle for data block
        LARGE_INTEGER TimeStamp; // Timestamp as returned in units of 100ns
                                 // since 1/1/1601
    };
    GUID Guid;                  // Guid for data block returned with results
    ULONG ClientContext;
    ULONG Flags;             // Flags, see below
} WNODE_HEADER, *PWNODE_HEADER;

//
// WNODE_HEADER flags are defined as follows
#define WNODE_FLAG_ALL_DATA        0x00000001 // set for WNODE_ALL_DATA
#define WNODE_FLAG_SINGLE_INSTANCE 0x00000002 // set for WNODE_SINGLE_INSTANCE
#define WNODE_FLAG_SINGLE_ITEM     0x00000004 // set for WNODE_SINGLE_ITEM
#define WNODE_FLAG_EVENT_ITEM      0x00000008 // set for WNODE_EVENT_ITEM

                                              // Set if data block size is
                                              // identical for all instances
                                              // (used with  WNODE_ALL_DATA
                                              // only)
#define WNODE_FLAG_FIXED_INSTANCE_SIZE 0x00000010

#define WNODE_FLAG_TOO_SMALL           0x00000020 // set for WNODE_TOO_SMALL

                                 // Set when a data provider returns a
                                 // WNODE_ALL_DATA in which the number of
                                 // instances and their names returned
                                 // are identical to those returned from the
                                 // previous WNODE_ALL_DATA query. Only data
                                 // blocks registered with dynamic instance
                                 // names should use this flag.
#define WNODE_FLAG_INSTANCES_SAME  0x00000040

                                 // Instance names are not specified in
                                 // WNODE_ALL_DATA; values specified at
                                 // registration are used instead. Always
                                 // set for guids registered with static
                                 // instance names
#define WNODE_FLAG_STATIC_INSTANCE_NAMES 0x00000080

#define WNODE_FLAG_INTERNAL      0x00000100  // Used internally by WMI

                                 // timestamp should not be modified by
                                 // a historical logger
#define WNODE_FLAG_USE_TIMESTAMP 0x00000200
#define WNODE_FLAG_PERSIST_EVENT 0x00000400

#define WNODE_FLAG_EVENT_REFERENCE 0x00002000

// Set if Instance names are ansi. Only set when returning from
// WMIQuerySingleInstanceA and WMIQueryAllDataA
#define WNODE_FLAG_ANSI_INSTANCENAMES 0x00004000

// Set if WNODE is a method call
#define WNODE_FLAG_METHOD_ITEM     0x00008000

// Set if instance names originated from a PDO
#define WNODE_FLAG_PDO_INSTANCE_NAMES  0x00010000

// The second byte, except the first bit is used exclusively for tracing
#define WNODE_FLAG_TRACED_GUID   0x00020000 // denotes a trace

#define WNODE_FLAG_LOG_WNODE     0x00040000 // request to log Wnode

#define WNODE_FLAG_USE_GUID_PTR  0x00080000 // Guid is actually a pointer

#define WNODE_FLAG_USE_MOF_PTR   0x00100000 // MOF data are dereferenced

#define WNODE_FLAG_NO_HEADER     0x00200000 // Trace without header

// Set for events that are WNODE_EVENT_REFERENCE
// Mask for event severity level. Level 0xff is the most severe type of event
#define WNODE_FLAG_SEVERITY_MASK 0xff000000

//
// This structure is used within the WNODE_ALL_DATA when the data blocks
// for the different instances are different lengths. If the data blocks
// for the different instances are identical lengths then
// WNODE_FLAG_FIXED_INSTANCE_SIZE should be set and FixedInstanceSize
// set to the common data block size.
typedef struct
{
    ULONG OffsetInstanceData;   // Offset from beginning of WNODE_ALL_DATA
                                // to Data block for instance
    ULONG LengthInstanceData;   // Length of data block for instance
} OFFSETINSTANCEDATAANDLENGTH, *POFFSETINSTANCEDATAANDLENGTH;

typedef struct tagWNODE_ALL_DATA
{
    struct _WNODE_HEADER WnodeHeader;

    ULONG DataBlockOffset;// Offset from begin of WNODE to first data block

    ULONG InstanceCount;  // Count of instances whose data follows.

                      // Offset to an array of offsets to the instance names
    ULONG OffsetInstanceNameOffsets;

    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is set in Flags then
    // FixedInstanceSize specifies the size of each data block. In this case
    // there is one ULONG followed by the data blocks.
    // If WNODE_FLAG_FIXED_INSTANCE_SIZE is not set
    // then OffsetInstanceDataAndLength
    // is an array of OFFSETINSTANCEDATAANDLENGTH that specifies the
    // offsets and lengths of the data blocks for each instance.
    union
    {
        ULONG FixedInstanceSize;
    	OFFSETINSTANCEDATAANDLENGTH OffsetInstanceDataAndLength[];
                                    /* [InstanceCount] */
    };

    // padding so that first data block begins on a 8 byte boundry

    // data blocks and instance names for all instances

} WNODE_ALL_DATA, *PWNODE_ALL_DATA;


typedef struct tagWNODE_SINGLE_INSTANCE
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Use when
                            // WNODE_FLAG_STATIC_INSTANCE_NAMES is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is set
    ULONG InstanceIndex;    // (Static Instance Names)

    ULONG DataBlockOffset;  // offset from beginning of WNODE to data block
    ULONG SizeDataBlock;    // Size of data block for instance

    UCHAR VariableData[];
    // instance names and padding so data block begins on 8 byte boundry

    // data block
} WNODE_SINGLE_INSTANCE, *PWNODE_SINGLE_INSTANCE;


typedef struct tagWNODE_SINGLE_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_SINGLE_INSTANCE
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG ItemId;           // Item Id for data item being set

    ULONG DataBlockOffset;  // offset from WNODE begin to data item value
    ULONG SizeDataItem;     // Size of data item

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_SINGLE_ITEM, *PWNODE_SINGLE_ITEM;

typedef struct tagWNODE_METHOD_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

                            // Offset from beginning of WNODE_METHOD_ITEM
                            // to instance name. Examine when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME is reset
                            // (Dynamic instance names)
    ULONG OffsetInstanceName;

                            // Instance index when
                            // WNODE_FLAG_STATIC_INSTANCE_NAME
    ULONG InstanceIndex;    //  set (Static Instance Names)

    ULONG MethodId;         // Method id of method being called

    ULONG DataBlockOffset;  // On Entry: offset from WNODE to input data
                            // On Return: offset from WNODE to input and
                            //            output data blocks
    ULONG SizeDataBlock;    // On Entry: Size of input data, 0 if no input
                            //           data
                            // On Return: Size of output data, 0 if no output
                            //            data

    UCHAR VariableData[];
    // instance names and padding so data value begins on 8 byte boundry

    // data item value
} WNODE_METHOD_ITEM, *PWNODE_METHOD_ITEM;

typedef struct tagWNODE_EVENT_ITEM
{
    struct _WNODE_HEADER WnodeHeader;

    // Different data could be here depending upon the flags set in the
    // WNODE_HEADER above. If the WNODE_FLAG_ALL_DATA flag is set then the
    // contents of a WNODE_ALL_DATA  (excluding WNODE_HEADER) is here. If the
    // WNODE_FLAG_SINGLE_INSTANCE flag is set then a WNODE_SINGLE_INSTANCE
    // (excluding WNODE_HEADER) is here. Lastly if the  WNODE_FLAG_SINGLE_ITEM
    // flag is set then a WNODE_SINGLE_ITEM (excluding WNODE_HEADER) is here.
} WNODE_EVENT_ITEM, *PWNODE_EVENT_ITEM;


//
// If a KM data provider needs to fire an event that is larger than the
// maximum size that WMI allows then it should fire a WNODE_EVENT_REFERENCE
// that specifies which guid and instance name to query for the actual data
// that should be part of the event.
typedef struct tagWNODE_EVENT_REFERENCE
{
    struct _WNODE_HEADER WnodeHeader;
    GUID TargetGuid;
    ULONG TargetDataBlockSize;
    union
    {
        ULONG TargetInstanceIndex;
        WCHAR TargetInstanceName[];
    };
} WNODE_EVENT_REFERENCE, *PWNODE_EVENT_REFERENCE;


typedef struct tagWNODE_TOO_SMALL
{
    struct _WNODE_HEADER WnodeHeader;
    ULONG SizeNeeded;                   // Size needed to build WNODE result
} WNODE_TOO_SMALL, *PWNODE_TOO_SMALL;


typedef struct
{
    GUID Guid;             // Guid of data block being registered or updated
    ULONG Flags;         // Flags

    ULONG InstanceCount; // Count of static instances names for the guid

    union
    {
                     // If WMIREG_FLAG_INSTANCE_LIST then this has the offset
                     // to a list of InstanceCount counted UNICODE
                     // strings placed end to end.
        ULONG InstanceNameList;
			
                     // If WMIREG_FLAG_INSTANCE_BASENAME then this has the
                     // offset to a single counted UNICODE string that
                     // has the basename for the instance names.
			
        ULONG BaseNameOffset;
			
                     // If WMIREG_FLAG_INSTANCE_PDO is set then InstanceInfo
                     // has the PDO whose device instance path will
                     // become the instance name
        ULONG_PTR Pdo;
			
                     // If WMIREG_FLAG_INSTANCE_REFERENCE then this points to
                     // a WMIREGINSTANCEREF structure.
			
        ULONG_PTR InstanceInfo;// Offset from beginning of the WMIREGINFO structure to
    };

} WMIREGGUIDW, *PWMIREGGUIDW;

typedef WMIREGGUIDW WMIREGGUID;
typedef PWMIREGGUIDW PWMIREGGUID;

// Set if collection must be enabled for the guid before the data provider
// can be queried for data.
#define WMIREG_FLAG_EXPENSIVE          0x00000001

// Set if instance names for this guid are specified in a static list within
// the WMIREGINFO
#define WMIREG_FLAG_INSTANCE_LIST      0x00000004

// Set if instance names are to be static and generated by WMI using a
// base name in the WMIREGINFO and an index
#define WMIREG_FLAG_INSTANCE_BASENAME  0x00000008

// Set if WMI should do automatic mapping of a PDO to device instance name
// as the instance name for the guid. This flag should only be used by
// kernel mode data providers.
#define WMIREG_FLAG_INSTANCE_PDO       0x00000020

// Note the flags WMIREG_FLAG_INSTANCE_LIST, WMIREG_FLAG_INSTANCE_BASENAME,
// WMIREG_FLAG_INSTANCE_REFERENCE and WMIREG_FLAG_INSTANCE_PDO are mutually
// exclusive.

//
// These flags are only valid in a response to WMI_GUID_REGUPDATE
#define WMIREG_FLAG_REMOVE_GUID       0x00010000 // Remove support for  guid
#define WMIREG_FLAG_RESERVED1         0x00020000 // Reserved by WMI
#define WMIREG_FLAG_RESERVED2         0x00040000 // Reserved by WMI

// Set if guid is one that is written to trace log.
// This guid cannot be queried directly via WMI, but must be read using
// logger apis.
#define WMIREG_FLAG_TRACED_GUID        0x00080000

//
// Only those Trace Guids that have this bit set can receive
// Enable/Disable Notifications.
//
#define WMIREG_FLAG_TRACE_CONTROL_GUID 0x00001000

//
// Set if the guid is only used for firing events. Guids that can be queried
// and that fire events should not have this bit set.
#define WMIREG_FLAG_EVENT_ONLY_GUID    0x00000040

typedef struct
{
// Size of entire WMIREGINFO structure including this ULONG 	
// and any static instance names that follow
    ULONG BufferSize;

    ULONG NextWmiRegInfo;         // Offset to next WMIREGINFO structure

    ULONG RegistryPath; // Offset from beginning of WMIREGINFO structure to a
                        // counted Unicode string containing
                        // the driver registry path (under HKLM\CCS\Services)
                        // This must be filled only by kernel mode data
						// providers
							
// Offset from beginning of WMIREGINFO structure to a
// counted Unicode string containing
// the name of resource in driver file containing MOF info
    ULONG MofResourceName;

// Count of WMIREGGUID structures immediately following
    ULONG GuidCount;
    WMIREGGUIDW WmiRegGuid[];  // array of GuidCount WMIREGGUID structures
    // Variable length data including :
    //     Instance Names
} WMIREGINFOW, *PWMIREGINFOW;

typedef WMIREGINFOW WMIREGINFO;
typedef PWMIREGINFOW PWMIREGINFO;

//
// WMI request codes
typedef enum
{
#ifndef _WMIKM_
    WMI_GET_ALL_DATA = 0,
    WMI_GET_SINGLE_INSTANCE = 1,
    WMI_SET_SINGLE_INSTANCE = 2,
    WMI_SET_SINGLE_ITEM = 3,
    WMI_ENABLE_EVENTS = 4,
    WMI_DISABLE_EVENTS  = 5,
    WMI_ENABLE_COLLECTION = 6,
    WMI_DISABLE_COLLECTION = 7,
    WMI_REGINFO = 8,
    WMI_EXECUTE_METHOD = 9
#endif
} WMIDPREQUESTCODE;

#if defined(_WINNT_) || defined(WINNT)
//
// WMI guid objects have the following rights
// WMIGUID_QUERY
// WMIGUID_SET
// WMIGUID_NOTIFICATION
// WMIGUID_READ_DESCRIPTION
// WMIGUID_EXECUTE
// TRACELOG_CREATE_REALTIME
// TRACELOG_CREATE_ONDISK
// TRACELOG_GUID_ENABLE
// TRACELOG_ACCESS_KERNEL_LOGGER
// TRACELOG_CREATE_INPROC
// TRACELOG_ACCESS_REALTIME

//
// GuidTypes 
//
//#ifndef _WMIKM_
#define WMI_GUIDTYPE_TRACECONTROL 0
#define WMI_GUIDTYPE_TRACE        1
#define WMI_GUIDTYPE_DATA         2
#define WMI_GUIDTYPE_EVENT        3
//#endif

//
// Specific rights for WMI guid objects. These are available from 0x0001 to
// 0xffff (ie up to 16 rights)
//
#define WMIGUID_QUERY                 0x0001
#define WMIGUID_SET                   0x0002
#define WMIGUID_NOTIFICATION          0x0004
#define WMIGUID_READ_DESCRIPTION      0x0008
#define WMIGUID_EXECUTE               0x0010
#define TRACELOG_CREATE_REALTIME      0x0020
#define TRACELOG_CREATE_ONDISK        0x0040
#define TRACELOG_GUID_ENABLE          0x0080
#define TRACELOG_ACCESS_KERNEL_LOGGER 0x0100
#define TRACELOG_CREATE_INPROC        0x0200
#define TRACELOG_ACCESS_REALTIME      0x0400
#define TRACELOG_REGISTER_GUIDS       0x0800

#define WMIGUID_ALL_ACCESS (STANDARD_RIGHTS_READ |     \
                            SYNCHRONIZE | \
                            WMIGUID_QUERY |                \
                            WMIGUID_SET |                  \
                            WMIGUID_NOTIFICATION |         \
                            WMIGUID_READ_DESCRIPTION |     \
                            WMIGUID_EXECUTE |              \
                            TRACELOG_CREATE_REALTIME |     \
                            TRACELOG_CREATE_ONDISK |       \
                            TRACELOG_GUID_ENABLE |         \
                            TRACELOG_ACCESS_KERNEL_LOGGER |\
                            TRACELOG_CREATE_INPROC | \
                            TRACELOG_ACCESS_REALTIME | \
                            TRACELOG_REGISTER_GUIDS  )

#define WMI_GLOBAL_LOGGER_ID          0x0001
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\wmium.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    Wmium.h

Abstract:

    Public headers for WMI data consumers and providers

Author:

    16-Jan-1997 AlanWar

Revision History:

--*/

#ifndef _WMIUM_
#define _WMIUM_

#ifndef MIDL_PASS
#ifdef _WMI_SOURCE_
#define WMIAPI __stdcall
#else
#define WMIAPI DECLSPEC_IMPORT __stdcall
#endif
#endif

#include <guiddef.h>

#include <basetsd.h>
#include <wmistr.h>
#include <evntrace.h>

typedef PVOID WMIHANDLE, *PWMIHANDLE, MOFHANDLE, *PMOFHANDLE;


//
// When set the guid can be opened and accessed
#define MOFCI_RESERVED0  0x00000001

#define MOFCI_RESERVED1  0x00000002
#define MOFCI_RESERVED2  0x00000004

typedef struct
{
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ImagePath;        // Path to image containing MOF resource
#ifdef MIDL_PASS
    [string] PDFTCHAR
#else
    LPWSTR
#endif
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
#ifdef MIDL_PASS
    [size_is(0)] PDFBYTE
#else
    PUCHAR
#endif
             ResourceBuffer;    // Reserved
} MOFRESOURCEINFOW, *PMOFRESOURCEINFOW;


typedef struct
{
    LPSTR
             ImagePath;        // Path to image containing MOF resource
    LPSTR
             ResourceName;     // Name of resource in image
    ULONG    ResourceSize;     // Number of bytes in resource
    UCHAR
             *ResourceBuffer;   // Reserved
} MOFRESOURCEINFOA, *PMOFRESOURCEINFOA;

#ifdef UNICODE
typedef MOFRESOURCEINFOW MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOW PMOFRESOURCEINFO;
#else
typedef MOFRESOURCEINFOA MOFRESOURCEINFO;
typedef PMOFRESOURCEINFOA PMOFRESOURCEINFO;
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data consumer apis
ULONG
WMIAPI
WmiOpenBlock(
    IN GUID *Guid,
    IN ULONG DesiredAccess,
    OUT WMIHANDLE *DataBlockHandle
);

ULONG
WMIAPI
WmiCloseBlock(
    IN WMIHANDLE DataBlockHandle
);

ULONG
WMIAPI
WmiQueryAllDataA(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );


ULONG
WMIAPI
WmiQueryAllDataW(
    IN WMIHANDLE DataBlockHandle,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define WmiQueryAllData WmiQueryAllDataW
#else
#define WmiQueryAllData WmiQueryAllDataA
#endif


ULONG
WMIAPI
WmiQueryAllDataMultipleA(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQueryAllDataMultipleW(
    IN WMIHANDLE *HandleList,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);
#ifdef UNICODE
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleW
#else
#define WmiQueryAllDataMultiple WmiQueryAllDataMultipleA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );

ULONG
WMIAPI
WmiQuerySingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN OUT ULONG *BufferSize,
    OUT PVOID Buffer
    );
#ifdef UNICODE
#define WmiQuerySingleInstance WmiQuerySingleInstanceW
#else
#define WmiQuerySingleInstance WmiQuerySingleInstanceA
#endif


ULONG
WMIAPI
WmiQuerySingleInstanceMultipleW(
    IN WMIHANDLE *HandleList,
    IN LPCWSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

ULONG
WMIAPI
WmiQuerySingleInstanceMultipleA(
    IN WMIHANDLE *HandleList,
    IN LPCSTR *InstanceNames,
    IN ULONG HandleCount,
    IN OUT ULONG *InOutBufferSize,
    OUT LPVOID OutBuffer
);

#ifdef UNICODE
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleW
#else
#define WmiQuerySingleInstanceMultiple WmiQuerySingleInstanceMultipleA
#endif

ULONG
WMIAPI
WmiSetSingleInstanceA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleInstanceW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleInstance WmiSetSingleInstanceW
#else
#define WmiSetSingleInstance WmiSetSingleInstanceA
#endif

ULONG
WMIAPI
WmiSetSingleItemA(
    IN WMIHANDLE DataBlockHandle,
    IN LPCSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );

ULONG
WMIAPI
WmiSetSingleItemW(
    IN WMIHANDLE DataBlockHandle,
    IN LPCWSTR InstanceName,
    IN ULONG DataItemId,
    IN ULONG Reserved,
    IN ULONG ValueBufferSize,
    IN PVOID ValueBuffer
    );
#ifdef UNICODE
#define WmiSetSingleItem WmiSetSingleItemW
#else
#define WmiSetSingleItem WmiSetSingleItemA
#endif

ULONG
WMIAPI
WmiExecuteMethodA(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

ULONG
WMIAPI
WmiExecuteMethodW(
    IN WMIHANDLE MethodDataBlockHandle,
    IN LPCWSTR MethodInstanceName,
    IN ULONG MethodId,
    IN ULONG InputValueBufferSize,
    IN PVOID InputValueBuffer,
    IN OUT ULONG *OutputBufferSize,
    OUT PVOID OutputBuffer
    );

#ifdef UNICODE
#define WmiExecuteMethod WmiExecuteMethodW
#else
#define WmiExecuteMethod WmiExecuteMethodA
#endif

// Set this Flag when calling NotficationRegistration to enable or
// disable a trace logging guid
#define NOTIFICATION_TRACE_FLAG       0x00010000

// Set this flag when enabling a notification that should be delivered via
// a direct callback. Any notifications received will be given their own
// thread and the callback function called immediately.
#define NOTIFICATION_CALLBACK_DIRECT  0x00000004

//
// Set this flag (and only this flag) when you want to only check if the 
// caller has permission to receive events for the guid
//
#define NOTIFICATION_CHECK_ACCESS 0x00000008

//
// Event notification callback function prototype
typedef void (
#ifndef MIDL_PASS
WINAPI
#endif
*NOTIFICATIONCALLBACK)(
    PWNODE_HEADER Wnode,
    UINT_PTR NotificationContext
    );

#ifndef MIDL_PASS
//
// This guid is for notifications of changes to registration
// {B48D49A1-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_REGISTRATION_CHANGE_NOTIFICATION,
0xb48d49a1, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A2-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_ADDED_NOTIFICATION,
0xb48d49a2, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);

//
// This guid id for notifications of new mof resources being added
// {B48D49A3-E777-11d0-A50C-00A0C9062910}
DEFINE_GUID(GUID_MOF_RESOURCE_REMOVED_NOTIFICATION,
0xb48d49a3, 0xe777, 0x11d0, 0xa5, 0xc, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10);
#endif

ULONG
WMIAPI
WmiNotificationRegistrationA(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );

ULONG
WMIAPI
WmiNotificationRegistrationW(
    IN LPGUID Guid,
    IN BOOLEAN Enable,
    IN PVOID DeliveryInfo,
    IN ULONG_PTR DeliveryContext,
    IN ULONG Flags
    );
#ifdef UNICODE
#define WmiNotificationRegistration WmiNotificationRegistrationW
#else
#define WmiNotificationRegistration WmiNotificationRegistrationA
#endif

void
WMIAPI
WmiFreeBuffer(
    IN PVOID Buffer
    );


ULONG
WMIAPI
WmiEnumerateGuids(
    OUT LPGUID GuidList,
    IN OUT ULONG *GuidCount
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesW(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOW *MofResourceInfo
    );

ULONG
WMIAPI
WmiMofEnumerateResourcesA(
    IN MOFHANDLE MofResourceHandle,
    OUT ULONG *MofResourceCount,
    OUT PMOFRESOURCEINFOA *MofResourceInfo
    );
#ifdef UNICODE
#define WmiMofEnumerateResources WmiMofEnumerateResourcesW
#else
#define WmiMofEnumerateResources WmiMofEnumerateResourcesA
#endif

ULONG
WMIAPI
WmiFileHandleToInstanceNameA(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT CHAR *InstanceNames
    );

ULONG
WMIAPI
WmiFileHandleToInstanceNameW(
    IN WMIHANDLE DataBlockHandle,
    IN HANDLE FileHandle,
    IN OUT ULONG *NumberCharacters,
    OUT WCHAR *InstanceNames
    );
#ifdef UNICODE
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameW
#else
#define WmiFileHandleToInstanceName WmiFileHandleToInstanceNameA
#endif

#define WmiInsertTimestamp(WnodeHeader) \
    GetSystemTimeAsFileTime((FILETIME *)&((PWNODE_HEADER)WnodeHeader)->TimeStamp)

ULONG
WMIAPI
WmiDevInstToInstanceNameA(
    OUT CHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN CHAR *DevInst,
    IN ULONG InstanceIndex
    );

ULONG
WMIAPI
WmiDevInstToInstanceNameW(
    OUT WCHAR *InstanceName,
    IN ULONG InstanceNameLength,
    IN WCHAR *DevInst,
    IN ULONG InstanceIndex
    );
#ifdef UNICODE
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameW
#else
#define WmiDevInstToInstanceName WmiDevInstToInstanceNameA
#endif

typedef struct _WMIGUIDINFORMATION
{
    ULONG Size;
    BOOLEAN IsExpensive;
    BOOLEAN IsEventOnly;
} WMIGUIDINFORMATION, *PWMIGUIDINFORMATION;


ULONG
WMIAPI
WmiQueryGuidInformation(
    IN WMIHANDLE GuidHandle,
    OUT PWMIGUIDINFORMATION GuidInfo
    );


ULONG
WMIAPI
WmiReceiveNotificationsW(
    IN ULONG HandleCount,
        IN HANDLE *HandleList,
        IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

ULONG
WMIAPI
WmiReceiveNotificationsA(
    IN ULONG HandleCount,
        IN HANDLE *HandleList,
        IN NOTIFICATIONCALLBACK Callback,
    IN ULONG_PTR DeliveryContext
);

#ifdef UNICODE
#define WmiReceiveNotifications WmiReceiveNotificationsW
#else
#define WmiReceiveNotifications WmiReceiveNotificationsA
#endif


//
// Internal Flags for different processing modes.
// Applies to the TRACE_LOGFILE_HEADER ReservedFlags field.
//

#define EVENT_TRACE_USE_RAWTIMESTAMP 0x00000002    // Used with OpenTrace(), prevents
                                                   // conversion of TimeStamps to UTC
#define EVENT_TRACE_GET_RAWEVENT     0x00000100    // Used with OpenTrace(), retrieves 
                                                   // event from file as is.

//
// Low level trace consumer routines
//

typedef enum tagWMI_HEADER_TYPE {
    WMIHT_NONE,
    WMIHT_UNKNOWN,
    WMIHT_SYSTEM32,
    WMIHT_SYSTEM64,
    WMIHT_EVENT_TRACE,
    WMIHT_EVENT_INSTANCE,
    WMIHT_TIMED,
    WMIHT_ULONG32,
    WMIHT_WNODE,
    WMIHT_MESSAGE,
    WMIHT_PERFINFO32,
    WMIHT_PERFINFO64
} WMI_HEADER_TYPE;

typedef enum tagWMI_BUFFER_SOURCE {
    WMIBS_FLUSH_LIST,
    WMIBS_FREE_LIST,
    WMIBS_TRANSITION_LIST,
    WMIBS_CURRENT_LIST,
    WMIBS_LOG_FILE
} WMI_BUFFER_SOURCE;

typedef struct {
    WMI_BUFFER_SOURCE BufferSource;
    ULONG BufferSize;   // Size of the Buffer
    ULONG ProcessorNumber;      
    ULONG Alignment;    // Alignment
    PVOID Buffer;       // Pointer to the raw buffer
} WMIBUFFERINFO, *PWMIBUFFERINFO;

//
// Get buffer offset to first event only. Returns Size. 
// Fix up the Buffer for proper termination and alignment. 
//

ULONG
WMIAPI
WmiGetFirstTraceOffset(
    IN PWMIBUFFERINFO BufferInfo
    );

//
// Get the next event, size and type. Caller must advance offset with Size
// 

WMI_HEADER_TYPE
WMIAPI
WmiGetTraceHeader(
    IN  PVOID  Buffer,
    IN  ULONG  Offset,
    OUT ULONG  *Size
    );

//
// Returns a EVENT_TRACE / (new Structure Ian will define) 
// in the Buffer provided

ULONG 
WMIAPI
WmiParseTraceEvent(
    IN PVOID Buffer,
    IN ULONG Offset,
    IN WMI_HEADER_TYPE HeaderType,
    IN OUT PVOID EventInfo,
    IN ULONG EventInfoSize
    );

//
//  Structures and routines to process trace
//  with cursor.
//
typedef struct _WMI_BUFFER_CURSOR {
    PVOID          BufferHeader;
    LARGE_INTEGER  CurrentBufferOffset;
    ULONG          CurrentEventOffset;
    EVENT_TRACE    CurrentEvent;
    BOOLEAN        NoMoreEvents;
} WMI_BUFFER_CURSOR, *PWMI_BUFFER_CURSOR;

#define WMI_MERGE_ETL_CURSOR_VERSION      1

typedef struct _WMI_MERGE_ETL_CURSOR {
    ULONG                CursorVersion;
    HANDLE               TraceMappingHandle;
    PVOID                Base;
    ULONG                CurrentCpu;
    WMI_BUFFER_CURSOR    BufferCursor[MAXIMUM_PROCESSORS];
    EVENT_TRACE_LOGFILEW Logfile;
} WMI_MERGE_ETL_CURSOR, *PWMI_MERGE_ETL_CURSOR;

ULONG
WMIAPI
WmiOpenTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

ULONG
WMIAPI
WmiCloseTraceWithCursor(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

VOID
WMIAPI 
WmiConvertTimestamp(
    OUT PLARGE_INTEGER DestTime,
    IN PLARGE_INTEGER  SrcTime,
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );
    

ULONG
WMIAPI
WmiGetNextEvent(
    IN PWMI_MERGE_ETL_CURSOR LogCursor
    );

#ifdef __cplusplus
}
#endif

#endif  // _WMIUM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\qfe\resourcedll\sp1\makefile.inc ===
sp1res.h sp1res.rc: sp1res.mc
    mc -v sp1res.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\smbus.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    smbus.h

Abstract:

    SMBus Class Driver Header File

Author:

    Ken Reneris

Environment:

Notes:


Revision History:

--*/

//
// SMB Request packet
//

#define SMB_MAX_DATA_SIZE   32

typedef struct {
    UCHAR       Status;             // Completion status
    UCHAR       Protocol;
    UCHAR       Address;
    UCHAR       Command;
    UCHAR       BlockLength;
    UCHAR       Data[SMB_MAX_DATA_SIZE];
} SMB_REQUEST, *PSMB_REQUEST;

//
// Protocol values
//

#define SMB_WRITE_QUICK                 0x00    // Issue quick command data bit = 0
#define SMB_READ_QUICK                  0x01    // Issue quick command data bit = 1
#define SMB_SEND_BYTE                   0x02
#define SMB_RECEIVE_BYTE                0x03
#define SMB_WRITE_BYTE                  0x04
#define SMB_READ_BYTE                   0x05
#define SMB_WRITE_WORD                  0x06
#define SMB_READ_WORD                   0x07
#define SMB_WRITE_BLOCK                 0x08
#define SMB_READ_BLOCK                  0x09
#define SMB_PROCESS_CALL                0x0A
#define SMB_BLOCK_PROCESS_CALL          0x0B
#define SMB_MAXIMUM_PROTOCOL            0x0B

//
// SMB Bus Status codes
//

#define SMB_STATUS_OK                   0x00
#define SMB_UNKNOWN_FAILURE             0x07
#define SMB_ADDRESS_NOT_ACKNOWLEDGED    0x10
#define SMB_DEVICE_ERROR                0x11
#define SMB_COMMAND_ACCESS_DENIED       0x12
#define SMB_UNKNOWN_ERROR               0x13
#define SMB_DEVICE_ACCESS_DENIED        0x17
#define SMB_TIMEOUT                     0x18
#define SMB_UNSUPPORTED_PROTOCOL        0x19
#define SMB_BUS_BUSY                    0x1A

//
// Alarm register/deregister requests
//

typedef
VOID
(*SMB_ALARM_NOTIFY) (
    PVOID       Context,
    UCHAR       Address,
    USHORT      Data
    );

// input buffer is SMB_REGISTER_ALARM.  output buffer is PVOID handle for registration.
// PVOID is passed in via DEREGISTER request to free registration

typedef struct {
    UCHAR               MinAddress;     // Min address for notifications
    UCHAR               MaxAddress;     // Max address for notifications
    SMB_ALARM_NOTIFY    NotifyFunction;
    PVOID               NotifyContext;
} SMB_REGISTER_ALARM, *PSMB_REGISTER_ALARM;

//
// Internal ioctls to SMB class driver
//

#define SMB_BUS_REQUEST             CTL_CODE(FILE_DEVICE_UNKNOWN, 0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_REGISTER_ALARM_NOTIFY   CTL_CODE(FILE_DEVICE_UNKNOWN, 1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define SMB_DEREGISTER_ALARM_NOTIFY CTL_CODE(FILE_DEVICE_UNKNOWN, 2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Shared SMB Class / Miniport driver structure
//

typedef
NTSTATUS
(*SMB_RESET_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
VOID
(*SMB_START_IO)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );

typedef
NTSTATUS
(*SMB_STOP_DEVICE)(
    IN struct _SMB_CLASS    *SmbClass,
    IN PVOID                SmbMiniport
    );



typedef struct _SMB_CLASS {
    USHORT              MajorVersion;
    USHORT              MinorVersion;

    PVOID               Miniport;           // Miniport extension data

    PDEVICE_OBJECT      DeviceObject;       // Device object for this miniport
    PDEVICE_OBJECT      PDO;                // PDO for this miniport
    PDEVICE_OBJECT      LowerDeviceObject;

    //
    // Current IO
    //

    PIRP                CurrentIrp;         // current request
    PSMB_REQUEST        CurrentSmb;         // pointer to SMB_REQUEST in the CurrentIrp

    //
    // Miniport functions
    //

    SMB_RESET_DEVICE    ResetDevice;        // Initialize/Reset, start device
    SMB_START_IO        StartIo;            // Perform IO
    SMB_STOP_DEVICE     StopDevice;         // Stop device

} SMB_CLASS, *PSMB_CLASS;

#define SMB_CLASS_MAJOR_VERSION     0x0001
#define SMB_CLASS_MINOR_VERSION     0x0000

//
// Class driver initializtion functions
//

#if !defined(SMBCLASS)
    #define SMBCLASSAPI DECLSPEC_IMPORT
#else
    #define SMBCLASSAPI
#endif


typedef
NTSTATUS
(*PSMB_INITIALIZE_MINIPORT) (
    IN PSMB_CLASS SmbClass,
    IN PVOID MiniportExtension,
    IN PVOID MiniportContext
    );

NTSTATUS
SMBCLASSAPI
SmbClassInitializeDevice (
    IN ULONG MajorVersion,
    IN ULONG MinorVersion,
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SMBCLASSAPI
SmbClassCreateFdo (
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           PDO,
    IN ULONG                    MiniportExtensionSize,
    IN PSMB_INITIALIZE_MINIPORT MiniportInitialize,
    IN PVOID                    MiniportContext,
    OUT PDEVICE_OBJECT          *FDO
    );

//
// Class driver interface functions for use by the miniport
//

VOID
SMBCLASSAPI
SmbClassCompleteRequest (
    IN PSMB_CLASS   SmbClass
    );


VOID
SMBCLASSAPI
SmbClassAlarm (
    IN PSMB_CLASS   SmbClass,
    IN UCHAR        Address,
    IN USHORT       Data
    );


VOID
SMBCLASSAPI
SmbClassLockDevice (
    IN PSMB_CLASS   SmbClass
    );

VOID
SMBCLASSAPI
SmbClassUnlockDevice (
    IN PSMB_CLASS   SmbClass
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\published\winperf.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    winperf.h

Abstract:

    Header file for the Performance Monitor data.

    This file contains the definitions of the data structures returned
    by the Configuration Registry in response to a request for
    performance data.  This file is used by both the Configuration
    Registry and the Performance Monitor to define their interface.
    The complete interface is described here, except for the name
    of the node to query in the registry.  It is

                   HKEY_PERFORMANCE_DATA.

    By querying that node with a subkey of "Global" the caller will
    retrieve the structures described here.

    There is no need to RegOpenKey() the reserved handle HKEY_PERFORMANCE_DATA,
    but the caller should RegCloseKey() the handle so that network transports
    and drivers can be removed or installed (which cannot happen while
    they are open for monitoring.)  Remote requests must first
    RegConnectRegistry().

--*/

#ifndef _WINPERF_
#define _WINPERF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <pshpack8.h>

//  Data structure definitions.

//  In order for data to be returned through the Configuration Registry
//  in a system-independent fashion, it must be self-describing.

//  In the following, all offsets are in bytes.

//
//  Data is returned through the Configuration Registry in a
//  a data block which begins with a _PERF_DATA_BLOCK structure.
//

#define PERF_DATA_VERSION   1
#define PERF_DATA_REVISION  1


typedef struct _PERF_DATA_BLOCK {
    WCHAR           Signature[4];       // Signature: Unicode "PERF"
    DWORD           LittleEndian;       // 0 = Big Endian, 1 = Little Endian
    DWORD           Version;            // Version of these data structures
                                        // starting at 1
    DWORD           Revision;           // Revision of these data structures
                                        // starting at 0 for each Version
    DWORD           TotalByteLength;    // Total length of data block
    DWORD           HeaderLength;       // Length of this structure
    DWORD           NumObjectTypes;     // Number of types of objects
                                        // being reported
    LONG            DefaultObject;      // Object Title Index of default
                                        // object to display when data from
                                        // this system is retrieved (-1 =
                                        // none, but this is not expected to
                                        // be used)
    SYSTEMTIME      SystemTime;         // Time at the system under
                                        // measurement
    LARGE_INTEGER   PerfTime;           // Performance counter value
                                        // at the system under measurement
    LARGE_INTEGER   PerfFreq;           // Performance counter frequency
                                        // at the system under measurement
    LARGE_INTEGER   PerfTime100nSec;    // Performance counter time in 100 nsec
                                        // units at the system under measurement
    DWORD           SystemNameLength;   // Length of the system name
    DWORD           SystemNameOffset;   // Offset, from beginning of this
                                        // structure, to name of system
                                        // being measured
} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


typedef struct _PERF_OBJECT_TYPE {
    DWORD           TotalByteLength;    // Length of this object definition
                                        // including this structure, the
                                        // counter definitions, and the
                                        // instance definitions and the
                                        // counter blocks for each instance:
                                        // This is the offset from this
                                        // structure to the next object, if
                                        // any
    DWORD           DefinitionLength;   // Length of object definition,
                                        // which includes this structure
                                        // and the counter definition
                                        // structures for this object: this
                                        // is the offset of the first
                                        // instance or of the counters
                                        // for this object if there is
                                        // no instance
    DWORD           HeaderLength;       // Length of this structure: this
                                        // is the offset to the first
                                        // counter definition for this
                                        // object
    DWORD           ObjectNameTitleIndex;
                                        // Index to name in Title Database
#ifdef _WIN64
    DWORD           ObjectNameTitle;    // Should use this as an offset
#else
    LPWSTR          ObjectNameTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           ObjectHelpTitleIndex;
                                        // Index to Help in Title Database
#ifdef _WIN64
    DWORD           ObjectHelpTitle;    // Should use this as an offset
#else
    LPWSTR          ObjectHelpTitle;    // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           DetailLevel;        // Object level of detail (for
                                        // controlling display complexity);
                                        // will be min of detail levels
                                        // for all this object's counters
    DWORD           NumCounters;        // Number of counters in each
                                        // counter block (one counter
                                        // block per instance)
    LONG            DefaultCounter;     // Default counter to display when
                                        // this object is selected, index
                                        // starting at 0 (-1 = none, but
                                        // this is not expected to be used)
    LONG            NumInstances;       // Number of object instances
                                        // for which counters are being
                                        // returned from the system under
                                        // measurement. If the object defined
                                        // will never have any instance data
                                        // structures (PERF_INSTANCE_DEFINITION)
                                        // then this value should be -1, if the
                                        // object can have 0 or more instances,
                                        // but has none present, then this
                                        // should be 0, otherwise this field
                                        // contains the number of instances of
                                        // this counter.
    DWORD           CodePage;           // 0 if instance strings are in
                                        // UNICODE, else the Code Page of
                                        // the instance names
    LARGE_INTEGER   PerfTime;           // Sample Time in "Object" units
                                        //
    LARGE_INTEGER   PerfFreq;           // Frequency of "Object" units in
                                        // counts per second.
} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

#define PERF_NO_INSTANCES           -1  // no instances (see NumInstances above)
//
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//
//  PERF_COUNTER_DEFINITION.CounterType field values
//
//
//        Counter ID Field Definition:
//
//   3      2        2    2    2        1        1    1
//   1      8        4    2    0        6        2    0    8                0
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//  |Display |Calculation  |Time|Counter |        |Ctr |Size|                |
//  |Flags   |Modifiers    |Base|SubType |Reserved|Type|Fld |   Reserved     |
//  +--------+--------+----+----+--------+--------+----+----+----------------+
//
//
//  The counter type is the "or" of the following values as described below
//
//  select one of the following to indicate the counter's data size
//
#define PERF_SIZE_DWORD         0x00000000  // 32 bit field
#define PERF_SIZE_LARGE         0x00000100  // 64 bit field
#define PERF_SIZE_ZERO          0x00000200  // for Zero Length fields
#define PERF_SIZE_VARIABLE_LEN  0x00000300  // length is in CounterLength field
                                            //  of Counter Definition struct
//
//  select one of the following values to indicate the counter field usage
//
#define PERF_TYPE_NUMBER        0x00000000  // a number (not a counter)
#define PERF_TYPE_COUNTER       0x00000400  // an increasing numeric value
#define PERF_TYPE_TEXT          0x00000800  // a text field
#define PERF_TYPE_ZERO          0x00000C00  // displays a zero
//
//  If the PERF_TYPE_NUMBER field was selected, then select one of the
//  following to describe the Number
//
#define PERF_NUMBER_HEX         0x00000000  // display as HEX value
#define PERF_NUMBER_DECIMAL     0x00010000  // display as a decimal integer
#define PERF_NUMBER_DEC_1000    0x00020000  // display as a decimal/1000
//
//  If the PERF_TYPE_COUNTER value was selected then select one of the
//  following to indicate the type of counter
//
#define PERF_COUNTER_VALUE      0x00000000  // display counter value
#define PERF_COUNTER_RATE       0x00010000  // divide ctr / delta time
#define PERF_COUNTER_FRACTION   0x00020000  // divide ctr / base
#define PERF_COUNTER_BASE       0x00030000  // base value used in fractions
#define PERF_COUNTER_ELAPSED    0x00040000  // subtract counter from current time
#define PERF_COUNTER_QUEUELEN   0x00050000  // Use Queuelen processing func.
#define PERF_COUNTER_HISTOGRAM  0x00060000  // Counter begins or ends a histogram
#define PERF_COUNTER_PRECISION  0x00070000  // divide ctr / private clock
//
//  If the PERF_TYPE_TEXT value was selected, then select one of the
//  following to indicate the type of TEXT data.
//
#define PERF_TEXT_UNICODE       0x00000000  // type of text in text field
#define PERF_TEXT_ASCII         0x00010000  // ASCII using the CodePage field
//
//  Timer SubTypes
//
#define PERF_TIMER_TICK         0x00000000  // use system perf. freq for base
#define PERF_TIMER_100NS        0x00100000  // use 100 NS timer time base units
#define PERF_OBJECT_TIMER       0x00200000  // use the object timer freq
//
//  Any types that have calculations performed can use one or more of
//  the following calculation modification flags listed here
//
#define PERF_DELTA_COUNTER      0x00400000  // compute difference first
#define PERF_DELTA_BASE         0x00800000  // compute base diff as well
#define PERF_INVERSE_COUNTER    0x01000000  // show as 1.00-value (assumes:
#define PERF_MULTI_COUNTER      0x02000000  // sum of multiple instances
//
//  Select one of the following values to indicate the display suffix (if any)
//
#define PERF_DISPLAY_NO_SUFFIX  0x00000000  // no suffix
#define PERF_DISPLAY_PER_SEC    0x10000000  // "/sec"
#define PERF_DISPLAY_PERCENT    0x20000000  // "%"
#define PERF_DISPLAY_SECONDS    0x30000000  // "secs"
#define PERF_DISPLAY_NOSHOW     0x40000000  // value is not displayed
//
//  Predefined counter types
//

// 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
#define PERF_COUNTER_COUNTER        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)


// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_QUEUELEN_TYPE  \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_LARGE_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using 100 Ns timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_100NS_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// Queue Length Space-Time Product using Object specific timebase.
// Divide delta by delta time. No Display Suffix.
#define PERF_COUNTER_OBJ_TIME_QUEUELEN_TYPE  \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |\
            PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
#define PERF_COUNTER_BULK_COUNT     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC)

// Indicates the counter is not a  counter but rather Unicode text Display as text.
#define PERF_COUNTER_TEXT           \
            (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |\
            PERF_DISPLAY_NO_SUFFIX)

// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |\
            PERF_DISPLAY_NO_SUFFIX)

// Special case for RAWCOUNT that want to be displayed in hex
// Indicates the data is a counter  which should not be
// time averaged on display (such as an error counter on a serial line)
// Display as is.  No Display Suffix.
#define PERF_COUNTER_RAWCOUNT_HEX       \
            (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)

// Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
#define PERF_COUNTER_LARGE_RAWCOUNT_HEX       \
            (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |\
            PERF_DISPLAY_NO_SUFFIX)


// A count which is either 1 or 0 on each sampling interrupt (% busy)
// Divide delta by delta base. Display Suffix: "%"
#define PERF_SAMPLE_FRACTION        \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT)

// A count which is sampled on each sampling interrupt (queue length)
// Divide delta by delta time. No Display Suffix.
#define PERF_SAMPLE_COUNTER         \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

// A label: no data is associated with this counter (it has 0 length)
// Do not display.
#define PERF_COUNTER_NODATA         \
            (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_COUNTER_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER | \
            PERF_DISPLAY_PERCENT)

// The divisor for a sample, used with the previous counter to form a
// sampled %.  You must check for >0 before dividing by this!  This
// counter will directly follow the  numerator counter.  It should not
// be displayed to the user.
#define PERF_SAMPLE_BASE            \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000001)  // for compatibility with pre-beta versions

// A timer which, when divided by an average base, produces a time
// in seconds which is the average time of some operation.  This
// timer times total operations, and  the base is the number of opera-
// tions.  Display Suffix: "sec"
#define PERF_AVERAGE_TIMER          \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_SECONDS)

// Used as the denominator in the computation of time or count
// averages.  Must directly follow the numerator counter.  Not dis-
// played to the user.
#define PERF_AVERAGE_BASE           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000002)  // for compatibility with pre-beta versions


// A bulk count which, when divided (typically) by the number of
// operations, gives (typically) the number of bytes per operation.
// No Display Suffix.
#define PERF_AVERAGE_BULK           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |\
            PERF_DISPLAY_NOSHOW)

// 64-bit Timer in object specific units. Display delta divided by
// delta time as returned in the object type header structure.  Display suffix: "%"
#define PERF_OBJ_TIME_TIMER	\
            (PERF_SIZE_LARGE   | PERF_TYPE_COUNTER  | PERF_COUNTER_RATE |\
             PERF_OBJECT_TIMER | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)


// 64-bit Timer in 100 nsec units. Display delta divided by
// delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER          \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 - delta divided by delta time.  Display suffix: "%"
#define PERF_100NSEC_TIMER_INV      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
// Timer for multiple instances, so result can exceed 100%.
#define PERF_COUNTER_MULTI_TIMER    \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_COUNTER_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |\
            PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Number of instances to which the preceding _MULTI_..._INV counter
// applies.  Used as a factor to get the percentage.
#define PERF_COUNTER_MULTI_BASE     \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW)

// 64-bit Timer in 100 nsec units. Display delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
#define PERF_100NSEC_MULTI_TIMER   \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_DISPLAY_PERCENT)

// 64-bit Timer inverse (e.g., idle is measured, but display busy %)
// Display 100 * _MULTI_BASE - delta divided by delta time.
// Display suffix: "%" Timer for multiple instances, so result
// can exceed 100%.  Followed by a counter of type _MULTI_BASE.
#define PERF_100NSEC_MULTI_TIMER_INV \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |\
            PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |\
            PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT)

// Indicates the data is a fraction of the following counter  which
// should not be time averaged on display (such as free space over
// total space.) Display as is.  Display the quotient as "%".
#define PERF_RAW_FRACTION           \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

#define PERF_LARGE_RAW_FRACTION           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |\
            PERF_DISPLAY_PERCENT)

// Indicates the data is a base for the preceding counter which should
// not be time averaged on display (such as free space over total space.)
#define PERF_RAW_BASE               \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW |\
            0x00000003)  // for compatibility with pre-beta versions

#define PERF_LARGE_RAW_BASE               \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |\
            PERF_DISPLAY_NOSHOW )

// The data collected in this counter is actually the start time of the
// item being measured. For display, this data is subtracted from the
// sample time to yield the elapsed time as the difference between the two.
// In the definition below, the PerfTime field of the Object contains
// the sample time as indicated by the PERF_OBJECT_TIMER bit and the
// difference is scaled by the PerfFreq of the Object to convert the time
// units into seconds.
#define PERF_ELAPSED_TIME           \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |\
            PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS)
//
//  The following counter type can be used with the preceding types to
//  define a range of values to be displayed in a histogram.
//

#define PERF_COUNTER_HISTOGRAM_TYPE   0x80000000
                                        // Counter begins or ends a histogram
//
//  This counter is used to display the difference from one sample
//  to the next. The counter value is a constantly increasing number
//  and the value displayed is the difference between the current
//  value and the previous value. Negative numbers are not allowed
//  which shouldn't be a problem as long as the counter value is
//  increasing or unchanged.
//
#define PERF_COUNTER_DELTA      \
            (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)

#define PERF_COUNTER_LARGE_DELTA      \
            (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |\
            PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX)
//
//  The precision counters are timers that consist of two counter values:
//      1) the count of elapsed time of the event being monitored
//      2) the "clock" time in the same units
//
//  the precition timers are used where the standard system timers are not
//  precise enough for accurate readings. It's assumed that the service
//  providing the data is also providing a timestamp at the same time which
//  will eliminate any error that may occur since some small and variable
//  time elapses between the time the system timestamp is captured and when
//  the data is collected from the performance DLL. Only in extreme cases
//  has this been observed to be problematic.
//
//  when using this type of timer, the definition of the
//      PERF_PRECISION_TIMESTAMP counter must immediately follow the
//      definition of the PERF_PRECISION_*_TIMER in the Object header
//
// The timer used has the same frequency as the System Performance Timer
#define PERF_PRECISION_SYSTEM_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_TICK    | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used has the same frequency as the 100 NanoSecond Timer
#define PERF_PRECISION_100NS_TIMER  \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_TIMER_100NS   | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// The timer used is of the frequency specified in the Object header's
//  PerfFreq field (PerfTime is ignored)
#define PERF_PRECISION_OBJECT_TIMER \
        (PERF_SIZE_LARGE    | PERF_TYPE_COUNTER     | PERF_COUNTER_PRECISION    | \
         PERF_OBJECT_TIMER  | PERF_DELTA_COUNTER    | PERF_DISPLAY_PERCENT   )
//
// This is the timestamp to use in the computation of the timer specified
// in the previous description block
#define PERF_PRECISION_TIMESTAMP    PERF_LARGE_RAW_BASE
//
//  The following are used to determine the level of detail associated
//  with the counter.  The user will be setting the level of detail
//  that should be displayed at any given time.
//
//
#define PERF_DETAIL_NOVICE          100 // The uninformed can understand it
#define PERF_DETAIL_ADVANCED        200 // For the advanced user
#define PERF_DETAIL_EXPERT          300 // For the expert user
#define PERF_DETAIL_WIZARD          400 // For the system designer
//
//
//  There is one of the following for each of the
//  PERF_OBJECT_TYPE.NumCounters.  The Unicode names in this structure MUST
//  come from a message file.
//
//
typedef struct _PERF_COUNTER_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure
    DWORD           CounterNameTitleIndex;
                                        // Index of Counter name into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterNameTitle;
#else
    LPWSTR          CounterNameTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    DWORD           CounterHelpTitleIndex;
                                        // Index of Counter Help into
                                        // Title Database
#ifdef _WIN64
    DWORD           CounterHelpTitle;
#else
    LPWSTR          CounterHelpTitle;   // Initially NULL, for use by
                                        // analysis program to point to
                                        // retrieved title string
#endif
    LONG            DefaultScale;       // Power of 10 by which to scale
                                        // chart line if vertical axis is 100
                                        // 0 ==> 1, 1 ==> 10, -1 ==>1/10, etc.
    DWORD           DetailLevel;        // Counter level of detail (for
                                        // controlling display complexity)
    DWORD           CounterType;        // Type of counter
    DWORD           CounterSize;        // Size of counter in bytes
    DWORD           CounterOffset;      // Offset from the start of the
                                        // PERF_COUNTER_BLOCK to the first
                                        // byte of this counter
} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;
//
//
//  If (PERF_DATA_BLOCK.NumInstances >= 0) then there will be
//  PERF_DATA_BLOCK.NumInstances of a (PERF_INSTANCE_DEFINITION
//  followed by a PERF_COUNTER_BLOCK followed by the counter data fields)
//  for each instance.
//
//  If (PERF_DATA_BLOCK.NumInstances < 0) then the counter definition
//  strucutre above will be followed by only a PERF_COUNTER_BLOCK and the
//  counter data for that COUNTER.
//

#define PERF_NO_UNIQUE_ID -1

typedef struct _PERF_INSTANCE_DEFINITION {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the subsequent name
    DWORD           ParentObjectTitleIndex;
                                        // Title Index to name of "parent"
                                        // object (e.g., if thread, then
                                        // process is parent object type);
                                        // if logical drive, the physical
                                        // drive is parent object type
    DWORD           ParentObjectInstance;
                                        // Index to instance of parent object
                                        // type which is the parent of this
                                        // instance.
    LONG            UniqueID;           // A unique ID used instead of
                                        // matching the name to identify
                                        // this instance, -1 = none
    DWORD           NameOffset;         // Offset from beginning of
                                        // this struct to the Unicode name
                                        // of this instance
    DWORD           NameLength;         // Length in bytes of name; 0 = none
                                        // this length includes the characters
                                        // in the string plus the size of the
                                        // terminating NULL char. It does not
                                        // include any additional pad bytes to
                                        // correct structure alignment
} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;
//
//  If .ParentObjectName is 0, there
//  is no parent-child hierarchy for this object type.  Otherwise,
//   the .ParentObjectInstance is an index, starting at 0, into the
//  instances reported for the parent object type.  It is only
//  meaningful if .ParentObjectName is not 0.  The purpose of all this
//  is to permit reporting/summation of object instances like threads
//  within processes, and logical drives within physical drives.
//
//
//  The PERF_INSTANCE_DEFINITION will be followed by a PERF_COUNTER_BLOCK.
//

typedef struct _PERF_COUNTER_BLOCK {
    DWORD           ByteLength;         // Length in bytes of this structure,
                                        // including the following counters
} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

//
//  The PERF_COUNTER_BLOCK is followed by PERF_OBJECT_TYPE.NumCounters
//  number of counters.
//

//
// Support for New Extensible API starting with NT 5.0
//
#define     PERF_QUERY_OBJECTS      ((LONG)0x80000000)
#define     PERF_QUERY_GLOBAL       ((LONG)0x80000001)
#define     PERF_QUERY_COSTLY       ((LONG)0x80000002)

//
//  function typedefs for extensible counter function prototypes
//
typedef DWORD (APIENTRY PM_OPEN_PROC) (LPWSTR);
typedef DWORD (APIENTRY PM_COLLECT_PROC) (LPWSTR, LPVOID *, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY PM_CLOSE_PROC) (void);
typedef DWORD (APIENTRY PM_QUERY_PROC) (LPDWORD, LPVOID *, LPDWORD, LPDWORD);

#define     MAX_PERF_OBJECTS_IN_QUERY_FUNCTION      (64L)

//
// The following are the possible values for
// HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Perflib\EventLogLevel
// The default is WINPERF_LOG_NONE if the registry value is not defined.
// This should be adopted by all perfdlls to avoid flooding the application
// event log.
//

#define  WINPERF_LOG_NONE       0           // No event reported
#define  WINPERF_LOG_USER       1           // Report only errors
#define  WINPERF_LOG_DEBUG      2           // Report debug errors as well
#define  WINPERF_LOG_VERBOSE    3           // Report everything

#include <poppack.h>

#endif // _WINPERF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\addwiz.h ===
//
// Copyright 1997 - Microsoft

//
// ADDWIZ.H - "Add" sif or image wizard class
//


#ifndef _ADDWIZ_H_
#define _ADDWIZ_H_

// Definitions
HRESULT
CAddWiz_CreateInstance( HWND hwndParent, LPUNKNOWN punk );

class CAddWiz;
typedef CAddWiz* LPCADDWIZ;
typedef HRESULT (*LPNEXTOP)( LPCADDWIZ lpc );

// CAddWiz
class
CAddWiz
{
private:
    WCHAR     _szNA[ 32 ];
    WCHAR     _szLocation[ 67 ];
    LPUNKNOWN _punk;
    HWND      _hDlg;
    HWND      _hwndList;
    LPWSTR    _pszPathBuffer;

    // "Add Wizard" flags
    BOOL    _fAddSif:1;
    BOOL    _fNewImage:1;
    BOOL    _fCopyFromServer:1;
    BOOL    _fCopyFromSamples:1;
    BOOL    _fCopyFromLocation:1;
    BOOL    _fDestPathIncludesSIF:1;
    BOOL    _fShowedPage8:1;
    BOOL    _fSIFCanExist:1;

    LPWSTR  _pszServerName;
    LPWSTR  _pszSourcePath;
    LPWSTR  _pszSourceImage;
    LPWSTR  _pszDestPath;
    LPWSTR  _pszDestImage;
    LPWSTR  _pszSourceServerName;

    WCHAR _szDescription[ REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT ];
    WCHAR _szHelpText[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT ];

private: // Methods
    CAddWiz();
    ~CAddWiz();
    STDMETHOD(Init)( HWND hwndParent, LPUNKNOWN punk );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    static INT_PTR CALLBACK
        EditSIFDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page1DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page2DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page3DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page4DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page5DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page6DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page7DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page8DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page9DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        Page10DlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam );
    INT     _VerifyCancel( HWND hDlg );
    STDMETHOD(_PopulateSamplesListView)( LPWSTR pszStartPath );
    STDMETHOD(_PopulateTemplatesListView)( LPWSTR pszStartPath );
    STDMETHOD(_PopulateImageListView)( LPWSTR pszStartPath );
    STDMETHOD(_FindLanguageDirectory)( LPNEXTOP lpNextOperation );
    STDMETHOD(_FindOSDirectory)( LPNEXTOP lpNextOperation );
    STDMETHOD(_EnumeratePlatforms)( LPNEXTOP lpNextOperation );
    static HRESULT _EnumerateTemplates( LPCADDWIZ lpc );
    static HRESULT _EnumerateImages( LPCADDWIZ lpc );
    STDMETHOD(_CheckImageType)( );
    STDMETHOD(_EnumerateSIFs)( );
    STDMETHOD(_AddItemToListView)( );
    STDMETHOD(_CleanupSIFInfo)( LPSIFINFO pSIF );
    STDMETHOD(_InitListView)( HWND hwndList, BOOL fShowDirectoryColumn );
    static HRESULT _OnSearch( HWND hwndParent );

public: // Methods
    friend HRESULT CAddWiz_CreateInstance( HWND hwndParent, LPUNKNOWN punk );
};

#endif // _ADDWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\ccomputr.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// CCOMPUTR.CPP - Handles the computer object property pages.
//

#include "pch.h"

#include "client.h"
#include "server.h"
#include "ccomputr.h"

#include "varconv.h"

//
// Begin Class Definitions
//
DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CComputer")
#define THISCLASS CComputer
#define LPTHISCLASS LPCComputer

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CComputer_CreateInstance( void )
{
	TraceFunc( "CComputer_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if (!lpcc)
        RETURN(lpcc);

    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// CreateCComputer( )
//
LPVOID
CreateIntelliMirrorClientComputer(
    IADs * pads)
{
    TraceFunc( "CreateCComputer(" );
    TraceMsg( TF_FUNC, "pads = 0x%08x )\n", pads );

    HRESULT   hr;
    LPTHISCLASS lpcc = NULL;

    if ( !pads )
    {
        hr = THR( E_POINTER );
        goto Error;
    }

    lpcc = new THISCLASS( );
    if ( !lpcc )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    hr = THR( lpcc->Init( ) );
    if ( hr )
        goto Error;

    hr = lpcc->Init2( pads );
    if (hr != S_FALSE) {
        hr = THR(E_FAIL);   // account exists?
        goto Error;
    }

Cleanup:
    RETURN((LPVOID) lpcc);

Error:
    if (lpcc) {
        delete lpcc;
        lpcc = NULL;
    }

    switch (hr) {
    case S_OK:
        break;

    default:
        MessageBoxFromHResult( NULL, IDC_ERROR_CREATINGACCOUNT_TITLE, hr );
        break;
    }
    goto Cleanup;
}

//
// Init2( )
//
STDMETHODIMP
THISCLASS::Init2(
    IADs * pads )
{
    TraceClsFunc( "Init2( ... )\n" );

    HRESULT hr;

    _pads = pads;
    _pads->AddRef( );

    hr = _pads->Get( NETBOOTGUID, &_vGUID );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) 
        goto Cleanup;

    hr = _pads->Get( NETBOOTSAP, &_vSCP );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    hr = _pads->Get( NETBOOTMACHINEFILEPATH, &_vMachineFilepath );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    hr = _pads->Get( NETBOOTINITIALIZATION, &_vInitialization );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( _vSCP.vt == VT_EMPTY
      || _vGUID.vt == VT_EMPTY
      || _vInitialization.vt == VT_EMPTY
      || _vMachineFilepath.vt == VT_EMPTY )
    {
        //
        // These must be blank since we are setting the attributes
        // of a newly created MAO.
        //
        hr = S_FALSE;
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CComputer()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CComputer, IShellExtInit );
    QITABLE_IMP( IShellExtInit );
    QITABLE_IMP( IShellPropSheetExt );
    QITABLE_IMP( IMAO );
    END_QITABLE_IMP( CComputer );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    // Private Members
    Assert( !_pads );
    Assert( !_pDataObj );

    VariantInit( &_vGUID );
    VariantInit( &_vMachineFilepath );
    VariantInit( &_vInitialization );
    VariantInit( &_vSCP );

    // _InitParams should already be zero'ed.
    _InitParams.dwSize = sizeof(_InitParams);

    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CComputer()\n" );

    // Members
    if ( _pads )
    {
        //
        // note: we shouldn't commit anything in the destructor -- we can't 
        // catch failures here.  We'll just have to make sure that we 
        // explicitly commit changes when necessary
        //
#if 0
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
#endif
        _pads->Release( );
    }

    if ( _pDataObj )
        _pDataObj->Release( );

    if ( _pszObjectName )
        TraceFree( _pszObjectName );

    VariantClear( &_vGUID );
    VariantClear( &_vMachineFilepath );
    VariantClear( &_vInitialization );
    VariantClear( &_vSCP );

#if 0 // EricB might be adding an AddRef( ) to this. Until then, don't release.
    if ( _InitParams.pDsObj )
        _InitParams.pDsObj->Release( );
#endif

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};


// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    // Ugly ugly ulgy... but it works
    if ( hr == E_NOINTERFACE && _pDataObj ) {
        hr = _pDataObj->QueryInterface( riid, ppv );
    }

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IShellExtInit
//
// ************************************************************************

//
// Initialize()
//
STDMETHODIMP
THISCLASS::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj,
    HKEY hkeyProgID )
{
    TraceClsFunc( "[IShellExtInit] Initialize( " );
    TraceMsg( TF_FUNC, " pidlFolder = 0x%08x, lpdobj = 0x%08x, hkeyProgID = 0x%08x )\n",
        pidlFolder, lpdobj, hkeyProgID );

    if ( !lpdobj )
        RETURN(E_INVALIDARG);

    HRESULT    hr = S_OK;
    FORMATETC  fmte;
    STGMEDIUM  stg = { 0 };
    STGMEDIUM  stgOptions = { 0 };

    LPWSTR     pszObjectName;
    LPWSTR     pszClassName;
    LPWSTR     pszAttribPrefix;

    LPDSOBJECT             pDsObject;
    LPDSOBJECTNAMES        pDsObjectNames;
    LPDSDISPLAYSPECOPTIONS pDsDisplayOptions;

    BOOL b;

    // Hang onto it
    _pDataObj = lpdobj;
    _pDataObj->AddRef( );

    //
    // Retrieve the Object Names
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsObjectNames;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stg) );
    if ( hr )
        goto Cleanup;

    pDsObjectNames = (LPDSOBJECTNAMES) stg.hGlobal;

    Assert( stg.tymed == TYMED_HGLOBAL );

    TraceMsg( TF_ALWAYS, "Object's Namespace CLSID: " );
    TraceMsgGUID( TF_ALWAYS, pDsObjectNames->clsidNamespace );
    TraceMsg( TF_ALWAYS, "\tNumber of Objects: %u \n", pDsObjectNames->cItems );

    Assert( pDsObjectNames->cItems == 1 );

    pDsObject = (LPDSOBJECT) pDsObjectNames->aObjects;

    pszObjectName = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetName );
    pszClassName  = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetClass );

    TraceMsg( TF_ALWAYS, "Object Name (Class): %s (%s)\n", pszObjectName, pszClassName );

    //
    // This must be a "Computer" class
    //
    if ( StrCmp( pszClassName, DSCOMPUTERCLASSNAME ) )
    {
        hr = S_FALSE;
        goto Error;
    }

    //
    // Retrieve the Display Spec Options
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsDisplaySpecOptions;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stgOptions ) );
    if ( hr )
        goto Cleanup;

    pDsDisplayOptions = (LPDSDISPLAYSPECOPTIONS) stgOptions.hGlobal;

    Assert( stgOptions.tymed == TYMED_HGLOBAL );
    Assert( pDsDisplayOptions->dwSize >= sizeof(DSDISPLAYSPECOPTIONS) );

    pszAttribPrefix = (LPWSTR) PtrToByteOffset( pDsDisplayOptions, pDsDisplayOptions->offsetAttribPrefix );

    // TraceMsg( TF_ALWAYS, TEXT("Attribute Prefix: %s\n"), pszAttribPrefix );

    if ( StrCmpW( pszAttribPrefix, STRING_ADMIN ) == 0 )
    {
        _uMode = MODE_ADMIN;
    }
    // else default from Init()

    TraceMsg( TF_ALWAYS, TEXT("Mode: %s\n"), _uMode ? TEXT("Admin") : TEXT("Shell") );

    ReleaseStgMedium( &stgOptions );

    _pszObjectName = TraceStrDup( pszObjectName );
    if ( !_pszObjectName )
        goto OutOfMemory;

    // create the DS notify object
    hr = THR( ADsPropCreateNotifyObj( _pDataObj, _pszObjectName, &_hwndNotify ) );
    if (FAILED( hr ))
        goto Error;

    b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
    if ( !b )
    {
        hr = E_FAIL;
        goto Error;
    }

    hr = THR( _InitParams.hr );
    if (FAILED( hr ))
        goto Error;

    hr = THR( _InitParams.pDsObj->QueryInterface( IID_IADs, (void**) &_pads ) );
    if (FAILED( hr ))
        goto Error;

    //
    // Retrieve the attributes
    //
    hr = _pads->Get( NETBOOTGUID, &_vGUID );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND ) 
        goto Error;

    hr = _pads->Get( NETBOOTSAP, &_vSCP );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    //
    // Check to see if this is an MAO that we need to add
    // ourselves to.
    //
    if ( _vSCP.vt == VT_EMPTY && _vGUID.vt == VT_EMPTY )
    {
        //
        // This MAO is not a IntelliMirror client or server.
        //
        hr = S_FALSE;
        goto Error;
    }

    hr = _pads->Get( NETBOOTMACHINEFILEPATH, &_vMachineFilepath );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    hr = _pads->Get( NETBOOTINITIALIZATION, &_vInitialization );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;

    //
    // Fix HR
    //
    if ( hr == E_ADS_PROPERTY_NOT_FOUND )
    {
        hr = S_OK;
    }

Cleanup:

    ReleaseStgMedium( &stg );

    HRETURN(hr);
OutOfMemory:
    hr = E_OUTOFMEMORY;
    // fall thru
Error:
    switch (hr) {
    case S_OK:
        break;

    case S_FALSE:
        hr = E_FAIL; // don't show page
        break;

    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
        break;
    }
    goto Cleanup;
}

// ************************************************************************
//
// IShellPropSheetExt
//
// ************************************************************************

//
// AddPages()
//
STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
{
    TraceClsFunc( "[IShellPropSheetExt] AddPages( )\n" );

    if ( !lpfnAddPage )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    BOOL fServer;

    hr = THR( IsServer( &fServer ) );
    if (FAILED( hr ))
        goto Error;

    if ( fServer )
    {
        //
        // Add the "IntelliMirror" tab for servers
        //
        hr = THR( ::AddPagesEx( NULL,
                                CServerTab_CreateInstance,
                                lpfnAddPage,
                                lParam,
                                (LPUNKNOWN) (IShellExtInit*) this ) );
        if (FAILED( hr ))
            goto Error;
    }
    else
    {
        //
        // Add the "IntelliMirror" tab for clients
        //
        hr = THR( ::AddPagesEx( NULL,
                                CClientTab_CreateInstance,
                                lpfnAddPage,
                                lParam,
                                (LPUNKNOWN) (IShellExtInit*) this ) );
        if (FAILED( hr ))
            goto Error;
    }

    // Release our count on it.
    // _pDataObj->Release( );
    // _pDataObj = NULL;

Error:
    HRETURN(hr); 
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam )
{

    TraceClsFunc( "[IShellPropSheetExt] ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

// ************************************************************************
//
// IMAO (Private)
//
// ************************************************************************

//
// CommitChanges( )
//
STDMETHODIMP
THISCLASS::CommitChanges( void )
{
    TraceClsFunc("[IMAO] CommitChanges( )\n" );

    HRESULT hr = THR( _pads->SetInfo( ) );

    HRETURN(hr);
}

//
// IsAdmin( )
//
STDMETHODIMP
THISCLASS::IsAdmin(
    BOOL * fAdmin )
{
    TraceClsFunc( "[IMAO] IsAdmin( )\n" );

    if ( !fAdmin )
        HRETURN( E_INVALIDARG );

    HRESULT hr = S_OK;

    *fAdmin = (_uMode == MODE_ADMIN);

    HRETURN(hr);
}

//
// IsServer( )
//
STDMETHODIMP
THISCLASS::IsServer(
    BOOL * fServer )
{
    TraceClsFunc( "[IMAO] IsServer( )\n" );

    if ( !fServer )
        HRETURN( E_INVALIDARG );

    HRESULT hr = S_OK;

    *fServer = (_vSCP.vt != VT_EMPTY);

    HRETURN(hr);
}

//
// IsClient( )
//
STDMETHODIMP
THISCLASS::IsClient(
    BOOL * fClient )
{
    TraceClsFunc( "[IMAO] IsClient( )\n" );
    if ( !fClient)
        HRETURN( E_INVALIDARG );

    HRESULT hr = S_OK;

    *fClient = (_vGUID.vt != VT_EMPTY ) |
               (_vMachineFilepath.vt != VT_EMPTY ) |
               (_vInitialization.vt != VT_EMPTY );

    HRETURN(hr);
}

//
// SetServerName( )
//
STDMETHODIMP
THISCLASS::SetServerName(
    LPWSTR pszName )
{
    TraceClsFunc( "[IMAO] SetServerName( " );
    TraceMsg( TF_FUNC, "pszName = %s )\n", pszName );

    HRESULT hr = S_OK;
    LPWSTR  pszFilepath = NULL;
    VARIANT var;

    if ( V_VT( &_vMachineFilepath ) == VT_BSTR )
    {
        pszFilepath = StrChr( _vMachineFilepath.bstrVal, L'\\' );
    }

    //
    // Create variant with new Server\Filepath string
    //
    VariantInit( &var );
    if ( !pszName || pszName[0] == L'\0' ) {
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, NETBOOTMACHINEFILEPATH, var ) );
        DebugMsg( "Cleared MachineFilepath\n" );
    } else {
        if ( pszFilepath ) {
            WCHAR szBuf[ DNS_MAX_NAME_LENGTH + 1 + 128 /* DHCP BOOTP PATH */ + 1 ];
            wsprintf( szBuf, L"%s\\%s", pszName, pszFilepath );
            PackStringToVariant( &var, szBuf);
            DebugMsg( "Set MachineFilepath to %s\n",  szBuf );
        } else {
            hr = PackStringToVariant( &var, pszName );
            if ( FAILED( hr ) )
                goto Cleanup;
            DebugMsg( "Set MachineFilepath to %s\n",  pszName );
        }

        //
        // Set the property
        //
        hr = THR( _pads->Put( NETBOOTMACHINEFILEPATH, var ) );
    }

    if (FAILED( hr ))
        goto Cleanup;
    //
    // Release the old variant and shallow copy the new one to the
    // MachineFilepath variant. No need to release the "var".
    //
    VariantClear( &_vMachineFilepath );
    _vMachineFilepath = var;
    VariantInit( &var ); // don't free

Cleanup:
    VariantClear( &var );
    HRETURN(hr);
}


//
// GetServerName( )
//
STDMETHODIMP
THISCLASS::GetServerName(
    LPWSTR * ppszName )
{
    TraceClsFunc( "[IMAO] GetServerName( " );
    TraceMsg( TF_FUNC, "*ppszName = 0x%08x )\n", *ppszName );

    HRESULT hr = S_OK;
    LPWSTR psz = _vMachineFilepath.bstrVal;

    if ( !ppszName )
        HRETURN( E_INVALIDARG );

    *ppszName = NULL;

    if ( _vMachineFilepath.vt != VT_BSTR || _vMachineFilepath.bstrVal == NULL )
        HRETURN( E_ADS_PROPERTY_NOT_FOUND );

    if ( *psz == L'\0' ) {
        hr = S_FALSE;
    } else {
        // Find the Filepath
        while ( *psz && *psz != L'\\' )
            psz++;

        *psz = L'\0';
        *ppszName = (LPWSTR) TraceStrDup( _vMachineFilepath.bstrVal );

        if ( !*ppszName )
            hr = E_OUTOFMEMORY;
    }

    HRETURN(hr);
}


//
// SetGUID( )
//
STDMETHODIMP
THISCLASS::SetGUID(
    LPWSTR pszGUID )
{
    TraceClsFunc("[IMAO] SetGUID( )\n" );

    HRESULT hr = E_FAIL;
    BYTE uGUID[16];
    VARIANT var;

    VariantInit( &var );
    if ( !pszGUID ) {

        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, NETBOOTGUID, var ) );
        if (FAILED( hr ))
            goto Cleanup;

        VariantClear( &_vGUID );

    } else {

        if ( ValidateGuid(pszGUID,uGUID,NULL) == S_OK ) {

            //
            // Put it into a variant
            //
            PackBytesToVariant( &var, uGUID, 16 );

            VariantClear( &_vGUID );
            _vGUID = var;

            hr = THR( _pads->Put( NETBOOTGUID, _vGUID ) );
            if (FAILED( hr ))
                goto Cleanup;
        }
        else // I don't know what it is.
        {
            Assert( FALSE );
            VariantClear( &var );
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

Cleanup:
    HRETURN(hr);
}

//
// GetGUID( )
//
STDMETHODIMP
THISCLASS::GetGUID(
    IN LPWSTR * ppszGUID OPTIONAL,
    IN LPBYTE uGUID OPTIONAL )
{
    TraceClsFunc("[IMAO] GetGUID( )\n" );

    HRESULT hr = S_OK;
    LPBYTE  ptr = NULL;
    VARIANT var = _vGUID;
    LONG Length;

    if ( ppszGUID != NULL ) {
        *ppszGUID = NULL;
    }

    if ( var.vt == VT_EMPTY )
        HRETURN( HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    if ( SafeArrayGetDim( var.parray ) != 1 )
        HRETURN( HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

    hr = THR( SafeArrayGetUBound( var.parray, 1, &Length ) );
    if (FAILED( hr ))
        goto Cleanup;

    Assert( Length == 15 );
    if ( Length != 15 )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto Cleanup;
    }

    hr = THR( SafeArrayAccessData( var.parray, (LPVOID*)&ptr ) );
    if (FAILED( hr ))
        goto Cleanup;

    if ( uGUID != NULL ) {
        memcpy( uGUID, ptr, 16 * sizeof(BYTE) );
    }

    if ( ppszGUID != NULL ) {
        *ppszGUID = PrettyPrintGuid( ptr );
        if ( !*ppszGUID )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
    }

    hr = S_OK;

Cleanup:
    if ( ptr )
        SafeArrayUnaccessData( var.parray );
    HRETURN(hr);
}


//
// GetSAP( )
//
STDMETHODIMP
THISCLASS::GetSAP(
    LPVOID *punk )
{
    TraceClsFunc( "[IMAO] GetSAP( punk )\n" );

    HRESULT hr = S_OK;
    LPWSTR pszDN = NULL;

    *punk = NULL;

    if ( _vSCP.vt != VT_BSTR ) {
        hr = E_ADS_PROPERTY_NOT_FOUND;
        goto Cleanup;
    }

    Assert( _vSCP.vt == VT_BSTR );
    Assert( _vSCP.bstrVal );

    // pre-pend the "LDAP://server/" from our DN
    hr = _FixObjectPath( V_BSTR( &_vSCP ), &pszDN );
    if (FAILED( hr ))
        goto Cleanup;

    // Bind to the MAO in the DS
    hr = THR( ADsGetObject( pszDN, IID_IADs, punk ) );
    if (FAILED( hr ))
        goto Cleanup;

Cleanup:
    if ( pszDN )
        TraceFree( pszDN );

    HRETURN(hr);
}

//
// _FixObjectPath( )
//
HRESULT
THISCLASS::_FixObjectPath( LPWSTR pszOldObjectPath, LPWSTR *ppszNewObjectPath )
{
    TraceClsFunc( "_FixObjectPath()\n" );
    if ( !ppszNewObjectPath )
        HRETURN(E_POINTER);

    HRESULT hr;
    LPWSTR psz = NULL;

    *ppszNewObjectPath = NULL;

    // Try to parse the string to connect to the same server as the DSADMIN
    if ( _pszObjectName && StrCmpNI( _pszObjectName, L"LDAP://", 7 ) == 0 )
    {
        psz = _pszObjectName + 7;
    }
    else if ( _pszObjectName && StrCmpNI( _pszObjectName, L"GC://", 5 ) == 0 )
    {
        psz = _pszObjectName + 5;
    }

    if ( psz )
    {
        psz = StrChr( psz, L'/' );
        psz++;

        INT_PTR uLen = psz - _pszObjectName;

        // get a chunk of memory, pre-zero'ed
        psz = TraceAllocString( LPTR, (size_t) uLen + wcslen( pszOldObjectPath ) + 1 );
        if ( !psz )
            goto OutOfMemory;

        MoveMemory( psz, _pszObjectName, uLen * sizeof(WCHAR) );
        wcscat( psz, pszOldObjectPath);
        *ppszNewObjectPath = psz;
    }
    else
    {   // find another server
        hr = THR( LDAPPrefix( pszOldObjectPath, ppszNewObjectPath ) );
    }

    Assert( ppszNewObjectPath || hr != S_OK );

    HRETURN(hr);
OutOfMemory:
    HRETURN(E_OUTOFMEMORY);
}

//
// GetDataObject( )
//
STDMETHODIMP
THISCLASS::GetDataObject( 
    LPDATAOBJECT * pDataObj 
    )
{
    TraceClsFunc( "GetDataObject( ... )\n ");

    if ( !pDataObj )
        HRETURN(E_POINTER);

    *pDataObj = _pDataObj;
    _pDataObj->AddRef( );

    HRETURN(S_OK);
}

//
//
//
STDMETHODIMP
THISCLASS::GetNotifyWindow(
    HWND *phNotifyObj 
    )
{
    TraceClsFunc( "GetNotifyWindow( ... )\n" );

    if ( !phNotifyObj )
        HRETURN(E_POINTER);

    *phNotifyObj = _hwndNotify;

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cenumsap.cpp ===
//
// Copyright 1997 - Microsoft

//
// CENUMSIF.CPP - Handles enumerating OSes and Tools SIFs from DS
//

#include "pch.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CEnumSAPs")
#define THISCLASS CEnumSAPs
#define LPTHISCLASS LPCENUMSAPS

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CEnumSAPs_CreateInstance( LPWSTR pszObjectName )
{
	TraceFunc( "CEnumSAPs_CreateInstance(" );
    TraceMsg( TF_FUNC, "pszObjectName = %s )\n", pszObjectName );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( pszObjectName ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CEnumSAPs()\n" );

	InterlockIncrement( g_cObjects );
    
    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( LPWSTR pszObjectName )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CEnumSAPs, IEnumSAPs );
    QITABLE_IMP( IEnumSAPs );
    END_QITABLE_IMP( CEnumSAPs );
    Assert( _cRef == 0);
    AddRef( );

    // Private Members
    Assert( _iIndex == 0 );
    Assert( _penum == NULL );

    RETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CEnumSAPs()\n" );

    // Private Members
    if ( _penum )
        _penum->Release( );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "[IUnknown] QueryInterface( riid=" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IEnumSAPs
//
// ************************************************************************

//
// Next( )
//
STDMETHODIMP
THISCLASS::Next( 
    ULONG celt, 
    VARIANT * rgelt, 
    ULONG * pceltFetched )
{
    TraceClsFunc( "[IEnumSAPs] Next( ... )\n " );

    if ( !rgelt )
        RRETURN(E_POINTER);

    HRESULT hr;

    if (pceltFetched)
        *pceltFetched = 0;

    //
    // Get the attribute vars
    //
    hr = THR( _penum->Next( celt, rgelt, pceltFetched ) );
    if (hr)
        goto Error;

Cleanup:
    RETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;

    default:
        MessageBoxFromHResult( NULL, IDC_ERROR_CREATINGACCOUNT_TITLE, hr );
        break;
    }
    goto Cleanup;
}

//
// Skip( )
//
STDMETHODIMP 
THISCLASS::Skip( 
    ULONG celt  )
{
    TraceClsFunc( "[IEnumSAPs] Skip( ... )\n " );

    HRESULT hr = S_OK;

    hr = THR( _penum->Skip( celt ) );
    if (hr)
        goto Error;

Error:
    RETURN(hr);
}


//
// Reset( )
//
STDMETHODIMP 
THISCLASS::Reset( void )
{
    TraceClsFunc( "[IEnumSAPs] Reset( ... )\n " );

    HRESULT hr = S_OK;

    hr = THR( _penum->Reset( ) );
    if (hr)
        goto Error;

Error:
    RETURN(hr);
}


//
// Clone( )
//
STDMETHODIMP 
THISCLASS::Clone( 
    LPUNKNOWN * ppenum )
{
    TraceClsFunc( "[IEnumSAPs] Clone( ... )\n" );
    
    if ( ppenum == NULL )
        RRETURN( E_POINTER );

    *ppenum = NULL;

    hr = THR( _penum->Clone( ppenum ) );
    if (hr)
        goto Error;

Error:
    RETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cenumsif.h ===
//
// Copyright 1997 - Microsoft
//

//
// CENUMSIF.H - Handles enumerating OSes and Tools SIFs from DS
//

#ifndef _CENUMSIF_H_
#define _CENUMSIF_H_

// Flag Definitions
#define ENUM_READ   0x00000000
#define ENUM_WRITE  0x00000001

// QI Table
BEGIN_QITABLE( CEnumIMSIFs )
DEFINE_QI( IID_IEnumIMSIFs, IEnumIMSIFs, 4 )
END_QITABLE

// Definitions
LPVOID
CEnumIMSIFs_CreateInstance( 
    LPWSTR pszEnumPath, 
    LPWSTR pszAttribute, 
    DWORD dwFlags, 
    IADs * pads );

// Private Interface Definition
interface 
IEnumIMSIFs:
    public IUnknown
{
public:
    STDMETHOD(Next)( ULONG celt, LPWSTR * rgelt, ULONG * pceltFetched ) PURE; 
    STDMETHOD(Skip)( ULONG celt  ) PURE; 
    STDMETHOD(Reset)(void) PURE;
    STDMETHOD(Clone)( LPUNKNOWN * ppenum ) PURE;    
};

typedef IEnumIMSIFs * LPENUMIMSIFS;

// CEnumIMSIFs
class 
CEnumIMSIFs:
    public IEnumIMSIFs
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CEnumIMSIFs );

    // IIntelliMirror
    IADs *   _pads;                 // ADS Object
    LPWSTR   _pszAttribute;         // Attribute to enumerate
    int      _iIndex;               // Index

    LPWSTR   _pszServerName;        // DNS name of server
    HANDLE   _hLanguage;            // FindFile handle for Languages
    LPWSTR   _pszLanguage;          // last language found
    LPWSTR   _pszEnumPath;          // \\Server\IMIRROR\Setup\<language>\<_pszEnumPath>\*
    HANDLE   _hOS;                  // FindFile handle for OSes
    LPWSTR   _pszOS;                // last OS found
    HANDLE   _hArchitecture;        // FindFile handle for Architectures
    LPWSTR   _pszArchitecture;      // last Architecture found
    HANDLE   _hSIF;                 // FindFile handle for SIF files
    LPWSTR   _pszSIF;               // last SIF found

    // Flags for enumeration
    union {
        DWORD       _dwFlags;       
        struct {
            BOOL _fWrite:1;
        };
    };

private: // Methods
    CEnumIMSIFs();
    ~CEnumIMSIFs();
    STDMETHOD(Init)( LPWSTR pszEnumPath, LPWSTR pszAttribute, DWORD dwFlags, IADs * pads );

    HRESULT _FindNextItem( LPWSTR * pszFilePath );
    HRESULT _NextLanguage( );
    HRESULT _NextOS( );
    HRESULT _NextArchitecture( );
    HRESULT _NextSIF( );

public: // Methods
    friend LPVOID 
        CEnumIMSIFs_CreateInstance( LPWSTR pszEnumPath, LPWSTR pszAttribute, 
                                    DWORD dwFlags, IADs * pads );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IEnumIMThings
    STDMETHOD(Next)( ULONG celt, LPWSTR * rgelt, ULONG * pceltFetched ); 
    STDMETHOD(Skip)( ULONG celt  ); 
    STDMETHOD(Reset)(void); 
    STDMETHOD(Clone)( LPUNKNOWN * ppenum );    
};

typedef CEnumIMSIFs* LPENUMSIFS;

#endif // _CENUMSIF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\addwiz.cpp ===
//
// Copyright 1997 - Microsoft

//
// IMOS.CPP - Handles the "IntelliMirror OS" IDD_PROP_INTELLIMIRROR_OS tab
//


#include "pch.h"
#include "addwiz.h"
#include "cservice.h"
#include "utils.h"
#include <lm.h>
#include <shlobj.h>
#include <commdlg.h>

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CAddWiz")
#define THISCLASS CAddWiz
#define LPTHISCLASS LPCADDWIZ

#define BITMAP_WIDTH        16
#define BITMAP_HEIGHT       16
#define LG_BITMAP_WIDTH     32
#define LG_BITMAP_HEIGHT    32
#define NUM_COLUMNS				    5
#define SERVER_START_STRING         L"\\\\%s\\" REMINST_SHARE

//
// CreateInstance()
//
HRESULT
CAddWiz_CreateInstance(
    HWND  hwndParent,
    LPUNKNOWN punk )
{
	TraceFunc( "CAddWiz_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT hr;

    if (lpcc == NULL) {
        
        hr = S_FALSE;

    } else {

        hr   = THR( lpcc->Init( hwndParent, punk ) );
        delete lpcc;

    }

    HRETURN(hr);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CAddWiz()\n" );

    DWORD dw;

    dw = LoadString( g_hInstance, IDS_NA, _szNA, ARRAYSIZE(_szNA) );
    Assert( dw );

    dw = LoadString( g_hInstance,
                     IDS_USER_LOCATION,
                     _szLocation,
                     ARRAYSIZE(_szLocation) );
    Assert( dw );

    Assert( !_pszServerName );
    Assert( !_pszSourcePath );
    Assert( !_pszDestPath );
    Assert( !_pszSourceImage );
    Assert( !_pszDestImage );
    Assert( !_pszSourceServerName );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init(
    HWND hwndParent,
    LPUNKNOWN punk )
{
    TraceClsFunc( "Init()\n" );

    if ( !punk )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;

    HPROPSHEETPAGE  rPages[ 10 ];
    PROPSHEETHEADER pshead;

    _punk = punk;
    _punk->AddRef( );

    ZeroMemory( &pshead, sizeof(pshead) );
    pshead.dwSize       = sizeof(pshead);
    pshead.dwFlags      = PSH_WIZARD97 | PSH_PROPTITLE | PSH_HEADER;
    pshead.hInstance    = g_hInstance;
    pshead.pszCaption   = MAKEINTRESOURCE( IDS_ADD_DOT_DOT_DOT );
    pshead.phpage       = rPages;
    pshead.pszbmHeader  = MAKEINTRESOURCE( IDB_HEADER );
    pshead.hwndParent   = hwndParent;

    AddWizardPage( &pshead, IDD_ADD_PAGE1,  Page1DlgProc,  IDS_PAGE1_TITLE,  IDS_PAGE1_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE2,  Page2DlgProc,  IDS_PAGE2_TITLE,  IDS_PAGE2_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE6,  Page6DlgProc,  IDS_PAGE6_TITLE,  IDS_PAGE6_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE3,  Page3DlgProc,  IDS_PAGE3_TITLE,  IDS_PAGE3_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE4,  Page4DlgProc,  IDS_PAGE4_TITLE,  IDS_PAGE4_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE5,  Page5DlgProc,  IDS_PAGE5_TITLE,  IDS_PAGE5_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE7,  Page7DlgProc,  IDS_PAGE7_TITLE,  IDS_PAGE7_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE8,  Page8DlgProc,  IDS_PAGE8_TITLE,  IDS_PAGE8_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE9,  Page9DlgProc,  IDS_PAGE9_TITLE,  IDS_PAGE9_SUBTITLE,  (LPARAM) this );
    AddWizardPage( &pshead, IDD_ADD_PAGE10, Page10DlgProc, IDS_PAGE10_TITLE, IDS_PAGE10_SUBTITLE, (LPARAM) this );

    PropertySheet( &pshead );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CAddWiz()\n" );

    Assert( !_pszPathBuffer );

    if ( _punk )
        _punk->Release( );

    if ( _pszServerName )
        TraceFree( _pszServerName );

    if ( _pszSourcePath )
        TraceFree( _pszSourcePath );

    if ( _pszSourceServerName )
        TraceFree( _pszSourceServerName );

    if ( _pszDestPath )
        TraceFree( _pszDestPath );

    if ( _pszSourceImage
      && _pszSourceImage != _szNA
      && _pszSourceImage != _szLocation )
        TraceFree( _pszSourceImage );

    if ( _pszDestImage
      && _pszDestImage != _szNA
      && _pszDestImage != _szLocation )
        TraceFree( _pszDestImage );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// Wizard Functions
//
// ************************************************************************

//
// _PopulateSamplesListView( )
//
STDMETHODIMP
THISCLASS::_PopulateSamplesListView(
    LPWSTR pszStartPath )
{
    TraceClsFunc( "_PopulateSamplesListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _pszPathBuffer =
        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                   wcslen( pszStartPath ) + MAX_PATH );
    if ( !_pszPathBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    wcscpy( _pszPathBuffer, pszStartPath );

    hr = _EnumerateSIFs( );

Error:
    if ( _pszPathBuffer )
    {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
    }

    HRETURN(hr);
}

//
// _PopulateTemplatesListView( )
//
STDMETHODIMP
THISCLASS::_PopulateTemplatesListView(
    LPWSTR pszStartPath )
{
    TraceClsFunc( "_PopulateTemplatesListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _pszPathBuffer =
        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                   wcslen( pszStartPath ) + MAX_PATH );
    if ( !_pszPathBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    wcscpy( _pszPathBuffer, pszStartPath );
    wcscat( _pszPathBuffer, SLASH_SETUP );

    hr = _FindLanguageDirectory( _EnumerateTemplates );

Error:
    if ( _pszPathBuffer )
    {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
    }

    HRETURN(hr);
}

//
// _PopulateImageListView( )
//
STDMETHODIMP
THISCLASS::_PopulateImageListView(
    LPWSTR pszStartPath )
{
    TraceClsFunc( "_PopulateImageListView( " );
    TraceMsg( TF_FUNC, "pszStartPath = '%s' )\n", pszStartPath );

    if ( !pszStartPath )
        HRETURN(E_POINTER);

    Assert( _hDlg );
    Assert( _hwndList );

    CWaitCursor Wait;
    HRESULT hr;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;

    ListView_DeleteAllItems( _hwndList );

    Assert( !_pszPathBuffer );
    _pszPathBuffer =
        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                   wcslen( pszStartPath ) + MAX_PATH );
    if ( !_pszPathBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    wcscpy( _pszPathBuffer, pszStartPath );
    wcscat( _pszPathBuffer, SLASH_SETUP );

    hr = _FindLanguageDirectory( _EnumerateImages );

Error:
    if ( _pszPathBuffer )
    {
        TraceFree( _pszPathBuffer );
        _pszPathBuffer = NULL;
    }

    HRETURN(hr);
}

//
// _FindLanguageDirectory( )
//
STDMETHODIMP
THISCLASS::_FindLanguageDirectory(
    LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_FindLanguageDirectory( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    Assert( lpNextOperation );

    uLength = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, L"\\*" );
    uLength2 = wcslen( _pszPathBuffer ) - 1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
              && StrCmp( find.cFileName, L"." ) != 0
              && StrCmp( find.cFileName, L".." ) != 0 )
            {
                _pszPathBuffer[uLength2] = L'\0';
                wcscat( _pszPathBuffer, find.cFileName );
                hr = _FindOSDirectory( lpNextOperation );
                if (FAILED(hr))
                    goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );
    }

Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _FindOSDirectory( )
//
STDMETHODIMP
THISCLASS::_FindOSDirectory(
    LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_FindOSDirectory( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    Assert( lpNextOperation );

    uLength = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, SLASH_IMAGES L"\\");
    uLength2 = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, L"*" );

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
              && StrCmp( find.cFileName, L"." ) != 0
              && StrCmp( find.cFileName, L".." ) != 0 )
            {
                _pszPathBuffer[uLength2] = L'\0';
                wcscat( _pszPathBuffer, find.cFileName );
                hr = _EnumeratePlatforms( lpNextOperation );
                if (FAILED(hr))
                    goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );
    }

Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumeratePlatforms( )
//
STDMETHODIMP
THISCLASS::_EnumeratePlatforms(
    LPNEXTOP lpNextOperation )
{
    TraceClsFunc( "_EnumeratePlatforms( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    ULONG   uLength2;
    WIN32_FIND_DATA find;

    Assert( lpNextOperation );
    Assert( _pszPathBuffer );

    uLength = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, L"\\*" );
    uLength2 = wcslen( _pszPathBuffer ) - 1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
              && StrCmp( find.cFileName, L"." ) != 0
              && StrCmp( find.cFileName, L".." ) != 0 )
            {
                _pszPathBuffer[uLength2] = L'\0';
                wcscat( _pszPathBuffer, find.cFileName );
                hr = lpNextOperation( this );
                if (FAILED(hr))
                    goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );
    }

Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateTemplates( )
//
HRESULT
THISCLASS::_EnumerateTemplates(
    LPTHISCLASS lpc )
{
    TraceClsFunc( "_EnumerateTemplates( )\n" );

    HRESULT hr;
    ULONG   uLength;

    Assert( lpc );
    Assert( lpc->_pszPathBuffer );
    uLength = wcslen( lpc->_pszPathBuffer );
    wcscat( lpc->_pszPathBuffer, SLASH_TEMPLATES );

    hr = lpc->_EnumerateSIFs( );

    lpc->_pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateImages( )
//
HRESULT
THISCLASS::_EnumerateImages(
    LPTHISCLASS lpc )
{
    TraceClsFunc( "_EnumerateImages( )\n" );

    HRESULT hr;

    Assert( lpc );

    hr = lpc->_CheckImageType( );
    if ( hr == S_OK )
    {
        hr = lpc->_AddItemToListView( );
    }

    HRETURN(hr);
}

//
// _CheckImageType( )
//
// This won't add an item to the listview. It only checks to make
// sure the image path points to a "Flat" image.
//
// Returns: S_OK - Flat image found
//          S_FALSE - not a flat image
//
HRESULT
THISCLASS::_CheckImageType( )
{
    TraceClsFunc( "_CheckImageType( )\n" );

    HRESULT hr = S_FALSE;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA find;
    ULONG   uLength;
    ULONG   uLength2;

    Assert( _pszPathBuffer );

    uLength = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, SLASH_TEMPLATES L"\\");

    uLength2 = wcslen( _pszPathBuffer );
    wcscat( _pszPathBuffer, L"*.sif" );

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            {
                WCHAR szImageType[ 40 ];
                _pszPathBuffer[uLength2] = L'\0';
                wcscat( _pszPathBuffer, find.cFileName );

                GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                         OSCHOOSER_IMAGETYPE_ENTRY,
                                         L"",
                                         szImageType,
                                         ARRAYSIZE(szImageType),
                                         _pszPathBuffer );

                if ( StrCmpI( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) == 0 )
                {
                    hr = S_OK;
                    goto Error;
                }
            }
        }
        while ( FindNextFile( hFind, &find ) );
    }
    else
    {   // no SIFs in the templates directory, then check for ntoskrnl
        // in the archtecture directory. If found, this is a "Flat" image.
        _pszPathBuffer[uLength] = L'\0';
        wcscat( _pszPathBuffer, L"\\ntoskrnl.exe" );

        hFind = FindFirstFile( _pszPathBuffer, &find );
        if ( hFind != INVALID_HANDLE_VALUE )
        {
            do
            {
                if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                {
                    Assert( StrCmpI( find.cFileName, L"ntoskrnl.exe" ) == 0 );
                    hr = S_OK;
                    goto Error;
                }
            }
            while ( FindNextFile( hFind, &find ) );
        }
    }

Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _EnumerateSIFs( )
//
STDMETHODIMP
THISCLASS::_EnumerateSIFs( )
{
    TraceClsFunc( "_EnumerateSIFs( ... )\n" );

    HRESULT hr = S_OK;
    HANDLE  hFind = INVALID_HANDLE_VALUE;
    ULONG   uLength;
    WIN32_FIND_DATA find;

    Assert( _pszPathBuffer );
    wcscat( _pszPathBuffer, L"\\*.sif" );
    uLength = wcslen( _pszPathBuffer ) - ARRAYSIZE(L"*.sif") + 1;

    hFind = FindFirstFile( _pszPathBuffer, &find );
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( !(find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                _pszPathBuffer[uLength] = L'\0';
                wcscat( _pszPathBuffer, find.cFileName );

                hr = _AddItemToListView( );
                if (FAILED(hr))
                    goto Error;
            }
        }
        while ( FindNextFile( hFind, &find ) );
    }

Error:
    if ( hFind != INVALID_HANDLE_VALUE )
        FindClose( hFind );

    _pszPathBuffer[uLength] = L'\0';

    HRETURN(hr);
}

//
// _AddItemToListView( )
//
// Returns: S_OK - Item add successfully
//          S_FALSE - Item is not valid
//          E_OUTOFMEMORY - obvious
//
HRESULT
THISCLASS::_AddItemToListView( )
{
    TraceClsFunc( "_AddItemToListView( )\n" );

    Assert( _pszPathBuffer );

    HRESULT hr = S_OK;
    LPSIFINFO pSIF = NULL;
    LV_ITEM lvI;
    INT     iCount = 0;
    LPWSTR  psz;
    LPWSTR  pszLanguage;
    LPWSTR  pszImage;
    LPWSTR  pszArchitecture;

    pSIF = (LPSIFINFO) TraceAlloc( LPTR, sizeof(SIFINFO) );
    if ( !pSIF )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    pSIF->pszFilePath = (LPWSTR) TraceStrDup( _pszPathBuffer );
    if ( !pSIF->pszFilePath )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    psz = &_pszPathBuffer[ wcslen( _pszPathBuffer ) - 4 ];
    if ( StrCmpI( psz, L".SIF" ) == 0 )
    {
        WCHAR szImageType[ 40 ];

        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                 OSCHOOSER_IMAGETYPE_ENTRY,
                                 L"",
                                 szImageType,
                                 ARRAYSIZE(szImageType),
                                 _pszPathBuffer );
        // only show "Flat" SIFs
        if ( szImageType[0] && StrCmpI( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) )
        {
            hr = S_FALSE; // skipping
            goto Error;
        }

        pSIF->pszDescription =
            (LPWSTR) TraceAllocString( LMEM_FIXED,
                                       REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT );
        if ( !pSIF->pszDescription )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }

        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                 OSCHOOSER_DESCRIPTION_ENTRY,
                                 L"",
                                 pSIF->pszDescription,
                                 REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT, // doesn't need -1
                                 _pszPathBuffer );

        if ( pSIF->pszDescription[0] == L'\0' )
        {
            hr = S_FALSE;
            goto Error; // not a valid OSChooser SIF
        }

        pSIF->pszHelpText = 
            (LPWSTR) TraceAllocString( LMEM_FIXED, 
                                       REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
        if ( pSIF->pszHelpText )
        {
            GetPrivateProfileString( OSCHOOSER_SIF_SECTION, 
                                     OSCHOOSER_HELPTEXT_ENTRY, 
                                     L"", 
                                     pSIF->pszHelpText, 
                                     REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT, // doesn't need -1
                                     _pszPathBuffer );
        }
    }

    // This path will be in one of these forms:
    // \\server\reminst\setup\english\images\nt50.wks\i386           ( Samples )
    // \\server\reminst\setup\english\images\nt50.wks\i386\templates ( template SIFs )
    // \\server\reminst\setup\english\images                         ( Images )

    // Find the language from the path
    psz = StrStr( _pszPathBuffer, SLASH_SETUP L"\\" );
    if (!psz)
        goto Language_NA;
    psz++;
    if ( !*psz )
        goto Language_NA;
    psz = StrChr( psz, L'\\' );
    if (!psz)
        goto Language_NA;
    psz++;
    if ( !*psz )
        goto Language_NA;
    pszLanguage = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz )
    {
        *psz = L'\0';   // terminate
    }
    pSIF->pszLanguage = (LPWSTR) TraceStrDup( pszLanguage );
    if ( psz )
    {
        *psz = L'\\';   // restore
    }
    if ( !pSIF->pszLanguage )
    {
        hr = E_OUTOFMEMORY;
        goto Language_NA;
    }

    // Find the image directory name from the path
    psz = StrStr( _pszPathBuffer, SLASH_IMAGES L"\\" );
    if ( !psz )
        goto Image_NA;
    psz++;
    if ( !*psz )
        goto Image_NA;
    psz = StrChr( psz, L'\\' );
    if (!psz)
        goto Image_NA;
    psz++;
    if ( !*psz )
        goto Image_NA;
    pszImage = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz )
    {
        *psz = L'\0';   // terminate
    }
    pSIF->pszImageFile = (LPWSTR) TraceStrDup( pszImage );
    if ( psz )
    {
        *psz = L'\\';    // restore
    }
    if ( !pSIF->pszImageFile )
    {
        hr = E_OUTOFMEMORY;
        goto Image_NA;
    }

    // Find the architecture from the path
    if ( !*psz )
        goto Architecture_NA;
    psz++;
    if ( !*psz )
        goto Architecture_NA;
    pszArchitecture = psz;
    psz = StrChr( psz, L'\\' );
    if ( psz )
    {
        *psz = L'\0';    // terminate
    }
    pSIF->pszArchitecture = (LPWSTR) TraceStrDup( pszArchitecture );
    if ( psz )
    {
        *psz = L'\\';    // restore
    }
    if ( !pSIF->pszArchitecture )
    {
        hr = E_OUTOFMEMORY;
        goto Architecture_NA;
    }

    goto Done;

    // Set columns that we couldn't determine to "n/a"
Language_NA:
    pSIF->pszLanguage = _szNA;
Image_NA:
    pSIF->pszImageFile = _szNA;
Architecture_NA:
    pSIF->pszArchitecture = _szNA;

Done:
    if ( !pSIF->pszDescription )
    {
        pSIF->pszDescription = (LPWSTR) TraceStrDup( pSIF->pszImageFile );
        if ( !pSIF->pszDescription )
        {
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT;
    lvI.lParam      = (LPARAM) pSIF;
    lvI.iItem       = iCount;
    lvI.pszText     = pSIF->pszDescription;
    iCount = ListView_InsertItem( _hwndList, &lvI );
    Assert( iCount != -1 );
    if ( iCount == -1 )
        goto Error;

    ListView_SetItemText( _hwndList, iCount, 1, pSIF->pszArchitecture );
    ListView_SetItemText( _hwndList, iCount, 2, pSIF->pszLanguage );
    // ListView_SetItemText( hwndList, iCount, 3, pSIF->pszVersion );
    ListView_SetItemText( _hwndList, iCount, 3, pSIF->pszImageFile );

    pSIF = NULL; // don't free

Error:
    if ( pSIF )
        THR( _CleanupSIFInfo( pSIF ) );

    HRETURN(hr);
}

//
// _CleanUpSifInfo( )
//
HRESULT
THISCLASS::_CleanupSIFInfo(
    LPSIFINFO pSIF )
{
    TraceClsFunc( "_CleanupSIFInfo( )\n" );

    if ( !pSIF )
        HRETURN(E_POINTER);

    if ( pSIF->pszDescription )
        TraceFree( pSIF->pszDescription );

    if ( pSIF->pszFilePath )
        TraceFree( pSIF->pszFilePath );

    //if ( pSIF->pszImageType && pSIF->pszImageType != _szNA )
    //    TraceFree( pSIF->pszImageType );

    if ( pSIF->pszArchitecture  && pSIF->pszArchitecture != _szNA )
        TraceFree( pSIF->pszArchitecture );

    if ( pSIF->pszLanguage && pSIF->pszLanguage != _szNA )
        TraceFree( pSIF->pszLanguage );

    if ( pSIF->pszImageFile && pSIF->pszImageFile != _szNA )
        TraceFree( pSIF->pszImageFile );

    //if ( pSIF->pszVersion && pSIF->pszVersion != _szNA )
    //    TraceFree( pSIF->pszVersion );

    TraceFree( pSIF );

    HRETURN(S_OK);

}

//
// _InitListView( )
//
HRESULT
THISCLASS::_InitListView(
    HWND hwndList,
    BOOL fShowDirectoryColumn )
{
    TraceClsFunc( "_InitListView( )\n" );

    CWaitCursor Wait;
    LV_COLUMN   lvC;
    INT         iSubItem;
    INT         iCount;
    LV_ITEM     lvI;
    WCHAR       szText[ 80 ];
    DWORD       dw;

    UINT uColumnWidth[ NUM_COLUMNS ] = { 215, 75, 75, 75, 75 };

    lvI.mask        = LVIF_TEXT | LVIF_PARAM;
    lvI.iSubItem    = 0;
    lvI.cchTextMax  = DNS_MAX_NAME_BUFFER_LENGTH;

    // Create the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;
    lvC.pszText = szText;

    // Add the columns.
    for ( iCount = 0; iCount < NUM_COLUMNS; iCount++ )
    {
        INT i;

        if ( iCount == 3 )
            continue; // skip "Version"

        if ( !fShowDirectoryColumn && iCount == 4 )
            continue; // skip "Directory"

        lvC.iSubItem = iCount;
        lvC.cx       = uColumnWidth[iCount];

        dw = LoadString( g_hInstance,
                         IDS_OS_COLUMN1 + iCount,
                         szText,
                         ARRAYSIZE(szText));
        Assert( dw );

        i = ListView_InsertColumn ( hwndList, iCount, &lvC );
        Assert( i != -1 );
    }

    ListView_DeleteAllItems( hwndList );

    HRETURN(S_OK);
}


//
// Page1DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page1DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            HRESULT hr;
            WCHAR szFQDNS[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD cbSize = DNS_MAX_NAME_BUFFER_LENGTH;
            IIntelliMirrorSAP * pimsap = NULL;
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;

            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;

            Button_SetCheck( GetDlgItem( hDlg, IDC_B_ADDSIF ), BST_CHECKED );

            Assert( lpc->_punk );
            hr = THR( lpc->_punk->QueryInterface( IID_IIntelliMirrorSAP,
                                                  (void**) &pimsap ) );
            if (hr) {
                goto InitDialog_Error;
            }

            Assert( !lpc->_pszServerName );
            hr = THR( pimsap->GetServerName( &lpc->_pszServerName ) );
            if (hr)
                goto InitDialog_Error;

            GetComputerNameEx( ComputerNameNetBIOS, szFQDNS, &cbSize );
            if ( StrCmpI( szFQDNS, lpc->_pszServerName ) == 0 )
            {
                EnableWindow( GetDlgItem( hDlg, IDC_B_NEWIMAGE ), TRUE );
            }

InitDialog_Error:
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_NEXT );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                if ( Button_GetCheck( GetDlgItem( hDlg, IDC_B_ADDSIF ) )
                        == BST_CHECKED )
                {
                    lpc->_fAddSif = TRUE;
                }
                else if ( Button_GetCheck( GetDlgItem( hDlg, IDC_B_NEWIMAGE ) )
                            == BST_CHECKED )
                {
                    STARTUPINFO startupInfo;
                    PROCESS_INFORMATION pi;
                    BOOL bRet;
                    WCHAR szCommand[] = L"RISETUP.EXE -add";

                    lpc->_fAddSif = FALSE;

                    ZeroMemory( &startupInfo, sizeof( startupInfo) );
                    startupInfo.cb = sizeof( startupInfo );

                    bRet = CreateProcess( NULL,
                                          szCommand,
                                          NULL,
                                          NULL,
                                          TRUE,
                                          NORMAL_PRIORITY_CLASS,
                                          NULL,
                                          NULL,
                                          &startupInfo,
                                          &pi );
                    if ( bRet )
                    {
                        CloseHandle( pi.hProcess );
                        CloseHandle( pi.hThread );
                    }
                    else
                    {
                        DWORD dwErr = GetLastError( );
                        MessageBoxFromError( hDlg,
                                             IDS_RISETUP_FAILED_TO_START,
                                             dwErr );
                    }

                    PropSheet_PressButton( GetParent( hDlg ), PSBTN_FINISH );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;
    }

    return FALSE;
}
//
// Page2DlgProc( )
//
// SIF Selection dialog proc.
//
INT_PTR CALLBACK
THISCLASS::Page2DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    LRESULT lResult;

                    lpc->_fCopyFromSamples   = FALSE;
                    lpc->_fCopyFromLocation  = FALSE;
                    lpc->_fCopyFromServer    = FALSE;

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_FROMSAMPLES ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromSamples = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_SERVER ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromServer = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_LOCATION ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromLocation = TRUE;
                    }

                    if ( !lpc->_fCopyFromLocation
                      && !lpc->_fCopyFromSamples && !lpc->_fCopyFromServer )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LRESULT lResult;

                    lpc->_fCopyFromSamples   = FALSE;
                    lpc->_fCopyFromLocation  = FALSE;
                    lpc->_fCopyFromServer    = FALSE;

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_FROMSAMPLES ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromSamples = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_SERVER ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromServer = TRUE;
                    }

                    lResult = Button_GetCheck( GetDlgItem( hDlg, IDC_B_LOCATION ) );
                    if ( lResult == BST_CHECKED )
                    {
                        lpc->_fCopyFromLocation = TRUE;
                    }

                    Assert( lpc->_fCopyFromLocation
                         || lpc->_fCopyFromSamples
                         || lpc->_fCopyFromServer );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) )
        {
        case IDC_B_FROMSAMPLES:
            if ( HIWORD( wParam ) == BN_CLICKED )
            {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_SERVER:
            if ( HIWORD( wParam ) == BN_CLICKED )
            {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_LOCATION:
            if ( HIWORD( wParam ) == BN_CLICKED )
            {
                LRESULT lResult = Button_GetCheck( hwnd );
                if ( lResult == BST_CHECKED )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        }
        break;
    }

    return FALSE;
}

//
// Page3DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page3DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromServer )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    ULONG uLength =
                        Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_SERVER ) );
                    if ( !uLength )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    CWaitCursor Wait;
                    LPSHARE_INFO_1 psi;
                    HWND hwndEdit = GetDlgItem( hDlg, IDC_E_SERVER );
                    ULONG uLength = Edit_GetTextLength( hwndEdit );
                    Assert( uLength );
                    uLength++;  // add one for the NULL

                    // if we had a previous buffer allocated,
                    // see if we can reuse it
                    if ( lpc->_pszSourceServerName && uLength
                            > wcslen(lpc->_pszSourceServerName) + 1 )
                    {
                        TraceFree( lpc->_pszSourceServerName );
                        lpc->_pszSourceServerName = NULL;
                    }

                    if ( !lpc->_pszSourceServerName )
                    {
                        lpc->_pszSourceServerName =
                            (LPWSTR) TraceAllocString( LMEM_FIXED, uLength );
                        if ( !lpc->_pszSourceServerName )
                            goto PSN_WIZNEXTABORT;
                    }

                    Edit_GetText( hwndEdit, lpc->_pszSourceServerName, uLength );

                    if ( NERR_Success !=
                            NetShareGetInfo( lpc->_pszSourceServerName,
                                             REMINST_SHARE,
                                             1,
                                             (LPBYTE *) &psi ) )
                    {
                        MessageBoxFromStrings( hDlg,
                                               IDS_NOTARISERVER_CAPTION,
                                               IDS_NOTARISERVER_TEXT,
                                               MB_OK );
                        SetFocus( hwndEdit );
                        goto PSN_WIZNEXTABORT;
                    }
                    else
                    {
                        NetApiBufferFree( psi );
                    }

                    break;
PSN_WIZNEXTABORT:
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );
                    return TRUE;
                }
                break;

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_SERVER:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                LONG uLength = Edit_GetTextLength( hwnd );
                if ( !uLength )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                }
                else
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_BROWSE:
            if ( HIWORD( wParam ) == BN_CLICKED )
            {
                _OnSearch( hDlg );
            }
            break;
        }
        break;
    }

    return FALSE;
}

HRESULT
THISCLASS::_OnSearch(
    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (hr)
        goto Error;

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;
    
    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
                      (CLIPFORMAT)g_cfDsObjectNames,
                      NULL,
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
 
        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDN( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVER, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

Error:
    
    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings( 
                        hDlg, 
                        IDS_PROBLEM_SEARCHING_TITLE, 
                        IDS_PROBLEM_SEARCHING_TEXT, 
                        MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}


//
// Page4DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page4DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_SIFS ), TRUE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromServer )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszSourceServerName );
                if ( lpc->_pszSourceServerName )
                {
                    LPWSTR pszStartPath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                   wcslen( lpc->_pszSourceServerName )
                                                   + ARRAYSIZE(SERVER_START_STRING) );
                    if ( pszStartPath )
                    {
                        wsprintf( pszStartPath,
                                  SERVER_START_STRING,
                                  lpc->_pszSourceServerName );
                        lpc->_hDlg = hDlg;
                        lpc->_hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                        lpc->_PopulateTemplatesListView( pszStartPath );
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszSourcePath )
                        TraceFree( lpc->_pszSourcePath );
                        // no need to NULL since it is set below

                    if ( lpc->_pszSourceImage
                      && lpc->_pszSourceImage != lpc->_szNA
                      && lpc->_pszSourceImage != lpc->_szLocation )
                        TraceFree( lpc->_pszSourceImage );
                        // no need to NULL since it is set below

                    lpc->_pszSourcePath  = pSIF->pszFilePath;
                    lpc->_pszSourceImage = pSIF->pszImageFile;
                    pSIF->pszFilePath    = NULL;   // don't free this, we're using it
                    pSIF->pszImageFile   = NULL;   // don't free this, we're using it

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    UINT iItems = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page5DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page5DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_FILEPATH ), MAX_PATH );
            SHAutoComplete(GetDlgItem( hDlg, IDC_E_FILEPATH ), SHACF_AUTOSUGGEST_FORCE_ON | SHACF_FILESYSTEM);
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromLocation )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    ULONG uLength =
                        Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_FILEPATH ) );
                    if ( !uLength )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    HWND  hwndEdit = GetDlgItem( hDlg, IDC_E_FILEPATH );
                    ULONG uLength = Edit_GetTextLength( hwndEdit );
                    DWORD dw;
                    Assert( uLength );
                    uLength++;  // add one for the NULL

                    // if we had a previous buffer allocated,
                    // see if we can reuse it
                    if ( lpc->_pszSourcePath && uLength
                         > wcslen(lpc->_pszSourcePath) + 1 )
                    {
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                    }

                    if ( lpc->_pszSourceImage
                      && lpc->_pszSourceImage != lpc->_szNA
                      && lpc->_pszSourceImage != lpc->_szLocation )
                        TraceFree( lpc->_pszSourceImage );
                        // no need to NULL since it is set below

                    lpc->_pszSourceImage = lpc->_szLocation;

                    if ( !lpc->_pszSourcePath )
                    {
                        lpc->_pszSourcePath =
                            (LPWSTR) TraceAllocString( LMEM_FIXED, uLength );
                        if ( !lpc->_pszSourcePath )
                        {
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 );   // don't change
                            return TRUE;
                        }
                    }

                    Edit_GetText( hwndEdit, lpc->_pszSourcePath, uLength );

                    DWORD dwAttrs = GetFileAttributes( lpc->_pszSourcePath );
                    if ( dwAttrs == 0xFFFFffff )
                    {   // file doesn't exist
                        DWORD dwErr = GetLastError( );
                        MessageBoxFromError( hDlg, NULL, dwErr );
                        TraceFree( lpc->_pszSourcePath );
                        lpc->_pszSourcePath = NULL;
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                        return TRUE;
                    }
                    else
                    {   // the SIF image must be a "FLAT" image
                        WCHAR szImageType[ 40 ];

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_IMAGETYPE_ENTRY,
                                                 L"",
                                                 szImageType,
                                                 ARRAYSIZE(szImageType),
                                                 lpc->_pszSourcePath );

                        if ( StrCmpI( szImageType, OSCHOOSER_IMAGETYPE_FLAT ) )
                        {
                            MessageBoxFromStrings( hDlg,
                                                   IDS_MUST_BE_FLAT_CAPTION,
                                                   IDS_MUST_BE_FLAT_TEXT,
                                                   MB_OK );
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                            return TRUE;
                        }

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_DESCRIPTION_ENTRY,
                                                 L"",
                                                 lpc->_szDescription,
                                                 ARRAYSIZE(lpc->_szDescription),
                                                 lpc->_pszSourcePath );

                        GetPrivateProfileString( OSCHOOSER_SIF_SECTION,
                                                 OSCHOOSER_HELPTEXT_ENTRY,
                                                 L"",
                                                 lpc->_szHelpText,
                                                 ARRAYSIZE(lpc->_szHelpText),
                                                 lpc->_pszSourcePath );
                    }
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_FILEPATH:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                LONG uLength = Edit_GetTextLength( hwnd );
                if ( !uLength )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                }
                else
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;

        case IDC_B_BROWSE:
            if ( HIWORD( wParam ) == BN_CLICKED )
            {
                WCHAR szFilter[ 80 ]; // random
                WCHAR szFilepath[ MAX_PATH ] = { L'\0' };   // bigger?
                WCHAR szSIF[ ] = { L"SIF" };
                DWORD dw;
                OPENFILENAME ofn;

                // Build OpenFileName dialogs filter
                ZeroMemory( szFilter, sizeof(szFilter) );
                dw = LoadString( g_hInstance,
                                 IDS_OFN_SIF_FILTER,
                                 szFilter,
                                 ARRAYSIZE(szFilter) );
                Assert( dw );
                dw++;   // include NULL character
                wcscat( &szFilter[dw], L"*.SIF" );
#ifdef DEBUG
                // paranoid... make sure it fits!
                dw += wcslen( &szFilter[dw] ) + 2; // +2 = one for each NULL character
                Assert( dw + 2 <= sizeof(szFilter) );
#endif // DEBUG

                // Build OpenFileName structure
                ZeroMemory( &ofn, sizeof(ofn) );
                ofn.lStructSize = sizeof(ofn);
                ofn.hwndOwner   = hDlg;
                ofn.hInstance   = g_hInstance;
                ofn.lpstrFilter = szFilter;
                ofn.lpstrFile   = szFilepath;
                ofn.nMaxFile    = ARRAYSIZE(szFilepath);
                ofn.Flags       = OFN_ENABLESIZING | OFN_FILEMUSTEXIST
                                | OFN_HIDEREADONLY;
                ofn.lpstrDefExt = szSIF;
                if ( GetOpenFileName( &ofn ) )
                {
                    SetDlgItemText( hDlg, IDC_E_FILEPATH, szFilepath );
                    return TRUE;
                }
            }
            break;
        }
        break;
    }

    return FALSE;
}

//
// Page6DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page6DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_OSES ), FALSE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszServerName );
                if ( lpc->_pszServerName )
                {
                    LPWSTR pszStartPath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                   wcslen( lpc->_pszServerName )
                                                   + ARRAYSIZE(SERVER_START_STRING) );
                    if ( pszStartPath )
                    {
                        wsprintf( pszStartPath,
                                  SERVER_START_STRING,
                                  lpc->_pszServerName );
                        lpc->_hDlg = hDlg;
                        lpc->_hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                        lpc->_PopulateImageListView( pszStartPath );
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszDestPath)
                        TraceFree( lpc->_pszDestPath );
                        // no need to NULL - it set again below

                    lpc->_pszDestPath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                   wcslen( pSIF->pszFilePath )
                                                   + ARRAYSIZE(SLASH_TEMPLATES) );
                    if ( !lpc->_pszDestPath )
                    {
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue;
                        return TRUE;
                    }

                    wcscpy( lpc->_pszDestPath, pSIF->pszFilePath );
                    wcscat( lpc->_pszDestPath, SLASH_TEMPLATES );
                    lpc->_fDestPathIncludesSIF = FALSE;

                    if ( lpc->_pszDestImage
                      && lpc->_pszDestImage != lpc->_szNA )
                        TraceFree( lpc->_pszDestImage );
                        // no need to NULL - it set again below

                    lpc->_pszDestImage = pSIF->pszImageFile;
                    pSIF->pszImageFile = NULL; // don't free this

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_OSES );
                    UINT iItems =
                        ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page7DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page7DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            lpc = (LPTHISCLASS) ppsp->lParam;
            THR( lpc->_InitListView( GetDlgItem( hDlg, IDC_L_SIFS ), FALSE ) );
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif || !lpc->_fCopyFromSamples )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                Assert( lpc->_pszDestPath );
                if ( lpc->_pszDestPath )
                {
                    LPWSTR pszStartPath =
                        (LPWSTR) TraceStrDup( lpc->_pszDestPath );
                    if ( pszStartPath )
                    {
                        // remove the "\templates" from the path
                        LPWSTR psz = StrRChr( pszStartPath,
                                              &pszStartPath[wcslen(pszStartPath)],
                                              L'\\' );
                        Assert( psz );
                        if ( psz )
                        {
                            *psz = L'\0'; // terminate
                            lpc->_hDlg = hDlg;
                            lpc->_hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                            lpc->_PopulateSamplesListView( pszStartPath );
                            *psz = L'\\'; // restore
                        }
                        TraceFree( pszStartPath );
                    }
                }
                PropSheet_SetWizButtons( GetParent( hDlg ), PSWIZB_BACK );
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    LVITEM lvi;
                    DWORD  dw;
                    HWND   hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    lvi.iItem = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    Assert( lvi.iItem != -1 );

                    lvi.iSubItem = 0;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( hwndList, &lvi );
                    Assert(lvi.lParam);

                    LPSIFINFO pSIF = (LPSIFINFO) lvi.lParam;

                    if ( lpc->_pszSourcePath )
                        TraceFree( lpc->_pszSourcePath );
                        // no need to NULL - it is set again below

                    if ( lpc->_pszSourceImage
                      && lpc->_pszSourceImage != lpc->_szNA
                      && lpc->_pszSourceImage != lpc->_szLocation )
                        TraceFree( lpc->_pszSourceImage );
                        // no need to NULL since it is set below

                    lpc->_pszSourcePath  = pSIF->pszFilePath;
                    lpc->_pszSourceImage = pSIF->pszImageFile;

                    if ( pSIF->pszDescription )
                    {
                        wcscpy( lpc->_szDescription, pSIF->pszDescription );
                    }
                    else
                    {
                        lpc->_szDescription[0] = L'\0';
                    }

                    if ( pSIF->pszHelpText )
                    {
                        wcscpy( lpc->_szHelpText, pSIF->pszHelpText );
                    }
                    else
                    {
                        lpc->_szHelpText[0] = L'\0';
                    }

                    pSIF->pszFilePath    = NULL;    // don't free this, we're using it
                    pSIF->pszImageFile   = NULL;    // don't free this, we're using it

                    ListView_DeleteAllItems( hwndList );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );

            case LVN_DELETEALLITEMS:
                TraceMsg( TF_WM, "LVN_DELETEALLITEMS - Deleting all items.\n" );
                break;

            case LVN_DELETEITEM:
                TraceMsg( TF_WM, "LVN_DELETEITEM - Deleting an item.\n" );
                {
                    LPNMLISTVIEW pnmv = (LPNMLISTVIEW) lParam;
                    LPSIFINFO pSIF = (LPSIFINFO) pnmv->lParam;
                    THR( lpc->_CleanupSIFInfo( pSIF ) );
                }
                break;

            case LVN_ITEMCHANGED:
                {
                    HWND hwndList = GetDlgItem( hDlg, IDC_L_SIFS );
                    UINT iItems = ListView_GetNextItem( hwndList, -1, LVNI_SELECTED );
                    if ( iItems != -1 )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                }
                break;
            }
        }
        break;
    }

    return FALSE;
}

//
// Page8DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page8DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    Assert( lpc->_pszSourcePath );
                    Assert( lpc->_pszDestPath );

                    LPWSTR pszDestFilePath;
                    ULONG  uDestLength = wcslen( lpc->_pszDestPath );
                    LPWSTR pszFilename;

                    lpc->_fSIFCanExist = FALSE; // reset

                    if ( lpc->_fDestPathIncludesSIF )
                    {   // strip the filename
                        LPWSTR psz = StrRChr( lpc->_pszDestPath,
                                             &lpc->_pszDestPath[ uDestLength ],
                                             L'\\' );
                        Assert(psz);
                        *psz = L'\0';   // truncate
                        lpc->_fDestPathIncludesSIF = FALSE;

                        if ( !lpc->_fShowedPage8 )
                        {
                            SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                            return TRUE;
                        }

                        psz++;
                        pszFilename = psz;
                    }
                    else
                    {
                        pszFilename =
                            StrRChr( lpc->_pszSourcePath,
                                     &lpc->_pszSourcePath[wcslen(lpc->_pszSourcePath)],
                                     L'\\' );
                        Assert( pszFilename );
                        pszFilename++;  // move past the '\'

                        pszDestFilePath =
                            (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                       uDestLength + 1
                                                       + wcslen( pszFilename ) + 1 );
                        if ( pszDestFilePath )
                        {
                            wcscpy( pszDestFilePath, lpc->_pszDestPath );
                            wcscat( pszDestFilePath, L"\\" );
                            wcscat( pszDestFilePath, pszFilename );

                            DWORD dwAttrs = GetFileAttributes( pszDestFilePath );
                            if ( dwAttrs == 0xFFFFffff )
                            { // file does not exist on destination server.
                              // Use the same SIF as the source.
                                TraceFree( lpc->_pszDestPath );
                                lpc->_pszDestPath = pszDestFilePath;
                                lpc->_fDestPathIncludesSIF = TRUE;
                                SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                                return TRUE;
                            }
                            TraceFree( pszDestFilePath );
                        }
                        // else be paranoid and prompt for a name
                    }

                    HWND hwnd = GetDlgItem( hDlg, IDC_E_FILENAME );
                    Edit_LimitText( hwnd, 128 - uDestLength );
                    Edit_SetText( hwnd, pszFilename );
                    lpc->_fShowedPage8 = TRUE;
                }
                break;

            case PSN_WIZBACK:
                lpc->_fShowedPage8 = FALSE;     // reset this
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    Assert( lpc->_pszDestPath );
                    Assert( !lpc->_fDestPathIncludesSIF );

                    HWND  hwndEdit    = GetDlgItem( hDlg, IDC_E_FILENAME );
                    ULONG uLength     = Edit_GetTextLength( hwndEdit );
                    ULONG uLengthDest = wcslen( lpc->_pszDestPath );
                    DWORD dwAttrs;

                    Assert( uLength );
                    AssertMsg( uLengthDest + uLength <= 128,
                               "The Edit_LimitText() should prevent this from happening." );

                    uLength++;  // add one for the NULL

                    LPWSTR pszNewDestPath =
                        (LPWSTR) TraceAllocString( LMEM_FIXED,
                                                   uLengthDest + 1 + uLength );
                    if ( !pszNewDestPath )
                        goto PSN_WIZNEXT_Abort;

                    wcscpy( pszNewDestPath, lpc->_pszDestPath );
                    wcscat( pszNewDestPath, L"\\" );

                    Edit_GetText( hwndEdit, &pszNewDestPath[uLengthDest + 1], uLength );

                    if ( !VerifySIFText( pszNewDestPath )
                      || StrChr( pszNewDestPath, 32 ) != NULL ) // no spaces!
                    {
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TITLE,
                                               IDS_OSCHOOSER_DIRECTORY_RESTRICTION_TEXT,
                                               MB_OK );
                        goto PSN_WIZNEXT_Abort;
                    }

                    // make sure it doesn't exist.
                    dwAttrs = GetFileAttributes( pszNewDestPath );
                    if ( dwAttrs != 0xFFFFffff )
                    { // file exists, verify with user to overwrite
                        UINT i = MessageBoxFromStrings( hDlg,
                                                        IDS_OVERWRITE_CAPTION,
                                                        IDS_OVERWRITE_TEXT,
                                                        MB_YESNO );
                        if ( i == IDNO )
                        {
                            goto PSN_WIZNEXT_Abort;
                        }
                        else
                        {
                            lpc->_fSIFCanExist = TRUE;
                        }
                    }

                    uLength = wcslen( pszNewDestPath );
                    if ( StrCmpI( &pszNewDestPath[ uLength - 4 ], L".SIF" ) != 0 )
                    {
                        UINT i = MessageBoxFromStrings( hDlg,
                                                        IDC_IMPROPER_EXTENSION_CAPTION,
                                                        IDC_IMPROPER_EXTENSION_TEXT,
                                                        MB_YESNO );
                        if ( i == IDNO )
                            goto PSN_WIZNEXT_Abort;
                    }

                    TraceFree( lpc->_pszDestPath );
                    lpc->_pszDestPath = pszNewDestPath;
                    lpc->_fDestPathIncludesSIF = TRUE;
                    return FALSE; // do it
PSN_WIZNEXT_Abort:
                    if ( pszNewDestPath )
                        TraceFree( pszNewDestPath );
                        // no need to NULL, going out of scope
                    SetFocus( hwndEdit );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue
                    return TRUE;
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        HWND hwnd = (HWND) lParam;
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_FILENAME:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                LONG uLength = Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_FILENAME ) );
                if ( !uLength )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                }
                else
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}

//
// Page9DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page9DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_DESCRIPTION ),
                            ARRAYSIZE(lpc->_szDescription) - 1 );
            Edit_LimitText( GetDlgItem( hDlg, IDC_E_HELPTEXT),
                            ARRAYSIZE(lpc->_szHelpText) - 1 );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    Assert( lpc->_pszSourcePath );
                    SetDlgItemText( hDlg, IDC_E_DESCRIPTION, lpc->_szDescription);
                    SetDlgItemText( hDlg, IDC_E_HELPTEXT, lpc->_szHelpText );
                    if ( !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) )
                      || !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT ) ) )
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK );
                    }
                    else
                    {
                        PropSheet_SetWizButtons( GetParent( hDlg ),
                                                 PSWIZB_BACK | PSWIZB_NEXT );
                    }
                }
                break;

            case PSN_WIZNEXT:
                TraceMsg( TF_WM, "PSN_WIZNEXT\n" );
                {
                    GetDlgItemText( hDlg,
                                    IDC_E_DESCRIPTION,
                                    lpc->_szDescription,
                                    ARRAYSIZE(lpc->_szDescription) );
                    GetDlgItemText( hDlg,
                                    IDC_E_HELPTEXT,
                                    lpc->_szHelpText,
                                    ARRAYSIZE(lpc->_szHelpText) );
                    if ( !VerifySIFText( lpc->_szDescription ) )
                    {
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                               MB_OK );
                        SetFocus( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't change
                        return TRUE;
                    }

                    if ( !VerifySIFText( lpc->_szHelpText ) )
                    {
                        MessageBoxFromStrings( hDlg,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TITLE,
                                               IDS_OSCHOOSER_RESTRICTION_FIELDS_TEXT,
                                               MB_OK );
                        SetFocus( GetDlgItem( hDlg, IDC_E_HELPTEXT ) );
                        SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't change
                        return TRUE;
                    }
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;

    case WM_COMMAND:
        TraceMsg( TF_WM, "WM_COMMAND\n" );
        switch ( LOWORD( wParam ) )
        {
        case IDC_E_DESCRIPTION:
        case IDC_E_HELPTEXT:
            if ( HIWORD( wParam ) == EN_CHANGE )
            {
                if ( !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_DESCRIPTION ) )
                  || !Edit_GetTextLength( GetDlgItem( hDlg, IDC_E_HELPTEXT ) ) )
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK );
                }
                else
                {
                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_NEXT );
                }
                return TRUE;
            }
            break;
        }
        break;
    }

    return FALSE;
}


//
// Page10DlgProc( )
//
INT_PTR CALLBACK
THISCLASS::Page10DlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    LPTHISCLASS lpc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    switch ( uMsg )
    {
    case WM_INITDIALOG:
        TraceMsg( TF_WM, "WM_INITDIALOG\n" );
        {
            LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE) lParam;
            Assert( ppsp );
            Assert( ppsp->lParam );
            SetWindowLongPtr( hDlg, GWLP_USERDATA, ppsp->lParam );
            // lpc = (LPTHISCLASS) ppsp->lParam;
            return TRUE;
        }
        break;

    case WM_NOTIFY:
        {
            LPNMHDR lpnmhdr = (LPNMHDR) lParam;
            Assert( lpc );

            switch( lpnmhdr->code )
            {
            case PSN_SETACTIVE:
                TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
                if ( !lpc->_fAddSif )
                {
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't show
                    return TRUE;
                }
                else
                {
                    WCHAR szTemp[ MAX_PATH ];
                    RECT  rect;

                    Assert( lpc->_pszSourcePath );
                    Assert( lpc->_pszDestPath );
                    Assert( lpc->_pszSourceImage );
                    Assert( lpc->_pszDestImage );

                    SetDlgItemText( hDlg, IDC_E_SOURCE, lpc->_pszSourcePath );

                    wcscpy( szTemp, lpc->_pszSourceImage );
                    GetWindowRect( GetDlgItem( hDlg, IDC_S_SOURCEIMAGE ), &rect );
                    PathCompactPath( NULL, szTemp, rect.right - rect.left );
                    SetDlgItemText( hDlg, IDC_S_SOURCEIMAGE, szTemp );

                    SetDlgItemText( hDlg, IDC_E_DESTINATION, lpc->_pszDestPath );

                    wcscpy( szTemp, lpc->_pszDestImage );
                    GetWindowRect( GetDlgItem( hDlg, IDC_S_DESTIMAGE ), &rect );
                    PathCompactPath( NULL, szTemp, rect.right - rect.left );
                    SetDlgItemText( hDlg, IDC_S_DESTIMAGE, szTemp );

                    PropSheet_SetWizButtons( GetParent( hDlg ),
                                             PSWIZB_BACK | PSWIZB_FINISH );
                }
                break;

            case PSN_WIZFINISH:
                TraceMsg( TF_WM, "PSN_WIZFINISH\n" );
                Assert( lpc->_pszSourcePath );
                Assert( lpc->_pszDestPath );
                Assert( wcslen( lpc->_pszSourcePath ) <= MAX_PATH );
                Assert( wcslen( lpc->_pszDestPath ) <= MAX_PATH );
                if ( !CopyFile( lpc->_pszSourcePath, lpc->_pszDestPath, !lpc->_fSIFCanExist ) )
                {
                    DWORD dwErr = GetLastError( );
                    MessageBoxFromError( hDlg, IDS_ERROR_COPYING_FILE, dwErr );
                    SetWindowLongPtr( hDlg, DWLP_MSGRESULT, -1 ); // don't continue;
                    return TRUE;
                }
                else
                {
                    WCHAR szTemp[ REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT + 2 ];
                    Assert( REMOTE_INSTALL_MAX_DESCRIPTION_CHAR_COUNT
                            < REMOTE_INSTALL_MAX_HELPTEXT_CHAR_COUNT );
                    wsprintf( szTemp, L"\"%s\"", lpc->_szDescription );
                    WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                               OSCHOOSER_DESCRIPTION_ENTRY,
                                               szTemp,
                                               lpc->_pszDestPath );
                    wsprintf( szTemp, L"\"%s\"", lpc->_szHelpText );
                    WritePrivateProfileString( OSCHOOSER_SIF_SECTION,
                                               OSCHOOSER_HELPTEXT_ENTRY,
                                               szTemp,
                                               lpc->_pszDestPath );
                }
                break;

            case PSN_QUERYCANCEL:
                TraceMsg( TF_WM, "PSN_QUERYCANCEL\n" );
                return lpc->_VerifyCancel( hDlg );
            }
        }
        break;
    }

    return FALSE;
}


//
// Verifies that the user wanted to cancel setup.
//
INT
THISCLASS::_VerifyCancel( HWND hParent )
{
    TraceClsFunc( "_VerifyCancel( ... )\n" );

    INT iReturn;
    BOOL fAbort = FALSE;

    iReturn = MessageBoxFromStrings( hParent,
                                     IDS_CANCELCAPTION,
                                     IDS_CANCELTEXT,
                                     MB_YESNO | MB_ICONQUESTION );
    if ( iReturn == IDYES ) {
        fAbort = TRUE;
    }

    SetWindowLongPtr( hParent, DWLP_MSGRESULT, ( fAbort ? 0 : -1 ));

    RETURN(!fAbort);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\ccomputr.h ===
//
// Copyright 1997 - Microsoft
//

//
// CComputr.H - Computer properties class
//

#ifndef _CCOMPUTR_H_
#define _CCOMPUTR_H_

#include <adsprop.h>

// QITable
BEGIN_QITABLE( CComputer )
DEFINE_QI( IID_IShellExtInit,      IShellExtInit      , 1 )
DEFINE_QI( IID_IShellPropSheetExt, IShellPropSheetExt , 2 )
DEFINE_QI( IID_IMAO,               IMAO               , 11 )
END_QITABLE

// Definitions
LPVOID
CComputer_CreateInstance( void );

LPVOID
CreateIntelliMirrorClientComputer( 
    IADs * pads);

// Error Codes
#define E_INVALIDSTATE TYPE_E_INVALIDSTATE

// Private IMAO Interface Definition
class
IMAO:
    public IUnknown
{
public:
    STDMETHOD(CommitChanges)( void ) PURE;                          // 1
    STDMETHOD(IsAdmin)( BOOL *fAdmin ) PURE;                        // 2
    STDMETHOD(IsServer)( BOOL *fServer ) PURE;                      // 3
    STDMETHOD(IsClient)( BOOL *fClient ) PURE;                      // 4
    STDMETHOD(SetServerName)( LPWSTR ppszName ) PURE;               // 5
    STDMETHOD(GetServerName)( LPWSTR * ppszName ) PURE;             // 6
    STDMETHOD(SetGUID)( LPWSTR ppGUID ) PURE;                       // 7
    STDMETHOD(GetGUID)( LPWSTR * ppszGUID, LPBYTE uGUID ) PURE;     // 8
    STDMETHOD(GetSAP)( LPVOID * punk ) PURE;                        // 9
    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj ) PURE;       // 10
    STDMETHOD(GetNotifyWindow)( HWND *phNotifyObj ) PURE;           // 11
};

// CComputer
class 
CComputer:
    public IShellExtInit, IShellPropSheetExt, IMAO
{
private:
    // Enums
    enum { 
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CComputer );

    UINT  _uMode;               // Admin or Shell mode

    LPDATAOBJECT _pDataObj;     // Data Object passed to ServerTab
    LPWSTR       _pszObjectName;// DN of the object

    IADs *   _pads;             // ADs to MAO    
    VARIANT  _vGUID;
    VARIANT  _vMachineFilepath;
    VARIANT  _vInitialization;
    VARIANT  _vSCP;

    HWND     _hwndNotify;       // DS notify window handle

    ADSPROPINITPARAMS _InitParams; // DSA init params

private: // Methods
    CComputer();
    ~CComputer();
    STDMETHOD(Init)();
    STDMETHOD(Init2)( IADs * pads );
    HRESULT _FixObjectPath( LPWSTR pszOldObjectPath, LPWSTR *ppszNewObjectPath );

public: // Methods
    friend LPVOID CComputer_CreateInstance( void );
    friend LPVOID CreateIntelliMirrorClientComputer( IADs * pads);

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IShellExtInit
    STDMETHOD(Initialize)( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage) ( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam);

    // IMAO
    STDMETHOD(CommitChanges)( void );
    STDMETHOD(IsAdmin)( BOOL *fAdmin );
    STDMETHOD(IsServer)( BOOL *fServer );
    STDMETHOD(IsClient)( BOOL *fClient );
    STDMETHOD(SetServerName)( LPWSTR ppszName );
    STDMETHOD(GetServerName)( LPWSTR * ppszName );
    STDMETHOD(SetGUID)( LPWSTR ppGUID );
    STDMETHOD(GetGUID)( LPWSTR * ppszGUID, LPBYTE uGUID );
    STDMETHOD(GetSAP)( LPVOID *punk );
    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj );
    STDMETHOD(GetNotifyWindow)( HWND *phNotifyObj );
};

typedef CComputer* LPCOMPUTER;

#endif // _CCOMPUTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cenumsif.cpp ===
//
// Copyright 1997 - Microsoft

//
// CENUMSIF.CPP - Handles enumerating OSes and Tools SIFs from DS
//

#include "pch.h"

#include "cenumsif.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CEnumIMSIFs")
#define THISCLASS CEnumIMSIFs
#define LPTHISCLASS LPENUMSIFS

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CEnumIMSIFs_CreateInstance( 
    LPWSTR pszEnumPath,
    LPWSTR pszAttribute, 
    DWORD dwFlags, 
    IADs * pads )
{
	TraceFunc( "CEnumIMSIFs_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( pszEnumPath, pszAttribute, dwFlags, pads ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CEnumIMSIFs()\n" );

	InterlockIncrement( g_cObjects );
    
    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( 
    LPWSTR pszEnumPath,
    LPWSTR pszAttribute, 
    DWORD dwFlags, 
    IADs * pads )
{
    TraceClsFunc( "Init()\n" );

    HRESULT hr = S_OK;
    LPWSTR  psz;
    VARIANT var;

    VariantInit( &var );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CEnumIMSIFs, IEnumIMSIFs );
    QITABLE_IMP( IEnumIMSIFs );
    END_QITABLE_IMP( CEnumIMSIFs );
    Assert( _cRef == 0);
    AddRef( );

    // Private Members
    Assert( _iIndex == 0 );
    Assert( !_pszLanguage );
    Assert( !_pszOS );
    Assert( !_pszArchitecture );
    Assert( !_pszSIF );

    pads->AddRef( );
    _pads = pads;

    hr = THR( _pads->Get( NETBOOTSERVER, &var ) );
    if (hr)
        goto Error;

    psz = V_BSTR( &var );
    hr = THR( DNtoFQDN( psz, &_pszServerName ) );
    if (hr) 
        goto Error;

    _dwFlags = dwFlags;

    _pszAttribute = (LPWSTR) TraceStrDup( pszAttribute );
    if ( !_pszAttribute )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    _pszEnumPath = (LPWSTR) TraceStrDup( pszEnumPath );
    if ( !_pszEnumPath )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    _hLanguage     = INVALID_HANDLE_VALUE;
    _hOS           = INVALID_HANDLE_VALUE;
    _hArchitecture = INVALID_HANDLE_VALUE;
    _hSIF          = INVALID_HANDLE_VALUE;

Error:  // Destructor will handle cleanup
    VariantClear( &var );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CEnumIMSIFs()\n" );

    // Private Members
    if ( _pads )
    {
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
        _pads->Release( );
    }

    if ( _pszAttribute )
        TraceFree( _pszAttribute );

    if ( _pszEnumPath )
        TraceFree( _pszEnumPath );

    if ( _hLanguage != INVALID_HANDLE_VALUE )
        FindClose( _hLanguage );

    if ( _hOS != INVALID_HANDLE_VALUE )
        FindClose( _hOS );

    if ( _hSIF != INVALID_HANDLE_VALUE )
        FindClose( _hSIF  );

    if ( _pszLanguage )
        TraceFree( _pszLanguage );

    if ( _pszOS )
        TraceFree( _pszOS );

    if ( _pszSIF )
        TraceFree( _pszSIF );

    if ( _pszServerName )
        TraceFree( _pszServerName );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "[IUnknown] QueryInterface( riid=" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IEnumIMSIFs
//
// ************************************************************************

//
// Next( )
//
HRESULT 
THISCLASS::Next( 
    ULONG celt, 
    LPWSTR * rgelt, 
    ULONG * pceltFetched )
{
    TraceClsFunc( "[IEnumIMSIFs] Next( ... )\n" );

    if ( !rgelt )
        RRETURN(E_POINTER);

    HRESULT hr;

    if (pceltFetched)
        *pceltFetched = 0;

    if ( _fWrite )
    {
        hr = THR(E_NOTIMPL);
    }
    else    // READ
    {
        for ( ULONG ul = 0; ul < celt; ul++ )
        {
            hr = _FindNextItem( &rgelt[ ul ] );
            if (hr)
                goto Error;
        }

        if (pceltFetched)
            *pceltFetched = ul;
    }


Cleanup:
    HRETURN(hr);

Error:
    goto Cleanup;
}


//
// Skip( )
//
HRESULT 
THISCLASS::Skip( 
    ULONG celt  )
{
    TraceClsFunc( "[IEnumIMSIFs] Skip( ... )\n" );

    HRESULT hr = S_OK;

    for( ULONG ul = 0; ul < celt; ul++ )
    {
        _iIndex++;

        hr = THR( _FindNextItem( NULL ) );
        if ( hr == E_POINTER )
        {   // expected result
            hr = S_OK;
        }
        else if (hr)
            goto Error;
    }

Error:
    HRETURN(hr);
}


//
// Reset( )
//
HRESULT 
THISCLASS::Reset( void )
{
    TraceClsFunc( "[IEnumIMSIFs] Reset( ... )\n" );

    HRESULT hr = S_OK;

    _iIndex = 0;
    
    if ( _hLanguage != INVALID_HANDLE_VALUE )
    {
        FindClose( _hLanguage );
        _hLanguage = INVALID_HANDLE_VALUE;
    }

    if ( _hOS != INVALID_HANDLE_VALUE )
    {
        FindClose( _hOS );
        _hOS = INVALID_HANDLE_VALUE;
    }

    if ( _hArchitecture )
    {
        FindClose( _hArchitecture );
        _hArchitecture = INVALID_HANDLE_VALUE;
    }

    if ( _hSIF )
    {
        FindClose( _hSIF );
        _hSIF = INVALID_HANDLE_VALUE;
    }

    HRETURN(hr);
}


//
// Clone( )
//
HRESULT 
THISCLASS::Clone( 
    LPUNKNOWN * ppenum )
{
    TraceClsFunc( "[IEnumIMSIFs] Clone( ... )\n" );

    if ( !ppenum )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    *ppenum = (LPUNKNOWN) CEnumIMSIFs_CreateInstance( _pszEnumPath, 
                                                      _pszAttribute,
                                                      _dwFlags,
                                                      _pads );

    if ( !*ppenum )
    {
        hr = THR(E_FAIL);
    }

    HRETURN(hr);
}


// ************************************************************************
//
// Privates
//
// ************************************************************************


//
// _FindNextItem( )
//
HRESULT
THISCLASS::_FindNextItem(
    LPWSTR * ppszFileName )
{
    TraceClsFunc( "_FindNextItem( ... )\n" );

    HRESULT hr = S_FALSE;
    WCHAR   szFilePath[ MAX_PATH ];

    if ( _hLanguage == INVALID_HANDLE_VALUE )
    {
        hr = _NextLanguage( );
        if (hr)
            goto Error;
    }

    if ( _hOS == INVALID_HANDLE_VALUE )
    {
        hr = _NextOS( );
        if (hr)
            goto Error;
    }

    if ( _hArchitecture == INVALID_HANDLE_VALUE )
    {
        hr = _NextArchitecture( );
        if (hr)
            goto Error;
    }

    hr = _NextSIF( );
    if (hr)
        goto Error;

    // NOTE: Skip( ) passes NULL in to "skip" and should except this error.
    if ( !ppszFileName )
        HRETURN(E_POINTER);

    // Create a buffer
    //            1               2           3
    // 12  345678901234567  8  9  0  12345678901  = 31 + NULL = 32
    // \\%s\REMINST\SETUP\%s\%s\%s\%s\templates\%s
    *ppszFileName = (LPWSTR ) TraceAllocString( LMEM_FIXED, 32 
                                                            + wcslen( _pszServerName ) 
                                                            + wcslen( _pszLanguage ) 
                                                            + wcslen( _pszEnumPath ) 
                                                            + wcslen( _pszOS )
                                                            + wcslen( _pszArchitecture )
                                                            + wcslen( _pszSIF ) );
    if ( !*ppszFileName )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    wsprintf( *ppszFileName, 
              L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\%s" SLASH_TEMPLATES L"\\%s",
              _pszServerName,
              _pszLanguage,
              _pszEnumPath,
              _pszOS,
              _pszArchitecture,
              _pszSIF );

    hr = S_OK;

Cleanup:
    HRETURN(hr);

Error:
    *ppszFileName = NULL;
    goto Cleanup;
}

//
// _NextLanguage( )
//
HRESULT
THISCLASS::_NextLanguage( )
{
    TraceClsFunc( "_NextLanguage( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszLanguage )
    {
        TraceFree( _pszLanguage );
        _pszLanguage = NULL;
    }

    if ( _hLanguage == INVALID_HANDLE_VALUE )
    {
        WCHAR szFilePath[ MAX_PATH ];

        wsprintf( szFilePath, 
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\*",
                  _pszServerName );

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hLanguage = FindFirstFile( szFilePath, &fd );
        if ( _hLanguage == INVALID_HANDLE_VALUE )
            goto TryAgain;

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hLanguage, &fd ) )
    {
        if ( fd.cFileName[0] != L'.' )
        {
            _pszLanguage = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszLanguage )
            {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

Cleanup:
    HRETURN(hr);

TryAgain:
    goto Cleanup;
}

//
// _NextOS( )
//
HRESULT
THISCLASS::_NextOS( )
{
    TraceClsFunc( "_NextOS( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszOS )
    {
        TraceFree( _pszOS );
        _pszOS = NULL;
    }

    if ( _hOS == INVALID_HANDLE_VALUE )
    {
        WCHAR szFilePath[ MAX_PATH ];

        wsprintf( szFilePath, 
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\*",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath );

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hOS = FindFirstFile( szFilePath, &fd );
        if ( _hOS == INVALID_HANDLE_VALUE )
            goto TryAgain;

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hOS, &fd ) )
    {
        if ( fd.cFileName[0] != L'.' )
        {
            _pszOS = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszOS )
            {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

    if (hr)
        goto TryAgain;

Cleanup:
    HRETURN(hr);

TryAgain:
    if ( _hOS != INVALID_HANDLE_VALUE )
    {
        FindClose( _hOS );
        _hOS = INVALID_HANDLE_VALUE;
        
    }

    hr = _NextLanguage( );
    if (hr)
        goto Cleanup;

    hr = _NextOS( ); // recurse
    goto Cleanup;
}

//
// _NextArchitecture( )
//
HRESULT
THISCLASS::_NextArchitecture( )
{
    TraceClsFunc( "_NextArchitecture( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszArchitecture )
    {
        TraceFree( _pszArchitecture );
        _pszArchitecture = NULL;
    }

    if ( _hArchitecture == INVALID_HANDLE_VALUE )
    {
        WCHAR szFilePath[ MAX_PATH ];

        wsprintf( szFilePath, 
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\*",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath,
                  _pszOS );

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hArchitecture = FindFirstFile( szFilePath, &fd );
        if ( _hArchitecture == INVALID_HANDLE_VALUE )
            goto TryAgain;

        Assert( fd.cFileName[0] == L'.' );
        // we skip the first one because it should be the "." file
    }

    while ( FindNextFile( _hArchitecture, &fd ) )
    {
        if ( fd.cFileName[0] != L'.' )
        {
            _pszArchitecture = (LPWSTR) TraceStrDup( fd.cFileName );
            if ( !_pszArchitecture )
            {
                hr = THR(E_OUTOFMEMORY);
                goto Cleanup;
            }

            hr = S_OK;
            break;
        }
    }

    if (hr)
        goto TryAgain;

Cleanup:
    HRETURN(hr);

TryAgain:
    if ( _hArchitecture != INVALID_HANDLE_VALUE )
    {
        FindClose( _hArchitecture );
        _hArchitecture = INVALID_HANDLE_VALUE;
    }

    hr = _NextOS( );
    if (hr)
        goto Cleanup;

    hr = _NextArchitecture( ); // recurse
    goto Cleanup;
}

//
// _NextSIF( )
//
HRESULT
THISCLASS::_NextSIF( )
{
    TraceClsFunc( "_NextSIF( ... )\n" );

    HRESULT hr = S_FALSE;
    WIN32_FIND_DATA fd;

    if ( _pszSIF )
    {
        TraceFree( _pszSIF );
        _pszSIF = NULL;
    }

    if ( _hSIF == INVALID_HANDLE_VALUE )
    {
        WCHAR szFilePath[ MAX_PATH ];

        wsprintf( szFilePath, 
                  L"\\\\%s\\" REMINST_SHARE SLASH_SETUP L"\\%s\\%s\\%s\\%s" SLASH_TEMPLATES L"\\*.sif",
                  _pszServerName,
                  _pszLanguage,
                  _pszEnumPath,
                  _pszOS,
                  _pszArchitecture );

        DebugMsg( "Enumerating %s...\n", szFilePath );

        _hSIF = FindFirstFile( szFilePath, &fd );
        if ( _hSIF == INVALID_HANDLE_VALUE )
            goto TryAgain;
    }
    else
    {
        if ( !FindNextFile( _hSIF, &fd ) )
            goto TryAgain;
    }

    _pszSIF = (LPWSTR) TraceStrDup( fd.cFileName );
    if ( !_pszSIF )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    hr = S_OK;

Cleanup:
    HRETURN(hr);

TryAgain:
    if ( _hSIF != INVALID_HANDLE_VALUE )
    {
        FindClose( _hSIF );
        _hSIF = INVALID_HANDLE_VALUE;
    }

    hr = _NextArchitecture( );
    if (hr)
        goto Cleanup;

    hr = _NextSIF( ); // recurse
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cfactory.h ===
//
// Copyright 1997 - Microsoft
//

//
// CFACTORY.H - Class Factory Object
//

#ifndef _CFACTORY_H_
#define _CFACTORY_H_

//
// QueryInterface Table
//
BEGIN_QITABLE( CFactory )
DEFINE_QI( IID_IClassFactory, IClassFactory, 2 )
END_QITABLE


// CFactory
class 
CFactory:
    public IClassFactory
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CFactory );

    // IClassFactory data
    LPCREATEINST _pfnCreateInstance;

private: // Methods
    CFactory( LPCREATEINST lpfn );
    ~CFactory();
    STDMETHOD(Init)( );

public: // Methods
    friend HRESULT CALLBACK 
        DllGetClassObject( REFCLSID rclsid, REFIID riid, void** ppv );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory
    STDMETHOD(CreateInstance)( IUnknown *punkOuter, REFIID riid, LPVOID *ppv );
    STDMETHOD(LockServer)( BOOL fLock );
};

typedef CFactory* LPCFACTORY ;

#endif // _CFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cfactory.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// CFACTORY.CPP - Class Factory Object
//

#include "pch.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CFactory")
#define THISCLASS CFactory

// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// Constructor
//
THISCLASS::THISCLASS( LPCREATEINST pfn )
{
    TraceClsFunc( "CFactory()\n" );

    _pfnCreateInstance = pfn; 

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

STDMETHODIMP
THISCLASS::Init( )
{
    TraceClsFunc( "Init()\n");

    //
    // IUnknown stuff
    //
    Assert( _cRef == 0 );

    // Build QI Table
    BEGIN_QITABLE_IMP( CFactory, IClassFactory );
    QITABLE_IMP( IClassFactory );
    END_QITABLE_IMP( CFactory );

    // Add one count
    AddRef( );

    //
    // Private Members
    //

    HRETURN(S_OK);
};

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CFactory()\n" );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IClassFactory
//
// ************************************************************************

//
// CreateInstance()
//
STDMETHODIMP 
THISCLASS::
    CreateInstance(
        IUnknown *pUnkOuter, 
        REFIID riid, 
        void **ppv )
{
    TraceClsFunc( "[IClassFactory] CreateInstance()\n" );

    if ( !ppv )
        RRETURN(E_POINTER);

    *ppv = NULL;

    HRESULT     hr  = E_NOINTERFACE;
    IUnknown *  pUnk = NULL; 

    if ( NULL != pUnkOuter )
    {
        hr = THR(CLASS_E_NOAGGREGATION);
        goto Cleanup;
    }

	Assert( _pfnCreateInstance != NULL );
    TraceMsgDo( pUnk = (IUnknown *) _pfnCreateInstance( ), "0x%08x" );
    if ( !pUnk )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    TraceMsgDo( hr = pUnk->QueryInterface( riid, ppv ), "0x%08x" );

Cleanup:
    if ( !!pUnk )
    {
        ULONG cRef;
        TraceMsgDo( cRef = pUnk->Release( ), "%u" );
    }

    HRETURN(hr);
}

//
// LockServer()
//
STDMETHODIMP
THISCLASS::
    LockServer( BOOL fLock )
{
    TraceClsFunc( "[IClassFactory] LockServer()\n");

    if ( fLock )
    {
        InterlockIncrement( g_cLock );
    }
    else
    {
        InterlockDecrement( g_cLock );
    }

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\client.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//


#ifndef _CLIENT_H_
#define _CLIENT_H_

// Definitions
LPVOID
CClientTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CClientTab
class
CClientTab:
    public ITab
{
private: // Members
    HWND      _hDlg;            // dialogs HWND
    LPUNKNOWN _punkComputer;    // Pointer back to computer object
    BOOL      _fChanged:1;      // UI changed by user
    HWND      _hNotify;         // HWND of the DSA notify object

private: // Methods
    CClientTab();
    ~CClientTab();
    STDMETHOD(Init)();

    // Property Sheet Functions
    STDMETHOD(_InitDialog)( HWND hDlg, LPARAM lParam );
    STDMETHOD(_OnCommand)( WPARAM wParam, LPARAM lParam );
    STDMETHOD(_ApplyChanges)( VOID);
    STDMETHOD_(INT,_OnNotify)( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    STDMETHOD(_JumpToServer)( BOOLEAN ShowProperties );
    STDMETHOD(_IsValidRISServer)( IN PCWSTR ServerName );
    static HRESULT _OnSearch( HWND hwndParent );
    STDMETHOD_(PWCHAR,AnsiStringToUnicodeString)( IN PCHAR pszAnsi, OUT PWCHAR pszUnicode, IN USHORT cbUnicode);


public: // Methods
    friend LPVOID CClientTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)(LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CClientTab* LPCClientTab;

#endif // _CLIENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\client.cpp ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.CPP - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//

#include "pch.h"

#include "client.h"
#include "ccomputr.h"
#include "winsock2.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CClientTab")
#define THISCLASS CClientTab
#define LPTHISCLASS LPCClientTab

#define LDAPSTRINGNOWACKS   L"LDAP://"

DWORD aClientHelpMap[] = {
    IDC_E_GUID, HIDC_E_GUID,
    IDC_E_SERVERNAME, HIDC_E_SERVERNAME,
    IDC_B_BROWSE, HIDC_B_BROWSE,
    IDC_B_SERVER, HIDC_B_SERVER,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CClientTab_CreateInstance( void )
{
        TraceFunc( "CClientTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if (FAILED( hr ))
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CClientTab()\n" );

        InterlockIncrement( g_cObjects );

    Assert( !_punkComputer );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CClientTab()\n" );

    // Private Members
    if ( _punkComputer )
        _punkComputer->Release( );  // matching AddRef() in AddPages()

    // tell ADS to destroy the notify object
    // NOTE: Another property page may do this before us. Ignore the error.
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_EXIT, 0, 0 );

        InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_INTELLIMIRROR_CLIENT);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punkComputer = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            pcc->_OnCommand( wParam, lParam );
            break;

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aClientHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aClientHelpMap );
            break;

        case WM_ADSPROP_PAGE_GET_NOTIFY:
            HWND *phwnd = (HWND *) wParam;
            *phwnd = pcc->_hNotify;
            return TRUE;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr;
    IMAO *  pmao;
    BOOL    fAdmin;
    HWND    hwndGuid;
    HWND    hwndServer;
    LPWSTR  pszServerName = NULL;
    LPWSTR  pszGUID = NULL;

    CWaitCursor Wait;

    _hDlg = hDlg;
    _fChanged = TRUE; // prevent turning on the Apply button early

    hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
    hwndServer = GetDlgItem( _hDlg, IDC_E_SERVERNAME );
    Edit_LimitText( hwndGuid, MAX_INPUT_GUID_STRING - 1 );
    Edit_LimitText( hwndServer, DNS_MAX_NAME_BUFFER_LENGTH - 1 );

    // retrieve values
    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    hr = THR( pmao->GetNotifyWindow( &_hNotify ) );
    if (FAILED( hr ))
        goto Error;

    ADsPropSetHwnd( _hNotify, _hDlg );

    hr = THR( pmao->IsAdmin( &fAdmin ) );
    EnableWindow( hwndGuid, fAdmin );
    EnableWindow( hwndServer, fAdmin );
    EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE ), fAdmin );

    hr = pmao->GetServerName( &pszServerName );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;
    Assert( SUCCEEDED(hr) || pszServerName == NULL );

    hr = THR( pmao->GetGUID( &pszGUID, NULL ) );
    if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Error;
    Assert( SUCCEEDED(hr) || pszGUID == NULL );

    if ( pszGUID )
    {
        SetWindowText( hwndGuid, pszGUID );
    }
    else
    {
        SetWindowText( hwndGuid, L"" );
    }

    if ( pszServerName )
    {
        SetWindowText( hwndServer, pszServerName );
        EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVER ), fAdmin );
    }
    else
    {
        SetWindowText( hwndServer, L"" );
    }

    hr = S_OK;

Cleanup:
    if ( pmao )
        pmao->Release( );
    if ( pszGUID )
        TraceFree( pszGUID );
    if ( pszServerName )
        TraceFree( pszServerName );

    _fChanged = FALSE;

    HRETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( _hDlg, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
        break;
    }
    goto Cleanup;
}


//
// _OnCommand( )
//
HRESULT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr;
    BOOL    fAdmin;
    BOOL    fChanged = FALSE;
    IMAO *  pmao;
    HWND    hwnd = (HWND) lParam;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    switch( LOWORD(wParam) )
    {
    case IDC_E_SERVERNAME:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            LRESULT iLength = GetWindowTextLength( (HWND) lParam );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_SERVER ), !!iLength );
            fChanged = TRUE;
        }
        break;

    case IDC_E_GUID:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            fChanged = TRUE;
        }
        break;

    case IDC_B_SERVER:
        if ( HIWORD( wParam ) == BN_CLICKED ) 
        {
            _JumpToServer( TRUE );
        }
        break;

    case IDC_B_BROWSE:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            hr = _OnSearch( _hDlg );
                        
        }
        break;
    }
    //
    // Update apply button as needed
    //
    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;   // indicates we need to save changes
            PropSheet_Changed( GetParent( _hDlg ), _hDlg );
        }
    }

Error:
    HRETURN(hr);
}

HRESULT
THISCLASS::_OnSearch(
    HWND hDlg )
{
    TraceClsFunc( "_OnSearch( )\n" );

    HRESULT hr = E_FAIL;
    DSQUERYINITPARAMS dqip;
    OPENQUERYWINDOW   oqw;
    LPDSOBJECTNAMES   pDsObjects;
    VARIANT var;
    ICommonQuery * pCommonQuery = NULL;
    IDataObject *pdo;

    VariantInit( &var );

    hr = THR( CoCreateInstance( CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (PVOID *)&pCommonQuery) );
    if (hr)
        goto Error;

    ZeroMemory( &dqip, sizeof(dqip) );
    dqip.cbStruct = sizeof(dqip);
    dqip.dwFlags  = DSQPF_NOSAVE | DSQPF_SHOWHIDDENOBJECTS | DSQPF_ENABLEADMINFEATURES;
    dqip.dwFlags  |= DSQPF_ENABLEADVANCEDFEATURES;

    ZeroMemory( &oqw, sizeof(oqw) );
    oqw.cbStruct           = sizeof(oqw);
    oqw.dwFlags            = OQWF_SHOWOPTIONAL | OQWF_ISSUEONOPEN
                           | OQWF_REMOVESCOPES | OQWF_REMOVEFORMS
                           | OQWF_DEFAULTFORM | OQWF_OKCANCEL | OQWF_SINGLESELECT;
    oqw.clsidHandler       = CLSID_DsQuery;
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm   = CLSID_RISrvQueryForm;
    
    hr = pCommonQuery->OpenQueryWindow( hDlg, &oqw, &pdo);

    if ( SUCCEEDED(hr) && pdo) {
        FORMATETC fmte = {
                      (CLIPFORMAT)g_cfDsObjectNames,
                      NULL,
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
        STGMEDIUM medium = { TYMED_HGLOBAL, NULL, NULL };
 
        //
        // Retrieve the result from the IDataObject, 
        // in this case CF_DSOBJECTNAMES (dsclient.h) 
        // is needed because it describes 
        // the objects which were selected by the user.
        //
        hr = pdo->GetData(&fmte, &medium);
        if ( SUCCEEDED(hr) ) {
            DSOBJECTNAMES *pdon = (DSOBJECTNAMES*)GlobalLock(medium.hGlobal);
            PWSTR p,FQDN;

            //
            // we want the name of the computer object that was selected.
            // crack the DSOBJECTNAMES structure to get this data, 
            // convert it into a version that the user can view, and set the
            // dialog text to this data.
            //
            if ( pdon ) {
                Assert( pdon->cItems == 1);
                p = (PWSTR)((ULONG_PTR)pdon + (ULONG_PTR)pdon->aObjects[0].offsetName);
                if (p && (p = wcsstr(p, L"LDAP://"))) {
                    p += 6;
                    if ((p = wcsstr(p, L"/CN="))) {
                        p += 1;
                        hr = DNtoFQDN( p, &FQDN);

                        if (SUCCEEDED(hr)) {
                            SetDlgItemText( hDlg, IDC_E_SERVERNAME, FQDN );
                            TraceFree( FQDN );
                        }
                    }
                }
                GlobalUnlock(medium.hGlobal);
            }
        }

        ReleaseStgMedium(&medium);
        pdo->Release();
    }

Error:
    
    if ( pCommonQuery )
        pCommonQuery->Release();

    if (FAILED(hr)) {
        MessageBoxFromStrings( 
                        hDlg, 
                        IDS_PROBLEM_SEARCHING_TITLE, 
                        IDS_PROBLEM_SEARCHING_TEXT,
                        MB_ICONEXCLAMATION );
    }

    HRETURN(hr);
}



//
// _ApplyChanges( )
//
HRESULT
THISCLASS::_ApplyChanges( )
{
    TraceClsFunc( "_ApplyChanges( )\n" );

    if ( !_fChanged )
        HRESULT(S_OK); // nothing to do

    HRESULT hr    = S_OK;
    IMAO    *pmao = NULL;
    WCHAR   szGuid[ MAX_INPUT_GUID_STRING ];
    WCHAR   szServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    INT     iLength;
    HWND    hwndServer = GetDlgItem( _hDlg, IDC_E_SERVERNAME );
    HWND    hwndGuid = GetDlgItem( _hDlg, IDC_E_GUID );
    HWND    eWnd;
    LPWSTR  pszGuid = NULL;

    CWaitCursor Wait;
    eWnd = hwndGuid;

    hr = THR( _punkComputer->QueryInterface( IID_IMAO, (void**) &pmao ) );
    if (FAILED( hr )) 
        goto Error;

    iLength = GetWindowText( hwndGuid, szGuid, ARRAYSIZE( szGuid ) );
    Assert( iLength <= ARRAYSIZE( szGuid ) );

    if ( iLength == 0 )
    {
        hr = THR( pmao->GetGUID( &pszGuid, NULL ) );
        if (FAILED( hr ) && hr != E_ADS_PROPERTY_NOT_FOUND )
            goto Error;
        Assert( SUCCEEDED(hr) || pszGuid == NULL );

        if ( pszGuid != NULL )
        {
            LRESULT iResult = MessageBoxFromStrings( _hDlg, IDS_REMOVING_GUID_TITLE, IDS_REMOVING_GUID_TEXT, MB_YESNO );
            if ( iResult == IDYES )
            {
                hr = THR( pmao->SetGUID( NULL ) );
                if (FAILED( hr ))
                    goto Error;
            }
            else
            {   // reset the GUID
                SetWindowText( hwndGuid, pszGuid );
                hr = E_FAIL;
                goto Cleanup;
            }
        }
    }
    else
    {
        hr = ValidateGuid( szGuid, NULL, NULL );
        if ( hr != S_OK )
        {
            hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );
            goto InvalidGuid;
        }

        hr = THR( pmao->SetGUID( szGuid ) );
        if (FAILED( hr ))
            goto Error;
    }

    iLength = GetWindowText( hwndServer, szServerName, ARRAYSIZE( szServerName ) );
    Assert( iLength <= ARRAYSIZE( szServerName ) );
    if (iLength != 0) {
        hr = _JumpToServer( FALSE );
        if( FAILED(hr) ){
            // Well, server name invalid. Stop and return false.
            eWnd = hwndServer;
            goto Error;
        }

        hr = THR( pmao->SetServerName( szServerName ) );
        if (FAILED( hr ))
            goto Error;

    } else {    
        hr = THR( pmao->SetServerName( NULL ) );
        if (FAILED( hr ))
            goto Error;
    }            

    hr = THR( pmao->CommitChanges( ) );
    if (FAILED( hr ))
        goto Error;

    _fChanged = FALSE;  // reset
    hr = S_OK;

Cleanup:
    if ( pszGuid )
        TraceFree( pszGuid );
    if ( pmao )
        pmao->Release( );

    // Tell DSA that someone hit the Apply
    SendMessage( _hNotify, WM_ADSPROP_NOTIFY_APPLY, !!SUCCEEDED( hr ), 0 );

    HRETURN(hr);
Error:
    SetFocus( eWnd );
    if ( eWnd == hwndGuid ) {
        MessageBoxFromHResult( _hDlg, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
    }
    goto Cleanup;
InvalidGuid:
    SetFocus( hwndGuid );
    MessageBoxFromStrings( NULL, IDS_INVALID_GUID_CAPTION, IDS_INVALID_GUID_TEXT, MB_OK );
    goto Cleanup;
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        {
            HRESULT hr;
            CWaitCursor *Wait;

            Wait = new CWaitCursor();

            TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
            hr = _ApplyChanges( );
            if (Wait) {
                delete Wait;
                Wait = NULL;
            }

            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

HRESULT
THISCLASS::_JumpToServer( 
    BOOLEAN ShowProperties
    )
{
    HRESULT hr = E_FAIL;
    WCHAR             szServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    IDataObject *pido = NULL;
    ULONG ulSize = 0;
    CWaitCursor *Wait;
    const WCHAR       cszFilter[] = L"(&(objectCategory=computer)(servicePrincipalName=host/%s%s))";
    const WCHAR       samname[]   = L"samaccountname";    
    LPCWSTR           patterns[]  = {L""};    
    CHAR              mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    // Later to do pattern matching searches on the dnsHostName or Netbios name
    // expand the above arrays. See the for loop for details.
    ULONG             index;
    WCHAR             *pStart;
    WCHAR             *pEnd;
    LPWSTR            pszFilter   = NULL;
    IADsContainer     *pads       = NULL;
    IEnumVARIANT      *penum      = NULL;
    ADS_SEARCH_COLUMN adsColumn;  // this needs to be freed
    ADS_SEARCH_HANDLE adsHandle   = NULL;
    IDirectorySearch  *pds        = NULL;
    LPWSTR            ComputerAttrs[] = { DISTINGUISHEDNAME, NETBOOTSAP };
    BOOL              badsColumnValid = FALSE;
    ULONG             uFetched;
    VARIANT           varEnum;
    size_t            len;
    HOSTENT           *hent;
    
    TraceClsFunc("_JumpToServer( )\n");

    Wait = new CWaitCursor();
    
    GetDlgItemText( _hDlg, IDC_E_SERVERNAME, szServerName, ARRAYSIZE(szServerName) );

    hr = _IsValidRISServer( szServerName );
    if ( FAILED( hr )) {
        goto Error;
    }    

    if (ShowProperties) {    
        VariantInit( &varEnum );

        //
        // get the full DN of the machine.
        //
        len =  wcstombs( mbszServerName, szServerName, ARRAYSIZE( mbszServerName ) );
        
        if ( !len ) {
            goto Error;
        }
        
        hent = gethostbyname( mbszServerName );
        if (!hent) {
            goto Error;
        }

        len = mbstowcs( szServerName, hent->h_name, strlen( hent->h_name ) );

        if ( !len ) {
            goto Error;
        }

        szServerName[len] = L'\0';

    
        // Build the filter
        pszFilter = (LPWSTR) TraceAllocString( LPTR, ARRAYSIZE(cszFilter) + wcslen(szServerName)
                                           + ARRAYSIZE(samname) + 2 ); // size of the longest         
        if ( !pszFilter )
            goto OutOfMemory;
    
        hr = THR( ADsOpenObject( L"LDAP:", NULL, NULL, ADS_SECURE_AUTHENTICATION, IID_IADsContainer, (LPVOID *) &pads ) );
        if (FAILED( hr ))
            goto Error;
    
        hr = THR( ADsBuildEnumerator( pads, &penum ) );
        if (FAILED( hr ))
            goto Error;
    
        hr = THR( ADsEnumerateNext( penum, 1, &varEnum, &uFetched ) );
        if (FAILED( hr ))
            goto Error;
        if ( hr == S_FALSE )
            goto Cleanup;   // hum...
        Assert( uFetched == 1 || varEnum.vt == VT_DISPATCH || varEnum.pdispVal != NULL );
    
        hr = THR( varEnum.pdispVal->QueryInterface( IID_IDirectorySearch, (void**)&pds) );
        if (FAILED( hr ))
            goto Error;    

        for ( index = 0; index < ARRAYSIZE(patterns); index ++ ) {

            wsprintf( pszFilter, cszFilter, szServerName,patterns[index] );
    
            DebugMsg( "Filter = '%s'\n", pszFilter );
    
            hr = THR( pds->ExecuteSearch( pszFilter, ComputerAttrs, ARRAYSIZE(ComputerAttrs), &adsHandle ) );
            if (FAILED( hr ))
                continue;        
    
                    do{
                        hr = THR( pds->GetNextRow( adsHandle ) );
                        if (FAILED( hr ) || ( hr == S_ADS_NOMORE_ROWS ) ) {
                            if ( adsHandle )
                                pds->CloseSearchHandle( adsHandle );
                            adsHandle = NULL;
                            break;
                        }
                        hr = THR( pds->GetColumn( adsHandle, ComputerAttrs[1], &adsColumn ) );
                        if (FAILED( hr )){
                            continue;
                        }
                        if ( pds ) {
                            hr = THR( pds->FreeColumn( &adsColumn ) );            
                        }
                        hr = THR( pds->GetColumn( adsHandle, ComputerAttrs[0], &adsColumn ) );
                        if (FAILED( hr )){
                            continue;
                        }
                        Assert( adsColumn.dwADsType == ADSTYPE_DN_STRING );
                        Assert( adsColumn.pADsValues->dwType == ADSTYPE_DN_STRING );
                        Assert( adsColumn.pADsValues->DNString );
                        badsColumnValid = TRUE;
                        break;
                    } while ( TRUE );
        if ( badsColumnValid ) {
            break;
        }

    }

    if (index == ARRAYSIZE( patterns ) ) {
        goto Error;
    }

    
        hr = THR( _punkComputer->QueryInterface( IID_IDataObject, (LPVOID *) &pido ) );
        if (FAILED( hr ))
            goto Error;

        if (Wait) {
            delete Wait;
            Wait = NULL;
        }
    
        hr = THR( PostADsPropSheet( adsColumn.pADsValues->DNString, pido, _hDlg, FALSE) );
        // PostADsPropSheet should put up its own errors
    }

    Cleanup:

        if (Wait) {
            delete Wait;
            Wait = NULL;
        }

        if ( pido )
            pido->Release( );
        if ( pszFilter )
            TraceFree( pszFilter );
        if ( pads )
            pads->Release( );
        if ( penum )
            ADsFreeEnumerator( penum );
        if ( pds && badsColumnValid ) {
            hr = THR( pds->FreeColumn( &adsColumn ) );
        }
        if ( pds && adsHandle ) {
            hr = THR( pds->CloseSearchHandle( adsHandle ) );
        }
        if ( pds )
            pds->Release();
        HRETURN(hr);

Error:

    if (Wait) {
        delete Wait;
        Wait = NULL;
    }

    if ( ShowProperties ){
        MessageBoxFromStrings( 
                    _hDlg, 
                    IDS_PROBLEM_FINDING_SERVER_TITLE, 
                    IDS_PROBLEM_FINDING_SERVER_TEXT, 
                    MB_OK | MB_ICONWARNING );
    } else {
        int retVal = MessageBoxFromStrings( 
                                    _hDlg, 
                                    IDS_PROBLEM_FINDING_SERVER_TITLE, 
                                    IDS_PROBLEM_FINDING_SERVER_CONFIRM_TEXT, 
                                    MB_YESNO | MB_ICONWARNING);

        hr = (retVal == IDYES)?S_OK:E_ADS_BAD_PARAMETER;
    }
    goto Cleanup;
OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Error;
}

HRESULT
THISCLASS::_IsValidRISServer(
    IN LPCWSTR ServerName
    )
/*++

Routine Description:

    Validates if the specified server name points to a valid RIS server.

Arguments:

    ServerName - name of the server to validate

Return Value:

    HRESULT indicating outcome.
    (S_OK indicates that the server is a valid RIS server).

--*/
{
    HRESULT hr = E_FAIL;
    CHAR mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH +1];
    size_t len;
    PHOSTENT hent;
    WCHAR ServerShare[MAX_PATH];
    
    TraceClsFunc("_IsValidRISServer( )\n");

    Assert( wcslen(ServerName) <= DNS_MAX_NAME_BUFFER_LENGTH );
    
    //
    // Do a DNS Lookup of the server as a first check to ensure it's a 
    // valid name.
    //
    len =  wcstombs( mbszServerName, ServerName, ARRAYSIZE( mbszServerName ) );
    
    if ( !len ) {
        goto e0;        
    }
    
    hent = gethostbyname( mbszServerName );
    if (!hent) {
        goto e0;
    }

    //
    // OK, we know the server actually resolves to a computer name.  Let's search
    // for \\servername\reminst share.  If this succeeds, we assume the server
    // is a valid remote install server
    //

    wsprintf( ServerShare, L"\\\\%s\\reminst\\oschooser", ServerName );    

    if (GetFileAttributes(ServerShare) == -1) {
        goto e0;
    }

    hr = S_OK;

e0:
    HRETURN(hr);
}


PWCHAR
THISCLASS::AnsiStringToUnicodeString(
    IN PCHAR pszAnsi,
    OUT PWCHAR pszUnicode,
    IN USHORT cbUnicode
    )
{
    NTSTATUS status;
    BOOLEAN fAllocate = (pszUnicode == NULL);
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;

    RtlInitAnsiString(&ansiString, pszAnsi);
    if (pszUnicode != NULL) {
        unicodeString.Length = 0;
        unicodeString.MaximumLength = cbUnicode;
        unicodeString.Buffer = pszUnicode;
    }
    status = RtlAnsiStringToUnicodeString(
               &unicodeString,
               &ansiString,
               fAllocate);

    return (status == STATUS_SUCCESS ? unicodeString.Buffer : NULL);
} // AnsiStringToUnicodeString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cgroup.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// CGROUP.CPP - Handles the computer object property pages.
//

#include "pch.h"

#ifdef INTELLIMIRROR_GROUPS

#include "cservice.h"
#include "groups.h"
#include "cgroup.h"

//
// Definitions
//

//
// Begin Class Definitions
//
DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CGroup")
#define THISCLASS CGroup
#define LPTHISCLASS LPGROUP


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CGroup_CreateInstance( void )
{
	TraceFunc( "CGroup_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CGroup()\n" );

	InterlockIncrement( g_cObjects );
    
    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CGroup, IShellExtInit );
    QITABLE_IMP( IShellExtInit );
    QITABLE_IMP( IShellPropSheetExt );
    QITABLE_IMP( IEnumSAPs );
    END_QITABLE_IMP( CGroup );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    // Private Members
    Assert( !_penum );
    Assert( !_pDataObj );

    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CGroup()\n" );

    // Members
    if ( _penum )
        _penum->Release( );

    if ( _pDataObj )
        _pDataObj->Release( );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};


// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    
    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IShellExtInit
//
// ************************************************************************

//
// Initialize()
//
HRESULT
THISCLASS::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj, 
    HKEY hkeyProgID )
{
    TraceClsFunc( "[IShellExtInit] Initialize( " );
    TraceMsg( TF_FUNC, " pidlFolder = 0x%08x, lpdobj = 0x%08x, hkeyProgID = 0x%08x )\n",
        pidlFolder, lpdobj, hkeyProgID );

    if ( !lpdobj )
        RETURN(E_INVALIDARG);

    HRESULT    hr = S_OK;
    FORMATETC  fmte;
    STGMEDIUM  stg = { 0 };
    STGMEDIUM  stgOptions = { 0 };

    LPWSTR     pszObjectName;
    LPWSTR     pszClassName;
    LPWSTR     pszAttribPrefix;

    LPDSOBJECT             pDsObject;
    LPDSOBJECTNAMES        pDsObjectNames;
    LPDSDISPLAYSPECOPTIONS pDsDisplayOptions;

    IADsContainer *pads = NULL;
    VARIANT        varFilter;
    VARIANT        varAFilter;
    SAFEARRAY      *psaFilter  = NULL;
    SAFEARRAYBOUND sabFilterArray;
    BSTR           bstr = NULL;
    LONG           ix[ 1 ];

    VariantInit(&varAFilter);
    VariantInit(&varFilter );

    // Hang onto it
    _pDataObj = lpdobj;
    _pDataObj->AddRef( );

    //
    // Retrieve the Object Names
    //
    fmte.cfFormat = g_cfDsObjectNames;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stg) );
    if ( hr )
        goto Cleanup;

    pDsObjectNames = (LPDSOBJECTNAMES) stg.hGlobal;

    Assert( stg.tymed == TYMED_HGLOBAL );

    TraceMsg( TF_ALWAYS, "Object's Namespace CLSID: " );
    TraceMsgGUID( TF_ALWAYS, pDsObjectNames->clsidNamespace );
    TraceMsg( TF_ALWAYS, "\tNumber of Objects: %u \n", pDsObjectNames->cItems );

    Assert( pDsObjectNames->cItems == 1 );

    pDsObject = (LPDSOBJECT) pDsObjectNames->aObjects;

    pszObjectName = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetName );
    pszClassName  = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetClass );

    TraceMsg( TF_ALWAYS, "Object Name (Class): %s (%s)\n", pszObjectName, pszClassName );

    //
    // This must be the correct classname.
    //
    if ( StrCmp( pszClassName, DSGROUPCLASSNAME ) )
    {
        hr = E_FAIL;
        goto Error;
    }

    //
    // Retrieve the Display Spec Options
    //
    fmte.cfFormat = g_cfDsDisplaySpecOptions;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( lpdobj->GetData( &fmte, &stgOptions ) );
    if ( hr )
        goto Cleanup;

    pDsDisplayOptions = (LPDSDISPLAYSPECOPTIONS) stgOptions.hGlobal;

    Assert( stgOptions.tymed == TYMED_HGLOBAL );
    Assert( pDsDisplayOptions->dwSize == sizeof(DSDISPLAYSPECOPTIONS) );

    pszAttribPrefix = (LPWSTR) PtrToByteOffset( pDsDisplayOptions, pDsDisplayOptions->offsetAttribPrefix );

    // TraceMsg( TF_ALWAYS, TEXT("Attribute Prefix: %s\n"), pszAttribPrefix );

    if ( StrCmpW( pszAttribPrefix, STRING_ADMIN ) == 0 )
    {
        _uMode = MODE_ADMIN;
    }
    // else default from Init()

    TraceMsg( TF_ALWAYS, TEXT("Mode: %s\n"), _uMode ? TEXT("Admin") : TEXT("Shell") );

    ReleaseStgMedium( &stgOptions );

    //
    // Bind to the group object in the DS as a container
    //
    hr = THR( ADsGetObject( pszObjectName, IID_IADsContainer, (void **)&pads ) );
    if (hr)
        goto Error;

    //
    // Build the filter variant
    //
    bstr = SysAllocString( DSIMSAPCLASSNAME );
    if (!bstr)
    {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    sabFilterArray.cElements   = 1;
    sabFilterArray.lLbound     = 0;
    psaFilter                  = SafeArrayCreate( VT_VARIANT, 1, &sabFilterArray );
    if ( !psaFilter )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }

    V_VT(&varAFilter)    = VT_BSTR;
    V_BSTR(&varAFilter)  = bstr;
    bstr                 = NULL;
    ix[0]                = 0;

    hr = THR( SafeArrayPutElement( psaFilter, ix, &varAFilter ) );
    if (hr)
        goto Error;

    V_VT(&varFilter)    = VT_VARIANT | VT_ARRAY;
    V_ARRAY(&varFilter) = psaFilter;
    psaFilter           = NULL;

    //
    // Apply filter
    //
    hr = THR( pads->put_Filter( varFilter ) );
    if (hr)
        goto Error;

    //
    // Get enumeration object
    //
    hr = THR( pads->get__NewEnum( (LPUNKNOWN*) &_penum ) );
    if (hr)
        goto Error;

Cleanup:
    if ( pads )
        pads->Release( );

    if ( bstr )
        SysFreeString( bstr );

    if ( psaFilter )
        SafeArrayDestroy( psaFilter );

    VariantClear( &varAFilter );
    VariantClear( &varFilter );
    ReleaseStgMedium( &stg );

    HRETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
        break;
    }
    goto Cleanup;
}

// ************************************************************************
//
// IShellPropSheetExt
//
// ************************************************************************

//
// AddPages()
//
HRESULT
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage, 
    LPARAM lParam) 
{ 
    TraceClsFunc( "[IShellPropSheetExt] AddPages( )\n" );

    if ( !lpfnAddPage )
        RRETURN(E_POINTER);
 
    HRESULT hr = S_OK;
    BOOL fServer;

    //
    // Add the "IntelliMirror Group" tab
    //
    hr = THR( ::AddPagesEx( NULL, 
                            CGroupsTab_CreateInstance, 
                            lpfnAddPage, 
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (hr)
        goto Error;

Error:
    RRETURN(hr); 
} 

//
// ReplacePage()
// 
HRESULT 
THISCLASS::ReplacePage( 
    UINT uPageID, 
    LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
    LPARAM lParam )
{

    TraceClsFunc( "[IShellPropSheetExt] ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

// ************************************************************************
//
// IEnumSAPs
//
// ************************************************************************

//
// Next( )
//
HRESULT 
THISCLASS::Next( 
    ULONG celt, 
    LPSERVICE * rgelt, 
    ULONG * pceltFetched )
{
    TraceClsFunc( "[IEnumSAPs] Next( ... )\n" );

    if ( !rgelt )
        RRETURN(E_POINTER);

    if ( celt > 1 )
        RRETURN(E_INVALIDARG);

    *rgelt = NULL;

    HRESULT    hr = S_OK;
    VARIANT    var;
    ULONG      cFetched;
    IADs *     pads = NULL;
    IDispatch *pdisp;       // don't ref count - "var" will hold it for us
    LPSERVICE  pc = NULL;

    VariantInit( &var );

    if (pceltFetched)
        *pceltFetched = 0;

    if ( _penum == NULL )
    {
        hr = THR(ERROR_INVALID_DATA);
        goto Error;
    }

    //
    // Get the attribute vars
    //
    hr = THR( _penum->Next( celt, &var, &cFetched ) );
    if (hr)
        goto Error;

    if ( cFetched == 0 )
    {
        hr = S_FALSE;
        goto Error;
    }

    if ( V_VT( &var ) != VT_DISPATCH )
    {
        hr = THR( ERROR_INVALID_DATA );
        goto Error;
    }

    pdisp = V_DISPATCH( &var );
    Assert( pdisp != NULL );

    hr = THR( pdisp->QueryInterface( IID_IADs, (void**) &pads ) );
    if (hr)
        goto Error;

    pc = (LPSERVICE) CService_CreateInstance( );
    if ( !pc )
    {
        hr = THR( E_OUTOFMEMORY );
        goto Error;
    }
    
    hr = THR( pc->Init2( pads ) );
    if (hr)
        goto Error;

    *rgelt = pc;

Cleanup:
    if ( pads )
        pads->Release( );

    VariantClear( &var );

    HRETURN(hr);

Error:
    if ( pc )
        pc->Release( );

    switch (hr) {
    case S_OK:
    case S_FALSE:
        break;
    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_WRITINGTOCOMPUTERACCOUNT, hr );
        break;
    }
    goto Cleanup;
}

//
// Skip( )
//
HRESULT 
THISCLASS::Skip( 
    ULONG celt  )
{
    TraceClsFunc( "[IEnumSAPs] Skip( ... )\n" );

    HRESULT hr;

    if ( _penum == NULL )
    {
        hr = THR(ERROR_INVALID_DATA);
        goto Error;
    }

    hr = THR( _penum->Skip( celt ) );
    if (hr)
        goto Error;

Error:
    HRETURN(hr);
}


//
// Reset( )
//
HRESULT 
THISCLASS::Reset( void )
{
    TraceClsFunc( "[IEnumSAPs] Reset( ... )\n" );

    HRESULT hr;

    if ( _penum == NULL )
    {
        hr = THR(ERROR_INVALID_DATA);
        goto Error;
    }

    hr = THR( _penum->Reset( ) );
    if (hr)
        goto Error;

Error:
    HRETURN(hr);
}


//
// Clone( )
//
HRESULT 
THISCLASS::Clone( 
    void ** ppenum )
{
    TraceClsFunc( "[IEnumSAPs] Clone( ... ) **** NOT IMPLEMENTED ****\n" );

    HRESULT hr = THR( E_NOTIMPL );

    HRETURN(hr);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\clients.h ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\clients.cpp ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cgroup.h ===
//
// Copyright 1997 - Microsoft
//

//
// CComputr.H - Computer properties class
//

#ifdef INTELLIMIRROR_GROUPS

#ifndef _CGROUP_H_
#define _CGROUP_H_

// QI Table
BEGIN_QITABLE( CGroup )
DEFINE_QI( IID_IShellExtInit,      IShellExtInit     , 1 )
DEFINE_QI( IID_IShellPropSheetExt, IShellPropSheetExt, 2 )
DEFINE_QI( IID_IEnumSAPs,          IEnumSAPs         , 4 )
END_QITABLE

// Definitions
LPVOID
CGroup_CreateInstance( void );

// SAPNode Structure
typedef struct __SAPNODE {
    LPWSTR pszServerName;
    BOOL   fMaster;
    BOOL   fSlave;
} SAPNODE, *LPSAPNODE;

// Private IEnumSAPs Interface
class
IEnumSAPs:
    public IUnknown
{
public:
    STDMETHOD(Next)( ULONG celt, LPSERVICE * rgVar, ULONG *pCeltFetched) PURE;
    STDMETHOD(Skip)( ULONG celt) PURE;
    STDMETHOD(Reset)( void) PURE;
    STDMETHOD(Clone)( void ** ppEnum) PURE;    
};

// CGroup
class 
CGroup:
    public IShellExtInit, IShellPropSheetExt, IEnumSAPs
{
private:
    // Enums
    enum { 
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CGroup );

    UINT  _uMode;                   // Admin or Shell mode

    LPDATAOBJECT    _pDataObj;     // Data Object passed to ServerTab
    IEnumVARIANT *  _penum;        // ADSI enumerator

private: // Methods
    CGroup();
    ~CGroup();
    STDMETHOD(Init)();

public: // Methods
    friend LPVOID CGroup_CreateInstance( void );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IShellExtInit
    STDMETHOD(Initialize)( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, 
                           HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                            LPARAM lParam);

    // IEnumVARIANT
    STDMETHOD(Next)( ULONG celt, LPSERVICE *rgVar, ULONG *pCeltFetched);    
    STDMETHOD(Skip)( ULONG celt);    
    STDMETHOD(Reset)( void);
    STDMETHOD(Clone)( void ** ppEnum);
};

typedef CGroup* LPGROUP;

#endif // _CGROUP_H_

#endif // INTELLIMIRROR_GROUPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cservice.h ===
//
// Copyright 1997 - Microsoft
//

//
// CComputr.H - Computer properties class
//

#ifndef _CSERVICE_H_
#define _CSERVICE_H_

#include <adsprop.h>

// QITable
BEGIN_QITABLE( CService )
DEFINE_QI( IID_IShellExtInit,      IShellExtInit     , 1  )
DEFINE_QI( IID_IShellPropSheetExt, IShellPropSheetExt, 2  )
DEFINE_QI( IID_IIntelliMirrorSAP,  IIntelliMirrorSAP , 30 )
END_QITABLE

// Definitions
LPVOID
CService_CreateInstance( void );

// Private IIntelliMirrorSAP Interface Definition
interface
IIntelliMirrorSAP:
    public IUnknown
{
public:
    STDMETHOD(CommitChanges)( void ) PURE;                      // 1
    STDMETHOD(IsAdmin)( BOOL * pbool ) PURE;                    // 2

    STDMETHOD(GetAllowNewClients)( BOOL *pbool ) PURE;          // 3
    STDMETHOD(SetAllowNewClients)( BOOL pbool ) PURE;           // 4

    STDMETHOD(GetLimitClients)( BOOL *pbool ) PURE;             // 5
    STDMETHOD(SetLimitClients)( BOOL pbool ) PURE;              // 6

    STDMETHOD(GetMaxClients)( UINT *pint ) PURE;                // 7
    STDMETHOD(SetMaxClients)( UINT pint ) PURE;                 // 8

    STDMETHOD(GetCurrentClientCount)( UINT *pint ) PURE;        // 9
    STDMETHOD(SetCurrentClientCount)( UINT pint ) PURE;         // 10

    STDMETHOD(GetAnswerRequests)( BOOL *pbool ) PURE;           // 11
    STDMETHOD(SetAnswerRequests)( BOOL pbool ) PURE;            // 12

    STDMETHOD(GetAnswerOnlyValidClients)( BOOL *pbool ) PURE;   // 13
    STDMETHOD(SetAnswerOnlyValidClients)( BOOL pbool ) PURE;    // 14

    STDMETHOD(GetNewMachineNamingPolicy)( LPWSTR *pwsz ) PURE;  // 15
    STDMETHOD(SetNewMachineNamingPolicy)( LPWSTR pwsz ) PURE;   // 16

    STDMETHOD(GetNewMachineOU)( LPWSTR *pwsz ) PURE;            // 17
    STDMETHOD(SetNewMachineOU)( LPWSTR pwsz ) PURE;             // 18

    STDMETHOD(EnumIntelliMirrorOSes)( DWORD dwFlags, LPUNKNOWN *punk ) PURE;             // 19
    STDMETHOD(GetDefaultIntelliMirrorOS)( LPWSTR * pszName, LPWSTR * pszTimeout ) PURE;  // 20
    STDMETHOD(SetDefaultIntelliMirrorOS)( LPWSTR pszName, LPWSTR pszTimeout ) PURE;      // 21

    STDMETHOD(EnumTools)( DWORD dwFlags, LPUNKNOWN *punk ) PURE;            // 22
    STDMETHOD(EnumLocalInstallOSes)( DWORD dwFlags, LPUNKNOWN *punk ) PURE; // 23

    STDMETHOD(GetServerDN)( LPWSTR *pwsz ) PURE;              // 24
    STDMETHOD(SetServerDN)( LPWSTR pwsz ) PURE;               // 25

    STDMETHOD(GetSCPDN)( LPWSTR * pwsz ) PURE;                  // 26
    STDMETHOD(GetGroupDN)( LPWSTR * pwsz ) PURE;                // 27

    STDMETHOD(GetServerName)( LPWSTR *pwsz ) PURE;              // 28

    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj ) PURE;   // 29
    STDMETHOD(GetNotifyWindow)( HWND * phNotifyObj ) PURE;      // 30
};

typedef IIntelliMirrorSAP *LPINTELLIMIRRORSAP;

// CService
class 
CService:
    public IShellExtInit, IShellPropSheetExt, IIntelliMirrorSAP
{
private:
    // Enums
    enum { 
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    UINT  _uMode;               // Admin or Shell mode
    LPWSTR _pszSCPDN;           // LDAP path to SCP
    LPWSTR _pszGroupDN;         // LDAP path to group. If NULL, not in a group.
    LPWSTR _pszMachineName;     // Machine Name
    LPWSTR _pszDSServerName;    // Save this so we use the same as DSADMIN

    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CService );

    LPDATAOBJECT      _pDataObj;    // DSA's data object
    HWND              _hwndNotify;  // DSA notify window
    ADSPROPINITPARAMS _InitParams;  // DSA init params

    IADs *   _pads;             // ADs to MAO    

private: // Methods
    CService();
    ~CService();
    STDMETHOD(Init)();

    HRESULT _GetDefaultSIF( LPWSTR pszAttribute, LPWSTR * pszName, LPWSTR * pszTimeout );
    HRESULT _SetDefaultSIF( LPWSTR pszAttribute, LPWSTR pszName, LPWSTR pszTimeout );
    HRESULT _GetComputerNameFromADs( );
    HRESULT _FixObjectPath( LPWSTR pszOldObjectPath, LPWSTR *ppszNewObjectPath );

public: // Methods
    friend LPVOID CService_CreateInstance( void );
    STDMETHOD(Init2)( IADs * pads );

    // IUnknown
    STDMETHOD(QueryInterface)( REFIID riid, LPVOID *ppv );
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IShellExtInit
    STDMETHOD(Initialize)( LPCITEMIDLIST pidlFolder, LPDATAOBJECT lpdobj, HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
                            LPARAM lParam);

    // IIntelliMirrorSAP
    STDMETHOD(CommitChanges)( void );
    STDMETHOD(IsAdmin)( BOOL * pbool );

    STDMETHOD(GetAllowNewClients)( BOOL *pbool );
    STDMETHOD(SetAllowNewClients)( BOOL pbool );

    STDMETHOD(GetLimitClients)( BOOL *pbool );
    STDMETHOD(SetLimitClients)( BOOL pbool );

    STDMETHOD(GetMaxClients)( UINT *pint );
    STDMETHOD(SetMaxClients)( UINT pint );

    STDMETHOD(GetCurrentClientCount)( UINT *pint );
    STDMETHOD(SetCurrentClientCount)( UINT pint );

    STDMETHOD(GetAnswerRequests)( BOOL *pbool );
    STDMETHOD(SetAnswerRequests)( BOOL pbool );

    STDMETHOD(GetAnswerOnlyValidClients)( BOOL *pbool );
    STDMETHOD(SetAnswerOnlyValidClients)( BOOL pbool );

    STDMETHOD(GetNewMachineNamingPolicy)( LPWSTR *pwsz );
    STDMETHOD(SetNewMachineNamingPolicy)( LPWSTR pwsz );

    STDMETHOD(GetNewMachineOU)( LPWSTR *pwsz );
    STDMETHOD(SetNewMachineOU)( LPWSTR pwsz );

    STDMETHOD(EnumIntelliMirrorOSes)( DWORD dwFlags, LPUNKNOWN *punk );
    STDMETHOD(GetDefaultIntelliMirrorOS)( LPWSTR * pszName, LPWSTR * pszTimeout );
    STDMETHOD(SetDefaultIntelliMirrorOS)( LPWSTR pszName, LPWSTR pszTimeout );

    STDMETHOD(EnumTools)( DWORD dwFlags, LPUNKNOWN *punk );
    STDMETHOD(EnumLocalInstallOSes)( DWORD dwFlags, LPUNKNOWN *punk );

    STDMETHOD(GetServerDN)( LPWSTR *pwsz );
    STDMETHOD(SetServerDN)( LPWSTR pwsz );

    STDMETHOD(GetSCPDN)( LPWSTR * pwsz );
    STDMETHOD(GetGroupDN)( LPWSTR * pwsz );

    STDMETHOD(GetServerName)( LPWSTR * pwsz );

    STDMETHOD(GetDataObject)( LPDATAOBJECT * pDataObj );
    STDMETHOD(GetNotifyWindow)( HWND * phNotifyObj );
};

typedef CService* LPSERVICE;

#endif // _CSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\cservice.cpp ===
//
// Copyright 1997 - Microsoft

//
// CCOMPUTR.CPP - Handles the computer object property pages.
//

#include "pch.h"

#include "imos.h"
#include "local.h"
#include "newclnts.h"
#include "tools.h"
#include "varconv.h"

#include "cservice.h"
#include "cenumsif.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CService")
#define THISCLASS CService
#define LPTHISCLASS LPSERVICE


// ************************************************************************
//
// Constructor / Destructor
//
// ************************************************************************

//
// CreateInstance()
//
LPVOID
CService_CreateInstance( void )
{
	TraceFunc( "CService_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID)lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CService()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    TraceClsFunc( "Init()\n" );

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CService, IShellExtInit );
    QITABLE_IMP( IShellExtInit );
    QITABLE_IMP( IShellPropSheetExt );
    QITABLE_IMP( IIntelliMirrorSAP );
    END_QITABLE_IMP( CService );

    Assert( _cRef == 0);
    Assert( !_pads );
    Assert( !_pszSCPDN );
    Assert( !_pszGroupDN );
    Assert( !_pszMachineName );
    AddRef( );

    _InitParams.dwSize = sizeof(_InitParams);

    HRESULT hr = S_OK;

    hr = CheckClipboardFormats( );

    // Private Members
    Assert( _pads == NULL );
    _uMode = MODE_SHELL; // default

    HRETURN(hr);
}

STDMETHODIMP
THISCLASS::Init2( IADs * pads )
{
    TraceClsFunc( "Init2( " );
    TraceMsg( TF_FUNC, "pads = 0x%08x )\n", pads );

    HRESULT hr;

    if ( !pads )
        HRETURN(E_INVALIDARG);

    _pads = pads;
    _pads->AddRef( );

    hr = _GetComputerNameFromADs( );
    if (FAILED( hr ))
        goto Error;

Error:
    HRETURN(hr);
}


//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CService()\n" );

    // Private Members
    if ( _pads )
    {
        //
        // note: we shouldn't commit anything in the destructor -- we can't 
        // catch failures here.  We'll just have to make sure that we 
        // explicitly commit changes when necessary
        //
#if 0
        // Commit any changes before we release
        THR( _pads->SetInfo( ) );
#endif
        _pads->Release( );
    }

    if ( _pszSCPDN )
        TraceFree( _pszSCPDN );

    if ( _pszGroupDN )
        TraceFree( _pszGroupDN );

    if ( _pszMachineName )
        TraceFree( _pszMachineName );

    if ( _pszDSServerName )
        TraceFree( _pszDSServerName );

    if ( _pDataObj )
        _pDataObj->Release( );

#if 0 // EricB might be adding an AddRef( ) to this. Until then, don't release.
    if ( _InitParams.pDsObj )
        _InitParams.pDsObj->Release( );
#endif

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}


// ************************************************************************
//
// IShellExtInit
//
// ************************************************************************

//
// Initialize()
//
HRESULT
THISCLASS::Initialize(
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT lpdobj, HKEY hkeyProgID)
{
    TraceClsFunc( "[IShellExtInit] Initialize( " );
    TraceMsg( TF_FUNC, " pidlFolder = 0x%08x, lpdobj = 0x%08x, hkeyProgID = 0x%08x )\n",
        pidlFolder, lpdobj, hkeyProgID );

    if ( !lpdobj )
        RETURN(E_INVALIDARG);

    HRESULT    hr = S_OK;
    FORMATETC  fmte;
    STGMEDIUM  stg = { 0 };
    STGMEDIUM  stgOptions = { 0 };

    LPWSTR     pszObjectName;
    LPWSTR     pszClassName;
    LPWSTR     pszAttribPrefix;

    LPDSOBJECT             pDsObject;
    LPDSOBJECTNAMES        pDsObjectNames;
    LPDSDISPLAYSPECOPTIONS pDsDisplayOptions;

    BOOL b;

#if 0
    IADs * padsGroup     = NULL;
    LPWSTR pszGroupClass = NULL;
    LPWSTR pszParent     = NULL;
#endif

    _pDataObj = lpdobj;
    _pDataObj->AddRef( );

    //
    // Retrieve the Object Names
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsObjectNames;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( _pDataObj->GetData( &fmte, &stg) );
    if ( hr )
        goto Cleanup;

    pDsObjectNames = (LPDSOBJECTNAMES) stg.hGlobal;

    Assert( stg.tymed == TYMED_HGLOBAL );

    TraceMsg( TF_ALWAYS, "Object's Namespace CLSID: " );
    TraceMsgGUID( TF_ALWAYS, pDsObjectNames->clsidNamespace );
    TraceMsg( TF_ALWAYS, "\tNumber of Objects: %u \n", pDsObjectNames->cItems );

    Assert( pDsObjectNames->cItems == 1 );

    pDsObject = (LPDSOBJECT) pDsObjectNames->aObjects;

    pszObjectName = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetName );
    pszClassName  = (LPWSTR) PtrToByteOffset( pDsObjectNames, pDsObject->offsetClass );

    TraceMsg( TF_ALWAYS, "Object Name (Class): %s (%s)\n", pszObjectName, pszClassName );

    _pszDSServerName = TraceStrDup( pszObjectName );

    //
    // If they handed us a "Computer" object, look at the NETBOOTSAP
    // attribute to get the IMSAP object.
    //
    if ( StrCmp( pszClassName, DSCOMPUTERCLASSNAME ) == 0 )
    {
        IADs*   pads = NULL;
        VARIANT var;

        VariantInit( &var );

        Assert( !_pszMachineName );
        //
        // Bind to the MAO in the DS
        //
        hr = THR( ADsGetObject( pszObjectName, IID_IADs, (void **)&pads ) );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        hr = THR( pads->Get( NETBOOTSAP, &var ) );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        Assert( V_VT( &var ) == VT_BSTR );

        // Try to parse the string to connect to the same server as the DSADMIN
        hr = _FixObjectPath( V_BSTR( &var ), &_pszSCPDN );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        DebugMsg( "SCP Path: %s\n", _pszSCPDN );
        VariantClear( &var );

        // while we are here, might as well get the server's NETBIOS name
        hr = THR( pads->Get( SAMNAME, &var ) );
        if (FAILED( hr ))
            goto Computer_Cleanup;

        Assert( V_VT( &var) == VT_BSTR );
        _pszMachineName = TraceStrDup( V_BSTR( &var ) );
        if ( _pszMachineName )
        {
            LPWSTR psz = &_pszMachineName[ wcslen( _pszMachineName ) - 1 ];
            if ( *psz == L'$' )
            {
                *psz = L'\0';
            }
            DebugMsg( "Server Name: %ws\n", _pszMachineName );
        }

Computer_Cleanup:
        VariantClear( &var );

        if ( pads )
            pads->Release( );

        if (FAILED( hr ))
            goto Error;

        // create the DS notify object
        hr = THR( ADsPropCreateNotifyObj( _pDataObj, pszObjectName, &_hwndNotify ) );
        if (FAILED( hr ))
            goto Error;

        b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
        if ( !b )
        {
            hr = E_FAIL;
            goto Error;
        }

        hr = THR( _InitParams.hr );
        if (FAILED( hr ))
            goto Error;

        // Bind to the IMSAP in the DS
        Assert( _pszSCPDN );
        hr = THR( ADsGetObject( _pszSCPDN, IID_IADs, (void **)&_pads ) );
        if (FAILED( hr ))
            goto Error;
    }
    else if ( StrCmp( pszClassName, DSIMSAPCLASSNAME ) )
    {
        //
        // This should be a IMSAP.
        //
        hr = E_INVALIDARG;
        goto Error;
    }
    else
    {
        // Keep the DN around
        _pszSCPDN = TraceStrDup( pszObjectName );
        Assert( !_pszMachineName );

        // create the DS notify object
        hr = THR( ADsPropCreateNotifyObj( _pDataObj, pszObjectName, &_hwndNotify ) );
        if (FAILED( hr ))
            goto Error;

        b = ADsPropGetInitInfo( _hwndNotify, &_InitParams );
        if ( !b )
        {
            hr = E_FAIL;
            goto Error;
        }

        hr = THR( _InitParams.hr );
        if (FAILED( hr ))
            goto Error;

        // Bind to the IMSAP in the DS
        Assert( _pszSCPDN );
        hr = THR( _InitParams.pDsObj->QueryInterface( IID_IADs, (void **)&_pads ) );
        if (FAILED( hr ))
            goto Error;
    }

    Assert( _pads );
    //
    // Retrieve the Display Spec Options
    //
    fmte.cfFormat = (CLIPFORMAT)g_cfDsDisplaySpecOptions;
    fmte.tymed    = TYMED_HGLOBAL;
    fmte.dwAspect = DVASPECT_CONTENT;
    fmte.lindex   = -1;
    fmte.ptd      = 0;

    hr = THR( _pDataObj->GetData( &fmte, &stgOptions ) );
    if ( hr )
        goto Error;

    pDsDisplayOptions = (LPDSDISPLAYSPECOPTIONS) stgOptions.hGlobal;

    Assert( stgOptions.tymed == TYMED_HGLOBAL );
    Assert( pDsDisplayOptions->dwSize == sizeof(DSDISPLAYSPECOPTIONS) );

    pszAttribPrefix = (LPWSTR) PtrToByteOffset( pDsDisplayOptions, pDsDisplayOptions->offsetAttribPrefix );

    // TraceMsg( TF_ALWAYS, TEXT("Attribute Prefix: %s\n"), pszAttribPrefix );

    if ( StrCmpW( pszAttribPrefix, STRING_ADMIN ) == 0 )
    {
        _uMode = MODE_ADMIN;
    }
    // else default from Init()

    TraceMsg( TF_ALWAYS, TEXT("Mode: %s\n"), _uMode == MODE_ADMIN ? TEXT("Admin") : TEXT("Shell") );

    ReleaseStgMedium( &stgOptions );

#if 0
    //
    // Check to see if it is in a Group by checking the parent DN's class
    //
    pszParent = StrChr( _pszSCPDN, L',' );
    Assert( pszParent );
    if ( !pszParent ) {
        hr = THR(E_FAIL);
        goto Error;
    }
    pszParent++;    // move just past the comma

    // create a new string by adding "LDAP://server/"
    hr = _FixObjectPath( pszParent, &pszParent );
    if (FAILED( hr ))
        goto Error;

    // Bind to the object
    hr = THR( ADsGetObject( pszParent, IID_IADs, (void **)&padsGroup ) );
    if (FAILED( hr ))
        goto Error;

    Assert( !pszGroupClass );
    hr = THR( padsGroup->get_Class( &pszGroupClass ) );
    if (FAILED( hr ))
        goto Error;

    Assert( !_pszGroupDN );
    DebugMsg( "SCP's parents Class is '%s'\n", pszGroupClass );

    if ( StrCmpI( pszGroupClass, DSGROUPCLASSNAME ) == 0 ) {
        _pszGroupDN = (LPWSTR) TraceStrDup( pszObjectName );
        TraceMsg( TF_ALWAYS, TEXT("Server is in group: %s\n"), _pszGroupDN );
    }
#endif

Cleanup:
#if 0
    if ( pszGroupClass )
        SysFreeString( pszGroupClass );

    if ( pszParent )
        TraceFree( pszParent );        

    if ( padsGroup )
        padsGroup->Release();
#endif
    HRETURN(hr);

Error:
    MessageBoxFromHResult( NULL, IDS_ERROR_READINGCOMPUTERACCOUNT, hr );
    goto Cleanup;
}


// ************************************************************************
//
// IShellPropSheetExt
//
// ************************************************************************

//
// AddPages()
//
HRESULT
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
{
    TraceClsFunc( "[IShellPropSheetExt] AddPages( )\n" );

    if ( !lpfnAddPage )
        RRETURN(E_POINTER);

    HRESULT hr = S_OK;

    hr = THR( ::AddPagesEx( NULL,
                            CNewClientsTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

    hr = THR( ::AddPagesEx( NULL,
                            CIntelliMirrorOSTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

#ifdef LOCALOS_PAGE
    hr = THR( ::AddPagesEx( NULL,
                            CLocalInstallOSTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;
#endif // LOCALOS_PAGE

    hr = THR( ::AddPagesEx( NULL,
                            CToolsTab_CreateInstance,
                            lpfnAddPage,
                            lParam,
                            (LPUNKNOWN) (IShellExtInit*) this ) );
    if (FAILED( hr ))
        goto Error;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
HRESULT
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam )
{

    TraceClsFunc( "[IShellPropSheetExt] ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

// ************************************************************************
//
// IIntelliMirrorSAP
//
// ************************************************************************

//
// CommitChanges( )
//
HRESULT
THISCLASS::CommitChanges( void )
{
    TraceClsFunc( "[IIntelliMirrorSAP] CommitChanges( )\n" );

    Assert( _pads );

    HRESULT        hr;
    SC_HANDLE      schManager = NULL;
    SC_HANDLE      sch = NULL;
    SERVICE_STATUS ss;

    hr = THR( _pads->SetInfo( ) );
    if ( FAILED( hr ) )
        goto Error;

    // if we don't have this yet, get it now.
    if ( !_pszMachineName )
    {
        hr = _GetComputerNameFromADs( );
        if (FAILED( hr ))
            goto Error;
    }

    schManager = OpenSCManager( _pszMachineName, NULL, SC_MANAGER_CONNECT );
    if (!schManager)
    {
        DWORD dwErr = GetLastError( );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    sch = OpenService( schManager, BINL_SERVER_NAME, SERVICE_USER_DEFINED_CONTROL);
    if (!sch)
    {
        DWORD dwErr = GetLastError( );
        hr = HRESULT_FROM_WIN32( dwErr );
        goto Error;
    }

    if ( !ControlService( sch, BINL_SERVICE_REREAD_SETTINGS, &ss ) )
    {
        DWORD dwErr = GetLastError( );
        hr = THR(HRESULT_FROM_WIN32( dwErr ));
        goto Error;
    }

    hr = HRESULT_FROM_WIN32( ss.dwWin32ExitCode );

Error:
    if ( sch )
        CloseServiceHandle( sch );
    if ( schManager )
        CloseServiceHandle( schManager );

    if ( hr == HRESULT_FROM_WIN32( ERROR_SERVICE_NOT_ACTIVE ) )
    {
        hr = S_OK;  // ignore error... by design
    }

    HRETURN(hr);
}


//
// IsAdmin( )
//
HRESULT
THISCLASS::IsAdmin(
    BOOL * fAdmin )
{
    TraceClsFunc( "[IIntelliMirrorSAP] IsAdmin( )\n" );

    if ( !fAdmin )
        RRETURN( E_INVALIDARG );

    HRESULT hr = S_OK;

    *fAdmin = (_uMode == MODE_ADMIN);

    HRETURN(hr);
}

//
// GetAllowNewClients( )
//
HRESULT
THISCLASS::GetAllowNewClients(
    BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAllowNewClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTALLOWNEWCLIENTS, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL )
    {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}

//
// SetAllowNewClients( )
//
HRESULT
THISCLASS::SetAllowNewClients(
    BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAllowNewClients( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTALLOWNEWCLIENTS, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetLimitClients( )
//
HRESULT
THISCLASS::GetLimitClients(
    BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetLimitClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTLIMITCLIENTS, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL )
    {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetLimitClients( )
//
HRESULT
THISCLASS::SetLimitClients(
    BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetLimitClients( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTLIMITCLIENTS, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetMaxClients( )
//
HRESULT
THISCLASS::GetMaxClients(
    UINT *puMax )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetMaxClients( ... )\n" );

    if ( !puMax )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTMAXCLIENTS, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_I4 )
    {
        *puMax = V_I4(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetMaxClients( )
//
HRESULT
THISCLASS::SetMaxClients(
    UINT uMax )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetMaxClients( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_I4;
    V_I4( &var ) = uMax;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTMAXCLIENTS, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetCurrentClientCount( )
//
HRESULT
THISCLASS::GetCurrentClientCount(
    UINT *puCount )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetCurrentClientCount( ... )\n" );

    if ( !puCount )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTCURRENTCLIENTCOUNT, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_I4 )
    {
        *puCount = V_I4(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetCurrentClientCount( )
//
HRESULT
THISCLASS::SetCurrentClientCount(
    UINT uCount )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetCurrentClientCount( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_I4;
    V_I4( &var ) = uCount;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTCURRENTCLIENTCOUNT, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetAnswerRequests( )
//
HRESULT
THISCLASS::GetAnswerRequests(
    BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAnswerRequests( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTANSWERREQUESTS, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL )
    {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetAnswerRequests( )
//
HRESULT
THISCLASS::SetAnswerRequests(
    BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAnswerRequests( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTANSWERREQUESTS, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetAnswerOnlyValidClients( )
//
HRESULT
THISCLASS::GetAnswerOnlyValidClients(
    BOOL *pbool )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetAnswerOnlyValidClients( ... )\n" );

    if ( !pbool )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTANSWERONLYVALIDCLIENTS, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BOOL )
    {
        *pbool = V_BOOL(&var);
        hr = S_OK;
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetAnswerOnlyValidClients( )
//
HRESULT
THISCLASS::SetAnswerOnlyValidClients(
    BOOL boolval )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetAnswerOnlyValidClients( ... )\n" );

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );
    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = (VARIANT_BOOL)boolval;

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTANSWERONLYVALIDCLIENTS, var ) );

    VariantClear( &var );

    HRETURN(hr);
}


//
// GetNewMachineNamingPolicy( )
//
HRESULT
THISCLASS::GetNewMachineNamingPolicy(
    LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetNewMachineNamingPolicy( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTNEWMACHINENAMINGPOLICY, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR )
    {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if (!*pwsz) 
        {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetNewMachineNamingPolicy( )
//
HRESULT
THISCLASS::SetNewMachineNamingPolicy(
    LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetNewMachineNamingPolicy( ... )\n" );

    HRESULT hr;
    VARIANT var;
    Assert( _pads );

    if ( pwsz )
    {
        V_VT( &var ) = VT_BSTR;
        V_BSTR( &var ) = SysAllocString( pwsz );

        if (V_BSTR(&var) == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }

        hr = THR( _pads->Put( NETBOOTNEWMACHINENAMINGPOLICY, var ) );
        VariantClear( &var );
    }
    else
    {
        VariantInit( &var );
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, NETBOOTNEWMACHINENAMINGPOLICY, var ) );
    }

    HRETURN(hr);
}


//
// GetNewMachineOU( )
//
HRESULT
THISCLASS::GetNewMachineOU(
    LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetNewMachineOU( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTNEWMACHINEOU, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR )
    {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if (!*pwsz)
        {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetNewMachineOU( )
//
HRESULT
THISCLASS::SetNewMachineOU(
    LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetNewMachineOU( ... )\n" );

    HRESULT hr;
    VARIANT var;

    Assert( _pads );

    if ( pwsz )
    {
        V_VT( &var ) = VT_BSTR;
        V_BSTR( &var ) = SysAllocString( pwsz );

        if (V_BSTR(&var) == NULL) {
            RRETURN(E_OUTOFMEMORY);
        }

        hr = THR( _pads->Put( NETBOOTNEWMACHINEOU, var ) );
        VariantClear( &var );
    }
    else
    {
        VariantInit( &var );
        hr = THR( _pads->PutEx( ADS_PROPERTY_CLEAR, NETBOOTNEWMACHINEOU, var ) );
    }

    HRETURN(hr);
}


//
// EnumIntelliMirrorOSes( )
//
HRESULT
THISCLASS::EnumIntelliMirrorOSes(
    DWORD dwFlags,
    LPUNKNOWN *punk )
{
    TraceClsFunc("[IIntelliMirrorSAP] EnumIntelliMirrorOSes( ... )\n" );

    if ( !punk )
        RRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;

    Assert( _pads );

    *punk = (LPUNKNOWN)
        CEnumIMSIFs_CreateInstance( REMOTE_INSTALL_IMAGE_DIR_W, NETBOOTINTELLIMIRROROSES, dwFlags, _pads );

    if ( !*punk )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);
}


//
// EnumTools( )
//
HRESULT
THISCLASS::EnumTools(
    DWORD dwFlags,
    LPUNKNOWN *punk )
{
    TraceClsFunc("[IIntelliMirrorSAP] EnumTools( ... )\n" );

    if ( !punk )
        RETURN(E_INVALIDARG);

    HRESULT hr = S_OK;

    Assert( _pads );

    *punk = (LPUNKNOWN)
        CEnumIMSIFs_CreateInstance( REMOTE_INSTALL_TOOLS_DIR_W, NETBOOTTOOLS, dwFlags, _pads );

    if ( !*punk )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);}

//
// EnumLocalInstallOSes( )
//
HRESULT
THISCLASS::EnumLocalInstallOSes(
    DWORD dwFlags,
    LPUNKNOWN *punk )
{
    TraceClsFunc("[IIntelliMirrorSAP] EnumLocalInstallOSes( ... )\n" );

    if ( !punk )
        RRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;

    Assert( _pads );

#if 0
    *punk = (LPUNKNOWN)
        CEnumIMSIFs_CreateInstance( LOCALOSES, NETBOOTLOCALINSTALLOSES, dwFlags, _pads );
#else
    *punk = NULL;
#endif

    if ( !*punk )
    {
        hr = E_FAIL;
    }

    HRETURN(hr);}


//
// GetServerDN( )
//
HRESULT
THISCLASS::GetServerDN(
    LPWSTR *pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] GetServerDN( ... )\n" );

    if ( !pwsz )
        RRETURN(E_POINTER);

    HRESULT hr;
    VARIANT var;

    VariantInit( &var );

    Assert( _pads );

    hr = _pads->Get( NETBOOTSERVER, &var );
    if (hr && hr != E_ADS_PROPERTY_NOT_FOUND )
        goto Cleanup;

    if ( V_VT(&var) == VT_BSTR )
    {
        *pwsz = TraceStrDup( V_BSTR(&var) );
        if ( !*pwsz )
        {
            hr = E_OUTOFMEMORY;
        }
    }

Cleanup:
    VariantClear( &var );

    HRETURN(hr);
}


//
// SetServerDN( )
//
HRESULT
THISCLASS::SetServerDN(
    LPWSTR pwsz )
{
    TraceClsFunc("[IIntelliMirrorSAP] SetServerDN( ... )\n" );

    if ( !pwsz )
        RRETURN(E_INVALIDARG);

    HRESULT hr;
    VARIANT var;

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwsz );

    if (V_BSTR(&var) == NULL) {
        RRETURN(E_OUTOFMEMORY);
    }

    Assert( _pads );

    hr = THR( _pads->Put( NETBOOTSERVER, var ) );

    VariantClear( &var );

    HRETURN(hr);
}

//
// GetDefaultIntelliMirrorOS( )
//
HRESULT
THISCLASS::GetDefaultIntelliMirrorOS(
    LPWSTR * pszName,
    LPWSTR * pszTimeout )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetDefaultIntelliMirrorOS( ...)\n" );

    HRESULT hr;

    hr = _GetDefaultSIF( NETBOOTINTELLIMIRROROSES, pszName, pszTimeout );

    HRETURN(hr);
}

//
// SetDefaultIntelliMirrorOS( )
//
HRESULT
THISCLASS::SetDefaultIntelliMirrorOS(
    LPWSTR pszName,
    LPWSTR pszTimeout )
{
    TraceClsFunc( "[IIntelliMirrorSAP] SetDefaultIntelliMirrorOS( " );
    TraceMsg( TF_FUNC, "pszName = '%s', pszTimeout = '%s' )\n",
        pszName, pszTimeout );

    HRESULT hr;

    hr = _SetDefaultSIF( NETBOOTINTELLIMIRROROSES, pszName, pszTimeout );

    HRETURN(hr);
}

//
// _GetDefaultSIF( )
//
HRESULT
THISCLASS::_GetDefaultSIF(
    LPWSTR pszAttribute,
    LPWSTR * pszName,
    LPWSTR * pszTimeout )
{
    TraceClsFunc( "_GetDefaultSIF( " );
    TraceMsg( TF_FUNC, "pszAttribute = '%s', ... )\n" , pszAttribute );

    if ( !pszAttribute )
        RRETURN(E_POINTER);

    if ( !pszName )
        RRETURN(E_POINTER);

    if ( !pszTimeout )
        RRETURN(E_POINTER);

    HRESULT   hr;
    LONG      lUBound;
    VARIANT   var;
    VARIANT * pvar;

    VariantInit( &var );
    *pszName = NULL;
    *pszTimeout = NULL;

    Assert( _pads );

    hr = THR( _pads->GetEx( pszAttribute, &var ) );
    if (FAILED( hr ))
        goto Error;

    //
    // Make sure that the var is an array of VARIANTs
    //
    if ( V_VT( &var ) != ( VT_ARRAY | VT_VARIANT ) )
    {
        hr = ERROR_INVALID_DATA;
        goto Error;
    }

    Assert( SafeArrayGetDim( V_ARRAY( &var ) ) == 1 );
#ifdef DEBUG
    {
        LONG lLBound;
        SafeArrayGetLBound( V_ARRAY( &var ), 1, &lLBound );
        Assert( lLBound == 0 );
    }
#endif // DEBUG

    SafeArrayGetUBound( V_ARRAY( &var ), 1, &lUBound );

    //
    // Copy the required data
    //
    SafeArrayAccessData( V_ARRAY( &var ), (void **)&pvar );
    *pszName    = (LPWSTR) TraceStrDup( V_BSTR( &pvar[ 0 ] ) );
    if (!*pszName)
    {
        SafeArrayUnaccessData( V_ARRAY( &var ) );
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    if ( lUBound == 2 )
    {
        *pszTimeout = (LPWSTR) TraceStrDup( V_BSTR( &pvar[ 1 ] ) );
        if ( !*pszTimeout )
        {
            SafeArrayUnaccessData( V_ARRAY( &var ) );
            hr = E_OUTOFMEMORY;
            goto Error;
        }
    }

    SafeArrayUnaccessData( V_ARRAY( &var ) );

Error:
    VariantClear( &var );

    HRETURN(hr);
}

//
// _SetDefaultSIF( )
//
HRESULT
THISCLASS::_SetDefaultSIF(
    LPWSTR pszAttribute,
    LPWSTR pszName,
    LPWSTR pszTimeout )
{
    TraceClsFunc( "_SetDefaultSIF( " );
    TraceMsg( TF_FUNC, "pszAttribute = '%s', ... )\n" , pszAttribute );

    if ( !pszAttribute )
        RRETURN(E_POINTER);

    if ( !pszName )
        RRETURN(E_POINTER);

    if ( !pszTimeout )
        RRETURN(E_POINTER);

    HRESULT   hr;
    LONG      lUBound;
    VARIANT   var;
    LPWSTR    pszStrings[ 2 ];

    pszStrings[0] = pszName;
    pszStrings[1] = pszTimeout;

    VariantInit( &var );

    hr = THR( StringArrayToVariant( &var, pszStrings, 2 ) );
    if (FAILED( hr ))
        goto Error;

    Assert( _pads );
    hr = THR( _pads->Put( pszAttribute, var ) );
    if (FAILED( hr ))
        goto Error;

Error:
    VariantClear( &var );

    HRETURN(hr);
}

//
// GetSCPDN( )
//
HRESULT
THISCLASS::GetSCPDN(
    LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetSCPDN( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN( E_POINTER );

    if ( _pszSCPDN ) {
		LPWSTR psz = StrRChr( _pszSCPDN, NULL, L'/' );
		if ( psz )
		{
			psz++;
		}
		else
		{
			psz = _pszSCPDN;
		}
        *ppwsz = (LPWSTR) TraceStrDup( psz );
        if ( !*ppwsz )
        {
            hr = E_OUTOFMEMORY;
        }
    } else {
        *ppwsz = NULL;
    }

    HRETURN(hr);
}

//
// GetGroupDN( )
//
HRESULT
THISCLASS::GetGroupDN(
    LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetGroupDN( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN( E_POINTER );

    if ( _pszGroupDN ) {
        *ppwsz = (LPWSTR) TraceStrDup( _pszGroupDN );
        if ( !*ppwsz )
        {
            hr = E_OUTOFMEMORY;
        }
    } else {
        *ppwsz = NULL;
        hr = S_FALSE;
    }

    HRETURN(hr);
}

//
// GetServerName( )
//
STDMETHODIMP
THISCLASS::GetServerName(
    LPWSTR * ppwsz )
{
    TraceClsFunc( "[IIntelliMirrorSAP] GetServerName( )\n" );

    HRESULT hr = S_OK;

    if ( !ppwsz )
        HRETURN(E_POINTER);

    *ppwsz = NULL;

    if ( !_pszMachineName )
    {
        hr = _GetComputerNameFromADs( );
        if (FAILED( hr ))
            goto Error;
    }

    if ( _pszMachineName )
    {
        *ppwsz = (LPWSTR) TraceStrDup( _pszMachineName );
        if ( !*ppwsz )
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }
Error:
    HRETURN(hr);

}

//
// _GetComputerNameFromADs( )
//
HRESULT
THISCLASS::_GetComputerNameFromADs( )
{
    TraceClsFunc( "_GetComputerNameFromADs( )\n" );

    if ( _pszMachineName )
        HRETURN(S_OK); // nop

    HRESULT hr;
    VARIANT var;
    IADs    *pads = NULL;
    LPWSTR  pszMachinePath = NULL;
    LPWSTR  psz;

    VariantInit( &var );

    // Retrieve the NETBOOTSERVER attribute
    hr = THR( _pads->Get( NETBOOTSERVER, &var ) );
    if (FAILED( hr ))
        goto Cleanup;

    Assert( V_VT( &var ) == VT_BSTR );
    hr = _FixObjectPath( V_BSTR( &var ), &pszMachinePath );
    if (FAILED( hr ))
        goto Cleanup;

    VariantClear( &var );

    hr = THR( ADsGetObject( pszMachinePath, IID_IADs, (void**) &pads ) );
    if (FAILED( hr ))
        goto Cleanup;

    hr = THR( pads->Get( SAMNAME, &var ) );
    if (FAILED( hr ))
        goto Cleanup;

    Assert( V_VT( &var ) == VT_BSTR );
    _pszMachineName = TraceStrDup( V_BSTR( &var ) );
    if ( !_pszMachineName )
        goto OutOfMemory;

    psz = &_pszMachineName[ wcslen( _pszMachineName ) - 1 ];
    if ( *psz == L'$' )
    {
        *psz = L'\0';
    }

    DebugMsg( "Server Name: %ws\n", _pszMachineName );

Cleanup:
    VariantClear( &var );
    if ( pads )
        pads->Release( );
    if ( pszMachinePath )
        TraceFree( pszMachinePath );
    HRETURN(hr);
OutOfMemory:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//
// _FixObjectPath( )
//
HRESULT
THISCLASS::_FixObjectPath( LPWSTR pszOldObjectPath, LPWSTR *ppszNewObjectPath )
{
    TraceClsFunc( "_FixObjectPath()\n" );
    if ( !ppszNewObjectPath )
        HRETURN(E_POINTER);

    HRESULT hr;
    LPWSTR psz = NULL;

    *ppszNewObjectPath = NULL;

    // Try to parse the string to connect to the same server as the DSADMIN
    if ( _pszDSServerName && StrCmpNI( _pszDSServerName, L"LDAP://", 7 ) == 0 )
    {
        psz = _pszDSServerName + 7;
    }
    else if ( _pszDSServerName && StrCmpNI( _pszDSServerName, L"GC://", 5 ) == 0 )
    {
        psz = _pszDSServerName + 5;
    }

    if ( psz )
    {
        psz = StrChr( psz, L'/' );
        psz++;

        INT_PTR uLen = psz - _pszDSServerName;

        // get a chunk of memory, pre-zero'ed
        psz = TraceAllocString( LPTR, (size_t) uLen + wcslen( pszOldObjectPath ) + 1 );
        if ( !psz )
            goto OutOfMemory;

        MoveMemory( psz, _pszDSServerName, uLen * sizeof(WCHAR) );
        wcscat( psz, pszOldObjectPath);
        *ppszNewObjectPath = psz;
    }
    else
    {   // find another server
        hr = THR( LDAPPrefix( pszOldObjectPath, ppszNewObjectPath ) );
    }

    Assert( ppszNewObjectPath || hr != S_OK );

    HRETURN(hr);
OutOfMemory:
    HRETURN(E_OUTOFMEMORY);
}

//
// GetDataObject( )
//
STDMETHODIMP
THISCLASS::GetDataObject( 
    LPDATAOBJECT * pDataObj 
    )
{
    TraceClsFunc( "GetDataObject( ... )\n" );

    if ( !pDataObj )
        HRETURN( E_POINTER );

    *pDataObj = _pDataObj;
    _pDataObj->AddRef( );

    HRETURN(S_OK);
}

//
// GetNotifyWindow( )
//
STDMETHODIMP
THISCLASS::GetNotifyWindow( 
    HWND * phNotifyObj 
    )
{
    TraceClsFunc( "GetNotifyWindow( ... )\n" );

    if ( !phNotifyObj )
        HRETURN(E_POINTER);

    *phNotifyObj = _hwndNotify;

    HRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dataobj.h ===
//
// Copyright 1997 - Microsoft
//

//
// DATAOBJ.H - A data object
//

#ifndef _DATAOBJ_H_
#define _DATAOBJ_H_

// QITable
BEGIN_QITABLE( CDsPropDataObj )
DEFINE_QI( IID_IDataObject,      IDataObject      , 9 )
END_QITABLE

LPVOID 
CDsPropDataObj_CreateInstance( 
    HWND hwndParent,
    IDataObject * pido,
    GUID * pClassGUID,
    BOOL fReadOnly,
    LPWSTR pszObjPath,
    LPWSTR bstrClass );


class CDsPropDataObj : public IDataObject
{
private:
    DECLARE_QITABLE( CDsPropDataObj );

    CDsPropDataObj::CDsPropDataObj( HWND hwndParent, IDataObject * pido, GUID * pClassGUID, BOOL fReadOnly);
    ~CDsPropDataObj(void);

    HRESULT Init(LPWSTR pwszObjName, LPWSTR pwszClass);

public:
    friend LPVOID CDsPropDataObj_CreateInstance( 
        HWND hwndParent, 
        IDataObject * pido, 
        GUID * pClassGUID, 
        BOOL fReadOnly,
        LPWSTR pszObjPath,
        LPWSTR bstrClass );

    //
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // Standard IDataObject methods
    //
    // Implemented
    //
    STDMETHOD(GetData)(FORMATETC * pformatetcIn, STGMEDIUM * pmedium);

    STDMETHOD(GetDataHere)(FORMATETC * pFormatEtcIn, STGMEDIUM * pMedium);

    STDMETHOD(EnumFormatEtc)(DWORD dwDirection,
                             IEnumFORMATETC ** ppenumFormatEtc);

    // Not Implemented
private:
    STDMETHOD(QueryGetData)(FORMATETC * pformatetc)
    { return E_NOTIMPL; };

    STDMETHOD(GetCanonicalFormatEtc)(FORMATETC * pformatectIn,
                                     FORMATETC * pformatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(FORMATETC * pformatetc, STGMEDIUM * pmedium,
                       BOOL fRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(FORMATETC * pformatetc, DWORD advf,
                       IAdviseSink * pAdvSink, DWORD * pdwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(IEnumSTATDATA ** ppenumAdvise)
    { return E_NOTIMPL; };

    BOOL                m_fReadOnly;
    PWSTR               m_pwszObjName;
    PWSTR               m_pwszObjClass;
    GUID                m_ClassGUID;
    IDataObject       * m_pPage;
    unsigned long       _cRef;
    HWND                m_hwnd;
};

typedef CDsPropDataObj * LPCDSPROPDATAOBJ;

#endif // _DATAOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dataobj.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DATAOBJ.CPP - A data object
//

#include "pch.h"
#include "dataobj.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CDsPropDataObj")
#define THISCLASS CDsPropDataObj
#define LPTHISCLASS CDsPropDataObj*


//
// CreateInstance( )
//
LPVOID 
CDsPropDataObj_CreateInstance( 
    HWND hwndParent,
    IDataObject * pido,
    GUID * pClassGUID,
    BOOL fReadOnly,
    LPWSTR pszObjPath,
    LPWSTR bstrClass )
{
    TraceFunc( "CDsPropDataObj_CreateInstance( ... )\n" );

    LPTHISCLASS lpcc = new THISCLASS( hwndParent, pido, pClassGUID, fReadOnly);
    if (!lpcc)
        RETURN(lpcc);

    HRESULT hr = THR( lpcc->Init( pszObjPath, bstrClass ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}


//
// Constructor
//
THISCLASS::THISCLASS(
    HWND hwndParent,
    IDataObject * pido, 
    GUID * pClassGUID,
    BOOL fReadOnly) :
        m_fReadOnly(fReadOnly),
        m_pwszObjName(NULL),
        m_pwszObjClass(NULL),
        m_hwnd(hwndParent),
        m_pPage(pido),
        m_ClassGUID(*pClassGUID),
        _cRef(0)
{
    TraceClsFunc( "CDsPropDataObj( )\n" );

    if (m_pPage) {
        m_pPage->AddRef();
    }

    TraceFuncExit( );
}

//
// Destructor
//
THISCLASS::~THISCLASS(void)
{
    TraceClsFunc( "~CDsPropDataObj( )\n" );
    if (m_pPage) {
        m_pPage->Release();
    }

    if (m_pwszObjName) {
        TraceFree(m_pwszObjName);
    }

    if (m_pwszObjClass) {
        TraceFree(m_pwszObjClass);
    }

    TraceFuncExit( );
}

//
// Init( )
//
HRESULT
THISCLASS::Init(
    LPWSTR pwszObjName, 
    LPWSTR pwszClass )
{
    TraceClsFunc( "Init( ... )\n" );

    HRESULT hr = S_OK;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CDsPropDataObj, IDataObject );
    QITABLE_IMP( IDataObject );
    END_QITABLE_IMP( CDsPropDataObj );
    Assert( _cRef == 0);
    AddRef( );

    if (!pwszObjName || *pwszObjName == L'\0')
    {
        HRETURN(E_INVALIDARG);
    }
    if (!pwszClass || *pwszClass == L'\0')
    {
        HRETURN(E_INVALIDARG);
    }

    m_pwszObjName = (LPWSTR) TraceStrDup( pwszObjName );
    if ( !m_pwszObjName ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

    m_pwszObjClass = (LPWSTR) TraceStrDup( pwszClass );
    if ( !m_pwszObjClass ) {
        hr = THR(E_OUTOFMEMORY);
        goto Error;
    }

Cleanup:
    HRETURN(S_OK);

Error:
    if ( m_pwszObjName ) {
        TraceFree( m_pwszObjName );
        m_pwszObjName = NULL;
    }

    if ( m_pwszObjClass ) {
        TraceFree( m_pwszObjClass );
        m_pwszObjClass = NULL;
    }

    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( m_hwnd, IDC_ERROR_CREATINGACCOUNT_TITLE, hr );
        break;
    }

    goto Cleanup;
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface( 
    REFIID riid, 
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );
    
    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IDataObject
//
// ************************************************************************

//
// GetData( )
//
STDMETHODIMP
THISCLASS::GetData(
    FORMATETC * pFormatEtc, 
    STGMEDIUM * pMedium)
{
    TraceClsFunc( "[IDataObject] GetData( ... )\n" );
    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM))) {
        HRETURN(E_INVALIDARG);
    }
    if (!(pFormatEtc->tymed & TYMED_HGLOBAL)) {
        HRETURN(DV_E_TYMED);
    }

    HRESULT hr = S_OK;

    if (pFormatEtc->cfFormat == g_cfDsObjectNames)
    {
        // return the object name and class.
        //
        INT cbPath  = sizeof(WCHAR) * (wcslen(m_pwszObjName) + 1);
        INT cbClass = sizeof(WCHAR) * (wcslen(m_pwszObjClass) + 1);
        INT cbStruct = sizeof(DSOBJECTNAMES);

        LPDSOBJECTNAMES pDSObj;

        pDSObj = (LPDSOBJECTNAMES)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                              cbStruct + cbPath + cbClass);
        if (pDSObj == NULL) {
            hr = THR(STG_E_MEDIUMFULL);
            goto Error;
        }

        pDSObj->clsidNamespace = CLSID_MicrosoftDS;
        pDSObj->cItems = 1;
        pDSObj->aObjects[0].offsetName = cbStruct;
        pDSObj->aObjects[0].offsetClass = cbStruct + cbPath;
        if (m_fReadOnly)
        {
            pDSObj->aObjects[0].dwFlags = DSOBJECT_READONLYPAGES;
        }

        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct), m_pwszObjName);
        wcscpy((PWSTR)((BYTE *)pDSObj + cbStruct + cbPath), m_pwszObjClass);

        pMedium->hGlobal = (HGLOBAL)pDSObj;
    }
    else if (pFormatEtc->cfFormat == g_cfDsPropCfg)
    {
        // return the property sheet notification info. In this case, it is
        // the invokding sheet's hwnd.
        //
        PPROPSHEETCFG pSheetCfg;

        pSheetCfg = (PPROPSHEETCFG)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                                               sizeof(PROPSHEETCFG));
        if (pSheetCfg == NULL) {
            hr = THR(STG_E_MEDIUMFULL);
            goto Error;
        }

        ZeroMemory(pSheetCfg, sizeof(PROPSHEETCFG));

        pSheetCfg->hwndParentSheet = m_hwnd;

        pMedium->hGlobal = (HGLOBAL)pSheetCfg;
    }
    else
    {
        // Pass call on to "parent" object's data obj.
        if (m_pPage ) {
            hr = m_pPage->GetData( pFormatEtc, pMedium );
#ifdef DEBUG
            if (hr != DV_E_FORMATETC )
                THR(hr);
#endif
            goto Error; // not really, but we don't want to clean up
        } else {
            hr = THR(E_FAIL);
            goto Error;
        }
    }

    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->pUnkForRelease = NULL;

Error:
    HRETURN(hr);
}

//
// GetDataHere( )
//
STDMETHODIMP
THISCLASS::GetDataHere(
    LPFORMATETC pFormatEtc, 
    LPSTGMEDIUM pMedium)
{
    TraceClsFunc( "[IDataObject] GetDataHere( ... )\n" );
    HRESULT hr;

    if (IsBadWritePtr(pMedium, sizeof(STGMEDIUM))) {
        HRETURN(E_INVALIDARG);
    }

    if (pFormatEtc->cfFormat == g_cfMMCGetNodeType)
    {   
        if (!(pFormatEtc->tymed & TYMED_HGLOBAL)) {
            hr = THR(DV_E_TYMED);
            goto Error;
        }
        LPSTREAM lpStream;
        ULONG written;

        // Create the stream on the hGlobal passed in.
        //
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &lpStream);
        if (hr)
            goto Error;

        hr = lpStream->Write(&m_ClassGUID, sizeof(m_ClassGUID), &written);

        // Because we told CreateStreamOnHGlobal with 'FALSE', only the
        // stream is released here.
        lpStream->Release();
    } else if (m_pPage ) {
        // Pass call on to "parent" object's data obj.
        hr = THR( m_pPage->GetDataHere( pFormatEtc, pMedium ) );
    } else {
        hr = THR(E_FAIL);
    }

Cleanup:
    HRETURN(hr);

Error:
    goto Cleanup;
}

//
// EnumFormatEtc( )
//
STDMETHODIMP
THISCLASS::EnumFormatEtc(
    DWORD dwDirection,
    LPENUMFORMATETC * ppEnumFormatEtc)
{
    TraceClsFunc( "[IDataObject] EnumFormatEtc( ... )\n" );
    //
    // Pass call on to "parent" object's data obj.
    //
    if (m_pPage )
    {
        HRETURN(m_pPage->EnumFormatEtc(dwDirection, ppEnumFormatEtc));
    }
    else
    {
        HRETURN(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dll.h ===
//
// Copyright 1997 - Microsoft
//

//
// DLL.H - DLL globals
//

#ifndef _DLL_H_
#define _DLL_H_

extern HINSTANCE g_hInstance;
extern DWORD     g_cObjects;
extern DWORD     g_cLock;
extern UINT      g_cfDsObjectNames;
extern UINT      g_cfDsDisplaySpecOptions;
extern UINT      g_cfDsPropetyPageInfo;
extern UINT      g_cfMMCGetNodeType;
extern TCHAR     g_szDllFilename[ MAX_PATH ];
extern WCHAR     g_cszHelpFile[];


#define DllExport   __declspec( dllimport )

//
// Thread-safe inc/decrements macros.
//
extern CRITICAL_SECTION g_InterlockCS;

#define InterlockDecrement( _var ) {\
    EnterCriticalSection( &g_InterlockCS ); \
    --_var;\
    LeaveCriticalSection( &g_InterlockCS ); \
    }
#define InterlockIncrement( _var ) {\
    EnterCriticalSection( &g_InterlockCS ); \
    ++_var;\
    LeaveCriticalSection( &g_InterlockCS ); \
    }


//
// Class Definitions
//
typedef void *(*LPCREATEINST)();

typedef struct _ClassTable {
    LPCREATEINST    pfnCreateInstance;  // creation function for class
    const CLSID *   rclsid;             // classes in this DLL
    LPCTSTR         pszName;            // Class name for debugging
} CLASSTABLE[], *LPCLASSTABLE;

//
// Class Table Macros
//
#define BEGIN_CLASSTABLE const CLASSTABLE g_DllClasses = {

#define DEFINE_CLASS( _pfn, _riid, _name ) { _pfn, &_riid, TEXT(_name) },

#define END_CLASSTABLE  { NULL, NULL, NULL } };

extern const CLASSTABLE  g_DllClasses;

#include "qi.h"
#include "debug.h"

// Macros
#define ARRAYSIZE( _x ) ((UINT) ( sizeof( _x ) / sizeof( _x[ 0 ] ) ))
#define PtrToByteOffset(base, offset)   (((LPBYTE)base)+offset)

#endif // _DLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\debug.h ===
/****************************************************************************

   Copyright (c) Microsoft Corporation 1997
   All rights reserved

  File: DEBUG.H

  Debugging utilities header
 
 ***************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_

// Trace Flags

#define TF_ALWAYS           0xFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_QUERYINTERFACE   0x00000001   // Query Interface details
#define TF_FUNC             0x00000002   // Functions entrances w/parameters
#define TF_CALLS            0x00000004   // Function calls
#define TF_MEMORYALLOCS     0x00000008   // Memory Allocations
#define TF_DLL              0x00000010   // DLL specific
#define TF_WM               0x00000020   // Window Messages
#define TF_SCP              0x00000030    // SCP objects


#ifdef DEBUG

#pragma message("BUILD: DEBUG macros being built")

// Globals
extern DWORD g_TraceMemoryIndex;
extern DWORD g_dwCounter;
extern DWORD g_dwTraceFlags;

extern const TCHAR g_szTrue[];
extern const TCHAR g_szFalse[];

extern CRITICAL_SECTION g_DebugCS;
extern BOOL  g_fDebugInitialized;


// Macros
#define DEFINE_MODULE( _module ) static const TCHAR g_szModule[] = TEXT(_module);
#define __MODULE__ g_szModule
#define DEFINE_THISCLASS( _class ) static const TCHAR g_szClass[] = TEXT(_class); 
#define __THISCLASS__ g_szClass
#define DEFINE_SUPER( _super ) static const TCHAR g_szSuper[] = TEXT(_super);
#define __SUPER__ g_szSuper

#if defined(_X86_)
#define DEBUG_BREAK        do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak( );
#endif

#define INITIALIZE_TRACE_MEMORY_PROCESS     \
    g_TraceMemoryIndex = TlsAlloc( );       \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    DebugInitializeTraceFlags( );           \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define INITIALIZE_TRACE_MEMORY_THREAD      \
    TlsSetValue( g_TraceMemoryIndex, NULL); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Thread Memory tracing initialize.\n") )

#define UNINITIALIZE_TRACE_MEMORY           \
    DebugMemoryCheck( );                    \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_DLL, TEXT("Memory tracing terminated.\n") ) 

#ifdef Assert
#undef Assert
#endif
#define Assert( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#ifdef AssertMsg
#undef AssertMsg
#endif
#define AssertMsg( _fn, _msg ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), !!(_fn) ) ) DEBUG_BREAK

#define TraceAlloc( _flags, _size ) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, _size, TEXT(#_size) )
#define TraceAllocString( _flags, _size ) (LPTSTR) DebugAlloc( TEXT(__FILE__), __LINE__, g_szModule, _flags, (_size) * sizeof(TCHAR), TEXT(#_size) )
#define TraceFree( _hmem )          DebugFree( _hmem )

//
// Tracing Macros
//
// All functions that begin with "Trace" are in both DEBUG and RETAIL, but
// in RETAIL they do not spew output.
//

// Displays file, line number, module and "_msg" only if the TF_FUNC is set
// in g_dwTraceFlags.
#define TraceFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ ") TEXT(_msg) );

// Displays file, line number, module, class name and "_msg" only if the 
// TF_FUNC is set in g_dwTraceFlags.
#define TraceClsFunc( _msg ) \
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("+ %s::%s"), g_szClass, TEXT(_msg) );

// Return macro for TraceFunc() and TraceClsFunc()
#define TraceFuncExit() { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V*\n") ); \
    InterlockDecrement(g_dwCounter); \
    return; \
}
#define RETURN( _rval ) { \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
    return _rval; \
}

// If the value is not S_OK, it will display it.
#define HRETURN( _hr ) { \
    if ( _hr ) \
        TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V hr = 0x%08x\n"), _hr ); \
    else \
        { TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_FUNC, TEXT("V\n") ); }\
    InterlockDecrement(g_dwCounter); \
    return _hr; \
}

// Displays the file, line number, module and function call and return from the
// function call (no return value displayed) for "_fn" only if the TF_CALLS is 
// set in g_dwTraceFlags. 
#define TraceDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Displays the file, line number, module and function call and return value
// which is formatted in "_msg" for "_fn" only if the TF_CALLS is set in 
// g_dwTraceFlags. 
#define TraceMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT("+ %s\n"), TEXT(#_fn) ); \
    TraceMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TF_CALLS, TEXT(_msg), TEXT(#_fn), _fn ); \
    InterlockDecrement(g_dwCounter); \
}

// This functions only asserts if the result is ZERO.
#define TraceAssertIfZero( _fn ) \
    if ( !(_fn) && AssertMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), !!(_fn) ) ) DEBUG_BREAK

#define TraceMsgGUID( _flag, _guid ) \
    TraceMsg( _flag, TEXT("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"), \
        _guid.Data1, _guid.Data2, _guid.Data3,  \
        _guid.Data4[0], _guid.Data4[1], _guid.Data4[2], _guid.Data4[3], \
        _guid.Data4[4], _guid.Data4[5], _guid.Data4[6], _guid.Data4[7] )

#define ErrorMsg( _fmt, _arg ) \
    TraceMessage( TEXT(__FILE__), __LINE__, g_szModule, TF_ALWAYS, TEXT(_fmt), _arg );

//
// Debug Macros
//
// These calls are only compiled in DEBUG. They are a NOP in RETAIL (not even
// compiled in.
//

// Same as TraceDo() but only compiled in DEBUG.
#define DebugDo( _fn ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    _fn; \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("V\n") ); \
    InterlockDecrement(g_dwCounter); \
}

// Same as TraceMsgDo() but only compiled in DEBUG.
#define DebugMsgDo( _fn, _msg ) {\
    InterlockIncrement(g_dwCounter); \
    DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("+ %s\n"), TEXT(#_fn) ); \
    DebugMessageDo( TEXT(__FILE__), __LINE__, g_szModule, TEXT(_msg), TEXT(#_fn), _fn); \
    InterlockDecrement(g_dwCounter); \
}

//
// HRESULT testing macros
//
// These functions check HRESULT return values and display UI if conditions
// warrant only in DEBUG.
//

// Warning is display if HRESULT is anything but S_OK (0).
#define THR( _fn ) \
    TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn )

// Warning is display if HRESULT is anything but S_OK (0).
#define RRETURN( _fn ) { \
    RETURN( TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_fn), _fn ) ); \
    }

// Warning is display if HRESULT is anything but S_OK (0) only if 
// TF_QUERYINTERFACE is set in g_dwTraceFlags, otherwise only a debug message
// will be printed.
#define QIRETURN( _hr, _riid ) { \
    if ( !!( TF_QUERYINTERFACE & g_dwTraceFlags ) ) { \
        RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), _hr )); \
    } else if ( _hr ) \
        DebugMessage( TEXT(__FILE__), __LINE__, g_szModule, TEXT("HRESULT: QueryInterface({%08x-%04x-%04x-%02x%02x%02x%02x%02x%02x%02x%02x}) failed(), hr = 0x%08x\n"),  _riid.Data1, _riid.Data2, _riid.Data3,  _riid.Data4[0], _riid.Data4[1], _riid.Data4[2], _riid.Data4[3], _riid.Data4[4], _riid.Data4[5], _riid.Data4[6], _riid.Data4[7], _hr ); \
    RETURN(_hr); \
    }

// Warning is display if HRESULT is not S_OK (0) or "_ok".
#define RRETURN1( _hr, _ok ) {\
    RETURN(TraceHR( TEXT(__FILE__), __LINE__, g_szModule, TEXT(#_hr), \
                    ( ( _hr == _ok ) ? S_OK : _hr ) ) ); \
    }

//
// Other
//
#define BOOLTOSTRING( _fBool ) ( !!(_fBool) ? g_szTrue : g_szFalse )

//
// Trace/Debug Functions - these do not exist in RETAIL.
//
void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCSTR pszFormat,
    ... );

void
TraceMsg( 
    DWORD   dwCheckFlags,
    LPCWSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCSTR pszFormat,
    ... );

void
DebugMsg( 
    LPCWSTR pszFormat,
    ... );

void
TraceMessage( 
    LPCTSTR pszFile, 
    const int uLine,
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... );

void
TraceMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

void 
DebugMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    ... );

void 
DebugMessageDo( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... );

BOOL
AssertMessage( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    BOOL    fTrue );

HRESULT
TraceHR( 
    LPCTSTR pszFile, 
    const int uLine, 
    LPCTSTR pszModule, 
    LPCTSTR pszfn, 
    HRESULT hr );

//
// Memory tracing functions - these are remapped to the "Global" memory 
// functions when in RETAIL.
//
HGLOBAL
DebugAlloc( 
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

HGLOBAL
DebugFree( 
    HGLOBAL hMem );

// The memory functions don't exist in RETAIL.
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment );

#define DebugMemoryAddHandle( _handle ) \
    DebugMemoryAdd( _handle, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_MOVEABLE, 0, TEXT("_handle") );

#define DebugMemoryAddAddress( _pv ) \
    DebugMemoryAdd( _pv, TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("_pv") );

#define TraceStrDup( _sz ) \
    (LPTSTR) DebugMemoryAdd( StrDup( _sz ), TEXT(__FILE__), __LINE__, __MODULE__, GMEM_FIXED, 0, TEXT("StrDup( _sz )") );

void
DebugMemoryDelete( 
    HGLOBAL hglobal );

void
DebugMemoryCheck( );

void
DebugInitializeTraceFlags( );

#ifdef __cplusplus
extern void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule );
#define new new( TEXT(__FILE__), __LINE__, __MODULE__ )

#endif

//
//
#else // it's RETAIL    ******************************************************
//
//

#pragma message("BUILD: RETAIL macros being built")

// Debugging -> NOPs
#define Assert( _fn )           
#define DebugDo( _fn )
#define DebugMsgDo( _fn, _msg )
#define DEFINE_MODULE( _module )
#define DEFINE_THISCLASS( _class )
#define DEFINE_SUPER( _super )
#define BOOLTOSTRING( _fBool )  NULL
#define AssertMsg                   1 ? (void)0 : (void) 
#define TraceMsg                    1 ? (void)0 : (void) 
#define TraceMsgGUID( _f, _g )      
#define DebugMsg                    1 ? (void)0 : (void) 
#define TraceMessage                1 ? (void)0 : (void) 
#define DebugMessage                1 ? (void)0 : (void) 
#define AssertMessage               1 ? (void)0 : (void) 
#define TraceHR                     1 ? (void)0 : (void) 
#define TraceFunc                   1 ? (void)0 : (void) 
#define TraceClsFunc                1 ? (void)0 : (void) 
#define TraceFuncExit()
#define DebugMemoryAddHandle( _handle )
#define DebugMemoryAddAddress( _pv )
#define INITIALIZE_TRACE_MEMORY_PROCESS
#define INITIALIZE_TRACE_MEMORY_THREAD
#define UNINITIALIZE_TRACE_MEMORY
#define DebugMemoryDelete( _h )

// Tracing -> just do operation
#define TraceDo( _fn )              _fn
#define TraceMsgDo( _fn, _msg )     _fn
#define TraceAssertIfZero( _fn )    _fn

// RETURN testing -> do retail
#define THR
#define RETURN( _fn )               return _fn
#define RRETURN( _fn )              return _fn
#define HRETURN( _hr )              return _hr
#define QIRETURN( _qi, _riid )      return _qi

// Memory Functions -> do retail
#define TraceAlloc( _flags, _size )     GlobalAlloc( _flags, _size )
#define TraceAllocString( _flags, _size )     (LPTSTR) GlobalAlloc( _flags, (_size) * sizeof(TCHAR))
#define TraceFree( _pv )                GlobalFree( _pv )
#define TraceStrDup( _sz )              StrDup( _sz )

#endif // DBG==1

#endif // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\debug.cpp ===
/****************************************************************************

  Copyright (c) Microsoft Corporation 1997
  All rights reserved

  File: DEBUG.CPP

  Debugging utilities

 ***************************************************************************/

#include "pch.h"
#include <shlwapi.h>

DEFINE_MODULE("IMADMUI")

#ifdef DEBUG

// Constants
#define DEBUG_OUTPUT_BUFFER_SIZE  512

// Globals
DWORD g_TraceMemoryIndex = 0;
DWORD g_dwCounter        = 0;
DWORD g_dwTraceFlags     = 0;
CRITICAL_SECTION g_DebugCS;
BOOL  g_fDebugInitialized = FALSE;

// Statics
static const TCHAR g_szNULL[]    = TEXT("");
static const TCHAR g_szTrue[]    = TEXT("True");
static const TCHAR g_szFalse[]   = TEXT("False");
static const TCHAR g_szFormat[]  = TEXT("%-50s  %-10.10s ");
static const TCHAR g_szUnknown[] = TEXT("<unknown>");

//
// DebugInitializeTraceFlags( )
//
void
DebugInitializeTraceFlags( )
{
    TCHAR szPath[ MAX_PATH ];
    LPTSTR pszExtension;

    GetModuleFileName( g_hInstance, szPath, ARRAYSIZE( szPath ) );
    pszExtension = &szPath[ lstrlen( szPath ) - 3 ];
    StrCpy( pszExtension, TEXT("ini") );
    DebugMsg( "Reading %s for debug settings...\n", szPath );

    g_dwTraceFlags = GetPrivateProfileInt( __MODULE__, TEXT("TraceFlags"), 0, szPath );
    DebugMsg( "g_dwTraceFlags = 0x%08x\n", g_dwTraceFlags );
}


//
// Debugging strrchr( )
//
LPCTSTR
dbgstrrchr( LPCTSTR lpsz, char ch )
{
    LPCTSTR psz = lpsz;

    while ( *psz )
        ++psz;

    while ( psz >= lpsz && *psz != ch )
        --psz;

    return psz;

}

//
// Adds 'g_dwCounter' spaces to debug spew
//
void
dbgspace( void )
{
    for( DWORD dw = 1; dw < g_dwCounter; dw++ )
        OutputDebugStringA( "| " );
}

//
// Makes sure multiple threads don't trample debugging output.
//
void
dbgEnterCS( void )
{
    if ( !g_fDebugInitialized )
    {
        //
        // There is NO matching DeleteCriticalSection( ) since
        // this is only used for debugging purposes.
        //
        InitializeCriticalSection( &g_DebugCS );
        g_fDebugInitialized = TRUE;
    }

    EnterCriticalSection( &g_DebugCS );
}

void
dbgExitCS( void )
{
    LeaveCriticalSection( &g_DebugCS );
}

//
// Takes the filename and line number and put them into a string buffer.
//
// NOTE: the buffer is assumed to be of size DEBUG_OUTPUT_BUFFER_SIZE.
//
LPTSTR
dbgmakefilelinestring(
    LPTSTR  pszBuf,
    LPCTSTR pszFile,
    const int uLine )
{
    LPVOID args[2];

    args[0] = (LPVOID) pszFile;
    args[1] = IntToPtr(uLine);

    FormatMessage(
        FORMAT_MESSAGE_FROM_STRING |
            FORMAT_MESSAGE_ARGUMENT_ARRAY,
        TEXT("%1(%2!u!):"),
        0,                          // error code
        0,                          // default language
        (LPTSTR) pszBuf,            // output buffer
        DEBUG_OUTPUT_BUFFER_SIZE,   // size of buffer
        (va_list*) &args );           // arguments

    return pszBuf;
}



//
// TraceMsg() - ascii
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
        TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
        mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, szFormat, valist );
        va_end( valist );
#else
        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMsg() - unicode
//
void
TraceMsg(
    DWORD dwCheckFlags,
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

        dbgEnterCS( );

        OutputDebugStringW( szBuf );

        dbgExitCS( );
    }
}

//
// TraceMessage()
//
void
TraceMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        va_start( valist, pszFormat );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );

        dbgExitCS( );
    }

}

//
// TraceMessageDo()
//
void
TraceMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    DWORD   dwCheckFlags,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;

    if (( dwCheckFlags == TF_ALWAYS
       || !!( g_dwTraceFlags & dwCheckFlags ) ))
    {
        TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPCTSTR psz = pszFunc;

        if ( !pszModule )
        {
            pszModule = g_szUnknown;
        }

        if ( !pszFile )
        {
            wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
        }
        else
        {
            TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

            dbgmakefilelinestring( szFileLine, pszFile, uLine );
            wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
        }

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgspace( );

        while ( *psz && *psz != TEXT('='))
            psz++;

        lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

        wsprintf( szBuf, TEXT("V %s= "), szVar );
        OutputDebugString( szBuf );

        va_start( valist, pszFunc );
        wvsprintf( szBuf, pszFormat, valist );
        va_end( valist );

        OutputDebugString( szBuf );
        OutputDebugString( TEXT("\n") );

        dbgExitCS( );
    }

}

//
// DebugMessage()
//
void
DebugMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMessageDo()
//
void
DebugMessageDo(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszFormat,
    LPCTSTR pszFunc,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
    TCHAR   szVar[ DEBUG_OUTPUT_BUFFER_SIZE ];
    LPCTSTR psz = pszFunc;

    if ( !pszModule )
    {
        pszModule = g_szUnknown;
    }

    if ( !pszFile )
    {
        wsprintf( szBuf, g_szFormat, g_szNULL, pszModule );
    }
    else
    {
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        dbgmakefilelinestring( szFileLine, pszFile, uLine );
        wsprintf( szBuf, g_szFormat, szFileLine, pszModule );
    }

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgspace( );

    while ( *psz && *psz != TEXT('='))
        psz++;

    lstrcpyn( szVar, pszFunc, (size_t)(1 + psz - pszFunc) );

    wsprintf( szBuf, TEXT("V %s= "), szVar );
    OutputDebugString( szBuf );

    va_start( valist, pszFunc );
    wvsprintf( szBuf, pszFormat, valist );
    va_end( valist );

    OutputDebugString( szBuf );
    OutputDebugString( TEXT("\n") );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifdef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    mbstowcs( szFormat, pszFormat, lstrlenA( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE

    dbgEnterCS( );

    OutputDebugString( szBuf );

    dbgExitCS( );
}

//
// DebugMsg()
//
void
DebugMsg(
    LPCWSTR pszFormat,
    ... )
{
    va_list valist;
    TCHAR   szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];

#ifndef UNICODE
    TCHAR  szFormat[ DEBUG_OUTPUT_BUFFER_SIZE ];
    wcstombs( szFormat, pszFormat, lstrlenW( pszFormat ) + 1 );

    va_start( valist, pszFormat );
    wvsprintf( szBuf, szFormat, valist);
    va_end( valist );
#else
    va_start( valist, pszFormat );
    wvsprintf( szBuf, pszFormat, valist);
    va_end( valist );
#endif // UNICODE


    dbgEnterCS( );

    OutputDebugStringW( szBuf );

    dbgExitCS( );
}


//
// Displays a dialog box with the failed assertion. User has the option of
// breaking.
//
BOOL
AssertMessage(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    BOOL    fTrue )
{
    if ( !fTrue )
    {
        TCHAR szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszFile == NULL )
        {
            pszFile = g_szNULL;
        }

        if ( pszModule == NULL )
        {
            pszModule = g_szNULL;
        }

        if ( pszfn == NULL )
        {
            pszfn = g_szNULL;
        }

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s ASSERT: %s\n"),
            szFileLine, pszModule, pszfn );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nAssertion:\t%s\t\n\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn );

        if ( IDNO == MessageBox( NULL, szBuf, TEXT("Assertion Failed!"),
                MB_YESNO|MB_ICONWARNING ) )
            fTrue = !FALSE;   // don't break

    }

    return !fTrue;

}

//
// Traces HRESULT errors. A dialog will appear is there is an error
// in the hr.
//
HRESULT
TraceHR(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    LPCTSTR pszfn,
    HRESULT hr )
{
    if ( hr )
    {
        TCHAR  szBuf[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];
        LPTSTR pszMsgBuf;
        BOOLEAN bDelete=TRUE;

        switch ( hr )
        {
        case S_FALSE:
            pszMsgBuf = TEXT("S_FALSE\n");
            break;

        default:
            FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER
                | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                (LPTSTR)&pszMsgBuf,
                0,
                NULL
            );
        }

        // Make sure everything is cool before we blow up somewhere else.
        if ( pszMsgBuf == NULL )
        {
            pszMsgBuf = TEXT("<unknown error code returned>\n");
            bDelete = FALSE;
        }
        Assert( pszFile != NULL );
        Assert( pszModule != NULL );
        Assert( pszfn != NULL );

        dbgmakefilelinestring( szFileLine, pszFile, uLine );

        wsprintf( szBuf, TEXT("%-50s  %-10s HRESULT: hr = 0x%08x - %s"),
            szFileLine, pszModule, hr, pszMsgBuf );

        dbgEnterCS( );

        OutputDebugString( szBuf );

        dbgExitCS( );

        wsprintf( szBuf, TEXT("Module:\t%s\t\nLine:\t%u\t\nFile:\t%s\t\n\nFunction:\t%s\t\nhr =\t0x%08x - %s\t\nDo you want to break here?"),
            pszModule, uLine, pszFile, pszfn, hr, pszMsgBuf );

        if ( IDYES == MessageBox( NULL, szBuf, TEXT("Trace HRESULT"),
                MB_YESNO|MB_ICONWARNING ) )
            DEBUG_BREAK;

        if ( hr != S_OK && hr != S_FALSE  && bDelete)
        {
            LocalFree( pszMsgBuf );
        }
    }

    return hr;

}


//
// Memory allocation and tracking
//

typedef struct _MEMORYBLOCK {
    HGLOBAL hglobal;
    DWORD   dwBytes;
    UINT    uFlags;
    LPCTSTR pszFile;
    int     uLine;
    LPCTSTR pszModule;
    LPCTSTR pszComment;
    _MEMORYBLOCK *pNext;
} MEMORYBLOCK, *LPMEMORYBLOCK;

//
// Adds a MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugMemoryAdd(
    HGLOBAL hglobal,
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmb     = (LPMEMORYBLOCK) GlobalAlloc(
                                                    GMEM_FIXED,
                                                    sizeof(MEMORYBLOCK) );

        if ( !pmb )
        {
            GlobalFree( hglobal );
            return NULL;
        }

        pmb->hglobal    = hglobal;
        pmb->dwBytes    = dwBytes;
        pmb->uFlags     = uFlags;
        pmb->pszFile    = pszFile;
        pmb->uLine      = uLine;
        pmb->pszModule  = pszModule;
        pmb->pszComment = pszComment;
        pmb->pNext      = pmbHead;

        TlsSetValue( g_TraceMemoryIndex, pmb );
        TraceMessage( pmb->pszFile,
                      pmb->uLine,
                      pmb->pszModule,
                      TF_MEMORYALLOCS,
                      L"Alloced %s - %u bytes at 0x%08x (pmb=0x%08x)\n",
                      pszComment,
                      dwBytes,
                      pmb->hglobal,
                      pmb );
    }

    return hglobal;
}

//
// Removes a MEMORYBLOCK to the memory tracking list.
//
void
DebugMemoryDelete(
    HGLOBAL hglobal )
{
    if ( hglobal )
    {
        LPMEMORYBLOCK pmbHead = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );
        LPMEMORYBLOCK pmbLast = NULL;

        while ( pmbHead && pmbHead->hglobal != hglobal )
        {
            pmbLast = pmbHead;
            pmbHead = pmbLast->pNext;
        }

        if ( pmbHead )
        {
            if ( pmbLast )
            {
                pmbLast->pNext = pmbHead->pNext;
            }
            else
            {
                TlsSetValue( g_TraceMemoryIndex, pmbHead->pNext );
            }

            TraceMessage( pmbHead->pszFile,
                          pmbHead->uLine,
                          pmbHead->pszModule,
                          TF_MEMORYALLOCS,
                          L"Freeing %s - %u bytes from 0x%08x (pmb=0x%08x)\n",
                          pmbHead->pszComment,
                          pmbHead->dwBytes,
                          pmbHead->hglobal,
                          pmbHead );
            memset( pmbHead->hglobal, 0xFA, pmbHead->dwBytes );
            GlobalFree( pmbHead );
        }
        else
        {
            DebugMsg( "\n**** Attempted to free memory at 0x%08x (ThreadID = 0x%08x) ****\n\n",
                hglobal, GetCurrentThreadId( ) );
        }
    }
}

//
// Allocates memory and adds the MEMORYBLOCK to the memory tracking list.
//
HGLOBAL
DebugAlloc(
    LPCTSTR pszFile,
    const int uLine,
    LPCTSTR pszModule,
    UINT    uFlags,
    DWORD   dwBytes,
    LPCTSTR pszComment )
{
    HGLOBAL       hglobal = GlobalAlloc( uFlags, dwBytes );

    return DebugMemoryAdd( hglobal, pszFile, uLine, pszModule, uFlags, dwBytes, pszComment );
}

//
// Remove the MEMORYBLOCK to the memory tracking list, memsets the
// memory to 0xFE and then frees the memory.
//
HGLOBAL
DebugFree(
    HGLOBAL hglobal )
{
    DebugMemoryDelete( hglobal );

    return GlobalFree( hglobal );
}

//
// Checks the memory tracking list. If it is not empty, it will dump the
// list and break.
//
void
DebugMemoryCheck( )
{
    BOOL          fFoundLeak = FALSE;
    LPMEMORYBLOCK pmb = (LPMEMORYBLOCK) TlsGetValue( g_TraceMemoryIndex );

    dbgEnterCS( );

    while ( pmb )
    {
        LPVOID args[ 5 ];
        TCHAR  szOutput[ DEBUG_OUTPUT_BUFFER_SIZE ];
        TCHAR  szFileLine[ DEBUG_OUTPUT_BUFFER_SIZE ];

        if ( fFoundLeak == FALSE )
        {
            DebugMsg("\n******** Memory leak detected ******** ThreadID = 0x%08x ******** \n\n", GetCurrentThreadId( ) );
               //OutputDebugString("12345678901234567890123456789012345678901234567890  1234567890 X 0x12345678  12345  1...");
            OutputDebugString(TEXT("Filename(Line Number):                              Module     Addr/HGLOBAL  Size   String\n"));
            fFoundLeak = TRUE;
        }

        dbgmakefilelinestring( szFileLine, pmb->pszFile, pmb->uLine );

        args[0] = (LPVOID) pmb->hglobal;
        args[1] = (LPVOID) &szFileLine;
        args[2] = (LPVOID) pmb->pszComment;
        args[3] = UlongToPtr(pmb->dwBytes);
        args[4] = (LPVOID) pmb->pszModule;

        if ( !!(pmb->uFlags & GMEM_MOVEABLE) )
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! H 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }
        else
        {
            FormatMessage(
                FORMAT_MESSAGE_FROM_STRING |
                    FORMAT_MESSAGE_ARGUMENT_ARRAY,
                TEXT("%2!-50s!  %5!-10s! A 0x%1!08x!  %4!-5u!  \"%3\"\n"),
                0,                          // error code
                0,                          // default language
                (LPTSTR) &szOutput,         // output buffer
                ARRAYSIZE( szOutput ),   // size of buffer
                (va_list*) &args );           // arguments
        }

        OutputDebugString( szOutput );

        pmb = pmb->pNext;
    }

    if ( fFoundLeak == TRUE )
    {
        OutputDebugString(TEXT("\n***************************** Memory leak detected *****************************\n\n"));
    }

    dbgExitCS( );

    if (g_dwTraceFlags & TF_MEMORYALLOCS) {
        Assert( !fFoundLeak );
    }

}

//
// Global Management Functions -
//
// These are in debug and retail but internally they change
// depending on the build.
//

#undef new
void* __cdecl operator new( size_t nSize, LPCTSTR pszFile, const int iLine, LPCTSTR pszModule )
{
    return DebugAlloc( pszFile, iLine, pszModule, GPTR, nSize, TEXT("new()") );
}

void * __cdecl operator new(size_t t_size )
{
    AssertMsg( 0, "Macro failure" );
    return NULL;
}

void __cdecl operator delete(void *pv)
{
    TraceFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#else // ! DEBUG -- It's retail

//
// Global Management Functions -
//
// These are in debug and retail but are internally they change
// depending on the build.
//

void * __cdecl operator new(size_t t_size )
{
    return LocalAlloc( GPTR, t_size );
}

void __cdecl operator delete(void *pv)
{
    LocalFree( pv );
}

int __cdecl _purecall(void)
{
    return 0;
}

#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dll.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DLL.CPP - DLL entry points
//

#include "pch.h"
#include "register.h"
#include "ccomputr.h"
#include "cservice.h"
#include "cgroup.h"

DEFINE_MODULE("IMADMUI")

// DLL Globals
HINSTANCE g_hInstance = NULL;
DWORD     g_cObjects  = 0;
DWORD     g_cLock     = 0;
TCHAR     g_szDllFilename[ MAX_PATH ] = { 0 };
UINT      g_cfDsObjectNames;
UINT      g_cfDsDisplaySpecOptions;
UINT      g_cfDsPropetyPageInfo;
UINT      g_cfMMCGetNodeType;
WCHAR     g_cszHelpFile[] = L"rbadmin.hlp";

CRITICAL_SECTION g_InterlockCS;

//
// DLLMain()
//
BOOL WINAPI
DllMain(
    HANDLE hInst, 
    ULONG uReason, 
    LPVOID lpReserved)
{
    if ( uReason == DLL_PROCESS_ATTACH )
    {
        InitializeCriticalSection( &g_InterlockCS );
    }

    // keep down the noise
#ifdef DEBUG
    if ( g_dwTraceFlags & TF_DLL )
    {
        TraceFunc( "DllMain() - " );
    }
#endif // DEBUG
   
    switch( uReason )
    {
    case DLL_PROCESS_ATTACH:
        TraceMsg( TF_DLL, "DLL_PROCESS_ATTACH - ThreadID = 0x%08x\n", GetCurrentThreadId( ) );

        INITIALIZE_TRACE_MEMORY_PROCESS;

        g_hInstance = (HINSTANCE) hInst;

        TraceAssertIfZero( GetModuleFileName( g_hInstance, g_szDllFilename, ARRAYSIZE( g_szDllFilename ) ) ); 
        break;

    case DLL_PROCESS_DETACH:
        TraceMsg( TF_DLL, "DLL_PROCESS_DETACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        UNINITIALIZE_TRACE_MEMORY;
#ifdef DEBUG
        if (g_fDebugInitialized) {
            DeleteCriticalSection(&g_DebugCS);
            g_fDebugInitialized = FALSE;
        }
#endif

        DeleteCriticalSection( &g_InterlockCS );
        break;

    case DLL_THREAD_ATTACH:
        TraceMsg( TF_DLL, "DLL_THREAD_ATTACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        INITIALIZE_TRACE_MEMORY_THREAD;
        break;

    case DLL_THREAD_DETACH:
        TraceMsg( TF_DLL, "DLL_THREAD_DETACH - ThreadID = 0x%08x ", GetCurrentThreadId( ) );

        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        UNINITIALIZE_TRACE_MEMORY;
        break;
    }

#ifdef DEBUG
    if ( g_dwTraceFlags & TF_DLL )
    {
        RETURN(TRUE);
    }
#endif // DEBUG

    return TRUE;
} // DLLMain()

//
// DllGetClassObject()
//
STDAPI 
DllGetClassObject(
    REFCLSID rclsid, 
    REFIID riid, 
    void** ppv )
{
    TraceFunc( "DllGetClassObject( ");

    if ( !ppv )
    {
        TraceMsg( TF_FUNC, "ppv == NULL! )\n" );
        RRETURN(E_POINTER);
    }

    LPCFACTORY  lpClassFactory;
    HRESULT     hr = CLASS_E_CLASSNOTAVAILABLE;

    int i = 0; 
    while( g_DllClasses[ i ].rclsid )
    {
        if ( *g_DllClasses[ i ].rclsid == rclsid )
        {
            TraceMsg( TF_FUNC, TEXT("rclsid= %s, riid, ppv )\n"), g_DllClasses[ i ].pszName );
            hr = S_OK;
            break;
        }

        i++;
    }

    if ( hr == CLASS_E_CLASSNOTAVAILABLE )
    {
        TraceMsg( TF_FUNC, "rclsid= " );
        TraceMsgGUID( TF_FUNC, rclsid );
        TraceMsg( TF_FUNC, ", riid, ppv )\n" );
        goto Cleanup;
    }

	Assert( g_DllClasses[ i ].pfnCreateInstance != NULL );
    lpClassFactory = 
        new CFactory( g_DllClasses[ i ].pfnCreateInstance );

    if ( !lpClassFactory )
    {
        hr = THR(E_OUTOFMEMORY);
        goto Cleanup;
    }

    hr = THR( lpClassFactory->Init( ) );
    if ( hr )
    {
        TraceDo( delete lpClassFactory );
        goto Cleanup;
    }

    hr = lpClassFactory->QueryInterface( riid, ppv );
    ((IUnknown *) lpClassFactory )->Release( );

Cleanup:
    HRETURN(hr);
}


//
// DllRegisterServer()
//
STDAPI 
DllRegisterServer(void)
{
    HRESULT hr;

    TraceFunc( "DllRegisterServer()\n" );

    hr = RegisterDll( TRUE );

    HRETURN(hr);
}

//
// DllUnregisterServer()
//
STDAPI 
DllUnregisterServer(void)
{
    TraceFunc( "DllUnregisterServer()\n" );

    HRETURN( RegisterDll( FALSE ) );
}

//
// DllCanUnloadNow()
//
STDAPI 
DllCanUnloadNow(void)
{
    TraceFunc( "DllCanUnloadNow()\n" );

    HRESULT hr = S_OK;

    if ( g_cLock || g_cObjects )
    {
        TraceMsg( TF_DLL, "[ g_cLock=%u, g_cObjects=%u ]\n", g_cLock, g_cObjects );
        hr = S_FALSE;
    }

    HRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dpguidqy.h ===
//
// Copyright 1997 - Microsoft

//
// DPGUIDQY.H - The duplicate GUID query form
//


#ifndef _DPGUIDQY_H_
#define _DPGUIDQY_H_

// QITable
BEGIN_QITABLE( CRIQueryForm )
DEFINE_QI( IID_IQueryForm, IQueryForm, 3 )
END_QITABLE

// Definitions
LPVOID
CRIQueryForm_CreateInstance( void );

// CRIQueryForm
class CRIQueryForm
    : public IQueryForm
{
private:
    // IUnknown
    ULONG       _cRef;
    DECLARE_QITABLE( CRIQueryForm );

    HWND        _hDlg;

private: // methods
    CRIQueryForm( );
    ~CRIQueryForm( );
    HRESULT
        Init( void );

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static HRESULT CALLBACK
        PropSheetPageProc( LPCQPAGE pQueryPage, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT     _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( );
    HRESULT _GetQueryParams( HWND hwnd, LPDSQUERYPARAMS* ppdsqp );

public: // methods
    friend LPVOID CRIQueryForm_CreateInstance( void );

    // IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef)();
    STDMETHOD_(ULONG,Release)();

    // IQueryForm methods
    STDMETHOD(Initialize)(HKEY hkForm);
    STDMETHOD(AddForms)(LPCQADDFORMSPROC pAddFormsProc, LPARAM lParam);
    STDMETHOD(AddPages)(LPCQADDPAGESPROC pAddPagesProc, LPARAM lParam);
};

typedef CRIQueryForm * LPCRIQueryForm;


#endif // _DPGUIDQY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\groups.cpp ===
/************************************************************************

   Copyright (c) Microsoft Corporation 1997-1999
   All rights reserved

 ***************************************************************************/

//
// GROUPS.CPP - Handles the "IntelliMirror Group" IDD_PROP_GROUPS tab
//


#include "pch.h"

#ifdef INTELLIMIRROR_GROUPS

#include "cservice.h"
#include "cgroup.h"
#include "groups.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CGroupsTab")
#define THISCLASS CGroupsTab
#define LPTHISCLASS LPCGroupsTab

#define NUM_COLUMNS         4
#define MAX_ITEMLEN         20
#define BITMAP_WIDTH        16
#define BITMAP_HEIGHT       16
#define LG_BITMAP_WIDTH     32
#define LG_BITMAP_HEIGHT    32

DWORD aGroupHelpMap[] = { NULL, NULL };

//
// CreateInstance()
//
LPVOID
CGroupsTab_CreateInstance( void )
{
	TraceFunc( "CGroupsTab_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CGroupsTab()\n" );

	InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CGroupsTab()\n" );

    if ( _punk )
        _punk->Release( );

	InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_USEREFPARENT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROP_GROUPS);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = E_FAIL;
            goto Error;
        }
    }

    punk->AddRef( );   // matching Release in the destructor
    _punk = punk;

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    HRETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    HRETURN(E_NOTIMPL);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    HRETURN(E_NOTIMPL);
}


// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************


//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    HRESULT hr = S_OK;
    LPSERVICE ps = NULL;
    ULONG   cFetched;
    HWND    hwnd = GetDlgItem( _hDlg, IDC_L_GROUPS );
    HICON   hIcon;      // handle to an icon
    int     index;      // index used in for loops
    int     iSubItem;   // index into column header string table
    LV_COLUMN  lvC;     // list view column structure
    LV_ITEM    lvI;     // list view item structure
    WCHAR   szText [MAX_PATH]; // place to store some text
    IEnumSAPs * penum = NULL;
    HIMAGELIST hSmall, hLarge; // handles to image lists for small and large icons

    _hDlg = hDlg;
    SetWindowLong( _hDlg, GWL_USERDATA, (LPARAM) this );
    _fChanged = TRUE;   // prevent Apply button from coming on

    // Initialize the list view icons
    hSmall = ImageList_Create ( BITMAP_WIDTH, BITMAP_HEIGHT, FALSE, 3, 0 );
    hLarge = ImageList_Create ( LG_BITMAP_WIDTH, LG_BITMAP_HEIGHT, FALSE, 3, 0 );
    hIcon  = LoadIcon ( g_hInstance, MAKEINTRESOURCE( IDI_COMPUTER ) );
    if (( ImageList_AddIcon( hSmall, hIcon ) == -1) ||
        ( ImageList_AddIcon( hLarge, hIcon ) == -1))
    {
        hr = THR( E_FAIL );
        goto Error;
    }

    // Associate the image lists with the list view control.
    ListView_SetImageList( hwnd, hSmall, LVSIL_SMALL );
    ListView_SetImageList( hwnd, hLarge, LVSIL_NORMAL );

    // Initialize the columns
    lvC.mask    = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvC.fmt     = LVCFMT_LEFT;      // left-align column
    lvC.cx      = 75;               // width of column in pixels
    lvC.pszText = szText;

    // Add the columns.
    for ( index = 0; index < NUM_COLUMNS; index++ )
    {
        DWORD dw;
        dw = LoadString( g_hInstance, IDS_COLUMN1 + index, szText, ARRAYSIZE ( szText ) );
        Assert(dw);

        lvC.iSubItem = index;

        if ( ListView_InsertColumn( hwnd, index, &lvC ) == -1 )
        {
            hr = THR( E_FAIL );
            goto Error;
        }
    }

    // Finally, add the actual items to the control.
    lvI.mask      = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvI.state     = 0;
    lvI.stateMask = 0;

    hr = THR( _punk->QueryInterface( IID_IEnumSAPs, (void**) &penum ) );
    if (hr)
        goto Error;

    index = 0;
    while( ( hr = penum->Next( 1, &ps, &cFetched ) ) == S_OK )
    {
        LPWSTR pszServerName;

        hr = THR( ps->GetServerDN( &pszServerName ) );
        if (hr)
            goto Error;

        ps->Release( );
        ps = NULL;

        // The parent window is responsible for storing the text.
        // The list view control will send an LVN_GETDISPINFO
        // when it needs the text to display.
        lvI.pszText    = pszServerName;
        lvI.iItem      = index;
        lvI.iSubItem   = 0;
        lvI.cchTextMax = MAX_ITEMLEN;
        lvI.iImage     = 0;
        lvI.lParam     = NULL;  // DEADISSUE: Ifdef'd out. BUGBUG: should point to a SAPNODE, 

        if ( ListView_InsertItem( hwnd, &lvI) == -1 )
        {
            hr = THR( E_FAIL );
            goto Error;
        }

        for ( iSubItem = 1; iSubItem < NUM_COLUMNS; iSubItem++ )
        {
            ListView_SetItemText( hwnd, index, iSubItem, pszServerName );
        }
    }

    // hr should equal S_FALSE
    if ( hr != S_FALSE )
    {
        THR(hr);
        goto Error;
    }

    hr = S_OK;

Cleanup:
    if ( ps )
        ps->Release( );
    if ( penum )
        penum->Release( );

    _fChanged = FALSE;

    HRETURN(hr);

Error:
    switch (hr) {
    case S_OK:
        break;
    default:
        MessageBoxFromHResult( NULL, IDS_ERROR_OPENNINGGROUPOBJECT, hr );
        break;
    }
    goto Cleanup;
}





//
// _OnCommand( )
//
BOOL
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    HRESULT hr;
    BOOL    fChanged = FALSE;
    BOOL    fResult  = FALSE;
    HWND    hwndCtl  = (HWND) lParam;

    switch( LOWORD(wParam) )
    {
    case 0:
        //dummy;
    default:
        hr = S_FALSE;
        break;
    }

    if ( fChanged )
    {
        if ( !_fChanged )
        {
            _fChanged = TRUE;
            SendMessage( GetParent( _hDlg ), PSM_CHANGED, 0, 0 );
        }
    }

    RETURN(fResult);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;

    switch( lpnmhdr->code )
    {
    case PSN_APPLY:
        TraceMsg( TF_WM, TEXT("WM_NOTIFY: PSN_APPLY\n"));
        AssertMsg( 0, "Need to implement this." );
        SetWindowLong( _hDlg, DWL_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE );
        _fChanged = FALSE;
        RETURN(TRUE);

    case LVN_GETDISPINFO:
        break;

    default:
        break;
    }

    RETURN(FALSE);
}

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLong( hDlg, GWL_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aGroupHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aGroupHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        RETURN(TRUE);   // create it
        break;

    case PSPCB_RELEASE:
        LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\dpguidqy.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// DPGUIDQY.CPP - The duplicate GUID query form
//

#include "pch.h"

#include "dpguidqy.h"
#include "mangdlg.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CRIQueryForm")
#define THISCLASS CRIQueryForm
#define LPTHISCLASS LPCRIQueryForm

#define FILTER_QUERY_BOTH           L"(&(objectClass=computer)(netbootGUID=%ws*)(netbootMachineFilePath=%s))"
#define FILTER_QUERY_GUID_ONLY      L"(&(objectClass=computer)(netbootGUID=%ws*))"
#define FILTER_QUERY_SERVER_ONLY    L"(&(objectClass=computer)(netbootMachineFilePath=%s))"

#define StringByteCopy(pDest, iOffset, sz)          \
        { memcpy(&(((LPBYTE)pDest)[iOffset]), sz, StringByteSize(sz)); }

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))


DWORD aQueryHelpMap[] = {
    IDC_E_SERVER, HIDC_E_SERVER,
    IDC_E_GUID, HIDC_E_GUID,
    NULL, NULL
};

//
// CRIQueryForm_CreateInstance( )
//
LPVOID
CRIQueryForm_CreateInstance( void )
{
    TraceFunc( "CRIQueryForm_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    if ( !lpcc ) {
        RETURN(lpcc);
    }

    HRESULT hr = THR( lpcc->Init( ) );
    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN(lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CRIQueryForm( )\n" );

    InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init( )
//
HRESULT
THISCLASS::Init( )
{
    TraceClsFunc( "Init( )\n" );

    HRESULT hr;

    // IUnknown stuff
    BEGIN_QITABLE_IMP( CRIQueryForm, IQueryForm );
    QITABLE_IMP( IQueryForm );
    END_QITABLE_IMP( CRIQueryForm );
    Assert( _cRef == 0);
    AddRef( );

    hr = CheckClipboardFormats( );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CRIQueryForm( )\n" );

    InterlockDecrement( g_cObjects );

    TraceFuncExit();
}

// ************************************************************************
//
// IUnknown
//
// ************************************************************************

//
// QueryInterface()
//
STDMETHODIMP
THISCLASS::QueryInterface(
    REFIID riid,
    LPVOID *ppv )
{
    TraceClsFunc( "" );

    HRESULT hr = ::QueryInterface( this, _QITable, riid, ppv );

    QIRETURN( hr, riid );
}

//
// AddRef()
//
STDMETHODIMP_(ULONG)
THISCLASS::AddRef( void )
{
    TraceClsFunc( "[IUnknown] AddRef( )\n" );

    InterlockIncrement( _cRef );

    RETURN(_cRef);
}

//
// Release()
//
STDMETHODIMP_(ULONG)
THISCLASS::Release( void )
{
    TraceClsFunc( "[IUnknown] Release( )\n" );

    InterlockDecrement( _cRef );

    if ( _cRef )
        RETURN(_cRef);

    TraceDo( delete this );

    RETURN(0);
}

// ************************************************************************
//
// IQueryForm
//
// ************************************************************************

//
// Initialize( )
//
STDMETHODIMP
THISCLASS::Initialize(
    HKEY hkForm)
{
    TraceClsFunc( "[IQueryForm] Initialize( )\n" );

    HRETURN(S_OK);
}

//
// SetObject( )
//
STDMETHODIMP
THISCLASS::AddForms(
    LPCQADDFORMSPROC pAddFormsProc,
    LPARAM lParam )
{
    TraceClsFunc( "[IQueryForm] AddForms(" );
    TraceMsg( TF_FUNC, " pAddFormsProc = 0x%p, lParam = 0x%p )\n", pAddFormsProc, lParam );

    if ( !pAddFormsProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQFORM cqf;
    WCHAR szTitle[ 255 ];
    DWORD dw;

    dw = LoadString( g_hInstance, IDS_REMOTE_INSTALL_CLIENTS, szTitle, ARRAYSIZE(szTitle) );
    Assert(dw);

    ZeroMemory( &cqf, sizeof(cqf) );
    cqf.cbStruct = sizeof(cqf);
    cqf.dwFlags = CQFF_ISOPTIONAL;
    cqf.clsid = CLSID_RIQueryForm;
    cqf.pszTitle = szTitle;

    hr = THR( pAddFormsProc(lParam, &cqf) );

    HRETURN(hr);
}


//
// AddPages( )
//
STDMETHODIMP
THISCLASS::AddPages(
    LPCQADDPAGESPROC pAddPagesProc,
    LPARAM lParam)
{
    TraceClsFunc( "[IQueryForm] AddPages(" );
    TraceMsg( TF_FUNC, " pAddPagesProc = 0x%p, lParam = 0x%p )\n", pAddPagesProc, lParam );

    if ( !pAddPagesProc )
        HRETURN(E_INVALIDARG);

    HRESULT hr = S_OK;
    CQPAGE cqp;

    cqp.cbStruct = sizeof(cqp);
    cqp.dwFlags = 0x0;
    cqp.pPageProc = (LPCQPAGEPROC) PropSheetPageProc;
    cqp.hInstance = g_hInstance;
    cqp.idPageName = IDS_REMOTE_INSTALL_CLIENTS;
    cqp.idPageTemplate = IDD_GUID_QUERY_FORM;
    cqp.pDlgProc = PropSheetDlgProc;
    cqp.lParam = (LPARAM)this;

    hr = THR( pAddPagesProc(lParam, CLSID_RIQueryForm, &cqp) );

    HRETURN(hr);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%p, uMsg = 0x%p, wParam = 0x%p, lParam = 0x%p )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        CQPAGE * pcqp = (CQPAGE *) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, pcqp->lParam );
        pcc = (LPTHISCLASS) pcqp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aQueryHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aQueryHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
HRESULT CALLBACK
THISCLASS::PropSheetPageProc(
    LPCQPAGE pQueryPage,
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("pQueryPage = 0x%p, hwnd = 0x%p, uMsg = 0x%p, wParam= 0x%p, lParam = 0x%p )\n"),
        pQueryPage, hwnd, uMsg, wParam, lParam );

    HRESULT hr = E_NOTIMPL;
    Assert( pQueryPage );
    LPTHISCLASS pQueryForm = (LPTHISCLASS )pQueryPage->lParam;
    Assert( pQueryForm );

    switch ( uMsg )
    {
    // Initialize so AddRef the object we are associated with so that
    // we don't get unloaded.

    case CQPM_INITIALIZE:
        TraceMsg( TF_WM, "CQPM_INITIALIZE\n" );
        pQueryForm->AddRef();
        hr = S_OK;
        break;

    // Release, therefore Release the object we are associated with to
    // ensure correct destruction etc.

    case CQPM_RELEASE:
        TraceMsg( TF_WM, "CQPM_RELEASE\n" );
        SetWindowLongPtr( pQueryForm->_hDlg, GWLP_USERDATA, NULL );
        pQueryForm->Release();
        hr = S_OK;
        break;

    // Enable so fix the state of our two controls within the window.

    case CQPM_ENABLE:
        TraceMsg( TF_WM, "CQPM_ENABLE\n" );
        EnableWindow( GetDlgItem( hwnd, IDC_E_GUID ), (BOOL)wParam );
        EnableWindow( GetDlgItem( hwnd, IDC_E_SERVER ), (BOOL)wParam );
        hr = S_OK;
        break;

    // Fill out the parameter structure to return to the caller, this is
    // handler specific.  In our case we constructure a query of the CN
    // and objectClass properties, and we show a columns displaying both
    // of these.  For further information about the DSQUERYPARAMs structure
    // see dsquery.h

    case CQPM_GETPARAMETERS:
        TraceMsg( TF_WM, "CQPM_GETPARAMETERS\n" );
        hr = pQueryForm->_GetQueryParams( hwnd, (LPDSQUERYPARAMS*)lParam );
        break;

    // Clear form, therefore set the window text for these two controls
    // to zero.

    case CQPM_CLEARFORM:
        TraceMsg( TF_WM, "CQPM_CLEARFORM\n" );
        SetDlgItemText( hwnd, IDC_E_GUID, L"" );
        SetDlgItemText( hwnd, IDC_E_SERVER, L"" );
        hr = S_OK;
        break;

    case CQPM_SETDEFAULTPARAMETERS:
        TraceMsg( TF_WM, "CQPM_SETDEFAULTPARAMETERS: wParam = %s  lParam = 0x%p\n", BOOLTOSTRING(wParam), lParam );
        if ( wParam && lParam )
        {
            VARIANT var;
            LPOPENQUERYWINDOW poqwi = (LPOPENQUERYWINDOW) lParam;
            IPropertyBag * ppb = poqwi->ppbFormParameters;
            Assert( ppb );
            VariantInit( &var );

            hr = ppb->Read( L"ServerName", &var, NULL );
            if (SUCCEEDED( hr ))
            {
                SetDlgItemText( hwnd, IDC_E_SERVER, V_BSTR( &var ) );
                VariantClear( &var );
            }          

            hr = ppb->Read( L"ClientGuid", &var, NULL );
            if (SUCCEEDED( hr ))
            {
                SetDlgItemText( hwnd, IDC_E_GUID, V_BSTR( &var ) );
                VariantClear( &var );
            }
        }
        else
        {
            DebugMsg( "No default parameters given.\n" );
            hr = S_OK;
        }
        break;

    default:
        TraceMsg( TF_WM, "CQPM_message 0x%08x *** NOT IMPL ***\n", uMsg );
        hr = E_NOTIMPL;
        break;
    }

    RETURN(hr);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    HRETURN(S_OK);
}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_GUID ), MAX_INPUT_GUID_STRING - 1 );
    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%p, lParam = 0x%p )\n", wParam, lParam );

#if 0
    switch ( LOWORD(wParam) )
    {
    }
#endif

    RETURN(FALSE);
}

//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%p, lParam = 0x%p )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%p, idFrom = 0x%08x, code = 0x%08x\n",
        lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );

#if 0
    switch( lpnmhdr->code )
    {
    }
#endif

    RETURN(FALSE);
}

struct
{
    INT fmt;
    INT cx;
    INT uID;
    LPCTSTR pDisplayProperty;
}
columns[] =
{
    0, 20, IDS_NAME, TEXT("cn"),
    0, 50, IDS_GUID, TEXT("netbootGuid"),
};

//
// _GetQueryParams( )
//
HRESULT
THISCLASS::_GetQueryParams(
    HWND hWnd,
    LPDSQUERYPARAMS* ppdsqp )
{
    TraceClsFunc( "_GetQueryParams( )\n" );

    if ( !ppdsqp )
        HRETURN(E_POINTER);

    HRESULT hr = S_OK;
    INT     i;
    WCHAR   szServer[DNS_MAX_NAME_BUFFER_LENGTH];
    WCHAR   szGuid[MAX_INPUT_GUID_STRING * 2];   // room for escaped GUID
    WCHAR   szFilter[ARRAYSIZE(szGuid)+ARRAYSIZE(szServer)+ARRAYSIZE(FILTER_QUERY_BOTH)];
    BYTE    uGuid[ 16 ];
    DWORD   uGuidLength;
    ULONG   offset;
    BOOL    fIncludeGuid = FALSE, fIncludeServer = FALSE;

    ULONG   cbStruct = 0;
    LPDSQUERYPARAMS pDsQueryParams = NULL;

#if 0
    if ( *ppdsqp )
    {
        // This page doesn't support appending its query data to an
        // existing DSQUERYPARAMS strucuture, only creating a new block,
        // therefore bail if we see the pointer is not NULL.
        hr = THR(E_INVALIDARG);
        goto Error;
    }
#endif

    //
    // This is how searches are done:
    // - if both guid and server are left blank, search for all
    //   accounts with netbootGuid specified (all managed computers).
    // - if either or both are specified, search for all computers
    //   that match.
    // - if guid is specified as '*', treat it the same as if it had
    //   been left blank (searches for all accounts with netbootGUID).
    //
    // Note that currently any account with a server in netbootMachineFilePath
    // will also have netbootGUID specified, because prestaging a
    // remote install computer always puts netbootGUID, and that is
    // the only way that netbootMachineFilePath will be set. So if the
    // user specifies a server but no guid, we don't need to include
    // netbootGUID=* in our ldap filter.
    //

    // Compute the size of the argument block
    if ( GetDlgItemText( hWnd, IDC_E_GUID, szGuid, ARRAYSIZE(szGuid)) )
    {
        //
        // Allow only a * as the GUID, to search for all machines with
        // a GUID.
        //

        if (wcscmp(szGuid, L"*") != 0)
        {
            if ( ValidateGuid(szGuid,uGuid,&uGuidLength) == E_FAIL || !uGuidLength ) {
                MessageBoxFromStrings( hWnd,
                                       IDS_INVALID_GUID_CAPTION,
                                       IDS_INVALID_PARTIAL_GUID_TEXT,
                                       MB_OK );
                hr = E_INVALIDARG;
                goto Error;
            }
    
            ZeroMemory( szGuid, sizeof(szGuid) );
            ldap_escape_filter_element((PCHAR)uGuid, uGuidLength, szGuid, sizeof(szGuid) );
        }
        else
        {
            szGuid[0] = L'\0';  // the filter adds a *, and "**" doesn't work, so blank it here
        }

        fIncludeGuid = TRUE;

    }

    if ( GetDlgItemText( hWnd, IDC_E_SERVER, szServer, ARRAYSIZE(szServer)) )
    {
        fIncludeServer = TRUE;
    }
    else
    {
        //
        // If no server or guid was specified, search for any guid.
        //
        if (!fIncludeGuid)
        {
            szGuid[0] = L'\0';
            fIncludeGuid = TRUE;
        }
    }

    if ( fIncludeGuid && fIncludeServer )
    {
        wsprintf( szFilter, FILTER_QUERY_BOTH, szGuid, szServer );
    }
    else if ( fIncludeGuid )
    {
        wsprintf( szFilter, FILTER_QUERY_GUID_ONLY, szGuid );
    }
    else if ( fIncludeServer )
    {
        wsprintf( szFilter, FILTER_QUERY_SERVER_ONLY, szServer );
    }
#ifdef DEBUG
    else
    {
        AssertMsg( 0, "How did we get here?\n" );
        szFilter[0] = L'\0';
    }
#endif // DEBUG

    DebugMsg( "RI Filter: %s\n", szFilter );

    // compute the size of the new query block
    if ( !*ppdsqp )
    {
        offset = cbStruct = sizeof(DSQUERYPARAMS) + ((ARRAYSIZE(columns)-1)*sizeof(DSCOLUMN));
        cbStruct += StringByteSize(szFilter);
        for ( i = 0; i < ARRAYSIZE(columns); i++ )
        {
            cbStruct += StringByteSize(columns[i].pDisplayProperty);
        }
    }
    else
    {
        LPWSTR pszQuery;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        offset = (*ppdsqp)->cbStruct;
        cbStruct = (*ppdsqp)->cbStruct + StringByteSize( pszQuery ) + StringByteSize( szFilter );
    }

    // Allocate it and populate it with the data, the header is fixed
    // but the strings are referenced by offset.
    pDsQueryParams = (LPDSQUERYPARAMS)CoTaskMemAlloc(cbStruct);
    if ( !pDsQueryParams )
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }

    // Did they hand in a query that we need to modify?
    if ( !*ppdsqp)
    {   // no... create our own query
        pDsQueryParams->cbStruct = cbStruct;
        pDsQueryParams->dwFlags = 0;
        pDsQueryParams->hInstance = g_hInstance;
        pDsQueryParams->offsetQuery = offset;
        pDsQueryParams->iColumns = ARRAYSIZE(columns);

        // Copy the filter string and bump the offset
        StringByteCopy(pDsQueryParams, offset, szFilter);
        offset += StringByteSize(szFilter);

        // Fill in the array of columns to dispaly, the cx is a percentage of the
        // current view, the propertie names to display are UNICODE strings and
        // are referenced by offset, therefore we bump the offset as we copy
        // each one.

        for ( i = 0 ; i < ARRAYSIZE(columns); i++ )
        {
            pDsQueryParams->aColumns[i].fmt = columns[i].fmt;
            pDsQueryParams->aColumns[i].cx = columns[i].cx;
            pDsQueryParams->aColumns[i].idsName = columns[i].uID;
            pDsQueryParams->aColumns[i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, columns[i].pDisplayProperty);
            offset += StringByteSize(columns[i].pDisplayProperty);
        }
    }
    else
    {   // yes... add our parameters to the query
        LPWSTR pszQuery;
        LPWSTR pszNewQuery;
        INT    n;

        // duplicate the existing query
        Assert( offset == (*ppdsqp)->cbStruct );
        CopyMemory( pDsQueryParams, *ppdsqp, offset );
        pDsQueryParams->cbStruct = cbStruct;

#if 0
        // add our columns
        for ( i = 0 ; i < ARRAYSIZE(columns); i++ )
        {
            pDsQueryParams->aColumns[n+i].fmt = columns[i].fmt;
            pDsQueryParams->aColumns[n+i].cx = columns[i].cx;
            pDsQueryParams->aColumns[n+i].idsName = columns[i].uID;
            pDsQueryParams->aColumns[n+i].offsetProperty = offset;

            StringByteCopy(pDsQueryParams, offset, columns[i].pDisplayProperty);
            offset += StringByteSize(columns[i].pDisplayProperty);
        }
#endif
        // new query location
        pDsQueryParams->offsetQuery = offset;
        pszQuery = (LPWSTR) ((LPBYTE)(*ppdsqp) + (*ppdsqp)->offsetQuery);
        pszNewQuery = (LPWSTR) ((LPBYTE)pDsQueryParams + offset);
        Assert( pszQuery );

        // append to their query
        if ( StrCmpN( pszQuery, L"(&", 2 ) == 0 )
        {
            pszQuery[ wcslen( pszQuery ) - 1 ] = L'\0'; // remove ")"
        }
        else
        {
            wcscpy( pszNewQuery, L"(&" );               // add "(&" to begining of query
        }
        wcscat( pszNewQuery, pszQuery );                // add their query
        wcscat( pszNewQuery, &szFilter[2] );            // add our query starting after the "(&"
        offset += StringByteSize( pszNewQuery );        // compute new offset
        DebugMsg( "New Query String: %s\n", pszNewQuery );

        // Cleanup
        CoTaskMemFree( *ppdsqp );
    }

    // Success
    *ppdsqp = pDsQueryParams;
    Assert( hr == S_OK );

Cleanup:
    HRETURN(hr);
Error:
    if ( pDsQueryParams )
        CoTaskMemFree( pDsQueryParams );

    // If we aren't modifying the query and there wasn't
    // a query handed into us, indicate failure instead.
    if ( hr == S_FALSE && !*ppdsqp )
    {
        hr = E_FAIL;
    }
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\guids.cpp ===
//
// Copyright 1997 - Microsoft
//

//
// GUIDS.CPP - GUID definitions
//

#include "pch.h"
#include <initguid.h>

#undef _GUIDS_H_
#include "guids.h"

#include "ccomputr.h"
#include "cservice.h"
#include "cgroup.h"
#include "newcmptr.h"
#include "dpguidqy.h"
#include "serverqy.h"

//
// Classes in this Component
//
BEGIN_CLASSTABLE
DEFINE_CLASS( CComputer_CreateInstance, CLSID_Computer, "Remote Install Computer Property Pages")
DEFINE_CLASS( CService_CreateInstance,  CLSID_Service,  "Remote Install Service Property Pages" )
//DEFINE_CLASS( CGroup_CreateInstance,    CLSID_Group,    "Remote Install Group Property Pages"   )
DEFINE_CLASS( CNewComputerExtensions_CreateInstance, CLSID_NewComputerExtension, "Remote Install New Computer Extension" )
DEFINE_CLASS( CRIQueryForm_CreateInstance, CLSID_RIQueryForm, "Remote Install DS Query Form" )
DEFINE_CLASS( CRISrvQueryForm_CreateInstance, CLSID_RISrvQueryForm, "Remote Install Server DS Query Form" )
END_CLASSTABLE

const IID IID_IExtendPropertySheet = {0x85DE64DC,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};
const CLSID CLSID_NodeManager = {0x43136EB5,0xD36C,0x11CF,{0xAD,0xBC,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const IID IID_IPropertySheetProvider = {0x85DE64DE,0xEF21,0x11cf,{0xA2,0x85,0x00,0xC0,0x4F,0xD8,0xDB,0xE6}};

#include <dsadmin.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\local.cpp ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\guids.h ===
//
// Copyright 1997 - Microsoft
//

//
// GUIDS.H - GUID definitions
//

#ifndef _GUIDS_H_
#define _GUIDS_H_

//
// External CLSIDs
//

// {0F65B1BF-740F-11d1-BBE6-0060081692B3}
DEFINE_GUID(CLSID_Computer, 
0xf65b1bf, 0x740f, 0x11d1, 0xbb, 0xe6, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {AC409538-741C-11d1-BBE6-0060081692B3}
DEFINE_GUID(CLSID_Service, 
0xac409538, 0x741c, 0x11d1, 0xbb, 0xe6, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {C641CF88-892F-11d1-BBEB-0060081692B3}
DEFINE_GUID(CLSID_Group, 
0xc641cf88, 0x892f, 0x11d1, 0xbb, 0xeb, 0x0, 0x60, 0x8, 0x16, 0x92, 0xb3);

// {D6D8C25A-4E83-11d2-8424-00C04FA372D4}
DEFINE_GUID(CLSID_NewComputerExtension,
0xd6d8c25a, 0x4e83, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {C1293E17-534E-11d2-8424-00C04FA372D4}
DEFINE_GUID(CLSID_RIQueryForm, 
0xc1293e17, 0x534e, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

// {55650117-5b71-47f7-9fc1-0431f53c006f}
DEFINE_GUID(CLSID_RISrvQueryForm,
0x55650117, 0x5b71, 0x47f7, 0x9f, 0xc1, 0x04, 0x31, 0xf5, 0x3c, 0x00, 0x6f);

//
// Internally Used Private Interfaces
//

// {F6215ED8-819C-11d1-BBE9-00C04FB953EA}
DEFINE_GUID(IID_IMAO, 
0xf6215ed8, 0x819c, 0x11d1, 0xbb, 0xe9, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {C88158C5-87A2-11d1-BBEA-00C04FB953EA}
DEFINE_GUID(IID_IIntelliMirrorSAP, 
0xc88158c5, 0x87a2, 0x11d1, 0xbb, 0xea, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {FA7C2CE0-889D-11d1-BBEA-00C04FB953EA}
DEFINE_GUID(IID_IEnumIMSIFs, 
0xfa7c2ce0, 0x889d, 0x11d1, 0xbb, 0xea, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {562B752D-9140-11d1-BBEF-00C04FB953EA}
DEFINE_GUID(IID_IEnumSAPs, 
0x562b752d, 0x9140, 0x11d1, 0xbb, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x53, 0xea);

// {D2378471-523D-11d2-8424-00C04FA372D4}
DEFINE_GUID(IID_ITab, 
0xd2378471, 0x523d, 0x11d2, 0x84, 0x24, 0x0, 0xc0, 0x4f, 0xa3, 0x72, 0xd4);

#endif // _GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\groups.h ===
//
// Copyright 1997 - Microsoft

//
// CLIENT.H - Handles the "IntelliMirror" IDD_PROP_INTELLIMIRROR_CLIENT tab
//

#ifdef INTELLIMIRROR_GROUPS

#ifndef _GROUPS_H_
#define _GROUPS_H_

// Definitions
LPVOID
CGroupsTab_CreateInstance( void );

class CComputer;
typedef CComputer* LPCComputer;

// CGroupsTab
class
CGroupsTab:
    public ITab
{
private:
    // Enums
    enum {
        MODE_SHELL = 0,
        MODE_ADMIN
    };

    HWND      _hDlg;
    LPUNKNOWN _punk;            // Pointer back to owner object
    BOOL      _fChanged:1;      // Has the dialog been changed

private: // Methods
    CGroupsTab();
    ~CGroupsTab();
    STDMETHOD(Init)();

    // This should be a copy of what CIMSCP has. We compare our
    // values with the IMSCP to see if the user has changed any
    // of their settings and only update those that have changed.
    BOOL  _fAllowNewClients;    // netbootAllowNewClients
    BOOL  _fLimitClients;       // netbootLimitClients
    UINT  _uMaxClients;         // netbootMaxClients
    UINT  _CGroupsTabs;            // netbootCurrentClientCount
    BOOL  _fAnswerRequests;     // netbootAnswerRequests
    BOOL  _fOnlyValidClients;   // netbootAnswerOnlyValidClients
    LPWSTR _pszNamimgPolicy;    // netbootNewMachineNamingPolicy
    LPWSTR _pszNewMachineOU;    // netbootNewMachineOU
    LPWSTR _pszMirroredOSs;     // netbootIntelliMirrorOSes
    LPWSTR _pszTools;           // netbootTools
    LPWSTR _pszLocalOSs;        // netbootLocallyInstalledOSes

    // Property Sheet Functions
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    BOOL    _OnCommand( WPARAM wParam, LPARAM lParam );
    INT     _OnNotify( WPARAM wParam, LPARAM lParam );
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );

public: // Methods
    friend LPVOID CGroupsTab_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                            LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );
};

typedef CGroupsTab* LPCGroupsTab;

#endif // _GROUPS_H_

#endif // INTELLIMIRROR_GROUPS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\local.h ===
// file deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\hostdlg.h ===
//
// Copyright 1997 - Microsoft

//
// HostDlg.H - Handles the IDD_HOST_SERVER_PAGE
//


#ifndef _HOSTDLG_H_
#define _HOSTDLG_H_


class CNewComputerExtensions; // fwd decl

// Definitions
LPVOID
CHostServerPage_CreateInstance( void );

// CHostServerPage
class
CHostServerPage:
    public ITab
{
private: // Members
    HWND  _hDlg;
    CNewComputerExtensions* _pNewComputerExtension;
    BOOL *       _pfActivatable;

private: // Methods
    CHostServerPage();
    ~CHostServerPage();
    STDMETHOD(Init)();

    // Property Sheet Functions
    static INT_PTR CALLBACK
        PropSheetDlgProc( HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam );
    static UINT CALLBACK
        PropSheetPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );
    HRESULT _InitDialog( HWND hDlg, LPARAM lParam );
    INT _OnCommand( WPARAM wParam, LPARAM lParam );
    INT _OnNotify( WPARAM wParam, LPARAM lParam );
    HRESULT _OnPSPCB_Create( VOID );
    HRESULT _IsValidRISServer( IN LPCWSTR ServerName );
    HRESULT _UpdateWizardButtons( VOID );
    static HRESULT _OnSearch( HWND hDlg );

public: // Methods
    friend LPVOID CHostServerPage_CreateInstance( void );

    // ITab
    STDMETHOD(AddPages)( LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(ReplacePage)( UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith,
                     LPARAM lParam, LPUNKNOWN punk );
    STDMETHOD(QueryInformation)( LPWSTR pszAttribute, LPWSTR * pszResult );
    STDMETHOD(AllowActivation)( BOOL * pfAllow );

    friend CNewComputerExtensions;
};

typedef CHostServerPage* LPCHostServerPage;

#endif // _HOSTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\remoteboot\admin\hostdlg.cpp ===
//
// Copyright 1997 - Microsoft

//
// HostDlg.CPP - Handles the IDD_HOST_SERVER_PAGE
//

#include "pch.h"
#include "dns.h"
#include "hostdlg.h"
#include "utils.h"
#include "newcmptr.h"
#include "winsock2.h"

DEFINE_MODULE("IMADMUI")
DEFINE_THISCLASS("CHostServerPage")
#define THISCLASS CHostServerPage
#define LPTHISCLASS LPCHostServerPage

DWORD aHostHelpMap[] = {
    IDC_B_ANYSERVER, HIDC_B_ANYSERVER,
    IDC_B_SPECIFICSERVER, HIDC_B_SPECIFICSERVER,
    IDC_E_SERVER, HIDC_E_SERVER,
    IDC_B_BROWSE, HIDC_B_BROWSE,
    NULL, NULL
};

//
// CreateInstance()
//
LPVOID
CHostServerPage_CreateInstance( void )
{
        TraceFunc( "CHostServerPage_CreateInstance()\n" );

    LPTHISCLASS lpcc = new THISCLASS( );
    HRESULT   hr   = THR( lpcc->Init( ) );

    if ( hr )
    {
        delete lpcc;
        RETURN(NULL);
    }

    RETURN((LPVOID) lpcc);
}

//
// Constructor
//
THISCLASS::THISCLASS( )
{
    TraceClsFunc( "CHostServerPage()\n" );

        InterlockIncrement( g_cObjects );

    TraceFuncExit();
}

//
// Init()
//
STDMETHODIMP
THISCLASS::Init( )
{
    HRESULT hr = S_OK;

    TraceClsFunc( "Init()\n" );

    Assert( !_pNewComputerExtension );

    HRETURN(hr);
}

//
// Destructor
//
THISCLASS::~THISCLASS( )
{
    TraceClsFunc( "~CHostServerPage()\n" );

        InterlockDecrement( g_cObjects );

    TraceFuncExit();
};

// *************************************************************************
//
// ITab
//
// *************************************************************************

STDMETHODIMP
THISCLASS::AddPages(
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam,
    LPUNKNOWN punk )
{
    TraceClsFunc( "AddPages( )\n" );

    HRESULT hr = S_OK;
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hpage;

    Assert( lpfnAddPage );
    if ( !lpfnAddPage )
        HRETURN(E_INVALIDARG);

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT | PSP_USECALLBACK;
    psp.hInstance   = (HINSTANCE) g_hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_HOST_SERVER_PAGE);
    psp.pcRefParent = (UINT *) &g_cObjects;
    psp.pfnCallback = (LPFNPSPCALLBACK) PropSheetPageProc;
    psp.pfnDlgProc  = PropSheetDlgProc;
    psp.lParam      = (LPARAM) this;

    hpage = CreatePropertySheetPage( &psp );
    if ( hpage )
    {
        if ( !lpfnAddPage( hpage, lParam ) )
        {
            DestroyPropertySheetPage( hpage );
            hr = THR(E_FAIL);
            goto Error;
        }
    }

Error:
    HRETURN(hr);
}

//
// ReplacePage()
//
STDMETHODIMP
THISCLASS::ReplacePage(
    UINT uPageID,
    LPFNADDPROPSHEETPAGE lpfnReplaceWith,
    LPARAM lParam,
    LPUNKNOWN punk )
{

    TraceClsFunc( "ReplacePage( ) *** NOT_IMPLEMENTED ***\n" );

    RETURN(E_NOTIMPL);
}

//
// QueryInformation( )
//
STDMETHODIMP
THISCLASS::QueryInformation(
    LPWSTR pszAttribute,
    LPWSTR * pszResult )
{
    TraceClsFunc( "QueryInformation( )\n" );

    if ( !pszResult )
        HRETURN(E_POINTER);

    if ( !pszAttribute )
        HRETURN(E_INVALIDARG);

    HRESULT hr = E_INVALIDARG;

    *pszResult = NULL;

    if ( StrCmpI( pszAttribute, NETBOOTSERVER ) == 0 )
    {
        LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
        if ( lResult )
        {
            Assert( *pszResult == NULL );
            hr = S_OK;
        }

        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult )
        {
            HWND  hwnd = GetDlgItem( _hDlg, IDC_E_SERVER );
            DWORD dw = Edit_GetTextLength( hwnd ) + 1;

            Assert( *pszResult == NULL );
            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwnd, *pszResult, dw );

            hr = S_OK;
        }
    }

    if ( StrCmpI( pszAttribute, L"Server" ) == 0 )
    {
        LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
        if ( lResult )
        {
            WCHAR szAny[80];
            DWORD dw = LoadString( g_hInstance, IDS_ANY_SERVER, szAny, ARRAYSIZE(szAny) );
            Assert( dw );

            Assert( *pszResult == NULL );
            *pszResult = (LPWSTR) TraceStrDup( szAny );
            if ( !*pszResult )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            hr = S_OK;
        }

        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult )
        {
            HWND  hwnd = GetDlgItem( _hDlg, IDC_E_SERVER );
            DWORD dw = Edit_GetTextLength( hwnd ) + 1;

            Assert( *pszResult == NULL );
            *pszResult = (LPWSTR) TraceAllocString( LMEM_FIXED, dw );
            if ( !*pszResult )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            Edit_GetText( hwnd, *pszResult, dw );

            hr = S_OK;
        }
    }

Cleanup:
    HRETURN(hr);
}

//
// AllowActivation( )
//
STDMETHODIMP
THISCLASS::AllowActivation(
    BOOL * pfAllow )
{
    TraceClsFunc( "AllowActivation( )\n" );

    _pfActivatable = pfAllow;

    HRETURN(S_OK);
}

// ************************************************************************
//
// Property Sheet Functions
//
// ************************************************************************

//
// PropSheetDlgProc()
//
INT_PTR CALLBACK
THISCLASS::PropSheetDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    //TraceMsg( TEXT("PropSheetDlgProc(") );
    //TraceMsg( TF_FUNC, TEXT(" hDlg = 0x%08x, uMsg = 0x%08x, wParam = 0x%08x, lParam = 0x%08x )\n"),
    //    hDlg, uMsg, wParam, lParam );

    LPTHISCLASS pcc = (LPTHISCLASS) GetWindowLongPtr( hDlg, GWLP_USERDATA );

    if ( uMsg == WM_INITDIALOG )
    {
        TraceMsg( TF_WM, TEXT("WM_INITDIALOG\n"));

        LPPROPSHEETPAGE psp = (LPPROPSHEETPAGE) lParam;
        SetWindowLongPtr( hDlg, GWLP_USERDATA, psp->lParam );
        pcc = (LPTHISCLASS) psp->lParam;
        pcc->_InitDialog( hDlg, lParam );
    }

    if (pcc)
    {
        Assert( hDlg == pcc->_hDlg );

        switch ( uMsg )
        {
        case WM_NOTIFY:
            TraceMsg( TF_WM, TEXT("WM_NOTIFY\n") );
            return pcc->_OnNotify( wParam, lParam );

        case WM_COMMAND:
            TraceMsg( TF_WM, TEXT("WM_COMMAND\n") );
            return pcc->_OnCommand( wParam, lParam );

        case WM_HELP:// F1
            {
                LPHELPINFO phelp = (LPHELPINFO) lParam;
                WinHelp( (HWND) phelp->hItemHandle, g_cszHelpFile, HELP_WM_HELP, (DWORD_PTR) &aHostHelpMap );
            }
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, g_cszHelpFile, HELP_CONTEXTMENU, (DWORD_PTR) &aHostHelpMap );
            break;
        }
    }

    return FALSE;
}

//
// PropSheetPageProc()
//
UINT CALLBACK
THISCLASS::PropSheetPageProc(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp )
{
    TraceClsFunc( "PropSheetPageProc( " );
    TraceMsg( TF_FUNC, TEXT("hwnd = 0x%08x, uMsg = 0x%08x, ppsp= 0x%08x )\n"),
        hwnd, uMsg, ppsp );

    Assert( ppsp );
    LPTHISCLASS pcc = (LPTHISCLASS) ppsp->lParam;

    switch ( uMsg )
    {
    case PSPCB_CREATE:
        TraceMsg( TF_WM, "PSPCB_CREATE\n" );
        if ( S_OK == pcc->_OnPSPCB_Create( ) )
        {
            RETURN(TRUE);   // create it
        }
        break;

    case PSPCB_RELEASE:
        TraceMsg( TF_WM, "PSPCB_RELEASE\n" );
        delete pcc;
        break;
    }

    RETURN(FALSE);
}

//
// _OnPSPCB_Create( )
//
HRESULT
THISCLASS::_OnPSPCB_Create( )
{
    TraceClsFunc( "_OnPSPCB_Create( )\n" );

    return S_OK;

}
//
// _InitDialog( )
//
HRESULT
THISCLASS::_InitDialog(
    HWND hDlg,
    LPARAM lParam )
{
    TraceClsFunc( "_InitDialog( )\n" );

    _hDlg = hDlg;

    Assert( _pNewComputerExtension );
    SetWindowText( GetParent( _hDlg ), _pNewComputerExtension->_pszWizTitle );
    SetDlgItemText( _hDlg, IDC_S_CREATEIN, _pNewComputerExtension->_pszContDisplayName );
    SendMessage( GetDlgItem( _hDlg, IDC_S_ICON ), STM_SETICON, (WPARAM) _pNewComputerExtension->_hIcon, 0 );

    Edit_LimitText( GetDlgItem( _hDlg, IDC_E_SERVER), DNS_MAX_NAME_LENGTH );
    Button_SetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ), BST_CHECKED );

    HRETURN(S_OK);
}


//
// _OnCommand( )
//
INT
THISCLASS::_OnCommand( WPARAM wParam, LPARAM lParam )
{
    TraceClsFunc( "_OnCommand( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    switch ( LOWORD(wParam) )
    {
    case IDC_B_ANYSERVER:
    case IDC_B_SPECIFICSERVER:
        if ( HIWORD(wParam) == BN_CLICKED )
        {
            LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
            EnableWindow( GetDlgItem( _hDlg, IDC_E_SERVER), (BOOL)lResult );
            EnableWindow( GetDlgItem( _hDlg, IDC_B_BROWSE), (BOOL)lResult );
            _UpdateWizardButtons( );
        }
        break;

    case IDC_E_SERVER:
        if ( HIWORD(wParam) == EN_CHANGE )
        {
            _UpdateWizardButtons( );
        }
        break;

    case IDC_B_SEARCH:
        if ( HIWORD( wParam ) == BN_CLICKED )
        {
            HRESULT hr = _OnSearch( _hDlg );            
        }
        break;

    }


    RETURN(FALSE);
}

//
// _UpdateWizardButtons( )
//
HRESULT
THISCLASS::_UpdateWizardButtons( )
{
    TraceClsFunc( "_UpdateWizardButtons( )\n" );

    HRESULT hr = S_OK;

    LRESULT lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
    if ( lResult == BST_CHECKED )
    {
        DWORD dw = Edit_GetTextLength( GetDlgItem( _hDlg, IDC_E_SERVER ) );
        if ( !dw )
        {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_BACK );
        }
        else
        {
            PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
        }
    }

    lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_ANYSERVER ) );
    if ( lResult == BST_CHECKED )
    {
        PropSheet_SetWizButtons( GetParent( _hDlg ), PSWIZB_NEXT | PSWIZB_BACK );
    }

    HRETURN(hr);
}


//
// _OnNotify( )
//
INT
THISCLASS::_OnNotify(
    WPARAM wParam,
    LPARAM lParam )
{
    TraceClsFunc( "_OnNotify( " );
    TraceMsg( TF_FUNC, "wParam = 0x%08x, lParam = 0x%08x )\n", wParam, lParam );

    LPNMHDR lpnmhdr = (LPNMHDR) lParam;
    TraceMsg( TF_WM, "NMHDR:  HWND = 0x%08x, idFrom = 0x%08x, code = 0x%08x\n",
        lpnmhdr->hwndFrom, lpnmhdr->idFrom, lpnmhdr->code );
    
    HRESULT hr;
    LRESULT lResult;
    switch( lpnmhdr->code )
    {
    case PSN_WIZNEXT:
        lResult = Button_GetCheck( GetDlgItem( _hDlg, IDC_B_SPECIFICSERVER ) );
        if ( lResult == BST_CHECKED ){
            WCHAR szServerName[DNS_MAX_NAME_BUFFER_LENGTH];
            CWaitCursor *Wait;

            Wait = new CWaitCursor();

            GetDlgItemText( _hDlg, IDC_E_SERVER, szServerName, ARRAYSIZE(szServerName) );
            hr = _IsValidRISServer( szServerName );

            if (Wait) {
                delete Wait;
                Wait = NULL;
            }

            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, ( SUCCEEDED(hr) ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE ));
            RETURN(TRUE);
        }
        break;
    case PSN_SETACTIVE:
        TraceMsg( TF_WM, "PSN_SETACTIVE\n" );
        Assert( _pfActivatable );
        if ( !*_pfActivatable )
        {
            SetWindowLongPtr( _hDlg, DWLP_MSGRESULT, -1 );   // don't show
            RETURN(TRUE);
        }
        _UpdateWizardButtons( );
        break;

    case PSN_KILLACTIVE:
        TraceMsg( TF_WM, "PSN_KILLACTIVE\n" );
        break;
    }

    RETURN(FALSE);
}


HRESULT
THISCLASS::_IsValidRISServer(
    IN LPCWSTR ServerName
    )
/*++

Routine Description:

    Validates if the specified server name points to a valid RIS server.

Arguments:

    ServerName - name of the server to validate

Return Value:

    HRESULT indicating outcome.
    (S_OK indicates that the server is a valid RIS server).

--*/
{
    HRESULT hr = E_FAIL;
    int retVal;
    CHAR mbszServerName[ DNS_MAX_NAME_BUFFER_LENGTH +1];
    size_t len;
    PHOSTENT hent;
    WCHAR ServerShare[MAX_PATH];
    
    TraceClsFunc("_IsValidRISServer( )\n");

    Assert( wcslen(ServerName) <= DNS_MAX_NAME_BUFFER_LENGTH );
    
    //
    // Do a DNS Lookup of the server as a first check to ensure it's a 
    // valid name.
    //
    len =  wcstombs( mbszServerName, ServerName, ARRAYSIZE( mbszServerName ) );
    
    hent = NULL;

    if ( !len ) {
        goto e0;
        
    }
    
    hent = gethostbyname( mbszServerName );
    if (!hent) {
        goto e0;
    }

    //
    // OK, we know the server actually resolves to a computer name.  Let's search
    // for \\servername\reminst share.  If this succeeds, we assume the server
    // is a valid remote install server
    //

    wsprintf( ServerShare, L"\\\\%s\\reminst\\oschooser", ServerName );    

    if (GetFileAttributes(ServerShare) == -1) {
        goto e0;
    }

    return(S_OK);

e0:
    retVal = MessageBoxFromStrings( 
                            _hDlg, 
                           