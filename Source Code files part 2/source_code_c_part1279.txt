rgets = LocalAlloc(LMEM_FIXED, (pDsInfo->ulNumServers * sizeof(ULONG))) );
            pDsInfo->ulNumTargets = 0;
            for(iServer=0; iServer < pDsInfo->ulNumServers; iServer++){
                if(pDsInfo->pszNC == NULL || DcDiagHasNC(pDsInfo->pszNC,
                                             &(pDsInfo->pServers[iServer]),
                                                            TRUE, TRUE)){
                    pDsInfo->pulTargets[pDsInfo->ulNumTargets] = iServer;
                    pDsInfo->ulNumTargets++;
                }
            }
        } else if(pDsInfo->ulFlags & DC_DIAG_TEST_SCOPE_SITE){
            // Test just this site
	    pDsInfo->ulNumTargets = 0;

	    pDsInfo->pulTargets = LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
						pDsInfo->ulNumServers * sizeof(ULONG));
	    DcDiagChkNull(pDsInfo->pulTargets);
	    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){
		if(pDsInfo->pServers[iServer].iSite == pDsInfo->iHomeSite){		
		    if(pDsInfo->pszNC == NULL || DcDiagHasNC(pDsInfo->pszNC,
							     &(pDsInfo->pServers[iServer]),
							     TRUE, TRUE)){
			pDsInfo->pulTargets[pDsInfo->ulNumTargets] = iServer;
			pDsInfo->ulNumTargets++;
		    }
		}
	    }
        } else {
            // Test just this server
            DcDiagChkNull( pDsInfo->pulTargets = LocalAlloc(LMEM_FIXED, sizeof(ULONG)) );
            pDsInfo->ulNumTargets = 1;
            pDsInfo->pulTargets[0] = pDsInfo->ulHomeServer;
        }

        PrintMessage(SEV_VERBOSE, L"* Found %ld DC(s). Testing %ld of them.\n",
                     pDsInfo->ulNumServers,
                     pDsInfo->ulNumTargets);

        PrintMessage(SEV_NORMAL, L"Done gathering initial info.\n");

    }  __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                        &dwWin32Err)){
        if (pDsInfo->pServers != NULL) {
            for (iServer = 0; iServer < pDsInfo->ulNumServers; iServer++) {
                if (pDsInfo->pServers[iServer].pszDn != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszDn);
                if (pDsInfo->pServers[iServer].pszName != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszName);
                if (pDsInfo->pServers[iServer].pszGuidDNSName != NULL)
                    LocalFree (pDsInfo->pServers[iServer].pszGuidDNSName);
            }
            LocalFree (pDsInfo->pServers);
            pDsInfo->pServers = NULL;
        }
        if (pDsInfo->pszRootDomain != NULL) LocalFree (pDsInfo->pszRootDomain);
    }

    // Note we do not unbind the Ds or Ldap connections, because they have been saved for later use.
    if (ppszOptions != NULL) ldap_value_freeW (ppszOptions);
    if (pszDn != NULL) ldap_memfreeW (pszDn);
    if (pldmNtdsDsaResults != NULL) ldap_msgfree (pldmNtdsDsaResults);
    if (pldmNtdsSiteDsaResults != NULL) ldap_msgfree (pldmNtdsSiteDsaResults);
    if (ppszSiteOptions != NULL) ldap_value_freeW (ppszSiteOptions);
    if (pldmNtdsSiteSettingsResults != NULL) ldap_msgfree (pldmNtdsSiteSettingsResults);
    if (pdsnameEnterprise != NULL) LocalFree (pdsnameEnterprise);
    if (pdsnameSite != NULL) LocalFree (pdsnameSite);
    if (pdsnameService != NULL) LocalFree (pdsnameService);
    if (ppszServiceName != NULL) ldap_value_freeW (ppszServiceName);
    if (pszSiteSettingsDn != NULL) LocalFree (pszSiteSettingsDn);
    if (pResult != NULL) DsFreeNameResultW(pResult);
    if (ppszRootDNC != NULL) ldap_value_freeW (ppszRootDNC);
    if (ppszConfigNc != NULL) ldap_value_freeW (ppszConfigNc);
    if (pldmRootResults != NULL) ldap_msgfree (pldmRootResults);
    if (fHomeNameMustBeFreed && HomeServer.pszName) { LocalFree(HomeServer.pszName); }

    if (pldmDsResults != NULL) ldap_msgfree(pldmDsResults);
    if (pszDsDn != NULL) LocalFree(pszDsDn);

    return dwWin32Err;
}

VOID
DcDiagFreeInfo (
    PDC_DIAG_DSINFO        pDsInfo
    )
/*++

Routine Description:

    Free the pDsInfo variable.

Arguments:

    pDsInfo - (IN) This is the pointer to free ... it is assumed to be
    DC_DIAG_DSINFO type

Return Value:

--*/
{
    ULONG            ul;

    // Free NCs
    if(pDsInfo->pNCs != NULL){
        for(ul = 0; ul < pDsInfo->cNumNCs; ul++){
            LocalFree(pDsInfo->pNCs[ul].pszName);
        }
        LocalFree(pDsInfo->pNCs);
    }

    // Free servers
    for (ul = 0; ul < pDsInfo->ulNumServers; ul++) {
        LocalFree (pDsInfo->pServers[ul].pszDn);
        LocalFree (pDsInfo->pServers[ul].pszName);
        LocalFree (pDsInfo->pServers[ul].pszGuidDNSName);
        LocalFree (pDsInfo->pServers[ul].pszDNSName);
        LocalFree (pDsInfo->pServers[ul].pszComputerAccountDn);
        if(pDsInfo->pServers[ul].ppszMasterNCs != NULL) {
            ldap_value_freeW (pDsInfo->pServers[ul].ppszMasterNCs);
        }
        if(pDsInfo->pServers[ul].ppszPartialNCs != NULL) {
            ldap_value_freeW (pDsInfo->pServers[ul].ppszPartialNCs);
        }
        if(pDsInfo->pServers[ul].hLdapBinding != NULL){
            ldap_unbind(pDsInfo->pServers[ul].hLdapBinding);
            pDsInfo->pServers[ul].hLdapBinding = NULL;
        }
        if(pDsInfo->pServers[ul].hDsBinding != NULL) {
            DsUnBind( &(pDsInfo->pServers[ul].hDsBinding));
            pDsInfo->pServers[ul].hDsBinding = NULL;
        }
        if(pDsInfo->pServers[ul].sNetUseBinding.pszNetUseServer != NULL){
            DcDiagTearDownNetConnection(&(pDsInfo->pServers[ul]));
        }
    }


    // Free Sites
    if(pDsInfo->pSites != NULL){
        for(ul = 0; ul < pDsInfo->cNumSites; ul++){
            if(pDsInfo->pSites[ul].pszISTG){
                LocalFree(pDsInfo->pSites[ul].pszISTG);
            }
            if(pDsInfo->pSites[ul].pszName){
                LocalFree(pDsInfo->pSites[ul].pszName);
            }
        }
        LocalFree(pDsInfo->pSites);
    }

    LocalFree (pDsInfo->pszRootDomain);
    LocalFree (pDsInfo->pServers);
    LocalFree (pDsInfo->pszRootDomainFQDN);
    LocalFree (pDsInfo->pulTargets);
}

VOID
DcDiagPrintDsInfo(
    PDC_DIAG_DSINFO pDsInfo
    )
/*++

Routine Description:

    This will print out the pDsInfo which might be helpful for debugging.

Parameters:

    pDsInfo - [Supplies] This is the struct that needs printing out,
        containing the info about the Active Directory.

  --*/
{
    ULONG                        ul, ulInner;

    wprintf(L"\n===============================================Printing out pDsInfo\n");
    wprintf(L"\nGLOBAL:"
            L"\n\tulNumServers=%ul"
            L"\n\tpszRootDomain=%s"
            L"\n\tpszNC=%s"
            L"\n\tpszRootDomainFQDN=%s"
            L"\n\tpszConfigNc=%s"
            L"\n\tiSiteOptions=%X"
            L"\n\tdwTombstoneLifeTimeDays=%d\n"
	    L"\n\tHomeServer=%d, %s\n", 
            pDsInfo->ulNumServers,
	    pDsInfo->pszRootDomain,
	    // This is an optional parameter.
	    (pDsInfo->pszNC) ? pDsInfo->pszNC : L"",
	pDsInfo->pszRootDomainFQDN,
	pDsInfo->pszConfigNc,
	pDsInfo->iSiteOptions,
	pDsInfo->dwTombstoneLifeTimeDays,
	pDsInfo->ulHomeServer, 
	pDsInfo->pServers[pDsInfo->ulHomeServer].pszName
        );

    for(ul=0; ul < pDsInfo->ulNumServers; ul++){
        LPWSTR pszUuidObject = NULL, pszUuidInvocation = NULL;
        UuidToString( &(pDsInfo->pServers[ul].uuid), &pszUuidObject );
        UuidToString( &(pDsInfo->pServers[ul].uuidInvocationId), &pszUuidInvocation );
        wprintf(L"\n\tSERVER: pServer[%d].pszName=%s"
                L"\n\t\tpServer[%d].pszGuidDNSName=%s"
                L"\n\t\tpServer[%d].pszDNSName=%s"
                L"\n\t\tpServer[%d].pszDn=%s"
                L"\n\t\tpServer[%d].pszComputerAccountDn=%s"
                L"\n\t\tpServer[%d].uuidObjectGuid=%s"
                L"\n\t\tpServer[%d].uuidInvocationId=%s"
                L"\n\t\tpServer[%d].iSite=%d (%s)"
                L"\n\t\tpServer[%d].iOptions=%x",
                ul, pDsInfo->pServers[ul].pszName,
                ul, pDsInfo->pServers[ul].pszGuidDNSName,
                ul, pDsInfo->pServers[ul].pszDNSName,
                ul, pDsInfo->pServers[ul].pszDn,
                ul, pDsInfo->pServers[ul].pszComputerAccountDn,
                ul, pszUuidObject,
                ul, pszUuidInvocation,
                ul, pDsInfo->pServers[ul].iSite, pDsInfo->pSites[pDsInfo->pServers[ul].iSite].pszName,
                ul, pDsInfo->pServers[ul].iOptions
                );
        if(pDsInfo->pServers[ul].ppszMasterNCs){
            wprintf(L"\n\t\tpServer[%d].ppszMasterNCs:", ul);
            for(ulInner = 0; pDsInfo->pServers[ul].ppszMasterNCs[ulInner] != NULL; ulInner++){
                wprintf(L"\n\t\t\tppszMasterNCs[%d]=%s",
                        ulInner,
                        pDsInfo->pServers[ul].ppszMasterNCs[ulInner]);
            }
        }
        if(pDsInfo->pServers[ul].ppszPartialNCs){
            wprintf(L"\n\t\tpServer[%d].ppszPartialNCs:", ul);
            for(ulInner = 0; pDsInfo->pServers[ul].ppszPartialNCs[ulInner] != NULL; ulInner++){
                wprintf(L"\n\t\t\tppszPartialNCs[%d]=%s",
                        ulInner,
                        pDsInfo->pServers[ul].ppszPartialNCs[ulInner]);
            }
        }
        wprintf(L"\n");
        RpcStringFree( &pszUuidObject );
        RpcStringFree( &pszUuidInvocation );
    }

    for(ul=0; ul < pDsInfo->cNumSites; ul++){
        wprintf(L"\n\tSITES:  pSites[%d].pszName=%s"
                L"\n\t\tpSites[%d].pszSiteSettings=%s"
                L"\n\t\tpSites[%d].pszISTG=%s"
                L"\n\t\tpSites[%d].iSiteOption=%x\n",
                ul, pDsInfo->pSites[ul].pszName,
                ul, pDsInfo->pSites[ul].pszSiteSettings,
                ul, pDsInfo->pSites[ul].pszISTG,
                ul, pDsInfo->pSites[ul].iSiteOptions);
    }

    if(pDsInfo->pNCs != NULL){
        for(ul=0; ul < pDsInfo->cNumNCs; ul++){
            wprintf(L"\n\tNC:     pNCs[%d].pszName=%s",
                    ul, pDsInfo->pNCs[ul].pszName);
            wprintf(L"\n\t\tpNCs[%d].pszDn=%s\n",
                    ul, pDsInfo->pNCs[ul].pszDn);
        }
    }

    wprintf(L"\n\t%d TARGETS: ", pDsInfo->ulNumTargets);
    for(ul=0; ul < pDsInfo->ulNumTargets; ul++){
        wprintf(L"%s, ", pDsInfo->pServers[pDsInfo->pulTargets[ul]].pszName);
    }

    wprintf(L"\n\n=============================================Done Printing pDsInfo\n\n");
}

DWORD
DcDiagRunTest (
    PDC_DIAG_DSINFO             pDsInfo,
    ULONG                       ulTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const DC_DIAG_TESTINFO *    pTestInfo
    )
/*++

Routine Description:

    Runs a test and catches any exceptions.

Arguments:

    pTestInfo        (IN ) -    The test's info structure.

Return Value:

    If the test raises a DC_DIAG_EXCEPTION, this will be the error
    code passed as an argument to DcDiagException.  Otherwise this
    will be NO_ERROR.

--*/
{
    DWORD            dwWin32Err = NO_ERROR;
    ULONG ulCount;
    CHAR c;


    PrintIndentAdj(1);


    __try {

// This can be used to check for memory leaks with dh.exe and dhcmp.exe
//#define DEBUG_MEM
#ifdef DEBUG_MEM
        c = getchar();
        for(ulCount=0; ulCount < 124; ulCount++){
            dwWin32Err = pTestInfo->fnTest (pDsInfo, ulTargetServer, gpCreds);
        }
        c = getchar();
#else
          dwWin32Err = pTestInfo->fnTest(pDsInfo, ulTargetServer, gpCreds);
#endif
    } __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                       &dwWin32Err)){
        // ... helpful to know when we died in an exception.
        IF_DEBUG(wprintf(L"JUMPED TO TEST EXCEPTION HANDLER(Err=%d): %s\n",
                         dwWin32Err,
                         Win32ErrToString(dwWin32Err)));
    }

    PrintIndentAdj(-1);
    return dwWin32Err;
}

VOID
DcDiagPrintTestsHeading(
    PDC_DIAG_DSINFO                   pDsInfo,
    ULONG                             iTarget,
    ULONG                             ulFlagSetType
    )
/*++

Routine Description:

    This prints a heading for the tests, it needed to be used about 3
    times so it became it's own function.

Arguments:

    ulFlagSetType - This is a

--*/
{
    PrintMessage(SEV_NORMAL, L"\n");
    if(ulFlagSetType == RUN_TEST_PER_SERVER){
        PrintMessage(SEV_NORMAL, L"Testing server: %s\\%s\n",
                     pDsInfo->pSites[pDsInfo->pServers[iTarget].iSite].pszName,
                     pDsInfo->pServers[iTarget].pszName);
    } else if(ulFlagSetType == RUN_TEST_PER_SITE){
        PrintMessage(SEV_NORMAL, L"Testing site: %s\n",
                     pDsInfo->pSites[iTarget].pszName);
    } else if(ulFlagSetType == RUN_TEST_PER_ENTERPRISE){
        PrintMessage(SEV_NORMAL, L"Running enterprise tests on : %s\n",
                     pDsInfo->pszRootDomain);
    }

}

VOID
DcDiagRunAllTests (
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR *                    ppszOmitTests,
    IN  BOOL                        bDoRequired,
    IN  ULONG                       ulFlagSetType, // server, site, enterprise
    IN  ULONG                       iTarget
    )
/*++

Routine Description:

    Runs the tests in alltests.h in sequence, if they match the
    ulFlagSetType and the bDoRequired type.

Arguments:

    ppszOmitTests    (IN ) -    A null-terminated list of tests to skip.

Return Value:

--*/
{
    DWORD   dwWin32Err = ERROR_SUCCESS;
    DWORD   dwTotalErr = ERROR_SUCCESS;
    ULONG   ulOmissionAt;
    BOOL    bPerform;
    CHAR    c;
    BOOL    bPrintedHeading = FALSE;
    LPWSTR  pszTarget = NULL;

    PrintIndentAdj(1);

    // Try running All the tests.
    for (gMainInfo.lTestAt = 0L; allTests[gMainInfo.lTestAt].testId != DC_DIAG_ID_FINISHED; gMainInfo.lTestAt++) {

        // Checking if test is the right kind of test: server, site, enterp...
        if(ulFlagSetType & allTests[gMainInfo.lTestAt].ulTestFlags){
            // The right kind of test ... server indexs must
            //    be matched with server tests, site indexs with
            //    site tests, etc.
            if(!bDoRequired
               && !(allTests[gMainInfo.lTestAt].ulTestFlags & CAN_NOT_SKIP_TEST)){
                // Running a non-required test ... This section will give
                //     all three reasons to or not do this optional test.
                bPerform = TRUE;

                // Checking if the user Specified not to do this test.
                for (ulOmissionAt = 0L; ppszOmitTests[ulOmissionAt] != NULL; ulOmissionAt++){
                    if (_wcsicmp (ppszOmitTests[ulOmissionAt],
                                  allTests[gMainInfo.lTestAt].pszTestName) == 0){
                        bPerform = FALSE;

                        if(!bPrintedHeading){
                            // Need to print heading for this test type before
                            //   printing out any errors
                            DcDiagPrintTestsHeading(pDsInfo, iTarget,
                                                    ulFlagSetType);
                            bPrintedHeading = TRUE;
                        }

                        PrintIndentAdj(1);
                        PrintMessage(SEV_VERBOSE,
                                     L"Test omitted by user request: %s\n",
                                     allTests[gMainInfo.lTestAt].pszTestName);
                        PrintIndentAdj(-1);
                    }
                }

                // Checking if the server failed the Up Check.
                if( (ulFlagSetType & RUN_TEST_PER_SERVER)
                    && ! (pDsInfo->pServers[iTarget].bDsResponding
                       && pDsInfo->pServers[iTarget].bLdapResponding) ){
                    bPerform = FALSE;

                    if(!bPrintedHeading){
                        // Need to print heading for this test type before
                        //    printing out any errors
                        DcDiagPrintTestsHeading(pDsInfo, iTarget,
                                                ulFlagSetType);
                        bPrintedHeading = TRUE;

                        PrintIndentAdj(1);
                        PrintMessage(SEV_NORMAL,
                                     L"Skipping all tests, because server %s is\n",
                                     pDsInfo->pServers[iTarget].pszName);
                        PrintMessage(SEV_NORMAL,
                                     L"not responding to directory service requests\n");
                        PrintIndentAdj(-1);
                    }
                }

            } else if(bDoRequired
                      && (allTests[gMainInfo.lTestAt].ulTestFlags & CAN_NOT_SKIP_TEST)){
                // Running a required test
                bPerform = TRUE;
            } else {
                bPerform = FALSE;
            } // end if/elseif/else if required/non-required
        } else {
            bPerform = FALSE;
        } // end if/else right kind of test set (server, site, enterprise

        if(!bPrintedHeading && bPerform){
            // Need to print out heading for this type of test, before printing
            //   out any test output
            DcDiagPrintTestsHeading(pDsInfo, iTarget, ulFlagSetType);
            bPrintedHeading = TRUE;
        }

        // Perform the test if appropriate ------------------------------------
        if (bPerform) {
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"Starting test: %s\n",
                         allTests[gMainInfo.lTestAt].pszTestName);
            dwWin32Err = DcDiagRunTest (pDsInfo,
                                        iTarget,
                                        gpCreds,
                                        &allTests[gMainInfo.lTestAt]);
           PrintIndentAdj(1);

            if(ulFlagSetType & RUN_TEST_PER_SERVER){
                pszTarget = pDsInfo->pServers[iTarget].pszName;
            } else if(ulFlagSetType & RUN_TEST_PER_SITE){
                pszTarget = pDsInfo->pSites[iTarget].pszName;
            } else if(ulFlagSetType & RUN_TEST_PER_ENTERPRISE){
                pszTarget = pDsInfo->pszRootDomain;
            } else {
                Assert(!"New set type fron alltests.h that hasn't been updated in main.c/DcDiagRunAllTests\n");
                pszTarget = L"";
            }
            if(dwWin32Err == NO_ERROR){
                PrintMessage(SEV_NORMAL,
                             L"......................... %s passed test %s\n",
                             pszTarget, allTests[gMainInfo.lTestAt].pszTestName);
            } else {
                PrintMessage(SEV_ALWAYS,
                             L"......................... %s failed test %s\n",
                             pszTarget, allTests[gMainInfo.lTestAt].pszTestName);
            }
            PrintIndentAdj(-1);
            PrintIndentAdj(-1);
        } // end bPeform ...

    } // end for each test

    PrintIndentAdj(-1);
}

VOID
DcDiagRunTestSet (
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR *                    ppszOmitTests,
    IN  BOOL                        bDoRequired,
    IN  ULONG                       ulFlagSetType // Server, Site, or Enterprise
    )
/*++

Routine Description:

    This calles the DcDiagRunAllTests one per server, site, or enterprise
    dependant on the what ulFlagSetType is set to.

Arguments:

    pDsInfo - the enterprise info (passed through)
    gpCreds - the alternate credentails if any (passed through)
    ppszOmitTests - a list of tests to not perform (passed through)
    bDoRequired - whether to do the required tests (passed through)
    ulFlagSetType - only important parameter, this tells wether we should be
        doing the tests per server, per site, or per enterprise.

--*/
{
    ULONG                           iTarget;

    if(ulFlagSetType == RUN_TEST_PER_SERVER){
        for(iTarget = 0; iTarget < pDsInfo->ulNumTargets; iTarget++){
             DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                               bDoRequired, ulFlagSetType,
                               pDsInfo->pulTargets[iTarget]);
        }
    } else if(ulFlagSetType == RUN_TEST_PER_SITE){
        for(iTarget = 0; iTarget < pDsInfo->cNumSites; iTarget++){
            DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                              bDoRequired, ulFlagSetType,
                              iTarget);
        }
    } else if(ulFlagSetType == RUN_TEST_PER_ENTERPRISE){
         DcDiagRunAllTests(pDsInfo, gpCreds, ppszOmitTests,
                           bDoRequired, ulFlagSetType,
                           0);
    } else {
        Assert(!"Programmer error, called DcDiagRunTestSet() w/ bad param\n");
    }
}

VOID
DcDiagMain (
    IN   LPWSTR                          pszHomeServer,
    IN   LPWSTR                          pszNC,
    IN   ULONG                           ulFlags,
    IN   LPWSTR *                        ppszOmitTests,
    IN   SEC_WINNT_AUTH_IDENTITY_W *     gpCreds,
    IN   WCHAR  *                        ppszExtraCommandLineArgs[]
    )
/*++

Routine Description:
whether server
    Runs the tests in alltests.h in sequence.

Arguments:

    ppszOmitTests    (IN ) -    A null-terminated list of tests to skip.
    pszSourceName = pNeighbor->pszSourceDsaAddress;


Return Value:

--*/
{
    DC_DIAG_DSINFO              dsInfo;
    DWORD                       dwWin32Err;
    ULONG                       ulTargetServer;
    WSADATA                     wsaData;
    INT                         iRet;
    CHAR                        c;

    INT i=0;
    // Set the Extra Command parameters
    dsInfo.ppszCommandLine = ppszExtraCommandLineArgs;

    // Print out general version info ------------------------------------------
    PrintMessage(SEV_NORMAL, L"\n");
    PrintMessage(SEV_NORMAL, DC_DIAG_VERSION_INFO);
    PrintMessage(SEV_NORMAL, L"\n");


    // Initialization of WinSock, and Gathering Initial Info -------------------
    PrintMessage(SEV_NORMAL, L"Performing initial setup:\n");
    PrintIndentAdj(1);

    // Init WinSock
    dwWin32Err = WSAStartup(MAKEWORD(1,1),&wsaData);
    if (dwWin32Err != 0) {
        PrintMessage(SEV_ALWAYS,
                     L"Couldn't initialize WinSock with error: %s\n",
                     Win32ErrToString(dwWin32Err));
    }

    // Gather Initial Info
    // Note: We expect DcDiagGatherInfo to print as many informative errors as it
    //   needs to.
    dwWin32Err = DcDiagGatherInfo (pszHomeServer, pszNC, ulFlags, gpCreds,
                                   &dsInfo);
    dsInfo.gpCreds = gpCreds;
    if(dwWin32Err != ERROR_SUCCESS){
        // Expect that DdDiagGatherInfo printed out appropriate errors, just bail.
        return;
    }
    PrintIndentAdj(-1);
    PrintMessage(SEV_NORMAL, L"\n");

    IF_DEBUG(DcDiagPrintDsInfo(&dsInfo););


    // Actually Running Tests --------------------------------------------------
    //   Do required Tests
    PrintMessage(SEV_NORMAL, L"Doing initial required tests\n");
    // Do per server tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_SERVER);
    // Do per site tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_SITE);
    // Do per enterprise tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     TRUE, RUN_TEST_PER_ENTERPRISE);

    //   Do non-required Tests
    PrintMessage(SEV_NORMAL, L"\nDoing primary tests\n");
    // Do per server tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_SERVER);
    // Do per site tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_SITE);
    // Do per enterprise tests
    DcDiagRunTestSet(&dsInfo, gpCreds, ppszOmitTests,
                     FALSE, RUN_TEST_PER_ENTERPRISE);

    // Clean up and leave ------------------------------------------------------
    WSACleanup();
    DcDiagFreeInfo (&dsInfo);
}

int
PreProcessGlobalParams(
    IN OUT    INT *    pargc,
    IN OUT    LPWSTR** pargv
    )
/*++

Routine Description:

    Scan command arguments for user-supplied credentials of the form
        [/-](u|user):({domain\username}|{username})
        [/-](p|pw|pass|password):{password}
    Set credentials used for future DRS RPC calls and LDAP binds appropriately.
    A password of * will prompt the user for a secure password from the console.

    Also scan args for /async, which adds the DRS_ASYNC_OP flag to all DRS RPC
    calls.

    CODE.IMPROVEMENT: The code to build a credential is also available in
    ntdsapi.dll\DsMakePasswordCredential().

Arguments:

    pargc
    pargv


Return Values:

    ERROR_SUCCESS - success
    other - failure

--*/
{
    INT     ret = 0;
    INT     iArg;
    LPWSTR  pszOption;

    DWORD   cchOption;
    LPWSTR  pszDelim;
    LPWSTR  pszValue;
    DWORD   cchValue;

    for (iArg = 1; iArg < *pargc; ){
        if (((*pargv)[iArg][0] != L'/') && ((*pargv)[iArg][0] != L'-')){
            // Not an argument we care about -- next!
            iArg++;
        } else {
            pszOption = &(*pargv)[iArg][1];
            pszDelim = wcschr(pszOption, L':');

        cchOption = (DWORD)(pszDelim - (*pargv)[iArg]);

        if (    (0 == _wcsnicmp(L"p:",        pszOption, cchOption))
            || (0 == _wcsnicmp(L"pw:",       pszOption, cchOption))
            || (0 == _wcsnicmp(L"pass:",     pszOption, cchOption))
            || (0 == _wcsnicmp(L"password:", pszOption, cchOption)) ){
            // User-supplied password.
          //            char szValue[ 64 ] = { '\0' };

        pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        if ((2 == cchValue) && (L'*' == pszValue[0])){
            // Get hidden password from console.
            cchValue = 64;

            gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

            if (NULL == gCreds.Password){
                PrintMessage(SEV_ALWAYS, L"No memory.\n" );
            return ERROR_NOT_ENOUGH_MEMORY;
            }

            PrintMessage(SEV_ALWAYS, L"Password: ");

            ret = GetPassword(gCreds.Password, cchValue, &cchValue);
        } else {
            // Get password specified on command line.
            gCreds.Password = malloc(sizeof(WCHAR) * cchValue);

            if (NULL == gCreds.Password){
                PrintMessage(SEV_ALWAYS, L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
            }
            wcscpy(gCreds.Password, pszValue); //, cchValue);

        }

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
                            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else if (    (0 == _wcsnicmp(L"u:",    pszOption, cchOption))
               || (0 == _wcsnicmp(L"user:", pszOption, cchOption)) ){


            // User-supplied user name (and perhaps domain name).
            pszValue = pszDelim + 1;
        cchValue = 1 + wcslen(pszValue);

        pszDelim = wcschr(pszValue, L'\\');

        if (NULL == pszDelim){
            // No domain name, only user name supplied.
            PrintMessage(SEV_ALWAYS, L"User name must be prefixed by domain name.\n");
            return ERROR_INVALID_PARAMETER;
        }

        gCreds.Domain = malloc(sizeof(WCHAR) * cchValue);
        gCreds.User = gCreds.Domain + (int)(pszDelim+1 - pszValue);

        if (NULL == gCreds.Domain){
            PrintMessage(SEV_ALWAYS, L"No memory.\n");
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        wcsncpy(gCreds.Domain, pszValue, cchValue);
        // wcscpy(gCreds.Domain, pszValue); //, cchValue);
        gCreds.Domain[ pszDelim - pszValue ] = L'\0';

        // Next!
        memmove(&(*pargv)[iArg], &(*pargv)[iArg+1],
            sizeof(**pargv)*(*pargc-(iArg+1)));
        --(*pargc);
        } else {
            iArg++;
        }
    }
    }

    if (NULL == gCreds.User){
        if (NULL != gCreds.Password){
        // Password supplied w/o user name.
        PrintMessage(SEV_ALWAYS, L"Password must be accompanied by user name.\n" );
            ret = ERROR_INVALID_PARAMETER;
        } else {
        // No credentials supplied; use default credentials.
        ret = ERROR_SUCCESS;
        }
        gpCreds = NULL;
    } else {
        gCreds.PasswordLength = gCreds.Password ? wcslen(gCreds.Password) : 0;
        gCreds.UserLength   = wcslen(gCreds.User);
        gCreds.DomainLength = gCreds.Domain ? wcslen(gCreds.Domain) : 0;
        gCreds.Flags        = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        // CODE.IMP: The code to build a SEC_WINNT_AUTH structure also exists
        // in DsMakePasswordCredentials.  Someday use it

        // Use credentials in DsBind and LDAP binds
        gpCreds = &gCreds;
    }

    return ret;
}



#define CR        0xD
#define BACKSPACE 0x8

INT
GetPassword(
    WCHAR *     pwszBuf,
    DWORD       cchBufMax,
    DWORD *     pcchBufUsed
    )
/*++

Routine Description:

    Retrieve password from command line (without echo).
    Code stolen from LUI_GetPasswdStr (net\netcmd\common\lui.c).

Arguments:

    pwszBuf - buffer to fill with password
    cchBufMax - buffer size (incl. space for terminating null)
    pcchBufUsed - on return holds number of characters used in password

Return Values:

    DRAERR_Success - success
    other - failure

--*/
{
    WCHAR   ch;
    WCHAR * bufPtr = pwszBuf;
    DWORD   c;
    INT     err;
    INT     mode;

    cchBufMax -= 1;    /* make space for null terminator */
    *pcchBufUsed = 0;               /* GP fault probe (a la API's) */
    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode)) {
        return GetLastError();
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsoleW(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
        if (!err || c != 1)
            ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) {  /* back up one or two */
            /*
             * IF bufPtr == buf then the next two lines are
             * a no op.
             */
            if (bufPtr != pwszBuf) {
                bufPtr--;
                (*pcchBufUsed)--;
            }
        }
        else {

            *bufPtr = ch;

            if (*pcchBufUsed < cchBufMax)
                bufPtr++ ;                   /* don't overflow buf */
            (*pcchBufUsed)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = L'\0';         /* null terminate the string */
    putchar('\n');

    if (*pcchBufUsed > cchBufMax)
    {
        PrintMessage(SEV_ALWAYS, L"Password too long!\n");
        return ERROR_INVALID_PARAMETER;
    }
    else
    {
        return ERROR_SUCCESS;
    }
}


//---------------------------------------------------------------------------
//
//  Function:       ConvertToWide
//
//  Description:    converts a single byte string to a double byte string
//
//  Arguments:      lpszDestination - destination string
//                  lpszSource - source string
//                  iDestSize - maximum # of chars to be converted
//                             (= destination size)
//
//  Returns:        none
//
//  History:        01/22/98 - gabrielh created
//
//---------------------------------------------------------------------------
void
ConvertToWide (LPWSTR lpszDestination,
               LPCSTR lpszSource,
               const int iDestSize)
{
    if (lpszSource){
        //
        //just convert the 1 character string to wide-character string
        MultiByteToWideChar (
                 CP_ACP,
                 0,
                 lpszSource,
                 -1,
                 lpszDestination,
                 iDestSize
                 );
    } else {
        lpszDestination[0] = L'\0';
    }
}


LPWSTR
findServerForDomain(
    LPWSTR pszDomainDn
    )

/*++

Routine Description:

    Locate a DC that holds the given domain.

    This routine runs before pDsInfo is allocated.  We don't know who our
    home server is. We can only use knowledge from the Locator.

    The incoming name is checked to be a Dn. Ncs such as CN=Configuration and
    CN=Schema are not allowed.

Arguments:

    pszDomainDn - DN of domain

Return Value:

    LPWSTR - DNS name of server. Allocated using LocalAlloc. Caller must
    free.

--*/

{
    DWORD status;
    LPWSTR pszServer = NULL;
    PDS_NAME_RESULTW pResult = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;

    // Check for valid DN syntax
    if (_wcsnicmp( pszDomainDn, L"dc=", 3 ) != 0) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of domain distinguished name %ws is incorrect.\n",
                      pszDomainDn );
        return NULL;
    }

    // Convert the DN of domain to DNS name
    status = DsCrackNamesW(
        NULL,
        DS_NAME_FLAG_SYNTACTICAL_ONLY,
        DS_FQDN_1779_NAME,
        DS_CANONICAL_NAME_EX,
        1,
        &pszDomainDn,
        &pResult);
    if ( (status != ERROR_SUCCESS) ||
         (pResult->rItems[0].pDomain == NULL) ) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of domain distinguished name %ws is incorrect.\n",
                      pszDomainDn );
        PrintMessage( SEV_ALWAYS,
                      L"Translation failed with error: %s.\n",
                      Win32ErrToString(status) );
        return NULL;
    }

    // Use DsGetDcName to find the server with the domain

    // Get active domain controller information
    status = DsGetDcName(
        NULL, // computer name
        pResult->rItems[0].pDomain, // domain name
        NULL, // domain guid,
        NULL, // site name,
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_IP_REQUIRED |
        DS_IS_DNS_NAME |
        DS_RETURN_DNS_NAME,
        &pDcInfo );
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS,
                     L"A domain controller holding %ws could not be located.\n",
                     pResult->rItems[0].pDomain );
        PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
        PrintMessage(SEV_ALWAYS, L"Try specifying a server with the /s option.\n" );
        goto cleanup;
    }

    pszServer = LocalAlloc( LMEM_FIXED,
                            (wcslen( pDcInfo->DomainControllerName + 2 ) + 1) *
                            sizeof( WCHAR ) );
    if (pszServer == NULL) {
        PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
        goto cleanup;
    }
    wcscpy( pszServer, pDcInfo->DomainControllerName + 2 );

    PrintMessage( SEV_VERBOSE, L"* The home server picked is %ws in site %ws.\n",
                  pszServer,
                  pDcInfo->DcSiteName );
cleanup:

    if (pResult != NULL) {
        DsFreeNameResultW(pResult);
    }
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }

    return pszServer;

} /* findServerForDomain */



LPWSTR
findDefaultServer(BOOL fMustBeDC)

/*++

Routine Description:

    Get the DNS name of the default computer, which would be the local machine.

Return Value:

    LPWSTR - DNS name of server. Allocated using LocalAlloc. Caller must
    free.

--*/

{
    LPWSTR             pwszServer = NULL;
    DWORD              ulSizeReq = 0;
    DWORD              dwErr = 0;
    HANDLE             hDs = NULL;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC    pBuffer = NULL;

    __try{

        // Call GetComputerNameEx() once to get size of buffer, then allocate the buffer.
        GetComputerNameEx(ComputerNameDnsHostname, pwszServer, &ulSizeReq);
        pwszServer = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulSizeReq);
        if(pwszServer == NULL){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        // Now actually get the computer name.
        if(GetComputerNameEx(ComputerNameDnsHostname, pwszServer, &ulSizeReq) == 0){
            dwErr = GetLastError();
            Assert(dwErr != ERROR_BUFFER_OVERFLOW);
            PrintMsg(SEV_ALWAYS, DCDIAG_GATHERINFO_CANT_GET_LOCAL_COMPUTERNAME,
                     Win32ErrToString(dwErr));
            __leave;
        }

        if (fMustBeDC)
        {
            PrintMsg(SEV_VERBOSE,
                     DCDIAG_GATHERINFO_VERIFYING_LOCAL_MACHINE_IS_DC,
                     pwszServer);
        }

        dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (CHAR **) &pBuffer);
        if(dwErr != ERROR_SUCCESS){
            Assert(dwErr != ERROR_INVALID_PARAMETER);
            Assert(dwErr == ERROR_NOT_ENOUGH_MEMORY && "It wouldn't surprise me if"
                   " this fires, but MSDN documentation claims there are only 2 valid"
                   " error codes");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            __leave;
        }
        Assert(pBuffer != NULL);
        if(!(pBuffer->MachineRole == DsRole_RolePrimaryDomainController
             || pBuffer->MachineRole == DsRole_RoleBackupDomainController)){
            if (fMustBeDC)
            {
                // This machine is NOT a DC.  Signal any error.
                PrintMsg(SEV_ALWAYS, DCDIAG_MUST_SPECIFY_S_OR_N,
                         pwszServer);
                dwErr = ERROR_DS_NOT_SUPPORTED;
            }
            __leave;
        }
/*        else
        {
            if (!fMustBeDC)
            {
                // This machine is a DC. Signal any error. BUGBUG need error
                PrintMsg(SEV_ALWAYS, DCDIAG_MUST_SPECIFY_S_OR_N,
                         pwszServer);
                dwErr = ERROR_DS_NOT_SUPPORTED;
            }
            __leave;
        }
*/

    } __finally {
        if(dwErr){
            if(pwszServer){
                LocalFree(pwszServer);
            }
            pwszServer = NULL;
        }
        if(pBuffer){
            DsRoleFreeMemory(pBuffer);
        }
    }

    return(pwszServer);
} /* findDefaultServer */


LPWSTR
convertDomainNcToDn(
    LPWSTR pwzIncomingDomainNc
    )

/*++

Routine Description:

This routine converts a domain in shorthand form into the standard
Distinguished Name form.

If the name is a dn we return it.
If the name is not a dns name, we use dsgetdcname to convert the netbios domain
to a dns domain.
Given a dns domain, we use crack names to generate the dn for the domain.

If a name looks like a DN, we return it without further validation.  That
will be performed later.

Note that CN=Schema and CN=Configuration have no convenient shorthand's like
domains that have a DNS and netbios name.  That is because they are not
domains, but only Ncs.

Note that at the time this routine runs, pDsInfo is not initialized, so we
cannot depend on it.  In fact, we have no bindings to any DC's yet. We don't
even know our home server at this point. The only knowledge I rely on is that
of the locator (DsGetDcName).

Arguments:

    pwzIncomingDomainNc - Naming context.

Return Value:

    LPWSTR - Naming context in Dn form. This is always allocated using
    LocalAlloc. Caller must free.

--*/

{
    DWORD status;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    LPWSTR pwzOutgoingDomainDn = NULL, pwzTempDnsName = NULL;
    PDS_NAME_RESULTW pResult = NULL;

    // Check if already a Dn
    // Looks like a DN, return it for now
    if (wcschr( pwzIncomingDomainNc, L'=' ) != NULL) {
        LPWSTR pwzNewDn = LocalAlloc( LMEM_FIXED,
                                      (wcslen( pwzIncomingDomainNc ) + 1) *
                                      sizeof( WCHAR ) );
        if (pwzNewDn == NULL) {
            PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
            goto cleanup;
        }
        wcscpy( pwzNewDn, pwzIncomingDomainNc );
        return pwzNewDn;
    }

    // If not a dns name, assume a netbios name and use the locator
    if (wcschr( pwzIncomingDomainNc, L'.' ) == NULL) {

        status = DsGetDcName(
            NULL, // computer name
            pwzIncomingDomainNc, // domain name
            NULL, // domain guid,
            NULL, // site name,
            DS_DIRECTORY_SERVICE_REQUIRED |
            DS_IP_REQUIRED |
            DS_RETURN_DNS_NAME,
            &pDcInfo );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS,
                         L"A domain named %ws could not be located.\n",
                         pwzIncomingDomainNc );
            PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
            PrintMessage(SEV_ALWAYS, L"Check syntax and validity of specified name.\n" );
            goto cleanup;
        }
        PrintMessage( SEV_ALWAYS, L"The domain name is %ws.\n",
                      pDcInfo->DomainName );
        pwzIncomingDomainNc = pDcInfo->DomainName;
    }

    // Copy name and terminate in special way to make crack names happy
    // DNS name must be newline terminated. Don't ask me.
    pwzTempDnsName = LocalAlloc( LMEM_FIXED,
                                 (wcslen( pwzIncomingDomainNc ) + 2) *
                                 sizeof( WCHAR ) );
    if (pwzTempDnsName == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        goto cleanup;
    }
    wcscpy( pwzTempDnsName, pwzIncomingDomainNc );
    wcscat( pwzTempDnsName, L"\n" );

    // Convert the dns name to Dn format

    status = DsCrackNamesW(
        NULL,
        DS_NAME_FLAG_SYNTACTICAL_ONLY,
        DS_CANONICAL_NAME_EX,
        DS_FQDN_1779_NAME,
        1,
        &pwzTempDnsName,
        &pResult);
    if ( (status != ERROR_SUCCESS) ||
         ( pResult->rItems[0].pName == NULL) ) {
        PrintMessage( SEV_ALWAYS,
                      L"The syntax of DNS domain name %ws is incorrect.\n",
                      pwzIncomingDomainNc );
        PrintMessage( SEV_ALWAYS,
                      L"Translation failed with error: %s.\n",
                      Win32ErrToString(status) );
        goto cleanup;
    }

    // Return new Dn
    pwzOutgoingDomainDn = LocalAlloc( LMEM_FIXED,
                                      (wcslen( pResult->rItems[0].pName ) + 1) *
                                      sizeof( WCHAR ) );
    if (pwzOutgoingDomainDn == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        goto cleanup;
    }
    wcscpy( pwzOutgoingDomainDn, pResult->rItems[0].pName );

    PrintMessage( SEV_ALWAYS, L"The distinguished name of the domain is %s.\n",
                  pwzOutgoingDomainDn );

cleanup:

    if (pwzTempDnsName != NULL) {
        LocalFree( pwzTempDnsName );
    }
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }
    if (pResult != NULL) {
        DsFreeNameResultW(pResult);
    }

    if (pwzOutgoingDomainDn == NULL) {
        PrintMessage( SEV_ALWAYS,
                      L"The specified naming context is incorrect and will be ignored.\n" );
    }

    return pwzOutgoingDomainDn;

} /* convertDomainNcToDN */

void
DoNonDcTests(
    PWSTR pwzComputer,
    ULONG ulFlags, // currently ignored, the DC_DIAG_FIX value may be needed later
    PWSTR * ppszDoTests,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    WCHAR * ppszExtraCommandLineArgs[])
/*++

Routine Description:

Runs the tests that are designed for machines that are not DCs.

Arguments:

--*/
{
    DC_DIAG_DSINFO dsInfo;
    BOOL fPerform;
    ULONG iTest = 0L;
    DWORD dwWin32Err = ERROR_SUCCESS;

    if (pwzComputer)
    {
        PrintMsg(SEV_ALWAYS, DCDIAG_DONT_USE_SERVER_PARAM);
        return;
    }

    pwzComputer = findDefaultServer(FALSE);

    if (!pwzComputer)
    {
        return;
    }

    dsInfo.pszNC = pwzComputer; // pass the computer name into the test function.
    // Set the Extra Command parameters
    dsInfo.ppszCommandLine = ppszExtraCommandLineArgs;

    for (gMainInfo.lTestAt = 0L; allTests[gMainInfo.lTestAt].testId != DC_DIAG_ID_FINISHED; gMainInfo.lTestAt++)
    {
        Assert(ppszDoTests);

        fPerform = FALSE;

        for (iTest = 0L; ppszDoTests[iTest] != NULL; iTest++)
        {
            if (_wcsicmp(ppszDoTests[iTest],
                         allTests[gMainInfo.lTestAt].pszTestName) == 0)
            {
                Assert(NON_DC_TEST & allTests[gMainInfo.lTestAt].ulTestFlags);
                fPerform = TRUE;
            }
        }

        // Perform the test if appropriate ------------------------------------
        if (fPerform)
        {
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"Starting test: %s\n",
                         allTests[gMainInfo.lTestAt].pszTestName);

            dwWin32Err = DcDiagRunTest(&dsInfo,
                                       0,
                                       gpCreds,
                                       &allTests[gMainInfo.lTestAt]);
            PrintIndentAdj(1);

            if(dwWin32Err == NO_ERROR){
                PrintMessage(SEV_NORMAL,
                             L"......................... %s passed test %s\n",
                             pwzComputer, allTests[gMainInfo.lTestAt].pszTestName);
            } else {
                PrintMessage(SEV_ALWAYS,
                             L"......................... %s failed test %s\n",
                             pwzComputer, allTests[gMainInfo.lTestAt].pszTestName);
            }
            PrintIndentAdj(-1);
            PrintIndentAdj(-1);
        } // end fPeform ...
    }

    LocalFree(pwzComputer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\common\registry.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    common\registry.c

ABSTRACT:

    This gives a library of functions to quickly grab registry
    values from remote machines.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>

#include "dcdiag.h"
#include "utils.h"

DWORD
GetRegistryDword(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pszRegLocation,
    LPWSTR                          pszRegParameter,
    PDWORD                          pdwResult
    )
/*++

Routine Description:

    This function will give us a registry dword from the place specified.

Arguments:

    pServer - The server to grab the reg value off of.
    pszRegLocation - The location in the registry.
    pszRegParameter - The parameter in this location of the registry
    pdwResult - The return parameter, will not be set if there is an error.

Return Value:

    A win 32 Error, if it is ERROR_SUCCESS, then pdwResult will have been set.

--*/
{
    DWORD                           dwRet;
    HKEY                            hkMachine = NULL;
    HKEY                            hk = NULL;
    DWORD                           dwType;
    DWORD                           dwSize = sizeof(DWORD);
    ULONG                           ulTemp;
    LPWSTR                          pszMachine = NULL;

    __try {

        dwRet = DcDiagGetNetConnection(pServer, pCreds);
        if(dwRet == ERROR_SUCCESS){
            __leave;
        }

        // 2 for "\\", 1 for null, and 1 extra
        ulTemp = wcslen(pServer->pszName) + 4;

        pszMachine = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszMachine == NULL){
            dwRet = GetLastError();
            __leave;
        }

        wcscpy(pszMachine, L"\\\\");
        wcscat(pszMachine, pServer->pszName);
        dwRet = RegConnectRegistry(pszMachine, HKEY_LOCAL_MACHINE, &hkMachine);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        dwRet = RegOpenKey(hkMachine, pszRegLocation, &hk);
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }

        dwRet = RegQueryValueEx(hk,    // handle of key to query        
                                pszRegParameter,   // value name            
                                NULL,                 // must be NULL          
                                &dwType,              // address of type value 
                                (LPBYTE) pdwResult,     // address of value data 
                                &dwSize);           // length of value data
        if(dwRet != ERROR_SUCCESS){
            __leave;
        }
        if(dwType != REG_DWORD){
            dwRet = ERROR_INVALID_PARAMETER;
            __leave;
        }

        // finally success ... pdwResult should be set.
        
    } __finally {
        if(hkMachine) { RegCloseKey(hkMachine); }
        if(hk) { RegCloseKey(hk); }
        if(pszMachine) { LocalFree(pszMachine); }
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\dns\dnsmain.c ===
//+----------------------------------------------------------------------------  
/*++

Copyright (c) 2000 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dnsmain.c

ABSTRACT:

    DNS tests for dcdiag.exe.

DETAILS:

    DrDNS tests as specified by LevonE

CREATED:

    20-Apr-2000 EricB

--*/
//-----------------------------------------------------------------------------  

#include <ntdspch.h>
#include <iphlpapi.h>
#include <dsrole.h>
#include <windns.h>
#include "dcdiag.h"
#include "alltests.h"

// From dnsapi.h; don't want to include the whole header since there are conflicts
// with windns.h on 2195.
//
typedef IP4_ARRAY   IP_ARRAY, *PIP_ARRAY;

DNS_STATUS
WINAPI
DnsUpdateTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    IN  LPWSTR      pszName,
    IN  DWORD       fOptions,
    IN  PIP_ARRAY   aipServers OPTIONAL
    );

// globals and constants.
//
const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 = 155; // from dcpromo\exe\headers.hxx
const PWSTR g_pwzSrvRecordPrefix = L"_ldap._tcp.dc._msdcs.";
const PWSTR g_pwzMSDCS = L"_msdcs.";
const PWSTR g_pwzSites = L"_sites.";
const PWSTR g_pwzTcp = L"_tcp.";
const PWSTR g_pwzUdp = L"_udp.";
const PWSTR g_pwzTcpIpParams = L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

#define DCDIAG_MAX_ADDR 4 // arbitrary, but not likely to find a machine with more
#define DCDIAG_LOOPBACK_ADDR 0x100007f

BOOL g_fUpgradedNT4DC = FALSE;
BOOL g_fDC = FALSE;
BOOL g_fDNSserver = FALSE;
DWORD g_rgIpAddr[DCDIAG_MAX_ADDR] = {0};

// extract IP octects from a DWORD
#define FIRST_IPADDRESS(x)  ((x>>24) & 0xff)
#define SECOND_IPADDRESS(x) ((x>>16) & 0xff)
#define THIRD_IPADDRESS(x)  ((x>>8) & 0xff)
#define FOURTH_IPADDRESS(x) (x & 0xff)

#define IP_STRING_FMT_ARGS(x) \
  FOURTH_IPADDRESS(x), THIRD_IPADDRESS(x), SECOND_IPADDRESS(x), FIRST_IPADDRESS(x)

WCHAR g_wzIpAddr[IP4_ADDRESS_STRING_LENGTH + 1];

DWORD ValidateNames(PWSTR pwzComputer, PWSTR pwzDnsDomain);
DWORD CheckAdapterDnsConfig(PWSTR pwzComputer);
PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond);
PWSTR AllocString(PWSTR pwz);
BOOL AddToList(PWSTR * ppwzList, PWSTR pwz);
BOOL BuildList(PWSTR * ppwzList, PWSTR pwzDnsDomain);
DWORD NewTreeSrvCheck(PWSTR pwzForestRoot, PWSTR pwzDnsDomain);
DWORD ChildDomainSrvCheck(PWSTR pwzDnsDomain);
DWORD ReplicaDcSrvCheck(PWSTR pwzDnsDomain);
DWORD DcLocatorRegisterCheck(PWSTR pwzDnsDomain);
DWORD RCodeNotImplTest(PWSTR pwzDnsDomain);
DWORD RCodeSrvFailTest(PWSTR pwzDnsDomain);
DWORD ARecordRegisterCheck(PWSTR pwzComputerLabel, PWSTR pwzComputerDnsSuffix,
                           PWSTR pwzDnsDomain);
DWORD GetComputerDnsSuffix(PWSTR * ppwzComputerDnsDomainName, PWSTR pwzDnsDomain);
void GetMachineInfo(void);

//+----------------------------------------------------------------------------
//
// Function:   PrePromoDnsCheck
//
// Synopsis:   Check a machine's DNS configuration before it is converted to a
//             domain controller.
//
// Note:       pDsInfo->pszNC is used to pass the computer name into this
//             function.
//
//-----------------------------------------------------------------------------
DWORD 
PrePromoDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   size_t cchDomainArgPrefix = wcslen(DNS_DOMAIN_ARG);
   size_t cchRootArgPrefix = wcslen(FOREST_ROOT_DOMAIN_ARG);
   int i;
   PWSTR pwzComputerDnsSuffix, pwzCmdLineDnsDomain = NULL;
   PWSTR pwzParent, pwzForestRoot = NULL;
   DNS_STATUS status;
   DWORD dwErr = ERROR_SUCCESS;
   enum {None, NewForest, NewTree, ChildDomain, ReplicaDC} Operation = None;

   //
   // Gather parameters.
   //
   if (!pDsInfo->ppszCommandLine)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   for (i = 0; pDsInfo->ppszCommandLine[i]; i++)
   {
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], DNS_DOMAIN_ARG, cchDomainArgPrefix) == 0)
      {
         pwzCmdLineDnsDomain = &pDsInfo->ppszCommandLine[i][cchDomainArgPrefix];
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], NEW_FOREST_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = NewForest;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], NEW_TREE_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = NewTree;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], CHILD_DOMAIN_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = ChildDomain;
         continue;
      }
      if (_wcsicmp(pDsInfo->ppszCommandLine[i], REPLICA_DC_ARG) == 0)
      {
         if (None != Operation)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
            PrintMessage(SEV_ALWAYS, L"\n");
            return ERROR_INVALID_PARAMETER;
         }
         Operation = ReplicaDC;
         continue;
      }
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], FOREST_ROOT_DOMAIN_ARG, cchRootArgPrefix) == 0)
      {
         pwzForestRoot = &pDsInfo->ppszCommandLine[i][cchRootArgPrefix];
         continue;
      }
      // If here, then somethine unrecognized is on the command line.
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   if (!pwzCmdLineDnsDomain || (None == Operation) ||
       (NewTree == Operation && NULL == pwzForestRoot))
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   PrintMessage(SEV_DEBUG,
                L"\nTemporary message: Can computer %s be promoted to a DC for\n\tdomain %s, Op %d\n\n",
                pDsInfo->pszNC, pwzCmdLineDnsDomain, Operation);

   GetMachineInfo();

   status = GetComputerDnsSuffix(&pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Validate the names. (step 1)
   //

   status = ValidateNames(pDsInfo->pszNC, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Check whether the computer's DNS suffix is going to be different than the
   // AD domain after the promotion. The below won't work if remoting to a
   // different computer is to be added. (step 2)
   //

   PrintMessage(SEV_DEBUG,
                L"\nComparing the computer name suffix %s with the DNS domain name.\n\n",
                pwzComputerDnsSuffix);

   if (_wcsicmp(pwzComputerDnsSuffix, pwzCmdLineDnsDomain) != 0)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SUFFIX_MISMATCH, pwzComputerDnsSuffix);
      PrintMessage(SEV_ALWAYS, L"\n");
   }

   //
   // Check whether at least one enabled adapter/connection is configured
   // with preferred DNS server. (step 3)
   //

   status = CheckAdapterDnsConfig(pDsInfo->pszNC);

   if (ERROR_SUCCESS != status)
   {
      LocalFree(pwzComputerDnsSuffix);
      return status;
   }

   //
   // Check whether the SRV DNS record for
   // _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
   // is in place. (step 4)
   //
   switch (Operation)
   {
   case NewForest:
      //
      // Skip for new forest.
      //
      break;

   case ReplicaDC:
      status = ReplicaDcSrvCheck(pwzCmdLineDnsDomain);
      break;

   case NewTree:
      status = NewTreeSrvCheck(pwzForestRoot, pwzCmdLineDnsDomain);
      break;

   case ChildDomain:
      status = ChildDomainSrvCheck(pwzCmdLineDnsDomain);
      break;

   default:
      Assert(FALSE);
   }

   if (ERROR_SUCCESS != status)
   {
      dwErr = status;
   }

   PrintMsg(SEV_ALWAYS, DCDIAG_WARN_MISCONFIGURE);
   PrintMessage(SEV_ALWAYS, L"\n");

   //
   // Verify that the server will be able to register DC locator records after
   // successful promotion to a DC. (step 5)
   //

   status = DcLocatorRegisterCheck(pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      LocalFree(pwzComputerDnsSuffix);
      return status;
   }

   //
   // Verify that the server will be able to register A record for its computer
   // name after successful promotion to a DC. (step 6)
   //

   status = ARecordRegisterCheck(pDsInfo->pszNC, pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   LocalFree(pwzComputerDnsSuffix);

   return (ERROR_SUCCESS != status) ? status : dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:   RegisterLocatorDnsCheck
//
// Synopsis:   Tests whether this domain controller can register the Domain
//             Controller Locator DNS records. These records must be present in
//             DNS in order for other computers to locate this domain controller
//             for the pwzCmdLineDnsDomain domain. Reports whether any modifications to
//             the existing DNS infrastructure are required.
//
// Note:       pDsInfo->pszNC is used to pass the computer name into this
//             function.
//
//-----------------------------------------------------------------------------
DWORD 
RegisterLocatorDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   DNS_STATUS status;
   PWSTR pwzCmdLineDnsDomain = NULL, pwzComputerDnsSuffix;
   int i;
   size_t cchDomainArgPrefix = wcslen(DNS_DOMAIN_ARG);

   //
   // Gather parameters.
   //
   if (!pDsInfo->ppszCommandLine)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   for (i = 0; pDsInfo->ppszCommandLine[i]; i++)
   {
      if (_wcsnicmp(pDsInfo->ppszCommandLine[i], DNS_DOMAIN_ARG, cchDomainArgPrefix) == 0)
      {
         pwzCmdLineDnsDomain = &pDsInfo->ppszCommandLine[i][cchDomainArgPrefix];
         continue;
      }
   }

   if (!pwzCmdLineDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   GetMachineInfo();

   status = GetComputerDnsSuffix(&pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Validate the names. (step 1)
   //

   status = ValidateNames(pDsInfo->pszNC, pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Check whether at least one enabled adapter/connection is configured
   // with preferred DNS server. (step 3)
   //

   status = CheckAdapterDnsConfig(pDsInfo->pszNC);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Verify that the server will be able to register DC locator records after
   // successful promotion to a DC. (step 5)
   //

   status = DcLocatorRegisterCheck(pwzCmdLineDnsDomain);

   if (ERROR_SUCCESS != status)
   {
      return status;
   }

   //
   // Verify that the server will be able to register A record for its computer
   // name after successful promotion to a DC. (step 6)
   //

   status = ARecordRegisterCheck(pDsInfo->pszNC, pwzComputerDnsSuffix, pwzCmdLineDnsDomain);

   LocalFree(pwzComputerDnsSuffix);

   return status;
}

/* DWORD 
JoinDomainDnsCheck(
   IN PDC_DIAG_DSINFO             pDsInfo,
   IN ULONG                       ulCurrTargetServer,
   IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds)
{
   PrintMessage(SEV_ALWAYS, L"Running test: \n");
    
   return ERROR_SUCCESS;
} */

//+----------------------------------------------------------------------------
//
// string helpers.
//
//-----------------------------------------------------------------------------

PWSTR AllocString(PWSTR pwz)
{
   PWSTR pwzTmp;

   pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED, ((int)wcslen(pwz) + 1) * sizeof(WCHAR));

   if (!pwzTmp)
   {
      return NULL;
   }

   wcscpy(pwzTmp, pwz);

   return pwzTmp;
}

PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond)
{
   PWSTR pwz;

   pwz = (PWSTR)LocalAlloc(LMEM_FIXED,
                           ((int)wcslen(pwzFirst) + (int)wcslen(pwzSecond) + 1) * sizeof(WCHAR));

   if (!pwz)
   {
      return NULL;
   }

   wcscpy(pwz, pwzFirst);
   wcscat(pwz, pwzSecond);

   return pwz;
}

BOOL AddToList(PWSTR * ppwzList, PWSTR pwz)
{
   PWSTR pwzTmp;

   if (*ppwzList)
   {
      pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED,
                                 ((int)wcslen(*ppwzList) + (int)wcslen(pwz) + 3) * sizeof(WCHAR));
      if (!pwzTmp)
      {
         return FALSE;
      }

      wcscpy(pwzTmp, *ppwzList);
      wcscat(pwzTmp, L", ");
      wcscat(pwzTmp, pwz);

      LocalFree(*ppwzList);

      *ppwzList = pwzTmp;
   }
   else
   {
      pwzTmp = AllocString(pwz);

      if (!pwzTmp)
      {
         return FALSE;
      }

      *ppwzList = pwzTmp;
   }
   return TRUE;
}

BOOL BuildList(PWSTR * ppwzList, PWSTR pwzItem)
{
   PWSTR pwzDot = NULL, pwzTmp = NULL;

   pwzTmp = AllocString(pwzItem);

   if (!pwzTmp)
   {
      return FALSE;
   }

   pwzDot = pwzItem;

   while (pwzDot = wcschr(pwzDot, L'.'))
   {
      pwzDot++;
      if (!pwzDot)
      {
         break;
      }

      if (!AddToList(&pwzTmp, pwzDot))
      {
         return FALSE;
      }
   }

   *ppwzList = pwzTmp;

   return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:   ValidateNames
//
// Synopsis:   Validate the names. (step 1)
//
//-----------------------------------------------------------------------------
DWORD
ValidateNames(PWSTR pwzComputer, PWSTR pwzDnsDomain)
{
   DNS_STATUS status;
   int cchName, cchDnsDomain;

   //
   // Validate the DNS domain name (logic same as DcPromo).
   //

   cchDnsDomain = (int)wcslen(pwzDnsDomain);

   if (DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 < cchDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_TOO_LONG, pwzDnsDomain,
                DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   cchName = WideCharToMultiByte(CP_UTF8,
                                 0,
                                 pwzDnsDomain,
                                 cchDnsDomain,
                                 0,
                                 0,
                                 0,
                                 0);

   if (DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 < cchName)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_TOO_LONG, pwzDnsDomain,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   status = DnsValidateName(pwzDnsDomain, DnsNameDomain);

   switch (status)
   {
   case ERROR_INVALID_NAME:
   case DNS_ERROR_INVALID_NAME_CHAR:
   case DNS_ERROR_NUMERIC_NAME:
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_SYNTAX, pwzDnsDomain,
               DNS_MAX_LABEL_LENGTH);
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;

   case DNS_ERROR_NON_RFC_NAME:
      //
      // Not an error, print warning message.
      //
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_WARN_RFC, pwzDnsDomain);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;

   case ERROR_SUCCESS:
      break;
   }

   //
   // Verify that the first label of the Full DNS name of the computer
   // doesn't contain any invalid characters. pwzComputer is assumed to be just
   // the first label since it was obtained via a call to GetComputerNameEx
   // with a level of ComputerNameDnsHostname in main.c. If the code is changed
   // to allow command line specification of remote computer names, then the
   // name will have to be checked to see what form it is.
   //

   status = DnsValidateName(pwzComputer, DnsNameHostnameLabel);

   switch (status)
   {
   case ERROR_INVALID_NAME:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case DNS_ERROR_INVALID_NAME_CHAR:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_BAD_NAME_CHAR);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case DNS_ERROR_NON_RFC_NAME:
      if (g_fUpgradedNT4DC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC1);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_NOTE);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_UPGR_DC3);
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NON_RFC_NOTE);
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      break;

   case ERROR_SUCCESS:
      break;

   default:
      PrintMsg(SEV_ALWAYS, DCDIAG_DNS_DOMAIN_SYNTAX, pwzDnsDomain,
               DNS_MAX_LABEL_LENGTH);
      PrintMessage(SEV_ALWAYS, L"\n");
      break;
   }

   return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   CheckAdapterDnsConfig
//
// Synopsis:   Check whether at least one enabled adapter/connection is
//             configured with a DNS server. (step 3)
//
//-----------------------------------------------------------------------------
DWORD
CheckAdapterDnsConfig(PWSTR pwzComputer)
{
   // IpConfig reads the registry and I can't find a good alternative way to do
   // this remotely. For now using DnsQueryConfig which is not remoteable nor
   // does it return per-adapter listings.
   //
   PIP4_ARRAY pipArray;
   DNS_STATUS status;
   DWORD i, dwBufSize = sizeof(IP4_ARRAY);
   BOOL fFound = FALSE;
   UNREFERENCED_PARAMETER(pwzComputer);

   status = DnsQueryConfig(DnsConfigDnsServerList, DNS_CONFIG_FLAG_ALLOC, NULL,
                           NULL, &pipArray, &dwBufSize);

   if (ERROR_SUCCESS != status || !pipArray)
   {
      PrintMessage(SEV_ALWAYS, L"Attempt to obtain DNS name server info failed with error %d\n", status);
      return status;
   }

   for (i = 0; i < pipArray->AddrCount; i++)
   {
      fFound = TRUE;
      PrintMessage(SEV_DEBUG, L"\nName server IP address: %d.%d.%d.%d\n",
                   IP_STRING_FMT_ARGS(pipArray->AddrArray[i]));
   }

   LocalFree(pipArray);

   if (!fFound)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS1);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS2);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_NAME_SERVERS3);
      PrintMessage(SEV_ALWAYS, L"\n");
      return DNS_INFO_NO_RECORDS;
   }

   return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   ReplicaDcSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
ReplicaDcSrvCheck(PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord = NULL, pwzSrvList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzDnsDomain);

   if (!pwzFullSrvRecord)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_NO_SRV, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      PWSTR pwzDomainList;

      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_SERVER4, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_NAME, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_RCODE_REFUSED, pwzDnsDomain, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_NO_RECORDS, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   NewTreeSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
NewTreeSrvCheck(PWSTR pwzForestRoot, PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord = NULL, pwzSrvList = NULL, pwzDomainList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzForestRoot);

   if (!pwzFullSrvRecord)
   {
       return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_NO_RECORDS, pwzDnsDomain, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER2, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_SERVER4, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_NAME1, pwzDnsDomain, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_NAME2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzForestRoot))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_RCODE_REFUSED, pwzDnsDomain, pwzForestRoot, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_NEWTREE_ERR_NO_RECORDS, pwzDnsDomain, pwzForestRoot);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   ChildDomainSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
ChildDomainSrvCheck(PWSTR pwzDnsDomain)
{
   PDNS_RECORD rgDnsRecs = NULL, pDnsRec = NULL;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzParent = NULL, pwzFullSrvRecord = NULL,
         pwzSrvList = NULL, pwzDomainList = NULL;

   pwzParent = wcschr(pwzDnsDomain, L'.');

   if (!pwzParent || !(pwzParent + 1))
   {
      // TODO: new message?
      PrintMsg(SEV_ALWAYS, DCDIAG_SYNTAX_ERROR_DCPROMO_PARAM);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_INVALID_PARAMETER;
   }

   pwzParent++;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzParent);

   if (!pwzFullSrvRecord)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   LocalFree(pwzFullSrvRecord);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_NO_SRV, pwzDnsDomain, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               status = DnsQuery_W(pDnsRec->Data.Srv.pNameTarget, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, pDnsRec->Data.Srv.pNameTarget))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  PrintMessage(SEV_DEBUG, L"\nSRV name: %s, A addr: %d.%d.%d.%d\n",
                               pDnsRec->Data.Srv.pNameTarget,
                               IP_STRING_FMT_ARGS(rgARecs->Data.A.IpAddress));
                  DnsRecordListFree(rgARecs, DnsFreeRecordListDeep);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

         if (fSuccess)
         {
            // Success message
            PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_SUCCESS, pwzDnsDomain);
            PrintMessage(SEV_ALWAYS, L"\n");
            status = NO_ERROR;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_A_RECORD, pwzDnsDomain, pwzSrvList);
            PrintMessage(SEV_ALWAYS, L"\n");
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_FORMAT, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER2, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_SERVER4, pwzParent, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME1, pwzDnsDomain, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME2, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_NAME3, pwzParent);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildList(&pwzDomainList, pwzParent))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_REFUSED1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_CHILD_ERR_RCODE_REFUSED2, pwzParent, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_GET_HELP);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzDomainList);
         break;

      case ERROR_TIMEOUT:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_TIMEOUT);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         PrintMessage(SEV_ALWAYS, L"\n");
         break;
      }
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   DcLocatorRegisterCheck
//
// Synopsis:   Verify that the server will be able to register DC locator
//             records after successful promotion to a DC. (step 5)
//
//-----------------------------------------------------------------------------
DWORD
DcLocatorRegisterCheck(PWSTR pwzDnsDomain)
{
#define DCDIAG_GUID_BUF_SIZE 64
   const PWSTR pwzAdapters = L"Adapters";
   const PWSTR pwzInterfaces = L"Interfaces";
   const PWSTR pwzDisableUpdate = L"DisableDynamicUpdate";
   const PWSTR pwzNetLogParams = L"System\\CurrentControlSet\\Services\\Netlogon\\Parameters";
   const PWSTR pwzUpdateOnAll = L"DnsUpdateOnAllAdapters";
   WCHAR wzGuidBuf[DCDIAG_GUID_BUF_SIZE];
   HKEY hTcpIpKey, hKey, hItfKey;
   LONG lRet;
   DWORD dwType, dwSize, dwDisable, dwUpdate, i;
   FILETIME ft;
   BOOL fDisabledOnAll = TRUE;
   DNS_STATUS status;

   //
   // Verify that the client is configured to attempt dynamic updates of the
   // DNS records
   //

   // If ((HKLM/System/CCS/Services/Tcpip/Paramaters/DisableDynamicUpdate == 0x1)
   // && (HKLM/System/CCS/Services/Netlogon/Parameters/DnsUpdateOnAllAdapters != 0x1))

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_pwzTcpIpParams, 0, KEY_READ, &hTcpIpKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   lRet = RegQueryValueEx(hTcpIpKey, pwzDisableUpdate, 0, &dwType, (PBYTE)&dwDisable, &dwSize);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwDisable = 0;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hTcpIpKey);
         return lRet;
      }
   }

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzNetLogParams, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      RegCloseKey(hTcpIpKey);
      return lRet;
   }

   lRet = RegQueryValueEx(hKey, pwzUpdateOnAll, 0, &dwType, (PBYTE)&dwUpdate, &dwSize);

   RegCloseKey(hKey);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwUpdate = 1;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hTcpIpKey);
         return lRet;
      }
   }

   if (1 == dwDisable)
   {
      if (1 != dwUpdate)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ALL_UPDATE_OFF);
         RegCloseKey(hTcpIpKey);
         return DNS_ERROR_RECORD_DOES_NOT_EXIST;
      }
   }
   else // DisableDynamicUpdate != 1
   {
      // if ((HKLM/System/CCS/Services/Tcpip/Paramaters/DisableDynamicUpdate != 0x1)
      // && (for all enabled connections HKLM/System/CCS/Services/Tcpip/Paramaters/Interfaces/<Interface GUID>/DisableDynamicUpdate == 0x1)
      // && (HKLM/CCS/Services/Netlogon/Parameters/DnsUpdateOnAllAdapters != 0x1))

      if (1 != dwUpdate)
      {
         /*
         PMIB_IFTABLE pIfTable;

         dwSize = 0;

         status = GetIfTable(NULL, &dwSize, FALSE);

         if (ERROR_INSUFFICIENT_BUFFER != status)
         {
            PrintMessage(SEV_ALWAYS, L"Reading the adapter interfaces failed with error %d\n", status);
            return status;
         }

         pIfTable = LocalAlloc(LMEM_FIXED, dwSize);
                               //sizeof(MIB_IFTABLE) + (sizeof(MIB_IFROW) * dwSize));
         if (!pIfTable)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         status = GetIfTable(pIfTable, &dwSize, FALSE);

         if (NO_ERROR != status)
         {
            PrintMessage(SEV_ALWAYS, L"Reading the adapter interfaces failed with error %d\n", status);
            LocalFree(pIfTable);
            return status;
         }

         for (i = 0; i < pIfTable->dwNumEntries; i++)
         {
            PrintMessage(SEV_DEBUG, L"Interface name %s, description %S.\n",
                         pIfTable->table[i].wszName, pIfTable->table[i].bDescr);
            if (pIfTable->table[i].dwOperStatus >= IF_OPER_STATUS_CONNECTING)
            {
               PrintMessage(SEV_DEBUG, L"Interface %s enabled.\n",
                            pIfTable->table[i].wszName);
            }
         }

         LocalFree(pIfTable);
         */

         lRet = RegOpenKeyEx(hTcpIpKey, pwzInterfaces, 0, KEY_READ, &hItfKey);

         if (ERROR_SUCCESS != lRet)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
            RegCloseKey(hTcpIpKey);
            return lRet;
         }

         i = 0;

         do
         {
            dwSize = DCDIAG_GUID_BUF_SIZE;

            lRet = RegEnumKeyEx(hItfKey, i, wzGuidBuf, &dwSize, NULL, NULL, NULL, &ft);

            if (ERROR_SUCCESS != lRet)
            {
               if (ERROR_NO_MORE_ITEMS == lRet)
               {
                  break;
               }
               else
               {
                  PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
                  RegCloseKey(hTcpIpKey);
                  return lRet;
               }
            }

            lRet = RegOpenKeyEx(hItfKey, wzGuidBuf, 0, KEY_READ, &hKey);

            if (ERROR_SUCCESS != lRet)
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
               RegCloseKey(hTcpIpKey);
               RegCloseKey(hItfKey);
               return lRet;
            }

            lRet = RegQueryValueEx(hKey, pwzDisableUpdate, NULL, &dwType, (PBYTE)&dwUpdate, &dwSize);

            RegCloseKey(hKey);

            if (ERROR_SUCCESS != lRet)
            {
               if (ERROR_FILE_NOT_FOUND == lRet)
               {
                  dwUpdate = 0;
                  lRet = ERROR_SUCCESS;
               }
               else
               {
                  PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
                  RegCloseKey(hTcpIpKey);
                  RegCloseKey(hItfKey);
                  return lRet;
               }
            }

            if (1 != dwUpdate)
            {
               // BUGBUG: need to determine what constitutes an enabled interface/connection
               fDisabledOnAll = FALSE;
            }

            i++;

         } while (ERROR_SUCCESS == lRet);

         RegCloseKey(hTcpIpKey);
         RegCloseKey(hItfKey);

         if (fDisabledOnAll)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ADAPTER_UPDATE_OFF);
            PrintMessage(SEV_ALWAYS, L"\n");
            return DNS_ERROR_RECORD_DOES_NOT_EXIST;
         }
      }
   }

   //
   // Verify that the zone(s) authoritative for the records to be registered
   // can be discovered and that it can be dynamically updated.
   //

   status = DnsUpdateTest_W(0, pwzDnsDomain, 0, 0);

   switch (status)
   {
   case NO_ERROR:
   case DNS_ERROR_RCODE_NXRRSET:
   case DNS_ERROR_RCODE_YXDOMAIN:
      PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
      PrintMessage(SEV_ALWAYS, L"\n");
      return ERROR_SUCCESS;

   case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
      return RCodeNotImplTest(pwzDnsDomain);

   case ERROR_TIMEOUT:
      PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_TIMEOUT);
      PrintMessage(SEV_ALWAYS, L"\n");
      if (!g_fDC)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_TIMEOUT_NOT_DC);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      return ERROR_SUCCESS;

   case DNS_ERROR_RCODE_SERVER_FAILURE:
      return RCodeSrvFailTest(pwzDnsDomain);
   }

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   RCodeNotImplTest
//
// Synopsis:   
//
//-----------------------------------------------------------------------------
DWORD
RCodeNotImplTest(PWSTR pwzDnsDomain)
{
   DNS_STATUS status, stMsd, stSit, stTcp, stUdp;
   PDNS_RECORD rgDomainRecs, rgDnsRecs, pDnsRec;
   PWSTR pwzAuthZone = NULL;
   PWSTR pwzMsDcs = NULL, pwzSites = NULL, pwzTcp = NULL, pwzUdp = NULL;

   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDomainRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   g_wzIpAddr[0] = L'\0';

   pDnsRec = rgDomainRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

         wsprintf(g_wzIpAddr, L"%d.%d.%d.%d", IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

         break;

      case DNS_TYPE_SOA:
         PrintMessage(SEV_DEBUG, L"\nSOA name: %s, zone primary server: %s\n",
                      pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
         pwzAuthZone = AllocString(pDnsRec->pName);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   if (!g_wzIpAddr)
   {
      wcscpy(g_wzIpAddr, L"unknown");
   }

   if (!pwzAuthZone)
   {
      pwzAuthZone = AllocString(L"zone_unknown");
   }

   //
   // Build up the four prefix strings.
   //
   pwzMsDcs = ConcatonateStrings(g_pwzMSDCS, pwzDnsDomain);

   if (!pwzMsDcs)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzSites = ConcatonateStrings(g_pwzSites, pwzDnsDomain);

   if (!pwzSites)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzTcp = ConcatonateStrings(g_pwzTcp, pwzDnsDomain);

   if (!pwzTcp)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   pwzUdp = ConcatonateStrings(g_pwzUdp, pwzDnsDomain);

   if (!pwzUdp)
   {
      status = ERROR_NOT_ENOUGH_MEMORY;
      goto Cleanup;
   }

   //
   // Query the four prefixes.
   //
   rgDnsRecs = NULL;

   stMsd = DnsQuery_W(pwzMsDcs, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stSit = DnsQuery_W(pwzSites, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stTcp = DnsQuery_W(pwzTcp, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }
   rgDnsRecs = NULL;

   stUdp = DnsQuery_W(pwzUdp, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                      NULL, &rgDnsRecs, NULL);

   if (rgDnsRecs)
   {
      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
   }

   //
   // If all 4 queries report DNS_ERROR_RCODE_NAME_ERROR...
   //
   if (DNS_ERROR_RCODE_NAME_ERROR == stMsd &&
       DNS_ERROR_RCODE_NAME_ERROR == stSit &&
       DNS_ERROR_RCODE_NAME_ERROR == stTcp &&
       DNS_ERROR_RCODE_NAME_ERROR == stUdp)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE0, g_wzIpAddr, pwzAuthZone);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE00);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE1, pwzAuthZone, g_wzIpAddr);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, (_wcsicmp(pwzDnsDomain, pwzAuthZone) == 0) ?
               DCDIAG_NO_DYNAMIC_UPDATE2A : DCDIAG_NO_DYNAMIC_UPDATE2B,
               pwzAuthZone);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE3, pwzMsDcs, pwzSites, pwzTcp, pwzUdp);
      PrintMessage(SEV_ALWAYS, L"\n");
      PrintMsg(SEV_ALWAYS, DCDIAG_NO_DYNAMIC_UPDATE4);
      PrintMessage(SEV_ALWAYS, L"\n");
      goto Cleanup;
   }

   //
   // If all four queries are successfull
   //
   if (NO_ERROR == (stMsd + stSit + stTcp + stUdp))
   {
      stMsd = DnsUpdateTest_W(0, pwzMsDcs, 0, 0);
      stSit = DnsUpdateTest_W(0, pwzSites, 0, 0);
      stTcp = DnsUpdateTest_W(0, pwzTcp, 0, 0);
      stUdp = DnsUpdateTest_W(0, pwzUdp, 0, 0);

      if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp ||
          DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
      {
         PWSTR pwzFailList = NULL;

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI_ALL,
                  pwzMsDcs, pwzSites, pwzTcp, pwzUdp, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzFailList);
      }
      else
      {
         if ((NO_ERROR == stMsd ||
              DNS_ERROR_RCODE_NXRRSET == stMsd ||
              DNS_ERROR_RCODE_YXDOMAIN == stMsd) &&
             (NO_ERROR == stSit ||
              DNS_ERROR_RCODE_NXRRSET == stSit ||
              DNS_ERROR_RCODE_YXDOMAIN == stSit)  &&
             (NO_ERROR == stTcp ||
              DNS_ERROR_RCODE_NXRRSET == stTcp ||
              DNS_ERROR_RCODE_YXDOMAIN == stTcp)  &&
             (NO_ERROR == stUdp ||
              DNS_ERROR_RCODE_NXRRSET == stUdp ||
              DNS_ERROR_RCODE_YXDOMAIN == stUdp))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
         }
      }
      goto Cleanup;
   }

   //
   // If some of the queries returned DNS_ERROR_RCODE_NAME_ERROR
   //
   if (DNS_ERROR_RCODE_NAME_ERROR == stMsd ||
       DNS_ERROR_RCODE_NAME_ERROR == stSit ||
       DNS_ERROR_RCODE_NAME_ERROR == stTcp ||
       DNS_ERROR_RCODE_NAME_ERROR == stUdp)
   {
      PWSTR pwzSuccessList = NULL, pwzFailList = NULL;

      if (NO_ERROR == stMsd)
      {
         if (!BuildList(&pwzSuccessList, pwzMsDcs))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stMsd = DnsUpdateTest_W(0, pwzMsDcs, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stSit)
      {
         if (!BuildList(&pwzSuccessList, pwzSites))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stSit = DnsUpdateTest_W(0, pwzSites, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stTcp)
      {
         if (!BuildList(&pwzSuccessList, pwzTcp))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stTcp = DnsUpdateTest_W(0, pwzTcp, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (NO_ERROR == stUdp)
      {
         if (!BuildList(&pwzSuccessList, pwzUdp))
         {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
         }

         stUdp = DnsUpdateTest_W(0, pwzUdp, 0, 0);

         if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
      }

      if (!pwzSuccessList)
      {
         // Nothing to report.
         //
         goto Cleanup;
      }

      if (pwzFailList)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI1, pwzSuccessList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI2, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_NI3);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzSuccessList);
         LocalFree(pwzFailList);
      }
      else
      {
         if (NO_ERROR != stMsd)
         {
            if (!BuildList(&pwzFailList, pwzMsDcs))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stSit)
         {
            if (!BuildList(&pwzFailList, pwzSites))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stTcp)
         {
            if (!BuildList(&pwzFailList, pwzTcp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }
         if (NO_ERROR != stUdp)
         {
            if (!BuildList(&pwzFailList, pwzUdp))
            {
               status = ERROR_NOT_ENOUGH_MEMORY;
               goto Cleanup;
            }
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK1, pwzSuccessList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK2, pwzFailList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_RCODE_OK3);
         PrintMessage(SEV_ALWAYS, L"\n");
         LocalFree(pwzSuccessList);
         LocalFree(pwzFailList);
      }
   }

Cleanup:
   if (ERROR_NOT_ENOUGH_MEMORY == status)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
   }
   if (pwzMsDcs)
      LocalFree(pwzMsDcs);
   if (pwzSites)
      LocalFree(pwzSites);
   if (pwzTcp)
      LocalFree(pwzTcp);
   if (pwzUdp)
      LocalFree(pwzUdp);
   DnsRecordListFree(rgDomainRecs, DnsFreeRecordListDeep);

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   RCodeSrvFailTest
//
// Synopsis:   
//
//-----------------------------------------------------------------------------
DWORD
RCodeSrvFailTest(PWSTR pwzDnsDomain)
{
   DNS_STATUS status = NO_ERROR;
   PDNS_RECORD rgDnsRecs, pDnsRec;
   IP4_ARRAY ipServer = {0};
   DWORD i;
   BOOL fNSfound = FALSE;
   PWSTR pwzDomainList;

   /* Skip the SOA test as per LevonE's 6/16/00 spec revision
   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_SOA, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_NAME_ERROR:
      case DNS_INFO_NO_RECORDS:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NAME_ERROR, pwzDnsDomain);
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         break;
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   pDnsRec = rgDnsRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));
         ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
         ipServer.AddrCount = 1;
         break;

      case DNS_TYPE_SOA:
         PrintMessage(SEV_DEBUG, L"\nSOA zone name: %s, zone primary server: %s\n",
                      pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

   if (!ipServer.AddrCount)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, NO_ERROR); // Better message maybe?
      PrintMessage(SEV_ALWAYS, L"\n");
      return NO_ERROR;
   }
   */

   status = DnsQuery_W(pwzDnsDomain, DNS_TYPE_NS, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   if (DNS_ERROR_RCODE_NO_ERROR != status)
   {
      switch (status)
      {
      case DNS_ERROR_RCODE_NAME_ERROR:
      case DNS_INFO_NO_RECORDS:
         if (!BuildList(&pwzDomainList, pwzDnsDomain))
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE1, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL2, pwzDnsDomain);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL3);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL4, pwzDomainList);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE5);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_NS_REC_RCODE6);
         PrintMessage(SEV_ALWAYS, L"\n");

         LocalFree(pwzDomainList);
         break;

      default:
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status);
         break;
      }
      PrintMessage(SEV_ALWAYS, L"\n");
      return status;
   }

   ipServer.AddrArray[0] = 0;
   ipServer.AddrCount = 0;

   pDnsRec = rgDnsRecs;

   while (pDnsRec)
   {
      PrintMessage(SEV_DEBUG, L"\nNS query returned record type %d\n", pDnsRec->wType);
      switch (pDnsRec->wType)
      {
      case DNS_TYPE_A:
         PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                      pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));
         ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
         ipServer.AddrCount = 1;
         break;

      case DNS_TYPE_NS:
         fNSfound = TRUE;
         PrintMessage(SEV_DEBUG, L"\nNS name: %s, host: %s\n",
                      pDnsRec->pName, pDnsRec->Data.NS.pNameHost);
         break;

      default:
         break;
      }

      pDnsRec = pDnsRec->pNext;
   }

   DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

   i = 0;

   if (fNSfound && !g_fDNSserver)
   {
      while (g_rgIpAddr[i])
      {
         if (ipServer.AddrArray[0] == g_rgIpAddr[i])
         {
            // if the DNS server is not locally installed, print success.
            //
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
            return NO_ERROR;
         }
         i++;
      }
   }

   if (!BuildList(&pwzDomainList, pwzDnsDomain))
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV1, pwzDnsDomain);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV2, pwzDnsDomain);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV3);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV4, pwzDomainList);
   PrintMessage(SEV_ALWAYS, L"\n");
   PrintMsg(SEV_ALWAYS, DCDIAG_ERR_RCODE_SRV5);
   PrintMessage(SEV_ALWAYS, L"\n");

   LocalFree(pwzDomainList);

   return NO_ERROR;
}

//+----------------------------------------------------------------------------
//
// Function:   ARecordRegisterCheck
//
// Synopsis:   Verify that the server will be able to register A record for
//             its computer name after successful promotion to a DC. (step 6)
//
//-----------------------------------------------------------------------------
DWORD
ARecordRegisterCheck(PWSTR pwzComputerLabel, PWSTR pwzComputerDnsSuffix,
                     PWSTR pwzDnsDomain)
{
   DNS_STATUS status = NO_ERROR, status2;
   PDNS_RECORD rgDnsRecs, pDnsRec, pDnsRec1;
   PWSTR pwzTmp, pwzFullComputerName, pwzAuthZone = NULL, pwzDomainList;
   IP4_ARRAY ipServer = {0};
   BOOL fMatched = FALSE;

   pwzTmp = ConcatonateStrings(pwzComputerLabel, L".");

   if (!pwzTmp)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   pwzFullComputerName = ConcatonateStrings(pwzTmp, pwzComputerDnsSuffix);

   if (!pwzFullComputerName)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      LocalFree(pwzTmp);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   LocalFree(pwzTmp);

   //
   // Verify that the zone(s) authoritative for the records to be registered
   // can be discovered and that it can be dynamically updated.
   //

   status = DnsUpdateTest_W(0, pwzFullComputerName, 0, 0);

   switch (status)
   {
   case NO_ERROR:
   case DNS_ERROR_RCODE_NXRRSET:
   case DNS_ERROR_RCODE_YXDOMAIN:
      PrintMsg(SEV_ALWAYS, DCDIAG_A_RECORD_OK);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;

   case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
   case DNS_ERROR_RCODE_SERVER_FAILURE:

      status2 = DnsQuery_W(pwzFullComputerName, DNS_TYPE_SOA,
                           DNS_QUERY_BYPASS_CACHE, NULL, &rgDnsRecs, NULL);

      if (DNS_ERROR_RCODE_NO_ERROR != status2)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, status2);
         PrintMessage(SEV_ALWAYS, L"\n");
         return status2;
      }

      g_wzIpAddr[0] = L'\0';

      pDnsRec = rgDnsRecs;

      while (pDnsRec)
      {
         PrintMessage(SEV_DEBUG, L"\nSOA query returned record type %d\n", pDnsRec->wType);
         switch (pDnsRec->wType)
         {
         case DNS_TYPE_A:
            PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                         pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

            wsprintf(g_wzIpAddr, L"%d.%d.%d.%d", IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

            ipServer.AddrArray[0] = pDnsRec->Data.A.IpAddress;
            ipServer.AddrCount = 1;

            break;

         case DNS_TYPE_SOA:
            PrintMessage(SEV_DEBUG, L"\nSOA zone name: %s, zone primary server: %s\n",
                         pDnsRec->pName, pDnsRec->Data.SOA.pNamePrimaryServer);
            pwzAuthZone = AllocString(pDnsRec->pName);
            break;

         default:
            break;
         }

         pDnsRec = pDnsRec->pNext;
      }

      DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);

      if (!g_wzIpAddr)
      {
         wcscpy(g_wzIpAddr, L"unknown");
      }

      if (!pwzAuthZone)
      {
         pwzAuthZone = AllocString(L"zone_unknown");
      }

      if (DNS_ERROR_RCODE_NOT_IMPLEMENTED == status)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI1, g_wzIpAddr, pwzAuthZone);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI2);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI3, pwzAuthZone, g_wzIpAddr);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI4, pwzAuthZone);
         PrintMessage(SEV_ALWAYS, L"\n");
         PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_NI5);
         PrintMessage(SEV_ALWAYS, L"\n");
      }
      else // DNS_ERROR_RCODE_SERVER_FAILURE
      {
         if (pwzComputerDnsSuffix == pwzDnsDomain && !g_fDNSserver)
         {
            if (!ipServer.AddrCount)
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_ERR_UNKNOWN, NO_ERROR); // Better message maybe?
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               PrintMessage(SEV_ALWAYS, L"\n");
               return NO_ERROR;
            }

            status2 = DnsQuery_W(pwzDnsDomain, DNS_TYPE_NS,
                                 DNS_QUERY_NO_RECURSION | DNS_QUERY_BYPASS_CACHE,
                                 &ipServer, &rgDnsRecs, NULL);

            if (NO_ERROR != status2)
            {
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               return NO_ERROR;
            }

            // See if at least one of the A record computer names matches the
            // local computer's name.
            //

            pDnsRec = rgDnsRecs;

            while (pDnsRec)
            {
               PrintMessage(SEV_DEBUG, L"\nNS query returned record type %d\n", pDnsRec->wType);
               if (DNS_TYPE_A == pDnsRec->wType)
               {
                  PrintMessage(SEV_DEBUG, L"\nA record, name: %s, IP address:  %d.%d.%d.%d\n",
                               pDnsRec->pName, IP_STRING_FMT_ARGS(pDnsRec->Data.A.IpAddress));

                  if (_wcsicmp(pDnsRec->pName, pwzFullComputerName) == 0)
                  {
                     fMatched = TRUE;
                     break;
                  }
               }

               pDnsRec = pDnsRec->pNext;
            }

            DnsRecordListFree(rgDnsRecs, DnsFreeRecordListDeep);
         }

         if (fMatched)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_LOCATOR_UPDATE_OK);
            PrintMessage(SEV_ALWAYS, L"\n");
         }
         else
         {
            if (!BuildList(&pwzDomainList, pwzFullComputerName))
            {
               PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
               LocalFree(pwzFullComputerName);
               LocalFree(pwzAuthZone);
               return ERROR_NOT_ENOUGH_MEMORY;
            }

            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL1, pwzFullComputerName);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL2, pwzFullComputerName);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL3);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL4, pwzDomainList);
            PrintMessage(SEV_ALWAYS, L"\n");
            PrintMsg(SEV_ALWAYS, DCDIAG_ERR_A_REC_RCODE_SRV_FAIL5);
            PrintMessage(SEV_ALWAYS, L"\n");

            LocalFree(pwzDomainList);
         }
      }

      LocalFree(pwzAuthZone);
      break;

   default:
      PrintMsg(SEV_ALWAYS, DCDIAG_ERR_DNS_UPDATE_PARAM, status);
      PrintMessage(SEV_ALWAYS, L"\n");
      status = NO_ERROR;
      break;
   }

   LocalFree(pwzFullComputerName);

   return status;
}

//+----------------------------------------------------------------------------
//
// Function:   GetMachineInfo
//
// Synopsis:   Get info on the target (local) machine such as IP address,
//             servers status, etc.
//
//-----------------------------------------------------------------------------
void
GetMachineInfo(void)
{
   PDSROLE_UPGRADE_STATUS_INFO pUpgradeInfo = NULL;
   PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBasicInfo = NULL;
   PMIB_IPADDRTABLE pAddrTable = NULL;
   DWORD dwErr, dwSize = 0, i, j = 0;
   SC_HANDLE hSC, hDNSsvc;
   SERVICE_STATUS SvcStatus;

   // What is the machine's IP address(s)
   //

   dwErr = GetIpAddrTable(NULL, &dwSize, FALSE);

   if (ERROR_INSUFFICIENT_BUFFER != dwErr)
   {
      PrintMessage(SEV_ALWAYS, L"Reading the size of the adapter address data failed with error %d\n", dwErr);
      return;
   }

   pAddrTable = LocalAlloc(LMEM_FIXED, dwSize);

   if (!pAddrTable)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return;
   }

   dwErr = GetIpAddrTable(pAddrTable, &dwSize, FALSE);

   if (NO_ERROR != dwErr)
   {
      PrintMessage(SEV_ALWAYS, L"Reading the adapter addresses failed with error %d\n", dwErr);
      LocalFree(pAddrTable);
      return;
   }

   for (i = 0; i < pAddrTable->dwNumEntries; i++)
   {
      if (pAddrTable->table[i].dwAddr && DCDIAG_LOOPBACK_ADDR != pAddrTable->table[i].dwAddr)
      {
         g_rgIpAddr[j] = pAddrTable->table[i].dwAddr;
         PrintMessage(SEV_DEBUG, L"\nServer IP address: %d.%d.%d.%d (0x%08x)\n",
                      IP_STRING_FMT_ARGS(g_rgIpAddr[j]), g_rgIpAddr[j]);
         j++;
         if (DCDIAG_MAX_ADDR <= j)
         {
            break;
         }
      }
   }
   LocalFree(pAddrTable);

   // Is this machine upgraded from an NT4 DC but DCPromo has not yet run?
   //

   DsRoleGetPrimaryDomainInformation(NULL, // server name, change if remoting implemented.
                                     DsRoleUpgradeStatus,
                                     (PBYTE *)&pUpgradeInfo);

   if (pUpgradeInfo)
   {
      if (DSROLE_UPGRADE_IN_PROGRESS == pUpgradeInfo->OperationState)
      {
         g_fUpgradedNT4DC = TRUE;
      }
      DsRoleFreeMemory(pUpgradeInfo);
   }

   // Is this machine a domain controller?
   //

   DsRoleGetPrimaryDomainInformation(NULL, // server name, change if remoting implemented.
                                     DsRolePrimaryDomainInfoBasic,
                                     (PBYTE *)&pBasicInfo);

   if (pBasicInfo)
   {
      if (DsRole_RoleBackupDomainController == pBasicInfo->MachineRole ||
          DsRole_RolePrimaryDomainController == pBasicInfo->MachineRole)
      {
         g_fDC = TRUE;
      }
      DsRoleFreeMemory(pBasicInfo);
   }

   //
   // Is this machine running the DNS server?
   //
   hSC = OpenSCManager(NULL,  // local machine
                       NULL,
                       SC_MANAGER_CONNECT | GENERIC_READ);
   if (!hSC)
   {
      PrintMessage(SEV_ALWAYS, L"Opening the service controller failed with error %d\n", GetLastError());
      return;
   }

   hDNSsvc = OpenService(hSC, L"dns", SERVICE_INTERROGATE);

   CloseServiceHandle(hSC);

   if (hDNSsvc)
   {
      if (ControlService(hDNSsvc, SERVICE_CONTROL_INTERROGATE, &SvcStatus))
      {
         // If we have gotten this far, the service is installed. It doesn't have
         // to be running to set the flag to true.
         //
         g_fDNSserver = TRUE;
      }
      CloseServiceHandle(hDNSsvc);
   }

   return;
}

//+----------------------------------------------------------------------------
//
// Function:   GetComputerDnsSuffix
//
// Synopsis:   Gets the computer DNS domain suffix.
//
//-----------------------------------------------------------------------------
DWORD
GetComputerDnsSuffix(PWSTR * ppwzComputerDnsDomain, PWSTR pwzDnsDomain)
{
   HKEY hKey;
   LONG lRet;
   DWORD dwType, dwSize, dwSync = 0;
   PWSTR pwzComputerDnsSuffix;
   PWSTR pwzSyncDomain = L"SyncDomainWithMembership";
   PWSTR pwzNVDomain = L"NV Domain";
   PWSTR pwzNVSuffix = L"NV PrimaryDnsSuffix";
   PWSTR pwzDnsPolicy = L"Software\\Policies\\Microsoft\\System\\DNSclient";

#if WINVER > 0x0500

   // Additional preliminary step to calculate the primary DNS suffix of the
   // DC for Whistler (the difference is that contrary to W2K's behavior DCs
   // can be renamed in Whistler)
   //

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pwzDnsPolicy, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet &&
       ERROR_FILE_NOT_FOUND != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   if (NO_ERROR == lRet)
   {
      dwSize = 0;

      lRet = RegQueryValueEx(hKey, pwzNVSuffix, 0, &dwType, NULL, &dwSize);

      if (ERROR_SUCCESS == lRet)
      {

         pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

         if (!pwzComputerDnsSuffix)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
            RegCloseKey(hKey);
            return ERROR_NOT_ENOUGH_MEMORY;
         }

         lRet = RegQueryValueEx(hKey, pwzNVDomain, 0, &dwType, (PBYTE)pwzComputerDnsSuffix, &dwSize);

         RegCloseKey(hKey);

         if (ERROR_SUCCESS != lRet)
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
            return lRet;
         }

         *ppwzComputerDnsDomain = pwzComputerDnsSuffix;

         return NO_ERROR;
      }
   }

#endif // Whistler-only step

   // Common steps for Whistler and for QFE.
   //

   lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, g_pwzTcpIpParams, 0, KEY_READ, &hKey);

   if (ERROR_SUCCESS != lRet)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_KEY_OPEN_FAILED, lRet);
      return lRet;
   }

   dwSize = sizeof(dwSync);

   lRet = RegQueryValueEx(hKey, pwzSyncDomain, 0, &dwType, (PBYTE)&dwSync, &dwSize);

   if (ERROR_SUCCESS != lRet)
   {
      if (ERROR_FILE_NOT_FOUND == lRet)
      {
         dwSync = 1;
      }
      else
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         RegCloseKey(hKey);
         return lRet;
      }
   }

   if (0 != dwSync)
   {
      // Use the DNS domain name specified on the command line.
      //
      pwzComputerDnsSuffix = pwzDnsDomain;
   }
   else
   {
      dwSize = 0;

      lRet = RegQueryValueEx(hKey, pwzNVDomain, 0, &dwType, NULL, &dwSize);

      if (ERROR_SUCCESS != lRet)
      {
         RegCloseKey(hKey);

         if (ERROR_FILE_NOT_FOUND == lRet)
         {
            // Use the DNS domain name specified on the command line.
            //
            pwzComputerDnsSuffix = pwzDnsDomain;
            goto Done;
         }
         else
         {
            PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
            return lRet;
         }
      }

      pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

      if (!pwzComputerDnsSuffix)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
         RegCloseKey(hKey);
         return ERROR_NOT_ENOUGH_MEMORY;
      }

      // Use the NV Domain value.
      //
      lRet = RegQueryValueEx(hKey, pwzNVDomain, 0, &dwType, (PBYTE)pwzComputerDnsSuffix, &dwSize);

      RegCloseKey(hKey);

      if (ERROR_SUCCESS != lRet)
      {
         PrintMsg(SEV_ALWAYS, DCDIAG_KEY_READ_FAILED, lRet);
         return lRet;
      }

      *ppwzComputerDnsDomain = pwzComputerDnsSuffix;

      return NO_ERROR;
   }

Done:

   *ppwzComputerDnsDomain = AllocString(pwzComputerDnsSuffix);

   if (!*ppwzComputerDnsDomain)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   return NO_ERROR;

/*
   GetComputerNameEx(ComputerNameDnsDomain, NULL, &dwSize);

   if (!dwSize)
   {
      return GetLastError();
   }

   pwzComputerDnsSuffix = LocalAlloc(LMEM_FIXED, ++dwSize * sizeof(WCHAR));

   if (!pwzComputerDnsSuffix)
   {
      PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   if (!GetComputerNameEx(ComputerNameDnsDomain, pwzComputerDnsSuffix, &dwSize))
   {
      dwRet = GetLastError();
      PrintMsg(SEV_ALWAYS, DCDIAG_GATHERINFO_CANT_GET_LOCAL_COMPUTERNAME,
               Win32ErrToString(dwRet));
      LocalFree(pwzComputerDnsSuffix);
      return dwRet;
   }
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\repair.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    repair.c

ABSTRACT:

    Contains routines to help recover from a deleted machine account.
    
DETAILS:

                       
CREATED:

    24 October 1999  Colin Brace (ColinBr)

REVISION HISTORY:
        

--*/

#define REPL_SPN_PREFIX  L"E3514235-4B06-11D1-AB04-00C04FC2DCD2"

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmsname.h>

#include <dsconfig.h>  // Definition of mask for visible containers

#include <lmcons.h>    // CNLEN
#include <lsarpc.h>    // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>


#include "dcdiag.h"
#include "dstest.h"


/*

Theory of Operation for Deleted Domain Controller Machine Account Recovery
==========================================================================


The scenario that this code address is specifically the following:

1) DCPROMO is run to install a replica domain controller
2) during the non-critical portion, the deletion of the machine account
   replicates in
3) on startup, the system will start but will not function properly
4) in this case, this recovery code should be run to recreate the DC's 
   machine account.
   
There are a couple of issues that makes this a non trivial task

1) because of how win2k replication works, the security context of a replication
is always the machine itself (ie the security context of the RPC calls to 
perform repliation is the DC's machine account).                                                   
2) because of how kerberos works, if a DC wishes to perform an authenticated RPC
to another machine, the local KDC _must_ have both machine accounts locally in
order to construct the tickets necessary to perform an authentication.

As such, simply creating the machine account on the broken DC does not work 
since no other DC will be able to replicate it off.  Simply creating the 
machine account on other DC doesn't work since the local DC won't be able
to replicate it in.  However, not all is lost.  The trick is to create the
machine account on another DC, *turn off the KDC on the local machine*, and then
replicate in our machine account.

Here are the specifics steps this code does to recover from a deleted DC
machine account:

1) find a DC in our domain to help us (see function for specifics)
2) create a machine account for us with a replication SPN and a known password
3) set the local $MACHINE.ACC password
4) stop the KDC
5) force a replication from our helper DC to us
   

Caveats:

For the steady state case, restoring the machine account (and children) from 
backup is by far the best option.

If this option is not available, the above code will work, but will not 
reconstruct service state that was stored under the machine account object (
for example, FRS objects).  In this case, repairing the account and then
demoting and repromoting is probably the best thing to do.

*/


typedef struct _REPAIR_DC_ACCOUNT_INFO
{
    BOOL fRestartKDC;

    LPWSTR SamAccountName;
    LPWSTR DomainDnsName;
    LPWSTR AccountDn;
    LPWSTR DomainDn;
    LPWSTR Password;
    LPWSTR ReplSpn;
    LPWSTR LocalServerDn;
    LPWSTR RemoteDc;
    ULONG  RemoteDcIndex;

} REPAIR_DC_ACCOUNT_INFO, *PREPAIR_DC_ACCOUNT_INFO;

VOID
InitRepairDcAccountInfo(
    IN PREPAIR_DC_ACCOUNT_INFO pInfo
    )
{
    RtlZeroMemory( pInfo, sizeof(REPAIR_DC_ACCOUNT_INFO));
    pInfo->RemoteDcIndex = NO_SERVER;
}

DWORD
RepairStartService(
    LPWSTR ServiceName
    );

DWORD
RepairStopService(
    LPWSTR ServiceName
    );

VOID
ReleaseRepairDcAccountInfo(
    IN PREPAIR_DC_ACCOUNT_INFO pInfo
    )
//
// Release and undo state recorded by a REPAIR_DC_ACCOUNT_INFO
//
{
    if ( pInfo ) {

        if ( pInfo->fRestartKDC) {

            RepairStartService( SERVICE_KDC );

        }

        if ( pInfo->SamAccountName ) LocalFree( pInfo->SamAccountName );
        if ( pInfo->DomainDnsName ) LocalFree( pInfo->DomainDnsName );
        if ( pInfo->AccountDn ) LocalFree( pInfo->AccountDn );
        if ( pInfo->DomainDn ) LocalFree( pInfo->DomainDn );
        if ( pInfo->Password ) LocalFree( pInfo->Password );
        if ( pInfo->ReplSpn ) free( pInfo->ReplSpn );
        if ( pInfo->LocalServerDn ) LocalFree( pInfo->LocalServerDn );
        if ( pInfo->RemoteDc ) LocalFree( pInfo->RemoteDc );
        
    }
}


DWORD
RepairGetLocalDCInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairGetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairSetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairSetLocalDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );

DWORD
RepairReplicateInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    );


DWORD
GetOperationalAttribute(
    IN LDAP *hLdap,
    IN LPWSTR OpAtt,
    OUT LPWSTR *OpAttValue
    );

// Forward from elsewhere ...
DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength,
               WCHAR   **ppszSpn);

DWORD
RepairDCWithoutMachineAccount(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    This routine attempts to recover a DC whose machine account has
    been deleted.  See Theory of Operation above for details.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    ERROR_SUCCESS if DC has been recovered.
    otherwise a a failure approxiamating the last error hit.

--*/

{
    DWORD WinError = ERROR_SUCCESS;
    REPAIR_DC_ACCOUNT_INFO RepairInfo;
    WCHAR ComputerName[MAX_COMPUTERNAME_LENGTH+1];
    ULONG Length = sizeof(ComputerName)/sizeof(ComputerName[0]);
    BOOL fLocalMachineMissingAccount = FALSE;


    //
    // Init
    //
    InitRepairDcAccountInfo( &RepairInfo );

    //
    // This only works when the tool is run from the DC that needs repairing
    //
    if ( GetComputerName( ComputerName, &Length ) ) {

        if ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,
                                         DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                         ComputerName,
                                         Length,
                                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                                         wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName) ))) {

            fLocalMachineMissingAccount = TRUE;
        }
    }

    if ( !fLocalMachineMissingAccount ) {
        //
        // We need to be running on the machine with the problem
        //
        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_RUN_LOCAL,
                 ComputerName );

        WinError = ERROR_CALL_NOT_IMPLEMENTED;

        goto Exit;

    }

    //
    // Get some local information
    //
    WinError = RepairGetLocalDCInfo( pDsInfo,
                                     ulCurrTargetServer,
                                     gpCreds,
                                     &RepairInfo );

    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Find a DC to help us
    //
    WinError = RepairGetRemoteDcInfo ( pDsInfo,
                                       ulCurrTargetServer,
                                       gpCreds,
                                       &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Set the remote info  (create the machine, etc ...)
    //
    WinError = RepairSetRemoteDcInfo ( pDsInfo,
                                       ulCurrTargetServer,
                                       gpCreds,
                                       &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Set the local info (the local secret, etc ...)
    //
    WinError = RepairSetLocalDcInfo ( pDsInfo,
                                      ulCurrTargetServer,
                                      gpCreds,
                                      &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // Attempt to bring over the information
    //
    WinError = RepairReplicateInfo ( pDsInfo,
                                     ulCurrTargetServer,
                                     gpCreds,
                                     &RepairInfo );
    if ( ERROR_SUCCESS != WinError ) {

        goto Exit;
        
    }

    //
    // That's it
    //

Exit:

    if ( ERROR_SUCCESS == WinError ) {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_SUCCESS );

    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_ERROR,
                 Win32ErrToString(WinError) );

    }

    ReleaseRepairDcAccountInfo( &RepairInfo );

    return WinError;

}


DWORD
RepairGetLocalDCInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

    This purpose of this routine is to fill in the following fields
    
    LPWSTR DomainDnsName;
    GUID   DomainGuid;
    LPWSTR LocalServerDn;
    LPWSTR LocalNtdsSettingsDn;

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES oa;
    LSA_HANDLE hLsa = 0;
    LDAP * hLdap;
    LPWSTR UuidString = NULL;
    WCHAR RDN[MAX_COMPUTERNAME_LENGTH+1];
    ULONG size;
    PPOLICY_DNS_DOMAIN_INFO DnsInfo = NULL;
    WCHAR *pc;

    //
    // Construct our SAM account name
    //
    size = (wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName)+2) * sizeof(WCHAR);
    pInfo->SamAccountName = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->SamAccountName ) {

        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
        
    }
    wcscpy( pInfo->SamAccountName, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &pInfo->SamAccountName[0];
    while ( *pc != L'\0' ) {
        towupper( *pc );
        pc++;
    }
    wcscat( pInfo->SamAccountName, L"$");

    //
    // Construct our password
    //
    size = (wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName)+2) * sizeof(WCHAR);
    pInfo->Password = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->Password ) {

        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
        
    }
    wcscpy( pInfo->Password, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &pInfo->SamAccountName[0];
    while ( *pc != L'\0' ) {
        towlower( *pc );
        pc++;
    }


    //
    // Construct our REPL SPN
    //
    RtlZeroMemory( &oa, sizeof(oa) );
    Status = LsaOpenPolicy( NULL,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hLsa );
    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( hLsa,
                                            PolicyDnsDomainInformation,
                                            (PVOID) &DnsInfo);
        
    }

    if ( !NT_SUCCESS( Status ) ) {
        WinError = RtlNtStatusToDosError( Status );
        goto Exit;
    }

    size = DnsInfo->DnsDomainName.Length + sizeof(WCHAR);
    pInfo->DomainDnsName = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->DomainDnsName ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    RtlCopyMemory( pInfo->DomainDnsName, 
                   DnsInfo->DnsDomainName.Buffer, 
                   DnsInfo->DnsDomainName.Length );

    //
    // Setup the service principal name
    //
    UuidToStringW( &pDsInfo->pServers[ulCurrTargetServer].uuid, &UuidString );

    size = 0;
    WinError = WrappedMakeSpnW(REPL_SPN_PREFIX,
                               pInfo->DomainDnsName,
                               UuidString,
                               0,
                               NULL,
                               &size,
                               &pInfo->ReplSpn );

    RpcStringFreeW(&UuidString);

    if ( WinError != ERROR_SUCCESS ) {
        goto Exit;
    }


    //
    // Get our ServerDn
    //
    WinError = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                    gpCreds,
                                    FALSE,
                                    &hLdap);

    if ( ERROR_SUCCESS == WinError ) {
        
        WinError = GetOperationalAttribute( hLdap,
                                            LDAP_OPATT_SERVER_NAME_W,
                                            &pInfo->LocalServerDn );

        if ( ERROR_SUCCESS == WinError ) {

            WinError = GetOperationalAttribute( hLdap,
                                                LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W,
                                                &pInfo->DomainDn );
            
        }
    }

    if ( WinError != ERROR_SUCCESS ) {
        goto Exit;
    }

    //
    // Construct what our new machine account DN will be
    //
    wcscpy( RDN, pDsInfo->pServers[ulCurrTargetServer].pszName );
    pc = &(RDN[0]);
    while ( *pc != L'\0' ) {
        towupper( *pc );
        pc++;
    }

    size =  (wcslen( L"CN=,OU=Domain Controllers,")
          + wcslen( pInfo->DomainDn )
          + wcslen( RDN )
          + 1) * sizeof(WCHAR);

    pInfo->AccountDn = LocalAlloc( LMEM_ZEROINIT, size );
    if ( !pInfo->AccountDn ) {
        WinError = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }
    wsprintf(pInfo->AccountDn, L"CN=%s,OU=Domain Controllers,%s",RDN, pInfo->DomainDn);



Exit:

    if ( DnsInfo ) {
        LsaFreeMemory( DnsInfo );
    }

    if ( hLsa ) {
        LsaClose( hLsa );
    }

    return WinError;
}


DWORD
RepairGetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

    The purpose of this routine is to find a DC to help us recover from our
    lost machine account.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;

    //
    // N.B.  Review algorithm below before changing default values
    //
    ULONG Flags =   (DS_DIRECTORY_SERVICE_REQUIRED | 
                     DS_AVOID_SELF |
                     DS_RETURN_DNS_NAME);
      

    ASSERT( NO_SERVER == pInfo->RemoteDcIndex );

    while (   (WinError == ERROR_SUCCESS)
           && (NO_SERVER == pInfo->RemoteDcIndex) ) {

        WinError = DsGetDcName( NULL,
                                NULL,
                                NULL,
                                NULL,
                                Flags,
                                &DcInfo  );
    
        if ( (WinError == ERROR_NO_SUCH_DOMAIN)
          && ((Flags & DS_FORCE_REDISCOVERY) == 0) ) {

              //
              // Retry harder
              //
              WinError = ERROR_SUCCESS;
              Flags |= DS_FORCE_REDISCOVERY;
              continue;
        }

        // Make sure to turn this flag off
        Flags |= ~DS_FORCE_REDISCOVERY;

        if ( ERROR_SUCCESS == WinError ) {

            pInfo->RemoteDc = LocalAlloc( LMEM_ZEROINIT, (wcslen( DcInfo->DomainControllerName )+1) * sizeof(WCHAR) );
            if ( !pInfo->RemoteDc ) {
                WinError = ERROR_NOT_ENOUGH_MEMORY;
                goto Exit;
            }
    
            if ( *DcInfo->DomainControllerName == L'\\' ) {
                wcscpy( pInfo->RemoteDc, DcInfo->DomainControllerName+2 );
            } else {
                wcscpy( pInfo->RemoteDc, DcInfo->DomainControllerName );
            }
    
            NetApiBufferFree(DcInfo);
    
            //
            // Now, find the server in the index
            //
            pInfo->RemoteDcIndex = DcDiagGetServerNum( pDsInfo,
                                                       ((Flags & DS_RETURN_FLAT_NAME) ? pInfo->RemoteDc : NULL),
                                                       NULL,
                                                       NULL,
                                                       ((Flags & DS_RETURN_DNS_NAME) ? pInfo->RemoteDc : NULL),
                                                       NULL
						       );
    
            if ( (NO_SERVER == pInfo->RemoteDcIndex)
              && ((Flags & DS_RETURN_FLAT_NAME) == 0)  ) {
    
                //
                // Couldn't find it?  DNS names can be finicky; try netbios
                //
                LocalFree( pInfo->RemoteDc );
                Flags |= ~DS_RETURN_DNS_NAME;
                Flags |= DS_RETURN_FLAT_NAME;

                continue;

            } else {

                // Can't match by flat or dns name; set an error so we bail out
                WinError = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
            }
        }
    }

    if ( NO_SERVER == pInfo->RemoteDcIndex ) {

        WinError = ERROR_DOMAIN_CONTROLLER_NOT_FOUND;

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_FIND_DC_ERROR);
        
    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_FIND_DC,
                 pInfo->RemoteDc );
        
        WinError = ERROR_SUCCESS;
    }

Exit:

    return WinError;
}

DWORD
RepairSetRemoteDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{

    DWORD WinError  = ERROR_SUCCESS;
    ULONG LdapError = LDAP_SUCCESS;

    //
    // The add values
    //
    LPWSTR ObjectClassValues[] = {0, 0};
    LDAPModW ClassMod = {LDAP_MOD_ADD, L"objectclass", ObjectClassValues};

    LPWSTR UserAccountControlValues[] = {0, 0};
    LDAPModW UserAccountControlMod = {LDAP_MOD_ADD, L"useraccountcontrol", UserAccountControlValues};

    LPWSTR ServicePrincipalNameValues[] = {0, 0};
    LDAPModW ServicePrincipalNameMod = {LDAP_MOD_ADD, L"serviceprincipalname", ServicePrincipalNameValues};

    LPWSTR SamAccountNameValues[] = {0, 0};
    LDAPModW SamAccountNameMod = {LDAP_MOD_ADD, L"samaccountname", SamAccountNameValues};

    LDAPModW *Attrs[] =
    {
        &ClassMod,
        &UserAccountControlMod,
        &ServicePrincipalNameMod, 
        &SamAccountNameMod, 
        0
    };

    WCHAR    Buffer[11];  // enough to hold a string representing a 32 bit number
    ULONG    UserAccountControl = UF_SERVER_TRUST_ACCOUNT | UF_TRUSTED_FOR_DELEGATION;


    //
    // The modify values
    //
    LPWSTR ServerReferenceValues[] = {0, 0};
    LDAPModW ServerReferenceMod = {LDAP_MOD_ADD, L"serverReference", ServerReferenceValues};

    LDAPModW *ModAttrs[] =
    {
        &ServerReferenceMod,
        0
    };

    LDAP *hLdap = NULL;

    //
    // Setup the object class
    //
    ObjectClassValues[0] = L"computer";

    //
    // Setup the useraccountcontrol
    //
    RtlZeroMemory(Buffer, sizeof(Buffer));
    _ltow( UserAccountControl, Buffer, 10 );
    UserAccountControlValues[0] = Buffer;


    //
    // Setup the serviceprincipalname
    //
    ServicePrincipalNameValues[0] = pInfo->ReplSpn;

    //
    // Setup the samaccountname
    //
    SamAccountNameValues[0] = pInfo->SamAccountName;


    WinError = DcDiagGetLdapBinding(&pDsInfo->pServers[pInfo->RemoteDcIndex],
                                    gpCreds,
                                    FALSE,
                                    &hLdap);

    if ( WinError != ERROR_SUCCESS ) {

        goto Exit;
        
    }


    LdapError = ldap_add_sW( hLdap,
                             pInfo->AccountDn,
                             Attrs );

    WinError = LdapMapErrorToWin32( LdapError );

    if ( ERROR_ACCESS_DENIED == WinError ) {

        //
        // For various reasons, the UF_TRUSTED_FOR_DELEGATION field may cause 
        // an access denied if policy has not been properly set on the machine
        //

        UserAccountControl &= ~UF_TRUSTED_FOR_DELEGATION;
        _ltow( UserAccountControl, Buffer, 10 );

        LdapError = ldap_add_sW( hLdap,
                                 pInfo->AccountDn,
                                 Attrs );
    
        WinError = LdapMapErrorToWin32( LdapError );

    }

    if ( LdapError == LDAP_ALREADY_EXISTS ) {

        //
        // The object is there ... assume it is good
        //
        WinError = ERROR_SUCCESS;

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_ALREADY_EXISTS,
                 pInfo->AccountDn,
                 pInfo->RemoteDc );
        
    } else {

        if ( ERROR_SUCCESS == WinError ) {
    
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CREATED_MA_SUCCESS,
                     pInfo->AccountDn,
                     pInfo->RemoteDc );
            
        } else {
    
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CREATED_MA_ERROR,
                     pInfo->AccountDn,
                     pInfo->RemoteDc,
                     Win32ErrToString(WinError) );
    
        }

    }

    //
    // Now set the password	
    //
    if ( ERROR_SUCCESS == WinError ) {

        PUSER_INFO_3 Info = NULL;
        DWORD       ParmErr;

        WinError = NetUserGetInfo( pInfo->RemoteDc,
                                   pInfo->SamAccountName,
                                   3,
                                   (PBYTE*) &Info);

        if ( ERROR_SUCCESS == WinError ) {

            Info->usri3_password = pInfo->Password;

            WinError = NetUserSetInfo( pInfo->RemoteDc,
                                       pInfo->SamAccountName,
                                       3,
                                       (PVOID) Info,
                                       &ParmErr );

            NetApiBufferFree( Info );
            
        }

        if ( ERROR_SUCCESS != WinError ) {

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_CANNOT_SET_PASSWORD,
                     pInfo->AccountDn,
                     pInfo->RemoteDc,
                     Win32ErrToString(WinError) );

            WinError = ERROR_SUCCESS;
            
        }
                                         
    }


    if ( ERROR_SUCCESS == WinError ) {

        //
        // Now set the server backlink
        //
        ServerReferenceValues[0] = pInfo->AccountDn;
        LdapError = ldap_modify_sW( hLdap,
                                    pInfo->LocalServerDn,
                                    ModAttrs );
    
    
        if ( LDAP_ATTRIBUTE_OR_VALUE_EXISTS == LdapError ) {

            // The value already exists; replace the value then
            ServerReferenceMod.mod_op = LDAP_MOD_REPLACE;
    
            LdapError = ldap_modify_sW( hLdap,
                                        pInfo->LocalServerDn,
                                        ModAttrs );

    
        }

        //
        // Ignore this LDAP value -- is is not critical
        //
        
    }

    
Exit:

    return WinError;
}


DWORD
RepairSetLocalDcInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{          
    DWORD WinError = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE hLsa = NULL;
    LSA_HANDLE hSecret = NULL;
    UNICODE_STRING NewPassword;
    UNICODE_STRING SecretName;
    OBJECT_ATTRIBUTES oa;

    RtlInitUnicodeString( &SecretName, L"$MACHINE.ACC" );
    RtlInitUnicodeString( &NewPassword, pInfo->Password );
    RtlZeroMemory( &oa, sizeof(oa) );

    Status = LsaOpenPolicy( NULL,
                           &oa,
                           POLICY_CREATE_SECRET,
                           &hLsa );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaOpenSecret( hLsa,
                                &SecretName,
                                SECRET_WRITE,
                                &hSecret );

        if ( NT_SUCCESS( Status ) ) {
            
            Status = LsaSetSecret( hSecret,
                                   &NewPassword,
                                   NULL );

            LsaClose( hSecret );
        
        }

        LsaClose( hLsa );
    }

    if ( NT_SUCCESS( Status ) ) {

        WinError = RepairStopService( SERVICE_KDC );
        if ( WinError == ERROR_SUCCESS ) {
    
            pInfo->fRestartKDC = TRUE;

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_STOP_KDC_SUCCESS );
    
        } else {

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_DCMA_REPAIR_STOP_KDC_ERROR,
                     Win32ErrToString(WinError) );

        }
        
    } else {

        WinError = RtlNtStatusToDosError( Status );
    }

    return WinError;
}


DWORD
RepairReplicateInfo(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN OUT PREPAIR_DC_ACCOUNT_INFO pInfo
    )
/*++

Routine Description:

        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    
    gpCreds - The command line credentials if any that were passed in.
    
    pInfo - the repair DC account state

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    HANDLE hDs;
    ULONG Options = 0;

    WinError = DcDiagGetDsBinding( &pDsInfo->pServers[ulCurrTargetServer],
                                   gpCreds,
                                   &hDs );

    if ( ERROR_SUCCESS == WinError ) {
        
        WinError = DsReplicaSync( hDs,
                                  pInfo->DomainDn,
                                  &pDsInfo->pServers[pInfo->RemoteDcIndex].uuid,
                                  Options );
    
        if ( ERROR_DS_DRA_NO_REPLICA == WinError )
        {
            //
            // Ok, we have to add this replica
            //
    
            // Schedule doesn't matter since this replica is going away
            ULONG     AddOptions = DS_REPSYNC_WRITEABLE;
            SCHEDULE  repltimes;
            memset(&repltimes, 0, sizeof(repltimes));
    
            WinError = DsReplicaAdd( hDs,
                                     pInfo->DomainDn,
                                     NULL, // SourceDsaDn not needed
                                     NULL, // transport not needed
                                     pDsInfo->pServers[pInfo->RemoteDcIndex].pszGuidDNSName,
                                     NULL, // no schedule
                                     AddOptions );
    
            if ( ERROR_SUCCESS == WinError  )
            {
                // Now try to sync it
                WinError = DsReplicaSync( hDs,
                                          pInfo->DomainDn,
                                          &pDsInfo->pServers[pInfo->RemoteDcIndex].uuid,
                                          Options );
            }
    
        }
    }

    if ( ERROR_SUCCESS == WinError ) {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_REPL_SUCCESS,
                 pInfo->RemoteDc );

    } else {

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_DCMA_REPAIR_REPL_ERROR,
                 pInfo->RemoteDc,
                 Win32ErrToString(WinError) );

    }

    return WinError;
}

DWORD
GetOperationalAttribute(
    IN LDAP *hLdap,
    IN LPWSTR OpAtt,
    OUT LPWSTR *OpAttValue
    )
/*++

Routine Description:

        
Arguments:

    hLdap - an LDAP handle
    
    OpAtt - the ROOT DSE attribute to retrieve
    
    OpAttValue - the value of the attribute

Return Value:

    ERROR_SUCCESS
    otherwise a failure approxiamating the last error hit.

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    ULONG LdapError;
    LDAPMessage  *SearchResult;
    ULONG NumberOfEntries;

    WCHAR       *attrs[] = {0, 0};

    *OpAttValue = NULL;

    attrs[0] = OpAtt;


    LdapError = ldap_search_sW(hLdap,
                               NULL,
                               LDAP_SCOPE_BASE,
                               L"objectClass=*",
                               attrs, 
                               FALSE,
                               &SearchResult);

    if (LdapError) {
        return LdapMapErrorToWin32(LdapGetLastError());
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);

    if (NumberOfEntries > 0) {

        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        ULONG        NumberOfAttrs, NumberOfValues, i;

        //
        // Get entry
        //
        for (Entry = ldap_first_entry(hLdap, SearchResult), NumberOfEntries = 0;
                Entry != NULL;
                    Entry = ldap_next_entry(hLdap, Entry), NumberOfEntries++) {
            //
            // Get each attribute in the entry
            //
            for(Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement), NumberOfAttrs = 0;
                    Attr != NULL;
                        Attr = ldap_next_attributeW(hLdap, Entry, pBerElement), NumberOfAttrs++) {
                //
                // Get the value of the attribute
                //
                Values = ldap_get_valuesW(hLdap, Entry, Attr);
                if (!wcscmp(Attr, OpAtt)) {

                    ULONG Size;

                    Size = (wcslen( Values[0] ) + 1) * sizeof(WCHAR);
                    *OpAttValue = (WCHAR*) LocalAlloc( 0, Size );
                    if ( !*OpAttValue ) {
                        WinError = ERROR_NOT_ENOUGH_MEMORY;
                        goto Exit;
                    }
                    wcscpy( *OpAttValue, Values[0] );
                }

            }  // looping on the attributes

        } // looping on the entries

    }

    if ( NULL == (*OpAttValue) ) {

        WinError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;   

    }

Exit:

    return WinError;
}


#define REPAIR_SERVICE_START 0x1
#define REPAIR_SERVICE_STOP  0x2

DWORD
RepairConfigureService(
    IN LPWSTR ServiceName,
    IN ULONG  ServiceOptions
    )
/*++

Routine Description:

    Starts or stops the configuration of a service.

Arguments:

    ServiceName - Service to configure

    ServiceOptions - Stop, start, dependency add/remove, or configure

    Dependency - a null terminated string identify a dependency

    ServiceWasRunning - Optional.  When stopping a service, the previous service state
                        is returned here

Returns:

    ERROR_SUCCESS - Success

    ERROR_INVALID_PARAMETER - A bad service option was given

--*/
{
    DWORD WinError = ERROR_SUCCESS;
    SC_HANDLE hScMgr = NULL, hSvc = NULL;
    ULONG OpenMode = SERVICE_START | SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_QUERY_STATUS;
    LPENUM_SERVICE_STATUS DependentServices = NULL;
    ULONG DependSvcSize = 0, DependSvcCount = 0, i;

    //
    // If the service doesn't stop within two minutes minute, continue on
    //
    ULONG AccumulatedSleepTime;
    ULONG MaxSleepTime = 120000;


    BOOLEAN ConfigChangeRequired = FALSE;
    BOOLEAN RunChangeRequired = FALSE;

    DWORD   PreviousStartType = SERVICE_NO_CHANGE;
    BOOLEAN fServiceWasRunning = FALSE;


    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( hScMgr == NULL ) {

        WinError = GetLastError();
        goto Cleanup;

    }

    //
    // Open the service
    //
    hSvc = OpenService( hScMgr,
                        ServiceName,
                        OpenMode );

    if ( hSvc == NULL ) {

        WinError = GetLastError();
        goto Cleanup;
    } 

    // Stop the service.
    if ( REPAIR_SERVICE_STOP == ServiceOptions ) {
    
        SERVICE_STATUS  SvcStatus;
    
        WinError = ERROR_SUCCESS;
    
        //
        // Enumerate all of the dependent services first
        //
        if(EnumDependentServices( hSvc,
                                  SERVICE_ACTIVE,
                                  NULL,
                                  0,
                                  &DependSvcSize,
                                  &DependSvcCount ) == FALSE ) {
    
            WinError = GetLastError();
        }
    
    
    
        if ( WinError == ERROR_MORE_DATA ) {
    
            DependentServices = RtlAllocateHeap( RtlProcessHeap(), 0, DependSvcSize );
    
            if ( DependentServices == NULL) {
    
                WinError = ERROR_OUTOFMEMORY;
    
            } else {
    
                if( EnumDependentServices( hSvc,
                                           SERVICE_ACTIVE,
                                           DependentServices,
                                           DependSvcSize,
                                           &DependSvcSize,
                                           &DependSvcCount ) == FALSE ) {
    
                    WinError = GetLastError();
    
                } else {
    
                    for ( i = 0; i < DependSvcCount; i++) {
    
                        WinError = RepairConfigureService(
                                         DependentServices[i].lpServiceName,
                                         REPAIR_SERVICE_STOP );
    
                        if ( WinError != ERROR_SUCCESS ) {
    
                            break;
                        }
    
                    }
                }
    
                RtlFreeHeap( RtlProcessHeap(), 0, DependentServices );
            }
    
        }
    
    
        if ( WinError == ERROR_SUCCESS ) {
    
            if ( ControlService( hSvc,
                                 SERVICE_CONTROL_STOP,
                                 &SvcStatus ) == FALSE ) {
    
                WinError = GetLastError();
    
                //
                // It's not an error if the service wasn't running
                //
                if ( WinError == ERROR_SERVICE_NOT_ACTIVE ) {
    
                    WinError = ERROR_SUCCESS;
                }
    
            } else {
    
                WinError = ERROR_SUCCESS;
    
                //
                // Wait for the service to stop
                //
                AccumulatedSleepTime = 0;
                while ( TRUE ) {
    
                    if( QueryServiceStatus( hSvc,&SvcStatus ) == FALSE ) {
    
                        WinError = GetLastError();
                    }
    
                    if ( WinError != ERROR_SUCCESS ||
                                        SvcStatus.dwCurrentState == SERVICE_STOPPED) {
    
                        break;
                    
                    }

                    if ( AccumulatedSleepTime < MaxSleepTime ) {

                        Sleep( SvcStatus.dwWaitHint );
                        AccumulatedSleepTime += SvcStatus.dwWaitHint;

                    } else {

                        //
                        // Give up and return an error
                        //
                        WinError = WAIT_TIMEOUT;
                        break;
                    }
                }
            }
        }

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }
    
    }

    if ( REPAIR_SERVICE_START == ServiceOptions ) {

        //
        // See about changing its state
        //
        if ( StartService( hSvc, 0, NULL ) == FALSE ) {

            WinError = GetLastError();

        } else {

            WinError = ERROR_SUCCESS;
        }

        if ( ERROR_SUCCESS != WinError ) {
            goto Cleanup;
        }

    }

Cleanup:

    if ( hSvc ) {

        CloseServiceHandle( hSvc );

    }

    if ( hScMgr ) {
        
        CloseServiceHandle( hScMgr );

    }

    return( WinError );
}


DWORD
RepairStartService(
    LPWSTR ServiceName
    )
{
    return RepairConfigureService( ServiceName, REPAIR_SERVICE_START );
}

DWORD
RepairStopService(
    LPWSTR ServiceName
    )
{
    return RepairConfigureService( ServiceName, REPAIR_SERVICE_STOP );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\obsc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    obsc.c

ABSTRACT:

    Contains tests related to outbound secure channels.  CheckOutboundSecureChannels()
    is called from DcDiag.c
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/


#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmsname.h>
#include <lsarpc.h>                     // PLSAPR_foo

#include <lmaccess.h>

#include "dcdiag.h"
#include "dstest.h"

//local prototypes
                                                                   
DWORD 
COSC_CheckOutboundTrusts(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *Domain,
                    IN  WCHAR                             *defaultNamingContext,
                    IN  WCHAR                             *targetdefaultNamingContext,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *       gpCreds
                    );

DWORD
COT_FindDownLevelTrustObjects(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *DomainName,
                    IN  WCHAR                             *defaultNamingContext
                    );

DWORD
COT_FindUpLevelTrustObjects(
                    IN  LDAP                              *hLdap,
                    IN  WCHAR                             *ServerName,
                    IN  WCHAR                             *DomainName,
                    IN  WCHAR                             *defaultNamingContext,
                    IN  WCHAR                             *targetdefaultNamingContext
                    );

DWORD 
CheckOutboundSecureChannels (
                     PDC_DIAG_DSINFO                      pDsInfo,
                     ULONG                                ulCurrTargetServer,
                     SEC_WINNT_AUTH_IDENTITY_W *          gpCreds
                     );

DWORD
COT_CheckSercureChannel(
                     WCHAR *                              server,
                     WCHAR *                              domain
                     );


DWORD 
CheckOutboundSecureChannels (
                    PDC_DIAG_DSINFO                       pDsInfo,            
                    ULONG                                 ulCurrTargetServer,
                    SEC_WINNT_AUTH_IDENTITY_W *           gpCreds
                    )
/*++

Routine Description:

    will display all domain that current domain has outbound trusts with
    Will check to see if domain has secure channels with all domains that
    it has an outbound trust with.  Will give reason why a secure channel is not present
    Will see if the trust is uplevel and if both a trust object and an interdomain trust
    object exists.  Helper functions of this function all begin with "COSC_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all tests checked out.
    A Win32 Error if any tests failed to check out.

--*/
{
    DWORD dwErr=NO_ERROR, RetErr=NO_ERROR;
    BOOL  bFoundDomain = FALSE;
    BOOL  LimitToSite = TRUE;
    WCHAR *Domain=NULL;
    WCHAR *defaultNamingContext=NULL;
    WCHAR *targetdefaultNamingContext=NULL;
    LDAP  *hLdap=NULL;
    LDAP  *targethLdap=NULL;
    ULONG i=0,j=0;

    PrintMessage(SEV_VERBOSE, 
                 L"* The Outbound Secure Channels test\n");

    //do test specific parsing
    for(i=0; pDsInfo->ppszCommandLine[i] != NULL ;i++)
    {
        if(_wcsnicmp(pDsInfo->ppszCommandLine[i],L"/testdomain:",wcslen(L"/testdomain:")) == 0)
        {
            Domain = &pDsInfo->ppszCommandLine[i][wcslen(L"/testdomain:")];
            bFoundDomain = TRUE;
        }
        else if (_wcsnicmp(pDsInfo->ppszCommandLine[i],L"/nositerestriction",wcslen(L"/nositerestriction")) == 0)
        {
            LimitToSite = FALSE;   
        }

    }
    
    if(!bFoundDomain)
    {
        PrintMessage(SEV_ALWAYS,
                     L"** Did not run Outbound Secure Channels test\n" );
        PrintMessage(SEV_ALWAYS,
                     L"because /testdomain: was not entered\n");
        return NO_ERROR;
    }

    
    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);
    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }

    for (i=0;i<pDsInfo->ulNumServers;i++)
    {
        //create a connection with the DS using LDAP
        dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[i],
                                     gpCreds,
                                     FALSE,
                                     &targethLdap);
        if ( dwErr != LDAP_SUCCESS )
        {
            dwErr = LdapMapErrorToWin32(dwErr);
            PrintMessage(SEV_ALWAYS,
                         L"[%s] LDAP bind failed with error %d. %s\n",
                         pDsInfo->pServers[i].pszName,
                         dwErr,
                         Win32ErrToString(dwErr));
            RetErr=dwErr;
            continue;
        }
        dwErr=FinddefaultNamingContext(targethLdap,&targetdefaultNamingContext);
        if ( dwErr != NO_ERROR )
        {
           RetErr=dwErr;
        }
        if(LimitToSite)
        {
            //if the server is in the same site as the target server then do the if
            if(pDsInfo->pServers[ulCurrTargetServer].iSite ==
               pDsInfo->pServers[i].iSite &&
               _wcsicmp(defaultNamingContext,
                        targetdefaultNamingContext) == 0)
            {
                dwErr=COSC_CheckOutboundTrusts(targethLdap,
                                               pDsInfo->pServers[i].pszName,
                                               Domain,
                                               defaultNamingContext,
                                               targetdefaultNamingContext,
                                               gpCreds);
                if(dwErr != NO_ERROR) 
                {
                    RetErr=dwErr;
                }
            }
        }
        else
        {
            if(_wcsicmp(defaultNamingContext,
                        targetdefaultNamingContext) == 0)
            {
                dwErr=COSC_CheckOutboundTrusts(targethLdap,
                                               pDsInfo->pServers[i].pszName,
                                               Domain,
                                               defaultNamingContext,
                                               targetdefaultNamingContext,
                                               gpCreds);
                if(dwErr != NO_ERROR) 
                {
                    RetErr=dwErr;
                }
            }
        }
        if(targetdefaultNamingContext)
            free(targetdefaultNamingContext);
    }

    cleanup:
    if(Domain)
        free(Domain);
    if(defaultNamingContext)
        free(defaultNamingContext);
    
    
    return RetErr;                         
}

DWORD 
COSC_CheckOutboundTrusts(
                    IN  LDAP                                *hLdap,
                    IN  WCHAR                               *ServerName,
                    IN  WCHAR                               *Domain,
                    IN  WCHAR                               *defaultNamingContext,
                    IN  WCHAR                               *targetdefaultNamingContext,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *         gpCreds)
/*++

Routine Description:

    will display all domain that current domain has outbound trusts with
    Will check to see if domain has secure channels with all domains that
    it has an outbound trust with.  Will give reason why a secure channel is not present
    Will see if the trust is uplevel and if both a trust object and an interdomain trust
    object exists.  Helper functions of this function all begin with "COSC_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all tests checked out.
    A Win32 Error if any tests failed to check out.

--*/
{
    NTSTATUS                        Status;
    LSAPR_HANDLE                    PolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES           ObjectAttributes;
    LSA_UNICODE_STRING              ServerString;
    PLSA_UNICODE_STRING             Server;
    NETRESOURCE                     NetResource;
    //LSA_ENUMERATION_HANDLE          EnumerationContext=0;
    PTRUSTED_DOMAIN_INFORMATION_EX  Buffer=NULL;
    LSA_UNICODE_STRING              DomainString;
    PLSA_UNICODE_STRING             pDomain;
    //ULONG                           CountReturned=0;
    WCHAR                           *remotename = NULL;
    WCHAR                           *lpPassword = NULL;
    WCHAR                           *lpUsername = NULL;
    WCHAR                           *temp=NULL;
    DWORD                           dwErr=NO_ERROR,dwRet=NO_ERROR;
    DWORD                           i=0;
    
    
    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;

    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));
    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwErr=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Remote ipc to [%s]:failed with %d: %s\n",
                     ServerName,
                     dwErr,
                     Win32ErrToString(dwErr));
        remotename = NULL;
        goto cleanup;
    }

    //test secure channel with netlogon api
    dwErr=COT_CheckSercureChannel(ServerName,Domain);
    if ( dwErr != NO_ERROR )
    {
        dwRet=dwErr;
    }

    //look for the uplevel and downlevel trusts
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));



    if ( ServerName != NULL )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        DInitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else
    {
        Server = NULL; // default to local machine
    }

    // Open a Policy
    Status = LsaOpenPolicy(
                          Server,
                          &ObjectAttributes,
                          TRUSTED_READ,
                          &PolicyHandle
                          );
    //Assert(PolicyHandle);
    if ( !NT_SUCCESS(Status) )
    {
        dwErr = RtlNtStatusToDosError(Status);
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Lsa Policy to [%s] : %s\n",
                     ServerName,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }

    
       
    DInitLsaString(&DomainString, Domain);
    pDomain = &DomainString;
                        
    
    Status=LsaQueryTrustedDomainInfoByName(
                                PolicyHandle,
                                pDomain,
                                TrustedDomainInformationEx,
                                &Buffer
                                );
    if ( !NT_SUCCESS(Status) )
    {
        dwErr = RtlNtStatusToDosError(Status);
        //wprintf(L"\n%x",Status);
        PrintMessage(SEV_ALWAYS,
                     L"Could not Query Trusted Domain :%s\n",
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    
    if((Buffer->TrustDirection&TRUST_TYPE_UPLEVEL) == TRUST_TYPE_UPLEVEL)
    {
        dwErr=COT_FindDownLevelTrustObjects(hLdap,
                                   ServerName,
                                   Domain,
                                   defaultNamingContext);
        dwRet=dwErr;
        dwErr=COT_FindUpLevelTrustObjects(hLdap,
                                   ServerName,
                                   Domain,
                                   defaultNamingContext,
                                   targetdefaultNamingContext);
        if ( dwErr != NO_ERROR )
        {
            dwRet=dwErr;
            goto cleanup;
        }
    }


    //cleanup
cleanup:
    if ( Buffer )
    {
        LsaFreeMemory(Buffer);
    }
    if ( PolicyHandle )
    {
            Status = LsaClose( PolicyHandle );
            Assert( NT_SUCCESS(Status) );
    }
    if( remotename )
        WNetCancelConnection2(remotename,
                              0,
                              TRUE);
    

    return dwRet;
}


DWORD
COT_CheckSercureChannel(
                     WCHAR *                             server,
                     WCHAR *                             domain
                     )
/*++

Routine Description:

    will check to see if there is a secure channel between the 
    server and the domain
    
Arguments:

    server - The name of the server that we will check
    domain - the domain we will be check to see if we have a 
             secure channel to.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    DWORD dwErr=NO_ERROR;
    PNETLOGON_INFO_2 Buffer=NULL;
    LPBYTE bDomain=NULL;

    bDomain=(LPBYTE)domain;

    dwErr=I_NetLogonControl2(server,
                             NETLOGON_CONTROL_REDISCOVER,
                             2,
                             (LPBYTE)&bDomain,
                             (LPBYTE*)&Buffer);
    if(NO_ERROR!=dwErr)
    {
        PrintMessage(SEV_ALWAYS,
                         L"Could not Check secure channel from %s to %s: %s\n",
                         server,
                         domain,
                         Win32ErrToString(dwErr));
    }
    else if(Buffer->netlog2_tc_connection_status != NO_ERROR)
    {
        PrintMessage(SEV_ALWAYS,
                         L"Error with Secure channel from [%s] to [%s] :%s\n",
                         server,
                         Buffer->netlog2_trusted_dc_name,
                         Win32ErrToString(Buffer->netlog2_tc_connection_status));
        dwErr=Buffer->netlog2_tc_connection_status;
    }
    else
    {
        PrintMessage(SEV_VERBOSE,
                         L"* Secure channel from [%s] to [%s] is working properly.\n",
                         server,
                         Buffer->netlog2_trusted_dc_name);
    }

    
    return dwErr;

}

DWORD
COT_FindDownLevelTrustObjects(
              LDAP                                  *hLdap,
              WCHAR                                 *ServerName,
              WCHAR                                 *DomainName,
              WCHAR                                 *defaultNamingContext
              )
/*++

Routine Description:

    will check to see if there is a downlevel trust object in the DS
    
Arguments:

    hLdap - handle to the ldap server
    ServerName - the name of the server that you are check
    DomainName - the name of the domain used to build the filter
    defaultNamingContext - used as the base of the search


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *filter=NULL;
    
    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;
    BOOL         hasDownLevel=FALSE;


    Assert(hLdap);
    Assert(ServerName);
    Assert(DomainName);
    Assert(defaultNamingContext);
    
    AttrsToSearch[0] = L"userAccountControl";
    AttrsToSearch[1] = NULL;


    //build the filter
    Length = wcslen( L"sAMAccountName=$" ) +
             wcslen( DomainName );
             
    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",DomainName);

    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        userAccountControl=_wtoi(Values[0]);
                        //check to see if the UF_TRUSTED_FOR_DELEGATION is set
                        if (  !((userAccountControl & UF_INTERDOMAIN_TRUST_ACCOUNT)  == 
                               UF_INTERDOMAIN_TRUST_ACCOUNT) )
                        {
                            PrintMessage(SEV_VERBOSE,
                                         L"* [%s] has downlevel trust object for [%s]\n",
                                         ServerName,
                                         DomainName);
                            hasDownLevel=TRUE;
                            goto cleanup;
                        }
                        else
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"[%s] Does not have UF_INTERDOMAIN_TRUST_ACCOUNT set on downlevel trust object for [%s]\n",
                                         ServerName,
                                         DomainName);
                            WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
                            goto cleanup;
                        }
                    }
                }
            }
        }
    }

    cleanup:
    if(!hasDownLevel)
    {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] Does not have downlevel trust object for [%s]\n",
                     ServerName,
                     DomainName);
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
    }


    
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    return WinError;
}

DWORD
COT_FindUpLevelTrustObjects(
              LDAP                                  *hLdap,
              WCHAR                                 *ServerName,
              WCHAR                                 *DomainName,
              WCHAR                                 *defaultNamingContext,
              WCHAR                                 *targetdefaultNamingContext
              )
/*++

Routine Description:

    will check to see if there is a secure channel between the 
    server and the domain
    
Arguments:

    hLdap - handle to the ldap server
    domain - the domain we will be check to see if we have a 
             secure channel to.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *Base=NULL;
    WCHAR        *filter=NULL;
    WCHAR        *schemaNamingContext=NULL;
    WCHAR        *objectCategory=NULL;

    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;
    BOOL         hasUpLevel=FALSE;


    Assert(hLdap);
    Assert(ServerName);
    Assert(DomainName);
    Assert(defaultNamingContext);
    Assert(targetdefaultNamingContext);

    WinError=FindschemaNamingContext(hLdap,&schemaNamingContext);
    if(WinError != NO_ERROR)
    {
        goto cleanup;
    }

    
    AttrsToSearch[0] = L"LDAPDisplayName";
    AttrsToSearch[1] = NULL;

    filter=L"objectClass=*";

    //build the base
    Length = wcslen( L"CN=Trusted-Domain," ) +
             wcslen( schemaNamingContext );
             
    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(Base,L"CN=Trusted-Domain,%s",schemaNamingContext);

    //find the ObjectCategory for trusted domains
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {
                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        objectCategory = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy( objectCategory, Values[0] );    
                    }
                }
            }
        }
    }
    if(!objectCategory)
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not find objectCatagory for Trusted Domains");
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
        goto cleanup;
    }

    if ( SearchResult )
    {
        ldap_msgfree( SearchResult );
        SearchResult=NULL;
    }

    AttrsToSearch[0] = NULL;

    //build the base
    Length = wcslen( L"CN=System," ) +
             wcslen( targetdefaultNamingContext );
             
    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(Base,L"CN=System,%s",targetdefaultNamingContext);

    //build the filter
    Length = wcslen( L"(&(flatName=)(objectCategory=))" ) +
             wcslen( DomainName ) +
             wcslen( objectCategory );
             
    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"(&(flatName=%s)(objectCategory=%s))",DomainName,objectCategory);


    //find the ObjectCategory for trusted domains
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                NULL,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                //
                // Found it - these are NULL-terminated strings
                //
                PrintMessage(SEV_VERBOSE,
                             L"* [%s] has uplevel trust object for [%s]\n",
                             ServerName,
                             DomainName);
                hasUpLevel=TRUE;
                goto cleanup;
                
            }
        }
    }



    cleanup:
    if(!hasUpLevel)
    {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] Does not have uplevel trust object for [%s]\n",
                     ServerName,
                     DomainName);
        WinError=ERROR_DS_CANT_RETRIEVE_ATTS;
    }

    
    if(schemaNamingContext)
        free(schemaNamingContext);
    
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    return WinError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\dstestcm.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dstestcommon.c

ABSTRACT:

    Contains common functions for various ds tests in
    dcdiag

DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include "dcdiag.h"
#include "dstest.h"


DWORD
FinddefaultNamingContext (
                         IN  LDAP *                      hLdap,
                         OUT WCHAR**                     ReturnString
                         )
/*++

Routine Description:

    This function will return the defaultNamingContext attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"defaultNamingContext";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for default NC failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}

DWORD
FindServerRef (
              IN  LDAP *                      hLdap,
              OUT WCHAR**                     ReturnString
              )
/*++

Routine Description:

    This function will return the serverName attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The serverName

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"serverName";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for serverName failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}



DWORD
GetMachineReference(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext,
                   OUT WCHAR **                    ReturnString
                   )
/*++

Routine Description:

    This function will check to see if the current DC is
    in the domain controller's OU

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    defaultNamingContext - the Base of the search
    ReturnString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *filter = NULL;

    ULONG         Length;

    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"distinguishedName";
    AttrsToSearch[1]=NULL;

    //built the filter
    Length= wcslen( L"sAMAccountName=$" ) +
            wcslen( name );

    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",name);


    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW subtree of %s for sam account failed with %d: %s\n",
                     defaultNamingContext,
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return ERROR_DS_CANT_RETRIEVE_ATTS;



}

DWORD
WrappedTrimDSNameBy(
           IN  WCHAR *                          InString,
           IN  DWORD                            NumbertoCut,
           OUT WCHAR **                         OutString
           )
/*++

Routine Description:

    This Function is wrapping TrimDSNameBy to hanndle the
    DSNAME struct.  Usage is the same as TrimDSNameBy except
    that you send WCHAR instead of DSNAME.  
    
    Callers: make sure that you send InString as a DN
             make sure to free OutString when done
    
Arguments:

    InString - A WCHAR that is a DN that we need to trim
    NumbertoCut - The number of parts to take off the front of the DN
    OutString - The Machine Reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG  Size;
    DSNAME *src, *dst, *QuotedSite;
    DWORD  WinErr=NO_ERROR;

    if ( *InString == L'\0' )
    {
        *OutString=NULL;
        return ERROR_INVALID_PARAMETER;
    }

    Size = (ULONG)DSNameSizeFromLen( wcslen(InString) );

    src = alloca(Size);
    RtlZeroMemory(src, Size);
    src->structLen = Size;

    dst = alloca(Size);
    RtlZeroMemory(dst, Size);
    dst->structLen = Size;

    src->NameLen = wcslen(InString);
    wcscpy(src->StringName, InString);

    WinErr = TrimDSNameBy(src, NumbertoCut, dst); 
    if ( WinErr != NO_ERROR )
    {
        *OutString=NULL;
        return WinErr;
    }

    *OutString = malloc((dst->NameLen+1)*sizeof(WCHAR));
    wcscpy(*OutString,dst->StringName);

    return NO_ERROR;


}

void
DInitLsaString(
              PLSA_UNICODE_STRING LsaString,
              LPWSTR String
              )
/*++

Routine Description:

    converts a PLSA_UNICODE_STRING to a LPWSTR.
        
Arguments:

                                 
    LsaString - a PLSA_UNICODE_STRING
    String - the returning LPWSTR
    
--*/
{
    DWORD StringLength;

    if ( String == NULL )
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;

        return;
    }

    StringLength = lstrlenW(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength = (USHORT) (StringLength + 1) *
                               sizeof(WCHAR);
}


DWORD
FindschemaNamingContext (
                         IN  LDAP *                      hLdap,
                         OUT WCHAR**                     ReturnString
                         )
/*++

Routine Description:

    This function will return the schemaNamingContext attrib so the it can
    be used for future searches.

Arguments:

    hLdap - handle to the LDAP server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";

    ULONG         Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"schemaNamingContext";
    AttrsToSearch[1] = NULL;

    LdapError = ldap_search_sW( hLdap,
                                NULL,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of RootDSE for schemaNC failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return NO_ERROR;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\dcma.c ===
/*++                

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcma.c

ABSTRACT:

    Contains tests related to the domain controller's machine account.  
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

//defines for the SPN's
#define sLDAP L"LDAP"
#define sHOST L"HOST"
#define sGC   L"GC"
#define sREP  L"E3514235-4B06-11D1-AB04-00C04FC2DCD2"
#define NUM_OF_SPN 11

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmaccess.h>

#include <dsconfig.h>                   // Definition of mask for visible
// containers

#include <lmcons.h>                     // CNLEN
#include <lsarpc.h>                     // PLSAPR_foo
#include <lmerr.h>
#include <lsaisrv.h>

#include <winldap.h>
#include <dns.h>
#include <ntdsapip.h>


#include "dcdiag.h"
#include "dstest.h"

// forward from repair.c
DWORD
RepairDCWithoutMachineAccount(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN ULONG                       ulCurrTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    );


//local prototypes
DWORD
CDCMA_CheckDomainOU(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);

DWORD
CDCMA_CheckForExistence(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);


DWORD
CDCMA_CheckServerFlags(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);

DWORD
CDCMA_CheckServerReference(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext);

DWORD
CDCMA_CheckSPNs(
               IN  PDC_DIAG_DSINFO             pDsInfo,
               IN  ULONG                       ulCurrTargetServer,
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               SEC_WINNT_AUTH_IDENTITY_W *     gpCreds);

DWORD
CS_CheckSPNs(
    IN  LDAP  *                     hLdap,
    IN  HANDLE                      hDsBinding,
    IN  WCHAR **                    SPNs,
    IN  DWORD                       dwReplSpnIndex,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext
    );

BOOL
GetNetBIOSDomainName(
                    WCHAR                     **DomainName,
                    WCHAR                      *wComputerName,
                    SEC_WINNT_AUTH_IDENTITY_W  *gpCreds);

BOOL
GetdnsMachine(LDAP *hLdap,
              WCHAR **ReturnString);


DWORD
getGUID(
       PDC_DIAG_DSINFO                     pDsInfo,
       IN  ULONG                           ulCurrTargetServer,
       WCHAR **                            ppszServerGuid);


DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
               WCHAR   **ppszSpn);



DWORD 
CheckDCMachineAccount(
                     PDC_DIAG_DSINFO                     pDsInfo,
                     ULONG                               ulCurrTargetServer,
                     SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                     )

/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test  
    Does sanity checks on the Domain Controller Machine Account in the ds
    Check to see if Current DC is in the domain controller's OU
    Check that useraccountcontrol has UF_SERVER_TRUST_ACCOUNT
    Check to see if the machine account is trusted for delegation
    Check's to see if the minimum SPN's are there
    Makes sure that that the server reference is set up correctly.  
    Helper functions of this function all begin with "CDCMA_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    LDAP   *hLdap = NULL;
    WCHAR  *defaultNamingContext=NULL;
    HANDLE phDsBinding=NULL;

    //Assert(gpCreds);
    Assert(pDsInfo);

    
    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);

    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        return dwErr;
    }

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        return dwErr;
    }

    //
    // Check to see if machine account exists locally, if not, call into
    // the repair code 
    //
    dwErr=CDCMA_CheckForExistence(hLdap,
                                  pDsInfo->pServers[ulCurrTargetServer].pszName,
                                  defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        DWORD RepairStatus = dwErr;

        if ( (dwErr == ERROR_NO_TRUST_SAM_ACCOUNT)
          && (pDsInfo->ulHomeServer == ulCurrTargetServer) ) {

            BOOL fRepairMachineAccount = FALSE;
            LPWSTR RepairOption = L"/repairmachineaccount";
            ULONG i;

            for(i=0; pDsInfo->ppszCommandLine[i] != NULL ; i++) {

                if (!_wcsnicmp(pDsInfo->ppszCommandLine[i],
                               RepairOption,
                               wcslen(RepairOption)) ) {

                    fRepairMachineAccount = TRUE;
                    break;

                }
            }

            if ( fRepairMachineAccount ) {
                  
                //
                // If the local machine does not have a machine account and
                // the user has asked us to try and repair this condition,
                // then we'll try.
                //
    
                PrintMsg(SEV_ALWAYS,
                         DCDIAG_DCMA_REPAIR_ATTEMPT,
                         pDsInfo->pServers[ulCurrTargetServer].pszName );
    
                RepairStatus =  RepairDCWithoutMachineAccount( pDsInfo,
                                                               ulCurrTargetServer,
                                                           gpCreds );

            } else  {

                PrintMsg(SEV_ALWAYS,
                         DCDIAG_DCMA_REPAIR_TRY_REPAIR,
                         pDsInfo->pServers[ulCurrTargetServer].pszName );

            }
        }

        dwRet = RepairStatus;

    }


    dwErr=CDCMA_CheckDomainOU(hLdap,
                              pDsInfo->pServers[ulCurrTargetServer].pszName,
                              defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }


    dwErr=CDCMA_CheckServerFlags(hLdap,
                                 pDsInfo->pServers[ulCurrTargetServer].pszName,
                                 defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }


    dwErr=CDCMA_CheckServerReference(hLdap,
                                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                                     defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }

    dwErr=CDCMA_CheckSPNs(pDsInfo,
                          ulCurrTargetServer,
                          hLdap,
                          pDsInfo->pServers[ulCurrTargetServer].pszName,
                          defaultNamingContext,
                          gpCreds);
    if ( dwErr != NO_ERROR )
    {
        dwRet = dwErr;
    }

    return dwRet;
}


DWORD
CDCMA_CheckDomainOU(
                   IN  LDAP  *                     hLdap,
                   IN  WCHAR *                     name,
                   IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check to see if the current DC is
    in the domain controller's OU

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *Base=NULL;

    WCHAR        *filter=NULL;

    WCHAR        *sname=NULL;

    DWORD        WinError=NO_ERROR;

    ULONG        Length;


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"sAMAccountName";
    AttrsToSearch[1]=NULL;

    //sam account name
    Length = wcslen (name) + 1;
    sname = (WCHAR*) alloca( (Length + 1) * sizeof(WCHAR) );
    wcscpy(sname,name);
    wcscat(sname,L"$");

    //built the filter
    Length = wcslen (sname) + wcslen (L"sAMAccountName=") + 1;
    filter = (WCHAR*) alloca( (Length + 1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s",sname);


    //built the Base
    Length= wcslen( L"OU=Domain Controllers," ) +
            wcslen( defaultNamingContext );

    Base=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );

    wsprintf(Base,L"OU=Domain Controllers,%s",defaultNamingContext);


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_ONELEVEL,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if ( !_wcsicmp( sname, Values[0] ) )
                        {
                            ldap_msgfree( SearchResult );
                            return NO_ERROR;
                        }
                    }
                }
            }
        }
    }

    //clean up
    ldap_msgfree( SearchResult );

    PrintMessage(SEV_ALWAYS,
                 L"* The current DC is not in the domain controller's OU\n");
    return ERROR_DS_CANT_RETRIEVE_ATTS;
}



DWORD
CDCMA_CheckServerFlags(
                      IN  LDAP  *                     hLdap,
                      IN  WCHAR *                     name,
                      IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check to see if the current DC has
    UF_SERVER_TRUST_ACCOUNT and UF_TRUSTED_FOR _DELEGATION
    set.  Also will check to see if objectClass includes
    computer.
    
Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *filter=NULL;

    DWORD        WinError=NO_ERROR;

    DWORD        userAccountControl=0;

    ULONG        Length;

    BOOL         isComputer=FALSE;                     //assume false until test
    BOOL         isTrust=TRUE;                         //assume true  until test
    BOOL         isTrustedDelegation=TRUE;             //assume true  until test


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"userAccountControl";
    AttrsToSearch[1]=L"objectClass";
    AttrsToSearch[2]=NULL;


    //built the filter
    Length= wcslen( L"sAMAccountName=$" ) +
            wcslen( name );

    filter=(WCHAR*) alloca( (Length+1) * sizeof(WCHAR) );
    wsprintf(filter,L"sAMAccountName=%s$",name);

    LdapError = ldap_search_sW( hLdap,
                                defaultNamingContext,
                                LDAP_SCOPE_SUBTREE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found userAccountControl
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        userAccountControl=_wtoi(Values[0]);
                        //check to see if the UF_TRUSTED_FOR_DELEGATION is set
                        if ( !(( userAccountControl & UF_SERVER_TRUST_ACCOUNT ) == 
                               UF_SERVER_TRUST_ACCOUNT) )
                        {
                            isTrust=FALSE;
                        }
                        if ( !(( userAccountControl & UF_TRUSTED_FOR_DELEGATION ) == 
                               UF_TRUSTED_FOR_DELEGATION) )
                        {
                            isTrustedDelegation=FALSE;
                        }
                    }
                    ldap_value_freeW(Values);
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {
                    DWORD       i = 0;
                    //
                    // Found objectClass - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    while ( Values && Values[i] )
                    {
                        if ( _wcsicmp( Values[i], L"computer" ) == 0)
                        {
                            isComputer=TRUE;
                            break;
                        }
                        i++;
                    }
                    ldap_value_freeW(Values);
                }
            }
        }
    }


    //clean up
    ldap_msgfree( SearchResult );


    //Display errors
    if ( !isTrust )
    {
        PrintMessage(SEV_ALWAYS,
                     L"* %s is not a server trust account\n",name);
        WinError = ERROR_INVALID_FLAGS;
    }

    if ( !isTrustedDelegation )
    {
        PrintMessage(SEV_ALWAYS,
                     L"* %s is not trusted for account delegation\n",name);
        WinError = ERROR_INVALID_FLAGS;
    }


    if ( !isComputer )
    {
        PrintMessage(SEV_ALWAYS,
                     L"* %s does not have computer as its objectClass\n",name);
        return ERROR_INVALID_FLAGS;    
    }




    return WinError;
}


DWORD
CDCMA_CheckServerReference(
                          IN  LDAP  *                     hLdap,
                          IN  WCHAR *                     name,
                          IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check to see if the server
    reference's are set up correctly
        
Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *Base=NULL;

    DWORD        WinError=NO_ERROR;

    WCHAR        *serverReference=NULL;

    ULONG        Length;
    BOOL         found=FALSE;


    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"serverReference";
    AttrsToSearch[1]=NULL;

    WinError=FindServerRef(hLdap,&Base);
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }

    WinError=GetMachineReference(hLdap,name,defaultNamingContext,&serverReference);
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        if ( _wcsicmp( Values[0], serverReference ) )
                        {
                            ldap_msgfree( SearchResult );
                            PrintMessage(SEV_ALWAYS,
                                         L"* %s Server Reference is incorrect\n"
                                         ,name);
                            return ERROR_DS_NO_ATTRIBUTE_OR_VALUE;    
                        }
                    }
                }
            }
        }
    }

    cleanup:
    //clean up
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( Base )
        free(Base);
    if ( serverReference )
        free(serverReference);

    return NO_ERROR;

}

DWORD
CDCMA_CheckSPNs(
               IN  PDC_DIAG_DSINFO             pDsInfo,
               IN  ULONG                       ulCurrTargetServer,
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               SEC_WINNT_AUTH_IDENTITY_W *     gpCreds)
/*++

Routine Description:

    This function will check to see if the proper
    SPN are published and that the minimum ones are
    there.
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{  
    WCHAR           *NetBiosDomainName=NULL;
    WCHAR           *SPNs[14];
    ULONG           Length=0;
    ULONG           i=0;
    WCHAR           *pszServerGuid;
    WCHAR           *ppszServerGuid;
    DWORD           dwErr=NO_ERROR;
    WCHAR           *dnsMachine=NULL;
    WCHAR           *dnsDomain=NULL;
    DWORD           c;
    BOOL            gotDNSMname=FALSE;
    BOOL            gotNBDname=FALSE;
    HANDLE          hDsBinding=NULL;
    WCHAR           **NameToConvert;
    PDS_NAME_RESULT ppResult=NULL;
    DWORD           dwReplSpnIndex = 0;

    //init
    for ( i=0;i<NUM_OF_SPN;i++ )
        SPNs[i]=0;

    //set up useful vars for SPNs
    
    if ( !GetNetBIOSDomainName(&NetBiosDomainName,name,gpCreds) )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get NetBIOSDomainName\n");
    }

    //construct the dnsMachine name
    if ( !GetdnsMachine(hLdap,&dnsMachine) )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get dnsHost\n");
    }

    //construct the dnsDomain name
    dwErr=DcDiagGetDsBinding(
                        &pDsInfo->pServers[ulCurrTargetServer],
                        gpCreds,
                        &hDsBinding
                        );
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Error: %d: [%s].  Could not perform DsBind() with [%s].  Some SPN's Will not be checked\n",
                     dwErr,
                     Win32ErrToString(dwErr),
                     pDsInfo->pServers[ulCurrTargetServer].pszName);
    }


    //convert DN name to DNS name
    if (dwErr == NO_ERROR)
    {
        dwErr=DsCrackNames(
                            hDsBinding,
                            DS_NAME_NO_FLAGS,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            1,
                            &defaultNamingContext,
                            &ppResult);
        if ( dwErr != NO_ERROR && ppResult->rItems->status != NO_ERROR)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Error: %d: [%s].  Could not perform DsCrackNames() with [%s].  Some SPN's Will not be checked\n",
                         dwErr,
                         Win32ErrToString(dwErr),
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
        }
        else
        {
            //place name in dnsDomain variable
            ASSERT( ppResult->rItems->pName );
            Length = wcslen( ppResult->rItems->pName );
            dnsDomain = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
            wsprintf(dnsDomain,L"%s",ppResult->rItems->pName);
            //free results
            DsFreeNameResult(ppResult);
            //remove trailing slash
            dnsDomain[wcslen(dnsDomain)-1]=L'\0';
        }
    }

    
    



    //prepare the spn's to search for

    // Make the first LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name/domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            dnsDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[0]);
    if ( dwErr != NO_ERROR || !dnsMachine || !dnsDomain)
    {
        if ( dnsMachine && dnsDomain)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for LDAP SPN\n");
        }
        if ( SPNs[0] )
        {
            free(SPNs[0]);
        }
        SPNs[0]=NULL;
    }

    // Make the second LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            dnsMachine,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[1]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for LDAP SPN\n");
        }
        if ( SPNs[1] )
        {
            free(SPNs[1]);
        }
        SPNs[1]=NULL;
    }

    // Make the third LDAP SPN
    // This is of the format
    //   LDAP/machinename
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            name,
                            name,
                            0,
                            NULL,
                            &c,
                            &SPNs[2]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        if ( SPNs[2] )
        {
            free(SPNs[2]);
        }
        SPNs[2]=NULL;
    }


    // Make the fourth LDAP SPN
    // This is of the format
    //   LDAP/host.dns.name/netbiosDomainName
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            NetBiosDomainName,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[3]);
    if ( dwErr != NO_ERROR || !dnsMachine || !NetBiosDomainName )
    {
        if ( dnsMachine && NetBiosDomainName )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[3] )
        {
            free(SPNs[3]);
        }
        SPNs[3]=NULL;
    }

    // Make the fifth LDAP SPN
    // This is of the format
    //   LDAP/guid-based-dns-name
    //
    dwErr = WrappedMakeSpnW(sLDAP,
                            pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName,
                            pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName,
                            0,
                            NULL,
                            &c,
                            &SPNs[4]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for LDAP SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        if ( SPNs[4] )
        {
            free(SPNs[4]);
        }
        SPNs[4]=NULL;    
    }



    // Make the DRS RPC SPN (for dc to dc replication)
    // This is of the format
    //   E3514235-4B06-11D1-AB04-00C04FC2DCD2/ntdsa-guid/
    //                      domain.dns.name
    //
    dwErr = getGUID(pDsInfo,ulCurrTargetServer,&pszServerGuid);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for replication SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
    }

    if ( dwErr == NO_ERROR )
    {
        dwReplSpnIndex = 5;
        dwErr = WrappedMakeSpnW(sREP,
                                dnsDomain,
                                pszServerGuid,
                                0,
                                NULL,
                                &c,
                                &SPNs[dwReplSpnIndex]);

        if ( dwErr != NO_ERROR || !dnsDomain)
        {
            if (dnsDomain)
            {
                PrintMessage(SEV_ALWAYS,
                         L"Can not test for replication SPN\n");
            }
            else
            {
                PrintMessage(SEV_ALWAYS,
                             L"Failed with %d: %s\nCan not test for replication SPN\n",
                             dwErr,
                             Win32ErrToString(dwErr));
            }
            if ( SPNs[dwReplSpnIndex] )
            {
                free(SPNs[dwReplSpnIndex]);
            }
            SPNs[dwReplSpnIndex]=NULL;
        }
    }

    // Make the default host SPN
    // This is of the format
    //   HOST/host.dns.name/domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            dnsDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[6]);
    if ( dwErr != NO_ERROR || !dnsMachine || !dnsDomain)
    {
        if ( dnsMachine && dnsDomain)
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[6] )
        {
            free(SPNs[6]);
        }
        SPNs[6]=NULL;
    }

    // Make the second host SPN - hostDnsName-only HOST SPN
    // This is of the format
    //   HOST/host.dns.name
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            dnsMachine,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[7]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[7] )
        {
            free(SPNs[7]);
        }
        SPNs[7]=NULL;
    }


    // Make the third host SPN - 
    // This is of the format
    //   HOST/machinename
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            name,
                            name,
                            0,
                            NULL,
                            &c,
                            &SPNs[8]);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\nCan not test for HOST SPN\n",
                     dwErr,
                     Win32ErrToString(dwErr));
        if ( SPNs[8] )
        {
            free(SPNs[8]);
        }
        SPNs[8]=NULL;return dwErr;
    }


    // Make the fourth host SPN - 
    // This is of the format
    //   HOST/host.dns.name/netbiosDoamainName
    //
    dwErr = WrappedMakeSpnW(sHOST,
                            NetBiosDomainName,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[9]);
    if ( dwErr != NO_ERROR || !dnsMachine || !NetBiosDomainName )
    {
        if ( dnsMachine && NetBiosDomainName )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for HOST SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for HOST SPN\n");
        }
        if ( SPNs[9] )
        {
            free(SPNs[9]);
        }
        SPNs[9]=NULL;
    }


    // Make the GC SPN. This is done on all systems, even non-GC.
    // results in an SPN of HOST/dot.delimited.dns.host.name form.
    // This is of the format
    //   HOST/host.dns.name/root.domain.dns.name
    //
    dwErr = WrappedMakeSpnW(sGC,
                            pDsInfo->pszRootDomain,
                            dnsMachine,
                            0,
                            NULL,
                            &c,
                            &SPNs[10]);
    if ( dwErr != NO_ERROR || !dnsMachine )
    {
        if ( dnsMachine )
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed with %d: %s\nCan not test for GC SPN\n",
                         dwErr,
                         Win32ErrToString(dwErr));
        } else
        {
            PrintMessage(SEV_ALWAYS,
                         L"Failed can not test for GC SPN\n");
        }
        if ( SPNs[10] )
        {
            free(SPNs[10]);
        }
        SPNs[10]=NULL;
    }


    dwErr=CS_CheckSPNs(hLdap,hDsBinding,SPNs,dwReplSpnIndex,name,defaultNamingContext);

    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        if ( SPNs[i] )
            free(SPNs[i]);
    }

    //clean up
    if ( defaultNamingContext )
        free(defaultNamingContext);
    if ( pszServerGuid )
        free(pszServerGuid);
    if ( NetBiosDomainName )
        free(NetBiosDomainName);
    if ( dnsMachine )
        free(dnsMachine);

    return dwErr;

}

DWORD
CS_CheckSPNs(
    IN  LDAP  *                     hLdap,
    IN  HANDLE                      hDsBinding,
    IN  WCHAR **                    SPNs,
    IN  DWORD                       dwReplSpnIndex,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext
    )
/*++

Routine Description:

    This is a helper of CS_CheckSPNs
    This function will check to see if the proper
    SPN are published and that the minimum ones are
    there.

    I can also correct a missing replication SPN if so directed.
        
Arguments:

    hLdap - handle to the LDAP server
    hDsBinding - handle to DS server
    SPNs - The constructed SPNs to check                                                  
    dwReplSpnIndex - Index of the replication spn in the SPN array
    name - The NetBIOS name of the current server
    ReturnString - The defaultNamingContext
    
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;
    ULONG        found[NUM_OF_SPN];
    ULONG        i=0;
    ULONG        j=0;
    ULONG        Length=0;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *Base=NULL;

    DWORD        WinError=NO_ERROR;


    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        found[i]=0;
    }

    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"servicePrincipalName";
    AttrsToSearch[1]=NULL;


    //built the Base
    WinError=GetMachineReference(hLdap,name,defaultNamingContext,&Base);
    if ( WinError != NO_ERROR )
        goto cleanup;


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                L"objectClass=*",
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        j=0;
                        while ( Values[j] != NULL )
                        {
                            for ( i=0;i<NUM_OF_SPN;i++ )
                            {
                                if ( SPNs[i] && !_wcsicmp(SPNs[i],Values[j]) )
                                {
                                    found[i]=1;
                                }
                            }
                            j++;
                        }
                    }
                }
            }
        }
    }

    //clean up
    ldap_msgfree( SearchResult );

    // Fix up replication spn if necessary
    if (SPNs[dwReplSpnIndex] &&
        (!found[dwReplSpnIndex]) &&
        (gMainInfo.ulFlags & DC_DIAG_FIX)) {
        DWORD status;

        status = DsWriteAccountSpn( hDsBinding,
                                    DS_SPN_ADD_SPN_OP,
                                    Base,
                                    1,
                                    &(SPNs[dwReplSpnIndex])
                                    );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS,
                         L"Failed to fix computer account object %s by writing missing replication spn %s : error %s\n",
                         Base,
                         SPNs[dwReplSpnIndex],
                         Win32ErrToString(WinError));
        } else {
            PrintMessage(SEV_VERBOSE,
                         L"Fixed computer account object %s by writing missing replication spn %s.\n",
                         Base,
                         SPNs[dwReplSpnIndex] );
            found[dwReplSpnIndex] = TRUE;
        }
    }


    for ( i=0;i<NUM_OF_SPN;i++ )
    {
        if ( found[i] !=1 )
        {
            PrintMessage(SEV_ALWAYS,
                         L"* Missing SPN :%s\n",SPNs[i]);
            WinError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        } else
        {
            PrintMessage(SEV_VERBOSE,
                         L"* SPN found :%s\n",SPNs[i]);
        }

    }

    cleanup:
    if ( Base )
        free(Base);

    return WinError;

}




BOOL
GetNetBIOSDomainName(
                    OUT WCHAR                               **DomainName,
                    IN  WCHAR                               *ServerName,
                    IN  SEC_WINNT_AUTH_IDENTITY_W *         gpCreds)
/*++
 Code taken from Cliff Van Dyke
--*/
{
    NTSTATUS Status;
    NET_API_STATUS NetStatus = NERR_UnknownServer;

    PLSAPR_POLICY_INFORMATION PrimaryDomainInfo = NULL;
    LSAPR_HANDLE PolicyHandle = NULL;
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;
    NETRESOURCE NetResource;
    WCHAR *remotename=NULL;
    WCHAR *lpPassword=NULL;
    WCHAR *lpUsername=NULL;
    DWORD dwErr=NO_ERROR;
    BOOL  connected=FALSE;

    *DomainName = NULL;

    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;

    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));
    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwErr=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);
    if ( dwErr == NO_ERROR )
    {
        connected=TRUE;
    }
    else
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open pipe with [%s]:failed with %d: %s\n",
                     ServerName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    


    //
    // Open the LSA policy
    //

    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));



    if ( ServerName != NULL )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //
        DInitLsaString(&ServerString, ServerName);
        Server = &ServerString;
    } else
    {
        Server = NULL; // default to local machine
    }

    // Open a Policy
    Status = LsaOpenPolicy(
                          Server,
                          &ObjectAttributes,
                          POLICY_VIEW_LOCAL_INFORMATION,
                          &PolicyHandle
                          );

    //Assert(PolicyHandle);
    if ( !NT_SUCCESS(Status) )
    {
        WNetCancelConnection2(remotename,
                              0,
                              TRUE);
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Lsa Policy\n"
                     );
        goto cleanup;
    }
    *DomainName = NULL;
    
    //
    // Get the Primary Domain info from the LSA.
    //
    Status = LsaQueryInformationPolicy(
                                      PolicyHandle,
                                      PolicyDnsDomainInformation,
                                      &PrimaryDomainInfo );

    if ( !NT_SUCCESS(Status) )
    {
        goto cleanup;
    }

    *DomainName = malloc(
                        (PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length +
                         sizeof(WCHAR) ));
    if ( !*DomainName )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        goto cleanup;
    }

    memcpy(*DomainName,
           PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Buffer,
           PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length );

    (*DomainName)[
                 PrimaryDomainInfo->PolicyDnsDomainInfo.Name.Length /
                 sizeof(WCHAR)] = L'\0';


    NetStatus = NERR_Success;

    
    //
    // Return
    //
cleanup:
    if ( NetStatus != NERR_Success )
    {
        if ( *DomainName != NULL )
        {
            *DomainName = NULL;
        }
    }

    if ( PrimaryDomainInfo != NULL )
    {
        LsaFreeMemory( PrimaryDomainInfo );
    }

    if ( PolicyHandle != NULL )
    {
        Status = LsaClose( PolicyHandle );
        Assert( NT_SUCCESS(Status) );
    }
    if (connected)
    {
        WNetCancelConnection2(remotename,
                          0,
                          TRUE);
    }
    
    return(NetStatus == NERR_Success);
}    


DWORD
WrappedMakeSpnW(
               WCHAR   *ServiceClass,
               WCHAR   *ServiceName,
               WCHAR   *InstanceName,
               USHORT  InstancePort,
               WCHAR   *Referrer,
               DWORD   *pcbSpnLength, // Note this is somewhat different that DsMakeSPN
               WCHAR  **ppszSpn
               )
//this function wraps DsMakeSpnW for the purpose of memory
{
    DWORD cSpnLength=128;
    WCHAR SpnBuff[128];
    DWORD err;

    cSpnLength = 128;
    err = DsMakeSpnW(ServiceClass,
                     ServiceName,
                     InstanceName,
                     InstancePort,
                     Referrer,
                     &cSpnLength,
                     SpnBuff);

    if ( err && err != ERROR_BUFFER_OVERFLOW )
    {
        return err;
    }

    *ppszSpn = malloc(cSpnLength * sizeof(WCHAR));
    if ( !*ppszSpn )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pcbSpnLength = cSpnLength * sizeof(WCHAR);

    if ( err == ERROR_BUFFER_OVERFLOW )
    {
        err = DsMakeSpnW(ServiceClass,
                         ServiceName,
                         InstanceName,
                         InstancePort,
                         Referrer,
                         &cSpnLength,
                         *ppszSpn);
        if ( err )
        {
            if ( *ppszSpn )
                free(*ppszSpn);
            return err;
        }
    } else
    {
        memcpy(*ppszSpn, SpnBuff, *pcbSpnLength);
    }
    Assert(*pcbSpnLength == (sizeof(WCHAR) * (1 + wcslen(*ppszSpn))));
    // Drop the null off.
    *pcbSpnLength -= sizeof(WCHAR);
    return 0;
}


DWORD
getGUID(
       IN  PDC_DIAG_DSINFO                 pDsInfo,
       IN  ULONG                           ulCurrTargetServer,
       OUT WCHAR **                        pszServerGuid
       )
/*++

Routine Description:

    Will return the GUID of the current server
        
Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    pszServerGuid - the returning GUID
    
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD Length=0;
    WCHAR *ppszServerGuid=NULL;

    Length = wcslen( pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName);
    *pszServerGuid = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
    if ( !*pszServerGuid )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Failed with %d: %s\n",
                     ERROR_NOT_ENOUGH_MEMORY,
                     Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    wcscpy(*pszServerGuid,pDsInfo->pServers[ulCurrTargetServer].pszGuidDNSName);

    ppszServerGuid=*pszServerGuid;

    while ( *ppszServerGuid != L'.' )
    {
        ppszServerGuid++;
    }
    *ppszServerGuid=L'\0';


    return NO_ERROR;
}


BOOL
GetdnsMachine(LDAP *hLdap,
              WCHAR **ReturnString
             )
/*++

Routine Description:

    Will return the dnsName of the machine
        
Arguments:

   
    hLdap - handle to the LDAP server
    ReturnString - The dnsName of the machine
        
Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *DefaultFilter = L"objectClass=*";
    WCHAR        *Base=NULL;

    ULONG        Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the fSMORoleOwner
    //
    AttrsToSearch[0] = L"dnsHostName";
    AttrsToSearch[1] = NULL;

    //get the Base
    WinError = FindServerRef (hLdap,&Base);
    if ( WinError != NO_ERROR )
    {
        return FALSE;   
    }

    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( Base )
        free(Base);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return FALSE;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return FALSE;
                        }
                        wcscpy( *ReturnString, Values[0] );
                        return TRUE;
                    }
                }
            }
        }
    }

    ldap_msgfree( SearchResult );
    PrintMessage(SEV_ALWAYS,
                 L"Failed with %d: %s\n",
                 ERROR_DS_CANT_RETRIEVE_ATTS,
                 Win32ErrToString(ERROR_DS_CANT_RETRIEVE_ATTS));
    return FALSE;   
}




DWORD
CDCMA_CheckForExistence(
    IN  LDAP  * hLdap,
    IN  WCHAR * name,
    IN  WCHAR * defaultNamingContext
    )
/*++

Routine Description:

    Checks if the hLdap connection has an object with the samaccountname of
    "name".
        
Arguments:

    hLdap - handle to the LDAP server
    
    name -  the sam account name to check for
    
    defaultNamingContext - the domain to search under
        
Return Value:

    ERROR_SUCCESS  -- account exists
    ERROR_NO_TRUST_SAM_ACCOUNT
    Operational errors otherwise.

--*/
{

    DWORD        WinError = ERROR_SUCCESS;
    ULONG        LdapError;
    LDAPMessage  *SearchResult;
    ULONG        NumberOfEntries;
    WCHAR        BaseFilter[] = L"samaccountname=$";
    ULONG        Size;
    LPWSTR       Filter = NULL;
    WCHAR        *AttrArray[2] = {0, 0};

    AttrArray[0] = L"objectclass";

    Size = ( (wcslen( name )+1) * sizeof(WCHAR) ) + sizeof(BaseFilter);
    Filter = LocalAlloc( 0, Size );
    if ( Filter ) {
        wcscpy( Filter, L"samaccountname=" );
        wcscat( Filter, name );
        wcscat( Filter, L"$" );
    
        LdapError = ldap_search_sW(hLdap,
                                   defaultNamingContext,
                                   LDAP_SCOPE_SUBTREE,
                                   Filter,
                                   AttrArray,   // attrs
                                   FALSE,  // attrsonly
                                   &SearchResult);
    
    
        if (LdapError == LDAP_SUCCESS) {
    
            NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
            if (NumberOfEntries == 0) {
    
                WinError = ERROR_NO_TRUST_SAM_ACCOUNT;
            }
    
        } else {
    
            WinError = LdapMapErrorToWin32(LdapError);
        }

        LocalFree( Filter );

    } else {

        WinError = ERROR_NOT_ENOUGH_MEMORY;

    }

    return WinError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\example\example.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    example.c

ABSTRACT:

    Example for adding new tests to dcdiag.exe.

DETAILS:

CREATED:

    05-May-1999 JeffParh

--*/

#include <ntdspch.h>
#include "dcdiag.h"

DWORD 
ExampleMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
{
    ULONG ul;

    PrintMessage(SEV_NORMAL, L"GLOBAL:\n");
    
    PrintIndentAdj(1);
    PrintMessage(SEV_NORMAL, _T("ulNumServers=%u\n"     ), pDsInfo->ulNumServers                           );
    PrintMessage(SEV_NORMAL, _T("pszRootDomain=%s\n"    ), pDsInfo->pszRootDomain                          );
    PrintMessage(SEV_NORMAL, _T("pszNC=%s\n"            ), pDsInfo->pszNC                                  );
    PrintMessage(SEV_NORMAL, _T("pszRootDomainFQDN=%s\n"), pDsInfo->pszRootDomainFQDN                      );
    PrintMessage(SEV_NORMAL, _T("iSiteOptions=0x%x\n"   ), pDsInfo->iSiteOptions                           );
    PrintMessage(SEV_NORMAL, _T("HomeServer=%s\n",      ), pDsInfo->pServers[pDsInfo->ulHomeServer].pszName);
    PrintIndentAdj(-1);

    for (ul=0; ul < pDsInfo->ulNumServers; ul++) {
        PrintMessage(SEV_NORMAL, _T("\n"));
        PrintMessage(SEV_NORMAL, _T("SERVER[%d]:\n"), ul);
        
        PrintIndentAdj(1);
        PrintMessage(SEV_NORMAL, _T("pszName=%s\n"       ), pDsInfo->pServers[ul].pszName       );
        PrintMessage(SEV_NORMAL, _T("pszGuidDNSName=%s\n"), pDsInfo->pServers[ul].pszGuidDNSName);
        PrintMessage(SEV_NORMAL, _T("pszDn=%s\n"         ), pDsInfo->pServers[ul].pszDn         );
        PrintMessage(SEV_NORMAL, _T("iOptions=%x\n"      ), pDsInfo->pServers[ul].iOptions      ); 
        PrintIndentAdj(-1);
    }

    for (ul=0; ul < pDsInfo->ulNumTargets; ul++) {
        PrintMessage(SEV_NORMAL, _T("\n"));
        PrintMessage(SEV_NORMAL, _T("TARGET[%d]:\n"), ul);
        
        PrintIndentAdj(1);
        PrintMessage(SEV_NORMAL, _T("%s\n"), pDsInfo->pServers[pDsInfo->pulTargets[ul]].pszName);
        PrintIndentAdj(-1);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\rid.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    rid.c

ABSTRACT:

    Contains tests related to the rid master.  Tests to see if rid master is up and does
    sanity checks on it.

DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include "dcdiag.h"
#include "dstest.h"

//the threshold before the rid master allocate a new
//rid pool
#define CURRENTTHRESHOLD 20


//local prototypes
DWORD
CRM_GetDNSfor (
              IN  LDAP  *                     hLdap,
              IN  WCHAR *                     DN,
              OUT WCHAR **                    ReturnString);

DWORD
CRM_CheckLocalRIDSanity(
                       IN  LDAP  *                     hLdap,
                       IN  WCHAR *                     pszName,
                       IN  WCHAR *                     defaultNamingContext);

DWORD
GetRIDReference(
               IN  LDAP  *                      hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               OUT WCHAR **                    ReturnString);


DWORD
CheckRidManager (
                PDC_DIAG_DSINFO                     pDsInfo,
                ULONG                               ulCurrTargetServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will determine if the 
    Rid Master can be reached and will make sure that values in the rid master are
    sane.  Helper functions of this function all begin with "CRM_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying everything 
    about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server is being
    tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD  dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    LDAP   *hLdap = NULL;
    WCHAR  *defaultNamingContext=NULL;
    WCHAR  *RIDMasterDNS=NULL;
    HANDLE hDsBinding=NULL;

    //Assert(gpCreds);
    Assert(pDsInfo);

    //create a connection with the DS using LDAP
    dwErr = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 FALSE,
                                 &hLdap);

    if ( dwErr != LDAP_SUCCESS )
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        PrintMessage(SEV_ALWAYS,
                     L"[%s] LDAP bind failed with error %d. %s\n",
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }

    //find the defaultNamingContext
    dwErr=FinddefaultNamingContext(hLdap,&defaultNamingContext);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }



    //find the DNS of the rid master
    dwErr=CRM_GetDNSfor(hLdap,defaultNamingContext,&RIDMasterDNS);
    if ( dwErr != NO_ERROR )
    {
        goto cleanup;
    }

    PrintMessage(SEV_VERBOSE,
                 L"* %s is the RID Master\n",RIDMasterDNS);

    //Attempt to Bind with the rid master
    dwErr = DsBindWithCred(RIDMasterDNS,
                           NULL,
                           (RPC_AUTH_IDENTITY_HANDLE) gpCreds,
                           &hDsBinding);
    if ( dwErr != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"[%s] DsBindWithCred() failed to bind to %s with error %d. %s\n",  
                     pDsInfo->pServers[ulCurrTargetServer].pszName,
		     RIDMasterDNS,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    }
    PrintMessage(SEV_VERBOSE,
                 L"* DsBind with RID Master was successful\n");

    dwErr=CRM_CheckLocalRIDSanity(hLdap,pDsInfo->pServers[ulCurrTargetServer].pszName,
                                  defaultNamingContext);



    //final cleanup
    cleanup:
    if ( &hDsBinding )
        DsUnBind(&hDsBinding);
    if ( defaultNamingContext )
        free(defaultNamingContext);
    if ( RIDMasterDNS )
        free(RIDMasterDNS);
    return dwErr;


}




DWORD
CRM_GetDNSfor (
              IN  LDAP *                      hLdap,
              IN  WCHAR*                      Base,
              OUT WCHAR**                     ReturnString
              )

/*++

Routine Description:

    This function will return the FSMORoleMaster in DNS form so the it can
    be used for future searches.  It will also check the sanity of the available
    rid pool

Arguments:

    hLdap - handle to the LDAP server
    Base - The DefaultNamingContext
    ReturnString - The FSMORoleMaster in DNS form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[3];

    WCHAR        *DefaultFilter = L"objectClass=*";

    WCHAR        *rIDManagerReference=NULL;
    WCHAR        *fSMORoleOwner=NULL;
    WCHAR        *fSMORoleOwnerOffset=NULL;

    ULONG        Length;

    // Parameter check
    Assert( hLdap );

    // The default return
    *ReturnString=NULL;

    //
    // Read the reference to the rIDManagerReference
    //
    AttrsToSearch[0] = L"rIDManagerReference";
    AttrsToSearch[1] = NULL;


    //Find the rIDManagerReference
    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid manager reference failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        rIDManagerReference = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(rIDManagerReference, Values[0] );
                        break;
                    }
                }
            }
        }
    }

    if (rIDManagerReference == NULL) {
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
    } else if (IsDeletedRDNW( rIDManagerReference )) {
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_DELETED, Base );
        PrintMsg( SEV_ALWAYS, DCDIAG_RID_MANAGER_NO_REF, Base );
    } else {
        PrintMessage( SEV_DEBUG, L"ridManagerReference = %s\n", rIDManagerReference );
    }

    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( WinError != NO_ERROR )
    {
        goto cleanup;
    }

    AttrsToSearch[0] = L"fSMORoleOwner";
    AttrsToSearch[1] = L"rIDAvailablePool";
    AttrsToSearch[2] = NULL;

    //find the fSMORoleOwner
    LdapError = ldap_search_sW( hLdap,
                                rIDManagerReference,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for FSMO Role Owner failed with %d: %s\n",
                     rIDManagerReference,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        fSMORoleOwner = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(fSMORoleOwner, Values[0] );

                    }
                }
                //sanity check while here
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        WCHAR *AvailablePool =NULL;
                        ULONGLONG Lvalue=0;
                        ULONGLONG Hvalue=0;
                        Length = wcslen( Values[0] );
                        AvailablePool = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(AvailablePool, Values[0] );
                        //convert to a binary
                        Hvalue=Lvalue=_wtoi64(AvailablePool);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                            goto cleanup;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* Available RID Pool for the Domain is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                     }
                }
            }
        }
    }

    if (fSMORoleOwner == NULL) {
        PrintMessage( SEV_ALWAYS, L"Warning: attribute FSMORoleOwner missing from %s\n",
                      rIDManagerReference );
    } else if (IsDeletedRDNW( fSMORoleOwner )) {
        PrintMessage( SEV_ALWAYS, L"Warning: FSMO Role Owner is deleted.\n" );
    } else {
        PrintMessage( SEV_DEBUG, L"fSMORoleOwner = %s\n", fSMORoleOwner );
    }

    //clean up
    if ( SearchResult )
        ldap_msgfree( SearchResult );

    //Finally find and return the DNS of the rid master.


    //Point pass  the first part of the fSMORoleOwner DN
    WrappedTrimDSNameBy(fSMORoleOwner,1,&fSMORoleOwnerOffset);


    AttrsToSearch[0] = L"dNSHostName";
    AttrsToSearch[1] = NULL;



    LdapError = ldap_search_sW( hLdap,
                                fSMORoleOwnerOffset,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for hostname failed with %d: %s\n",
                     fSMORoleOwnerOffset,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            WinError = ERROR_NOT_ENOUGH_MEMORY;
                            goto cleanup;
                        }

                        wcscpy(*ReturnString, Values[0] );
                        break;
                    }
                }
            }
        }
    }

    //clean up
    cleanup:
    if ( fSMORoleOwnerOffset )
        free(fSMORoleOwnerOffset);
    if ( SearchResult )
        ldap_msgfree( SearchResult );


    return WinError;

}

DWORD
CRM_CheckLocalRIDSanity(
                       IN  LDAP  *                     hLdap,
                       IN  WCHAR *                     pszName,
                       IN  WCHAR *                     defaultNamingContext)
/*++

Routine Description:

    This function will check the sanity of the information that is found
    in the rid set

Arguments:

    hLdap - handle to the LDAP server 
    pszName - A wchar string that will be used to build the base for a ldap search
    ReturnString - A wchar string that will be used to build the base for a ldap search

Return Value:

    A WinError is return to indicate if there were any problems.

--*/

{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[4];

    WCHAR        *DefaultFilter = L"objectClass=*";
    WCHAR        *StringtoConvert=NULL;
    WCHAR        *Base=NULL;

    DWORD        rIDNextRID=0;
    ULONGLONG    rIDPreviousAllocationPool=0;
    ULONGLONG    rIDAllocationPool=0;

    ULONGLONG    Lvalue=0;
    ULONGLONG    Hvalue=0;
    DWORD        PercentRemaining=0;
    ULONG        TotalRidsInPool;

    ULONG        Length;

    //check parameters
    Assert(pszName);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"rIDNextRID";
    AttrsToSearch[1]=L"rIDPreviousAllocationPool";
    AttrsToSearch[2]=L"rIDAllocationPool";
    AttrsToSearch[3]=NULL;

    //built the Base
    WinError=GetRIDReference(hLdap,pszName,defaultNamingContext,&Base);
    if ( WinError == ERROR_DS_CANT_RETRIEVE_ATTS )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not get Rid set Reference :failed with %d: %s\n",
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    //find the attributes and do sanity checks on them

    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                DefaultFilter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);

    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid info failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        goto cleanup;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        Length = wcslen( Values[0] );
                        StringtoConvert = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(StringtoConvert, Values[0] );

                        //convert to a binary
                        rIDNextRID=_wtoi(StringtoConvert);

                        PrintMessage(SEV_VERBOSE,L"* rIDNextRID: %ld\n",rIDNextRID);

                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[1] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A LARGE_INTERGER in string format
                        Length = wcslen( Values[0] );
                        StringtoConvert = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(StringtoConvert, Values[0] );

                        //convert to a binary
                        Hvalue=Lvalue=rIDPreviousAllocationPool=_wtoi64(StringtoConvert);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* rIDPreviousAllocationPool is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                    }
                }
                if ( !_wcsicmp( Attr, AttrsToSearch[2] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        //A ULONGLONG in string format
                        Length = wcslen( Values[0] );
                        StringtoConvert = (WCHAR*) alloca( (Length+1)*sizeof(WCHAR) );
                        wcscpy(StringtoConvert, Values[0] );

                        //convert to a binary
                        Hvalue=Lvalue=rIDAllocationPool=_wtoi64(StringtoConvert);
                        //LowPart
                        Lvalue<<=32;
                        Lvalue>>=32;
                        //Highpart
                        Hvalue>>=32;
                        //sanity checks
                        if ( Hvalue - Lvalue <= 0 )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"The DS has corrupt data: %s value is not valid\n",
                                         AttrsToSearch[1]);
                            WinError = ERROR_DS_CODE_INCONSISTENCY;
                        }
                        PrintMessage(SEV_VERBOSE,
                                     L"* rIDAllocationPool is %I64d to %I64d\n",
                                     Lvalue,
                                     Hvalue);
                    }
                }

            }
        }

    }

    //sanity checks
    Hvalue=Lvalue=rIDPreviousAllocationPool;
    //LowPart
    Lvalue<<=32;
    Lvalue>>=32;
    //Highpart
    Hvalue>>=32;
    //sanity checks
    TotalRidsInPool = (ULONG)(Hvalue-Lvalue);
    if ( TotalRidsInPool != 0 )
    {
        PercentRemaining = (ULONG)(100-((rIDNextRID-Lvalue)*100/TotalRidsInPool));
        if ( PercentRemaining < CURRENTTHRESHOLD )
        {
            if ( rIDPreviousAllocationPool == rIDAllocationPool )
            {
                PrintMessage(SEV_VERBOSE,
                             L"* Warning :Next rid pool not allocated\n");
            }
            PrintMessage(SEV_VERBOSE,
                         L"* Warning :There is less than %ld%% available RIDs in the current pool\n",
                         PercentRemaining);
        }

    }
    else
    {

        PrintMessage(SEV_ALWAYS,
                     L"No rids allocated -- please check eventlog.\n");


    }
    if ( rIDNextRID < Lvalue || rIDNextRID > Hvalue )
    {
        PrintMessage(SEV_ALWAYS,
                     L"The DS has corrupt data: rIDNextRID value is not valid\n");
        WinError = ERROR_DS_CODE_INCONSISTENCY;
    }

    cleanup:
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    if ( Base )
        free(Base);

    return WinError;


}

DWORD
GetRIDReference(
               IN  LDAP  *                     hLdap,
               IN  WCHAR *                     name,
               IN  WCHAR *                     defaultNamingContext,
               OUT WCHAR **                    ReturnString
               )
/*++

Routine Description:

    This function will return the RID set reference

Arguments:

    hLdap - handle to the LDAP server
    name - The NetBIOS name of the current server
    defaultNamingContext - the Base of the search
    ReturnString - The RID set reference in DN form

Return Value:

    A WinError is return to indicate if there were any problems.

--*/
{
    DWORD WinError = ERROR_SUCCESS;

    ULONG        LdapError = LDAP_SUCCESS;

    LDAPMessage  *SearchResult = NULL;
    ULONG        NumberOfEntries;

    WCHAR        *AttrsToSearch[2];

    WCHAR        *filter = NULL;
    WCHAR        *Base = NULL;

    ULONG         Length;

    //check parameters
    Assert(hLdap);
    Assert(name);
    Assert(defaultNamingContext);

    AttrsToSearch[0]=L"rIDSetReferences";
    AttrsToSearch[1]=NULL;

    //built the filter
    filter=L"objectClass=*";


    WinError = GetMachineReference(hLdap,name,defaultNamingContext,&Base);
    if ( WinError != NO_ERROR )
    {
        return WinError;
    }


    LdapError = ldap_search_sW( hLdap,
                                Base,
                                LDAP_SCOPE_BASE,
                                filter,
                                AttrsToSearch,
                                FALSE,
                                &SearchResult);
    if ( LDAP_SUCCESS != LdapError )
    {
        WinError = LdapMapErrorToWin32(LdapError);
        PrintMessage(SEV_ALWAYS,
                     L"ldap_search_sW of %s for rid set references failed with %d: %s\n",
                     Base,
                     WinError,
                     Win32ErrToString(WinError));
        return WinError;
    }

    NumberOfEntries = ldap_count_entries(hLdap, SearchResult);
    if ( NumberOfEntries > 0 )
    {
        LDAPMessage *Entry;
        WCHAR       *Attr;
        WCHAR       **Values;
        BerElement  *pBerElement;

        for ( Entry = ldap_first_entry(hLdap, SearchResult);
            Entry != NULL;
            Entry = ldap_next_entry(hLdap, Entry) )
        {
            for ( Attr = ldap_first_attributeW(hLdap, Entry, &pBerElement);
                Attr != NULL;
                Attr = ldap_next_attributeW(hLdap, Entry, pBerElement) )
            {
                if ( !_wcsicmp( Attr, AttrsToSearch[0] ) )
                {

                    //
                    // Found it - these are NULL-terminated strings
                    //
                    Values = ldap_get_valuesW( hLdap, Entry, Attr );
                    if ( Values && Values[0] )
                    {
                        ldap_msgfree( SearchResult );
                        Length = wcslen( Values[0] );
                        *ReturnString = (WCHAR*) malloc( (Length+1)*sizeof(WCHAR) );
                        if ( !*ReturnString )
                        {
                            PrintMessage(SEV_ALWAYS,
                                         L"Failed with %d: %s\n",
                                         ERROR_NOT_ENOUGH_MEMORY,
                                         Win32ErrToString(ERROR_NOT_ENOUGH_MEMORY));
                            return ERROR_NOT_ENOUGH_MEMORY;
                        }
                        wcscpy( *ReturnString, Values[0] );

                        if (IsDeletedRDNW( *ReturnString )) {
                            PrintMessage( SEV_ALWAYS, L"Warning: rid set reference is deleted.\n" );
                        } else {
                            PrintMessage( SEV_DEBUG, L"rIDSetReferences = %s\n", *ReturnString );
                        }

                        return NO_ERROR;
                    }
                }
            }
        }
    }

    PrintMessage( SEV_ALWAYS,
                  L"Warning: attribute rIdSetReferences missing from %s\n",
                  Base );
    
    if ( SearchResult )
        ldap_msgfree( SearchResult );
    return ERROR_DS_CANT_RETRIEVE_ATTS;



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\ds\services.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    services.c

ABSTRACT:

    Will test to see if critical DC services are running
    
DETAILS:

CREATED:

    8 July 1999  Dmitry Dukat (dmitrydu)

REVISION HISTORY:
        
    20 August 1999 Brett Shirley (brettsh) - Generalized this file to do many
    services instead of just netlogon.

--*/



#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <lmsname.h>
#include <lsarpc.h>                     // PLSAPR_foo

#include "dcdiag.h"
#include "ldaputil.h"
#include "dstest.h"


DWORD
CNLR_QueryResults(
                 WCHAR *                ServerName,
                 SC_HANDLE              hService,
                 LPSERVICE_STATUS       lpServiceStatus,
                 LPWSTR                 pszService
                 );

DWORD
CFSR_CheckForService(
                PDC_DIAG_SERVERINFO                 prgServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
                SC_HANDLE                           hSCManager,
                LPWSTR                              pszService
                )
/*++

Routine Description:

    Will check to see if the specified service is running.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    SC_HANDLE        hService=NULL;
    SERVICE_STATUS   lpServiceStatus;
    BOOL             success=FALSE;
    DWORD            dwErr=NO_ERROR;

    //open the requested service (pszService)
    hService=OpenService(hSCManager,
                         pszService,
                         SERVICE_QUERY_STATUS);
    if ( hService == NULL )
    {
        dwErr = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not open %s Service on [%s]:failed with %d: %s\n",
                     pszService,
                     prgServer->pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    } 

    //query Netlogon
    success=QueryServiceStatus(hService,
                               &lpServiceStatus);
    if ( !success )
    {
        dwErr = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not query %s Service on [%s]:failed with %d: %s\n",
                     pszService,
                     prgServer->pszName,
                     dwErr,
                     Win32ErrToString(dwErr));
        goto cleanup;
    } 
    
    dwErr=CNLR_QueryResults(prgServer->pszName,
                            hService,
                            &lpServiceStatus,
                            pszService);
    
      
    //cleanup
cleanup:
    
    if(hService)
        CloseServiceHandle(hService);

    return dwErr;
}


DWORD
CNLR_QueryResults(WCHAR *                ServerName,
                  SC_HANDLE              hService,
                  LPSERVICE_STATUS       lpServiceStatus,
                  LPWSTR                 pszService)
/*++

Routine Description:

    Will report the state of Service.  And will report if
    Service is hung in a pending state
    
Arguments:

    ServerName - The name of the server running the service
    hService - A handle to the service being tested
    lpServiceStatus - the stucture that will be queried


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    DWORD dwErr=NO_ERROR;
    BOOL  success=TRUE;

    //look at the results of the query
    if (lpServiceStatus->dwCurrentState == SERVICE_RUNNING)
    {
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_STOPPED)
    {
        PrintMessage(SEV_ALWAYS,
                     L"%s Service is stopped on [%s]\n",
                     pszService, 
                     ServerName);
        dwErr = ERROR_SERVICE_NOT_ACTIVE;
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_PAUSED)
    {
        PrintMessage(SEV_ALWAYS,
                     L"%s Service is paused on [%s]\n",
                     pszService, 
                     ServerName);
        dwErr = ERROR_SERVICE_NOT_ACTIVE;
        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to start on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_START_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung starting on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_VERBOSE,
                     L"* %s Service has started on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to continue on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_CONTINUE_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending continue on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_VERBOSE,
                     L"* %s Service has started on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to stop on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,                   
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_STOP_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending stop on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_ALWAYS,
                     L"* %s Service has stopped on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    if (lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
    {
        DWORD i=0;
        DWORD wait=0;
        DWORD Check=lpServiceStatus->dwCheckPoint;  //make sure that service is starting
        
        PrintMessage(SEV_VERBOSE,
                     L"* waiting for %s Service to pause on [%s] aproximate time to wait is %d sec.",
                     pszService, 
                     ServerName,
                     lpServiceStatus->dwWaitHint/1000);
        while(lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
        {
            //print a period every 1/10th the wait time
            wait=lpServiceStatus->dwWaitHint/10;
            for(i=0;i<10;i++)
            {
                Sleep(wait);
                PrintMsg0( SEV_VERBOSE, DCDIAG_DOT );
            }
            //query Service
            success=QueryServiceStatus(hService,
                                       lpServiceStatus);
            if ( !success )
            {
                dwErr = GetLastError();
                PrintMessage(SEV_ALWAYS,
                             L"\nCould not query %s Service on [%s]:failed with %d: %s\n",
                             pszService, 
                             ServerName,
                             dwErr,
                             Win32ErrToString(dwErr));
                return dwErr;
            }
            if(Check == lpServiceStatus->dwCheckPoint &&
               lpServiceStatus->dwCurrentState == SERVICE_PAUSE_PENDING)
            {
                dwErr=ERROR_SERVICE_START_HANG;
                PrintMessage(SEV_ALWAYS,
                     L"\nError: %s Service is hung pending pause on [%s]\n",
                             pszService, 
                             ServerName);
                return dwErr;
            }
            Check=lpServiceStatus->dwCheckPoint;
        }
        
        PrintMessage(SEV_VERBOSE,L"\n");
        PrintMessage(SEV_ALWAYS,
                     L"* %s Service has paused on [%s]\n",
                     pszService, 
                     ServerName);

        return dwErr;
    }
    dwErr=ERROR_SERVICE_START_HANG;
    PrintMessage(SEV_ALWAYS,
                 L"Error: %s Service is in an unknown state [%s]\n",
                 pszService, 
                 ServerName);
    return dwErr;
}

BOOL
ServerUsesMBR(
    PDC_DIAG_DSINFO                        pDsInfo,
    ULONG                                  iServer
    )

{
    LPWSTR                 pszServerDn = NULL;
    LPWSTR                 pszResult = NULL;
    DWORD                  dwRet = FALSE;

    __try{
        pszServerDn = DcDiagTrimStringDnBy(pDsInfo->pServers[iServer].pszDn, 1);
        if(pszServerDn == NULL){
            dwRet = FALSE;
            __leave;
        }
        DcDiagGetStringDsAttribute(&(pDsInfo->pServers[iServer]), pDsInfo->gpCreds,
                                   pszServerDn, L"mailAddress",
                                   &pszResult);
        
        if(pszResult == NULL){
            dwRet = FALSE;
            __leave;
        }
        dwRet = TRUE;
    } __finally {
        if(pszServerDn != NULL){ LocalFree(pszServerDn); }
    }
    return(dwRet);
}


DWORD
CheckForServicesRunning(
                PDC_DIAG_DSINFO                     pDsInfo,
                ULONG                               ulCurrTargetServer,
                SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
                )
/*++

Routine Description:

    Routine is a test to check whether various services that are 
    critical to a DC are running.
    
Arguments:

    ServerName - The name of the server that we will check
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    A Win32 Error if any tests failed to check out.

--*/

{
    NETRESOURCE      NetResource;
    WCHAR            *remotename=NULL;
    WCHAR            *lpPassword=NULL;
    WCHAR            *lpUsername=NULL;
    WCHAR            *ServerName=NULL;
    SC_HANDLE        hSCManager=NULL;
    ULONG            iService;
    DWORD            dwRet;
    DWORD            dwErr;
    // These are the services to check, I used the constants when
    //    they could be found, and otherwise I used the string that
    //    specifies them.  Sorry it is ugly, but I wanted to keep
    //    the history.
    // Critical DC Services
    LPWSTR           ppszCritDcSrvs [] = {
        L"Dnscache",
        SERVICE_NTFRS, //        L"NtFrs",
        SERVICE_ISMSERV, //        L"IsmServ",
        SERVICE_KDC, //        L"kdc",
        L"SamSs",
        SERVICE_SERVER, //        L"lanmanserver",
        SERVICE_WORKSTATION, //        L"LanmanWorkstation",
        L"RpcSs",
        SERVICE_RPCLOCATOR, //        L"RpcLocator",
        SERVICE_W32TIME, //        L"W32Time",
        SERVICE_TRKWKS, //        L"TrkWks",
        SERVICE_TRKSVR, //        L"TrkSvr",
        SERVICE_NETLOGON, //        L"Netlogon",
        NULL
    };
    // Critical Services to a DC that uses Mail Based Repl
    LPWSTR           ppszCritMailSrvs [] = {
        L"IISADMIN",
        L"SMTPSVC",
        NULL
    };
    
    ServerName=pDsInfo->pServers[ulCurrTargetServer].pszName;

    if(!gpCreds)
    {
        lpUsername=NULL;
        lpPassword=NULL;
    }
    else
    {
        lpUsername=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Domain)+wcslen(gpCreds->User)+2));
        wsprintf(lpUsername,L"%s\\%s",gpCreds->Domain,gpCreds->User);
        
        lpPassword=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(gpCreds->Password)+1));
        wcscpy(lpPassword,gpCreds->Password);           
    }

    remotename=(WCHAR*)alloca(sizeof(WCHAR)*(wcslen(L"\\\\\\ipc$")+wcslen(ServerName)+1));
    wsprintf(remotename,L"\\\\%s\\ipc$",ServerName);

    NetResource.dwType=RESOURCETYPE_ANY;
    NetResource.lpLocalName=NULL;
    NetResource.lpRemoteName=remotename;
    NetResource.lpProvider=NULL;

    //get permission to access the server
    dwRet=WNetAddConnection2(&NetResource,
                             lpPassword,
                             lpUsername,
                             0);

    if ( dwRet != NO_ERROR )
    {
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Remote ipc to [%s]:failed with %d: %s\n",
                     ServerName,
                     dwRet,
                     Win32ErrToString(dwRet));
        remotename = NULL;
        goto cleanup;
    } 

    //open the service control manager
    hSCManager=OpenSCManager(
                      ServerName,
                      SERVICES_ACTIVE_DATABASE,
                      GENERIC_READ);
    if ( hSCManager == NULL )
    {
        dwRet = GetLastError();
        PrintMessage(SEV_ALWAYS,
                     L"Could not open Service Control Manager on [%s]:failed with %d: %s\n",
                     ServerName,
                     dwRet,
                     Win32ErrToString(dwRet));
        goto cleanup;
    } 

    // Check for the critical DC services.
    for(iService = 0; ppszCritDcSrvs[iService] != NULL; iService++){
        PrintMessage(SEV_VERBOSE, L"* Checking Service: %s\n", ppszCritDcSrvs[iService]);
        PrintIndentAdj(1);
        dwErr = CFSR_CheckForService(&(pDsInfo->pServers[ulCurrTargetServer]),
                                     gpCreds,
                                     hSCManager,
                                     ppszCritDcSrvs[iService]);
        PrintIndentAdj(-1);
        if(dwErr != ERROR_SUCCESS){
            dwRet = dwErr;
        }
    }

    // If this server uses MBR (mail based replication) then check for critical MBR DC services.
    if(ServerUsesMBR(pDsInfo, ulCurrTargetServer)){
        for(iService = 0; ppszCritMailSrvs[iService] != NULL; iService++){
            PrintMessage(SEV_VERBOSE, L"* Checking Service: %s\n", ppszCritDcSrvs[iService]);
            PrintIndentAdj(1);
            dwErr = CFSR_CheckForService(&(pDsInfo->pServers[ulCurrTargetServer]),
                                         gpCreds,
                                         hSCManager,
                                         ppszCritMailSrvs[iService]);
            PrintIndentAdj(-1);
            if(dwErr != ERROR_SUCCESS){
                dwRet = dwErr;
            }
        }
    }
      
    //cleanup
cleanup:
    if(hSCManager)
        CloseServiceHandle(hSCManager);
    if(remotename)
        WNetCancelConnection2(remotename, 0, TRUE);

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\frs\frsevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\frsevent.c

ABSTRACT:

    Check the File Replication System (frs) eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

#include <ntdspch.h>
#include <netevent.h>

#include "dcdiag.h"
#include "utils.h"

// Notes on some FRS events.
//  EVENT_FRS_SYSVOL_READY 0x400034CC
//  EVENT_FRS_STARTING
//  EVENT_FRS_ERROR 0xC00034BC
//  EVENT_FRS_SYSVOL_NOT_READY_PRIMARY 0x800034CB
//  EVENT_FRS_SYSVOL_NOT_READY 0x800034CA

#define   LOGFILENAME            L"File Replication Service"
BOOL gbFrsEventTestThereAreErrors = FALSE;

VOID
FileReplicationFoundBeginningEvent(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This file will be called by the event tests library common\events.c, when
    the beginning event (EVENT_FRS_SYSVOL_READY) is found.  If the event is
    not found, then the function is called with pEvent = NULL;

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    if(pEvent == NULL || pEvent->EventID != EVENT_FRS_SYSVOL_READY){
        PrintMessage(SEV_ALWAYS,
                     L"Error: No record of File Replication System, SYSVOL "
                     L"started.\n");
        PrintMessage(SEV_ALWAYS,
                    L"The Active Directory may be prevented from starting.\n");
    } else {
        PrintMessage(SEV_VERBOSE, 
                     L"The SYSVOL has been shared, and the AD is no longer\n");
        PrintMessage(SEV_VERBOSE, 
                     L"prevented from starting by the File Replication "
                     L"Service.\n");
    }
}

VOID
FileReplicationEventlogPrint(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings EVENT_FRS_SYSVOL_NOT_READY and 
    EVENT_FRS_SYSVOL_NOT_READY_PRIMARY.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    Assert(pEvent != NULL);

    if(!gbFrsEventTestThereAreErrors){
        PrintMessage(SEV_ALWAYS, 
                     L"There are errors after the SYSVOL has been shared.\n");
        PrintMessage(SEV_ALWAYS, 
                     L"The SYSVOL can prevent the AD from starting.\n");
        gbFrsEventTestThereAreErrors = TRUE;
    }
    if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            GenericPrintEvent(LOGFILENAME, pEvent, TRUE);
    }
}



DWORD
CheckFileReplicationEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

ERoutine Description:

    This checks that the SYSVOL has started, and is allowing netlogon to 
    advertise this machine as a DC.  First it checks the registry failing
    this, it checks the eventlog.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD                paEmptyEvents [] = { 0 };
    DWORD                paSelectEvents [] = 
        { EVENT_FRS_SYSVOL_NOT_READY,
          EVENT_FRS_SYSVOL_NOT_READY_PRIMARY,
          0 };
    DWORD                paBegin [] = 
        { EVENT_FRS_STARTING,
          EVENT_FRS_SYSVOL_READY,
          0 };
    DWORD                dwRet;
    DWORD                bSysVolReady = FALSE;

    PrintMessage(SEV_VERBOSE, 
                 L"* The File Replication Service Event log test\n");

    dwRet = GetRegistryDword(&(pDsInfo->pServers[ulCurrTargetServer]),
                             gpCreds,
                             L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
                             L"SysvolReady",
                             &bSysVolReady);

    if(dwRet == ERROR_SUCCESS && bSysVolReady){
        // The sysvol is ready according to the registry.
        PrintMessage(SEV_VERBOSE,
                     L"File Replication Service's SYSVOL is ready\n");
    } else {
        // Either the registry couldn't be contacted or the registry said
        //   that the SYSVOL was not up.  So check the evenlog for errors
        //   and specific warnings.

        PrintMessage(SEV_DEBUG, 
                   L"The registry lookup failed to determine the state of\n");
        PrintMessage(SEV_DEBUG, 
                   L"the SYSVOL. Using the systems event log instead.\n");

        dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                                  pDsInfo->gpCreds,
                                  LOGFILENAME,
                                  EVENTLOG_WARNING_TYPE,
                                  paSelectEvents,
                                  paBegin,
                                  0, // no time limit
                                  FileReplicationEventlogPrint,
                                  FileReplicationFoundBeginningEvent,
                                  NULL );
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\alltests.h ===
//+----------------------------------------------------------------------------  
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    alltests.h

ABSTRACT:

    Contains information about each test.

DETAILS:

    To add a new test:
    
    1. Add new DC_DIAG_ID_* for your test.
    2. Add a prototype for new function.
    3. Add entry in allTests[].
    4. Add test specific command line options in to the clOptions array
    
CREATED:

    09 Jul 98    Aaron Siegel (t-asiege)

REVISION HISTORY:

    22 Aug 99    Dmitry Dukat (dmitrydu)
    
        Added support for test specific command line args

--*/

// Prototypes for the test entry functions

#ifndef _ALLTESTS_H_
#define _ALLTESTS_H_

#define DNS_DOMAIN_ARG L"/DnsDomain:"
#define NEW_FOREST_ARG L"/NewForest"
#define NEW_TREE_ARG L"/NewTree"
#define CHILD_DOMAIN_ARG L"/ChildDomain"
#define REPLICA_DC_ARG L"/ReplicaDC"
#define FOREST_ROOT_DOMAIN_ARG L"/ForestRoot:"

// Constants for names of tests
#define RPC_SERVICE_CHECK_STRING          L"RPC Service Check"
#define REPLICATIONS_CHECK_STRING         L"Replications Check"
#define TOPOLOGY_INTEGRITY_CHECK_STRING   L"Topology Integrity Check"

// Test flags
//    The 3 flags RUN_TEST_PER_SERVER, RUN_TEST_PER_SITE, 
//    RUN_TEST_PER_ENTERPRISE should not be used together, or the test will be
//    called once per server, once per site, and once for the enterprise.
//    The 2 flags, CAN_NOT_SKIP_TEST and DO_NOT_RUN_TEST_BY_DEFAULT are also
//    mutually exclusive for obvious reasons.
//    NON_DC_TEST means the test applies to machines that are not (yet) DCs.
#define RUN_TEST_PER_SERVER               0x00000001
#define RUN_TEST_PER_SITE                 0x00000002
#define RUN_TEST_PER_ENTERPRISE           0x00000004
#define CAN_NOT_SKIP_TEST                 0x00000010
#define DO_NOT_RUN_TEST_BY_DEFAULT        0x00000020
#define NON_DC_TEST                       0x00000040

#define MAX_NUM_OF_ARGS                   50

// Type definitions
typedef enum _DC_DIAG_ID {
    DC_DIAG_ID_INITIAL_CHECK,
    DC_DIAG_ID_REPLICATIONS_CHECK,
    DC_DIAG_ID_TOPOLOGY_INTEGRITY,
    DC_DIAG_ID_CHECK_NC_HEADS,
    DC_DIAG_ID_CHECK_NET_LOGONS,
    DC_DIAG_ID_INTERSITE_HEALTH,
    DC_DIAG_ID_LOCATOR_GET_DC,
    DC_DIAG_ID_GATHER_KNOWN_ROLES,
    DC_DIAG_ID_CHECK_ROLES,
    DC_DIAG_ID_CHECK_RID_MANAGER,
    DC_DIAG_ID_CHECK_DC_MACHINE_ACCOUNT,
    DC_DIAG_ID_CHECK_SERVICES_RUNNING,
    DC_DIAG_ID_CHECK_DC_OUTBOUND_SECURE_CHANNELS,
    DC_DIAG_ID_CHECK_OBJECTS,
    DC_DIAG_ID_TOPOLOGY_CUTOFF,
    DC_DIAG_ID_CHECK_FILE_REPLICATION_EVENTLOG,
    DC_DIAG_ID_CHECK_KCC_EVENTLOG,
    DC_DIAG_ID_CHECK_SYSTEM_EVENTLOG,
    //DC_DIAG_ID_DNS_JOIN_CHECK, postponed, functionality in netdiag
    DC_DIAG_ID_PRE_PROMO_DNS_CHECK,
    DC_DIAG_ID_REGISTER_DNS_CHECK,
    // <-- insert new tests here
    DC_DIAG_ID_EXAMPLE,
    DC_DIAG_ID_FINISHED // This MUST be the last enum.
} DC_DIAG_ID;

DWORD ReplUpCheckMain                         (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplReplicationsCheckMain               (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplToplIntegrityMain                   (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplToplCutoffMain                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckNcHeadSecurityDescriptorsMain  (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckLogonPrivilegesMain            (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplIntersiteHealthTestMain             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplLocatorGetDcMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckFsmoRoles                          (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckRolesMain                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ExampleMain                             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckRidManager                         (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckDCMachineAccount                   (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckForServicesRunning                 (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckOutboundSecureChannels             (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD ReplCheckObjectsMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckFileReplicationEventlogMain        (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckKccEventlogMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD CheckSysEventlogMain                    (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
//DWORD JoinDomainDnsCheck                      (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD PrePromoDnsCheck                        (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);
DWORD RegisterLocatorDnsCheck                 (PDC_DIAG_DSINFO, ULONG, SEC_WINNT_AUTH_IDENTITY_W *);

#ifdef INCLUDE_ALLTESTS_DEFINITION
const DC_DIAG_TESTINFO allTests[] = {

    // DNS Registration Test -- checks if the DNS names are properly 
    // registered.  This tries to DsBind to each target server by GUID DNS 
    // name.  If it fails, the corresponding pDsInfo->pServers[i].bResponding
    // flag is set FALSE. It then tries other (LDAP) method of binding, and 
    // checks for the DNS name, pingability, etc.
    { DC_DIAG_ID_INITIAL_CHECK, ReplUpCheckMain, 
      RUN_TEST_PER_SERVER | CAN_NOT_SKIP_TEST,
      L"Connectivity",
      L"Tests whether DCs are DNS registered, pingeable, and\n"
      L"\t\thave LDAP/RPC connectivity." },

    // Replications Check Test -- checks to make sure that LDAP is responding 
    // on all servers.  Also checks all replications in all NCs on all 
    // servers, to make sure they are functioning properly.
    { DC_DIAG_ID_REPLICATIONS_CHECK, ReplReplicationsCheckMain,
      RUN_TEST_PER_SERVER,
      L"Replications",
      L"Checks for timely replication between domain controllers." },

    // Topology integrity check -- checks if the topology is properly 
    // connected. This test runs DsReplicaSyncAll on all servers with option
    // DS_REPSYNCALL_DO_NOT_SYNC.  This will check to make sure all servers
    // are "visible" along the graph from all other servers.  The test looks 
    // only at the actual topology defined by each server's config container,
    // without taking into account unresponsive servers (those are handled by
    // earlier tests.)
    { DC_DIAG_ID_TOPOLOGY_INTEGRITY, ReplToplIntegrityMain,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"Topology",
      L"Checks that the generated topology is fully connected for\n"
      L"\t\tall DCs." },

    // Check for servers that are cutoff from changes
    { DC_DIAG_ID_TOPOLOGY_CUTOFF, ReplToplCutoffMain,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"CutoffServers",
      L"Check for servers that won't receive replications\n"
      L"\t\tbecause its partners are down"},

    // Check the Naming Context Heads for appropriate security descriptors 
    // that allow the 3 replication rights (DS-Replication-Get-Changes, 
    // DS-Replication-Syncronize, and DS-Replication-Manage-Topology) to the
    // Enterprise Domain Controllers and the Builtin Administrators.  These 
    // are needed for replication to happen correctly.
    { DC_DIAG_ID_CHECK_NC_HEADS, ReplCheckNcHeadSecurityDescriptorsMain,
      RUN_TEST_PER_SERVER,
      L"NCSecDesc",
      L"Checks that the security descriptosrs on the naming\n"
      L"\t\tcontext heads have appropriate permissions for replication." },

    // Check that 3 users (Authenticated Users, Builtin Administrators, and 
    // World) have the network logon right.  Truely we only should check if
    // Authenticated Users need
    // it for replication purposes.
    { DC_DIAG_ID_CHECK_NET_LOGONS, ReplCheckLogonPrivilegesMain,
      RUN_TEST_PER_SERVER,
      L"NetLogons",
      L"Checks that the appropriate logon priviledges allow\n"
      L"\t\treplication to proceed." },

    // Check whether each DC is advertising itself.
    { DC_DIAG_ID_LOCATOR_GET_DC, ReplLocatorGetDcMain,
      RUN_TEST_PER_SERVER,
      L"Advertising",
      L"Checks whether each DC is advertising itself, and whether\n"
      L"\t\tit is advertising itself as having the capabilities of a DC." },

    // Code.Improvement ...
    // This should be the per server portion of the RoleHolders test, what
    // really needs to happen is that these need to be recorded in pDsInfo,
    // so that later the ENTERPRISE portion of RoleHolders test can be used
    // to verify that everyone things the role holders are the same.
    { DC_DIAG_ID_GATHER_KNOWN_ROLES, CheckFsmoRoles,
      RUN_TEST_PER_SERVER,
      L"KnowsOfRoleHolders",
      L"Check whether the DC thinks it knows the role\n"
      L"\t\tholders, and prints these roles out in verbose mode." },

    // Check for the health of intersite replication. This test will report 
    // any failures in intersite replication, any failures likely to affect
    // intersite replication, and finally when to expect those errors to be
    // corrected.
    { DC_DIAG_ID_INTERSITE_HEALTH, ReplIntersiteHealthTestMain,
      RUN_TEST_PER_ENTERPRISE,
      L"Intersite",
      L"Checks for failures that would prevent or temporarily\n"
      L"\t\thold up intersite replication." },

    // Verify whether role holders can be found via the locator
    // Also verify that FSMO roles are actively held
    { DC_DIAG_ID_CHECK_ROLES, ReplCheckRolesMain,
      RUN_TEST_PER_ENTERPRISE,
      L"FsmoCheck",
      L"Checks that global role-holders are known, can be\n"
      L"\t\tlocated, and are responding." },

    // Check to see if the Rid Manager is accessable and does sanity checks on it
    // Preforms a DsBind with the RID master of the domain.
    // Check to see the target DC's current rid pool is valid, and if there is another
    // rid pool set if the DC is short on RIDs
    { DC_DIAG_ID_CHECK_RID_MANAGER, CheckRidManager,
      RUN_TEST_PER_SERVER, 
      L"RidManager",
      L"Check to see if RID master is accessable and to see if\n"
      L"\t\tit contains the proper information." },
    
    // Does sanity checks on the Domain Controller Machine Account in the ds
    // Check to see if Current DC is in the domain controller's OU
    // Check that useraccountcontrol has UF_SERVER_TRUST_ACCOUNT
    // Check to see if the machine account is trusted for delegation
    // Check's to see if the minimum SPN's are there
    // Makes sure that that the server reference is set up correctly
    { DC_DIAG_ID_CHECK_DC_MACHINE_ACCOUNT, CheckDCMachineAccount,
      RUN_TEST_PER_SERVER,  
      L"MachineAccount",
      L"Check to see if the Machine Account has the proper\n"
      L"\t\tinformation. Use /RepairMachineAccount to attempt a repair\n"
      L"\t\tif the local machine account is missing." },

    //will check to see if the appropriate services are running on a DC.
    { DC_DIAG_ID_CHECK_SERVICES_RUNNING, CheckForServicesRunning,
      RUN_TEST_PER_SERVER,
      L"Services",
      L"Check to see if appropriate DC services are running." },

    // Will check to see if domain has secure channels with the domain that
    // it has an outbound trust with.  Will give reason why a secure channel is not present
    // Will see if the trust is uplevel and if both a trust object and an interdomain trust
    // object exists
    { DC_DIAG_ID_CHECK_DC_OUTBOUND_SECURE_CHANNELS, CheckOutboundSecureChannels,
      RUN_TEST_PER_SERVER | DO_NOT_RUN_TEST_BY_DEFAULT,
      L"OutboundSecureChannels",
      L"See if we have secure channels from all of the\n"
      L"\t\tDC's in the domain the domains specified by /testdomain:.\n"
      L"\t\t/nositerestriction will prevent the test from\n"
      L"\t\tbeing limited to the DC's in the site." },

    // Verify that important objects and their attributes have replicated
    { DC_DIAG_ID_CHECK_OBJECTS, ReplCheckObjectsMain,
      RUN_TEST_PER_SERVER,
      L"ObjectsReplicated",
      L"Check that Machine Account and DSA objects have\n"
      L"\t\treplicated. Use /objectdn:<dn> with /n:<nc> to specify an\n"
      L"\t\tadditional object to check."
    },

    // Check the File Replication System (frs) eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_FILE_REPLICATION_EVENTLOG, CheckFileReplicationEventlogMain,
      RUN_TEST_PER_SERVER,
      L"frssysvol",
      L"This test checks that the file replication system (FRS)\n"
      L"\t\tSYSVOL is ready" }, 

    // Check the Knowledge Consistency Checker (kcc) eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_KCC_EVENTLOG, CheckKccEventlogMain,
      RUN_TEST_PER_SERVER,
      L"kccevent",
      L"This test checks that the Knowledge Consistency Checker\n"
      L"\t\tis completing without errors." }, 

    // Check the System eventlog to see that certain critical
    // events have occured and to signal that any fatal events that might have
    // occured.
    { DC_DIAG_ID_CHECK_SYSTEM_EVENTLOG, CheckSysEventlogMain,
      RUN_TEST_PER_SERVER,
      L"systemlog",
      L"This test checks that the system is running without errors." }, 

    // Tests whether the existing DNS infrastructure is sufficient to allow the
    // computer to be joined to a domain specified in <Active Directory Domain
    // DNS Name> and reports if any modifications to the existing infrastructure
    // is required.
    //{ DC_DIAG_ID_DNS_JOIN_CHECK, JoinDomainDnsCheck,
    //  NON_DC_TEST,
    //  L"JoinTest",
    //  L"Tests whether the existing DNS infrastructure is sufficient\n"
    //  L"\t\tto allow the computer to be joined to a domain." },

    // Tests whether the existing DNS infrastructure is sufficient to allow the
    // computer to be promoted to a Domain Controller in a domain specified in
    // <Active Directory Domain DNS Name> and reports if any modifications to
    // the existing infrastructure is required.
    { DC_DIAG_ID_PRE_PROMO_DNS_CHECK, PrePromoDnsCheck,
      NON_DC_TEST,
      L"DcPromo",
      L"Tests the existing DNS infrastructure for promotion to domain\n"
      L"\t\tcontroller. If the infrastructure is sufficient, the computer\n"
      L"\t\tcan be promoted to domain controller in a domain specified in\n"
      L"\t\t<Active_Directory_Domain_DNS_Name>. Reports whether any\n"
      L"\t\tmodifications to the existing DNS infrastructure are required.\n"
      L"\t\tRequired argument:\n"
      L"\t\t/DnsDomain:<Active_Directory_Domain_DNS_Name>\n"
      L"\t\tOne of the following arguments is required:\n"
      L"\t\t/NewForest\n"
      L"\t\t/NewTree\n"
      L"\t\t/ChildDomain\n"
      L"\t\t/ReplicaDC\n"
      L"\t\tIf NewTree is specified, then the ForestRoot argument is\n"
      L"\t\trequired:\n"
      L"\t\t/ForestRoot:<Forest_Root_Domain_DNS_Name>" },

    // Test whether this Domain Controller will be able to register the Domain
    // Controller Locator DNS records that are required to be present in DNS to
    // allow other computers to locate this Domain Controller for the domain.
    { DC_DIAG_ID_REGISTER_DNS_CHECK, RegisterLocatorDnsCheck,
      NON_DC_TEST,
      L"RegisterInDNS",
      L"Tests whether this domain controller can register the\n"
      L"\t\tDomain Controller Locator DNS records. These records must be\n"
      L"\t\tpresent in DNS in order for other computers to locate this\n"
      L"\t\tdomain controller for the <Active_Directory_Domain_DNS_Name>\n"
      L"\t\tdomain. Reports whether any modifications to the existing DNS\n"
      L"\t\tinfrastructure are required.\n"
      L"\t\tRequired argument:\n"
      L"\t\t/DnsDomain:<Active_Directory_Domain_DNS_Name>\n\n"
      L"\tAll tests except DcPromo and RegisterInDNS must be run on computers\n"
      L"\tafter they have been promoted to domain controller.\n" },

#if 0
    // Example:
    // { First field is an enum from DC_DIAG_ID above, 
    //   Second field is a string to reference the function from the command line with,
    //   Third field is the name of a the function that actually performs the test }
    { DC_DIAG_ID_EXAMPLE, ExampleMain,
      0 /* Test flags */,
      L"ShortExampleTestName", L"Long example description ...." },
#endif


    // Finished signal -- not a test; informs the main program to terminate execution
    { DC_DIAG_ID_FINISHED, NULL,
      0,
      NULL, NULL } 
};

//list of command line switches that are specific to individual tests.
const WCHAR *clOptions[] = 
{
    //command for CheckOutboundSecureChannels allows you to enter the domain flatname
    {L"/testdomain:"},
    
    //command for CheckOutboundSecureChannels allows you test all the DC even the 
    //ones outside the site
    {L"/nositerestriction"},

    // User specified object dn to check during CheckObjects
    { L"/objectdn:" },

    // User has asked for the machine account to be fixed
    { L"/repairmachineaccount" },

    // JoinTest, DCPromo require a DNS domain name
    { DNS_DOMAIN_ARG },

    // DCPromo test requires one of the following options.
    { NEW_FOREST_ARG }, { NEW_TREE_ARG }, { CHILD_DOMAIN_ARG }, { REPLICA_DC_ARG },

    // DCPromo test option required if NEW_TREE_ARG is specified
    { FOREST_ROOT_DOMAIN_ARG },

    //add more options here
    
    //terminator
    {NULL}
};

#else // #ifdef INCLUDE_ALLTESTS_DEFINITION
extern const DC_DIAG_TESTINFO allTests[];
#endif // #else // #ifdef INCLUDE_ALLTESTS_DEFINITION

#endif    // _ALLTESTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\frs\sysevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\sysevent.c

ABSTRACT:

    Check the System eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

MODIFIED:

    29 Oct 1999 William Lees (wlees)

--*/

#include <ntdspch.h>
#include <netevent.h>
#include <time.h>
#include "mdcodes.h"

#include "dcdiag.h"
#include "utils.h"

typedef DWORD MessageId;

typedef struct _EVENT_CALLBACK_CONTEXT {
    BOOL fEventsFound;
    ULONG ulDsInfoFlags;
} EVENT_CALLBACK_CONTEXT, *PEVENT_CALLBACK_CONTEXT;

#define   LOGFILENAME            L"System"

#define EVENTLOG_STARTED 6005
#define EVENTLOG_SESSION_SETUP_FAILURE 0x0000165A
#define EVENTLOG_SESSION_SETUP_CANCELLED 0x00001697
#define EVENTLOG_KDC_MULTIPLE_ACCOUNTS 0XC000000B
#define EVENTLOG_TIME_SECURITY_FALLBACK 0x8000003F
#define EVENTLOG_COMPUTER_LOST_TRUST 0x00001589
#define EVENTLOG_IPSEC_PACKET_IN_CLEAR 0xC00010BC
#define EVENTLOG_MRXSMB_ELECTION_FORCED 0xC0001F43
#define EVENTLOG_NO_DC_FOR_DOMAIN 0x00001657

static VOID
foundBeginningEvent(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This file will be called by the event tests library common\events.c, when
    the beginning event. If the event is
    not found, then the function is called with pEvent = NULL;

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    NOTHING;
}

static VOID
eventlogPrint(
    PVOID                           pvContextArgument,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    PEVENT_CALLBACK_CONTEXT pContext = (PEVENT_CALLBACK_CONTEXT) pvContextArgument;
    DWORD paSuppressedEvents [] = {
        // Put your events that can be skipped here
        EVENTLOG_SESSION_SETUP_FAILURE,
        EVENTLOG_SESSION_SETUP_CANCELLED,
        EVENTLOG_KDC_MULTIPLE_ACCOUNTS,
        EVENTLOG_COMPUTER_LOST_TRUST,
        EVENTLOG_IPSEC_PACKET_IN_CLEAR,
        EVENTLOG_MRXSMB_ELECTION_FORCED,
        EVENTLOG_NO_DC_FOR_DOMAIN,
        0
    };
    DWORD paIgnorableEvents [] = {
        // Put your events that can be optionally ignored here
        0
    };
    Assert(pEvent != NULL);

    // Handle events we want to suppress
    if (EventIsInList( pEvent->EventID, paSuppressedEvents ) ) {
        return;
    }

    // Handle ignorable errors
    if ( (pContext->ulDsInfoFlags & DC_DIAG_IGNORE) &&
         (EventIsInList( pEvent->EventID, paIgnorableEvents ) ) ) {
        return;
    }

    GenericPrintEvent(LOGFILENAME, pEvent, (gMainInfo.ulSevToPrint >= SEV_VERBOSE) );

    pContext->fEventsFound = TRUE;
}



DWORD
CheckSysEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    Check whether the Sys is currently in an error state. That is, we check
    whether the Sys logged any errors on its last run.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD paSelectEvents [] = { 
        // Put special selected events here
        // For future use
        0 };
    DWORD paBegin [] = {
        // These events will cause the search to stop
        EVENTLOG_STARTED,
        0 };
    DWORD dwRet;
    DWORD dwMinutesPast, dwTimeLimit;
    EVENT_CALLBACK_CONTEXT context;
    time_t tLimit;

    PrintMessage(SEV_VERBOSE, L"* The System Event log test\n");

    context.fEventsFound = FALSE;
    context.ulDsInfoFlags = pDsInfo->ulFlags;

    dwMinutesPast = 60;

    // Calculate time limit of minutes in the past
    time( &tLimit );
    dwTimeLimit = (DWORD)tLimit;
    dwTimeLimit -= (dwMinutesPast * 60);

    // We will select events as follows:
    // a. Must be within 60 minutes
    // b. Will stop searching at computer start
    // c. Any error severity event in the log will be selected,
    // d. Any non-error in the select list will be flagged

    dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                              pDsInfo->gpCreds,
                              LOGFILENAME,
                              EVENTLOG_ERROR_TYPE,
                              NULL, // paSelectEvents,
                              paBegin,
                              dwTimeLimit,
                              eventlogPrint,
                              foundBeginningEvent,
                              &context );

    if (dwRet) {
        PrintMessage( SEV_ALWAYS, L"Failed to enumerate event log records, error %s\n",
                      Win32ErrToString(dwRet) );
        return dwRet;
    } else if (context.fEventsFound) {
        return ERROR_DS_GENERIC_ERROR;
    } else {
	PrintMessage(SEV_VERBOSE, L"Found no errors in System Event log in the last %d minutes.\n", dwMinutesPast);
        return ERROR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\frs\kccevent.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    frs\kccevent.c

ABSTRACT:

    Check the Knowledge Consistency Checker eventlog to see that certain 
    critical events have occured and to signal that any fatal events that 
    might have occured.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

MODIFIED:

    29 Oct 1999 William Lees (wlees)

--*/

#include <ntdspch.h>
#include <netevent.h>
#include <time.h>
#include "mdcodes.h"

#include "dcdiag.h"
#include "utils.h"

typedef DWORD MessageId;

typedef struct _EVENT_CALLBACK_CONTEXT {
    BOOL fEventsFound;
    ULONG ulDsInfoFlags;
} EVENT_CALLBACK_CONTEXT, *PEVENT_CALLBACK_CONTEXT;

#define   LOGFILENAME            L"Directory Service"

VOID
foundBeginningEvent(
    PVOID                           pvContext,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This file will be called by the event tests library common\events.c, when
    the beginning event. If the event is
    not found, then the function is called with pEvent = NULL;

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    NOTHING;
}

VOID
eventlogPrint(
    PVOID                           pvContextArgument,
    PEVENTLOGRECORD                 pEvent
    )
/*++

Routine Description:

    This function will be called by the event tests library common\events.c,
    whenever an event of interest comes up.  An event of interest for this
    test is any error or the warnings.

Arguments:

    pEvent - A pointer to the event of interest.

--*/
{
    PEVENT_CALLBACK_CONTEXT pContext = (PEVENT_CALLBACK_CONTEXT) pvContextArgument;
    DWORD paIgnorableEvents [] = {
        DIRLOG_CHK_LINK_ADD_MASTER_FAILURE,
	DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
        DIRLOG_KCC_REPLICA_LINK_DOWN,
        DIRLOG_ISM_SMTP_DSN,
        DIRLOG_EXCEPTION,
        DIRLOG_DRA_CALL_EXIT_BAD,
        DIRLOG_DRA_NOTIFY_FAILED,
        0
    };
    Assert(pEvent != NULL);

    // Handle ignorable errors
    if ( (pContext->ulDsInfoFlags & DC_DIAG_IGNORE) &&
         (EventIsInList( pEvent->EventID, paIgnorableEvents ) ) ) {
        return;
    }

    GenericPrintEvent(LOGFILENAME, pEvent, (gMainInfo.ulSevToPrint >= SEV_VERBOSE) );

    pContext->fEventsFound = TRUE;
}



DWORD
CheckKccEventlogMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds
    )
/*++

Routine Description:

    Check whether the KCC is currently in an error state. That is, we check
    whether the KCC logged any errors on its last run.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/
{
    // Setup variables for PrintSelectEvents
    DWORD paSelectEvents [] = { 
        DIRLOG_KCC_NO_SPANNING_TREE,
        DIRLOG_KCC_AUTO_TOPL_GENERATION_INCOMPLETE,
        DIRLOG_KCC_ERROR_CREATING_CONNECTION_OBJECT,
        DIRLOG_KCC_CONNECTION_OBJECT_DELETION_FAILED,
        DIRLOG_KCC_KEEPING_INTERSITE_CONN,
        DIRLOG_KCC_DIR_OP_FAILURE,
        DIRLOG_KCC_TRANSPORT_ADDRESS_MISSING,
        DIRLOG_KCC_TRANSPORT_BRIDGEHEAD_NOT_FOUND,
        DIRLOG_KCC_ALL_TRANSPORT_BRIDGEHEADS_STALE,
        DIRLOG_KCC_EXPLICIT_BRIDGEHEAD_LIST_INCOMPLETE,
        DIRLOG_KCC_NO_BRIDGEHEADS_ENABLED_FOR_TRANSPORT,
        DIRLOG_KCC_REPLICA_LINK_DOWN,
        DIRLOG_CHK_INIT_FAILURE,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_END_ABNORMAL,
        DIRLOG_CHK_LINK_DEL_NONC_BUSY,
        DIRLOG_CHK_LINK_DEL_NOTGC_BUSY,
        DIRLOG_CHK_LINK_DEL_DOMDEL_BUSY,
        DIRLOG_CHK_LINK_DEL_NOCONN_BUSY,
        DIRLOG_CHK_LINK_DEL_NOSRC_BUSY,
        DIRLOG_CHK_INVALID_TRANSPORT_FOR_WRITEABLE_DOMAIN_NC,
        DIRLOG_CHK_CANT_REPLICATE_FROM_SELF,
        DIRLOG_CHK_REPSTO_DEL_FAILURE,
        DIRLOG_CHK_ALL_CONNECTIONS_FOR_NC_DISABLED,
        DIRLOG_CHK_NO_LOCAL_SOURCE_FOR_NC,
        DIRLOG_CHK_BAD_SCHEDULE,
        DIRLOG_CHK_DUPLICATE_CONNECTION,
        DIRLOG_CHK_LINK_ADD_MASTER_FAILURE,
	DIRLOG_CHK_LINK_ADD_REPLICA_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOSRC_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOTGC_FAILURE,
        DIRLOG_CHK_LINK_DEL_DOMDEL_FAILURE,
        DIRLOG_CHK_LINK_DEL_NOCONN_FAILURE,
        DIRLOG_CHK_LINK_DEL_NONC_FAILURE,
        DIRLOG_CHK_CONFIG_PARAM_TOO_LOW,
        DIRLOG_CHK_CONFIG_PARAM_TOO_HIGH,
        DIRLOG_CHK_SITE_HAS_NO_NTDS_SETTINGS,
        DIRLOG_GC_PROMOTION_DELAYED,
        DIRLOG_DRA_DISABLED_OUTBOUND_REPL,
        DIRLOG_DRA_DELETED_PARENT,
        DIRLOG_SCHEMA_CREATE_INDEX_FAILED,
        DIRLOG_SCHEMA_INVALID_RDN,
        DIRLOG_SCHEMA_INVALID_MUST,
        DIRLOG_SCHEMA_INVALID_MAY,
        DIRLOG_PRIVILEGED_OPERATION_FAILED,
        DIRLOG_SCHEMA_DELETE_COLUMN_FAIL,
        DIRLOG_SCHEMA_DELETED_COLUMN_IN_USE,
        DIRLOG_SCHEMA_DELETE_INDEX_FAIL,
        DIRLOG_RECOVER_RESTORED_FAILED,
        DIRLOG_SCHEMA_DELETE_LOCALIZED_INDEX_FAIL,
        DIRLOG_DRA_SCHEMA_MISMATCH,
        DIRLOG_SDPROP_TOO_BUSY_TO_PROPAGATE,
        DIRLOG_DSA_NOT_ADVERTISE_DC,
        DIRLOG_ADUPD_GC_NC_MISSING,
        DIRLOG_GC_OCCUPANCY_NOT_MET,
        DIRLOG_DS_DNS_HOST_RESOLUTION_FAILED,
        DIRLOG_RPC_PROTSEQ_FAILED,
        DIRLOG_DRA_NC_TEARDOWN_BEGIN,
        DIRLOG_DRA_NC_TEARDOWN_RESUME,
        DIRLOG_DRA_NC_TEARDOWN_SUCCESS,
        DIRLOG_DRA_NC_TEARDOWN_FAILURE,
        DIRLOG_ADUPD_NC_SYNC_NO_PROGRESS,
        0 };
    DWORD paBegin [] = {
        DIRLOG_KCC_TASK_ENTRY,
        DIRLOG_CHK_UPDATE_REPL_TOPOLOGY_BEGIN,
        DIRLOG_STARTED,
        0 };
    DWORD dwRet;
    DWORD dwMinutesPast, dwTimeLimit;
    time_t tLimit;
    EVENT_CALLBACK_CONTEXT context;

    PrintMessage(SEV_VERBOSE, L"* The KCC Event log test\n");

    context.fEventsFound = FALSE;
    context.ulDsInfoFlags = pDsInfo->ulFlags;

    // BUGBUG: use actual kcc frequency on that system
    dwMinutesPast = 15;

    // Calculate time limit of minutes in the past
    time( &tLimit );
    dwTimeLimit = (DWORD)tLimit;
    dwTimeLimit -= (dwMinutesPast * 60);

    // We will select events as follows:
    // a. Must be within 15 minutes
    // b. Will stop searching at directory start
    // c. Any error in the log will be selected, kcc or not
    // d. Any non-error in my list will be flagged

    dwRet = PrintSelectEvents(&(pDsInfo->pServers[ulCurrTargetServer]),
                              pDsInfo->gpCreds,
                              LOGFILENAME,
                              EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE,
                              paSelectEvents,
                              paBegin,
                              dwTimeLimit,
                              eventlogPrint,
                              foundBeginningEvent,
                              &context );

    if (dwRet) {
        PrintMessage( SEV_ALWAYS, L"Failed to enumerate event log records, error %s\n",
                      Win32ErrToString(dwRet) );
        return dwRet;
    } else if (context.fEventsFound) {
        return ERROR_DS_GENERIC_ERROR;
    } else {
	PrintMessage(SEV_VERBOSE, L"Found no KCC errors in Directory Service Event log in the last %d minutes.\n", dwMinutesPast);
        return ERROR_SUCCESS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\dstest.h ===
#ifndef DSTEST_H
#define DSTEST_H

DWORD
FinddefaultNamingContext (
    IN  LDAP  *		                hLdap,
	OUT WCHAR **                    ReturnString);


DWORD
FindServerRef (
    IN  LDAP *		                hLdap,
	OUT WCHAR**                     ReturnString);

DWORD
GetMachineReference(
    IN  LDAP  *		                hLdap,
    IN  WCHAR *                     name,
    IN  WCHAR *                     defaultNamingContext,
    OUT WCHAR **                    ReturnString);

DWORD
WrappedTrimDSNameBy(
    IN  WCHAR                       *InString,
    IN  DWORD                       NumbertoCut,
    OUT WCHAR                       **OutString);

void
DInitLsaString(
              PLSA_UNICODE_STRING LsaString,
              LPWSTR String);

DWORD
FindschemaNamingContext (
    IN  LDAP *                      hLdap,
    OUT WCHAR**                     ReturnString);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\dcdiag.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dcdiag.h

ABSTRACT:

    This is the header for the globally useful data structures for the entire
    dcdiag.exe utility.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

--*/

#ifndef _DCDIAG_H_
#define _DCDIAG_H_

#include <winldap.h>
#include <tchar.h>

#include <ntlsa.h>

#include "debug.h"

#include "msg.h"

#define DC_DIAG_EXCEPTION    ((0x3 << 30) | (0x1 << 27) | (0x1 << 1))
#define DC_DIAG_VERSION_INFO L"Domain Controller Diagnosis\n"

#define DEFAULT_PAGED_SEARCH_PAGE_SIZE   (1000)

// In Whister Beta 2, the handling of \n in RDNs changed. It used to be that
// embedded newlines were not quoted.  Now, they are quoted like this: \\0A.
//#define IsDeletedRDNW( s ) (s && (wcsstr( s, L"\nDEL:" ) || wcsstr( s, L"\\0ADEL:" )))
#define IsDeletedRDNW( s ) (DsIsMangledDnW(s,DS_MANGLE_OBJECT_RDN_FOR_DELETION))

// Level of detail to display.
enum {
    SEV_ALWAYS,
    SEV_NORMAL,
    SEV_VERBOSE,
    SEV_DEBUG
};

typedef struct {
    FILE *  streamOut;      // Output stream
    FILE *  streamErr;      // Error stream
    ULONG   ulFlags;        // Flags
    ULONG   ulSevToPrint;   // Level of detail to display
    LONG    lTestAt;        // The current test
    INT     iCurrIndent;    // The current number of intents to precede each line
    DWORD   dwScreenWidth;  // Width of console
} DC_DIAG_MAININFO, * PDC_DIAG_MAININFO;

extern DC_DIAG_MAININFO gMainInfo;

// Flags

// Flags for scope of testing
#define DC_DIAG_TEST_SCOPE_SITE          0x00000010
#define DC_DIAG_TEST_SCOPE_ENTERPRISE    0x00000020

// Flags, other
#define DC_DIAG_IGNORE                   0x00000040
#define DC_DIAG_FIX                      0x00000080

typedef struct {
    LPWSTR                 pszNetUseServer;
    LPWSTR                 pszNetUseUser;
    NETRESOURCE            NetResource;
    LSA_OBJECT_ATTRIBUTES  ObjectAttributes;
    LSA_UNICODE_STRING     sLsaServerString;
    LSA_UNICODE_STRING     sLsaRightsString;
} NETUSEINFO;

typedef struct {
    LPWSTR      pszDn;
    LPWSTR      pszName;
    UUID        uuid;
    UUID        uuidInvocationId;
    LPWSTR      pszGuidDNSName;
    LPWSTR      pszDNSName;
    LPWSTR      pszComputerAccountDn;
    LPWSTR *    ppszMasterNCs; //8
    LPWSTR *    ppszPartialNCs;
    ULONG       iSite;
    INT         iOptions;  //11
    BOOL        bIsSynchronized;
    BOOL        bIsGlobalCatalogReady;
    BOOL        bDnsIpResponding;    // Set by UpCheckMain
    BOOL        bLdapResponding;     // Set by UpCheckMain
    BOOL        bDsResponding;       // Set by UpCheckMain ... as in the Rpc is responding by DsBind..()
    LDAP *      hLdapBinding;   // Access this through the DcDiagLdapOpenAndBind() function.
    LDAP *      hGcLdapBinding;   // Access this through the DcDiagLdapOpenAndBind() function.
    HANDLE      hDsBinding;   // Access this through the DcDiagDsBind() function.
    NETUSEINFO  sNetUseBinding;
    DWORD       dwLdapError;
    DWORD       dwGcLdapError;
    DWORD       dwDsError;
    DWORD       dwNetUseError;
    USN         usnHighestCommittedUSN;
    FILETIME    ftRemoteConnectTime; // Remote time when connect occurred
    FILETIME    ftLocalAcquireTime; // Local time when timestamp taken
} DC_DIAG_SERVERINFO, * PDC_DIAG_SERVERINFO;

typedef struct {
    LPWSTR      pszDn;
    LPWSTR      pszName;
} DC_DIAG_NCINFO, * PDC_DIAG_NCINFO;

typedef struct {
    LPWSTR      pszSiteSettings;
    LPWSTR      pszName;
    INT         iSiteOptions;
    LPWSTR      pszISTG; // This will be set by ReplIntersiteHealthCheck 
} DC_DIAG_SITEINFO, * PDC_DIAG_SITEINFO;

typedef struct {
    LDAP *	                    hld; //1
    // Specified on command line
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds;
    ULONG                       ulFlags;
    LPWSTR                      pszNC;
    ULONG                       ulHomeServer;
    ULONG                       iHomeSite; //5
    // Target Servers
    ULONG                       ulNumTargets;
    ULONG *                     pulTargets;
    //         Enterprise Info ---------------
    // All the servers
    ULONG                       ulNumServers; //9
    PDC_DIAG_SERVERINFO         pServers;
    // All the sites
    ULONG                       cNumSites;
    PDC_DIAG_SITEINFO           pSites;
    // All the naming contexts
    ULONG                       cNumNCs; //13
    PDC_DIAG_NCINFO             pNCs;
    // Other Stuff
    INT                         iSiteOptions;
    LPWSTR                      pszRootDomain;
    LPWSTR                      pszRootDomainFQDN; //17
    LPWSTR                      pszConfigNc;
    DWORD                       dwTombstoneLifeTimeDays;
    // Contain information from the CommandLine that
    // will be parsed by tests that required information
    // specific to them.  Switches must be declared in
    // alltests.h
    LPWSTR                      *ppszCommandLine;  
} DC_DIAG_DSINFO, * PDC_DIAG_DSINFO;

typedef struct {
    INT                         testId;
    DWORD (__stdcall *	fnTest) (DC_DIAG_HANDLE);
    ULONG                       ulTestFlags;
    LPWSTR                      pszTestName;
    LPWSTR                      pszTestDescription;
} DC_DIAG_TESTINFO, * PDC_DIAG_TESTINFO;

// Pseudofunctions

#if 1
#define IF_DEBUG(x)               if(gMainInfo.ulSevToPrint >= SEV_DEBUG) x;
#else
#define IF_DEBUG(x)               
#endif

#define DcDiagChkErr(x)  {   ULONG _ulWin32Err; \
                if ((_ulWin32Err = (x)) != 0) \
                    DcDiagException (_ulWin32Err); \
                }

#define DcDiagChkLdap(x)    DcDiagChkErr (LdapMapErrorToWin32 (x));

#define DcDiagChkNull(x)    if (NULL == (x)) \
                    DcDiagChkErr (GetLastError ());

// Function prototypes

#define NO_SERVER               0xFFFFFFFF
#define NO_SITE                 0xFFFFFFFF
#define NO_NC                   0xFFFFFFFF

ULONG
DcDiagGetServerNum(
    PDC_DIAG_DSINFO            pDsInfo,
    LPWSTR                      pszName,
    LPWSTR                      pszGuidName,
    LPWSTR                      pszDsaDn,
    LPWSTR                      pszDNSName,
    LPGUID                      puuidInvocationId 
    );

DWORD
DcDiagCacheServerRootDseAttrs(
    IN LDAP *hLdapBinding,
    IN PDC_DIAG_SERVERINFO pServer
    );

DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    );

DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    );

BOOL
DcDiagIsMemberOfStringList(
    LPWSTR pszTarget, 
    LPWSTR * ppszSources, 
    INT iNumSources
    );

ULONG
DcDiagExceptionHandler(
    IN const  EXCEPTION_POINTERS * prgExInfo,
    OUT PDWORD                     pdwWin32Err
    );

VOID
DcDiagException (
    ULONG            ulWin32Err
    );

LPWSTR
DcDiagAllocNameFromDn (
    LPWSTR            pszDn
    );

LPWSTR
Win32ErrToString(
    ULONG            ulWin32Err
    );

INT PrintIndentAdj (INT i);
INT PrintIndentSet (INT i);

void 
ConvertToWide (LPWSTR lpszDestination,
               LPCSTR lpszSource,
               const int iDestSize);

void
PrintMessage(
    IN  ULONG   ulSev,
    IN  LPCWSTR pszFormat,
    IN  ...
    );

void
PrintMessageID(
    IN  ULONG   ulSev,
    IN  ULONG   uMessageID,
    IN  ...
    );

void
PrintMsg(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintMsg0(
    IN  ULONG   ulSev,
    IN  DWORD   dwMessageCode,
    IN  ...
    );

void
PrintMessageSz(
    IN  ULONG   ulSev,
    IN  LPCTSTR pszMessage
    );

VOID *
GrowArrayBy(
    VOID *            pArray, 
    ULONG             cGrowBy, 
    ULONG             cbElem
    );

#include "alltests.h"

#endif  // _DCDIAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\list.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    list.h

ABSTRACT:

    Function decls, for list functions.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:


NOTES:

    This is a "pure" list function, in that it returns NULL, or a memory address.  If
    it returns NULL, then GetLastError() should have the error, even if another pure
    list function was called in the mean time.  If not it is almost certainly a memory
    error, as this is the only thing that can go wrong in pure list functions.  The pure
    list functions return a NO_SERVER terminated list.  The function always returns the
    pointer to the list.  Note most of the list functions modify one of the lists they
    are passed and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().

--*/


DWORD
IHT_PrintListError(
    DWORD                               dwErr
    );

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    );

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    );

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    );

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    );

PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    );

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_EXAMPLE_STRING                 1000

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\repl.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    repl.h

ABSTRACT:

    This function contains some foward decls for some useful functions scattered 
    through the dcdiag framework.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:

    Code.Improvement ... to put DcDiagHasNC in some more generic header file, 
    and to make sure that dcdiag is developing in a coherent fashion towards a
    nice clean structure.

--*/

INT 
ReplServerConnectFailureAnalysis(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    );

BOOL
DcDiagHasNC(
    LPWSTR                          pszNC,
    PDC_DIAG_SERVERINFO             pServer,
    BOOL                            bMasters,
    BOOL                            bPartials
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\ldaputil.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldaputil.h

ABSTRACT:

    This gives shortcuts to common ldap code.

DETAILS:

    This is a work in progress to have convienent functions added as needed
    for simplyfying the massive amounts of LDAP code that must be written for
    dcdiag.

CREATED:

    23 Aug 1999  Brett Shirley

--*/

extern FILETIME gftimeZero;

DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    );

DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

DWORD
DcDiagGeneralizedTimeToSystemTime(
    LPWSTR IN                   szTime,
    PSYSTEMTIME OUT             psysTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\initial.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    servers.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

        Did alot, added a DNS/server failure analysis.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>

// added to make IsIcmpRespose() or Ping() function
#include <winsock2.h>
#include <lmcons.h>
#include <ipexport.h>  // has type IPaddr for icmpapi.h
#include <icmpapi.h>   // for IcmpCreateFile, IcmpSendEcho, IcmpCloseHandle

#include <dnsresl.h>
#include <svcguid.h>

#include "dcdiag.h"
#include "repl.h"

// Some pound defines imported from xportst.h
#define DEFAULT_SEND_SIZE      32
#define MAX_ICMP_BUF_SIZE      ( sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE )
#define DEFAULT_TIMEOUT        1000L
#define PING_RETRY_CNT         4


// Some constants for DNSRegistration/Up Check
// There is a better place to get this var ... but it is a pain in the ass
const LPWSTR                    pszTestNameUpCheck = L"DNS Registration & Server Up Check";

//-------------------------------------------------------------------------//
//######  I s I c m p R e s p o n s e ()  #################################//
// NOTE: This is actually IsIcmpRespose from 
//   /nt/private/net/sockets/tcpcmd/nettest/xportst.c modified instead to take
//   a ULONG as an IP address, compared to before where it took an IP string.
//-------------------------------------------------------------------------//
DWORD
Ping( 
    ULONG ipAddr
    ) 
//++
//
//  Routine Description:
//
//      Sends ICMP echo request frames to the IP address specified.
//    
//  Arguments:
//
//      ipAddrStr - address to ping
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{

    CHAR   *SendBuffer, *RcvBuffer;
    INT     i, nReplyCnt;
    INT     nReplySum = 0;
    INT     iTempRet;
    HANDLE  hIcmp;
    PICMP_ECHO_REPLY reply;

    //
    //  contact ICMP driver
    //
    hIcmp = IcmpCreateFile();
    if ( hIcmp == INVALID_HANDLE_VALUE ) {
        return ERROR_NOT_ENOUGH_MEMORY; // Should be corrected
    }

    //
    //  prepare buffers
    //
    SendBuffer = LocalAlloc( LMEM_FIXED, DEFAULT_SEND_SIZE );
    if ( SendBuffer == NULL ) {
	IcmpCloseHandle( hIcmp );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( SendBuffer, DEFAULT_SEND_SIZE );

    RcvBuffer = LocalAlloc( LMEM_FIXED, MAX_ICMP_BUF_SIZE );
    if ( RcvBuffer == NULL ) {
        LocalFree( SendBuffer );
	IcmpCloseHandle( hIcmp );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( RcvBuffer, DEFAULT_SEND_SIZE );

    //
    //  send ICMP echo request
    //
    for ( i = 0; i < PING_RETRY_CNT; i++ ) {
        nReplyCnt = IcmpSendEcho( hIcmp,
                                  ipAddr,
                                  SendBuffer,
                                  (unsigned short )DEFAULT_SEND_SIZE,
                                  NULL,
                                  RcvBuffer,
                                  MAX_ICMP_BUF_SIZE,
                                  DEFAULT_TIMEOUT
                                );

        //
        //  test for destination unreachables
        //
        if ( nReplyCnt != 0 ) {
            reply = (PICMP_ECHO_REPLY )RcvBuffer;
            if ( reply->Status == IP_SUCCESS ) {
                nReplySum += nReplyCnt;
            }
        }

    } /* for loop */

    //
    //  cleanup
    //
    LocalFree( SendBuffer );
    LocalFree( RcvBuffer );
    IcmpCloseHandle( hIcmp );
    if ( nReplySum == 0 ) { 
        return GetLastError(); 
    } else { 
        return ERROR_SUCCESS;
    }

} /* END OF IsIcmpRespose() */

DWORD
FaCheckIdentityHelperF1(
    IN   PDC_DIAG_SERVERINFO          pServer,
    IN   LPWSTR                       pszTargetNameToCheck
)
/*++

Description:

    This function will look up the official DNS name and aliases for pszHostNameToLookup and compare them to
    pszTargetNameToCheck.

Arguments:

    pServer (IN) - Host Name to resolve into official names, use ->pszGuidDNSName or ->pszName.

    pszTargetNameToCheck (IN) - Name to be checked.


Return value:

    dwRet - is undetermined at this time.

Notes:

    This function was created instead of using gethostbyname(), because gethostbyname does not support
    non-ANSI names, as part of a recent (as of 5.17.1999) RFC -- i.e., that gethostbyname() supports 
    only ANSI names, and we need to be able to resolve Unicode names.

--*/
{
    LPWSTR                             pszOfficialDnsName = NULL;
    VOID *                             pPD = NULL;
    DWORD                              dwRet;
    LPWSTR                             pszHostNameToLookup = NULL;

    if(pServer->pszGuidDNSName != NULL){
        pszHostNameToLookup = pServer->pszGuidDNSName;
    } else {
        pszHostNameToLookup = pServer->pszName;
    }

    __try {
        dwRet = GetDnsHostNameW(&pPD, pszHostNameToLookup, &pszOfficialDnsName);
        if(dwRet == NO_ERROR){
            if(_wcsicmp(pszOfficialDnsName, pszTargetNameToCheck) == 0){
                dwRet = NO_ERROR;
                __leave;
            } // else they don't match try the next alias.
        } else {
            // An unknown error from winsock.
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"***Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"There was an error in Windows Sockets during hostname resolution.\n");
            PrintMessage(SEV_NORMAL, L"Winsock retured the following error (%D):\n", dwRet);
            PrintMessage(SEV_NORMAL, L"%s", Win32ErrToString(dwRet));
            __leave;
        }
        
        while((dwRet = GetDnsAliasNamesW(&pPD, &pszOfficialDnsName)) == NO_ERROR){
            if(_wcsicmp(pszOfficialDnsName, pszTargetNameToCheck) == 0){
                dwRet = NO_ERROR;
                __leave;
            } // else they don't match try the next alias.
        }

        if(dwRet == WSA_E_NO_MORE){
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"*** Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"If there are problems accessing this directory server then\n");
            PrintMessage(SEV_NORMAL, L"you may need to check that this server is correctly registered\n");
            PrintMessage(SEV_NORMAL, L"with DNS\n");
            PrintIndentAdj(-2);
            dwRet = NO_ERROR;
            __leave;
        } else if (dwRet != NO_ERROR){
            // An unknonwn error from winsock.
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"***Warning: could not confirm the identity of this server in\n");
            PrintIndentAdj(1);
            PrintMessage(SEV_NORMAL, L"the directory versus the names returned by DNS servers.\n");
            PrintMessage(SEV_NORMAL, L"There was an error in Windows Sockets during hostname resolution.\n");
            PrintMessage(SEV_NORMAL, L"Winsock retured the following error (%D):\n", dwRet);
            PrintMessage(SEV_NORMAL, L"%s", Win32ErrToString(dwRet));
            __leave;
        }
    } __finally {
        GetDnsFreeW(&pPD);
    }

    return(dwRet);
} // End of FaCheckIdentityHelperF1()

INT
FaCheckIdentity(
    PDC_DIAG_SERVERINFO              pServer,
    LDAP *                           hld,
    ULONG                            ulIPofDNSName,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
    )

/*++

Routine Description

    This function uses an open and bound ldap handle.  This function checks the various Domain Names of a machine against the official.

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    hld - IMPORTANT this is assumed to be an open and bound ldap connection that can just be used, and 
        not unbound, because the caller will do that.
    ulIPofDNSName - Assumed to be the IP address of the machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
  
    ULONG                       ulRet;
    INT                         iTemp, iTempSize;
    INT                         iTempRet = 1;
    LPWSTR                      ppszServerAttr [] = {L"dnsHostName", NULL};
    LDAPMessage *               pldmMachineCheck = NULL;
    LDAPMessage *               pldmMCEntry = NULL;
    LPWSTR *                    ppszMachineName = NULL;
    LPWSTR                      pszTempDNSName = NULL;
    UUID                        uuidTemp;

    // Time to do some ldapping!
    ulRet = LdapMapErrorToWin32( ldap_search_sW(hld,
						NULL, // Want the root object
						LDAP_SCOPE_BASE,
						L"(objectClass=*)",
						ppszServerAttr,
						0,
						&pldmMachineCheck) );

    if(ulRet != ERROR_SUCCESS){
        if(ulRet == ERROR_NOT_ENOUGH_MEMORY){
	    PrintMessage(SEV_ALWAYS, L"Fatal Error: Not enough memory to complete operation\n");
	} else {
	    PrintMessage(SEV_ALWAYS, L"LDAP There was an error searching, %s\n",
				Win32ErrToString(ulRet));
	}
	goto CleanExitPoint;
    }

    pldmMCEntry = ldap_first_entry(hld, pldmMachineCheck);
    ulRet = LdapMapErrorToWin32(LdapGetLastError());
    if(pldmMCEntry == NULL || ulRet != ERROR_SUCCESS){
	if(ulRet == ERROR_NOT_ENOUGH_MEMORY){
	    PrintMessage(SEV_ALWAYS, L"Fatal Error: Not enough memory to complete operation\n");
	} else if(ulRet == ERROR_SUCCESS) {
	    PrintMessage(SEV_ALWAYS, L"LDAP couldn't retrieve the root object from the server %s.\n", 
                         pServer->pszName);
	} else {
	    PrintMessage(SEV_ALWAYS, L"LDAP couldn't retrieve the root object from the server %s with\n", 
                         pServer->pszName);
            PrintMessage(SEV_ALWAYS, L"this error %s\n", Win32ErrToString(ulRet));
	}
	goto CleanExitPoint;
    }
    ppszMachineName = ldap_get_valuesW(hld, pldmMCEntry, L"dnsHostName");
    ulRet = LdapMapErrorToWin32(LdapGetLastError());
    if(ppszMachineName == NULL || ulRet != ERROR_SUCCESS){
	if(ulRet == ERROR_NOT_ENOUGH_MEMORY){
	    PrintMessage(SEV_ALWAYS, L"Fatal Error: Not enough memory to complete operation\n");
	} else if(ulRet == ERROR_SUCCESS) {
	    PrintMessage(SEV_ALWAYS, L"LDAP couldn't retrieve the root object from the server %s.\n");
	} else {
	    PrintMessage(SEV_ALWAYS, L"LDAP unable to get machine information from server %s, with\n", 
                         pServer->pszName);
            PrintMessage(SEV_ALWAYS, L"this error: %s\n", Win32ErrToString(ulRet));
	}
	goto CleanExitPoint;
    }
   

    ulRet = FaCheckIdentityHelperF1(pServer, ppszMachineName[0]);

 CleanExitPoint:
    if(pldmMachineCheck != NULL) ldap_msgfree(pldmMachineCheck);
    pldmMachineCheck = NULL;
    if(ppszMachineName != NULL) ldap_value_freeW(ppszMachineName);
    ppszMachineName = NULL;

    return(ulRet);
}

INT
FaLdapCheck(
    PDC_DIAG_SERVERINFO              pServer,
    ULONG                            ulIPofDNSName,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
    )
/*++

Routine Description

    This function will try to make a successful ldap_init() and ldap_bind() and
    then call CheckIdentity().  Otherwise print out a pleasant/helpful error
    message and return a Win32Err

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server
        we are trying to identify.
    ulIPofDNSName - Assumed to be the IP address of the machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
    LDAP *                     hld = NULL;
    ULONG                      ulRet;

    ulRet = DcDiagGetLdapBinding(pServer, gpCreds, FALSE, &hld);
    if(ulRet == NO_ERROR){
        if (!pServer->bIsSynchronized) {
            PrintMsg( SEV_ALWAYS, DCDIAG_INITIAL_DS_NOT_SYNCED, pServer->pszName );
        }
        ulRet = FaCheckIdentity(pServer, hld, ulIPofDNSName, gpCreds);
    } else {
        if(ulRet == ERROR_BAD_NET_RESP){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_BAD_NET_RESP,
                     pServer->pszName);
        } else if (ulRet == ERROR_WRONG_PASSWORD) {
            PrintMsg(SEV_ALWAYS, DCDIAG_NEED_GOOD_CREDS);
        } else {
            // Do nothing.
        }
    }

    return(ulRet);
}

BOOL
FaCheckNormalName(
    PDC_DIAG_SERVERINFO              pServer,
    LPWSTR                           pszGuidIp,
    ULONG                            ulIPofGuidDNSName
    )
/*++

Routine Description:

    This function checks the Normal DNS Name if the GUID based
    DNS Name failed either to resolve in DNS or ping.
    
Arguments:

    pServer - The server to check.
    pszGuidIp - This is the string version of ulIPofGuidDNSName.  It is
        NULL if ulIPofGuidDNSName equals INADDR_NONE.
    ulIPofGuidDNSName - If the GUID DNS Name resolved, then this is a 
        valid IP, if the GUID DNS Name didn't even resolve this is 
        INADDR_NONE.

Returns: TRUE if it prints an advanced and more informative error, FALSE if
    it did not.


    BUGBUG It might just be a better less confusing output synario to 
    have a 3 step print thing.  Ie just the facts.
    1) Is the guid based name registered/resolving?
    2) Are the guid based name and normal name resolving to the same IP.
        Indicated DNS server inconsistencies or DHCP problems.
    3) Is the IP respondings.  Often indicates is the system up.   

--*/
{
    WCHAR                            pszNormalIp[IPADDRSTR_SIZE];
    CHAR                             paszNormalIp[IPADDRSTR_SIZE];
    ULONG                            ulNormalIp = INADDR_NONE;
    ULONG                            dwRet, dwRetPing;

    Assert(pServer->pszGuidDNSName != NULL && "This function is only"
           " relevant if we have both a GUID and normal DNS name.");
    Assert((ulIPofGuidDNSName == INADDR_NONE && pszGuidIp == NULL) ||
           (ulIPofGuidDNSName != INADDR_NONE && pszGuidIp != NULL));

    // We either failed in the DNS lookup or the ping of the IP of the Guid
    //   based DNS Name.  Either way lookup the normal name.
    dwRet = GetIpAddrByDnsNameW(pServer->pszDNSName, pszNormalIp);
    if(dwRet == NO_ERROR){
        wcstombs(paszNormalIp, pszNormalIp, IPADDRSTR_SIZE-1);
        ulNormalIp = inet_addr(paszNormalIp);
        if(ulNormalIp == INADDR_NONE){
            if(ulIPofGuidDNSName == INADDR_NONE){
                // Nothing weird here, neither name resolved, nothing printed out.
                return(FALSE); 
            }
            // How odd, the Guid DNS Name resolved, but the Normal Name
            //   could not be resolved.

            PrintMsg(SEV_ALWAYS,
                     DCDIAG_CONNECTIVITY_DNS_NO_NORMAL_NAME,
                     pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName);
            return(FALSE);
        }
    } else {
        if(ulIPofGuidDNSName == INADDR_NONE){
            // Nothing weird here, neither name resolved, nothing printed out.
            return(FALSE);
        } 
        // How odd, the Guid DNS Name resolved, but the Normal Name
        //   could not be resolved.

        PrintMsg(SEV_ALWAYS,
                 DCDIAG_CONNECTIVITY_DNS_NO_NORMAL_NAME,
                 pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName);
        return(FALSE);
    }

    if(ulIPofGuidDNSName == ulNormalIp){
        // The GUID based DNS Name and Normal DNS Name resolved to the same
        //   IP, so no need to try to reping it or print out an error. Just
        //   bail out.
        Assert(ulIPofGuidDNSName != INADDR_NONE && "What?? This should"
               " never happen, because ulNormalIp should be a valid IP.");
        return(FALSE);
    }
    
    // Interesting case, the resolved IP of the Normal name was different
    //    than that of the resolved Guid based IP.  So lets run a ping off
    //    the Normal DNS Name.

    if((dwRet = Ping(ulNormalIp)) == ERROR_SUCCESS){

        if(ulIPofGuidDNSName == INADDR_NONE){
            // The Guid based name couldn't  be resolved, but the normal name
            //    could be resolved and pinged.
            
            PrintMsg(SEV_ALWAYS,
                     DCDIAG_CONNECTIVITY_DNS_GUID_NAME_NOT_RESOLVEABLE,
                     pServer->pszGuidDNSName, pServer->pszDNSName, pszNormalIp);
            return(TRUE);
        } else {
            // The Guid based DNS name was resolved, but could not be pinged,
            //   the normal name resolved to a different IP, and was pingeable.
            
            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_CONNECTIVITY_DNS_INCONSISTENCY_NO_GUID_NAME_PINGABLE,
                     pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName,
                     pszNormalIp);
            return(TRUE);
        }
    } else {
        if(ulIPofGuidDNSName == INADDR_NONE){
            // The Guid based DNS name couldn't be resolved, but the Normal
            //    DNS name was resolved but couldn't be pinged.

            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_CONNECTIVITY_DNS_NO_GUID_NAME_NORMAL_NAME_PINGABLE,
                     pServer->pszGuidDNSName, pServer->pszDNSName, pszNormalIp);
            return(FALSE);
        } else {
            // Both Guid And Normal DNS names resolved, but to different IPs,
            //   and neither could be pinged.  Most odd case.

            PrintMsg(SEV_ALWAYS,
                         DCDIAG_CONNECTIVITY_DNS_INCONSISTENCY_NO_PING,
                         pServer->pszGuidDNSName, pszGuidIp, pServer->pszDNSName,
                         pszNormalIp);
            return(FALSE);
        }
    }
    Assert(!"Bad programmer!  The conditional above should have taken care of it.");
    return(FALSE);
}
INT
FaPing(
    PDC_DIAG_SERVERINFO              pServer,
    LPWSTR                           pszGuidIp,
    ULONG                            ulIPofGuidDNSName,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
    )

/*++

Routine Description

    This function tries to ping the IP address provided, if successful it calls ...FaLdapCheck(), else it prints a friendly error message and returns a win32Err

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    pszGuidIp - String version of IP address like: L"172.98.233.13"
    ulIPofGuidDNSName - Assumed to be the IP address of the machine, this may not actually be the 
        Guid IP, if this is the first call of this function on the original machine.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
  
    ULONG                        dwRet, dwRet2;

    if((dwRet = Ping(ulIPofGuidDNSName)) == ERROR_SUCCESS){
        dwRet = FaLdapCheck(pServer, ulIPofGuidDNSName, gpCreds);
    } else {
        if(dwRet == ERROR_NOT_ENOUGH_MEMORY){
            PrintMsg(SEV_ALWAYS, DCDIAG_ERROR_NOT_ENOUGH_MEMORY);
        } else {
            if(pServer->pszGuidDNSName == NULL
               || !FaCheckNormalName(pServer, pszGuidIp, ulIPofGuidDNSName)){
                PrintMessage(SEV_ALWAYS, L"Server %s resolved to this IP address %s, \n", 
                             pServer->pszName, pszGuidIp);
                PrintMessage(SEV_ALWAYS, L"but the address couldn't be reached(pinged), so check the network.  \n");
                PrintMessage(SEV_ALWAYS, L"The error returned was: %s  \n", Win32ErrToString(dwRet));

                switch(dwRet){
                case WSA_QOS_NO_RECEIVERS:
                    PrintMessage(SEV_ALWAYS, L"This error more often than not means the local machine is \n");
                    PrintMessage(SEV_ALWAYS, L"disconnected from the network.\n");
                    break;
                case WSA_QOS_ADMISSION_FAILURE:
                    PrintMessage(SEV_ALWAYS, L"This error more often means that the targeted server is \n");
                    PrintMessage(SEV_ALWAYS, L"shutdown or disconnected from the network\n");
                    break;
                default:
                    // Note the default message is printed above.
                    ;
                }
            } // end if there is a Guid Name, ie not a call of this function.
            //  on home server.
            
        } // if/else no memory
    }
    return(dwRet);
}


INT
RUC_FaDNSResolve(
    PDC_DIAG_SERVERINFO              pServer,
    SEC_WINNT_AUTH_IDENTITY_W *      gpCreds
		      )
/*++

Routine Description

    This resolves the pServer->pszGuidDNSName or pServer->pszName provided to a IP address and then 
    calles ...FaPing(), else prints off a friendly descriptive error message and returns a Win32Err.

Arguments:

    pServer (IN) - a pointer to a server DC_DIAG_SERVERINFO struct of the server we are trying to identify.
    gpCreds - User credentials.

Return Value:

    Win 32 Error code.

--*/
{
    ULONG                       ulIPofDNSName;
    ULONG                       dwErr;
    INT                         iTempSize, iTemp;
    CHAR                        cTemp;
    WCHAR                       pszIp[IPADDRSTR_SIZE];
    CHAR                        paszIp[IPADDRSTR_SIZE];
    DWORD                       dwRet;
    LPWSTR                      pszHostName;

    // Guid-based name may not always be set
    pszHostName = (pServer->pszGuidDNSName ? pServer->pszGuidDNSName : pServer->pszName );

    dwErr = GetIpAddrByDnsNameW(pszHostName, pszIp);

    if(dwErr == NO_ERROR){

        wcstombs(paszIp, pszIp, IPADDRSTR_SIZE-1);
	
        ulIPofDNSName = inet_addr(paszIp);
        if(ulIPofDNSName == INADDR_NONE){
            PrintMessage(SEV_ALWAYS, L"The host %s could not be resolved to a valid IP address.\n",
                         pszHostName );
            PrintMessage(SEV_ALWAYS, L"Check the DNS server, DHCP, server name, etc\n");
            return(ERROR_INVALID_PARAMETER);
        }

        dwRet = FaPing(pServer, pszIp, ulIPofDNSName, gpCreds);
	goto CleanExitPoint;
    } else {
        // There was an error in GetIpAddrByDnsNameW()
        dwRet = dwErr;

	switch(dwRet){
	case WSAHOST_NOT_FOUND:
	case WSANO_DATA:
	  PrintMessage(SEV_ALWAYS, L"The host %s could not be resolved to an\n", pszHostName);
          PrintMessage(SEV_ALWAYS, L"IP address.  Check the DNS server, DHCP, server name, etc\n");
	  break;
	case WSATRY_AGAIN:
	case WSAEINPROGRESS:
	case WSAEINTR:
	  PrintMessage(SEV_ALWAYS, L"An error that is usually temporary occured during DNS host lookup,\n");
          PrintMessage(SEV_ALWAYS, L"Please try again later.\n");
	  break;
	case WSANO_RECOVERY:
	  PrintMessage(SEV_ALWAYS, L"An error occured during DNS host lookup, that the program could not\n");
          PrintMessage(SEV_ALWAYS, L"recover from\n");
	  break;
	case WSANOTINITIALISED:
	case WSAENETDOWN:
	  PrintMessage(SEV_ALWAYS, L"There is a problem with the network.  Check to see the sockets\n");
          PrintMessage(SEV_ALWAYS, L"services are up, the computer is connected to the network, etc.\n");
	  break;
	default:
          PrintMessage(SEV_ALWAYS, L"An error cocured during DNS host lookup\n");
        }

        if(pServer->pszGuidDNSName != NULL){
            FaCheckNormalName(pServer, NULL, INADDR_NONE);
        }

	goto CleanExitPoint;
    }

 CleanExitPoint:
    
    return(dwRet);
}

INT 
ReplServerConnectFailureAnalysis(
                             PDC_DIAG_SERVERINFO             pServer,
			     SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
			       )
 /*++

Routine Description:

    Use this to print a message that users would not normally want to
    see but that might be useful in localizing an error.  It will only
    be displayed in verbose mode.  It will return a Win 32 Error, either
    a ERROR_SUCCESS, or the first error it ran into during the process,
    from ldap open() or bind() or DNS lookup, or Ping(), etc.

Arguments:

    pDsInfo (IN) - This is the dcdiag struct of info about the whole enterprise
    ulCurrTargetServer (IN) - This is the server we are targeting for this test
    gpCreds (IN) - Credentials for ldap and 

Return Value:

    Win 32 Error Value;

--*/
{
    DWORD                       dwWin32Err = ERROR_SUCCESS;
    LPWSTR                      pszRet = NULL;
        
    WSASetLastError(0);

    if(pServer == NULL){
        Assert("This shouldn't happen, bad programmer error, someone is calling ReplServerConnectFailureAnalysis() with a NULL for pServer field\n");
        return(ERROR_INVALID_PARAMETER);
    }

    dwWin32Err = RUC_FaDNSResolve(pServer, gpCreds);

    if(dwWin32Err == ERROR_SUCCESS){
        IF_DEBUG( PrintMessage(SEV_ALWAYS, L"Failure Analysis: %s ... OK.\n", 
                                    pServer->pszName) );
    } else {
        pServer->bDnsIpResponding = FALSE;
    }

    return(dwWin32Err);
}


VOID DNSRegistrationHelp (
    DWORD			dwWin32Err
    )
{
    switch (dwWin32Err) {

	case RPC_S_SERVER_TOO_BUSY:
	case EPT_S_NOT_REGISTERED:
	    PrintMessage(SEV_ALWAYS, L"This may be a transient error.  Try running dcdiag again in a\n");
	    PrintMessage(SEV_ALWAYS, L"few minutes.  If the error persists, there might be a problem with\n");
	    PrintMessage(SEV_ALWAYS, L"the target server.  Try running nettest and dcdiag on the target\n");
	    PrintMessage(SEV_ALWAYS, L"server.\n");
	    break;

	case RPC_S_SERVER_UNAVAILABLE:
	    PrintMessage(SEV_ALWAYS, L"This server could not be located on the network.  This might\n");
	    PrintMessage(SEV_ALWAYS, L"be due to one or several of these reasons:\n");
	    PrintMessage(SEV_ALWAYS, L"(a) The target server is temporarily down.\n");
	    PrintMessage(SEV_ALWAYS, L"(b) There is a problem with the target server.  Try running\n");
	    PrintMessage(SEV_ALWAYS, L"    nettest and dcdiag on the target server.\n");
	    PrintMessage(SEV_ALWAYS, L"(c) The target server's DNS name is registered incorrectly\n");
	    PrintMessage(SEV_ALWAYS, L"    in the directory service.\n");
	    break;

	default:
	    break;

    }

}

DWORD 
RPCServiceCheck (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This function checks that the RPC or DsBind services are up and running.

Arguments:
    pServer (IN) - This is the server to check for DsBind service.
    gpCreds (IN) - Credentials for DsBindWithCredW() if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    HANDLE			hDS = NULL;
    DWORD                       ulRet;

    PrintMessage(SEV_VERBOSE, L"* Active Directory RPC Services Check\n");

    ulRet = DcDiagGetDsBinding(pServer, gpCreds, &hDS);
    pServer->bDsResponding = (ulRet == ERROR_SUCCESS);

    return ulRet;
}

DWORD 
LDAPServiceCheck (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This function checks that the ldap services are up and running.

Arguments:
    pServer (IN) - This is the server to check for ldap services.
    gpCreds (IN) - Credentials for ldap_bind_sW() if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD			dwWin32Err;

    PrintMessage(SEV_VERBOSE, L"* Active Directory LDAP Services Check\n");

    dwWin32Err = ReplServerConnectFailureAnalysis(pServer, gpCreds);

    pServer->bLdapResponding = (dwWin32Err == ERROR_SUCCESS); // Not responding
    return dwWin32Err;        
}

DWORD
ReplUpCheckMainEx (
    PDC_DIAG_SERVERINFO            pServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This is the guts/top level function of the UpCheck test, it basically first 
    checks that first DNS is registered, then that it's IP address is pingeable,
    then that ldap services are up and finally that RPC/DsBind services are up.  
    If it fails at any point it prints out suiteable error message an returns an
    error code.

Arguments:
    pServer (IN) - This is the server to check for DsBind service.
    gpCreds (IN) - Credentials for ldap_bind_sW() and DsBindWithCredW() calls if needed.

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD			dwWin32Err = ERROR_SUCCESS;

    if(pServer == NULL){
        Assert("This shouldn't happen, bad programmer error, someone is calling ReplUpCheckMainEx() with a NULL for pServer field\n");
        return(ERROR_INVALID_PARAMETER);
    }

    if(dwWin32Err != ERROR_SUCCESS){
        pServer->bDnsIpResponding = FALSE;
        return dwWin32Err;
    } else {
        dwWin32Err = LDAPServiceCheck(pServer, gpCreds);
        if(dwWin32Err != ERROR_SUCCESS){
            pServer->bLdapResponding = FALSE;
            return dwWin32Err;
        } else {
            dwWin32Err = RPCServiceCheck(pServer, gpCreds);
            if(dwWin32Err != ERROR_SUCCESS){
                pServer->bDsResponding = FALSE;
                return dwWin32Err;
            }
        }
    }

    return ERROR_SUCCESS;
}


VOID
checkClockDifference(
    PDC_DIAG_SERVERINFO pHomeServer,
    PDC_DIAG_SERVERINFO pTargetServer
    )

/*++

Routine Description:

Check if the time at the target server is too far apart from the time at the
home server.

We are comparing the time of ldap connect on these servers, accounting for the
local time delay between collecting the timestamps. We are assuming that time
passes at the same rate on this system as it does on the dc's being measured.

It is assumed that the connect time of the home server is initialized when
dcdiag first starts. See main.c

The timestamp for a particular target is collected before the bind attempt is
made. Thus this routine can be called even if the bind attempt fails.

Arguments:

    pHomeServer - 
    pTargetServer - 

Return Value:

    None

--*/

{
    LONGLONG time1, time2, localSkew, remoteSkew;
#define ONE_SECOND (10 * 1000 * 1000L)
#define ONE_MINUTE (60 * ONE_SECOND)

    // Calculate the local delay in acquiring the two stamps
    time1 = *(LONGLONG*)&(pTargetServer->ftLocalAcquireTime);
    time2 = *(LONGLONG*)&(pHomeServer->ftLocalAcquireTime);
    if (time1 == 0) {
        // If stamp not collected, don't bother
        return;
    }
    Assert( time2 != 0 );
    Assert( time1 >= time2 );

    localSkew = time1 - time2;
    // Round down to nearest second
    // Remote times are only to second accuracy anyway
    localSkew = (localSkew / ONE_SECOND) * ONE_SECOND;

    // Calculate the time clock difference
    time1 = *(LONGLONG*)&(pTargetServer->ftRemoteConnectTime);
    time2 = *(LONGLONG*)&(pHomeServer->ftRemoteConnectTime);
    Assert( time1 != 0 );
    Assert( time2 != 0 );

    time1 -= localSkew;// Account for local collection delay

    // Either computer could be running a little fast
    if (time1 > time2) {
        remoteSkew = time1 - time2;
    } else {
        remoteSkew = time2 - time1;
    }

    if (remoteSkew > ONE_MINUTE) {
        PrintMsg( SEV_ALWAYS, DCDIAG_CLOCK_SKEW_TOO_BIG,
                  pHomeServer->pszName, pTargetServer->pszName );
    }

#undef ONE_MINUTE
#undef ONE_SECOND
} /* checkClockDifference */

DWORD
ReplUpCheckMain (
    PDC_DIAG_DSINFO		   pDsInfo,
    ULONG                          ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *    gpCreds
    )
 /*++

Routine Description:
    This is merely a wrapper routine of ReplUpCheckMainEx(), except this function
    takes a pDsInfo structure and a target server and calls ReplUpCheckMainEx()
    with the appropriate pServer structure.  This is so that this test can be called
    from the array of tests in include\alltests.h, which forces a test to take
    a pDsInfo structure and a target server.

Arguments:

    pDsInfo (IN) - This is the dcdiag struct of info about the whole enterprise
    ulCurrTargetServer (IN) - This is the server we are targeting for this test
    gpCreds (IN) - Credentials for ldap and 

Return Value:
    Win 32 Error Value;

--*/
{
    DWORD status;
    PDC_DIAG_SERVERINFO pHomeServer, pTargetServer;

    if(ulCurrTargetServer == NO_SERVER){
        Assert("The programmer shouldn't call ReplUpCheckMain() with NO_SERVER value");
        return(ERROR_INVALID_PARAMETER);
    }

    pHomeServer = &(pDsInfo->pServers[pDsInfo->ulHomeServer]);
    pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    status = ReplUpCheckMainEx( pTargetServer, gpCreds);

    // Check this regardless of status
    checkClockDifference( pHomeServer, pTargetServer );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\intersite.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    intersite.c

ABSTRACT:

    Contains tests related to checking the health of intersite replication.

DETAILS:

CREATED:

    28 Jun 99   Brett Shirley (brettsh)

REVISION HISTORY:


NOTES:

    The heart of this test lies in the following functions (organized by who 
    calls who), for each site and NC do this:

        ReplIntersiteDoOneSite(
            ReplIntersiteGetISTGInfo(
                IHT_GetOrCheckISTG(
                    IHT_GetNextISTG(
            ReplIntersiteCheckBridgeheads(
            ReplIntersiteSiteAnalysis(

    This is basically it, everything else is really a helper type function, that
    either checks for something, creates a list, modifies a list, or get some
    parameter from a server.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <dsutil.h>
#include <dsconfig.h>
//#include <mdglobal.h>

//Want to #include "..\kcc\kcc.hxx", but couldn't get it to work, plus
//   it is in C++ and this will hissy fit over it. So the evil of all evils
//   a copy.
// Code.Improvement move these constants to dsconfig.h, so I can 
//   #include them from dsconfig
#define KCC_DEFAULT_SITEGEN_FAILOVER           (60) // Minutes.
#define KCC_DEFAULT_SITEGEN_RENEW              (30) // Minutes.

#define KCC_DEFAULT_INTERSITE_FAILOVER_TRIES   (1)
#define KCC_MIN_INTERSITE_FAILOVER_TRIES       (0)
#define KCC_MAX_INTERSITE_FAILOVER_TRIES       (ULONG_MAX)

#define KCC_DEFAULT_INTERSITE_FAILOVER_TIME    (2 * HOURS_IN_SECS) // Seconds
#define KCC_MIN_INTERSITE_FAILOVER_TIME        (0)                 // Seconds
#define KCC_MAX_INTERSITE_FAILOVER_TIME        (ULONG_MAX)         // Seconds

// Used in the ReplIntersiteGetBridgeheadsList().
#define LOCAL_BRIDGEHEADS       0x1
#define REMOTE_BRIDGEHEADS      0x2

#define FAILOVER_INFINITE                0x0FFFFFFF

#include "dcdiag.h"
#include "repl.h"
#include "list.h"
#include "utils.h"

typedef struct {
    ULONG        iNC;
    BOOL         bMaster;
} TARGET_NC, * PTARGET_NC;

typedef struct {
    ULONG                               iSrc;
    ULONG                               iDst;
} CONNECTION_PAIR, * PCONNECTION_PAIR;

typedef struct {
    BOOL           bFailures;
    BOOL           bDown;
    LONG           lConnTriesLeft; // connection failures til KCC declares down.
    LONG           lLinkTriesLeft; // link failures til KCC declares down.
    LONG           lConnTimeLeft; // time til KCC declares down from first connnection failure.
    LONG           lLinkTimeLeft; // time til KCC declares down from first link failure.
} KCCFAILINGSERVERS, *PKCCFAILINGSERVERS;


PDSNAME 
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );

DWORD
IHT_PrintInconsistentDsCopOutError(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iServer,
    LPWSTR                              pszServer
    )
/*++

Description:

    This prints the generic error from having different DS information
    on different DCs.  This handles that error.

Parameters:
    pDsInfo
    iServer or pszServer are optional parameters that describe what DC the
        extra inconsistent info was found on.

Return Value:
    The Win32 error.

  --*/
{
    DWORD                               dwRet;
    
    if((pszServer == NULL && iServer == NO_SERVER)
       || (iServer == pDsInfo->ulHomeServer)){
        // Don't know any servers, so bail badly.
        

        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_INCONSISTENT_DS_COPOUT_UNHELPFUL);
        return(ERROR_DS_CODE_INCONSISTENCY); 
    }
    
    // Server is set in either pszServer, or iServer.
    if(iServer != NO_SERVER){
        // Server is set in iServer, so don't use pszServer
        pszServer = pDsInfo->pServers[iServer].pszName;
    }
    
    PrintMsg(SEV_ALWAYS, 
             DCDIAG_INTERSITE_INCONSISTENT_DS_COPOUT_HOME_SERVER_NOT_IN_SYNC,
             pDsInfo->pServers[pDsInfo->ulHomeServer].pszName,
             pszServer);
    
    return(ERROR_DS_CODE_INCONSISTENCY); 
}

DSTIME
IHT_GetSecondsSince1601()
/*++

Description:

    This function just gets the seconds since 1601, as easy as that.

Return Value:

    a DSTIME, that is the seconds since 1601.

  --*/
{
    SYSTEMTIME sysTime;
    FILETIME   fileTime;
    DSTIME  dsTime = 0, tempTime = 0;

    GetSystemTime( &sysTime );

    // Get FileTime
    SystemTimeToFileTime(&sysTime, &fileTime);

    dsTime = fileTime.dwLowDateTime;
    tempTime = fileTime.dwHighDateTime;
    dsTime |= (tempTime << 32);

    return(dsTime/(10*1000*1000L));
}

VOID
IHT_FreeConnectionList(
    PCONNECTION_PAIR                    pConnections
    )
/*++

Description:

    This frees the pConnections array.  Note this is unnecessary right now, but
    just in case later we want to store more in a connection's list.

Parameters:

    pConnections - 

  --*/
{
    ULONG                               ii;

    if(pConnections == NULL){
        return;
    }
    for(ii = 0; pConnections[ii].iSrc != NO_SERVER; ii++){
        // free any per connection allocated items ...none yet, but maybe soon.
    }

    LocalFree(pConnections);
}

PCONNECTION_PAIR
IHT_GetConnectionList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      LDAP *                      hld,
    IN      ULONG                       iSite
    )
/*++

Description:

    This returns a array of ULONG pairs with a iSrc, and iDst field, for
    the two sides of a connection object.  This returns all connection
    objects with destinations in iSite.

Parameters:

    pDsInfo ... this is how we get at the GUIDs.
    hld ... an LDAP handle to the appropriate server that you want to read
                 the connection objects off of
    iSite ... the site to read all the connection objects for.

Return Value:
  
    Not a pure list function, it returns NULL or an array of 
    CONNECTION_PAIRs.  If it returns NULL, SetLastError should
    have been called.

  --*/
{
    LPWSTR                              ppszConnectionSearch [] = {
        L"enabledConnection",
        L"objectGUID",
        L"fromServer",
        L"distinguishedName",
        NULL };
    LDAPMessage *                       pldmEntry = NULL;
    LDAPMessage *                       pldmConnResults = NULL;
    LPWSTR *                            ppszTemp = NULL;
    DWORD                               dwRet;
    ULONG                               ii, cNumConn, iTempServer;
    ULONG                               iTargetConn = 0;
    PDSNAME                             pdsnameSite = NULL;
    PDSNAME                             pdsnameSiteSettings = NULL;
    PDSNAME                             pdsnameConnection = NULL;
    PDSNAME                             pdsnameServer = NULL;
    PCONNECTION_PAIR                    pConnections = NULL;
    LDAPSearch *                        pSearch = NULL;
    ULONG                               ulTotalEstimate = 0;
    DWORD                               dwLdapErr;

    __try {
    

        SetLastError(ERROR_SUCCESS);

        pdsnameSiteSettings = 
            DcDiagAllocDSName (pDsInfo->pSites[iSite].pszSiteSettings);
        DcDiagChkNull( pdsnameSite = (PDSNAME) LocalAlloc (LMEM_FIXED, 
                                       pdsnameSiteSettings->structLen));
        TrimDSNameBy (pdsnameSiteSettings, 1, pdsnameSite);
        
        // Can connect to supposed ISTG.    

        pSearch = ldap_search_init_page(hld,
					pdsnameSite->StringName,
					LDAP_SCOPE_SUBTREE,
					L"(&(objectCategory=nTDSConnection)(enabledConnection=TRUE))",
					ppszConnectionSearch,
					FALSE, NULL, NULL, 0, 0, NULL);
	if(pSearch == NULL){
	    dwLdapErr = LdapGetLastError();
	    SetLastError(LdapMapErrorToWin32(dwLdapErr));
	    return(NULL);
	}
		  
	dwLdapErr = ldap_get_next_page_s(hld, 
					 pSearch,
					 0,
					 DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					 &ulTotalEstimate,
					 &pldmConnResults);
	if(dwLdapErr == LDAP_NO_RESULTS_RETURNED){
	    SetLastError(ERROR_DS_OBJ_NOT_FOUND);
	    return(NULL);
	}

	while(dwLdapErr == LDAP_SUCCESS){

	    pConnections = (PCONNECTION_PAIR) GrowArrayBy(pConnections,
                       ldap_count_entries(hld, pldmConnResults) + (ULONG)1,
				       sizeof(CONNECTION_PAIR));
	    if(pConnections == NULL){
		// Error should have been set by LocalAlloc in GrowArrayBy().
		return(NULL);
	    }

            pldmEntry = ldap_first_entry(hld, pldmConnResults);
	    for(; pldmEntry != NULL; iTargetConn++){
		// First get destination server.
		ppszTemp = ldap_get_valuesW(hld, pldmEntry, 
					    L"distinguishedName");
		if(ppszTemp == NULL){
		    IHT_FreeConnectionList(pConnections);
		    return(NULL);
        }
        // DcDiagAllocDSName will throw an exception on allocation failure.
		pdsnameConnection = DcDiagAllocDSName (ppszTemp[0]);
		DcDiagChkNull( pdsnameServer = (PDSNAME) LocalAlloc 
			       (LMEM_FIXED, pdsnameConnection->structLen));
		TrimDSNameBy (pdsnameConnection, 1, pdsnameServer);       
		if((iTempServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
						     pdsnameServer->StringName,
						     NULL,NULL))
		   != NO_SERVER){
		    // Setting the connection's destination.
		    pConnections[iTargetConn].iDst = iTempServer;
		} else {
		    IHT_FreeConnectionList(pConnections);
		    SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
								    NO_SERVER,
								    NULL));
		    return(NULL);
		}
		ldap_value_freeW(ppszTemp);
		ppszTemp = NULL;

		// Now get source server.
		ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"fromServer");
		if(ppszTemp == NULL){
		    pConnections[iTargetConn].iDst = NO_SERVER;
		    IHT_FreeConnectionList(pConnections);
		    if(GetLastError() == ERROR_SUCCESS){
			SetLastError(ERROR_DS_CANT_RETRIEVE_ATTS);
		    } 
		    return(NULL);
		}
		if((iTempServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
						     ppszTemp[0], NULL, NULL))
		   != NO_SERVER){
		    // Setting the connection's source.
		    pConnections[iTargetConn].iSrc = iTempServer; 
		} else {
		    pConnections[iTargetConn].iDst = NO_SERVER;
		    IHT_FreeConnectionList(pConnections);
		    SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
								    NO_SERVER, 
								    NULL));
		    return(NULL);
		}
		ldap_value_freeW(ppszTemp);
		ppszTemp = NULL;

		if(pdsnameConnection != NULL) { LocalFree(pdsnameConnection); }
		pdsnameConnection = NULL;
		if(pdsnameServer != NULL) { LocalFree(pdsnameServer); }
		pdsnameServer = NULL;

		pldmEntry = ldap_next_entry (hld, pldmEntry);
	    } // End for each connection object loop
    
	    ldap_msgfree(pldmConnResults);

	    dwLdapErr = ldap_get_next_page_s(hld,
					     pSearch,
					     0,
					     DEFAULT_PAGED_SEARCH_PAGE_SIZE,
					     &ulTotalEstimate,
					     &pldmConnResults);
	} // End of while loop for a page of searches
	if(dwLdapErr != LDAP_NO_RESULTS_RETURNED){
	    SetLastError(LdapMapErrorToWin32(dwLdapErr));
	    return(NULL);
	}

        ldap_search_abandon_page(hld, pSearch);

        pConnections[iTargetConn].iSrc = NO_SERVER;
        pConnections[iTargetConn].iDst = NO_SERVER;
        
    } __finally {

        if(pdsnameSiteSettings != NULL) { LocalFree(pdsnameSiteSettings); }
        if(pdsnameSite != NULL) { LocalFree(pdsnameSite); }
        if(pdsnameConnection != NULL) { LocalFree(pdsnameConnection); }
        if(pdsnameServer != NULL) { LocalFree(pdsnameServer); }
        if(ppszTemp != NULL) { ldap_value_freeW(ppszTemp); }
        if(pldmConnResults != NULL) { ldap_msgfree(pldmConnResults); }

    }
    
    return(pConnections);
}

PCONNECTION_PAIR
IHT_TrimConnectionsForInterSite(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iSite,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description:

    This simply takes a Connections objects list, and kills the ones that
    don't have the requested NC or have a source server that is intrasite.
    i.e. it finds all intersite connections objects with the needed NC. This 
    was just done to make the code a little more broken up.

Parameters:

    pDsInfo
    iSite ... the site to read all the connection objects for.
    pConnections ... an existing list to trim.

Return Value:
  
    Should be a pure list function, except that it does return CONNECTION_PAIRS,
    and not a straight array of ULONGs.

  --*/
{
    ULONG                               iConn, iTargetConn, cConns;
    PCONNECTION_PAIR                    pTemp;

    if(pConnections == NULL){
        return NULL;
    }
    
    for(cConns = 0; pConnections[cConns].iSrc != NO_SERVER; cConns++){
        ; // Note the ";" this counts.
    }

    pTemp = LocalAlloc(LMEM_FIXED, sizeof(CONNECTION_PAIR) * (cConns+1));
    if(pTemp == NULL){
        return(NULL);
    }

    iTargetConn = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        if(pDsInfo->pServers[pConnections[iConn].iSrc].iSite != iSite){
            // This connection pair is an intersite connection.
            pTemp[iTargetConn].iSrc = pConnections[iConn].iSrc;
            pTemp[iTargetConn].iDst = pConnections[iConn].iDst;
            // note may be more to copy someday.
            iTargetConn++;
        }
    }

    pTemp[iTargetConn].iSrc = NO_SERVER;
    pTemp[iTargetConn].iDst = NO_SERVER;
    memcpy(pConnections, pTemp, sizeof(CONNECTION_PAIR) * (iTargetConn+1));
    LocalFree(pTemp);

    return(pConnections);
}

PCONNECTION_PAIR
IHT_TrimConnectionsForInterSiteAndTargetNC(    
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iSite,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description:

    This simply takes a Connections objects list, and kills the ones that
    don't have the requested NC or have a source server that is intrasite.
    i.e. it finds all intersite connections objects with the needed NC. This 
    was just done to make the code a little more broken up.

Parameters:

    pDsInfo
    iSite ... the site to read all the connection objects for.
    pConnections ... an existing list to trim.

Return Value:
  
    Should be a pure list function, except that it does return CONNECTION_PAIRS,
    and not a straight array of ULONGs.

  --*/
{
    ULONG                               iConn, iTargetConn, cConns;
    PCONNECTION_PAIR                    pTemp;

    if(pConnections == NULL){
        return NULL;
    }
    
    for(cConns = 0; pConnections[cConns].iSrc != NO_SERVER; cConns++){
        ; // Note the ";" this counts.
    }

    pTemp = LocalAlloc(LMEM_FIXED, sizeof(CONNECTION_PAIR) * (cConns+1));
    if(pTemp == NULL){
        return(NULL);
    }

    iTargetConn = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        if(pDsInfo->pServers[pConnections[iConn].iSrc].iSite != iSite 
           && (pDsInfo->pszNC != NULL 
               && (DcDiagHasNC(pDsInfo->pszNC, 
                          &(pDsInfo->pServers[pConnections[iConn].iDst]), 
                          TRUE, TRUE) 
                   && DcDiagHasNC(pDsInfo->pszNC, 
                                  &(pDsInfo->pServers[pConnections[iConn].iSrc]), 
                                  TRUE, TRUE)
                   )
               )
           ){
            // This connection pair is intersite and has the right NC.
            pTemp[iTargetConn].iSrc = pConnections[iConn].iSrc;
            pTemp[iTargetConn].iDst = pConnections[iConn].iDst;
            // note may be more to copy someday.
            iTargetConn++;
        }
    }

    pTemp[iTargetConn].iSrc = NO_SERVER;
    pTemp[iTargetConn].iDst = NO_SERVER;
    memcpy(pConnections, pTemp, sizeof(CONNECTION_PAIR) * (iTargetConn+1));
    LocalFree(pTemp);

    return(pConnections);
}

PULONG
IHT_GetSrcSitesListFromConnections(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      PCONNECTION_PAIR            pConnections
    )
/*++

Description
 
    This returns a list of all the src's from the pConnections, with no
    duplicates.

Parameters
  
    pDsInfo
    pConnections ... the connections list to strip the iSrc fields out of.

Return Value:
  
    pure list function, see IHT_GetServerList().

  --*/
{
    ULONG                               iConn, iiTargetSite, iiSite;
    PULONG                              piSites;

    piSites = (PULONG) LocalAlloc(LMEM_FIXED, 
                                  sizeof(ULONG) * (pDsInfo->cNumSites + 1));
    if(pConnections == NULL || piSites == NULL){
        return(NULL);
    }

    iiTargetSite = 0;
    for(iConn = 0; pConnections[iConn].iSrc != NO_SERVER; iConn++){
        // Check to make sure we don't have this site already.
        for(iiSite = 0; iiSite < iiTargetSite; iiSite++){
            if(piSites[iiSite] 
               == pDsInfo->pServers[pConnections[iConn].iSrc].iSite){
                // We already have this site targeted.
                break;
            }
        }
        if(iiSite == iiTargetSite){
            // This means that we didn't find the site in piSites.
            piSites[iiTargetSite] = pDsInfo->pServers[pConnections[iConn].iSrc].iSite;
            iiTargetSite++;
        }    
    }
    piSites[iiTargetSite] = NO_SITE;

    return(piSites);
}

VOID
IHT_GetISTGsBridgeheadFailoverParams(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iISTG,
    OUT     PULONG                      pulIntersiteFailoverTries,
    OUT     PULONG                      pulIntersiteFailoverTime
    )
/*++

Description:

    This function gets the bridgehead failover parameters from the registry
    of the server as indexed by iISTG, or uses the default values.

Parameters:

    pDsInfo
    iISTG ... the server to get the failover parameters of.
    pulIntersiteFailoverTries ... this is how many tries before a bridghead 
            is stale.
    pulIntersiteFailoverTime ... This is how long before a bridgehead is stale.
       ... note that both Tries & Time must be exceeded for a bridgehead to be 
       stale.

Return Value:
  
    No return value, always succeeds ... will use default if thier is an error.

  --*/
{
    HKEY                                hkMachine = NULL;
    HKEY                                hk= NULL;
    CHAR *                              cpszMachine = NULL;
    CHAR *                              cpszTemp = NULL;
    ULONG                               ulTemp = 0;
    DWORD                               dwRet = 0, dwErr = 0, dwType = 0;
    DWORD                               dwSize = 4;
    LPWSTR                              pszMachine = NULL;
    LPWSTR                              pszDsaConfigSection = NULL;
    LPWSTR                              pszKccIntersiteFailoverTries = NULL;
    LPWSTR                              pszKccIntersiteFailoverTime = NULL;

    // This function will either succeed at reading the parameters
    //   of the ISTG's registry OR it will print a warning and use 
    //   the default values below.

    __try{

                                      // 2 for "\\", 1 for null, and 1 extra
        ulTemp = wcslen(pDsInfo->pServers[iISTG].pszName) + 4;
        cpszMachine = LocalAlloc(LMEM_FIXED, sizeof(char) * ulTemp);
        cpszTemp = LocalAlloc(LMEM_FIXED, sizeof(char) * ulTemp);
        if(cpszMachine == NULL || cpszTemp == NULL){
            goto UseDefaultsAndBail;
        }
        
        WideCharToMultiByte(CP_UTF8, 0, pDsInfo->pServers[iISTG].pszName, -1, 
                            cpszTemp, ulTemp, NULL, NULL);
        
        strcpy(cpszMachine, "\\\\");
        strcat(cpszMachine, cpszTemp);
        LocalFree(cpszTemp);
        
        pszMachine = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszMachine == NULL){
            goto UseDefaultsAndBail;
        }
        wcscpy(pszMachine, L"\\\\");
        wcscat(pszMachine, pDsInfo->pServers[iISTG].pszName);
        
        dwRet = RegConnectRegistry(pszMachine, HKEY_LOCAL_MACHINE, &hkMachine);
        if(dwRet != ERROR_SUCCESS){
            goto UseDefaultsAndBail;
        }
        
        ulTemp = strlen(DSA_CONFIG_SECTION) + 1;
        pszDsaConfigSection = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        mbstowcs(pszDsaConfigSection, DSA_CONFIG_SECTION, ulTemp);

        ulTemp = strlen(KCC_INTERSITE_FAILOVER_TRIES) + 1;
        pszKccIntersiteFailoverTries = LocalAlloc(LMEM_FIXED,
                                                  sizeof(WCHAR) * ulTemp);
        mbstowcs(pszKccIntersiteFailoverTries, KCC_INTERSITE_FAILOVER_TRIES, 
                 ulTemp);
        
        ulTemp = strlen(KCC_INTERSITE_FAILOVER_TIME) + 1;
        pszKccIntersiteFailoverTime = LocalAlloc(LMEM_FIXED, 
                                                 sizeof(WCHAR) * ulTemp);
        mbstowcs(pszKccIntersiteFailoverTime, KCC_INTERSITE_FAILOVER_TIME, 
                 ulTemp);
        
        if ((dwRet = RegOpenKey(hkMachine, pszDsaConfigSection, &hk)) 
            == ERROR_SUCCESS){

            // Get Tries if exists;
            if((dwErr = RegQueryValueEx(hk, pszKccIntersiteFailoverTries, 
                                        NULL, &dwType, 
                                        (LPBYTE) pulIntersiteFailoverTries, 
                                        &dwSize))){

                // Parameter not found use the default.
                *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
            } else if (dwType == REG_DWORD){
                // Do nothing, this means the value was found and set.
            } else {
                // This would mean that the dwType was other than REG_DWORD ...
                //    cause for concern?
                *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
            }
            
            // Get Time if exists
            if (dwErr = RegQueryValueEx(hk, pszKccIntersiteFailoverTime, 
                                        NULL, &dwType, 
                                        (LPBYTE) pulIntersiteFailoverTime, 
                                        &dwSize)){
                // Paramter not found use the default.
                *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
            } else if (dwType == REG_DWORD){
                // Do nothing, this means the value was found and set.
            } else {
                // This would mean that the dwType was other than REG_DWORD ...
                //    cause for concern?
                *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
            }
            
        } else {
            RegCloseKey(hkMachine);
            goto UseDefaultsAndBail;
        }
        
        return;
    
    UseDefaultsAndBail:
        
        *pulIntersiteFailoverTries = KCC_DEFAULT_INTERSITE_FAILOVER_TRIES;
        *pulIntersiteFailoverTime = KCC_DEFAULT_INTERSITE_FAILOVER_TIME;
        
    } __finally {

        if (hk) RegCloseKey(hk);
        if (hkMachine) RegCloseKey(hkMachine);
        if(pszMachine != NULL) { LocalFree(pszMachine); }
        if(pszKccIntersiteFailoverTries != NULL) { 
            LocalFree(pszKccIntersiteFailoverTries); 
        }
        if(pszKccIntersiteFailoverTime != NULL) { 
            LocalFree(pszKccIntersiteFailoverTime); 
        }
        if(pszDsaConfigSection != NULL) { 
            LocalFree(pszDsaConfigSection); 
        }

    }
        
}

BOOL
IHT_BridgeheadIsUp(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iServerToCheck,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    IN      BOOL                        bPrintErrors
    )
/*++

Description:

    This function takes the ISTG's parameters of ulIntersiteFailoverTries & 
    ulIntersiteFailoverTime and a server to check, and the failure caches
    from the ISTG and determines if that DC/ISTG's KCC would consider this
    bridgehead to be stale or not.

Parameters:

    pDsInfo
    iServerToCheck ... server to check for staleness
    ulIntersiteFailoverTries ... number of failures not to be exceeded
    ulIntersiteFailoverTime ... length of time not to be exceeded
    pConnectFailures ... the connect failure cache from the ISTG.
    pLinkFailures ... the link failure cache from the ISTG.
    bPrintErrors ... print out the errors.

Return Value:
  
    returns FALSE if the KCC would consider the bridgehead stale/down,
    TRUE otherwise.

  --*/
{
    ULONG                               iFailure;
    DS_REPL_KCC_DSA_FAILUREW *          pFailure = NULL;
    DSTIME                              dstFirstFailure;
    DSTIME                              dstNow;
    DWORD                               dwRet;
    DSTIME                              dstTimeSinceFirstFailure = 0;
    ULONG                               ulTemp;

    dstNow = IHT_GetSecondsSince1601();

    if(pConnectFailures->cNumEntries == 0 && pLinkFailures->cNumEntries == 0){
        return(TRUE);
    }

    dwRet = TRUE;

    for(iFailure = 0; iFailure < pConnectFailures->cNumEntries; iFailure++){
        pFailure = &pConnectFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServerToCheck].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > ulIntersiteFailoverTries){
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                dstTimeSinceFirstFailure = ((ULONG) dstNow - dstFirstFailure);
                if((dstNow - dstFirstFailure) > ulIntersiteFailoverTime){
                    // We know this server is down in connect cache
                    dwRet = FALSE;
                } // end if too long since first failure
            } // end if too many consecutive failures
        } // end if right server by GUID
    }

    for(iFailure = 0; iFailure < pLinkFailures->cNumEntries; iFailure++){
        pFailure = &pLinkFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServerToCheck].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > ulIntersiteFailoverTries){
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                dstTimeSinceFirstFailure = ((ULONG) dstNow - dstFirstFailure);
                if((dstNow - dstFirstFailure) > ulIntersiteFailoverTime){
                    // We know this server is down in the link cache
                    dwRet = FALSE;
                } // end if too long since first failure
            } // end if too many consecutive failures
        } // end if right server by GUID
    }

    return(dwRet);                                

}

PULONG
IHT_GetExplicitBridgeheadList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iISTG
    )
/*++

Description:

    Gets the list of all the explicit brdigeheads for an enterprise, for
    the IP transport.

Parameters:

    pDsInfo
    hld ... an LDAP binding to use to query a server for the explicit 
         bridgehead list.

Return Value:
  
    not quite a pure function, but pretty pure.  Will return NULL, or a 
    pointer to a bridgehead list.  IF NULL, then SetLastError() should have
    been called.

  --*/
{
    LPWSTR                              ppszTransportSearch [] = {
        L"bridgeheadServerListBL",
        NULL };
    // Code.Improvement BUGBUG We should be able to handle 
    //    multiple transports someday.
    LPWSTR                              pszIpContainerPrefix = 
        L"CN=IP,CN=Inter-Site Transports,";
    LPWSTR                              pszNtDsSettingsPrefix = 
        L"CN=NTDS Settings,";
    PULONG                              piExplicitBridgeheads = NULL;
    PDSNAME                             pdsnameSiteSettings = NULL;
    PDSNAME                             pdsnameSitesContainer = NULL;
    LDAPMessage *                       pldmBridgeheads = NULL;
    LDAPMessage *                       pldmBridgeheadResults = NULL;
    LPWSTR *                            ppszExplicitBridgeheads = NULL;
    LPWSTR                              pszTemp = NULL;
    ULONG                               iServer = NO_SERVER;
    ULONG                               ulTemp, i;
    LPWSTR                              pszIpTransport = NULL;
    LDAP *                              hld = NULL;
    DWORD                               dwRet;

    __try {

        dwRet = DcDiagGetLdapBinding(&(pDsInfo->pServers[iISTG]), 
                                     pDsInfo->gpCreds,
                                     FALSE, &hld);
        if(dwRet != ERROR_SUCCESS){
            SetLastError(dwRet);
            return(NULL);
        }

        piExplicitBridgeheads = IHT_GetEmptyServerList(pDsInfo);
        if(piExplicitBridgeheads == NULL){
            SetLastError(IHT_PrintListError(GetLastError()));
            return(NULL);
        }

        // presumes at least one site.
        pdsnameSiteSettings = DcDiagAllocDSName (
            pDsInfo->pSites[0].pszSiteSettings);
        DcDiagChkNull( pdsnameSitesContainer = (PDSNAME) LocalAlloc 
                       (LMEM_FIXED, pdsnameSiteSettings->structLen));
        TrimDSNameBy (pdsnameSiteSettings, 2, pdsnameSitesContainer);
        ulTemp = wcslen(pdsnameSitesContainer->StringName) + 
                 wcslen(pszIpContainerPrefix) + 2;
        pszIpTransport = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
        if(pszIpTransport == NULL){
            SetLastError(IHT_PrintListError(GetLastError()));
            return(NULL);
        }
        wcscpy(pszIpTransport, pszIpContainerPrefix);
        wcscat(pszIpTransport, pdsnameSitesContainer->StringName);
        
        DcDiagChkLdap (ldap_search_sW ( hld,
                                        pszIpTransport,
                                        LDAP_SCOPE_BASE,
                                        L"(objectCategory=interSiteTransport)",
                                        ppszTransportSearch,
                                        0,
                                        &pldmBridgeheadResults));
        
        pldmBridgeheads = ldap_first_entry (hld, pldmBridgeheadResults);
        ppszExplicitBridgeheads = ldap_get_valuesW(hld, pldmBridgeheads, 
                                                   L"bridgeheadServerListBL");
        if(ppszExplicitBridgeheads == NULL){
            // we are done, and empty list is returned because thier 
            //    are no explicit bridgeheads
            return(piExplicitBridgeheads); 
        }
        
        for(i = 0; ppszExplicitBridgeheads[i] != NULL; i++){
            // walk through each explicit bridgehead.
            ulTemp = wcslen(ppszExplicitBridgeheads[i]) + 
                     wcslen(pszNtDsSettingsPrefix) + 2;
            pszTemp = LocalAlloc(LMEM_FIXED, sizeof(WCHAR) * ulTemp);
            if(pszTemp == NULL){
                SetLastError(IHT_PrintListError(GetLastError()));
                return(NULL);
            }
            wcscpy(pszTemp, pszNtDsSettingsPrefix);
            wcscat(pszTemp, ppszExplicitBridgeheads[i]);
            // should have NTDS Settings Dn of a server now.
            iServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, pszTemp, NULL, NULL);
            if(iServer == NO_SERVER){
                SetLastError(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                NO_SERVER, 
                                                                pszTemp));
                return(NULL);
            }
            IHT_AddToServerList(piExplicitBridgeheads, iServer);
            LocalFree(pszTemp);
            pszTemp = NULL;
        }
        
    } __finally {

        if(pdsnameSiteSettings != NULL) { LocalFree(pdsnameSiteSettings); }
        if(pdsnameSitesContainer != NULL) { LocalFree(pdsnameSitesContainer); }
        if(pszIpTransport != NULL) { LocalFree(pszIpTransport); }
        if(pszTemp != NULL) { LocalFree(pszTemp); }
        if(ppszExplicitBridgeheads != NULL) { 
            ldap_value_freeW(ppszExplicitBridgeheads); 
        }
        if(pldmBridgeheadResults != NULL) { 
            ldap_msgfree(pldmBridgeheadResults); 
        }
    }
    
    return(piExplicitBridgeheads);
}

DWORD
IHT_GetFailureCaches(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iServer, // The server num
    HANDLE                              hDS,
    DS_REPL_KCC_DSA_FAILURESW **        ppConnectionFailures,
    DS_REPL_KCC_DSA_FAILURESW **        ppLinkFailures
    )
/*++

Description:
 
    This function retireves the failure caches for the Ds binding handle hDS.

Parameters:

    pDsInfo
    iServer ... The server number, for printing purposes.
    hDS ... effectively server to retrieve failure cache from
    ppConnectionFailures ... pointer to a pointer of failure info to return
    ppLinkFailures ... same as connection failures but for link failures.

Return Value:
  
    not quite a pure function, but pretty pure.  Will return NULL, or a 
    pointer to a bridgehead list.  IF NULL, then SetLastError() should have 
    been called.

  --*/
{
    DWORD                               dwRet;
    DS_REPL_KCC_DSA_FAILURESW *         pFailures;

    dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES,
                              NULL, NULL, &pFailures);
    if (dwRet != ERROR_SUCCESS) {
        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ERROR_GETTING_FAILURE_CACHE_ABORT,
                 pDsInfo->pServers[iServer].pszName,
                 Win32ErrToString(dwRet));
        return(dwRet);
    } else {
        *ppConnectionFailures = pFailures;
        dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_KCC_DSA_LINK_FAILURES,
                                  NULL, NULL, &pFailures);
        if (dwRet != ERROR_SUCCESS) {
            PrintMsg(SEV_ALWAYS, 
                     DCDIAG_INTERSITE_ERROR_GETTING_FAILURE_CACHE_ABORT,
                     pDsInfo->pServers[iServer].pszName, 
                     Win32ErrToString(dwRet));
            if(*ppConnectionFailures != NULL){
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                                  *ppConnectionFailures);            
            }
            return(dwRet);
        } else {
            *ppLinkFailures = pFailures;
        }  // if/else can't get Link Failures
    } // end if/else can't get Connection Failures

    return(ERROR_SUCCESS);
}

VOID
ReplIntersiteSetBridgeheadFailingInfo(
    IN      PDC_DIAG_DSINFO             pDsInfo,
    IN      ULONG                       iServer,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectionFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    IN      PKCCFAILINGSERVERS          prgKCCFailingServer
    )
/*++

Description:

    This function takes the Failure caches and puts them into a nicer
    structured array that can be easily passed around and quickly
    referenced
    
Parameters:

    pDsInfo
    iServer - The server that we are setting up.
    ulIntersiteFailoverTries (IN) - The Failover retries the KCC will make
    ulIntersiteFailoverTime (IN) - The failover time the kcc will wait.
    pConnectionFailures (IN) - The connection failure cache from the ISTG.
    pLinkFailures (IN) - The link failures cache from the ISTG.
    prgKCCFailingServer (OUT) - This is the thing to setup with info
        from the two failure caches.       

--*/
{
    DSTIME                              dstNow;
    DSTIME                              dstFirstFailure;
    ULONG                               iFailure;
    DS_REPL_KCC_DSA_FAILUREW *          pFailure = NULL;


    Assert(pConnectionFailures);
    Assert(pLinkFailures);
    Assert(prgKCCFailingServer != NULL);

    prgKCCFailingServer->bFailures = FALSE;
    prgKCCFailingServer->bDown = FALSE;
    prgKCCFailingServer->lConnTriesLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lLinkTriesLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lConnTimeLeft = FAILOVER_INFINITE;
    prgKCCFailingServer->lLinkTimeLeft = FAILOVER_INFINITE;
    
    dstNow = IHT_GetSecondsSince1601();

    for(iFailure = 0; iFailure < pConnectionFailures->cNumEntries; iFailure++){
        pFailure = &pConnectionFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServer].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > 0){
                prgKCCFailingServer->bFailures = TRUE;
                prgKCCFailingServer->lConnTriesLeft = ulIntersiteFailoverTries - pFailure->cNumFailures;                
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                prgKCCFailingServer->lConnTimeLeft = ulIntersiteFailoverTime - (LONG) (dstNow - dstFirstFailure);
            }
        } // end if right server by GUID
    }

    for(iFailure = 0; iFailure < pLinkFailures->cNumEntries; iFailure++){
        pFailure = &pLinkFailures->rgDsaFailure[iFailure];
        if(memcmp(&(pFailure->uuidDsaObjGuid), 
                  &(pDsInfo->pServers[iServer].uuid), 
                  sizeof(UUID)) == 0){
            // Guids match ... so this server has some failures.
            if(pFailure->cNumFailures > 0){
                prgKCCFailingServer->bFailures = TRUE;
                prgKCCFailingServer->lLinkTriesLeft = ulIntersiteFailoverTries - pFailure->cNumFailures;                
                FileTimeToDSTime(pFailure->ftimeFirstFailure, &dstFirstFailure);
                prgKCCFailingServer->lLinkTimeLeft = ulIntersiteFailoverTime - (LONG) (dstNow - dstFirstFailure);
            }
        } // end if right server by GUID
    }

}

PULONG
IHT_GetKCCFailingServersLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       ulIntersiteFailoverTries,
    IN      ULONG                       ulIntersiteFailoverTime,
    IN      DS_REPL_KCC_DSA_FAILURESW * pConnectionFailures,
    IN      DS_REPL_KCC_DSA_FAILURESW * pLinkFailures,
    OUT     PKCCFAILINGSERVERS *        pprgKCCFailingServers
    )
/*++

Description:

    This gives back a list of which servers in the enterprise are down 
    _according to the KCC_.  And also returns a list of servers that are
    failing, but aren't considered down by the KCC.

Parameters:

    pDsInfo
    ulIntersiteFailoverTries ... the number of tries that are acceptable
    ulIntersiteFailoverTime ... the length of time of failure that is 
         acceptable.
    pConnectionFailures ... connection failures
    pLinkFailures ... link failures
    pprgKCCFailingServers ... out param, for the servers that are failing,
        but not down yet.

Return Value:

    This is a pure list function, it can only fail because a memory alloc 
    failed, see IHT_GetServerList().

  --*/
{
    ULONG                               iServer;
    PULONG                              piKCCDownServers = NULL;

    piKCCDownServers = IHT_GetEmptyServerList(pDsInfo);
    if(piKCCDownServers == NULL){
        return(NULL);
    }
    *pprgKCCFailingServers = LocalAlloc(LMEM_FIXED,
                     pDsInfo->ulNumServers * sizeof(KCCFAILINGSERVERS));
    if(*pprgKCCFailingServers == NULL){
        LocalFree(piKCCDownServers);
        return(NULL);
    }

    // Walk through all servers.
    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){

        ReplIntersiteSetBridgeheadFailingInfo(pDsInfo,
                                     iServer,
                                     ulIntersiteFailoverTries,
                                     ulIntersiteFailoverTime,
                                     pConnectionFailures,
                                     pLinkFailures,
                                     &((*pprgKCCFailingServers)[iServer]));
        
        // Code.Improvement ... make a BridgeheadIsUp(), function
        //   that only takes iServer, and prgKCCFailingServers array.
        if(!IHT_BridgeheadIsUp(pDsInfo,
                               iServer,
                               ulIntersiteFailoverTries,
                               ulIntersiteFailoverTime,
                               pConnectionFailures,
                               pLinkFailures,
                               FALSE)){
            // if not up, add to the list
            IHT_AddToServerList(piKCCDownServers, iServer);

        }
        

    }

    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){
        if(IHT_ServerIsInServerList(piKCCDownServers, iServer)){
            (*pprgKCCFailingServers)[iServer].bDown = TRUE;
        }
    }

    return(piKCCDownServers);
}

PULONG
ReplIntersiteGetUnreacheableServers(
    PDC_DIAG_DSINFO                     pDsInfo
    )
/*++

Description:

    Using the info in pDsInfo, it constructs a list of servers that we
    couldn't contact.

Parameters:

    pDsInfo - mini - enterprise

Return Value:

    NULL if we can't allocate the list, a pointer to the list if we can.

--*/
{
    PULONG                              piUnreacheableServers = NULL;
    ULONG                               iServer;

    piUnreacheableServers = IHT_GetEmptyServerList(pDsInfo);
    if(piUnreacheableServers == NULL){
        return(NULL);
    }    
    
    for(iServer = 0; iServer < pDsInfo->ulNumServers; iServer++){
        if(!pDsInfo->pServers[iServer].bDnsIpResponding 
           || !pDsInfo->pServers[iServer].bDsResponding){
            IHT_AddToServerList(piUnreacheableServers, iServer);
        }    
    } // End for each server.

    return(piUnreacheableServers);
}

VOID
GetInterSiteAttributes(
    IN   LDAP *                         hld,
    IN   LPWSTR                         pszSiteSettings,
    OUT  LPWSTR *                       ppszInterSiteTopologyGenerator,
    OUT  PULONG                         pulInterSiteTopologyFailover,
    OUT  PULONG                         pulInterSiteTopologyRenew
    )
/*++

Description:

    This function gets the relevant attributes of a NTDS Site Settings 
    object, for purpose of locating the ISTG.

Parameters:

    hld ... Ldap binding handle of possible ISTG.
    pszSiteSettings ... string to the CN=NTDS Site Settings,DC=Site,DC=etc 
           string
    ppszInterSiteTopologyGenerator ... return the ISTG string found on this 
           object.
    pulInterSiteTopologyFailover ... the failover period
    pulInterSiteTopologyRenew ... frequency of writes to ISTG attribute.

Return Value:

    NULL in ppszInterSiteTopologyGenerator, that'd be closest to an actual 
    error.

--*/
{
    LPWSTR                              ppszNtdsSiteSearch [] = {
        L"objectGUID",
        L"distinguishedName",
        L"interSiteTopologyGenerator",
        L"interSiteTopologyFailover",
        L"interSiteTopologyRenew",
        NULL };
    LDAPMessage *                       pldmEntry = NULL;
    LDAPMessage *                       pldmNtdsSitesResults = NULL;
    LPWSTR *                            ppszTemp = NULL;
    ULONG                               ulTemp;

    // Can connect to supposed ISTG.
    DcDiagChkLdap (ldap_search_sW ( hld,
                                    pszSiteSettings,
                                    LDAP_SCOPE_BASE,
                                    L"(objectCategory=ntDSSiteSettings)",
                                    ppszNtdsSiteSearch,
                                    0,
                                    &pldmNtdsSitesResults));
    pldmEntry = ldap_first_entry (hld, pldmNtdsSitesResults);
    
    // interSiteTopologyGenerator                
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyGenerator");
    if(ppszTemp != NULL){
        ulTemp = wcslen(ppszTemp[0]) + 2;
        *ppszInterSiteTopologyGenerator = (LPWSTR) LocalAlloc(LMEM_FIXED, 
                                                 sizeof(WCHAR) * ulTemp);
        wcscpy(*ppszInterSiteTopologyGenerator, ppszTemp[0]);
        ldap_value_freeW(ppszTemp);
    } else {
        *ppszInterSiteTopologyGenerator = NULL;
    }
    
    // interSiteTopologyFailover
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyFailover");
    if(ppszTemp != NULL){
        *pulInterSiteTopologyFailover = wcstoul(ppszTemp[0], NULL, 10);
        ldap_value_freeW(ppszTemp);
    } else {
        *pulInterSiteTopologyFailover = KCC_DEFAULT_SITEGEN_FAILOVER;
    }
    
    // interSiteTopologyRenew
    ppszTemp = ldap_get_valuesW(hld, pldmEntry, L"interSiteTopologyRenew");
    if(ppszTemp != NULL){
        *pulInterSiteTopologyRenew = wcstoul(ppszTemp[0], NULL, 10);
        ldap_value_freeW(ppszTemp);
    } else {
        *pulInterSiteTopologyRenew = KCC_DEFAULT_SITEGEN_RENEW;
    }

    if(pldmNtdsSitesResults != NULL) ldap_msgfree (pldmNtdsSitesResults);
}

DWORD
GetTimeSinceWriteStamp(
    HANDLE                              hDS,
    LPWSTR                              pszDn,
    LPWSTR                              pszAttr,
    PULONG                              pulTimeSinceLastWrite
    )
/*++

Description:

    This returns in seconds the time since the last write to the attribute
    pszAttr of the object pszDn.

Parameters:

    hDS ... the handle of the DC to get this info from.
    pszDn ... the DN of the object where the attribute resides that we want
         the last write meta data of.
    pszAttr ... the attribute to retrieve the last write of.
    pulTimeSinceLastWrite ... place to store the time since last write.

Return Value:

    Returns a Win 32 error.

--*/
{
    DSTIME                              dstWriteStamp; 
                                     // dst - Directory Standard Time :)
    DS_REPL_OBJ_META_DATA *             pObjMetaData;
    DWORD                               dwRet = ERROR_SUCCESS;
    ULONG                               iMetaEntry;

    dwRet = DsReplicaGetInfoW(hDS, DS_REPL_INFO_METADATA_FOR_OBJ, pszDn,
                              NULL, &pObjMetaData);
    if (dwRet != ERROR_SUCCESS) {
        return(dwRet);
    }

    for(iMetaEntry = 0; iMetaEntry < pObjMetaData->cNumEntries; iMetaEntry++){
        if(_wcsicmp(pszAttr, pObjMetaData->rgMetaData[iMetaEntry].pszAttributeName) == 0){
            FileTimeToDSTime(pObjMetaData->rgMetaData[iMetaEntry].ftimeLastOriginatingChange, &dstWriteStamp);
            // we have got our meta data!
            break;
        }
    }

    *pulTimeSinceLastWrite = (ULONG) ((IHT_GetSecondsSince1601() - dstWriteStamp)/60);

    DsReplicaFreeInfo(DS_REPL_INFO_METADATA_FOR_OBJ, pObjMetaData);

    return(ERROR_SUCCESS);
}


DWORD
IHT_GetISTGInfo(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN      ULONG                       iSite,
    IN      ULONG                       iServer,
    OUT     LPWSTR *                    ppszLocalISTG,
    OUT     PULONG                      pulInterSiteFailover,
    OUT     PULONG                      pulInterSiteRenew,
    OUT     PULONG                      pulTimeSinceLastISTGWrite
    )
{
    DWORD                               dwRet;
    LDAP *                              hld;
    HANDLE                              hDS;
    
    dwRet = DcDiagGetLdapBinding(&(pDsInfo->pServers[iServer]),
                                     gpCreds, FALSE, &hld);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    dwRet = DcDiagGetDsBinding(&(pDsInfo->pServers[iServer]), gpCreds, &hDS);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    GetInterSiteAttributes(hld, pDsInfo->pSites[iSite].pszSiteSettings,
                           ppszLocalISTG, pulInterSiteFailover, 
                           pulInterSiteRenew);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    } 
    dwRet = GetTimeSinceWriteStamp(hDS, pDsInfo->pSites[iSite].pszSiteSettings, 
                                   L"interSiteTopologyGenerator", 
                                   pulTimeSinceLastISTGWrite);
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    return(ERROR_SUCCESS);
}



DWORD
IHT_GetNextISTG(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iSite,
    IN      PULONG                      piServersSiteOrig,
    IN OUT  PULONG                      pulISTG,
    OUT     PULONG                      pulFailoverTotal
    )
/*++

Description:

    This function is one of the 5 meaty functions that make the intersite 
    test go.  This function will get the ISTG to come, and set the 
    pulFailoverTotal.

Parameters:

    pDsInfo
    iSite ... This is the site we are analyzing.
    piServersSiteOrig ... all the servers for the site, ie potential ISTGs
    pulISTG ... the last guess as an ISTG.
    pulFailoverTotal ... the failover to be set
    ulInterSiteFailover ... 
    ulTimeSinceLastISTGWrite ... the time since the ISTG attribute has been 
         written (in sec?)

Return Value:

    returns a Win 32 error.  If it does this is a fatal error to this test.

  --*/
{
    ULONG                               iiOldISTG, cNumServers, iiTarget;
    ULONG                               iDefunctISTG;
    ULONG                               ulInterSiteRenew;
    LPWSTR                              pszLocalISTG = NULL;
    DWORD                               dwRet;
    PULONG                              piOrderedServers = NULL;
    ULONG                               ulTimeSinceLastISTGWrite = 0;
    ULONG                               ulInterSiteFailover = 0;

    __try{

        iDefunctISTG = *pulISTG;
        for(cNumServers=0; piServersSiteOrig[cNumServers] != NO_SERVER; cNumServers++){
            ; // get number of servers ... note semicolon.
        }
        
        piOrderedServers = IHT_CopyServerList(pDsInfo, piServersSiteOrig);
        piOrderedServers = IHT_OrderServerListByGuid(pDsInfo, 
                                                     piOrderedServers);
        
        if(piOrderedServers == NULL){
            return(IHT_PrintListError(GetLastError()));
        } else if(piOrderedServers[0] == NO_SERVER){
            // No servers in this site
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_NO_SERVERS_IN_SITE_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            return(ERROR_SUCCESS);
        }
        
        for(iiOldISTG=0; piOrderedServers[iiOldISTG] != NO_SERVER; iiOldISTG++){
            if(iDefunctISTG == piOrderedServers[iiOldISTG]){
                break;
            }
        }
        
        if(piOrderedServers[iiOldISTG] == NO_SERVER){
            // the old ISTG has been moved out of the site.
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            return(IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                      NO_SERVER, 
                                                      NULL));
        }
        
        for(iiTarget = (iiOldISTG+1) % cNumServers; iiTarget != iiOldISTG; iiTarget = (iiTarget+1) % cNumServers){

            if(pDsInfo->pServers[piOrderedServers[iiTarget]].bDnsIpResponding 
               && pDsInfo->pServers[piOrderedServers[iiTarget]].bDsResponding 
               && pDsInfo->pServers[piOrderedServers[iiTarget]].bLdapResponding){
                // Server pServers[piOrderedServers[iiTarget]] is up and will 
                //   be the next ISTG.  Calculate failover ... off of time      
                Assert(iiTarget != iiOldISTG && 
                       "If this is the case, we should have dropped out to"
                       " the ii == iiTarget\n");
                
                dwRet = IHT_GetISTGInfo(pDsInfo, pDsInfo->gpCreds, iSite, 
                                        piOrderedServers[iiTarget],
                                        &pszLocalISTG, 
                                        &ulInterSiteFailover, 
                                        &ulInterSiteRenew, 
                                        &ulTimeSinceLastISTGWrite);
                if(dwRet != ERROR_SUCCESS){
                    PrintMsg(SEV_VERBOSE,
                             DCDIAG_INTERSITE_NO_METADATA_TIMESTAMP_ABORT,
                             pDsInfo->pServers[*pulISTG].pszName,
                             pDsInfo->pSites[iSite].pszName);
                    *pulISTG = NO_SERVER;
                    return(dwRet);
                }
                if(_wcsicmp(pszLocalISTG, 
                            pDsInfo->pServers[piOrderedServers[iiTarget]].pszDn)
                   == 0){
                    // Note this server has already take over as the ISTG.
                    *pulFailoverTotal = 0;
                    *pulISTG = piOrderedServers[iiTarget];
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;
                    return(ERROR_SUCCESS);
                }
                if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                pszLocalISTG = NULL;
                
                // Code.Improvement: get max kcc lag, and put in here. Can't
                //    remember where kcc lag is, somewhere is how often the kcc runs.
                // pulFailoverTotal  = (# in between up server and failed ISTG)
                //                                   *   failover period   +    
                //             max kcc lag - Time elapsed since write of ISTG
                //                                                   attribue
                *pulISTG = piOrderedServers[iiTarget]; 
                if(iiTarget > iiOldISTG){
                    *pulFailoverTotal = (iiTarget - iiOldISTG) 
                                        * ulInterSiteFailover +    
                                        15 - ulTimeSinceLastISTGWrite;
                } else {
                    *pulFailoverTotal = (iiTarget + (cNumServers - iiOldISTG))
                                        * ulInterSiteFailover +    
                                        15 - ulTimeSinceLastISTGWrite;
                }
                if(*pulFailoverTotal > (cNumServers * ulInterSiteFailover)){
                    Assert(!"Hey what is up, did the TimeSinceLastWrite "
                           "exceed the down servers\n");
                    // Something's wrong, but it should be about one intersite
                    //   failover before some DC at least tries to take the 
                    //   ISTG role.
                    *pulFailoverTotal = *pulFailoverTotal %
                                         ulInterSiteFailover + 15;
                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_ISTG_CANT_AUTHORATIVELY_DETERMINE,                             
                             pDsInfo->pSites[iSite].pszName,
                             *pulFailoverTotal);
                }
                break;
            }
        }
        if(iiOldISTG == iiTarget){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_ALL_DCS_DOWN_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailoverTotal = 0;
            return(ERROR_SUCCESS);
        }
        
        Assert(piOrderedServers[iiOldISTG] != NO_SERVER);
     
    } __finally {
        if(piOrderedServers != NULL){ LocalFree(piOrderedServers); }
        if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
        pszLocalISTG = NULL;
    }   
    return(ERROR_SUCCESS); 
}

DWORD
IHT_GetOrCheckISTG(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN      ULONG                       iSite,
    IN      PULONG                      piServersForSite,
    IN OUT  PULONG                      pulISTG,
    OUT     PULONG                      pulFailover,
    IN      INT                         iRecursionLevel
    )
/*++

Description:

    This function is one of the 5 meaty functions that make the intersite test 
    go.  This function basically checks if we have the ISTG or makes a guess at
    the ISTG if we don't have the 

Parameters:

    pDsInfo
    iSite ... This is the site we are analyzing.
    piServersForSite ... all the servers for the site, ie potential ISTGs
    pulISTG ... the last guess as an ISTG.
    pulFailover ... the failover to be set
    iRecursionLevel ... to ensure we don't recurse too far.

Return Value:

    returns a Win 32 error.  If it does this is a fatal error to this test.

  --*/
{
    LDAP *                              hld = NULL;
    DWORD                               dwWin32Err = ERROR_SUCCESS;
    DWORD                               dwRet = ERROR_SUCCESS;
    DWORD                               dwRetDS, dwRetLDAP;
    LPWSTR                              pszLocalISTG = NULL;
    ULONG                               ulInterSiteFailover;
    ULONG                               ulInterSiteRenew;
    HANDLE                              hDS;
    ULONG                               ulTimeSinceLastISTGWrite;
    ULONG                               ulFirstGuessISTG;

    Assert(piServersForSite);
    Assert(piServersForSite[0] != NO_SERVER);
    Assert(pulISTG);
    Assert(pulFailover);

    *pulISTG = NO_SERVER;
    *pulFailover = 0;

    __try {

        if(iRecursionLevel > 6){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_CIRCULAR_LOOP_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            *pulISTG = NO_SERVER;
            *pulFailover = 0;
            return(ERROR_SUCCESS);
        }

        if(*pulISTG == NO_SERVER){
            // Get the home servers guess for teh ISTG for the site.
            *pulISTG = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                          pDsInfo->pSites[iSite].pszISTG, 
                                          NULL,NULL);
            if(*pulISTG == NO_SERVER){
                return(IHT_PrintInconsistentDsCopOutError(pDsInfo, NO_SERVER, 
                                         pDsInfo->pSites[iSite].pszISTG));
            }

        } else {
            // pulISTG is set with a DC the caller wants us to try ... 
            //   so lets check out that DC.
        }

        Assert(*pulISTG != NO_SERVER);
        ulFirstGuessISTG = *pulISTG;

        if(pDsInfo->pServers[*pulISTG].iSite == iSite){
            // At least the server is in this site ... go on.

            dwRetLDAP = DcDiagGetLdapBinding(&(pDsInfo->pServers[*pulISTG]),
                                         pDsInfo->gpCreds, FALSE, &hld);
            dwRetDS = DcDiagGetDsBinding(&(pDsInfo->pServers[*pulISTG]), 
                                         pDsInfo->gpCreds, &hDS);

            if((dwRetDS == ERROR_SUCCESS) && (dwRetLDAP == ERROR_SUCCESS)){
                Assert(pDsInfo->pServers[*pulISTG].bDnsIpResponding 
                       && "If this fires, something is wrong with the failure "
                       "anaylsis in RUC_FaDNSResolve OR maybe this is OK, if"
                       "we didn't scope to this server ahead of time.\n");

                GetInterSiteAttributes(hld,
                                       pDsInfo->pSites[iSite].pszSiteSettings,
                                       &pszLocalISTG, &ulInterSiteFailover, 
                                       &ulInterSiteRenew);
                
                if(_wcsicmp(pszLocalISTG, pDsInfo->pSites[iSite].pszISTG) == 0){
                    // the ISTG attribute is consistent on the home server 
                    //    and the ISTG itself.  clear? :)
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;

                    dwRet = GetTimeSinceWriteStamp(hDS, 
                                  pDsInfo->pSites[iSite].pszSiteSettings, 
                                  L"interSiteTopologyGenerator", 
                                  &ulTimeSinceLastISTGWrite);
                    if(dwRet == ERROR_SUCCESS){
                        // Note ulTimeSinceLastISTGWrite is returned in minutes.
                        
                        if( ulTimeSinceLastISTGWrite < ulInterSiteFailover ){
                            // We know this is the authorative ISTG.
                            //   This will be the exit point of this function 
                            //   90% of the time.
                            *pulFailover = 0;
                            return(ERROR_SUCCESS);
                        } else {
                            // Meta data is old, meaning ISTG is past due, 
                            //    a new DC will take ISTG control.
                            PrintMsg(SEV_VERBOSE,
                                     DCDIAG_INTERSITE_OLD_ISTG_TIME_STAMP,
                                     ulTimeSinceLastISTGWrite,
                                     pDsInfo->pServers[*pulISTG].pszName);

                            dwRet = IHT_GetNextISTG(pDsInfo, iSite, 
                                                    piServersForSite,
                                                    pulISTG, 
                                                    pulFailover);
                            if(dwRet != ERROR_SUCCESS) {
                                PrintMsg(SEV_ALWAYS,
                                         DCDIAG_INTERSITE_COULD_NOT_LOCATE_AN_ISTG_ABORT,
                                         pDsInfo->pSites[iSite].pszName);
                                return(dwRet);
                            }
                            if(*pulISTG == NO_SERVER){
                                // Last known to be the ISTG roll.
                                *pulISTG = ulFirstGuessISTG; 
                                // This is indented, becuase of where we come
                                //   from in GetNextISTG kind of completes 
                                //   the error message.
                                PrintMsg(SEV_NORMAL,
                                         DCDIAG_INTERSITE_USING_LAST_KNOWN_ISTG,
                                         pDsInfo->pSites[iSite].pszName,
                                         pDsInfo->pServers[*pulISTG].pszName);
                            }
                        } // end if/else meta data was up to date.
                    } else {
                        // Couldn't get the meta data/time stamp on the 
                        //   ISTG attr.
                        PrintMsg(SEV_ALWAYS,
                                 DCDIAG_INTERSITE_NO_METADATA_TIMESTAMP_ABORT,
                                 pDsInfo->pServers[*pulISTG].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 Win32ErrToString(dwRet));
                        *pulFailover = 0;
                        *pulISTG = NO_SERVER;
                        return(ERROR_SUCCESS);
                    }
                } else {
                    // The ISTG attribute on the home server did not match the 
                    //   ISTG attribute on the ISTG (that was claimed by the 
                    //   home server).  So now goto this new ISTG attribute.
                    //   ... watch out for endless recursion.
                    // Get next guess, which is the local ISTG attribute.
                    *pulISTG = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                                  pszLocalISTG, NULL,NULL);
                    if(*pulISTG == NO_SERVER){
                        dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, 
                                                                 NO_SERVER, 
                                                                 pszLocalISTG);
                        if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                        pszLocalISTG = NULL;
                        return(dwRet);
                    }
                    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
                    pszLocalISTG = NULL;
                    // The iRecurisionLevel+1 ensures no endless recursion.
                    return(IHT_GetOrCheckISTG(pDsInfo, iSite, 
                                              piServersForSite,
                                              pulISTG, 
                                              pulFailover, 
                                              iRecursionLevel+1));
                } //end if/else ISTG attributes matched. 
            } else {
                // Can't connect to current ISTG is he down?  
                //   if so -> IHT_GetNextISTG().
                // Errors for this DC should have already been reported 
                //   by the inital connection tests.
                PrintMsg(SEV_VERBOSE,
                         DCDIAG_INTERSITE_ISTG_DOWN,
                         pDsInfo->pServers[*pulISTG].pszName);
                return(IHT_GetNextISTG(pDsInfo, iSite, 
                                       piServersForSite, 
                                       pulISTG,
                                       pulFailover));
            } // end if/else couldn't connect.
        } else { 
            // ISTG server isn't actually in this site.
            //   Needs a special function.  Code.Imrovement ... be able to
            //   identify that the server was just moved out of the site, and
            //   then figure out the failover and new ISTG anyway.
            PrintMsg(SEV_NORMAL, DCDIAG_INTERSITE_ISTG_MOVED_OUT_OF_SITE,
                     pDsInfo->pServers[*pulISTG].pszName,
                     pDsInfo->pSites[iSite].pszName);
            return(IHT_GetNextISTG(pDsInfo, iSite, 
                                   piServersForSite, 
                                   pulISTG,
                                   pulFailover));
        }
        
    }  __except (DcDiagExceptionHandler(GetExceptionInformation(),
                                        &dwWin32Err)){
    }

    if(pszLocalISTG != NULL) { LocalFree(pszLocalISTG); }
    
    return dwWin32Err;
}

PULONG
ReplIntersiteGetBridgeheadList(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iISTG,
    ULONG                               iSite,
    ULONG                               ulFlag
    )
{
    PULONG                              piBridgeheads = NULL;
    PCONNECTION_PAIR                    paConns = NULL;
    ULONG                               iConn;
    LDAP *                              hldISTG = NULL;
    DWORD                               dwErr;

    Assert(pDsInfo != NULL);
    Assert(iSite != NO_SITE);
    Assert((ulFlag & LOCAL_BRIDGEHEADS) || (ulFlag & REMOTE_BRIDGEHEADS));
    
    dwErr = DcDiagGetLdapBinding(&(pDsInfo->pServers[iISTG]), 
                                 pDsInfo->gpCreds,
                                 FALSE, 
                                 &hldISTG);
    if(dwErr != ERROR_SUCCESS){
        SetLastError(dwErr);
        return(NULL);
    }

    // Get all the connections for every server in the site.
    paConns = IHT_GetConnectionList(pDsInfo, hldISTG, iSite);
    if(paConns == NULL){
        return(NULL);
    }

    // Trims connections to only leave the ones that have this NC on both
    //   sides of the connection, and where the src is in another site.
    paConns = IHT_TrimConnectionsForInterSite(pDsInfo, 
                                              iSite,
                                              paConns);
    if(paConns == NULL){
        return(NULL);
    }

    // Make the list requested for.
    piBridgeheads = IHT_GetEmptyServerList(pDsInfo);
    for(iConn = 0; paConns[iConn].iSrc != NO_SERVER; iConn++){
        if(ulFlag & LOCAL_BRIDGEHEADS){
            IHT_AddToServerList(piBridgeheads, paConns[iConn].iSrc);
        }
        if(ulFlag & REMOTE_BRIDGEHEADS){
            IHT_AddToServerList(piBridgeheads, paConns[iConn].iDst);
        }
    }


    return(piBridgeheads);
}

BOOL
IHT_CheckServerListForNC(
    PDC_DIAG_DSINFO                     pDsInfo,
    PULONG                              piServers,
    LPWSTR                              pszNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials
    )
/*++

Description:

    This function checks all the target servers to see if this NC
    is contained amongst them.

Parameters:

    pDsInfo
    piServers ... The servers to find the naming context among
    pszNC ... The Naming Context to check the target servers
    bDoMasters ... whether to check it for master replicas of pszNC
    bDoPartials ... whether to check it for partial replicas of pszNC

Return Value:

    returns TRUE if one of the target servers has the NC, else FALSE

  --*/
{
    ULONG                               iiDC;

    if(piServers == NULL){
        return(FALSE);
    }

    for(iiDC = 0; piServers[iiDC] != NO_SERVER; iiDC++){
        if(DcDiagHasNC(pszNC, 
                          &(pDsInfo->pServers[pDsInfo->pulTargets[iiDC]]), 
                          bDoMasters, bDoPartials)){
            return(TRUE);
        }
    }
    return(FALSE);
}

PTARGET_NC
IHT_GenerateTargetNCsList(
    PDC_DIAG_DSINFO                     pDsInfo,
    PULONG                              piServers
    )
/*++

Description:

    This generates the targets NCs based on the scope of the run,
    /a or /e.

Parameters:

    pDsInfo

Return Value:

    returns an array of TARGET_NC's, or NULL if a fatal error occurs.

  --*/
{
    ULONG                               iNC, ulTemp, iiTarget;
    LPWSTR *                            ppszzNCs = NULL;
    LPWSTR *                            ppTemp = NULL;
    PDC_DIAG_SERVERINFO                 pServer = NULL;
    PTARGET_NC                          prgTargetNCs = NULL;

    Assert(piServers);

    prgTargetNCs = LocalAlloc(LMEM_FIXED, 
                              sizeof(TARGET_NC) * (pDsInfo->cNumNCs * 2 + 1));
    if(prgTargetNCs == NULL){
        return(NULL);
    }

    iiTarget = 0;
    if(pDsInfo->pszNC != NULL){
        if(IHT_CheckServerListForNC(pDsInfo, piServers, 
                                    pDsInfo->pszNC, TRUE, FALSE)){
            // Add this to the target NC set.
            //   but first must find the NC again, this is a hack.
            for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
                if(_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pDsInfo->pszNC) == 0){
                    prgTargetNCs[iiTarget].iNC = iNC;
                    prgTargetNCs[iiTarget].bMaster = TRUE;
                    iiTarget++;
                }
            }
        } else {
            // check to see if we need to check this NCs read only, only
            //  if we aren't doing a writeable, because then the read only
            //  is piggybacked on the writeable.
            if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                        pDsInfo->pszNC, FALSE, TRUE)){
                // Add this to the target NC set.
                //   but first must find the NC again, this is a hack.
                for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
                    if(_wcsicmp(pDsInfo->pNCs[iNC].pszDn, pDsInfo->pszNC) == 0){
                        prgTargetNCs[iiTarget].iNC = iNC;
                        prgTargetNCs[iiTarget].bMaster = FALSE;
                        iiTarget++;
                    }
                }
            }
        }
    } else {
        // Walk through each NC and see which NCs are on the target servers.
        // BUGBUG ... this code & later code too, will test a partial NC as 
        //   a partial NC on a site of servers that are all master replicas 
        //   for the NC.
        for(iNC = 0; iNC < pDsInfo->cNumNCs; iNC++){
            
            prgTargetNCs[iiTarget].iNC = NO_NC;
            // Check to see if we need to check this NC's read/write
            if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                        pDsInfo->pNCs[iNC].pszDn, 
                                        TRUE, FALSE)){
                // Add this to the target NC set.
                prgTargetNCs[iiTarget].iNC = iNC;
                prgTargetNCs[iiTarget].bMaster = TRUE;
                iiTarget++;
            } else {
                // check to see if we need to check this NCs read only, only
                //  if we aren't doing a writeable, because then the read only
                //  is piggybacked on the writeable.
                if(IHT_CheckServerListForNC(pDsInfo, piServers,
                                            pDsInfo->pNCs[iNC].pszDn, 
                                            FALSE, TRUE)){
                    // Add this to the target NC set.
                    prgTargetNCs[iiTarget].iNC = iNC;
                    prgTargetNCs[iiTarget].bMaster = FALSE;
                    iiTarget++;
                }
            }
        }

    }

    prgTargetNCs[iiTarget].iNC = NO_NC;
    return(prgTargetNCs);
}

PULONG
ReplIntersiteGetRemoteSitesWithNC(
    PDC_DIAG_DSINFO		        pDsInfo, 
    PULONG                              piBridgeheads,
    LPWSTR                              pszNC
    )
/*++

Description:

    Thsi function Gets all the sites from the list of bridgeheads, if there
    is a NC it makes sure that the servers have the NC.

Parameters:

    pDsInfo
    piBridgeheads (IN) - The servers to extrapolate the sites from.
    pszNC (IN) - The optional NC

Return Value:


--*/
{
    ULONG                               iiBridgehead;
    PULONG                              piSites = NULL;

    piSites = LocalAlloc(LMEM_FIXED, sizeof(ULONG) * (pDsInfo->cNumSites + 1));
    if(piSites == NULL){
        return(NULL);
    }
    piSites[0] = NO_SITE;

    for(iiBridgehead = 0; piBridgeheads[iiBridgehead] != NO_SERVER; iiBridgehead++){
        if(pszNC){
            if(DcDiagHasNC(pszNC, &(pDsInfo->pServers[piBridgeheads[iiBridgehead]]),
                           TRUE, TRUE)){
                IHT_AddToServerList(piSites, 
                          pDsInfo->pServers[piBridgeheads[iiBridgehead]].iSite);
            }
        } else {
            IHT_AddToServerList(piSites, 
                         pDsInfo->pServers[piBridgeheads[iiBridgehead]].iSite);
        }
    }

    return(piSites);
}

PULONG
ReplIntersiteTrimServerListByKCCUpness(
    PDC_DIAG_DSINFO		        pDsInfo, 
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether the KCC things they're up.

Parameters:

    pDsInfo
    prgKCCFailingServers (IN) - Holds which servers are failing.
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise teh address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(!prgKCCFailingServers[piOriginalServers[iCheck]].bDown){\
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

PULONG
ReplIntersiteTrimServerListByReacheability(
    PDC_DIAG_DSINFO		        pDsInfo, 
    PULONG                              piUnreacheableServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether dcdiag could verify
    that the servers were up (ping) with and able to DsBind for 
    replication purposes.

Parameters:

    pDsInfo
    piUnreacheableServers (IN) - The state of server from dcdiag's perspective.
        Which is always right, BTW ;)
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise the address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(pDsInfo->pServers[piOriginalServers[iCheck]].bDnsIpResponding
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDsResponding){
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

PULONG
ReplIntersiteTrimServerListByUpness(
    PDC_DIAG_DSINFO		        pDsInfo, 
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piUnreacheableServers,
    PULONG                              piOriginalServers
    )
/*++

Description:

    This trims the list given to it by whether the KCC AND whether
    dcdiag thinks the servers are up.

Parameters:

    pDsInfo
    prgKCCFailingServers (IN) - Holds which servers are failing.
    piUnreacheableServers (IN) - Servers dcdiag couldn't reach.
    piOriginalServers (INOUI) - The server list to trim.
    
Return value

    NULL if it fails, otherwise the address of the piOriginalServers.

--*/
{
    ULONG                               iPut, iCheck;
    
    if(piOriginalServers == NULL){
        return(NULL);
    }

    iPut = 0;
    iCheck = 0;
    while(piOriginalServers[iCheck] != NO_SERVER){
        if(!prgKCCFailingServers[piOriginalServers[iCheck]].bDown
           && !prgKCCFailingServers[piOriginalServers[iCheck]].bFailures
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDnsIpResponding
           && pDsInfo->pServers[piOriginalServers[iCheck]].bDsResponding){
            piOriginalServers[iPut] = piOriginalServers[iCheck];
            iPut++;
        }
        iCheck++;
    }

    return(piOriginalServers);
}

VOID
ReplIntersiteDbgPrintISTGFailureParams(
    PDC_DIAG_DSINFO		        pDsInfo, 
    ULONG                               iSite, 
    ULONG                               iISTG, 
    ULONG                               ulIntersiteFailoverTries, 
    ULONG                               ulIntersiteFailoverTime, 
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures
    )
/*++

Description:

    This prints out a little interesting information if the /d flag is
    specified.

Parameters:

    pDsInfo
    iSite - the site wer are doing
    iISTG - the ISTG of iSite.
    ulIntersiteFailoverTries - The failover param from teh KCC
    ulIntersiteFailoverTime - the failover param from the KCC
    pConnectionFailures - The connection failure cache
    pLinkFailures - The link failure cache
    
    
--*/
{
    if(!(gMainInfo.ulSevToPrint >= SEV_DEBUG)){
        return;
    }
    PrintIndentAdj(1);
    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_DBG_ISTG_FAILURE_PARAMS,
             pDsInfo->pServers[iISTG].pszName,
             ulIntersiteFailoverTries,
             ulIntersiteFailoverTime/60);
    PrintIndentAdj(-1);
    // Code.Improvement: Print out failure caches, steal code from repadmin.
}

DWORD
ReplIntersiteGetISTGInfo(
    PDC_DIAG_DSINFO		        pDsInfo, 
    ULONG                               iSite, 
    PULONG                              piISTG, 
    PULONG                              pulIntersiteFailoverTries, 
    PULONG                              pulIntersiteFailoverTime, 
    DS_REPL_KCC_DSA_FAILURESW **        ppConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW **        ppLinkFailures
    )
/*++

Description:

    This function's purpose is to get all the ISTG info that is necessary for
    the rest of the intersite test to run.  Basically it finds the ISTG,
    using IHT_GetOrCheckISTG(), then gets the LDAP and DS bindings to make
    sure the ISTG can be connected, then gets the connection and link failure
    caches, and finally the failover parameters.

Parameters:

    pDsInfo .
    iSite (IN) - The site we are analyzing.
    piISTG (OUT) - This is an index into pDsInfo->pServers[iISTG] for which
        server is the ISTG.
    pulIntersiteFailoverTries (OUT) - This is how many retries the KCC will
        try before declaring a birdgehead stale, if the *pulIntersiteFailoverTime
        is already exceeded.
    pulIntersiteFailoverTime (OUT) - This is how long before a KCC will call a
        bridgehead stale, if the *pulIntersiteFailoverTries are exceeded.  Note
        that it takes both IntersiteFailover params to be exceeded before a
        bridgehead is declared stale or down for the KCC.
    ppConnectionFailures - The connection failure cache off the ISTG.
    ppLinkFailures - The link failures cache off the ISTG.    

Return Value:

    If there is a fatal error, and the ISTG, or failure caches are not 
    retrieveable, then this will not be ERROR_SUCCESS.

--*/
{
    PULONG                              piSiteServers = NULL;
    ULONG                               ul;
    DWORD                               dwRet, dwRetLdap, dwRetDs;
    ULONG                               ulFailoverTime = 0;
    LDAP *                              hldISTG = NULL;
    HANDLE                              hDSISTG = NULL;

    __try{

        *piISTG = NO_SERVER;
        *ppConnectionFailures = NULL;
        *ppLinkFailures = NULL;

        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_GET_ISTG_INFO);

        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }
        
        piSiteServers = IHT_GetServerList(pDsInfo);
        piSiteServers = IHT_TrimServerListBySite(pDsInfo, iSite, piSiteServers);
        if(piSiteServers == NULL){
            dwRet = IHT_PrintListError(GetLastError());
            __leave;
        }

        // FIRST) Find the Intersite Topology Generator (ISTG).
        *piISTG = NO_SERVER;
        dwRet = IHT_GetOrCheckISTG(pDsInfo, iSite, 
                                   piSiteServers, 
                                   piISTG, 
                                   &ulFailoverTime, 
                                   0);
        if(dwRet == ERROR_SUCCESS){
            if(*piISTG == NO_SERVER){
                // For any error, GetOrCheckISTG has printed out
                //   an message.
                dwRet = ERROR_DS_SERVER_DOWN;
                __leave;
            } else {
                // Only need to print things if GetOrCheckISTG() has returned
                //   successful results, ie ERROR_SUCCESS, and valid server 
                //   index.
                if(ulFailoverTime == 0){
                    // The returned server is the authoratitive ISTG.
                    // Printing is our responsibility here.
                    PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_THE_SITES_ISTG_IS,
                             pDsInfo->pSites[iSite].pszName, 
                             pDsInfo->pServers[*piISTG].pszName);
                } else {
                    // The returned server is the next ISTG to come.
                    // Printing is our responsibility in this case.
                    if(ulFailoverTime < 60){
                        PrintMsg(SEV_NORMAL, 
                                 DCDIAG_INTERSITE_ISTG_FAILED_NEW_ISTG_IN_MIN,
                                 pDsInfo->pServers[*piISTG].pszName, 
                                 ulFailoverTime);
                    } else {
                        PrintMsg(SEV_NORMAL, 
                                 DCDIAG_INTERSITE_ISTG_FAILED_NEW_ISTG_IN_HRS,
                                 pDsInfo->pServers[*piISTG].pszName, 
                                 ulFailoverTime / 60, ulFailoverTime % 60);
                    }
                }
            }
        } else {
            // an error from IHT_GetOrCheckISTG() is a fatal error, but the
            //    a message should have been already printed out.
            __leave;
        }

        // SECOND) Get ISTG's Ldap and Ds bindings.
        dwRetLdap = DcDiagGetLdapBinding(&(pDsInfo->pServers[*piISTG]), 
                                         pDsInfo->gpCreds, FALSE, &hldISTG);
        dwRetDs = DcDiagGetDsBinding(&(pDsInfo->pServers[*piISTG]), 
                                     pDsInfo->gpCreds, &hDSISTG);
        if(dwRetLdap != ERROR_SUCCESS || dwRetDs != ERROR_SUCCESS){
            PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ISTG_CONNECT_FAILURE_ABORT,
                     pDsInfo->pSites[iSite].pszName);
            dwRet = (dwRetLdap != ERROR_SUCCESS)? dwRetLdap : dwRetDs;
            __leave;
        }
        
        // Get failure cache of ISTG.
        dwRet = IHT_GetFailureCaches(pDsInfo, *piISTG, hDSISTG, 
                                     ppConnectionFailures, 
                                     ppLinkFailures);
        if(dwRet != ERROR_SUCCESS){
            // IHT_GetFailureCaches took care of printing errors, just fail out.
            __leave;
        }
        
        // This function will use default values if it can't get these
        //   two values from the registry of the ISTG.
        IHT_GetISTGsBridgeheadFailoverParams(pDsInfo, *piISTG,
                                             pulIntersiteFailoverTries,
                                             pulIntersiteFailoverTime);
        
        // Got an ISTG, it's bindings, and the failure params

    } __finally { 
        
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        
        if(piSiteServers) { LocalFree(piSiteServers); }
        if(dwRet != ERROR_SUCCESS){
            // free up return variables, because function failed.
            if(*ppConnectionFailures != NULL) {
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, 
                                  *ppConnectionFailures);
                *ppConnectionFailures = NULL;
            }
            if(*ppLinkFailures != NULL) {
                DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                                  *ppLinkFailures);
                *ppLinkFailures = NULL;
            }
        } // end of if function failed, so clean upstuff.
    } // End of clean up memory.

    return(dwRet);
} // End of ReplIntersiteGetISTGInfo()


DWORD
ReplIntersiteCheckBridgeheads(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite,
    ULONG                               iISTG,
    ULONG                               ulIntersiteFailoverTries,
    ULONG                               ulIntersiteFailoverTime,
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures,
    PULONG *                            ppiBridgeheads,
    PULONG *                            ppiKCCDownServers,
    PKCCFAILINGSERVERS *                pprgKCCFailingServers,
    PULONG *                            ppiUnreacheableServers
    )
/*++

Description:
   
    This function is simply to print the down bridgeheads, and return a list of
    Bridgeheads, Servers considered down in the KCC, and servers that are 
    unreacheable.
        
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    iISTG - The index into pDsInfo->pServers[iISTG] of the ISTG
    ulIntersiteFailoverTries - Intersite failover tries from the ISTG.
    ulIntersiteFailoverTime - Intersite failover time from the ISTG.
    pConnectionFailures - Connection Failures from the ISTG.
    pLinkFailures - Link Failures from the ISTG.
    ppiBridgeheads (OUT) - The list of bridgeheads to return for site iSite.
    ppiKCCDownServers (OUT) - Down servers as calculated from the above params.
    pprgKCCFailingServers (OUT) - The failures, and the time left til the server
        is down.
    ppiUnreacheableServers - The servers that we haven't contacted.    

Return Value:

    Returns a Win32 Error code for success or not.  Should only return a value
    other than ERROR_SUCCESS, if it couldn't possibly go on.
    
--*/
{
    DWORD                               dwRet = ERROR_SUCCESS;
    ULONG                               iiServer;
    LONG                                lTriesLeft;
    LONG                                lTimeLeft;
    
    __try {
        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_CHECK_BRIDGEHEADS);
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }

        // Get List of bridgeheads.
        *ppiBridgeheads = ReplIntersiteGetBridgeheadList(pDsInfo, iISTG, iSite, 
                                    LOCAL_BRIDGEHEADS | REMOTE_BRIDGEHEADS);
        if(*ppiBridgeheads == NULL){
            dwRet = GetLastError();
            __leave;
        }

        // Get KCC's down & failing servers.
        *ppiKCCDownServers = IHT_GetKCCFailingServersLists(pDsInfo,
                                                      ulIntersiteFailoverTries, 
                                                      ulIntersiteFailoverTime,
                                                      pConnectionFailures, 
                                                      pLinkFailures,
                                                      pprgKCCFailingServers);
        if(*ppiKCCDownServers == NULL){
            dwRet = GetLastError();
            __leave;
        }
        Assert(*pprgKCCFailingServers && "Should have been set by "
               "IHT_GetKCCFailingServers() if we got this far"); 

        // Get servers that we couldn't contact.
        *ppiUnreacheableServers = ReplIntersiteGetUnreacheableServers(pDsInfo);

        // Do local site ...


        // for each bridgehead
        for(iiServer = 0; (*ppiBridgeheads)[iiServer] != NO_SERVER; iiServer++){
            if(pDsInfo->pszNC){
                if(!DcDiagHasNC(pDsInfo->pszNC, 
                                &(pDsInfo->pServers[(*ppiBridgeheads)[iiServer]]),
                                TRUE, TRUE)){
                    // This bridgehead doesn't actually have the specified NC,
                    //   so skip it.
                    continue;
                }
            }

            if(((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]]).bDown){
                Assert(IHT_ServerIsInServerList(*ppiKCCDownServers, 
                                                (*ppiBridgeheads)[iiServer]));
                // KCC is showing enough failures to declare server down.

                PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_KCC_DOWN_REMOTE,
                         pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                         pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                         pDsInfo->pSites[iSite].pszName);

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } else if ((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].bFailures) {
                Assert(!IHT_ServerIsInServerList(*ppiKCCDownServers, (*ppiBridgeheads)[iiServer]));
                // KCC is showing some failures.

                lTriesLeft = min((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lConnTriesLeft,
                                 (*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lLinkTriesLeft);
                lTimeLeft = min((*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lConnTimeLeft,
                                (*pprgKCCFailingServers)[(*ppiBridgeheads)[iiServer]].lLinkTimeLeft);
                Assert(lTriesLeft > 0 || lTimeLeft > 0);
                Assert(lTriesLeft != FAILOVER_INFINITE 
                       || lTimeLeft != FAILOVER_INFINITE);

                if(lTriesLeft == FAILOVER_INFINITE && lTimeLeft == FAILOVER_INFINITE){
                    Assert(!"Don't we have to have a PrintMsg() here. Why doesn't this fall under"
                           " the else clause at the end?\n");
                } else if(lTriesLeft < 0){
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_TIME_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTimeLeft/60/60, lTimeLeft/60%60);

                } else if (lTimeLeft < 0) {
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_TRIES_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTriesLeft);
                } else {
                    PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_BRIDGEHEAD_BOTH_LEFT,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName,
                             lTimeLeft/60/60, lTimeLeft/60%60, lTriesLeft);
                }

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } else {
                // The bridgehead appears to be up and replicating fine.
                Assert(!IHT_ServerIsInServerList(*ppiKCCDownServers, (*ppiBridgeheads)[iiServer]));

                PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BRIDGEHEAD_UP,
                         pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                         pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);

                if(!pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDnsIpResponding 
                   || !pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].bDsResponding){
                    // Also we couldn't contact the server

                    PrintMsg(SEV_ALWAYS, 
                             DCDIAG_INTERSITE_BRIDGEHEAD_UNREACHEABLE_REMOTE,
                             pDsInfo->pSites[pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].iSite].pszName,
                             pDsInfo->pServers[(*ppiBridgeheads)[iiServer]].pszName);
                }
            } // end if/elseif/else state of bridgehead upness.

        } // End of for each bridgehead

    } __finally {
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        if(dwRet != ERROR_SUCCESS){
            // Function failed clean up return parameters, but ONLY ON ERROR.
            if(*ppiBridgeheads){
                LocalFree(*ppiBridgeheads);
                *ppiBridgeheads = NULL;
            }
            if(*ppiKCCDownServers) { 
                LocalFree(*ppiKCCDownServers); 
                *ppiKCCDownServers = NULL;
            }
            if(*pprgKCCFailingServers){
                LocalFree(*pprgKCCFailingServers);
                *pprgKCCFailingServers = NULL;
            }
            if(*ppiUnreacheableServers){
                LocalFree(*ppiUnreacheableServers);
                *ppiUnreacheableServers = NULL;
            }
        }
    }
    
    return(dwRet);
} // End of ReplIntersiteCheckBridgeheads()

BOOL
ReplIntersiteDoThisNCP(
    PTARGET_NC                         prgLocalNC,
    PTARGET_NC                         paRemoteNCs
    )
/*++

Description:
   
    A predicate function (that the P at the end), determines whether
    the NC in prgLocalNC is in the array of NCs in paRemoteNCs.
        
Parameters:

    prgLocalNC - The NC to find
    paRemoteNCs - The NCs to search.

Return Value:

    TRUE if it finds the NC in the NCs, FALSE otherwise.
        
--*/
{
    ULONG                             iiNC;
    
    Assert(paRemoteNCs != NULL && prgLocalNC != NULL);

    for(iiNC = 0; paRemoteNCs[iiNC].iNC != NO_NC; iiNC++){
        if(prgLocalNC->iNC == paRemoteNCs[iiNC].iNC
           && (paRemoteNCs[iiNC].bMaster || (prgLocalNC->bMaster 
                                             && paRemoteNCs[iiNC].bMaster))){
            return(TRUE);
        }
    }
    return(FALSE);
}

BOOL
ReplIntersiteServerListHasNC(
    PDC_DIAG_DSINFO                    pDsInfo,
    PULONG                             piServers,
    ULONG                              iNC,
    BOOL                               bMaster,
    BOOL                               bPartial
    )
/*++

Description:
   
    This is just like DcDiagHaNC, except it operates on a list of servers,
    instead of on a single server.
        
Parameters:

    pDsInfo
    piServers - The list of servers to search for the NC
    iNC - The NC to search for.
    bMaster - To search for it as a master NC
    bPartial - To search for it as a partial NC

Return Value:

    TRUE if it finds the NC in the list of servers, FALSE otherwise.
        
--*/
{
    ULONG                              iiSer;

    if(piServers == NULL){
        return(FALSE);
    }

    for(iiSer = 0; piServers[iiSer] != NO_SERVER; iiSer++){
        if(DcDiagHasNC(pDsInfo->pNCs[iNC].pszDn,
                       &(pDsInfo->pServers[piServers[iiSer]]),
                       bMaster, bPartial)){
            return(TRUE);
        }
    }
    return(FALSE);
}

DWORD
ReplIntersiteSiteAnalysis(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite,
    ULONG                               iISTG,
    ULONG                               ulIntersiteFailoverTries,
    ULONG                               ulIntersiteFailoverTime,
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures, 
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures,
    PULONG                              piBridgeheads,
    PULONG                              piKCCDownServers,
    PKCCFAILINGSERVERS                  prgKCCFailingServers,
    PULONG                              piUnreacheableServers
    )
/*++
Description:
   
    This function does the site analysis to determine which NCs can't
    replicate in.
        
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    iISTG - The index into pDsInfo->pServers[iISTG] of the ISTG
    ulIntersiteFailoverTries - Intersite failover tries from the ISTG.
    ulIntersiteFailoverTime - Intersite failover time from the ISTG.
    pConnectionFailures - Connection Failures from the ISTG.
    pLinkFailures - Link Failures from the ISTG.
    piKCCDownServers - Down servers as calculated from the above params.

Return Value:

    Returns a Win32 Error code for success or not.  If all NCs can progress in
    replication then ERROR_SUCCESS is returned.

--*/
{
    DWORD                               dwRet = ERROR_SUCCESS;
    PTARGET_NC                          prgLocalNCs = NULL;
    PTARGET_NC                          prgRemoteNCs = NULL;
    PULONG                              piRSites = NULL;
    ULONG                               iiBridgehead;
    ULONG                               iiNC;
    ULONG                               iRSite;
    // These server lists will be trimmed by thier level of "upness".  See below.
    PULONG                              piLocalBridgeheads = NULL;
    PULONG                              piExplicitBridgeheads = NULL;
    PULONG                              piKCCUpBridgeheads = NULL;
    PULONG                              piReacheableBridgeheads = NULL;
    PULONG                              piUpBridgeheads = NULL;
    // These correspong to the 3 lists above, but trimmed by Site.
    PULONG                              piRemoteBridgeheads = NULL;
    PULONG                              piExpGotSiteBrdhds = NULL;
    PULONG                              piKUpGotSiteBrdhds = NULL;
    PULONG                              piReachGotSiteBrdhds = NULL;
    PULONG                              piUpGotSiteBrdhds = NULL;
    // These will be trimed by NC as well
    PULONG                              piExpGotNCGotSiteBrdhds = NULL;
    PULONG                              piKUpGotNCGotSiteBrdhds = NULL;
    PULONG                              piReachGotNCGotSiteBrdhds = NULL;
    PULONG                              piUpGotNCGotSiteBrdhds = NULL;

    BOOL                                bFailures;

    Assert(piBridgeheads);
    Assert(piKCCDownServers);
    Assert(prgKCCFailingServers);
    Assert(piUnreacheableServers);
    
    __try {
        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_BEGIN_SITE_ANALYSIS);
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(1); 
        }

        // ---------------------------------------------------------------------  
        // if (there are no failures in the bridgeheads, then we need not
        // go on ... this site is OK.  This is sort of an opt out early thing.
        bFailures = FALSE;
        for(iiBridgehead = 0; piBridgeheads[iiBridgehead] != NO_SERVER; iiBridgehead++){

            if(prgKCCFailingServers[piBridgeheads[iiBridgehead]].bDown){
                bFailures = TRUE;
            }
            if(prgKCCFailingServers[piBridgeheads[iiBridgehead]].bFailures){
                bFailures = TRUE;
            }
            if(IHT_ServerIsInServerList(piUnreacheableServers, piBridgeheads[iiBridgehead])){
                bFailures = TRUE;
            }
        }
        if(!bFailures){
            // No brigeheads failed or even are failing or even are
            //    just  unreacheable, so print all is fine and leave;
            PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_ALL_SITES_UP,
                     pDsInfo->pSites[iSite].pszName);
            __leave;
        }

        // ---------------------------------------------------------------------
        // Get all the target remote sites.
        piRSites = ReplIntersiteGetRemoteSitesWithNC(pDsInfo, 
                                                     piBridgeheads, 
                                                     pDsInfo->pszNC);
        if(piRSites == NULL){
            dwRet = IHT_PrintListError(GetLastError());
            __leave;
        }

        // ---------------------------------------------------------------------
        // Detemine various arrays of bridgeheads with different kinds of 
        //   "upness".  Each version of upness is explained when set.
        
        // This is a list of the local bridgeheads.
        piLocalBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piLocalBridgeheads = IHT_TrimServerListBySite(pDsInfo, iSite, piLocalBridgeheads);

        // piExplicitBridgeheads or ipExpBrdhdsXXXX, are lists that will 
        //   be used to determine if we need only pay attention to bridgeheads.
        piExplicitBridgeheads = IHT_GetExplicitBridgeheadList(pDsInfo, iISTG);

        // piKCCUpBridgeheads, or piKUpBrdhdsXXXX, are lists with only
        //   bridgeheads that qualify in the kCC of the ISTG as being up.
        piKCCUpBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piKCCUpBridgeheads = 
            ReplIntersiteTrimServerListByKCCUpness(pDsInfo,
                                                   prgKCCFailingServers,
                                                   piKCCUpBridgeheads);

        // piReacheableBridgeheads, or piReachBrdhdsXXXX, are lists with only
        //   bridgeheads that dcdiag personally contacted.
        piReacheableBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piReacheableBridgeheads = 
            ReplIntersiteTrimServerListByReacheability(pDsInfo,
                                                       piUnreacheableServers,
                                                       piReacheableBridgeheads);

        // piUpBridgeheads, or piUpBrdhdsXXXX, are lists with only bridgeheads
        //   that are up, by the contrived definition described in the 
        //   ReplIntersiteTrimByUpness() function.
        piUpBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
        piUpBridgeheads = 
            ReplIntersiteTrimServerListByUpness(pDsInfo,
                                                prgKCCFailingServers,
                                                piUnreacheableServers,
                                                piUpBridgeheads);

        // Check to make sure all these lists were setup correctly.
        if(!piExplicitBridgeheads || !piKCCUpBridgeheads 
           || !piReacheableBridgeheads || !piUpBridgeheads){
            dwRet = IHT_PrintListError(GetLastError()); 
            __leave;
        }

        // ---------------------------------------------------------------------
        // Setup our target NC's array, so we can walk through it in a moment.
        if(pDsInfo->pszNC != NULL){
            prgLocalNCs = LocalAlloc(LMEM_FIXED, sizeof(TARGET_NC) * 3);
            if(prgLocalNCs == NULL){
                dwRet = IHT_PrintListError(GetLastError());
                __leave;
            }
            prgLocalNCs[0].iNC = DcDiagGetNCNum(pDsInfo, pDsInfo->pszNC, NULL);
            if(prgLocalNCs[0].iNC == NO_NC){
                dwRet = IHT_PrintInconsistentDsCopOutError(pDsInfo, iISTG, NULL);
                __leave;
            }
            prgLocalNCs[0].bMaster = ReplIntersiteServerListHasNC(pDsInfo, 
                                                            piLocalBridgeheads,
                                                            prgLocalNCs[0].iNC, 
                                                            TRUE, FALSE);
            if(!ReplIntersiteServerListHasNC(pDsInfo, piLocalBridgeheads, prgLocalNCs[0].iNC, FALSE, TRUE)){
                PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_MISTAKE);
                dwRet = ERROR_SUCCESS;
                __leave;
            }
            prgLocalNCs[1].iNC = NO_NC;
        } else {
            // Get all the target NCs for this site.
            if((prgLocalNCs = IHT_GenerateTargetNCsList(pDsInfo, piLocalBridgeheads)) 
               == NULL){
                return(IHT_PrintListError(GetLastError()));
            }

            if(prgLocalNCs[0].iNC == NO_NC){
                PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_MISTAKE);
                Assert(!"This is an invalid code path now ... I think.  -BrettSh");
                return(ERROR_SUCCESS);
            }
        }

        // -------------------------------------------------------------------
        // Start walking through the sites.
        for(iRSite = 0; iRSite < pDsInfo->cNumSites; iRSite++){

            if(iRSite == iSite){
                // Skip the local site.
                continue;
            }

            // Get site stuff.
            piRemoteBridgeheads = IHT_CopyServerList(pDsInfo, piBridgeheads);
            piExpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piExplicitBridgeheads);
            piKUpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piKCCUpBridgeheads);
            piReachGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piReacheableBridgeheads);
            piUpGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piUpBridgeheads);
            piRemoteBridgeheads = IHT_TrimServerListBySite(pDsInfo, 
                                                           iRSite, 
                                                           piRemoteBridgeheads);
            piExpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                          piExpGotSiteBrdhds);
            piKUpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                        piKUpGotSiteBrdhds);
            piReachGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                          piReachGotSiteBrdhds);
            piUpGotSiteBrdhds = IHT_TrimServerListBySite(pDsInfo, iSite,
                                                       piUpGotSiteBrdhds);
            if(!piExpGotSiteBrdhds || !piKUpGotSiteBrdhds 
               || !piReachGotSiteBrdhds || ! piUpGotSiteBrdhds){
                dwRet = IHT_PrintListError(GetLastError()); 
                __leave;
            }
            
            prgRemoteNCs = IHT_GenerateTargetNCsList(pDsInfo, piRemoteBridgeheads);

            // Start walking through each of the target NCs.
            for(iiNC = 0; prgLocalNCs[iiNC].iNC != NO_NC; iiNC++){

                // Deterimine if the Bridgeheads of the remote site support this NC.
                if(!ReplIntersiteDoThisNCP(&(prgLocalNCs[iiNC]), prgRemoteNCs)){
                    // This paticular NC isn't on the remote site.
                    continue;
                }
                
                if(prgLocalNCs[iiNC].bMaster){
                    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_ANALYSIS_GOT_TO_ANALYSIS_RW,
                             pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName,
                             pDsInfo->pSites[iRSite].pszName);
                } else {
                    PrintMsg(SEV_DEBUG, DCDIAG_INTERSITE_ANALYSIS_GOT_TO_ANALYSIS_RO,
                        pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName,
                        pDsInfo->pSites[iRSite].pszName);
                }

                piExpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piExpGotSiteBrdhds);
                piKUpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piKUpGotSiteBrdhds);
                piReachGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piReachGotSiteBrdhds);
                piUpGotNCGotSiteBrdhds = IHT_CopyServerList(pDsInfo, piUpGotSiteBrdhds);
                
                piExpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                 prgLocalNCs[iiNC].iNC,
                                                                 TRUE, 
                                                                 !prgLocalNCs[iiNC].bMaster,
                                                                 piExpGotNCGotSiteBrdhds);
                piKUpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                 prgLocalNCs[iiNC].iNC,
                                                                 TRUE,
                                                                 !prgLocalNCs[iiNC].bMaster,
                                                                 piKUpGotNCGotSiteBrdhds);
                piReachGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                   prgLocalNCs[iiNC].iNC,
                                                                   TRUE,
                                                                   !prgLocalNCs[iiNC].bMaster,
                                                                   piReachGotNCGotSiteBrdhds);
                piUpGotNCGotSiteBrdhds = IHT_TrimServerListByNC(pDsInfo,
                                                                prgLocalNCs[iiNC].iNC,
                                                                TRUE,
                                                                !prgLocalNCs[iiNC].bMaster,
                                                                piUpGotNCGotSiteBrdhds);
                if(!piExpGotNCGotSiteBrdhds || !piKUpGotNCGotSiteBrdhds 
                   || !piReachGotNCGotSiteBrdhds || !piUpGotNCGotSiteBrdhds){
                    dwRet = IHT_PrintListError(GetLastError());
                    __leave;
                }
            
                if(piExpGotNCGotSiteBrdhds[0] != NO_SERVER){
                    // We've got explicit bridgeheads.
                    // readjust the upness lists.
                    piKUpGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                 piKUpGotNCGotSiteBrdhds,
                                                                 piExpGotNCGotSiteBrdhds);
                    piReachGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                   piReachGotNCGotSiteBrdhds,
                                                                   piExpGotNCGotSiteBrdhds);
                    piUpGotNCGotSiteBrdhds = IHT_AndServerLists(pDsInfo,
                                                                piUpGotNCGotSiteBrdhds,
                                                                piExpGotNCGotSiteBrdhds);
                    if(!piKUpGotNCGotSiteBrdhds 
                       || !piReachGotNCGotSiteBrdhds 
                       || !piUpGotNCGotSiteBrdhds){
                        dwRet = IHT_PrintListError(GetLastError());
                        __leave;
                    }
                }

                // FINALLY DO FAILURE ANALYSIS ==============================
                // Note: this is the mean this is wh)at it all is for. :)
                // for prgTargetNCs[iiNC], iRSite.

                if(piKUpGotNCGotSiteBrdhds[0] == NO_SERVER){
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_SERVERS_AVAIL_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_SERVERS_AVAIL_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                } else if(piUpGotNCGotSiteBrdhds[0] == NO_SERVER){
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_GOOD_SERVERS_AVAIL_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_ALWAYS, DCDIAG_INTERSITE_ANALYSIS_NO_GOOD_SERVERS_AVAIL_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                } else {
                    if(prgLocalNCs[iiNC].bMaster){
                        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_SITE_IS_GOOD_RW,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    } else {
                        PrintMsg(SEV_VERBOSE, DCDIAG_INTERSITE_ANALYSIS_SITE_IS_GOOD_RO,
                                 pDsInfo->pSites[iRSite].pszName,
                                 pDsInfo->pSites[iSite].pszName,
                                 pDsInfo->pNCs[prgLocalNCs[iiNC].iNC].pszName);
                    }
                }

                // END FAILURE ANALYSIS =====================================

                // Clean up the server lists for this NC
                if(piExpGotNCGotSiteBrdhds){ 
                    LocalFree(piExpGotNCGotSiteBrdhds);
                    piExpGotNCGotSiteBrdhds = NULL;
                }
                if(piKUpGotNCGotSiteBrdhds){ 
                    LocalFree(piKUpGotNCGotSiteBrdhds);
                    piKUpGotNCGotSiteBrdhds = NULL;
                }
                if(piReachGotNCGotSiteBrdhds){ 
                    LocalFree(piReachGotNCGotSiteBrdhds); 
                    piReachGotNCGotSiteBrdhds = NULL;
                }
                if(piUpGotNCGotSiteBrdhds){ 
                    LocalFree(piUpGotNCGotSiteBrdhds);
                    piUpGotNCGotSiteBrdhds = NULL;
                }


            }  // end for each NC
        
        
            // Clean up the server lists for this Site.
            if(piRemoteBridgeheads){
                LocalFree(piRemoteBridgeheads);
                piRemoteBridgeheads = NULL;
            }
            if(piExpGotSiteBrdhds){
                LocalFree(piExpGotSiteBrdhds);
                piExpGotSiteBrdhds = NULL;
            }
            if(piKUpGotSiteBrdhds){
                LocalFree(piKUpGotSiteBrdhds);
                piKUpGotSiteBrdhds = NULL;
            }
            if(piReachGotSiteBrdhds){
                LocalFree(piReachGotSiteBrdhds);
                piReachGotSiteBrdhds = NULL;
            }
            if(piUpGotSiteBrdhds){
                LocalFree(piUpGotSiteBrdhds);
                piUpGotSiteBrdhds = NULL;
            }
            if(prgRemoteNCs){
                LocalFree(prgRemoteNCs);
                prgRemoteNCs = NULL;
            }

        } // end for each site.

    } __finally {
        if(gMainInfo.ulSevToPrint >= SEV_VERBOSE){
            PrintIndentAdj(-1); 
        }
        if(prgLocalNCs){ LocalFree(prgLocalNCs); }
        if(prgRemoteNCs){ LocalFree(prgRemoteNCs); }
        
        if(piRSites) { LocalFree(piRSites); }

        // Clean up all those darn server lists I used to do analysis.
        if(piExplicitBridgeheads){ LocalFree(piExplicitBridgeheads); }
        if(piKCCUpBridgeheads){ LocalFree(piKCCUpBridgeheads); }
        if(piReacheableBridgeheads){ LocalFree(piReacheableBridgeheads); }
        if(piUpBridgeheads){ LocalFree(piUpBridgeheads); }
        if(piRemoteBridgeheads) { LocalFree(piRemoteBridgeheads); }
        if(piExpGotSiteBrdhds){ LocalFree(piExpGotSiteBrdhds); }
        if(piKUpGotSiteBrdhds){ LocalFree(piKUpGotSiteBrdhds); }
        if(piReachGotSiteBrdhds){ LocalFree(piReachGotSiteBrdhds); }
        if(piUpGotSiteBrdhds){ LocalFree(piUpGotSiteBrdhds); }
        if(piExpGotNCGotSiteBrdhds){ LocalFree(piExpGotNCGotSiteBrdhds); }
        if(piKUpGotNCGotSiteBrdhds){ LocalFree(piKUpGotNCGotSiteBrdhds); }
        if(piReachGotNCGotSiteBrdhds){ LocalFree(piReachGotNCGotSiteBrdhds); }
        if(piUpGotNCGotSiteBrdhds){ LocalFree(piUpGotNCGotSiteBrdhds); }
        if(piLocalBridgeheads) { LocalFree(piLocalBridgeheads); }
    }

    return(dwRet);
}

DWORD
ReplIntersiteDoOneSite(
    PDC_DIAG_DSINFO                     pDsInfo,
    ULONG                               iSite
    )
/*++
Description:
   
    This is the heart of the Inbound Intersite Replication test.  This function,
    does inbound intersite replication test on one site (iSite).  It basically
    holds together the 3 most important functions of intersite:
        ReplIntersiteGetISTGInfo()
        ReplIntersiteCheckBridgeheads()
        ReplIntersiteSiteAnalysis()
       
    
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to test.

Return Value:

    Returns a Win32 Error on whether it could proceed or whether inbound
    intersite replication seems A-OK.
    
Notes:

    The function has 3 parts,
        1) Get and establish bindings to the ISTG or furture ISTG, and get
            various ISTG info, failure caches, failover params, etc
        2) Print out down bridgeheads wrt to the KCC, and bridgeheads that
            look like they are not responding and starting to fail in the KCC.
        3) Do site analysis based on the down bridgeheads, and print out an
            NCs and remote sites that seem to be not replicating in.

--*/
{
    DWORD                               dwRet;
    
    // Things returned by ReplIntersiteGetISTG()
    ULONG                               iISTG = NO_SERVER;
    ULONG                               ulIntersiteFailoverTries = 0;
    ULONG                               ulIntersiteFailoverTime = 0;
    DS_REPL_KCC_DSA_FAILURESW *         pConnectionFailures = NULL;
    DS_REPL_KCC_DSA_FAILURESW *         pLinkFailures = NULL;    
    PULONG                              piBridgeheads = NULL;
    PULONG                              piKCCDownServers = NULL;
    PKCCFAILINGSERVERS                  prgKCCFailingServers = NULL;
    PULONG                              piUnreacheableServers = NULL;

    __try{
    
        // Get ISTG and related info ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteGetISTGInfo(pDsInfo, iSite, 
                                         &iISTG, 
                                         &ulIntersiteFailoverTries,
                                         &ulIntersiteFailoverTime,
                                         &pConnectionFailures,
                                         &pLinkFailures);
        if(dwRet != ERROR_SUCCESS){
            // There was an error trying to find/contact an ISTG.
            // The function should have taken care of printing the error.
            __leave;
        }
        Assert(iISTG != NO_SERVER);
        Assert(pConnectionFailures != NULL);
        Assert(pLinkFailures != NULL);

        // This function only prints things if the /d flag is specified.
        ReplIntersiteDbgPrintISTGFailureParams(pDsInfo, iSite,
                                               iISTG,
                                               ulIntersiteFailoverTries,
                                               ulIntersiteFailoverTime,
                                               pConnectionFailures,
                                               pLinkFailures);


        // Get down bridgehead lists ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteCheckBridgeheads(pDsInfo, iSite,
                                              iISTG,
                                              ulIntersiteFailoverTries,
                                              ulIntersiteFailoverTime,
                                              pConnectionFailures,
                                              pLinkFailures,
                                              &piBridgeheads,
                                              &piKCCDownServers,
                                              &prgKCCFailingServers,
                                              &piUnreacheableServers);
        if(dwRet != ERROR_SUCCESS){
            // There was an error printing/creating the bridgehead and
            // bridgehead's failing lists.
            __leave;
        }
        Assert(piBridgeheads != NULL);
        Assert(piKCCDownServers != NULL);
        Assert(prgKCCFailingServers != NULL);
        Assert(piUnreacheableServers != NULL);


        // Do site analysis ...
        // --------------------------------------------------------------------
        dwRet = ReplIntersiteSiteAnalysis(pDsInfo, iSite,
                                          iISTG,
                                          ulIntersiteFailoverTries,
                                          ulIntersiteFailoverTime,
                                          pConnectionFailures,
                                          pLinkFailures,
                                          piBridgeheads,
                                          piKCCDownServers,
                                          prgKCCFailingServers,
                                          piUnreacheableServers);
        if(dwRet != ERROR_SUCCESS){
            // There was an error in doing the site analysis.  This is 
            // probably a fatal error, like out of mem.
            Assert(dwRet != -1);
            __leave;
        }


    } __finally {
        if(pConnectionFailures != NULL) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES, 
                              pConnectionFailures);
        }
        if(pLinkFailures != NULL) {
            DsReplicaFreeInfo(DS_REPL_INFO_KCC_DSA_LINK_FAILURES, 
                              pLinkFailures);
        }
        if(piBridgeheads) { LocalFree(piBridgeheads); }
        if(piKCCDownServers) { LocalFree(piKCCDownServers); }
        if(prgKCCFailingServers) { LocalFree(prgKCCFailingServers); }
        if(piUnreacheableServers) { LocalFree(piUnreacheableServers); }
    } // End clean up memory section.
    
    return(dwRet);
}

DWORD
ReplIntersiteDoThisSiteP(
    IN  PDC_DIAG_DSINFO                     pDsInfo,
    IN  ULONG                               iSite,
    OUT PBOOL                               pbDoSite
    )
/*++

Description:
   
    This takes the DsInfo struct (containing the target NC if there is one),
    and the Site to do.  This function sets pbDoSite to TRUE if the scoping of
    dcdiag (via, SITE, ENTERPRISE, and NC scope) if this is a site that 
    should be examined by the inbound intersite replication engine.  If there
    is an error it returns an win 32 error.
    
Parameters:

    pDsInfo - This contains the target NC if relevant.
    iSite - The target site to consider.
    pbDoSite - Whether this site should be done or not.
        
Return Value:

    Returns a win 32 error.  ERROR_SUCCESS if one should use pbDoSite
    
--*/
{
    PULONG                            piRelevantServers = NULL;
    PULONG                            piSites = NULL;
    PCONNECTION_PAIR                  pConnections = NULL;
    LDAP *                            hldHomeServer = NULL;
    ULONG                             iNC;
    DWORD                             dwErr = ERROR_SUCCESS;

    *pbDoSite = TRUE;

    __try{

        if(pDsInfo->cNumSites == 1){
            // Can't do intersite anything with only one site.
            *pbDoSite = FALSE;
            __leave;
        }

        if(!(gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE || 
           gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_SITE)){
            // Why analyze intersite repl. without at least site or enterprise scope.
            *pbDoSite = FALSE;
            __leave;
        }

        if(gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_SITE && iSite != pDsInfo->iHomeSite){
            // Doing only one site, and this one is not it.
            *pbDoSite = FALSE;
            __leave;
        }

        piRelevantServers = IHT_GetServerList(pDsInfo);
        piRelevantServers = IHT_TrimServerListBySite(pDsInfo,
                                                     iSite,
                                                     piRelevantServers);
        if(piRelevantServers == NULL){
            *pbDoSite = FALSE;
            dwErr = IHT_PrintListError(GetLastError());
            Assert(dwErr != ERROR_SUCCESS);
            __leave;
        }
        if(piRelevantServers[0] == NO_SERVER){
            // This means it is a site that has no servers in it.
            *pbDoSite = FALSE;
            __leave;
        }

        if(pDsInfo->pszNC != NULL){
            
            // There is a target NC
            iNC = DcDiagGetNCNum(pDsInfo, pDsInfo->pszNC, NULL);
            Assert(iNC != NO_NC && "I don't think this should ever fire -BrettSh");
            
            piRelevantServers = IHT_TrimServerListByNC(pDsInfo, 
                                                       iNC, TRUE, TRUE, 
                                                       piRelevantServers);
            if(piRelevantServers == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }
            if(piRelevantServers[0] == NO_SERVER){
                // This site contains no servers with the specified NC.
                *pbDoSite = FALSE;
                __leave;
            }

            // Check whether any sites that we are attached to have the target NC.
            if((dwErr = DcDiagGetLdapBinding( &(pDsInfo->pServers[pDsInfo->ulHomeServer]), 
                                              pDsInfo->gpCreds, 
                                              FALSE, 
                                              &hldHomeServer)) != ERROR_SUCCESS){
                PrintMsg(SEV_ALWAYS,
                         DCDIAG_INTERSITE_FAILURE_CONNECTING_TO_HOME_SERVER,
                         pDsInfo->pServers[pDsInfo->ulHomeServer].pszName,
                         Win32ErrToString(dwErr));
                *pbDoSite = FALSE;
                __leave;
            }

            pConnections = IHT_GetConnectionList(pDsInfo, hldHomeServer, iSite);
            if(pConnections == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }

            // Trims connections to only leave the ones that have this NC on both
            //   sides of the connection, and where the src is in another site.
            pConnections = IHT_TrimConnectionsForInterSiteAndTargetNC(pDsInfo, 
                                                                      iSite,
                                                                      pConnections);
            if(pConnections == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }

            // Get list of sites for the src's of the connection objects.
            piSites = IHT_GetSrcSitesListFromConnections(pDsInfo, pConnections);
            if(piSites == NULL){
                *pbDoSite = FALSE;
                dwErr = IHT_PrintListError(GetLastError());
                Assert(dwErr != ERROR_SUCCESS);
                __leave;
            }
            if(piSites[0] == NO_SITE){
                // There are no sites outside this one that have this NC
                // This is a rare case that there are no GCs outside this site.
                *pbDoSite = FALSE;
                __leave;
            }

        } else {
            // Every site should be valid in this case, because at least Config/Schema
            //   are replicated to every DC.

        }

    } __finally {
        if(piRelevantServers) { LocalFree(piRelevantServers); }
        if(piSites) { LocalFree(piSites); }
        if(pConnections) { IHT_FreeConnectionList(pConnections); }
    }
    
    // Looks like a good site to do.  "Houston, We are go fly for launch!"
    return(dwErr);
}

DWORD
ReplIntersiteHealthTestMain(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iTargetSite,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Description:

    This is the basic stub function ... it bails on certain preliminary
    conditions, like only one site, scope not set to /a or /e, etc ... 
    otherwise the function calls ReplIntersiteDoOneSite().

Parameters:

    pDsInfo ... the pDsInfo structure, basically the mini-enterprise variable.
    iCurrTargetServer ... the targeted serve ... which means nothing to this 
             test, because this is an enterprise test.
    gpCreds ... the users credentials

Return Value:

    returns a Win 32 error.

  --*/
{
    DWORD                              dwRet;
    DWORD                              dwWorst = ERROR_SUCCESS;
    ULONG                              iSite;
    BOOL                               bDoSite;

    for(iSite = 0; iSite < pDsInfo->cNumSites; iSite++){
        if((dwRet = ReplIntersiteDoThisSiteP(pDsInfo, iSite, &bDoSite)) 
           != ERROR_SUCCESS){
            // This means trouble talking to home server or out of memory, 
            //   either way a completely fatal condition.
            return(dwRet);
        }

        if(!bDoSite){ //!bDoSite){
            // This site doesn't quailify,
            PrintMsg(SEV_VERBOSE,
                     DCDIAG_INTERSITE_SKIP_SITE,
                     pDsInfo->pSites[iSite].pszName);
            continue;
        }

        // Do a site.
        PrintMsg(SEV_NORMAL, 
                 DCDIAG_INTERSITE_BEGIN_DO_ONE_SITE,
                 pDsInfo->pSites[iSite].pszName);
        PrintIndentAdj(1);
        dwRet = ReplIntersiteDoOneSite(pDsInfo, iSite);
        if(dwWorst == ERROR_SUCCESS){
            dwWorst = dwRet;
        }
        PrintIndentAdj(-1);
    }

    return(dwWorst);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\include\utils.h ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    include\utils.h

ABSTRACT:

    This is the file that contains most of the function headers for the dcdiag
    set of utilities.

DETAILS:

CREATED:

    02 Sept 1999 Brett Shirley (BrettSh)

--*/

// from common\main.c --------------------------------------------------------
// Code.Improvement: move these functions to common\dsinfo.c
ULONG
DcDiagGetNCNum(
    PDC_DIAG_DSINFO                     pDsInfo,
    LPWSTR                              pszNCDN,
    LPWSTR                              pszDomain
    );

// from common\ldaputil.c ----------------------------------------------------
DWORD
DcDiagGetStringDsAttributeEx(
    LDAP *                          hld,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

LPWSTR
DcDiagTrimStringDnBy(
    IN  LPWSTR                      pszInDn,
    IN  ULONG                       ulTrimBy
    );

DWORD
DcDiagGetStringDsAttribute(
    IN  PDC_DIAG_SERVERINFO         prgServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    IN  LPWSTR                      pszDn,
    IN  LPWSTR                      pszAttr,
    OUT LPWSTR *                    ppszResult
    );

// from common\bindings.c ----------------------------------------------------
DWORD
DcDiagGetLdapBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   BOOL                                bUseGcPort,
    OUT  LDAP * *                            phLdapBinding
    );

DWORD
DcDiagGetDsBinding(
    IN   PDC_DIAG_SERVERINFO                 pServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    OUT  HANDLE *                            phDsBinding
    );

DWORD
DcDiagGetNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W *     gpCreds
    );

VOID
DcDiagTearDownNetConnection(
    IN  PDC_DIAG_SERVERINFO             pServer
    );

// from common\list.c --------------------------------------------------------
/*
NOTES:

    This is a "pure" list function, in that it returns NULL, or a memory address.  If
    it returns NULL, then GetLastError() should have the error, even if another pure
    list function was called in the mean time.  If not it is almost certainly a memory
    error, as this is the only thing that can go wrong in pure list functions.  The pure
    list functions return a NO_SERVER terminated list.  The function always returns the
    pointer to the list.  Note most of the list functions modify one of the lists they
    are passed and passes back that pointer, so if you want the original contents, make
    a copy with IHT_CopyServerList().
*/

DWORD
IHT_PrintListError(
    DWORD                               dwErr
    );

VOID
IHT_PrintServerList(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );

PULONG
IHT_GetServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

PULONG
IHT_GetEmptyServerList(
    PDC_DIAG_DSINFO		        pDsInfo
    );

BOOL
IHT_ServerIsInServerList(
    PULONG                              piServers,
    ULONG                               iTarget
    );

PULONG
IHT_AddToServerList(
    PULONG                             piServers,
    ULONG                              iTarget
    );

PULONG
IHT_TrimServerListBySite(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iSite,
    PULONG                              piServers
    );

PULONG
IHT_TrimServerListByNC(
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               iNC,
    BOOL                                bDoMasters,
    BOOL                                bDoPartials,
    PULONG                              piServers
    );

PULONG
IHT_AndServerLists(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc1,
    IN      PULONG                      piSrc2
    );

PULONG
IHT_CopyServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_NotServerList(
    IN      PDC_DIAG_DSINFO		pDsInfo,
    IN OUT  PULONG                      piSrc
    );

PULONG
IHT_OrderServerListByGuid(
    PDC_DIAG_DSINFO		        pDsInfo,
    PULONG                              piServers
    );


// from common\registry.c ----------------------------------------------------

DWORD
GetRegistryDword(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pszRegLocation,
    LPWSTR                          pszRegParameter,
    PDWORD                          pdwResult
    );

// from common\events.c ------------------------------------------------------

DWORD
GetEventString(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    LPWSTR *                        ppszMsg
    );

BOOL
EventIsInList(
    DWORD                           dwTarget,
    PDWORD                          paEventsList
    );

VOID 
PrintTimeGenerated(
    PEVENTLOGRECORD              pEvent
    );

VOID
GenericPrintEvent(
    LPWSTR                          pszEventLog,
    PEVENTLOGRECORD                 pEvent,
    BOOL                            fVerbose
    );

DWORD
PrintSelectEvents(
    PDC_DIAG_SERVERINFO             pServer,
    SEC_WINNT_AUTH_IDENTITY_W *     pCreds,
    LPWSTR                          pwszEventLog,
    DWORD                           dwPrintAllEventsOfType,
    PDWORD                          paSelectEvents,
    PDWORD                          paBeginningEvents,
    DWORD                           dwBeginTime,
    VOID (__stdcall *               pfnPrintEventHandler) (PVOID, PEVENTLOGRECORD),
    VOID (__stdcall *               pfnBeginEventHandler) (PVOID, PEVENTLOGRECORD),
    PVOID                           pvContext
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\objects.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    objects.c

Abstract:

This module contains the test and the support routines to check that
critical objects are fully replicated to all holders of the domain.
There are two aspects to this: enumerating what the critical objects are,
and finding all the replicas of that object and verifying that they are
at the latest version.    

Author:

    Will Lees (wlees) 31-Aug-1999

Environment:

    optional-environment-info (e.g. kernel mode only...)

Notes:

    optional-notes

Revision History:

    most-recent-revision-date email-name
        description
        .
        .
    least-recent-revision-date email-name
        description

--*/

#include <ntdspch.h>
#include <ntdsa.h>    // options
#include <mdglobal.h>
#include <dsutil.h>
#include <drs.h>  // need DS_REPL_INFO_REPSTO

#include "dcdiag.h"
#include "repl.h"
#include "ldaputil.h"

// Data structure to represent one candidate server holding an object in a domain

typedef struct _SERVER_OBJECT {
    PDC_DIAG_SERVERINFO pServer;
    HANDLE *hDS;
    BOOL fMaster;
    DS_REPL_OBJ_META_DATA * pObjMetaData;
} SERVER_OBJECT, *PSERVER_OBJECT;

// Data structure to represent one attribute on one object on one
// candidate server

typedef struct _SERVER_ATTRIBUTE {
    PSERVER_OBJECT pServerObject;
    DS_REPL_ATTR_META_DATA *pAttrMetaData;
} SERVER_ATTRIBUTE, *PSERVER_ATTRIBUTE;

/* External */

/* Static */

/* Forward */
/* End Forward */


void
PrintAttrMetaData(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN LPWSTR pszDescription,
    IN LPWSTR pszServerName,
    IN BOOL fMaster,
    IN DS_REPL_ATTR_META_DATA *pAttrMetaData
    )

/*++

Routine Description:

Print the contents of server attribute record.  This is user-visable
attribute print routine

Arguments:

    pDsInfo - 
    pszDescription - Call's string description of this attribute
    pszServerName - Server where this attribute came from
    pAttrMetaData - Metadata to be printed

Return Value:

    None

--*/

{
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DSTIME dstime;
    DWORD i;
    LPWSTR pszLastOriginatingDsa, pszUuid = NULL;

    PrintMessage( SEV_ALWAYS, L"%ws attribute %ws on %ws (%ws)\n",
                  pszDescription,
                  pAttrMetaData->pszAttributeName,
                  pszServerName,
                  fMaster ? L"writeable" : L"readonly" );

    FileTimeToDSTime(pAttrMetaData->ftimeLastOriginatingChange,
                     &dstime);
    DSTimeToDisplayString(dstime, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         wszTime, SZDSTIME_LEN);

    UuidToString( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                  &pszUuid);

    // Reverse translate invocation id to server name
    pszLastOriginatingDsa = pszUuid;
    for( i=0; i < pDsInfo->ulNumServers; i++ ) {
        if (memcmp( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                    &(pDsInfo->pServers[i].uuidInvocationId),
                    sizeof( UUID ) ) == 0 ) {
            pszLastOriginatingDsa = pDsInfo->pServers[i].pszName;
            break;
        }
    }

    PrintIndentAdj(1);
    PrintMessage( SEV_ALWAYS, L"usnLocalChange = %I64d\n",
                  pAttrMetaData->usnLocalChange );
    PrintMessage( SEV_ALWAYS, L"LastOriginatingDsa = %ws\n",
                  pszLastOriginatingDsa );
    PrintMessage( SEV_ALWAYS, L"usnOriginatingChange = %I64d\n",
                  pAttrMetaData->usnOriginatingChange );
    PrintMessage( SEV_ALWAYS, L"timeLastOriginatingChange = %ws\n",
                  wszTime );
    PrintMessage( SEV_ALWAYS, L"VersionLastOriginatingChange = %d\n",
                  pAttrMetaData->dwVersion );
    PrintIndentAdj(-1);

// cleanup

    if (pszUuid) {
        RpcStringFree( &pszUuid );
    }
} /* PrintAttrMetaData */


void
printServerAttributeSingleLine(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttr,
    IN BOOL fPrintHeader
    )

/*++

Routine Description:

Helper routine that dumps a single line of the attribute
instance array.

Note, uses fwprintf

Arguments:

    pDsInfo - 
    pServerAttr - 
    fPrintHeader - 

Return Value:

    None

--*/

{
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DSTIME dstime;
    DWORD i;
    LPWSTR pszLastOriginatingDsa, pszUuid = NULL;
    DS_REPL_ATTR_META_DATA *pAttrMetaData =
        pServerAttr->pAttrMetaData;
    
    if (fPrintHeader) {
        fwprintf( gMainInfo.streamOut,
                  L"\nDumping %d Server Attributes.\n", cServerAttributes );

        fwprintf( gMainInfo.streamOut,
                  L"\n%15s%3s%10s%37s%10s%20s%5s %s\n",
                  L"Local DSA",
                  L"W",
                  L"Loc.USN",
                  L"Originating DSA",
                  L"Org.USN",
                  L"Org.Time/Date",
                  L"Ver",
                  L"Attribute"
            );

        fwprintf( gMainInfo.streamOut,
            L"%15s%3s%10s%37s%10s%20s%5s %s\n",
                  L"===",
                  L"=========",
                  L"=======",
                  L"===============",
                  L"=======",
                  L"=============",
                  L"===",
                  L"========="
            );
    }

    FileTimeToDSTime(pAttrMetaData->ftimeLastOriginatingChange,
                     &dstime);
    DSTimeToDisplayString(dstime, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                         wszTime, SZDSTIME_LEN);

    UuidToString( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                  &pszUuid);

    // Reverse translate invocation id to server name
    pszLastOriginatingDsa = pszUuid;
    for( i=0; i < pDsInfo->ulNumServers; i++ ) {
        if (memcmp( &(pAttrMetaData->uuidLastOriginatingDsaInvocationID),
                    &(pDsInfo->pServers[i].uuidInvocationId),
                    sizeof( UUID ) ) == 0 ) {
            pszLastOriginatingDsa = pDsInfo->pServers[i].pszName;
            break;
        }
    }

    fwprintf( gMainInfo.streamOut,
              L"%15ls%3d%10I64d%37ls%10I64d%20s%5d %ls\n",
              pServerAttr->pServerObject->pServer->pszName,
              pServerAttr->pServerObject->fMaster,
              pAttrMetaData->usnLocalChange,
              pszLastOriginatingDsa,
              pAttrMetaData->usnOriginatingChange,
              wszTime,
              pAttrMetaData->dwVersion,
              pAttrMetaData->pszAttributeName
        );

// cleanup

    if (pszUuid) {
        RpcStringFree( &pszUuid );
    }
} /* printServerAttributeSingleLine */


void
printServerAttributes(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttributes
    )

/*++

Routine Description:

Dump routine that prints the array of attribute instances

Arguments:

    pDsInfo - 
    cServerAttributes - 
    pServerAttributes - 

Return Value:

    None

--*/

{
    DWORD i;

    for( i = 0; i < cServerAttributes; i++ ) {
        PSERVER_ATTRIBUTE pServerAttr = &(pServerAttributes[i]);
        printServerAttributeSingleLine(
            pDsInfo,
            cServerAttributes,
            pServerAttr,
            (i == 0) // First line or not?
            );
    };
} /* printServerAttributes */


int __cdecl
compareServerAttrVersion(
    const void *pArg1,
    const void *pArg2
    )

/*++

Routine Description:

Helper comparison function.

1. sort by version, DESCENDING
2. sort by change time, DESCENDING

Arguments:

    pArg1 - 
    pArg2 - 

Return Value:

    int __cdecl - 

--*/

{
    PSERVER_ATTRIBUTE pServerAttribute1 = (PSERVER_ATTRIBUTE) pArg1;
    PSERVER_ATTRIBUTE pServerAttribute2 = (PSERVER_ATTRIBUTE) pArg2;
    int result;
    LONGLONG llTime1, llTime2;

    // Attribute names are equal, sort by version, DESCENDING

    if (pServerAttribute1->pAttrMetaData->dwVersion >
        pServerAttribute2->pAttrMetaData->dwVersion ) {
        return -1;
    } else if (pServerAttribute1->pAttrMetaData->dwVersion <
        pServerAttribute2->pAttrMetaData->dwVersion ) {
        return 1;
    }

    // Version numbers are equal, sort by change time, DESCENDING

    llTime1 = *((UNALIGNED64 LONGLONG *) &(pServerAttribute1->pAttrMetaData->ftimeLastOriginatingChange));
    llTime2 = *((UNALIGNED64 LONGLONG *) &(pServerAttribute2->pAttrMetaData->ftimeLastOriginatingChange));
    if (llTime1 > llTime2) {
        return -1;
    } else if (llTime1 < llTime2) {
        return 1;
    }

    // The two records are equal as far as we are concerned

    return 0;
} /* sortByVersion */


int __cdecl
compareServerAttrNameWriteVersion(
    const void *pArg1,
    const void *pArg2
    )

/*++

Routine Description:

qsort comparison function
1. Sort by attribute name, ASCENDING
2. Sort by writeability, DESCENDING
3. Attribute names are equal, sort by version, DESCENDING
4. Version numbers are equal, sort by change time, DESCENDING

Arguments:

    pArg1 - 
    pArg2 - 

Return Value:

    int __cdecl - 

--*/

{
    PSERVER_ATTRIBUTE pServerAttribute1 = (PSERVER_ATTRIBUTE) pArg1;
    PSERVER_ATTRIBUTE pServerAttribute2 = (PSERVER_ATTRIBUTE) pArg2;
    int result;
    LONGLONG llTime1, llTime2;

    // Sort by attribute name, ASCENDING

    result = _wcsicmp( pServerAttribute1->pAttrMetaData->pszAttributeName,
                       pServerAttribute2->pAttrMetaData->pszAttributeName );
    if (result != 0) {
        return result;
    }

    // Sort by writability, DESCENDING
    if (pServerAttribute1->pServerObject->fMaster >
        pServerAttribute2->pServerObject->fMaster ) {
        return -1;
    } else if (pServerAttribute1->pServerObject->fMaster <
               pServerAttribute2->pServerObject->fMaster ) {
        return 1;
    }

    return
        compareServerAttrVersion( pServerAttribute1, pServerAttribute2 );
} /* sortByNameVersion */


BOOL
walkSortedServerAttributes(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerAttributes,
    IN PSERVER_ATTRIBUTE pServerAttributes
    )

/*++

Routine Description:

All the attributes from all the replicas have been correllated in one array.
Walk through the attributes and report any that are not current.

We know that the array is sorted first by attribute name, then by most recent change.
So the first occurance of an attribute name in the list must be the most
recent, so call that the "authoritative" instance of the attribute.  Any that
deviate from this are called "out of date".

CODE.IMPROVEMENT: detect if an attribute is missing on some of the servers. Note
that GC's only hold a subset of the attributes.

Arguments:

    cServerAttributes - 
    pServerAttributes - 

Return Value:

    BOOL - Difference found

--*/

{
    DWORD status = ERROR_SUCCESS, i;
    PSERVER_ATTRIBUTE pAuthAttr;
    BOOL fAuthAttrPrinted = FALSE;
    BOOL fDifferenceFound = FALSE;

    // Start out with the 0th element being authoritative, and go through
    // the rest of the array starting at element 1.  If the name changes,
    // declare a new authoritative element.

    pAuthAttr = &(pServerAttributes[0]);
    for( i = 1; i < cServerAttributes; i++ ) {
        PSERVER_ATTRIBUTE pServerAttr = &(pServerAttributes[i]);

        // See if it is time to start a new attribute name
        if (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                      pServerAttr->pAttrMetaData->pszAttributeName ) != 0) {
            pAuthAttr = &(pServerAttributes[i]);
            fAuthAttrPrinted = FALSE;
            continue;
        }

        // See if current attribute change is the same as the authoritative
        if (compareServerAttrVersion( pAuthAttr, pServerAttr ) == 0) {
            continue;
        }

        // WORKAROUND problem that whenCreated was added to partial attribute set
        // If readonly copy of whenCreated is more recent, skip
        if ( (pAuthAttr->pServerObject->fMaster) &&
             (!(pServerAttr->pServerObject->fMaster)) &&
             (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                        L"whenCreated" ) == 0) &&
             (compareServerAttrVersion( pAuthAttr, pServerAttr ) > 0) ) {
            continue;
        }
        // operatingSystemServicePack was another one that changed from being set
        // to not being set around 2/99
        if (_wcsicmp( pAuthAttr->pAttrMetaData->pszAttributeName,
                      L"operatingSystemServicePack" ) == 0) {
            continue;
        }
        // WORKAROUND

        // Current attribute is out of date

        // Print the authoritative attribute out once
        if (!fAuthAttrPrinted) {
            PrintAttrMetaData( pDsInfo,
                               L"Authoritative",
                               pAuthAttr->pServerObject->pServer->pszName,
                               pAuthAttr->pServerObject->fMaster,
                               pAuthAttr->pAttrMetaData);
            fAuthAttrPrinted = TRUE;
        }

        // Print the out of date attribute
        PrintAttrMetaData( pDsInfo,
                           L"Out-of-date",
                           pServerAttr->pServerObject->pServer->pszName,
                           pServerAttr->pServerObject->fMaster,
                           pServerAttr->pAttrMetaData);
        fDifferenceFound = TRUE;
    }

    return fDifferenceFound;
} /* walkSortedServerAttributes */


BOOL
mergeAttributesOnServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN DWORD cServerObjects,
    IN PSERVER_OBJECT pServerObjects
    )

/*++

Routine Description:

At this point, we have an array of records, one for each server.  In the record
is a pointer to metadata for the object.

What we want to do is check that across all servers, all hold the same metadata
for the same attribute.

What we do here is allocate another array, an array of attribute instances.
Each occurance of an attribute metadata on a particular server gets its own
record.  These records are then sorted, first by attribute, then by most
recent change.  Then we can easily go through them.

Arguments:

    pDsInfo - Global information
    cServerObjects - Number of replicas
    pServerObjects - Array of server object context records

Return Value:

    BOOL - 

--*/

{
    DWORD status = ERROR_SUCCESS, cServerAttributes = 0;
    DWORD i, j, dwCurrentAttribute;
    PSERVER_ATTRIBUTE pServerAttributes = NULL;
    BOOL fDifferenceFound = FALSE;

    // Make two passes: count the attribute instances, then allocate and init

    // Count the number of server attributes we have

    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);
        // If no metadata, do not include this server
        if (pServerObject->pObjMetaData == NULL) {
            continue;
        }
        for( j = 0; j < pServerObject->pObjMetaData->cNumEntries; j++ ) {
            // Skip non-replicated attributes
            if (_wcsicmp( pServerObject->pObjMetaData->rgMetaData[j].pszAttributeName,
                          L"cn" ) == 0) {
                continue;
            }
            cServerAttributes++;
        }
    }

    // Allocate array
    // Zero all fields to start out
    pServerAttributes = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                    cServerAttributes *
                                    sizeof( SERVER_ATTRIBUTE ) );
    if (pServerAttributes == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        return TRUE;  // Indicate an error occurred
    }

    // Initialize array

    dwCurrentAttribute = 0;
    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);

        // If no metadata, do not include this server
        if (pServerObject->pObjMetaData == NULL) {
            continue;
        }
        for( j = 0; j < pServerObject->pObjMetaData->cNumEntries; j++ ) {
            // Skip non-replicated attributes
            if (_wcsicmp( pServerObject->pObjMetaData->rgMetaData[j].pszAttributeName,
                          L"cn" ) == 0) {
                continue;
            }
            pServerAttributes[dwCurrentAttribute].pServerObject = pServerObject;
            pServerAttributes[dwCurrentAttribute].pAttrMetaData =
                &(pServerObject->pObjMetaData->rgMetaData[j]);
            dwCurrentAttribute++;
        }
    }

    // Sort the array

    qsort( pServerAttributes,
           cServerAttributes,
           sizeof( SERVER_ATTRIBUTE ),
           compareServerAttrNameWriteVersion );

#ifdef EXTENDED_DEBUGGING
    // Dump server attributes table if desired
    IF_DEBUG(printServerAttributes(pDsInfo, cServerAttributes, pServerAttributes););
#endif

    // Walk through the sorted attributes

    fDifferenceFound =
        walkSortedServerAttributes( pDsInfo,
                                    cServerAttributes,
                                    pServerAttributes );
    if (!fDifferenceFound) {
        PrintMessage( SEV_VERBOSE, L"Object is up-to-date on all servers.\n" );
    }

// cleanup
    if (pServerAttributes) {
        LocalFree( pServerAttributes );
    }
    return fDifferenceFound;
} /* mergeAttributesOnServers */


DWORD
checkObjectOnServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN LPWSTR pszDomainDn,
    IN LPWSTR pszObjectDn,
    IN DWORD cServerObjects,
    IN PSERVER_OBJECT pServerObjects
    )

/*++

Routine Description:

Check whether the given object in the domain is at the latest version on
all of its replicas.

Arguments:

    pszDomainDn - DN of domain to be searched
    pszObjectDn - DN of object in domain to be checked
    cServerObjects - Number of replicas to be searched
    pServerObjects - Array of server object context records

Return Value:

    DWORD - Error if object not fully replicated

--*/

{
    BOOL fDifferenceFound = FALSE;
    DWORD status, i;

    PrintMessage( SEV_VERBOSE, L"Checking for %ws in domain %ws on %d servers\n",
                  pszObjectDn, pszDomainDn, cServerObjects );

    // Fill the server object array with metadata 
    // One metadata query for each server

    for( i = 0; i < cServerObjects; i++ ) {
        PSERVER_OBJECT pServerObject = &(pServerObjects[i]);

        status = DsReplicaGetInfoW( pServerObject->hDS,
                                    DS_REPL_INFO_METADATA_FOR_OBJ,
                                    pszObjectDn,
                                    NULL,
                                    &(pServerObject->pObjMetaData));
        if (ERROR_SUCCESS != status) {
            PrintMessage( SEV_ALWAYS,
                          L"Failed to read object metadata on %ws, error %ws\n",
                          pServerObject->pServer->pszName,
                          Win32ErrToString(status) );
            // keep going, leave pObjMetaData as null
        }
    }

    // Compare all the attributes for differences

    PrintIndentAdj(1);

    fDifferenceFound =
        mergeAttributesOnServers( pDsInfo,
                                  cServerObjects,
                                  pServerObjects );

    PrintIndentAdj(-1);

// cleanup

    for( i = 0; i < cServerObjects; i++ ) {
        if (pServerObjects[i].pObjMetaData) {
            DsReplicaFreeInfo( DS_REPL_INFO_METADATA_FOR_OBJ,
                               pServerObjects[i].pObjMetaData );
            pServerObjects[i].pObjMetaData = NULL;
        }
    }

    return fDifferenceFound ? ERROR_DS_GENERIC_ERROR : ERROR_SUCCESS;
} /* checkObjectOnServers */


DWORD
checkObjectsOnDomain(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN SEC_WINNT_AUTH_IDENTITY_W * pCreds,
    LPWSTR pszDomainDn,
    LPWSTR pszObjectDn
    )

/*++

Routine Description:

This routine generates a data structure that is an array of server-object records.
There is one such record for each server that holds a copy of the domain
we are interested in.  We enumerate the replicas by going through the known
server list looking for writable or readable copies.

This test requires N x N queries.  There are as many computer accounts as there are
DC's.  Each computer account is replicated to all the holders of that domain.
I had a choice of defining what the target server means for this test.  Is it the
account to be checked for, or each server on which the check occurs.  I have chosen to
use the test target server for the account to be checked for.  The systems that will be
checked are hard coded to all the domain holders.

Arguments:

    pDsInfo - 
    pTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD i, status, cServerObjects = 0;
    BOOL fHoldsDomainWriteable = FALSE, fHoldsDomainReadOnly = FALSE;
    PSERVER_OBJECT pServerObjects = NULL;

    // Allocate a maximal size array
    // Note that fields are all zero'd to start with
    pServerObjects = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                 pDsInfo->ulNumServers * sizeof( SERVER_OBJECT ) );
    if (pServerObjects == NULL) {
        PrintMessage( SEV_ALWAYS, L"Memory allocation failure\n" );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Walk the known server list, and find replicas

    for( i = 0; i < pDsInfo->ulNumTargets; i++ ) {
        PDC_DIAG_SERVERINFO pCandidateServer =
            &(pDsInfo->pServers[pDsInfo->pulTargets[i]]);
        HANDLE hDS = NULL;

        // Check for writable copy
        fHoldsDomainWriteable =
            DcDiagHasNC( pszDomainDn, pCandidateServer, TRUE, FALSE );
        if (!fHoldsDomainWriteable) {
            // Check for readonly copy
            fHoldsDomainReadOnly =
                DcDiagHasNC( pszDomainDn, pCandidateServer, FALSE, TRUE );
            if (!fHoldsDomainReadOnly) {
                continue;
            }
        }

        // If we already know candidate is down, don't bother
        if ( (!pCandidateServer->bDnsIpResponding) ||
             (!pCandidateServer->bLdapResponding) ||
             (!pCandidateServer->bDsResponding) ) {
            continue;
        }
        // If candidate not reachable via ldap, don't bother
        status = DcDiagGetDsBinding(pCandidateServer,
                                    pCreds,
                                    &hDS);
    	if (ERROR_SUCCESS != status) {
            continue;
    	}

        pServerObjects[cServerObjects].pServer = pCandidateServer;
        pServerObjects[cServerObjects].hDS = hDS;
        pServerObjects[cServerObjects].fMaster = fHoldsDomainWriteable;
        cServerObjects++;
    }

    // Check given object

    status = checkObjectOnServers( pDsInfo,
                                   pszDomainDn,
                                   pszObjectDn,
                                   cServerObjects,
                                   pServerObjects );

// Cleanup

    if (pServerObjects) {
        LocalFree( pServerObjects );
    }

    return status;
} /* checkObjectsOnDomain */


DWORD
ReplCheckObjectsMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This test verifies that the most recent copies of important
objects and attributes have replicated through the domain.

The objects that are checked are:
1. The machine account object of the target server. The search scope is all
the copies of the machine's primary domain.
2. The NTDS-DSA object of the target server. The search scope is all the
replicas of the CN=Configuration naming context.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status = ERROR_SUCCESS, worst = ERROR_SUCCESS;
    DWORD i, j;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);
    LPWSTR pszDomainDn = NULL;
    LPWSTR pszObjectDn = NULL;

    // See if user-specified object present
    for( i = 0; pDsInfo->ppszCommandLine[i] != NULL; i++ ) {
        if (_wcsnicmp( pDsInfo->ppszCommandLine[i],
                       L"/objectdn:", wcslen( L"/objectdn:" ) ) == 0 )
        {
            pszObjectDn = &pDsInfo->ppszCommandLine[i][wcslen(L"/objectdn:")];
            break;
        }
    }

    // Find the primary domain of the target server
    for( j = 0; pTargetServer->ppszMasterNCs[j] != NULL; j++ ) {
        if (_wcsnicmp( pTargetServer->ppszMasterNCs[j], L"DC=", 3 ) == 0) {
            pszDomainDn = pTargetServer->ppszMasterNCs[j];
            break;
        }
    }
    Assert( pszDomainDn );

    PrintMessage( SEV_VERBOSE, L"%ws is in domain %ws\n",
                  pTargetServer->pszName,
                  pszDomainDn );

    //
    // Check replication for the machine account of the target server,
    // which is in the domain of the target server
    //

    status = checkObjectsOnDomain( pDsInfo,
                                   pCreds,
                                   pszDomainDn,
                                   pTargetServer->pszComputerAccountDn );
    if (status != ERROR_SUCCESS) {
        worst = status;
    }

    //
    // Check replication of the server object, which is in
    // the configuration naming context
    //

    status = checkObjectsOnDomain( pDsInfo,
                                   pCreds,
                                   pDsInfo->pszConfigNc,
                                   pTargetServer->pszDn );
    if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
        worst = status;
    }

    //
    // Check user supplied object
    //

    if ( (pszObjectDn) && (pDsInfo->pszNC) ) {
        status = checkObjectsOnDomain( pDsInfo,
                                       pCreds,
                                       pDsInfo->pszNC,
                                       pszObjectDn );
        if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
            worst = status;
        }
    }

    return worst;
} /* CheckObjectsMain */

/* end objects.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\roles.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    roles.c

ABSTRACT:

    Advertisement and role holding test

DETAILS:

CREATED:

    21 Jul 1999  William Lees

--*/

#include <ntdspch.h>

#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h> // NetApiBufferFree
#include <ntdsa.h>    // options

#include "dcdiag.h"
#include "ldaputil.h"

// Other Forward Function Decls
PDSNAME
DcDiagAllocDSName (
    LPWSTR            pszStringDn
    );
BOOL
RH_CARVerifyGC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    );

static LPWSTR wzRoleNames[] = {
    L"Schema Owner",
    L"Domain Owner",
    L"PDC Owner",
    L"Rid Owner",
    L"Infrastructure Update Owner",
};

static LPWSTR wzNameErrors[] = {
    L"No Error",
    L"Can't Resolve",
    L"Not Found",
    L"Not Unique",
    L"No Mapping",
    L"Domain Only",
    L"No Syntactical Mapping",
};


DWORD
CheckFsmoRoles(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This is a helper function for the CheckRoles test.

This test checks whether Fsmo roles can be returned, and that the
returned role holders are responding.

Fsmo roles are stored as dn-valued attributes in the DS.  Each role is stored
on a different attribute on a different object.  By writing the name of a 
server on a Fsmo attribute, we are causing the election of that server to that
role.  Replication will resolve any conflicts so that eventually all dc's will
agree who holds that role.  Note that Fsmo's must be manually moved, and that
the do not float automatically like the site generator role (which is not,
strictly speaking, a Fsmo).

The DsListRoles api will return the Fsmo holders for us.

We are assuming that all Fsmo's returned are global to the enterprise, and are
not domain specific.

Note that this test assumes that the home server's view of the Fsmo role 
holders is sufficient.  This test does not verify that all dc's share the same
view of the Fsmo's. Replication should assure that all dc's see the same 
Fsmo's, unless part of the problem being debugged is that replication is 
partitioned.  Since Fsmo's should not change verify frequently, differing 
views of the Fsmo's is not our top priority.

Arguments:

    pDsInfo - The mini enterprise structure.
    ulCurrTargetServer - the number in the pDsInfo->pServers array.
    pCreds - the crdentials.

Return Value:

    DWORD - win 32 error.

--*/

{
    DWORD status, dwRoleIndex, dwServerIndex;
    BOOL fWarning = FALSE;
    PDS_NAME_RESULTW pRoles = NULL;
    PDC_DIAG_SERVERINFO psiTarget = &(pDsInfo->pServers[ulCurrTargetServer]);
    PDC_DIAG_SERVERINFO psiRoleHolder;
    HANDLE hDs;
    LDAP *hLdap;

    // Don't check servers that are not responding
    if ( (!psiTarget->bLdapResponding) || (!psiTarget->bDsResponding) ) {
        return ERROR_SUCCESS;
    }

    // Bind to target server
    status = DcDiagGetDsBinding( psiTarget, pCreds, &hDs );
    if (status != ERROR_SUCCESS) {
        goto cleanup;
    }

    // Get the roles as known to the home server...

    status = DsListRoles( hDs, &pRoles );
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"Fatal Error: DsListRoles (%ws) call failed, error %d\n", psiTarget->pszName, status );
        PrintMessage( SEV_ALWAYS, L"Could not reach DS at home server.\n" );
        goto cleanup;
    }

    Assert( pRoles->cItems > DS_ROLE_INFRASTRUCTURE_OWNER );

    //
    // Iterate through the role holders.  Verify that the role holder could
    // be determined, and that the server is valid and responding.
    //

    for( dwRoleIndex = 0; dwRoleIndex < pRoles->cItems; dwRoleIndex++ ) {
        PDS_NAME_RESULT_ITEM pnsiRole = pRoles->rItems + dwRoleIndex;

        if (!pnsiRole->status) {
            PrintMessage( SEV_VERBOSE, L"Role %ws = %ws\n",
                      wzRoleNames[dwRoleIndex], pnsiRole->pName );
        }

        // Was the name resolved?
        if ( (pnsiRole->status != DS_NAME_NO_ERROR) ||
             (!pnsiRole->pName) ) {
            PrintMessage(SEV_ALWAYS,
                        L"Warning: %ws could not resolve the name for role\n",
                         psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"%ws.\n", wzRoleNames[dwRoleIndex] );
            PrintMessage( SEV_ALWAYS, L"The name error was %ws.\n",
                          wzNameErrors[pnsiRole->status] );
            fWarning = TRUE;
            continue;
        }

        // Is the server deleted?
        if (IsDeletedRDNW( pnsiRole->pName )) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is deleted.\n", pnsiRole->pName, wzRoleNames[dwRoleIndex] );
            fWarning = TRUE;
            continue;
        }

        // The name returned by ListRoles is a dn of the NTDS-DSA object
        // Convert Role holder Dn to server info

        dwServerIndex = DcDiagGetServerNum( pDsInfo, NULL, NULL, 
                                            pnsiRole->pName, NULL,NULL );
        if (dwServerIndex == NO_SERVER) {
            // Lookup failed
            PrintMessage(SEV_ALWAYS,
                         L"Warning: %ws returned role-holder name\n",
                         psiTarget->pszName );
            PrintMessage(SEV_ALWAYS,
                         L"%ws that is unknown to this Enterprise.\n",
                         pnsiRole->pName );
            fWarning = TRUE;
            continue;
        }
        psiRoleHolder = &(pDsInfo->pServers[dwServerIndex]);   

        status = DcDiagGetDsBinding( psiRoleHolder, pCreds, &hDs );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is not responding to DS RPC Bind.\n", psiRoleHolder->pszName, wzRoleNames[dwRoleIndex] );
            fWarning = TRUE;
        }

        status = DcDiagGetLdapBinding( psiRoleHolder, pCreds, FALSE, &hLdap );
        if (status != ERROR_SUCCESS) {
            PrintMessage(SEV_ALWAYS, L"Warning: %ws is the %ws, but is not responding to LDAP Bind.\n", psiRoleHolder->pszName, wzRoleNames[dwRoleIndex] );
            fWarning = TRUE;
        }

    } // for role index ...

    status = ERROR_SUCCESS;
cleanup:

    if (pRoles != NULL) {
        DsFreeNameResult( pRoles );
    }

    // If warning flag set, and no more serious error, return indicator...
    if ( (status == ERROR_SUCCESS) && (fWarning) ) {
        status = ERROR_NOT_FOUND;
    }

    return status;
} /* CheckFsmoRoles */


DWORD 
ReplLocatorGetDcMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This test performs locator related checks.  This test determines if a server
is advertising when it should.

This is a per-server test.

DsGetDcName is the API to the "locator". The locator is the service location
mechanism for Domain Controllers.  It may use Netbios, DNS or the DS itself to
locate other domain controllers.  The locator can find DC's by capability, such
as a Global Catalog or a Primary Domain Controller.

When DsGetDcName is directed at a particular server, it will return whether that
server is up, and what capabilities that server has.  We want to verify that the
server is reporting all the capabilities, or roles, that it should.

In this test, we should only be called if the server is responding.  There is a
possibility that DsGetDcName might refer us to another DC if the server we
requested is not suitable.  We check for this case.

Arguments:

    pDsInfo - Information structure
    ulCurrTargetServer - Index of target server
    pCreds - 

Return Value:

    DWORD  - 

--*/

{
    DWORD status, cItems;
    BOOL fWarning = FALSE;
    PDC_DIAG_SERVERINFO psiTarget = &(pDsInfo->pServers[ulCurrTargetServer]);
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    DWORD dwTempErr = ERROR_SUCCESS;

    if (!psiTarget->bIsSynchronized) {
        PrintMessage( SEV_ALWAYS, L"Warning: the directory service on %ws has not completed initial synchronization.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Other services will be delayed.\n" );
        PrintMessage( SEV_ALWAYS, L"Verify that the server can replicate.\n" );
        fWarning = TRUE;
    }

    // Get active domain controller information
    status = DsGetDcName(
        psiTarget->pszName,
        NULL, // domain name
        NULL, // domain guid,
        NULL, // site name,
        DS_DIRECTORY_SERVICE_REQUIRED |
        DS_IP_REQUIRED |
        DS_IS_DNS_NAME |
        DS_RETURN_DNS_NAME,
        &pDcInfo );
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"Fatal Error:DsGetDcName (%ws) call failed, error %d\n",
                     psiTarget->pszName, status ); 
        PrintMessage(SEV_ALWAYS, L"The Locator could not find the server.\n" );
        goto cleanup;
    }

    // Verify that DsGetDcName returned info for the server we asked for
    if (_wcsnicmp( pDcInfo->DomainControllerName + 2,
                  psiTarget->pszName,
                  wcslen( psiTarget->pszName ) ) != 0 ) {
        PrintMessage( SEV_ALWAYS, L"Warning: DsGetDcName returned information for %ws, when we were trying to reach %ws.\n", pDcInfo->DomainControllerName, psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Server is not responding or is not considered suitable.\n" );
        fWarning = TRUE;
    }

    // DS Role Flag
    if ( !(pDcInfo->Flags & DS_DS_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a directory server Domain Controller.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Check that the database on this machine has sufficient free space.\n" );
        fWarning = TRUE;
    } else {
        // Code.Improvement would be to condense all these lines into 
        PrintMessage( SEV_VERBOSE, L"The DC %s is advertising itself as a DC and having a DS.\n", psiTarget->pszName );
    }

    // LDAP Role Flag
    if ( !(pDcInfo->Flags & DS_LDAP_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a LDAP server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as an LDAP server\n", psiTarget->pszName );
    }

    // DS WRITABLE Role Flag
    if ( !(pDcInfo->Flags & DS_WRITABLE_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a writable directory server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as having a writeable directory\n", psiTarget->pszName );
    }

    // KDC Role Flag
    if ( !(pDcInfo->Flags & DS_KDC_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a Key Distribution Center.\n", psiTarget->pszName );
        PrintMessage( SEV_ALWAYS, L"Check that the Directory has started.\n" );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as a Key Distribution Center\n", psiTarget->pszName );
    }

    // TIMESERV Role Flag
    if ( !(pDcInfo->Flags & DS_TIMESERV_FLAG) ) {
        PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a time server.\n", psiTarget->pszName );
        fWarning = TRUE;
    } else {
        PrintMessage(SEV_VERBOSE, L"The DC %s is advertising as a time server\n", psiTarget->pszName );
    }

    // GC Role Flag, if it is supposed to be a GC
    if (psiTarget->iOptions & NTDSDSA_OPT_IS_GC) {
        if (!psiTarget->bIsGlobalCatalogReady) {
            PrintMessage( SEV_ALWAYS, L"Warning: %ws has not finished promoting to be a GC.\n", psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"Check the event log for domains that cannot be replicated.\n" );
        }
        if (pDcInfo->Flags & DS_GC_FLAG) {
            if(!RH_CARVerifyGC(pDsInfo, pDcInfo, &dwTempErr)){
                PrintMessage(SEV_ALWAYS, L"Server %s is advertising as a global catalog, but\n",
                             psiTarget->pszName);
                PrintMessage(SEV_ALWAYS, L"it could not be verified that the server thought it was a GC.\n");
                fWarning = TRUE;
            } else {
                PrintMessage(SEV_VERBOSE, L"The DS %s is advertising as a GC.\n", psiTarget->pszName );
            }
        } else {
            PrintMessage( SEV_ALWAYS, L"Warning: %ws is not advertising as a global catalog.\n", psiTarget->pszName );
            PrintMessage( SEV_ALWAYS, L"Check that server finished GC promotion.\n" );
            PrintMessage( SEV_ALWAYS, L"Check the event log on server that enough source replicas for the GC are available.\n" );
            fWarning = TRUE;
        } 
    }

    // Check whether DsListRoles returns Fsmo's, and that they are responding

    status = ERROR_SUCCESS;

cleanup:

    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
    }

    // If warning flag set, and no more serious error, return indicator...
    if ( (status == ERROR_SUCCESS) && (fWarning) ) {
        status = ERROR_NOT_FOUND;
    }

    return status;
} /* LocatorGetDcMain */

BOOL
RH_CARVerifyGC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    )
/*++

Routine Description

    This code verifys that the DC passed back in pDcInfo is in fact a GC.

Arguments:

    pDsInfo - the mini enterprise.
    pDcInfo - the struct gotten from DsGetDcName()
    pdwErr - a return value of an error if it occured.

Return Values
  
    returns TRUE if it could verify the machine as a GC, returns FALSE if ther
    was an error or it verifies the machine as NOT a GC.  If the function
    verifies the machine as not a GC, then pdwErr will be ERROR_SUCCESS.

--*/
{
    LPWSTR                             pszTemp = NULL;
    LPWSTR                             pszOptions = NULL;
    INT                                i;
    ULONG                              iServer;
    LONG                               lOptions;
    WCHAR *                            pwcStopString;
    BOOL                               bRet;

    Assert(pDsInfo);
    Assert(pDcInfo);
    Assert(pdwErr);
    
    *pdwErr = ERROR_SUCCESS;

    __try {
        // Get a copy of the first part of the DNS name.
        pszTemp = pDcInfo->DomainControllerName;
        for(;pszTemp[0] == L'\\'; pszTemp++);

        // Find the server associated with this DNS name.
        iServer = DcDiagGetServerNum(pDsInfo, NULL, NULL, NULL, pszTemp, NULL);
        if(iServer == NO_SERVER){
            *pdwErr = ERROR_INVALID_SERVER_STATE;
            bRet = FALSE;
            __leave;
        }
        // Get the options attribute of this servere NTDSA object.
        *pdwErr = DcDiagGetStringDsAttribute(&(pDsInfo->pServers[iServer]), 
                                             pDsInfo->gpCreds,
                                             pDsInfo->pServers[iServer].pszDn,
                                             L"options",
                                             &pszOptions);
        if(*pdwErr != ERROR_SUCCESS){
            // Most likely NTDSA object didn't exist.
            bRet = FALSE;
            __leave;
        }
        if(pszOptions == NULL){
            // Attribute did not exist, meaning not a GC
            *pdwErr = ERROR_SUCCESS;
            bRet = FALSE;
            __leave;
        }

        lOptions = wcstol(pszOptions, &pwcStopString, 10);
        Assert(*pwcStopString == L'\0');
        
        if(lOptions & NTDSDSA_OPT_IS_GC){
            // Hooray, machine thinks it's a GC.
            *pdwErr = ERROR_SUCCESS;
            bRet = TRUE;
            __leave;
        } else {
            // Uh-oh, doesn't think it is a GC.
            *pdwErr = ERROR_SUCCESS;
            bRet = FALSE;
            __leave;
        }
    } __finally {
        if(pszOptions){ LocalFree(pszOptions); }
    }
    return(bRet);
}

BOOL
RH_CARVerifyPDC(
    IN  PDC_DIAG_DSINFO                pDsInfo,
    IN  PDOMAIN_CONTROLLER_INFO        pDcInfo,
    OUT PDWORD                         pdwErr
    )
/*++

Routine Description

    This function verifies that the server in the pDcInfo struct is a PDC.

Arguments:

    pDsInfo - the mini-enterprise.
    pDcInfo - the server struct from DsGetDcName()
    pdwErr - the error code if there is an error.

Return Values
  
    Returns TRUE if we are able to verify from DsListRoles() that this machine
    is a PDC.  If the machine is not listed in DsListRoles(), or there is an
    error then FALSE is returned.  If it is confirmed the server is NOT
    the PDC then the error code in pdwErr will be ERROR_SUCCESS

--*/
{
    HANDLE                             hDS = NULL;
    LPWSTR                             pszTemp = NULL;
    LPWSTR                             pszTargetName = NULL;
    PDS_NAME_RESULTW                   prgRoles = NULL;
    PDSNAME                            pdsnameNTDSSettings = NULL;
    PDSNAME                            pdsnameServer = NULL;
    ULONG                              iServer;
    ULONG                              iTemp;
    LPWSTR                             pszDnsName = NULL;

    Assert(pDsInfo);
    Assert(pDcInfo);
    Assert(pdwErr);

    *pdwErr = ERROR_SUCCESS;

    __try{
        // --------------------------------------------------- 
        // Setup server string from pDcInfo
        pszTemp = pDcInfo->DomainControllerName;
        for(;pszTemp[0] == L'\\'; pszTemp++);

        // ---------------------------------------------------
        // Setup Server string from DsListRoles.
        *pdwErr = DcDiagGetDsBinding(&(pDsInfo->pServers[pDsInfo->ulHomeServer]),
                                     pDsInfo->gpCreds,
                                     &hDS);
        if(*pdwErr != ERROR_SUCCESS){
            return(FALSE);
        }
        *pdwErr = DsListRoles(hDS, &prgRoles);
        if(*pdwErr != NO_ERROR){
            return(FALSE);
        }
        if(prgRoles->cItems < DS_ROLE_PDC_OWNER){
            *pdwErr = ERROR_INVALID_DATA;
            return(FALSE);
        }
        // Now we have the NTDSA object, but trim it off and get the 
        //   dNSHostName, from the Computer object.
        pdsnameNTDSSettings = DcDiagAllocDSName(prgRoles->rItems[DS_ROLE_PDC_OWNER].pName);
        if(pdsnameNTDSSettings == NULL){
            *pdwErr = GetLastError();
            return(FALSE);
        }
        pdsnameServer = (PDSNAME) LocalAlloc(LMEM_FIXED, 
                                             pdsnameNTDSSettings->structLen);
        if(pdsnameServer == NULL){
            *pdwErr = GetLastError();
            return(FALSE);
        }
        TrimDSNameBy(pdsnameNTDSSettings, 1, pdsnameServer);
        *pdwErr = DcDiagGetStringDsAttribute(&(pDsInfo->pServers[pDsInfo->ulHomeServer]), pDsInfo->gpCreds, 
                                             pdsnameServer->StringName, L"dNSHostName",
                                             &pszDnsName);
        
        if(*pdwErr != ERROR_SUCCESS){
            return(FALSE);
        }
        if(pszDnsName == NULL){
            // Simply means the attribute didn't exist.
            *pdwErr = ERROR_NOT_FOUND;
            return(FALSE);
        }

        // ---------------------------------------------------
        // Compare the two strings and make sure they are the same server.
        if(_wcsicmp(pszTemp, pszDnsName) == 0){
        // Successfully verified PDC with DsListRoles.
            *pdwErr = ERROR_SUCCESS;
            return(TRUE);
        } else {
            // Successfully concluded that they are advertising different PDCs.
            *pdwErr = ERROR_SUCCESS;
            return(FALSE);
        }
    } __finally {
        if(prgRoles){ DsFreeNameResult(prgRoles); }
        if(pdsnameNTDSSettings){ LocalFree(pdsnameNTDSSettings); }
        if(pdsnameServer){ LocalFree(pdsnameServer); }
        if(pszDnsName){ LocalFree(pszDnsName); }
    }
}

DWORD
RH_CARDsGetDcName(
    PDC_DIAG_SERVERINFO                psiTarget,
    ULONG                              ulRoleFlags,
    PDOMAIN_CONTROLLER_INFO *          ppDcInfo
    )
/*++

Routine Description

This is a helper routine to CheckAdvertiesedRoles(), and it basically reduces
this 12 line function call down to a 3 line function call.  Just for clarity
of code.

Arguments:

    psiTarget - the server to test.
    ulRoleFlags - the flags to OR (|) into the 5th parameter
    pDcInfo - the return structure

Return Values
  
    DWORD - the error code from DsGetDcName()

--*/
{
    return(DsGetDcName(psiTarget->pszName,
                       NULL, // domain name
                       NULL, // domain guid
                       NULL, // site name
                       DS_FORCE_REDISCOVERY |
                       DS_IP_REQUIRED |
                       DS_IS_DNS_NAME |
                       DS_RETURN_DNS_NAME |
                       (ulRoleFlags),
                       ppDcInfo ));
}


DWORD
CheckAdvertisedRoles(
    IN  PDC_DIAG_DSINFO             pDsInfo
    )
/*++

Routine Description:

This is a helper function for the CheckRoles test.

Check global roles known to the locator.  If the locator returns the name, the
server is up.

The locator can return a server according to a required criteria.  We point
DsGetDcName at a server to start, so it knows which enterprise it is in.
If we ask for a capability that is not on the starting server, it refers us to
another server with the capability.

The four capabilities, or roles, we ask it to locate are:
o Global Catalog Server (GC)
o Primary Domain Controller (PDC)
o Time Server
o Preferred Time Server
o Kerberos Key Distribution Center (KDC)

Arguments:

    pDsInfo - 

Return Value:

    DWORD - 

--*/
{
    DWORD status;
    BOOL fWarning = FALSE;
    PDC_DIAG_SERVERINFO psiTarget =
        &(pDsInfo->pServers[pDsInfo->ulHomeServer]);
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    DWORD dwError = ERROR_SUCCESS;

    // -----------------------------------------------------------------------
    //
    // Search for an advertised GC somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, 
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_GC_SERVER_REQUIRED, 
                                     &pDcInfo)) 
        == ERROR_SUCCESS) {
        if(!RH_CARVerifyGC(pDsInfo, pDcInfo, &dwError) != ERROR_SUCCESS){
            if(dwError == ERROR_SUCCESS){
                PrintMessage(SEV_NORMAL,
                             L"Error: A GC returned by DsGetDcName() was not a GC in it's directory\n");
            } else {
                PrintMessage( SEV_VERBOSE,
                              L"Warning: Couldn't verify this server as a GC in this servers AD.\n");
            }
        }
        PrintMessage(SEV_VERBOSE, L"GC Name: %ws\n",
                     pDcInfo->DomainControllerName );
        PrintMessage(SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                     pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS, 
                     L"Warning: DcGetDcName(GC_SERVER_REQUIRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS,
                      L"A Global Catalog Server could not be located - All GC's are down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised PDC somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget,
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_PDC_REQUIRED,
                                     &pDcInfo)) 
        == ERROR_SUCCESS) {
        if(!RH_CARVerifyPDC(pDsInfo, pDcInfo, &dwError) != ERROR_SUCCESS){
            if(dwError == ERROR_SUCCESS){
                PrintMessage( SEV_ALWAYS,
                              L"Error: The server returned by DsGetDcName() did not match DsListRoles() for the PDC\n");
            } else {
                PrintMessage( SEV_VERBOSE, L"Warning: Couldn't verify this server as a PDC using DsListRoles()\n");
            }
        }
        PrintMessage( SEV_VERBOSE, L"PDC Name: %ws\n", 
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS, 
                     L"Warning: DcGetDcName(PDC_REQUIRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS, 
                      L"A Primary Domain Controller could not be located.\n" );
        PrintMessage( SEV_ALWAYS, 
                      L"The server holding the PDC role is down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Time Server somewhere in the enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, 
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_TIMESERV_REQUIRED,
                                     &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"Time Server Name: %ws\n", 
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n", 
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(TIME_SERVER) call failed, error %d\n", 
                     status );
        PrintMessage( SEV_ALWAYS,
                      L"A Time Server could not be located.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"The server holding the PDC role is down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Preferred Time Server somewhere in the 
    //    enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget, DS_GOOD_TIMESERV_PREFERRED, &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"Preferred Time Server Name: %ws\n",
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n",
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(GOOD_TIME_SERVER_PREFERRED) call failed, error %d\n", 
                     status ); 
        PrintMessage( SEV_ALWAYS, 
                      L"A Good Time Server could not be located.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    // -----------------------------------------------------------------------
    //
    // Search for an advertised Key Distribution Center somewhere in the 
    //    enterprise...
    //

    // Get active domain controller information
    if ((status = RH_CARDsGetDcName(psiTarget,
                                     DS_DIRECTORY_SERVICE_REQUIRED | DS_KDC_REQUIRED,
                                     &pDcInfo))
        == ERROR_SUCCESS){
        PrintMessage( SEV_VERBOSE, L"KDC Name: %ws\n",
                      pDcInfo->DomainControllerName );
        PrintMessage( SEV_VERBOSE, L"Locator Flags: 0x%x\n",
                      pDcInfo->Flags );
    } else {
        PrintMessage(SEV_ALWAYS,
                     L"Warning: DcGetDcName(KDC_REQUIRED) call failed, error %d\n", 
                     status );
        PrintMessage( SEV_ALWAYS,
                      L"A KDC could not be located - All the KDCs are down.\n" );
        fWarning = TRUE;
        // Keep going
    }
    // Cleanup if previous function succeeded
    if (pDcInfo != NULL) {
        NetApiBufferFree( pDcInfo );
        pDcInfo = NULL;
    }

    if(fWarning){
        return ERROR_NOT_FOUND;
    }
    return(ERROR_SUCCESS);

} /* CheckAdvertisedRoles */


DWORD
ReplCheckRolesMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

This is a per-enterprise test.  It verifies that the owners of global roles can
be returened, at the owners are responding.

We check the two ways that Roles are made known to clients: through the locator
and through the Fsmo role apis.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status;

    status = CheckAdvertisedRoles( pDsInfo );

    return status;
} /* CheckRolesMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\servers.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    servers.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)

        Did alot, added a DNS/server failure analysis.

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <drs.h>  // need DS_REPL_INFO_REPSTO

#include "dcdiag.h"
#include "ldaputil.h"
#include "repl.h"

// Some constants for ReplicationsCheck
// There is a better place to get this var ... but it is a pain in the ass
const LPWSTR                    pszTestNameRepCheck = L"Replications Check";

// Extern
// BUGBUG - move this routine to common
DSTIME
IHT_GetSecondsSince1601();

BOOL DcDiagIsMasterForNC (
    PDC_DIAG_SERVERINFO          pServer,
    LPWSTR                       pszNC
    );


DWORD
GetRemoteSystemsTimeAsFileTime(
    PDC_DIAG_SERVERINFO         pServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    FILETIME *                  pTimeNow
    )
/*++

Routine Description:

    This takes a Server (pServer) and gets the "currentTime" stored in the 
    RootDSE from that server.

Parameters:

    pServer - [Supplies] The server to fetch the current time from.
    gpCreds - [Supplies] The credentials to use when fetching the time.
    pTimeNow - [Returns] The current time retrieved.

Return Value:
  
    Win 32 Error.

  --*/
{
    LDAPMessage *               pldmTimeResults = NULL;
    LPWSTR                      ppszCurrentTime [] = {
        L"currentTime",
        NULL };
    struct berval **            ppsbvTime = NULL;
    SYSTEMTIME                  aTime;
    DWORD                       dwRet;
    LDAP *                      hld = NULL;
    LDAPMessage *		pldmEntry;
    LPWSTR *                    ppszTime = NULL;

    if((dwRet = DcDiagGetLdapBinding(pServer,
                                     gpCreds,
                                     FALSE,
                                     &hld)) != NO_ERROR){
        return(dwRet);
    }    
    dwRet = LdapMapErrorToWin32(ldap_search_sW (hld,
                                                NULL,
                                                LDAP_SCOPE_BASE,
                                                L"(objectCategory=*)",
                                                ppszCurrentTime,
                                                0,
                                                &pldmTimeResults));
    if(dwRet != ERROR_SUCCESS){
        return(dwRet);
    }
    pldmEntry = ldap_first_entry (hld, pldmTimeResults);
    ppszTime = ldap_get_valuesW (hld, pldmEntry, L"currentTime");
    if(ppszTime == NULL){
        return(-1); // Error isn't used anyway.
    }
    dwRet = DcDiagGeneralizedTimeToSystemTime((LPWSTR) ppszTime[0], &aTime);
    if(dwRet != ERROR_SUCCESS){
        ldap_value_freeW(ppszTime);
        return(dwRet);
    }
    ldap_value_freeW(ppszTime);
    SystemTimeToFileTime(&aTime, pTimeNow);
        
    return(ERROR_SUCCESS); 
}


BOOL
GetCachedHighestCommittedUSN(
    PDC_DIAG_SERVERINFO pServer,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    USN *pUsn
    )

/*++

Routine Description:

Retrieve the "highestCommittedUSN" attribute from the ROOTDSE of the named
server.  If it is returned, it is cached in the server object, and reused
on the next call.

Arguments:

    pServer - 
    gpCreds - 
    pUsn - 

Return Value:

    BOOL - 

--*/

{
    DWORD status;
    BOOL fReturnResult = FALSE;
    LDAP *hLdap = NULL;
    LDAPMessage *pldmResults = NULL;
    LPWSTR ppszRootAttrs [] = {
        L"highestCommittedUSN",
        NULL };
    LDAPMessage *pldmEntry;
    LPWSTR *ppszUsnValues = NULL;

    // Return cached value if present
    if (pServer->usnHighestCommittedUSN) {
        *pUsn = pServer->usnHighestCommittedUSN;
        return TRUE;
    }

    // See if server is reachable. May not be if using MBR
    status = DcDiagGetLdapBinding( pServer, gpCreds, FALSE, &hLdap);
    if (status) {
        // If not reachable, just return quietly
        return FALSE;
    }

    // Get the value using LDAP
    status = LdapMapErrorToWin32(ldap_search_sW (hLdap,
                                                 NULL,
                                                 LDAP_SCOPE_BASE,
                                                 L"(objectCategory=*)",
                                                 ppszRootAttrs,
                                                 0,
                                                 &pldmResults));
    if (status != ERROR_SUCCESS) {
        PrintMessage(SEV_ALWAYS, L"An LDAP search of the RootDSE failed.\n" );
        PrintMessage(SEV_ALWAYS, L"The error is %s\n", Win32ErrToString(status) );
        goto cleanup;
    }

    // Only one object returned
    pldmEntry = ldap_first_entry (hLdap, pldmResults);
    if (pldmEntry == NULL) {
        Assert( FALSE );
        goto cleanup;
    }

    ppszUsnValues = ldap_get_valuesW (hLdap, pldmEntry, L"highestCommittedUSN");
    if (ppszUsnValues == NULL) {
        Assert( FALSE );
        goto cleanup;
    }

    // store the usn
    *pUsn = pServer->usnHighestCommittedUSN = _wtoi64( *ppszUsnValues );
    
    fReturnResult = TRUE;
cleanup:

    if (ppszUsnValues) {
        ldap_value_freeW(ppszUsnValues);
    }
    if (pldmResults != NULL) {
        ldap_msgfree(pldmResults);
    }

    return fReturnResult;
} /* GetCachedHighestCommittedUSN */


BOOL
checkRepsTo(
    PDC_DIAG_DSINFO		pDsInfo,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const LPWSTR		pszNC,
    PDC_DIAG_SERVERINFO         pSourceServer,
    PDC_DIAG_SERVERINFO         pDestServer
    )

/*++

Routine Description:

Look for the reps-to on the source server

Arguments:

    pDsInfo - 
    gpCreds - 
    pszNC - 
    pSourceServer - 
    pDestServer - 

Return Value:

    BOOL - was found or not

--*/

{
    DWORD ret;
    BOOL fResult = FALSE;
    HANDLE hDS = NULL;
    DS_REPL_NEIGHBORSW *pNeighbors = NULL;
    DS_REPL_NEIGHBORW * pNeighbor;

    if ( (!pSourceServer->bDnsIpResponding) ||
         (!pSourceServer->bLdapResponding) ||
         (!pSourceServer->bDsResponding) ) {
        // If we know source is down, don't bother
        return TRUE;
    }

    // Bind to the source server if it is up
    ret = DcDiagGetDsBinding(pSourceServer,
                             gpCreds,
                             &hDS);
    if (ERROR_SUCCESS != ret) {
        return TRUE; // claim success if can't reach
    }

    // Look up the reps-to we need
    ret = DsReplicaGetInfoW(hDS,
                            DS_REPL_INFO_REPSTO,
                            pszNC,
                            &(pDestServer->uuid),
                            &pNeighbors);
    if (ERROR_SUCCESS != ret) {
        PrintMessage(SEV_VERBOSE,
                     L"[%s,%s] DsReplicaGetInfo(REPSTO) failed with error %d,\n",
                     REPLICATIONS_CHECK_STRING,
                     pSourceServer->pszName,
                     ret);
        PrintMessage(SEV_VERBOSE, L"%s.\n",
                     Win32ErrToString(ret));
        return TRUE; // claim success if can't reach
    }

    // Resources acquired - must goto cleanup after this point

    // No reps-to looks like zero neighbors
    if (pNeighbors->cNumNeighbors == 0) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage(SEV_ALWAYS, L"ERROR: Expected notification link is missing.\n" );
        PrintMessage(SEV_ALWAYS, L"Source %s\n", pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"This problem should self-correct on the next periodic sync.\n" );
        goto cleanup;
    } else if (pNeighbors->cNumNeighbors != 1) {
        // Verify that it looks right
        PrintMessage( SEV_ALWAYS,
                      L"ERROR: Unexpected number of reps-to neighbors returned from %ws.\n",
                      pSourceServer->pszName );
        goto cleanup;
    }

    pNeighbor = &(pNeighbors->rgNeighbor[0]);
    if ( (_wcsicmp( pNeighbor->pszNamingContext, pszNC ) != 0) ||
         (memcmp( &(pNeighbor->uuidSourceDsaObjGuid),
                  &(pDestServer->uuid), sizeof( UUID ) ) != 0 ) ) {
        PrintMessage( SEV_ALWAYS,
                      L"ERROR: Reps-to has unexpected contents.\n" );
        goto cleanup;
    }

    fResult = TRUE;
cleanup:
    if (pNeighbors != NULL) {
        DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
    }

    return fResult;
} /* checkRepsTo */


VOID
RepCheckHelpSuccess(
    DWORD dwSuccessStatus
    )

/*++

Routine Description:

Given the user recommendations for success errors.  These errors are not counted
as failures (see drarfmod.c) must indicate a replication delay.

Arguments:

    dwSuccessStatus - 

Return Value:

    None

--*/

{
//Columns for message length
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    switch (dwSuccessStatus) {
    case ERROR_SUCCESS:
    case ERROR_DS_DRA_REPL_PENDING:
        PrintMessage( SEV_ALWAYS,
        L"Progress is occurring normally on this path.\n" );
        break;
    case ERROR_DS_DRA_PREEMPTED:
        PrintMessage( SEV_ALWAYS,
        L"A large number of replication updates need to be carried on this\n" );
        PrintMessage( SEV_ALWAYS,
        L"path. Higher priority replication work has temporarily interrupted\n" );
        PrintMessage( SEV_ALWAYS,
        L"progress on this link.\n" );
        break;
    case ERROR_DS_DRA_ABANDON_SYNC:
        PrintMessage( SEV_ALWAYS,
        L"Boot-time synchronization of this link was skipped because the source\n" );
        PrintMessage( SEV_ALWAYS,
        L"was taking too long returning updates.  Another sync will be tried\n" );
        PrintMessage( SEV_ALWAYS,
        L"at the next periodic replication interval.\n" );
        break;
    case ERROR_DS_DRA_SHUTDOWN:
        PrintMessage( SEV_ALWAYS,
        L"Either the source or destination was shutdown during the replication cycle.\n" );
        break;
    }

} /* RepCheckHelpSuccess */


VOID
RepCheckHelpFailure(
    DWORD dwFailureStatus,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    PDC_DIAG_SERVERINFO pSourceServer,
    PDC_DIAG_SERVERINFO pDestServer
    )

/*++

Routine Description:

Given the user recommendations for replication failures.

Arguments:

    dwFailureStatus - 
    pSourceServer - Source server for link. May be null if we haven't heard of this
    server yet.

Return Value:

    None

--*/

{
    DWORD status;
    HANDLE hDS = NULL;

    // If we couldn't resolve the source server, don't bother
    if (!pSourceServer) {
        return;
    }
//Columns for message length
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    switch (dwFailureStatus) {
// Retriable (transient) errors
    case ERROR_DS_DRA_SHUTDOWN:
    case ERROR_DS_DRA_SCHEMA_MISMATCH:
    case ERROR_DS_DRA_BUSY:
    case ERROR_DS_DRA_PREEMPTED:
    case ERROR_DS_DRA_ABANDON_SYNC:
        break;
    case ERROR_DS_DRA_OBJ_NC_MISMATCH:
        PrintMessage( SEV_ALWAYS,
        L"The parent of the object we tried to add is in the wrong\n" );
        PrintMessage( SEV_ALWAYS,
        L"partition.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A modification and a cross-domain move occurred at the same time.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Replication will correct itself later once the writeable\n" );
        PrintMessage( SEV_ALWAYS,
        L"copies synchronize and sort out the inconsistency.\n" );
        break;
    case ERROR_OBJECT_NOT_FOUND:
    case ERROR_DS_DRA_MISSING_PARENT:
        PrintMessage( SEV_ALWAYS,
        L"The parent of the object we tried to add is missing\n" );
        PrintMessage( SEV_ALWAYS,
        L"because it is deleted.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A modification and a parent delete occurred at the same time.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Replication will correct itself later once the writeable\n" );
        PrintMessage( SEV_ALWAYS,
        L"copies synchronize and  sort out the inconsistency.\n" );
        break;
    case RPC_S_SERVER_UNAVAILABLE:
        if ( (!pSourceServer->bDnsIpResponding) ||
             (!pSourceServer->bLdapResponding) ||
             (!pSourceServer->bDsResponding) ) {
            // Server is down
            PrintMessage( SEV_ALWAYS,
                          L"The source remains down. Please check the machine.\n" );
        } else {
            // Bind to the source server if it is up
            status = DcDiagGetDsBinding(pSourceServer,
                                        gpCreds,
                                        &hDS);
            if (ERROR_SUCCESS == status) {
                // Server is up now
                PrintMessage( SEV_ALWAYS,
                              L"The source %s is responding now.\n",
                              pSourceServer->pszName );
            } else {
                // Server is down
                PrintMessage( SEV_ALWAYS,
                              L"The source remains down. Please check the machine.\n" );
            }
        }
        break;

// Call failures
    case ERROR_DS_DNS_LOOKUP_FAILURE:
        PrintMessage( SEV_ALWAYS,
        L"The guid-based DNS name %s\n", pSourceServer->pszGuidDNSName );
        PrintMessage( SEV_ALWAYS,
        L"is not registered on one or more DNS servers.\n" );
        break;
    case ERROR_DS_DRA_OUT_OF_MEM:
    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        break;
    case RPC_S_SERVER_TOO_BUSY:
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"Security provider may have returned an unexpected error code.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"Check the clock difference between the two machines.\n" );

        break;
    case RPC_S_CALL_FAILED:
    case ERROR_DS_DRA_RPC_CANCELLED:
        PrintMessage( SEV_ALWAYS,
        L"The replication RPC call executed for too long at the server and\n" );
        PrintMessage( SEV_ALWAYS,
        L"was cancelled.\n" );
        PrintMessage( SEV_ALWAYS,
                      L"Check load and resouce usage on %s.\n",
                      pSourceServer->pszName );
        break;
    case EPT_S_NOT_REGISTERED:
        PrintMessage( SEV_ALWAYS,
        L"The directory on %s is in the process.\n",
                      pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"of starting up or shutting down, and is not available.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Verify machine is not hung during boot.\n" );
        break;

// Kerberos security errors
    case ERROR_TIME_SKEW:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check that the system time between the two servers is sufficiently.\n" );
        PrintMessage( SEV_ALWAYS,
        L"close. Also check that the time service is functioning correctly\n" );
        break;
    case ERROR_DS_DRA_ACCESS_DENIED:
        PrintMessage( SEV_ALWAYS,
        L"The machine account for the destination %s.\n",
                      pDestServer->pszName );
        PrintMessage( SEV_ALWAYS,
                      L"is not configured properly.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check the userAccountControl field.\n" );
        // fall through
    case ERROR_LOGON_FAILURE:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The machine account is not present, or does not match on the.\n" );
        PrintMessage( SEV_ALWAYS,
        L"destination, source or KDC servers.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Verify domain partition of KDC is in sync with rest of enterprise.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The tool repadmin/syncall can be used for this purpose.\n" );
        break;
    case ERROR_WRONG_TARGET_NAME:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The Service Principal Name for %s.\n",
                      pSourceServer->pszName );
        PrintMessage( SEV_ALWAYS,
        L"is not registered at the KDC (usually %s).\n",
                      pDestServer->pszName );
        PrintMessage( SEV_ALWAYS,
        L"Verify domain partition of KDC is in sync with rest of enterprise.\n" );
        PrintMessage( SEV_ALWAYS,
        L"The tool repadmin/syncall can be used for this purpose.\n" );
        break;
    case ERROR_DOMAIN_CONTROLLER_NOT_FOUND:
        PrintMessage( SEV_ALWAYS,
        L"Kerberos Error.\n" );
        PrintMessage( SEV_ALWAYS,
        L"A KDC was not found to authenticate the call.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Check that sufficient domain controllers are available.\n" );
        break;
        
// Replication Errors

    case ERROR_ENCRYPTION_FAILED:
        PrintMessage( SEV_ALWAYS,
        L"Check that the servers have the proper certificates.\n" );
        break;
    case ERROR_DS_DRA_SOURCE_DISABLED:
    case ERROR_DS_DRA_SINK_DISABLED:
        PrintMessage( SEV_ALWAYS,
        L"Replication has been explicitly disabled through the server options.\n" );
        break;
    case ERROR_DS_DRA_SCHEMA_INFO_SHIP:
    case ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT:
        PrintMessage( SEV_ALWAYS,
        L"Try upgrading all domain controllers to the lastest software version.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Try synchronizing the Schema partition on all servers in the forest.\n" );
        break;
    case ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET:
    case ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA:
        PrintMessage( SEV_ALWAYS,
        L"Try synchronizing the Schema partition on all servers in the forest.\n" );
        break;

//Serious error

    case ERROR_DISK_FULL:
        PrintMessage( SEV_ALWAYS,
        L"The disk containing the database or log files on %s\n",
                      pDestServer->pszName );
        PrintMessage( SEV_ALWAYS,
        L"does not have enough space to replicate in the latest changes.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Try moving the database files to a larger volume using ntdsutil.\n" );
        break;
    case ERROR_DS_OBJ_TOO_LARGE:
        PrintMessage( SEV_ALWAYS,
        L"The size of the last replication update was too large or complex\n" );
        PrintMessage( SEV_ALWAYS,
        L"to be held in memory.  Consult the error log. The change\n" );
        PrintMessage( SEV_ALWAYS,
        L"must be simplified at the server where it originated.\n" );
        break;
    case ERROR_DS_DRA_INTERNAL_ERROR:
    case ERROR_DS_DRA_DB_ERROR:
        PrintMessage( SEV_ALWAYS,
        L"A serious error is preventing replication from continuing.\n" );
        PrintMessage( SEV_ALWAYS,
        L"Consult the error log for further information.\n" );
        PrintMessage( SEV_ALWAYS,
        L"If a particular object is named, it may be necessary to manually\n" );
        PrintMessage( SEV_ALWAYS,
        L"modify or delete the object.\n" );
        PrintMessage( SEV_ALWAYS,
        L"If the condition persists, contact Microsoft Support.\n" );
        break;

    // Core internal errors, should not be returned
    case ERROR_DS_DRA_NAME_COLLISION:
    case ERROR_DS_DRA_SOURCE_REINSTALLED:
        Assert( !"Unexpected error status returned" );
        break;

    default:
        break;
    }

} /* RepCheckHelpFailure */

VOID 
ReplicationsCheckRep (
    PDC_DIAG_DSINFO		pDsInfo,
    SEC_WINNT_AUTH_IDENTITY_W * gpCreds,
    const ULONG			ulServer,
    const LPWSTR		pszNC,
    const DS_REPL_NEIGHBORW *	pNeighbor
    )
/*++

Routine Description:

    This function takes the pNeighbor structure associated with the server 
    ulServer and checks the replications for the specified NC.

Parameters:
    pDsInfo - [Supplies] The main directiory info.
    ulServer - [Supplies] The server to target.
    pszNC - [Supplies] The NC to specify.
    pNeighbor - [Supplies] The neighbor info from the repsFrom that is used
        to detemine if there are any errors on this servers replications.

  --*/
{
    // The number of 100 nsec intervals in one minute.
    const LONGLONG		llIntervalsPerMinute = (60 * 1000 * 1000 * 10);
    const LONGLONG		llUnusualRepDelay = 180 * llIntervalsPerMinute;
                                                     //  3 hours
    CHAR			szBuf [SZDSTIME_LEN];
    WCHAR			szTimeLastAttempt [SZDSTIME_LEN];
    WCHAR			szTimeLastSuccess [SZDSTIME_LEN];
    FILETIME			timeNow;
    //    FILETIME			timeLastAttempt;
    DSTIME                      dstimeLastSyncSuccess;
    DSTIME                      dstimeLastSyncAttempt;
    LONGLONG			llTimeSinceLastAttempt;
    LONGLONG			llTimeSinceLastSuccess;

    LPWSTR			pszSourceName = L"(unknown)";
    ULONG			ulServerTemp;
    DWORD                       dwRet;
    PDC_DIAG_SERVERINFO         pSourceServer = NULL;

    if (IsDeletedRDNW(pNeighbor->pszSourceDsaDN)) { 
        //  Since this is actually a deleted server/neighbor we will skip it
        return;
    }

    ulServerTemp = DcDiagGetServerNum(pDsInfo, NULL, NULL, 
                                      pNeighbor->pszSourceDsaDN, NULL, NULL);
    if(ulServerTemp != NO_SERVER) {
        pSourceServer = &(pDsInfo->pServers[ulServerTemp]);
        pszSourceName = pSourceServer->pszName;

        // Should we skip this source?
        if ( (pDsInfo->ulFlags & DC_DIAG_IGNORE) &&
             ( (!pSourceServer->bDnsIpResponding) ||
               (!pSourceServer->bLdapResponding) ||
               (!pSourceServer->bDsResponding) ) &&
             (pNeighbor->cNumConsecutiveSyncFailures) &&
             (pNeighbor->dwLastSyncResult == RPC_S_SERVER_UNAVAILABLE) ) {
            IF_DEBUG(
                PrintMessage(SEV_VERBOSE, 
                             L"Skipping neighbor %s, because it was down\n",
                             pDsInfo->pServers[ulServerTemp].pszName) );
            return;
        }

        // Is this source server prohibiting outbound replications?
        if (pSourceServer->iOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            PrintMessage(SEV_NORMAL, 
                         L"Skipping server %s, because it has outbound "
                         L"replication disabled\n", 
                         pSourceServer->pszName);
            return;
            // If it is, there's no point in printing a zillion 
            //   warning messages.
        }
    }

    // Gather all the time information.
    // pNeighbor ->ftimeLastSyncSuccess  ->ftimeLastSyncAttempt  timeNow

    FileTimeToDSTime(pNeighbor->ftimeLastSyncAttempt, &dstimeLastSyncAttempt);
    DSTimeToDisplayString (dstimeLastSyncAttempt, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
				szTimeLastAttempt, SZDSTIME_LEN);

    FileTimeToDSTime(pNeighbor->ftimeLastSyncSuccess, &dstimeLastSyncSuccess);
    DSTimeToDisplayString (dstimeLastSyncSuccess, szBuf);
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
				szTimeLastSuccess, SZDSTIME_LEN);

    dwRet = GetRemoteSystemsTimeAsFileTime (&(pDsInfo->pServers[ulServer]),
                                            pDsInfo->gpCreds,
                                            &timeNow);
    if(dwRet != ERROR_SUCCESS){
        PrintMessage(SEV_VERBOSE, 
                     L"Warning: Could not get current time from remote\n");
        PrintMessage(SEV_VERBOSE,
                     L"directory on %s, using the local time instead\n",
                     pDsInfo->pServers[ulServer].pszName);
        GetSystemTimeAsFileTime(&timeNow);
    }

    // instead of timeLastAttempt .. use pNeighbor->ftimeLastSyncAttempt
    llTimeSinceLastSuccess = ((LARGE_INTEGER *) &timeNow)->QuadPart
        - ((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncSuccess)->QuadPart;
    llTimeSinceLastAttempt = ((LARGE_INTEGER *) &timeNow)->QuadPart 
        - ((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncAttempt)->QuadPart;

    Assert(llTimeSinceLastAttempt >= 0);
    Assert(llTimeSinceLastSuccess >= 0);
    
    // Check for failures.
    if (pNeighbor->cNumConsecutiveSyncFailures) {
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] A recent replication attempt failed:\n",
                     REPLICATIONS_CHECK_STRING,
                     pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
    	PrintMessage(SEV_ALWAYS, L"From %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
    	PrintMessage(SEV_ALWAYS, L"Naming Context: %s\n", pszNC);
    	PrintMessage(SEV_ALWAYS, 
                     L"The replication generated an error (%ld):\n", 
                     pNeighbor->dwLastSyncResult);
    	PrintMessage(SEV_ALWAYS, L"%s\n", 
                     Win32ErrToString (pNeighbor->dwLastSyncResult));
    	PrintMessage(SEV_ALWAYS, L"The failure occurred at %s.\n", 
                     szTimeLastAttempt);
    	PrintMessage(SEV_ALWAYS, L"The last success occurred at %s.\n", 
                     szTimeLastSuccess);
    	PrintMessage(SEV_ALWAYS, 
                     L"%d failures have occurred since the last success.\n",
                     pNeighbor->cNumConsecutiveSyncFailures);
        RepCheckHelpFailure( pNeighbor->dwLastSyncResult,
                             gpCreds,
                             pSourceServer,
                             &(pDsInfo->pServers[ulServer]) );
        PrintIndentAdj(-1);

    // Check if this replication has never been attempted.
    } else if (((LARGE_INTEGER *) &pNeighbor->ftimeLastSyncAttempt)->QuadPart == 0) {
        // This is okay -- e.g., a newly added source.  This means a
        //    replication has never been attempted.

        NOTHING;

    // Check if it's gone unattempted || for an unusually long time.
    } else if (llTimeSinceLastAttempt >= llUnusualRepDelay){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] No replication recently attempted:\n",
                     REPLICATIONS_CHECK_STRING,
                     pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
    	PrintMessage(SEV_ALWAYS, L"From %s to %s\n", 
                     pszSourceName, pDsInfo->pServers[ulServer].pszName);
    	PrintMessage(SEV_ALWAYS, L"Naming Context: %s\n", pszNC);
    	PrintMessage(SEV_ALWAYS, 
                L"The last attempt occurred at %s (about %I64d hours ago).\n", 
                     szTimeLastAttempt, 
                     llTimeSinceLastAttempt / llIntervalsPerMinute / 60);
        PrintIndentAdj(-1);

        // Check for delays when the last status was success
    } else if ( (llTimeSinceLastSuccess >= llUnusualRepDelay) ||
                ( (pNeighbor->dwLastSyncResult != ERROR_SUCCESS) &&
                  (pNeighbor->dwLastSyncResult != ERROR_DS_DRA_REPL_PENDING) )) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS,
                   L"%s: This replication path was preempted by higher priority work.\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
    	PrintMessage(SEV_ALWAYS, L"from %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
    	PrintMessage(SEV_ALWAYS, L"Reason: %s\n", 
                     Win32ErrToString (pNeighbor->dwLastSyncResult));
    	PrintMessage(SEV_ALWAYS, L"The last success occurred at %s.\n", 
                     szTimeLastSuccess);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        RepCheckHelpSuccess( pNeighbor->dwLastSyncResult) ;
        PrintIndentAdj(-1);
    } // end big if/elseif/elseif check for failures statement

    // Report on full sync in progress

    // Can't use DS_REPL_NBR_NEVER_SYNCED because not set for mail
    if (pNeighbor->usnAttributeFilter == 0) {
        USN usnHighestCommittedUSN = 0;

        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: A full synchronization is in progress\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
    	PrintMessage(SEV_ALWAYS, L"from %s to %s\n", pszSourceName, 
                     pDsInfo->pServers[ulServer].pszName);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        // If we can reach the source, find out his highest USN
        if ( pSourceServer &&
             (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT)) &&
             (GetCachedHighestCommittedUSN(
                 pSourceServer, pDsInfo->gpCreds, &usnHighestCommittedUSN ))) {
            double percentComplete =
                ((double)pNeighbor->usnLastObjChangeSynced /
                 (double)usnHighestCommittedUSN) * 100.0;
            PrintMessage( SEV_ALWAYS,
                          L"The full sync is %.2f%% complete.\n", percentComplete );

        }
        PrintIndentAdj(-1);
    }

    // If expecting notification, check reps-to on source
    if ( (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS)) &&
         (!(pNeighbor->dwReplicaFlags & DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT)) &&
         (pSourceServer) ) {
        checkRepsTo( pDsInfo, gpCreds, pszNC, pSourceServer,
                     &(pDsInfo->pServers[ulServer]) );
    }
}


VOID
ReplicationsCheckQueue(
    PDC_DIAG_DSINFO		pDsInfo,
    const ULONG			ulServer,
    DS_REPL_PENDING_OPSW *      pPendingOps
    )

/*++

Routine Description:

Check that the current item in the replication work queue has not gone on too long.

Arguments:

    pDsInfo - 
    ulServer - 
    pPendingOps - 

Return Value:

    None

--*/

{
#define NON_BLOCKING_TIMELIMIT (5 * 60)
#define BLOCKING_TIMELIMIT (2 * 60)
#define EXCESSIVE_ITEM_LIMIT (50)
    CHAR szBuf[SZDSTIME_LEN];
    WCHAR wszTime[SZDSTIME_LEN];
    DWORD status;
    PDC_DIAG_SERVERINFO pServer = &(pDsInfo->pServers[ulServer]);
    DSTIME dsTime, dsTimeNow;
    int dsElapsed, limit;
    BOOL fBlocking;
    DS_REPL_OPW *pOp;
    LPWSTR pszOpType;

    // Check for no work in progress
    if ( (pPendingOps->cNumPendingOps == 0) ||
         (memcmp( &pPendingOps->ftimeCurrentOpStarted, &gftimeZero,
                  sizeof( FILETIME ) ) == 0) ) {
        return;
    }

    PrintMessage( SEV_VERBOSE,
                  L"%s: There are %d replication work items in the queue.\n",
                  pDsInfo->pServers[ulServer].pszName,
                  pPendingOps->cNumPendingOps );

    FileTimeToDSTime(pPendingOps->ftimeCurrentOpStarted, &dsTime);
    dsTimeNow = IHT_GetSecondsSince1601();

    dsElapsed = (int) (dsTimeNow - dsTime);

    // See if anyone is waiting

    if ( (pPendingOps->cNumPendingOps == 1) ||
         (pPendingOps->rgPendingOp[0].ulPriority >=
          pPendingOps->rgPendingOp[1].ulPriority ) ) {
        // Nobody more important is waiting
        limit = NON_BLOCKING_TIMELIMIT;
        fBlocking = FALSE;
    } else {
        // Somebody important is blocked
        limit = BLOCKING_TIMELIMIT;
        fBlocking = TRUE;
    }

    // This has gone on long enough!

    if (dsElapsed > limit) {
        pOp = &pPendingOps->rgPendingOp[0];

        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: A long-running replication operation is in progress\n",
                      pDsInfo->pServers[ulServer].pszName);
        PrintIndentAdj(1);
        PrintMessage( SEV_ALWAYS, L"The job has been executing for %d minutes and %d seconds.\n",
                      dsElapsed / 60, dsElapsed % 60);
        PrintMessage( SEV_ALWAYS,
                      L"Replication of new changes along this path will be delayed.\n" );
        if (fBlocking) {
            PrintMessage( SEV_ALWAYS, L"Error: Higher priority replications are being blocked\n" );
        } else {
            PrintMessage( SEV_ALWAYS,
                          L"This is normal for a new connection, or for a system\n" );
            PrintMessage( SEV_ALWAYS,
                          L"that has been down a long time.\n" );
        }
        
        FileTimeToDSTime(pOp->ftimeEnqueued, &dsTime);
        DSTimeToDisplayString(dsTime, szBuf);
        MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szBuf, SZDSTIME_LEN,
                             wszTime, SZDSTIME_LEN);
        
        PrintMessage( SEV_ALWAYS, L"Enqueued %s at priority %d\n",
                      wszTime,
                      pOp->ulPriority );
            
        switch (pOp->OpType) {
        case DS_REPL_OP_TYPE_SYNC:
            pszOpType = L"SYNC FROM SOURCE";
            break;
        case DS_REPL_OP_TYPE_ADD:
            pszOpType = L"ADD NEW SOURCE";
            break;
        case DS_REPL_OP_TYPE_DELETE:
            pszOpType = L"DELETE SOURCE";
            break;
        case DS_REPL_OP_TYPE_MODIFY:
            pszOpType = L"MODIFY SOURCE";
            break;
        case DS_REPL_OP_TYPE_UPDATE_REFS:
            pszOpType = L"UPDATE CHANGE NOTIFICATION";
            break;
        default:
            pszOpType = L"UNKNOWN";
            break;
        }

        PrintMessage( SEV_ALWAYS, L"Op: %s\n", pszOpType);
        PrintMessage( SEV_ALWAYS, L"NC %ls\n", pOp->pszNamingContext);
        PrintMessage( SEV_ALWAYS, L"DSADN %ls\n", 
                      pOp->pszDsaDN ? pOp->pszDsaDN : L"(null)");
        PrintMessage( SEV_ALWAYS, L"DSA transport addr %ls\n",
                      pOp->pszDsaAddress ? pOp->pszDsaAddress : L"(null)");
        PrintIndentAdj(-1);
    } else {
        // Job still has time left
        PrintMessage( SEV_VERBOSE,
                      L"The first job has been executing for %d:%d.\n",
                      dsElapsed / 60, dsElapsed % 60);
    }

    if (pPendingOps->cNumPendingOps > EXCESSIVE_ITEM_LIMIT) {
        PrintMessage( SEV_ALWAYS, L"REPLICATION LATENCY WARNING\n" );
        PrintMessage( SEV_ALWAYS, L"%s: %d replication work items are backed up.\n",
                      pDsInfo->pServers[ulServer].pszName,
                      pPendingOps->cNumPendingOps );
    }

} /* ReplicationsCheckQueue */


DWORD
ReplicationsCheckLatency(
    HANDLE                      hDs,
    PDC_DIAG_DSINFO		pDsInfo,
    const ULONG			ulServer
    )

/*++

Routine Description:

Check that the latency of replication from all other servers for all NC's
Display if over EXCESSIVE_LATENCY_LIMIT

Arguments:

    hDs - handle
    pDsInfo - info block
    ulServer - index of server in pDsInfo->pServers

Return Value:

    0 on success or Win32 error code on failure.

--*/

{

    DWORD               iCursor;
    DSTIME              dsTime;
    CHAR                szTime[SZDSTIME_LEN];
    BOOL                fWarning = FALSE;
    BOOL                fNCWarning = FALSE;
    FILETIME            ftCurrentTime;
    FILETIME            ftLastSyncSuccess;
    DS_REPL_CURSORS_2 *         pCursors2 = NULL;
    ULARGE_INTEGER      uliSyncTime;
    ULONG               ulOtherServerIndex;
    ULONG               ulNC;
    INT                 ret;
    ULONG               cRetiredInvocationId = 0;
    ULONG               cTimeStamp = 0;
    ULONG               cIgnoreReadOnlyReplicas = 0;
    
    //define times in nanoseconds for latency limit
    #define _SECOND ((LONGLONG)10000000)
    #define _MINUTE (60 * _SECOND)
    #define _HOUR   (60 * _MINUTE)
    #define _DAY    (24 * _HOUR) 
    #define EXCESSIVE_LATENCY_LIMIT (12*_HOUR)
    

    PrintMessage(SEV_VERBOSE, 
			 L"*Replication Latency Check\n"   );
    //check latency for each NC we have info on
    for (ulNC=0;ulNC<pDsInfo->cNumNCs;ulNC++) { 
	if (  !((pDsInfo->pszNC != NULL) && _wcsicmp(pDsInfo->pNCs[ulNC].pszDn,pDsInfo->pszNC)) 
	      &&
	      (DcDiagHasNC(pDsInfo->pNCs[ulNC].pszDn, &(pDsInfo->pServers[ulServer]), TRUE, TRUE))
	       ) 
	   //do not perform the test for this NC if:

	   //the NC is specified on the command line and this NC is not the one specified
	   //or
	   //this NC doesn't exist on this server 
	    
	{ 
	//init counters to track info on vector entries we cannot compute a latency for
	cRetiredInvocationId = 0;
	cTimeStamp = 0;
	cIgnoreReadOnlyReplicas = 0;

	//init for warning info
	fNCWarning = FALSE;

	//get UTD cursor
	ret = DsReplicaGetInfoW(hDs, DS_REPL_INFO_CURSORS_2_FOR_NC, pDsInfo->pNCs[ulNC].pszDn, NULL, &pCursors2);
	
	if (ERROR_NOT_SUPPORTED == ret) {
	    PrintMessage(SEV_VERBOSE,
			 L"The replications latency check is not available on this DC.\n");
	    return ERROR_SUCCESS;
	}
	else if (ERROR_SUCCESS != ret) {
	    PrintMessage(SEV_ALWAYS,
			 L"[%s,%s] DsReplicaGetInfoW(CURSORS_2_FOR_NC) failed with error %d,\n",
			 REPLICATIONS_CHECK_STRING,
			 pDsInfo->pServers[ulServer].pszName,
			 ret);
	    PrintMessage(SEV_ALWAYS, L"%s\n",
			 Win32ErrToString(ret));
	    if (pCursors2 != NULL)   {DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_2_FOR_NC, pCursors2);}
	    return ret;
	} 


	//get the current time on the homeserver (or at least current with respect to vector)
	ftCurrentTime = pDsInfo->pServers[ulServer].ftRemoteConnectTime;

	//for each row/invocationID in the cursor, check the repl latency to the corresponding server
	for (iCursor = 0; iCursor < pCursors2->cNumCursors; iCursor++) {
	    
	    ulOtherServerIndex = DcDiagGetServerNum(pDsInfo, 
						    NULL, 
						    NULL, 
						    NULL, 
						    NULL, 
						    &(pCursors2->rgCursor[iCursor].uuidSourceDsaInvocationID));
	    if (ulOtherServerIndex==ulServer) {
		// this is us, we don't need to do anything for our own row in the vector
	    }
	    else if (ulOtherServerIndex==NO_SERVER) {    
		//no server found in the pDsInfo to match the GUID from the Cursor
		//this machine has been restored/etc and the invocationId is retired
		//no need to check latency for this. track how many for verbose print
		cRetiredInvocationId += 1; 
	    }
	    else if (!DcDiagIsMasterForNC(&(pDsInfo->pServers[ulOtherServerIndex]),pDsInfo->pNCs[ulNC].pszDn)) {
		// don't check latency for read only copies in the cursor, they are not
		// guaranteed to be viable in our repliation path (there can exist entires in the UTD which
		// we no longer replicate with, so those latencies will appear stale)
		cIgnoreReadOnlyReplicas +=1;
	    }
	    else { 
		//translate filetime to ularge_integer for comparison	
		uliSyncTime.LowPart = pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess.dwLowDateTime;
		uliSyncTime.HighPart = pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess.dwHighDateTime;

		if (uliSyncTime.QuadPart==0) {
		    //the timestamp is not there, version < V2
		    //verbose print count below
		    cTimeStamp += 1;  
		}
		else { //uliSyncTime is non zero

		    // Add EXCESSIVE_LATENCY_LIMIT
		    uliSyncTime.QuadPart = uliSyncTime.QuadPart + EXCESSIVE_LATENCY_LIMIT;

		    // Copy the result back into a FILETIME structure to make comparisons.
		    ftLastSyncSuccess.dwLowDateTime  = uliSyncTime.LowPart;
		    ftLastSyncSuccess.dwHighDateTime = uliSyncTime.HighPart; 

		    if ( CompareFileTime(&ftCurrentTime,&ftLastSyncSuccess) > 0) {
			
			if (!fWarning) {
			    FileTimeToDSTime(ftCurrentTime,
					     &dsTime); 
			    DSTimeToDisplayString(dsTime, szTime);
			    PrintMessage( SEV_ALWAYS, L"REPLICATION-RECEIVED LATENCY WARNING\n");   
			    PrintMessage( SEV_ALWAYS, L"%s:  Current time is %S.\n", 
					  pDsInfo->pServers[ulServer].pszName, 
					  szTime );


			}
			//for any nc outside the latency limits, only display the above message once
			fWarning = TRUE;
			if (!fNCWarning) {
			    PrintMessage( SEV_ALWAYS, L"   %s\n", pDsInfo->pNCs[ulNC].pszDn);
			}
			fNCWarning = TRUE;
			//for each nc outside the latency limits, display the above message once

			FileTimeToDSTime(pCursors2->rgCursor[iCursor].ftimeLastSyncSuccess,
					 &dsTime); 
			DSTimeToDisplayString(dsTime, szTime);
			PrintMessage( SEV_ALWAYS, L"      Last replication recieved from %s at %S.\n",
				      pDsInfo->pServers[ulOtherServerIndex].pszName,
				      szTime ? szTime : "(unknown)" ); 
			//if beyond the tombstonelifetime, print another warning
			uliSyncTime.QuadPart = uliSyncTime.QuadPart - EXCESSIVE_LATENCY_LIMIT + pDsInfo->dwTombstoneLifeTimeDays*_DAY;
			
			ftLastSyncSuccess.dwLowDateTime  = uliSyncTime.LowPart;
			ftLastSyncSuccess.dwHighDateTime = uliSyncTime.HighPart;
			if (CompareFileTime(&ftCurrentTime,&ftLastSyncSuccess) > 0) {
			    PrintMessage (SEV_ALWAYS, 
					  L"      WARNING:  This latency is over the Tombstone Lifetime of %d days!\n",
					  pDsInfo->dwTombstoneLifeTimeDays);
			}

		    }// if comparefiletime
		}//else { //uliSyncTime is non zero
	    }//else ulOtherServer not found
	}//for (iCursor = 0; iCursor < 	pCurors2->cNumCursors; iCursor++) {
 
	if (cRetiredInvocationId!=0 || cTimeStamp!=0 || cIgnoreReadOnlyReplicas!=0) {
	    if (!fNCWarning) {
		PrintMessage( SEV_VERBOSE, L"   %s\n", pDsInfo->pNCs[ulNC].pszDn);
	    }
	    PrintMessage(SEV_VERBOSE, 
			 L"      Latency information for %d entries in the vector were ignored.\n", 
			 cRetiredInvocationId + cTimeStamp + cIgnoreReadOnlyReplicas);
	    PrintMessage(SEV_VERBOSE,
			 L"         %d were retired Invocations.  %d were read-only replicas and are not verifiably latent.  %d had no latency information (Win2K DC).  \n",
			 cRetiredInvocationId,
			 cIgnoreReadOnlyReplicas,
			 cTimeStamp);
	}

        if (pCursors2 != NULL)  { DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_2_FOR_NC, pCursors2); }
	} //else
    } //for(ulNC=0;ulNC<pDsInfo->cNumNCs;ulNC++) {

    return ERROR_SUCCESS;
} //ReplicationsCheckLatency

BOOL
DcDiagHasNC(
    LPWSTR                           pszNC,
    PDC_DIAG_SERVERINFO              pServer,
    BOOL                             bMasters,
    BOOL                             bPartials
    )
/*++

Routine Description:

    Checks if the DC specified by pServer has the NC specified by pszNC.  The
    routine can check for read only, writeable or both, by bMasters & bPartials

Parameters:
    pszNC - IN is the NC to check for
    pServer - IN is the server to check
    bMasters - IN is true if you want to check for writeable copies of NCs
    bPartials - IN is true if you want to check for read only copies of NCs

Return Value:
  
    True if it found the NC in the right form (read only/writeable).
    Fales otherwise.

  --*/
{
    INT iTemp;

    if(pszNC == NULL){
        return TRUE;
    }

    // Make sure this is a server that has this NC.
    if(bMasters){
        if(pServer->ppszMasterNCs != NULL){
            for(iTemp = 0; pServer->ppszMasterNCs[iTemp] != NULL; iTemp++){
                if(_wcsicmp(pServer->ppszMasterNCs[iTemp], pszNC) == 0){
                    return TRUE;
                }

            } // end for loop cycling through MasterNCs for pServer
        }
    }

    if(bPartials){
        if(pServer->ppszPartialNCs != NULL){
            for(iTemp = 0; pServer->ppszPartialNCs[iTemp] != NULL; iTemp++){
                if(_wcsicmp(pServer->ppszPartialNCs[iTemp], pszNC) == 0){
                    return TRUE;
                }

            } // end for loop cycling through MasterNCs for pServer
        }
    }

    return FALSE;
}

BOOL DcDiagIsMasterForNC (
    PDC_DIAG_SERVERINFO          pServer,
    LPWSTR                       pszNC
    )
/*++

Routine Description:

Check that pServer is a master for the NC pszNC

Arguments:

    pServer - Server info block
    pszNC - String representation of NC

Return Value:

    TRUE or FALSE

--*/
{
    ULONG                        ulTemp;

    if (!pServer) {
	return FALSE;
    }

    if(pServer->ppszMasterNCs){
	for(ulTemp = 0; pServer->ppszMasterNCs[ulTemp] != NULL; ulTemp++) {  
	    if (!_wcsicmp(pServer->ppszMasterNCs[ulTemp],pszNC)) {
		return TRUE;
	    }
	}
    }
    return FALSE;
}

DWORD 
ReplReplicationsCheckMain (
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
{
    #define DsRRCMChkLdap(s,e)                                                      \
    {                                                                               \
        DWORD _dwWin32Err;                                                          \
        if ((_dwWin32Err = LdapMapErrorToWin32 (e)) != NO_ERROR) {                  \
            PrintMessage(SEV_ALWAYS,                                                \
                         L"[%s,%s] An LDAP operation failed with error %d, %s.\n",  \
                         REPLICATIONS_CHECK_STRING,                                 \
                         pDsInfo->pServers[ulCurrTargetServer].pszName,             \
                         _dwWin32Err,                                               \
                         Win32ErrToString(_dwWin32Err));                   \
            PrintMessage(SEV_ALWAYS,                                                \
                         L"%s.\n",  \
                         Win32ErrToString(_dwWin32Err));                   \
            return _dwWin32Err;                                                     \
        }                                                                           \
    }

    LPWSTR  ppszServerSearch [] = {
				L"hasMasterNCs",
				L"hasPartialReplicaNCs",
				L"options",
				NULL };
    LPWSTR  ppszNCSearch [] = {
				L"repsFrom",
				L"repsTo",
				NULL };
    LPWSTR  ppszDsServiceName [] = {
                L"dsServiceName",
				NULL };

    LDAP *			hld = NULL;
    HANDLE                      hDS = NULL;
    LDAPMessage *		pldmEntry;

    LDAPMessage *		pldmRootResults = NULL;
    LPWSTR *			ppszServiceName = NULL;

    LDAPMessage *		pldmServerResults = NULL;
    LPWSTR *			ppszOptions = NULL;
    LPWSTR *			ppszMasterNCs = NULL;
    LPWSTR *			ppszPartialReplicaNCs = NULL;
    //    LPWSTR *			ppszNCs = NULL;

    LDAPMessage *		pldmNCResults = NULL;
    struct berval **		ppbvRepsFrom = NULL;
    struct berval **		ppbvRepsTo = NULL;
    DS_REPL_NEIGHBORSW *        pNeighbors = NULL;
    DS_REPL_NEIGHBORW *         pNeighbor = NULL;
    DS_REPL_PENDING_OPSW *      pPendingOps = NULL;
    

    DWORD			dwWin32Err;
    BOOL			bSkip;
    ULONG			ulServer;
    ULONG			ulRepFrom;

    INT             iNCType;
    INT                         ret = 0;
 
 
    // Check all connections in all NCs on all servers to see when the last
    // replication was and whether or not it was successful.
    // Also make sure LDAP is responding on all machines.

    if(!DcDiagHasNC(pDsInfo->pszNC, &(pDsInfo->pServers[ulCurrTargetServer]), TRUE, TRUE)){
        // Skipping this server, because it doesn't contain the NC.
        IF_DEBUG( PrintMessage(SEV_VERBOSE, L"ReplicationsCheck: Skipping %s, because it doesn't hold NC %s\n",
                                     pDsInfo->pServers[ulCurrTargetServer].pszName,
                                     pDsInfo->pszNC) );
        return ERROR_SUCCESS;
    }

    PrintMessage(SEV_VERBOSE, L"* Replications Check\n");
    
    __try {

        if((dwWin32Err = DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                              gpCreds,
                                              FALSE,
                                              &hld)) != NO_ERROR){
    	    return dwWin32Err;
        }
    
    	DsRRCMChkLdap (pDsInfo->pServers[ulCurrTargetServer].pszName, ldap_search_sW (
    				      hld,
    				      NULL,
    				      LDAP_SCOPE_BASE,
    				      L"(objectCategory=*)",
    				      ppszDsServiceName,
    				      0,
    				      &pldmRootResults));
    
    	pldmEntry = ldap_first_entry (hld, pldmRootResults);
    	ppszServiceName = ldap_get_valuesW (hld, pldmEntry, L"dsServiceName");
    
    	DsRRCMChkLdap (pDsInfo->pServers[ulCurrTargetServer].pszName, ldap_search_sW (
    				      hld,
    				      ppszServiceName[0],
    				      LDAP_SCOPE_BASE,
    				      L"(objectCategory=*)",
    				      ppszServerSearch,
    				      0,
    				      &pldmServerResults));
    
    	pldmEntry = ldap_first_entry (hld, pldmServerResults);
    	// Grab a fresh copy of the options to make sure they reflect
    	// what this server actually believes.
    	ppszOptions = ldap_get_valuesW (hld, pldmEntry, L"options");
    	if (ppszOptions == NULL) pDsInfo->pServers[ulCurrTargetServer].iOptions = 0;
    	else pDsInfo->pServers[ulCurrTargetServer].iOptions = atoi ((LPSTR) ppszOptions[0]);
    
    	// Check if this server is disabling replications.
    	bSkip = FALSE;
    	if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_INBOUND_REPL) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Inbound replication is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_INBOUND_REPL\"\n",
    				     pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    bSkip = TRUE;
    	}
    	if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_OUTBOUND_REPL) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Outbound replication is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_OUTBOUND_REPL\"\n",
    				     pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    bSkip = TRUE;
    	}
    	if (pDsInfo->pServers[ulCurrTargetServer].iOptions & NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] Connection object translation is disabled.\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    PrintMessage(SEV_ALWAYS,
                         L"To correct, run \"repadmin /options %s -DISABLE_NTDSCONN_XLATE\"\n",
    				     pDsInfo->pServers[ulCurrTargetServer].pszName);
    	    bSkip = TRUE;
    	}
    	if (bSkip) return ERROR_DS_NOT_SUPPORTED;
    
        ret = DcDiagGetDsBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                 gpCreds,
                                 &hDS);
    	if (ERROR_SUCCESS != ret) {
    	    return ret;
    	}
    	ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_NEIGHBORS, pDsInfo->pszNC, NULL, &pNeighbors);
    	if (ERROR_SUCCESS != ret) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] DsReplicaGetInfo(NEIGHBORS) failed with error %d,\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                         ret);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(ret));
    	    return ret;
    	}
    
	// Walk through all the repsFrom neighbors ... then done.
    	for (ulRepFrom = 0; ulRepFrom < pNeighbors->cNumNeighbors; ulRepFrom++) {
    	    ReplicationsCheckRep (pDsInfo,
                                  gpCreds,
                                  ulCurrTargetServer,
                                  pNeighbors->rgNeighbor[ulRepFrom].pszNamingContext,
                                  &pNeighbors->rgNeighbor[ulRepFrom]);
    	} // Move on to the next NC	

        // Check the replication queue on this guy as well
        ret = DsReplicaGetInfoW(hDS, DS_REPL_INFO_PENDING_OPS, NULL, NULL,
                                &pPendingOps);
    	if (ERROR_SUCCESS != ret) {
            PrintMessage(SEV_ALWAYS,
                         L"[%s,%s] DsReplicaGetInfoW(PENDING_OPS) failed with error %d,\n",
                         REPLICATIONS_CHECK_STRING,
                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                         ret);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(ret));
    	    return ret;
    	}

        ReplicationsCheckQueue( pDsInfo,
                                ulCurrTargetServer,
                                pPendingOps );

	//check the replication times for outstanding latencies on all nc's
	//do this for all nc's inside the following function
	ret = ReplicationsCheckLatency( hDS, pDsInfo,    
				  ulCurrTargetServer ); 
	if (ERROR_SUCCESS != ret) {
	    return ret;
	}
	
	
    } __finally {

        if (ppbvRepsTo != NULL)             ldap_value_free_len (ppbvRepsTo);
        if (ppbvRepsFrom != NULL)           ldap_value_free_len (ppbvRepsFrom);
        if (pldmNCResults != NULL)          ldap_msgfree (pldmNCResults);
        if (ppszPartialReplicaNCs != NULL)  ldap_value_freeW (ppszPartialReplicaNCs);
        if (ppszMasterNCs != NULL)          ldap_value_freeW (ppszMasterNCs);
        if (ppszOptions != NULL)            ldap_value_freeW (ppszOptions);
        if (pldmServerResults != NULL)      ldap_msgfree (pldmServerResults);
        if (ppszServiceName != NULL)        ldap_value_freeW (ppszServiceName);
        if (pldmRootResults != NULL)        ldap_msgfree (pldmRootResults);
        if (pNeighbors != NULL)             DsReplicaFreeInfo(DS_REPL_INFO_NEIGHBORS, pNeighbors);
        if (pPendingOps != NULL)            DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
	

    } // end exception handler
    return NO_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\topology.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    topology.c

ABSTRACT:

    Contains tests related to the replication topology.

DETAILS:

CREATED:

    09 Jul 98	Aaron Siegel (t-asiege)

REVISION HISTORY:

    15 Feb 1999 Brett Shirley (brettsh)
    08 Sep 1999 Completely re-written to use tool framework services

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include "dcdiag.h"
#include "repl.h"


void
printUnreachableServers(
    IN PDC_DIAG_DSINFO pDsInfo,
    PDS_REPSYNCALL_ERRINFOW *apErrInfo
    )

/*++

Routine Description:

Helper routine to print the unreachable servers

Arguments:

    pDsInfo - 
    apErrInfo - 

Return Value:

    None

--*/

{
    DWORD i, dwServer;
    LPWSTR pszName, pszSite;

    PrintIndentAdj(1);
    for (i = 0; apErrInfo[i] != NULL; i++){
        dwServer = DcDiagGetServerNum(
            pDsInfo, NULL, NULL, apErrInfo[i]->pszSvrId, NULL, NULL );
        if (dwServer == NO_SERVER) {
            pszSite = L"unknown";
            pszName = apErrInfo[i]->pszSvrId;
        } else {
            pszSite = pDsInfo->pSites[pDsInfo->pServers[dwServer].iSite].pszName;
            pszName = pDsInfo->pServers[dwServer].pszName;
        }
        switch (apErrInfo[i]->error) {
        case DS_REPSYNCALL_SERVER_UNREACHABLE:
            PrintMessage(SEV_ALWAYS, L"%s/%s\n", pszSite, pszName );
            break;
        }
    }
    PrintIndentAdj( -1 );
} /* printUnreachableServers */


BOOL
errorIndicatesDisconnected(
    PDS_REPSYNCALL_ERRINFOW *apErrInfo
    )

/*++

Routine Description:

Helper routine to determine if there are any unreachable server errors
in the error array

Arguments:

    apErrInfo - 

Return Value:

    BOOL - 

--*/

{
    DWORD i;
    BOOL bDisconnected = FALSE;

    // Are any nodes unreachable?
    if (apErrInfo) {
        for( i = 0; apErrInfo[i] != NULL; i++ ) {
            if (apErrInfo[i]->error == DS_REPSYNCALL_SERVER_UNREACHABLE) {
                bDisconnected = TRUE;
                break;
            }
        }
    }
    return bDisconnected;
} /* errorIndicatesDisconnected */


DWORD
checkTopologyOneNc(
    IN PDC_DIAG_DSINFO pDsInfo,
    IN HANDLE hDS,
    IN PDC_DIAG_SERVERINFO pTargetServer,
    IN BOOL fAlivenessCheck,
    IN LPWSTR pszNc
    )

/*++

Routine Description:

Check the topology of one naming context.  The DsReplicaSyncAll api is used
to check for unreachable servers.

There are two modes to this check, depending on whether aliveness should
be considered when calculating servers that cannot be reached by the
replication topology.

Without the aliveness check, this test becomes purely a question of whether
the KCC build a connected set of connections, regardless of the current
state of the systems.

Arguments:

    pDsInfo - Global tool data
    hDS - Handle to current server
    pTargetServer - Current server info structure
    fCheckAliveness - Whether aliveness should be taken into account
    pszNc - NC being checked

Return Value:

    DWORD - 

--*/

{
    DWORD status, dwFlags, worst = ERROR_SUCCESS;
    PDS_REPSYNCALL_ERRINFOW *apErrInfo = NULL;

    // Standard flags for all cases
    dwFlags =
        DS_REPSYNCALL_ID_SERVERS_BY_DN;

    // Search intersite if requested
    if (gMainInfo.ulFlags & DC_DIAG_TEST_SCOPE_ENTERPRISE) {
        dwFlags |=
            DS_REPSYNCALL_CROSS_SITE_BOUNDARIES;
    }

    if (fAlivenessCheck) {
        PrintMessage(SEV_VERBOSE,
                     L"* Analyzing the alive system replication topology for %s.\n",
                     pszNc);
    } else {
        PrintMessage(SEV_VERBOSE, L"* Analyzing the connection topology for %s.\n",
                     pszNc);
        dwFlags |= DS_REPSYNCALL_SKIP_INITIAL_CHECK;
    }

//
// Upstream analysis: Whose changes can't I receive?
//

    PrintMessage(SEV_VERBOSE, L"* Performing upstream (of target) analysis.\n" );
    status = DsReplicaSyncAllW (
        hDS,
        pszNc,
        dwFlags,
        NULL,		// No callback function
        NULL,		// No parameter to callback function
        &apErrInfo
        );
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"DsReplicaSyncAllW failed with error %ws.\n",
                      Win32ErrToString(status) );
    }

    if (errorIndicatesDisconnected( apErrInfo )) {
        PrintMessage(SEV_ALWAYS,
                     L"Upstream topology is disconnected for %ws.\n",
                     pszNc);
        PrintMessage(SEV_ALWAYS,
                     L"Home server %ws can't get changes from these servers:\n",
                     pTargetServer->pszName );
        printUnreachableServers( pDsInfo, apErrInfo );
        worst = ERROR_DS_GENERIC_ERROR;
    } // if disconneced

    if (apErrInfo != NULL) {
        LocalFree (apErrInfo);
        apErrInfo = NULL;
    }

    //
    // Downstream analysis: who can't receive my changes?
    //

    dwFlags |= DS_REPSYNCALL_PUSH_CHANGES_OUTWARD;

    PrintMessage(SEV_VERBOSE, L"* Performing downstream (of target) analysis.\n" );

    status = DsReplicaSyncAllW (
        hDS,
        pszNc,
        dwFlags,
        NULL,		// No callback function
        NULL,		// No parameter to callback function
        &apErrInfo
        );
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"DsReplicaSyncAllW failed with error %ws.\n",
                      Win32ErrToString(status) );
    }

    if (errorIndicatesDisconnected( apErrInfo )) {
        PrintMessage(SEV_ALWAYS,
                     L"Downstream topology is disconnected for %ws.\n",
                     pszNc);
        PrintMessage(SEV_ALWAYS,
                     L"These servers can't get changes from home server %ws:\n",
                     pTargetServer->pszName );
        printUnreachableServers( pDsInfo, apErrInfo );
        worst = ERROR_DS_GENERIC_ERROR;
    } // if disconneced

// cleanup      
    if (apErrInfo != NULL) {
        LocalFree (apErrInfo);
        apErrInfo = NULL;
    }

    return worst;
} /* checkTopologyOneNc */


DWORD
checkTopologyHelp(
    IN PDC_DIAG_DSINFO             pDsInfo,
    IN PDC_DIAG_SERVERINFO pTargetServer,
    IN SEC_WINNT_AUTH_IDENTITY_W * pCreds,
    IN BOOL fAlivenessCheck
    )

/*++

Routine Description:

Helper routine with common code for both tests: the pure topology test, and the
cutoff server test.

Arguments:

    pDsInfo - common tool state
    pTargetServer - server information for target server
    pCreds - credentials
    fAlivenessCheck - Whether aliveness should be taken into account

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    HANDLE hDS = NULL;

    // Bind to the source server if it is up
    status = DcDiagGetDsBinding(pTargetServer,
                                pCreds,
                                &hDS);
    if (ERROR_SUCCESS != status) {
        PrintMessage( SEV_ALWAYS,
                      L"Failed to bind to %ws: %ws.\n",
                      pTargetServer->pszName,
                      Win32ErrToString(status) );
        return status;
    }

    if (pDsInfo->pszNC) {
        // Explicit NC specified: use it
        worst = checkTopologyOneNc( pDsInfo,
                                    hDS,
                                    pTargetServer,
                                    fAlivenessCheck,
                                    pDsInfo->pszNC );
    } else {
        // No NC specified, check all of them

        // Check writable connection topology
        if(pTargetServer->ppszMasterNCs){
            for(i = 0; pTargetServer->ppszMasterNCs[i] != NULL; i++){
                status = checkTopologyOneNc( pDsInfo,
                                             hDS,
                                             pTargetServer,
                                             fAlivenessCheck,
                                             pTargetServer->ppszMasterNCs[i]);
                if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
                    worst = status;
                }
            }
        }

        // Check partial connection topology
        if(pTargetServer->ppszPartialNCs){
            for(i = 0; pTargetServer->ppszPartialNCs[i] != NULL; i++){
                status = checkTopologyOneNc( pDsInfo,
                                             hDS,
                                             pTargetServer,
                                             fAlivenessCheck,
                                             pTargetServer->ppszPartialNCs[i]);
                if ( (status != ERROR_SUCCESS) && (worst == ERROR_SUCCESS) ) {
                    worst = status;
                }
            }
        }
    }

    return worst;
} /* checkTopologyHelp */


DWORD
ReplToplIntegrityMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

Top level routine for "topology integrity" test.

This test verifies whether the topology is connected if we assume all
systems are up.  It is a KCC verification.

Arguments:

    pDsInfo - Common state
    ulCurrTargetServer - index of target
    pCreds - Credentials

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    PrintMessage(SEV_VERBOSE, L"* Configuration Topology Integrity Check\n");

    // Is inter/intrasite topology generation off?
    if(pDsInfo->pSites[pTargetServer->iSite].iSiteOptions
       & NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] Intra-site topology generation is disabled in this site.\n",
                     TOPOLOGY_INTEGRITY_CHECK_STRING,
                     pTargetServer->pszName);
    }
    if(pDsInfo->pSites[pTargetServer->iSite].iSiteOptions
       & NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED){
        PrintMessage(SEV_ALWAYS,
                     L"[%s,%s] Inter-site topology generation is disabled in this site.\n",
                     TOPOLOGY_INTEGRITY_CHECK_STRING,
                     pTargetServer->pszName);
    }

    // Check topology

    worst = checkTopologyHelp(
        pDsInfo,
        pTargetServer,
        pCreds,
        FALSE // connectivity check only
        );

    return worst;
} /* ReplToplIntegrityMain */


DWORD
ReplToplCutoffMain(
    IN  PDC_DIAG_DSINFO             pDsInfo,
    IN  ULONG                       ulCurrTargetServer,
    IN  SEC_WINNT_AUTH_IDENTITY_W * pCreds
    )

/*++

Routine Description:

Top-level routine for "Cutoff server topology" test.

This test identifies those servers that cannot receive changes because servers
are down in the topology.

Arguments:

    pDsInfo - 
    ulCurrTargetServer - 
    pCreds - 

Return Value:

    DWORD - 

--*/

{
    DWORD status, i, worst = ERROR_SUCCESS;
    HANDLE hDS = NULL;
    PDC_DIAG_SERVERINFO pTargetServer = &(pDsInfo->pServers[ulCurrTargetServer]);

    PrintMessage(SEV_VERBOSE, L"* Configuration Topology Aliveness Check\n");

    worst = checkTopologyHelp(
        pDsInfo,
        pTargetServer,
        pCreds,
        TRUE // aliveness check
        );

    return worst;
} /* ReplToplCutoffMain */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dcdiag\repl\security.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    security.c

ABSTRACT:

    Contains tests related to replication and whether the appropriate 
    permissions on some security objects are set to allow replication.

DETAILS:

CREATED:

    22 May 1999  Brett Shirley (brettsh)

REVISION HISTORY:
        

--*/

#include <ntdspch.h>
#include <ntdsa.h>
#include <mdglobal.h>
#include <dsutil.h>
#include <ntldap.h>
#include <ntlsa.h>
#include <ntseapi.h>
#include <winnetwk.h>

#include <permit.h>

#include "dcdiag.h"
#include "repl.h"

// Ripped out of ds/src/dsamain/src/mdupdate.c
const GUID RIGHT_DS_REPL_GET_CHANGES = 
            {0x1131f6aa,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_SYNC = 
            {0x1131f6ab,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};
const GUID RIGHT_DS_REPL_MANAGE_TOPOLOGY =
            {0x1131f6ac,0x9c07,0x11d1,0xf7,0x9f,0x00,0xc0,0x4f,0xc2,0xdc,0xd2};

// security.c helper data structure
typedef struct _TARGET_ACCOUNT_STRUCT {
    PSID        pSid;
    GUID        Guid;
    ACCESS_MASK access;
    BOOL        bFound;
    
} TARGET_ACCOUNT_STRUCT;

typedef struct {
    PSID           pSid;
    BOOL           bGetChangesRight;
    BOOL           bSyncRight;
    BOOL           bManageTopoRight;
    ULONG          iAce;
} ACCOUNT_AND_REPLICATION_RIGHTS;

#define NO_SUCH_ACCOUNT             0xFFFFFFFF
#define ACCT_STRING_SZ 80L

#define    ALL_REPL_RIGHTS(x)    ((x)->bGetChangesRight && (x)->bSyncRight && (x)->bManageTopoRight)

// security.c helper functions
VOID
FreeTargetAccounts(
    IN   TARGET_ACCOUNT_STRUCT *             pTargetAccounts,
    IN   ULONG                               ulTargetAccounts
    )
/*++

Routine Description:

    This is the parallel to XXX_GetTargetAccounts().  Goes through and frees 
    all the pSids, and then frees the array.

Arguments:

    pTargetAccounts - Array of TARGET_ACCOUNT_STRUCTs to free.
    ulTargetAccounts - number of structs in array.

--*/
{
    ULONG                                  ulTarget = 0;

    if(pTargetAccounts != NULL){
        for(ulTarget = 0; ulTarget < ulTargetAccounts; ulTarget++){
            if(pTargetAccounts[ulTarget].pSid != NULL){
                FreeSid(pTargetAccounts[ulTarget].pSid);
            }
        }
        LocalFree(pTargetAccounts);
    }
}

VOID
InitLsaString(
    OUT  PLSA_UNICODE_STRING pLsaString,
    IN   LPWSTR              pszString
    )
/*++

Routine Description:

    InitLsaString, is something that takes a normal unicode string null 
    terminated string, and inits a special unicode structured string.  This 
    function is basically reporduced all over the NT source.

Arguments:

    pLsaString - Struct version of unicode strings to be initialized
    pszString - String to use to init pLsaString.

--*/
{
    DWORD dwStringLength;

    if (pszString == NULL) 
    {
        pLsaString->Buffer = NULL;
        pLsaString->Length = 0;
        pLsaString->MaximumLength = 0;
        return;
    }

    dwStringLength = wcslen(pszString);
    pLsaString->Buffer = pszString;
    pLsaString->Length = (USHORT) dwStringLength * sizeof(WCHAR);
    pLsaString->MaximumLength=(USHORT)(dwStringLength+1) * sizeof(WCHAR);
}

// ===========================================================================
//
// CheckNcHeadSecurityDescriptors() function & helpers.
// 
// This test will basically query the DC as to whether the appropriate 
//    accounts have the Network Logon Right.
//
// ===========================================================================
// 

DWORD
CNHSD_GetNextAccountWithReplicationRights( 
    IN      PACL                               Dacl,
    IN OUT  ACCOUNT_AND_REPLICATION_RIGHTS *   pNextAccount
    )
/*++

Routine Description:

    This function searches through the Dacl for the first/next account with
    replication rights, and then returns which replication rights this account
    has.

Arguments:

    Dacl - Is a pointer to a DACL that has the aces you want to search for
        replication rights.
    pNextAccount - A pointer to a struct.  On the way in it either has pSid
        set to NULL (indicating start at the first ace (index = 0)), or pSid
        is not NULL and iAce is set to the value of the last ACE that this 
        function found with replication rights.  If the function returns
        ERROR_SUCCESS then the pSid will point to a sid in the DACL, and 
        the BOOLs for repliction rights will be set on whether this account 
        has one/any/all these repliction rights.

Return Value:

    Windows 32 Error.

--*/
{
    ACE_HEADER *                   pTempAce = NULL;
    ACCESS_ALLOWED_OBJECT_ACE *    pToCurrAce = NULL;
    GUID                           guidGetChangesRight = 
                                            RIGHT_DS_REPL_GET_CHANGES;
    GUID                           guidSyncRight = 
                                            RIGHT_DS_REPL_SYNC;
    GUID                           guidManageTopoRight = 
                                            RIGHT_DS_REPL_MANAGE_TOPOLOGY;

    
    Assert(pNextAccount != NULL);
    Assert(Dacl != NULL);
    
    if(pNextAccount->pSid == NULL){
        pNextAccount->iAce = 0;
    } else {
        pNextAccount->iAce++;
    }

    pNextAccount->bGetChangesRight = FALSE;
    pNextAccount->bSyncRight = FALSE;
    pNextAccount->bManageTopoRight = FALSE;
    
    for(; pNextAccount->iAce < Dacl->AceCount; pNextAccount->iAce++){
        if(GetAce( Dacl, pNextAccount->iAce, &pTempAce)){
            if(pTempAce->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE){ 
                ACCESS_ALLOWED_ACE * pAce = (ACCESS_ALLOWED_ACE *) pTempAce;
                if(pAce->Mask & RIGHT_DS_CONTROL_ACCESS){
                    pNextAccount->pSid = &(pAce->SidStart);
                    pNextAccount->bGetChangesRight = TRUE;
                    pNextAccount->bSyncRight = TRUE;
                    pNextAccount->bManageTopoRight = TRUE;
                    return(ERROR_SUCCESS);  // found an account so return.
                }
            } else {
                //
                ACCESS_ALLOWED_OBJECT_ACE * pAce = (ACCESS_ALLOWED_OBJECT_ACE *) pTempAce;
                if(pAce->Mask & RIGHT_DS_CONTROL_ACCESS){
                    if(pAce->Flags & ACE_OBJECT_TYPE_PRESENT){
                        GUID * pGuid = (GUID *) &(pAce->ObjectType);
                        if(memcmp(pGuid, &guidGetChangesRight, sizeof(GUID)) == 0){
                            if(pAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT){
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID) + sizeof(GUID);
                            } else {
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID);
                            }
                            pNextAccount->bGetChangesRight = TRUE;
                            return(ERROR_SUCCESS);
                        } else if(memcmp(pGuid, &guidSyncRight, sizeof(GUID)) == 0){
                            if(pAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT){
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID) + sizeof(GUID);
                            } else {
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID);
                            }
                            pNextAccount->bSyncRight = TRUE;
                            return(ERROR_SUCCESS);
                        } else if(memcmp(pGuid, &guidManageTopoRight, sizeof(GUID)) == 0){
                            if(pAce->Flags & ACE_INHERITED_OBJECT_TYPE_PRESENT){
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID) + sizeof(GUID);
                            } else {
                                pNextAccount->pSid = ((PBYTE) pGuid) + sizeof(GUID);
                            }
                            pNextAccount->bManageTopoRight = TRUE;
                            return(ERROR_SUCCESS);
                        }
                    }
                }
            }
        } else {
            // Problem getting Ace, Dacl is mal formed, return error.
            return(ERROR_INVALID_PARAMETER);
        }
    }
    pNextAccount->iAce = NO_SUCH_ACCOUNT;
    return(NO_SUCH_ACCOUNT);
}


DWORD
CNHSD_CheckAccountsForReplRights(
    IN      PACL                              Dacl,
    IN OUT  ACCOUNT_AND_REPLICATION_RIGHTS *  pAccountDomControllers,
    OUT     ACCOUNT_AND_REPLICATION_RIGHTS *  pAccountAdministrators
    )
/*++

Routine Description

    This function takes an account prinicipal and Dacl, and then returns what 
    replication rights this account has according to the Dacl.

Arguments:

    Dacl - Is a pointer to a Dacl that you want to check for repliction rights.
    pAccountDomControllers - Contains a ACCOUNT_AND_REPLICATION_RIGHTS struct 
        that has the pSid set to Domain Controllers, and is used to return that
        the dom controllers have all 3 repl rights.
    pAccountAdministrators - Contains a ACCOUNT_AND_REPLICATION_RIGHTS struct
        that has no pSid set, and is used to return what repl rights other 
        (non-domain controllers) have the repl rights, so _someone_ can 
        administer the system.

Return Value:
    
    Win32Err

--*/
{
    ACCOUNT_AND_REPLICATION_RIGHTS  sNextAccount = 
                                        { NULL, FALSE, FALSE, FALSE, 0 };
    DWORD                           dwRet;

    while(((dwRet = CNHSD_GetNextAccountWithReplicationRights(Dacl, &sNextAccount))
           == ERROR_SUCCESS)
          && !(ALL_REPL_RIGHTS(pAccountDomControllers) 
               && ALL_REPL_RIGHTS(pAccountAdministrators))
        ){
        if(IsValidSid(sNextAccount.pSid) 
           && IsValidSid(pAccountDomControllers->pSid)){
            if(EqualSid(pAccountDomControllers->pSid, sNextAccount.pSid)){
                // Domain controllers has repl rights, figure out which ones
                //   and set pAccountDomControllers appropriately
                if(sNextAccount.bGetChangesRight){
                    pAccountDomControllers->bGetChangesRight = TRUE;
                }
                if(sNextAccount.bSyncRight){
                    pAccountDomControllers->bSyncRight = TRUE;
                }
                if(sNextAccount.bManageTopoRight){
                    pAccountDomControllers->bManageTopoRight = TRUE;
                }
            } else {
                // An admin account has repl rights, figure out which ones
                //   and set pAccountAdministrators appropriately
                if(sNextAccount.bGetChangesRight){
                    pAccountAdministrators->bGetChangesRight = TRUE;
                }
                if(sNextAccount.bSyncRight){
                    pAccountAdministrators->bSyncRight = TRUE;
                }
                if(sNextAccount.bManageTopoRight){
                    pAccountAdministrators->bManageTopoRight = TRUE;
                }
            }
        }
    }

    if(dwRet == NO_SUCH_ACCOUNT || dwRet == ERROR_SUCCESS){
        return(ERROR_SUCCESS);
    } else {    
        return(dwRet);
    }
}

DWORD 
CNHSD_CheckOneNc(
    IN   PDC_DIAG_DSINFO                     pDsInfo,
    IN   ULONG                               ulCurrTargetServer,
    IN   SEC_WINNT_AUTH_IDENTITY_W *         gpCreds,
    IN   LPWSTR                              pszNC,
    IN   BOOL                                bIsMasterNc
    )
/*++

Routine Description:

    This helper function of CheckNcHeadSecurityDescriptors takes a single 
    Naming Context (pszNC) to check for the appropriate security access.

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying 
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is beingtested.
    gpCreds - The command line credentials if any that were passed in.
    pszNC - The Naming Context to test.

Return Value:

    NO_ERROR, if the NC checked out OK, with the appropriate rights for the 
    appropriate people a Win32 error of somekind otherwise, indicating that
    someone doesn't have rights.

--*/
{
    LPWSTR  ppszSecurityAttr [2] = {
				L"nTSecurityDescriptor",
				NULL };    
    LDAP *			hld = NULL;
    LDAPMessage *		pldmEntry;
    SECURITY_DESCRIPTOR *       pSecDesc = NULL;
    PLDAP_BERVAL *              pSDValue = NULL; 
    LDAPMessage *		pldmRootResults = NULL;

    DWORD                       dwRet;
    DWORD			dwWin32Err;
    BOOL			bSkip;
    ULONG			ulServer;
    ULONG			ulRepFrom;
    
    HANDLE                      hToken = NULL;
    TOKEN_PRIVILEGES            tp, tpPrevious;
    DWORD                       tpSize;
    DWORD                       dwErr = ERROR_SUCCESS;

    SECURITY_INFORMATION        seInfo =   DACL_SECURITY_INFORMATION
                                         | GROUP_SECURITY_INFORMATION
                                         | OWNER_SECURITY_INFORMATION;
                          // Don't need  | SACL_SECURITY_INFORMATION;
    BYTE                        berValue[2*sizeof(ULONG)];
    LDAPControlW                seInfoControl = { LDAP_SERVER_SD_FLAGS_OID_W,
                                              { 5, (PCHAR) berValue }, 
                                              TRUE };
    PLDAPControlW               serverControls[2] = { &seInfoControl, NULL };
    PACL                        Dacl;
    BOOLEAN                     DaclPresent = FALSE;
    BOOLEAN                     Defaulted;
    TARGET_ACCOUNT_STRUCT *     pTargetAccounts = NULL;
    ULONG                       ulTargetAccounts = 0;
    ULONG                       ulCurr, ulTarget;
    ULONG                       ulAccountSize = ACCT_STRING_SZ;
    ULONG                       ulDomainSize = ACCT_STRING_SZ;
    WCHAR                       pszAccount[ACCT_STRING_SZ];
    WCHAR                       pszDomain[ACCT_STRING_SZ];
    SID_NAME_USE                SidType = SidTypeWellKnownGroup;
    LPWSTR                      pszGuidType = NULL;
    ULONG *                     ulOptions = LDAP_OPT_OFF;
    ACCOUNT_AND_REPLICATION_RIGHTS    sAccountDomControllers 
        = { NULL, FALSE, FALSE, FALSE, 0 };
    ACCOUNT_AND_REPLICATION_RIGHTS    sAccountAdministrators
        = { NULL, FALSE, FALSE, FALSE, 0 };
    PSID                        pSidEnterpriseDomainControllers = NULL;
    SID_IDENTIFIER_AUTHORITY    siaNtAuthority = SECURITY_NT_AUTHORITY;

    PrintMessage(SEV_VERBOSE, L"* Security Permissions Check for\n");
    PrintMessage(SEV_VERBOSE, L"  %s\n", pszNC);

    // initialize the ber val
    berValue[0] = 0x30;
    berValue[1] = 0x03;
    berValue[2] = 0x02;
    berValue[3] = 0x01;
    berValue[4] = (BYTE) (seInfo & 0xF);
 
    __try {
        
        // QUERY & GATHER INFO -----------------------------------------------
        if((dwWin32Err=DcDiagGetLdapBinding(&pDsInfo->pServers[ulCurrTargetServer],
                                            gpCreds, 
                                            !bIsMasterNc, 
                                            &hld)) != NO_ERROR){
            return dwWin32Err;
        }

        if ((dwWin32Err = LdapMapErrorToWin32 (ldap_search_ext_sW (
    				      hld,
    				      pszNC, 
    				      LDAP_SCOPE_BASE,
    				      L"(objectCategory=*)",
    				      ppszSecurityAttr,
    				      0,
                                      (PLDAPControlW *) &serverControls,
                                      NULL,
                                      NULL,
                                      0, // return all entries
    				      &pldmRootResults)))
            != NO_ERROR){
            PrintMessage(SEV_ALWAYS,
                         L"[%s] An LDAP operation failed with error %d\n",
                         pDsInfo->pServers[ulCurrTargetServer].pszName,
                         dwWin32Err);
            PrintMessage(SEV_ALWAYS, L"%s.\n",
                         Win32ErrToString(dwWin32Err));
            return dwWin32Err;                                            
        }

    	pldmEntry = ldap_first_entry (hld, pldmRootResults);
        pSDValue = ldap_get_values_lenW (hld, pldmEntry, 
                                         ppszSecurityAttr[0]);
        
        Assert(pldmEntry != NULL);
        Assert(pSDValue != NULL);
        if(pldmEntry == NULL || pSDValue == NULL){
            PrintMessage(SEV_ALWAYS, 
                      L"Fatal Error: Cannot retrieve Security Descriptor\n"); 
            __leave;
        }

        pSecDesc = (SECURITY_DESCRIPTOR *) (*pSDValue)->bv_val ;
        Assert( pSecDesc != NULL );
        if(pSecDesc == NULL){
            PrintMessage(SEV_ALWAYS, 
                     L"Fatal Error: Cannot retrieve Security Descriptor\n"); 
            __leave;
        }

        dwRet=RtlGetDaclSecurityDescriptor( pSecDesc, 
                                            &DaclPresent, &Dacl, &Defaulted );
        if(dwRet != NO_ERROR){ 
            PrintMessage(SEV_ALWAYS, 
                  L"Fatal Error: Cannot retrieve Security Descriptor Dacl\n"); 
            __leave;
        }

        // setting up domain controllers account.
        if (!AllocateAndInitializeSid(&siaNtAuthority,
                                      1,
                                      SECURITY_ENTERPRISE_CONTROLLERS_RID, 
                                      0, 0, 0, 0, 0, 0, 0,
                                      &pSidEnterpriseDomainControllers)){
            return GetLastError();
        }
        sAccountDomControllers.pSid =  pSidEnterpriseDomainControllers;

        // SEARCH DATA FOR TARGET ACCOUNTS -----------------------------------
        // Checking target accounts versus the Dacl.
        if (Dacl == NULL || Dacl->AclSize == 0) {
            return ERROR_INVALID_DATA;
        }

        // Actually figure out if the Dacl has the desired repl rights.
        dwRet = CNHSD_CheckAccountsForReplRights(Dacl,
                                                 &sAccountDomControllers,
                                                 &sAccountAdministrators);

        // Analyze the results from the previous line and print out any errors.
        if(!ALL_REPL_RIGHTS((&sAccountDomControllers))){
            // Print domain controllers error
            dwRet = LookupAccountSid(NULL,
                                     sAccountDomControllers.pSid,
                                     pszAccount,
                                     &ulAccountSize,
                                     pszDomain,
                                     &ulDomainSize,
                                     &SidType);
            PrintMessage(SEV_ALWAYS, L"Error %s\\%s doesn't have \n",
                         pszDomain, pszAccount);
            PrintIndentAdj(1);
            if(!sAccountDomControllers.bGetChangesRight){
                PrintMessage(SEV_ALWAYS, L"Replicating Directory Changes\n");
            }
            if(!sAccountDomControllers.bSyncRight){
                PrintMessage(SEV_ALWAYS, L"Replication Syncronization\n");
            }
            if(!sAccountDomControllers.bManageTopoRight){
                PrintMessage(SEV_ALWAYS, L"Manage Replication Topology\n");
            }
            PrintIndentAdj(-1);
            PrintMessage(SEV_ALWAYS, 
                         L"access rights for the naming context:\n");
            PrintMessage(SEV_ALWAYS, L"%s\n", pszNC);            
        }

        if(!ALL_REPL_RIGHTS((&sAccountAdministrators))){
            // Print no adminstrator accounts have repl rights
            PrintMessage(SEV_VERBOSE, 
                         L"Warning: no administrator account has\n");
            PrintIndentAdj(1);
            if(!sAccountAdministrators.bGetChangesRight){
                PrintMessage(SEV_VERBOSE, L"Replicating Directory Changes\n");
            }
            if(!sAccountAdministrators.bSyncRight){
                PrintMessage(SEV_VERBOSE, L"Replication Syncronization\n");
            }
            if(!sAccountAdministrators.bManageTopoRight){
                PrintMessage(SEV_VERBOSE, L"Manage Replication Topology\n");
            }
            PrintIndentAdj(-1);
            PrintMessage(SEV_VERBOSE, 
                         L"access rights for the naming context:\n");
            PrintMessage(SEV_VERBOSE, L"%s\n", pszNC);            
        }
        
    } __finally {
	    if (pldmRootResults != NULL)  ldap_msgfree (pldmRootResults);
            if (pSDValue != NULL)         ldap_value_free_len(pSDValue);
    } // end exception handler

    return(dwRet);
}

DWORD
ReplCheckNcHeadSecurityDescriptorsMain (
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will 
    determine if the Security Descriptors associated with all the Naming 
    Context heads for that server have the right accounts with the right 
    access permissions to make sure replication happens.  Helper functions 
    of this function all begin with "CNHSD_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is being tested.
    gpCreds - The command line credentials if any that were passed in.


Return Value:

    NO_ERROR, if all NCs checked out.
    A Win32 Error if any NC failed to check out.

--*/
{
    DWORD                     dwRet = ERROR_SUCCESS, dwErr = ERROR_SUCCESS;
    ULONG                     i;
    BOOL                      bIsMasterNC;

    if(pDsInfo->pszNC != NULL){
        bIsMasterNC = DcDiagHasNC(pDsInfo->pszNC,
                                  &(pDsInfo->pServers[ulCurrTargetServer]), 
                                  TRUE, FALSE);
        dwRet = CNHSD_CheckOneNc(pDsInfo, ulCurrTargetServer, gpCreds, 
                                 pDsInfo->pszNC, 
                                 bIsMasterNC);
        return(dwRet);
    }
        
    // First Check Master NCs
    if(pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs != NULL){
        for(i = 0; pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs[i] != NULL; i++){
            dwRet = CNHSD_CheckOneNc(
                pDsInfo, 
                ulCurrTargetServer, 
                gpCreds, 
                pDsInfo->pServers[ulCurrTargetServer].ppszMasterNCs[i],
                TRUE);
            if(dwRet != ERROR_SUCCESS){
                dwErr = dwRet;
            }
        }
    }

    // Then Check Partial NCs
    if(pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs != NULL){
        for(i = 0; pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs[i] != NULL; i++){
            dwRet = CNHSD_CheckOneNc(
                pDsInfo, 
                ulCurrTargetServer, 
                gpCreds,
                pDsInfo->pServers[ulCurrTargetServer].ppszPartialNCs[i],
                FALSE);
            if(dwRet != ERROR_SUCCESS){
                dwErr = dwRet;
            }
        }
    }

    return dwErr;
}





// ===========================================================================
//
// CheckLogonPriviledges() function & helpers.
// 
// This test will basically query the DC as to whether the appropriate 
//    accounts have the Network Logon Right.
//
// ===========================================================================
// 

DWORD
CLP_GetTargetAccounts(
    TARGET_ACCOUNT_STRUCT **            ppTargetAccounts,
    ULONG *                             pulTargetAccounts
    )
/*++

Routine Description:

    This helper function of CheckLogonPriviledges() gets the accounts and then 
    returns them.

Arguments:

    ppTargetAccounts - ptr to array of TARGET_ACCOUNT_STRUCTS ... filled in 
        by function.  
    pulTargetAccounts - ptr to int for the number of TARGET_ACCOUNT_STRUCTS
        filled in.

Return Value:

    returns a GetLastError() Win32 error if the function failes, NO_ERROR 
    otherwise.

--*/
{
    SID_IDENTIFIER_AUTHORITY        siaNtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY        siaWorldSidAuthority = 
                                              SECURITY_WORLD_SID_AUTHORITY;
    TARGET_ACCOUNT_STRUCT *         pTargetAccounts = NULL;
    ULONG                           ulTarget = 0;
    ULONG                           ulTargetAccounts = 3;

    *pulTargetAccounts = 0;
    *ppTargetAccounts = NULL;

    pTargetAccounts = LocalAlloc(LMEM_FIXED, 
                       sizeof(TARGET_ACCOUNT_STRUCT) * ulTargetAccounts);
    if(pTargetAccounts == NULL){
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(pTargetAccounts, 0, 
           sizeof(TARGET_ACCOUNT_STRUCT) * ulTargetAccounts);
    
    if (!AllocateAndInitializeSid(&siaNtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0, 
                                  &pTargetAccounts[0].pSid)){
        return(GetLastError());
    }
    
    // This I believe is the important one that allows replication
    if (!AllocateAndInitializeSid(&siaNtAuthority, 
                                  1,
                                  SECURITY_AUTHENTICATED_USER_RID,
                                  0, 0, 0, 0, 0, 0, 0, 
                                  &pTargetAccounts[1].pSid)){
        return(GetLastError());
    }
    if (!AllocateAndInitializeSid(&siaWorldSidAuthority,
                                  1,
                                  SECURITY_WORLD_RID, 
                                  0, 0, 0, 0, 0, 0, 0,
                                  &pTargetAccounts[2].pSid)){
        return(GetLastError());
    }

    *pulTargetAccounts = ulTargetAccounts;
    *ppTargetAccounts = pTargetAccounts;
    return(ERROR_SUCCESS);
}

DWORD 
ReplCheckLogonPrivilegesMain (
    PDC_DIAG_DSINFO		        pDsInfo,
    ULONG                               ulCurrTargetServer,
    SEC_WINNT_AUTH_IDENTITY_W *         gpCreds
    )
/*++

Routine Description:

    This is a test called from the dcdiag framework.  This test will determine
    whether certain important user accounts have Net Logon privileges.  If 
    they don't replication may be hampered or stopped.  Helper functions of 
    this function all begin with "CLP_".

Arguments:

    pDsInfo - This is the dcdiag global variable structure identifying 
        everything about the domain
    ulCurrTargetServer - an index into pDsInfo->pServers[X] for which server
        is being tested.
    gpCreds - The command line credentials if any that were passed in.

Return Value:

    NO_ERROR, if all expected accounts had net logon privileges.
    A Win32 Error if any expected account didn't have net logon privileges.

--*/
{
    DWORD                               dwRet = ERROR_SUCCESS; 
    NETRESOURCE                         NetResource;
    LSA_HANDLE                          hPolicyHandle = NULL;
    DWORD                               DesiredAccess = 
                                           POLICY_VIEW_LOCAL_INFORMATION;
    LSA_OBJECT_ATTRIBUTES               ObjectAttributes;
    LSA_UNICODE_STRING                  sLsaServerString;
    LSA_UNICODE_STRING                  sLsaRightsString;
    LSA_ENUMERATION_INFORMATION *       pAccountsWithLogonRight = NULL;
    ULONG                               ulNumAccounts = 0; 
    ULONG                               ulTargetAccounts = 0;
    ULONG                               ulTarget, ulCurr;
    TARGET_ACCOUNT_STRUCT *             pTargetAccounts = NULL;
    LPWSTR                              pszNetUseServer = NULL;
    LPWSTR                              pszNetUseUser = NULL;
    LPWSTR                              pszNetUsePassword = NULL;
    ULONG                               iTemp, i;
    UNICODE_STRING                      TempUnicodeString;
    ULONG                               ulAccountSize = ACCT_STRING_SZ;
    ULONG                               ulDomainSize = ACCT_STRING_SZ;
    WCHAR                               pszAccount[ACCT_STRING_SZ];
    WCHAR                               pszDomain[ACCT_STRING_SZ];
    SID_NAME_USE                        SidType = SidTypeWellKnownGroup;
    BOOL                                bConnected = FALSE;
    DWORD                               dwErr = ERROR_SUCCESS;
    BOOL                                bFound = FALSE;

    __try{

        PrintMessage(SEV_VERBOSE, L"* Network Logons Privileges Check\n");
            
        // INIT ---------------------------------------------------------------
        // Always initialize the object attributes to all zeroes.
        InitializeObjectAttributes(&ObjectAttributes,NULL,0,NULL,NULL);

        // Initialize various strings for the Lsa Services and for 
        //     WNetAddConnection2()
        InitLsaString( &sLsaServerString, 
                       pDsInfo->pServers[ulCurrTargetServer].pszName );
        InitLsaString( &sLsaRightsString, SE_NETWORK_LOGON_NAME );

        if(gpCreds != NULL 
           && gpCreds->User != NULL 
           && gpCreds->Password != NULL 
           && gpCreds->Domain != NULL){ 
            // only need 2 for NULL, and an extra just in case. 
            iTemp = wcslen(gpCreds->Domain) + wcslen(gpCreds->User) + 4;
            pszNetUseUser = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
            if(pszNetUseUser == NULL){
                dwRet = ERROR_NOT_ENOUGH_MEMORY;
                __leave;
            }
            wcscpy(pszNetUseUser, gpCreds->Domain);
            wcscat(pszNetUseUser, L"\\");
            wcscat(pszNetUseUser, gpCreds->User);
            pszNetUsePassword = gpCreds->Password;
        } // end if creds, else assume default creds ... 
        //      pszNetUseUser = NULL; pszNetUsePassword = NULL;

        // "\\\\" + "\\ipc$"
        iTemp = wcslen(pDsInfo->pServers[ulCurrTargetServer].pszName) + 10; 
        pszNetUseServer = LocalAlloc(LMEM_FIXED, iTemp * sizeof(WCHAR));
        if(pszNetUseServer == NULL){
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        }
        wcscpy(pszNetUseServer, L"\\\\");
        wcscat(pszNetUseServer, pDsInfo->pServers[ulCurrTargetServer].pszName);
        wcscat(pszNetUseServer, L"\\ipc$");

        // Initialize NetResource structure for WNetAddConnection2()
        NetResource.dwType = RESOURCETYPE_ANY;
        NetResource.lpLocalName = NULL;
        NetResource.lpRemoteName = pszNetUseServer;
        NetResource.lpProvider = NULL;


        // CONNECT & QUERY ---------------------------------------------------
        //net use \\brettsh-posh\ipc$ /u:brettsh-fsmo\administrator ""
        dwRet = WNetAddConnection2(&NetResource, // connection details
                                   pszNetUsePassword, // points to password
                                   pszNetUseUser, // points to user name string
                                   0); // set of bit flags that specify 
        if(dwRet != NO_ERROR){
            if(dwRet == ERROR_SESSION_CREDENTIAL_CONFLICT){
                PrintMessage(SEV_ALWAYS, 
                   L"* You must make sure there are no existing net use connections,\n");
                PrintMessage(SEV_ALWAYS, 
                        L"  you can use \"net use /d %s\" or \"net use /d\n", 
                             pszNetUseServer);
                PrintMessage(SEV_ALWAYS, 
                             L"  \\\\<machine-name>\\<share-name>\"\n");
            }
            __leave;
        } else bConnected = TRUE;


        // Attempt to open the policy.
        dwRet = LsaOpenPolicy(&sLsaServerString,
                              &ObjectAttributes,
                              DesiredAccess,
                              &hPolicyHandle); 
        if(dwRet != NO_ERROR) __leave;
        Assert(hPolicyHandle != NULL);

        dwRet = LsaEnumerateAccountsWithUserRight( hPolicyHandle,
                                                   &sLsaRightsString,
                                                   &pAccountsWithLogonRight,
                                                   &ulNumAccounts);
        if(dwRet != NO_ERROR) __leave;
        Assert(pAccountsWithLogonRight != NULL);

        dwRet = CLP_GetTargetAccounts(&pTargetAccounts, &ulTargetAccounts);
        if(dwRet != ERROR_SUCCESS) __leave;
     
        // CHECKING FOR LOGON RIGHTS -----------------------------------------
        for(ulTarget = 0; ulTarget < ulTargetAccounts; ulTarget++){

            for(ulCurr = 0; ulCurr < ulNumAccounts && !pTargetAccounts[ulTarget].bFound; ulCurr++){
                if( IsValidSid(pTargetAccounts[ulTarget].pSid) &&
                    IsValidSid(pAccountsWithLogonRight[ulCurr].Sid) &&
                    EqualSid(pTargetAccounts[ulTarget].pSid, 
                             pAccountsWithLogonRight[ulCurr].Sid) ){
                    // Sids are equal
                    bFound = TRUE;
                    break;
                }
            }
        }
        if(!bFound){
            dwRet = LookupAccountSid(NULL,
                                     pTargetAccounts[0].pSid,
                                     pszAccount,
                                     &ulAccountSize,
                                     pszDomain,
                                     &ulDomainSize,
                                     &SidType);
            PrintMessage(SEV_NORMAL, 
                L"* Warning %s\\%s did not have the \"Access this computer\n",
                         pszDomain, pszAccount);
            PrintMessage(SEV_NORMAL, L"*   from network\" right.\n");
            dwErr = ERROR_INVALID_ACCESS;
        }
        

    } __finally {
        // CLEAN UP ----------------------------------------------------------
        if(hPolicyHandle != NULL)           LsaClose(hPolicyHandle);
        if(bConnected)                      WNetCancelConnection2(pszNetUseServer, 0, FALSE);
        if (pszNetUseServer != NULL)        LocalFree(pszNetUseServer);
        if(pszNetUseUser != NULL)           LocalFree(pszNetUseUser);
        if(pAccountsWithLogonRight != NULL) LsaFreeMemory(pAccountsWithLogonRight);
        FreeTargetAccounts(pTargetAccounts, ulTargetAccounts);

    }

    // ERROR HANDLING --------------------------------------------------------

    switch(dwRet){
    case ERROR_SUCCESS:
    case ERROR_SESSION_CREDENTIAL_CONFLICT: 
        // Took care of it earlier, no need to print out.
        break;
    case ERROR_NOT_ENOUGH_MEMORY:
        PrintMessage(SEV_ALWAYS, 
                 L"Fatal Error: Not enough memory to complete operation.\n");
        break;
    case ERROR_ALREADY_ASSIGNED:
        PrintMessage(SEV_ALWAYS, 
                     L"Fatal Error: The network resource is already in use\n");
        break;
    case STATUS_ACCESS_DENIED:
    case ERROR_INVALID_PASSWORD:
    case ERROR_LOGON_FAILURE:
        // This comes from the LsaOpenPolicy or 
        //    LsaEnumerateAccountsWithUserRight or 
        //    from WNetAddConnection2
        PrintMessage(SEV_ALWAYS, 
                     L"User credentials does not have permission to perform this operation.\n");
        PrintMessage(SEV_ALWAYS, 
                     L"The account used for this test must have network logon privileges\n");
        PrintMessage(SEV_ALWAYS, 
                     L"for the target machine's domain.\n");
        break;
    case STATUS_NO_MORE_ENTRIES:
        // This comes from LsaEnumerateAccountsWithUserRight
    default:
        PrintMessage(SEV_ALWAYS,                                               
                     L"[%s] An net use or LsaPolicy operation failed with error %d, %s.\n", 
                     pDsInfo->pServers[ulCurrTargetServer].pszName,            
                     dwRet,                                              
                     Win32ErrToString(dwRet));
        break;
    }

    if(dwErr == ERROR_SUCCESS)
        return(dwRet);
    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dnsresl\dns.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    dnsresl - DNS Resolution Library

Abstract:

    This is a library to do DNS hostresolution and return a stringized IP using winsock2 functions
    instead of gethostbyname().

Author:

    BrettSh   14-May-1999

Environment:

    any environment, it does need Assert()s though

Revision History:

--*/

#include <ntdspch.h>
#include <winsock2.h>
#include <svcguid.h>
#include <dnsresl.h>

#include <debug.h>
#include <dsexcept.h>

DWORD
GetIpAddrByDnsNameHelper(
    IN     LPWSTR             pszHostName,
    OUT    LPWSTR             pszIP,
    IN OUT INT *              piQueryBufferSize,
    OUT    WSAQUERYSETW *     pQuery)
/*++

Description:

    This is a helper function for GetIpAddrByDnsNameW, solely for the purpose of avoiding code dupication.  This
    function is basically wrapped by the real function which takes care of memory allocations of pQuery.

Arguments:

    pszHostName (IN) - Host Name to resolve.

    pszIP (OUT) - The pszIP string to ... it should be a WCHAR array of at least IPADDRSTR_SIZE size.

    piQueryBufferSize (IN/OUT) - This is the size of the pQuery buffer that was passed in.  If the pQuery
          buffer isn't big enough, then this var will be set to a buffer of the requisite size.

    pQuery (IN) - This is just a empty buffer that is guaranteed to be piQueryBufferSize

Return value:

    dwRet - If there is no error then NO_ERROR will be returned, and pszIP will have a wchar 
    stringized IP in it.  If WSAEFAULT is returned, then piQueryBufferSize will have the needed
    size in it.  All other cases are just various errors winsock, MultiByteToWideChar, or 
    inet_ntoa might cause us to have.

    Note there are actually pQuery->dwNumberOfCsAddrs IP addresses in pQuery->lpcsaBuffer[]:
    I am just using the first one, because I do not know better.  Everything I tested this on
    only returned one IP address though.
    pTemp = (struct sockaddr_in *) pQuery->lpcsaBuffer[i].RemoteAddr.lpSockaddr;

--*/
{
    HANDLE                      handle = NULL;
    GUID                        ServiceClass = SVCID_HOSTNAME;
    DWORD                       dwRet = NO_ERROR;
    CHAR *                      pszTemp;
    struct sockaddr_in *        pTemp;

    // Initialize things.
    pszIP[0] = L'\0'; // Just in case no IP.
    memset(pQuery, 0, *piQueryBufferSize);
    pQuery->lpszServiceInstanceName =  pszHostName;
    pQuery->dwNameSpace = NS_ALL;
    pQuery->dwSize = sizeof(WSAQUERYSETW);
    pQuery->lpServiceClassId = &ServiceClass;

    __try{

        // Begin the name lookup process
        if(WSALookupServiceBeginW(pQuery, LUP_RETURN_ADDR, &handle) == SOCKET_ERROR){
            dwRet = WSAGetLastError();
            Assert(dwRet != WSAEFAULT);
            __leave;
        }

        if(WSALookupServiceNextW(handle, 0, piQueryBufferSize, pQuery) != SOCKET_ERROR){
            // take care of the ip address.
            if(pQuery->dwNumberOfCsAddrs >= 1){

                Assert(pQuery->lpcsaBuffer != NULL);
                pTemp = (struct sockaddr_in *) pQuery->lpcsaBuffer->RemoteAddr.lpSockaddr;
                Assert(pTemp);
                Assert(sizeof(pTemp->sin_addr)==4); // If this fails, then no longer IPv4?
                
                // Code.Improvement could check to make sure the IP address isn't 0.

                pszTemp = inet_ntoa(pTemp->sin_addr);
                if(pszTemp == NULL || '\0' == pszTemp[0]){
                    dwRet = ERROR_INVALID_PARAMETER;
                    __leave;
                }
                if(MultiByteToWideChar(CP_UTF8, 0, pszTemp, -1, pszIP, IPADDRSTR_SIZE) != 0){
                    // SUCCESS  HOORAY.  RAH RAH GO TEAM!
                    dwRet = NO_ERROR;
                    // we could use __leave or just fall out ... wonder which is more efficient?
                } else {
                    dwRet = GetLastError();
                    __leave;
                }
            } else {
                Assert(!"There are no IP addresses returned from a successful WSALookupServiceNextW() call? Why?");
                dwRet = ERROR_DS_DNS_LOOKUP_FAILURE;
                __leave;
            } // if/else has IP address in the returned Query Set

        } else {
            // There was some kind of error on lookup.
            dwRet = WSAGetLastError();
            __leave;
        }

    } __finally {
        if(handle != NULL) {
            if(WSALookupServiceEnd(handle) == SOCKET_ERROR) Assert(!"Badness\n");
        }
    }

    return(dwRet);
} // end GetIpAddrByDnsNameHelper()

DWORD
GetIpAddrByDnsNameW(
    IN   LPWSTR             pszHostName,
    OUT  LPWSTR             pszIP)
/*++

Description:

    Generate a string IP address from the pszHostName

Arguments:

    pszHostName (IN) - Host Name to resolve.

    pszIP (OUT) - The pszIP string to ... it should be a WCHAR array of at least IPADDRSTR_SIZE size.

Return value:

    dwRet - Will be either NO_ERROR or a Windows Sockets 2 error. 10108 is if the host is unresolveable.

Notes:

    This function was created instead of using gethostbyname(), because gethostbyname does not support
    non-ANSI names, as part of a recent (as of 5.17.1999) RFC -- i.e., that gethostbyname() supports 
    only ANSI names, and we need to be able to resolve Unicode names.

--*/
{
    WSAQUERYSETW *              pQuery = NULL;
    BOOL                        bLocalAllocd = FALSE;
    INT                         dwRet = NO_ERROR;
    INT                         iQueryBufferSize = 148; 
                                                 // Found you need at least 116 through experimentation.  
                                                 //  Probably should increase with IPv6.  Added a little
                                                 //  (32 B) extra for extra IP addresses to be returned.
                                                 //  sizeof(WSAQUERYSETW) is about 64 bytes, so that is
                                                 //  an absolute minimum


    // Allocate and clear the WSA Query Set struct
    __try{
        pQuery = (WSAQUERYSETW *) alloca(iQueryBufferSize);
    } __except(EXCEPTION_EXECUTE_HANDLER){
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    if(dwRet == ERROR_NOT_ENOUGH_MEMORY || pQuery == NULL){
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    // Do the lookup
    dwRet = GetIpAddrByDnsNameHelper(pszHostName, pszIP, &iQueryBufferSize, pQuery);
    if(dwRet == WSAEFAULT){
        // Need more memory to do this lookup.
        // Allocate and clear a bigger WSA Query Set struct off the heap
        bLocalAllocd = TRUE;
        pQuery = (WSAQUERYSETW *) LocalAlloc(LMEM_FIXED, iQueryBufferSize); // allocate and init buffer to 0
        if(pQuery == NULL){
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
            
        dwRet = GetIpAddrByDnsNameHelper(pszHostName, pszIP, &iQueryBufferSize, pQuery);
        Assert(dwRet != WSAEFAULT && "This makes no sense, we just inceased the buffer size for the 2nd call.\n");
    } // end if need more memory (dwRet == WSAEFAULT)

    if(bLocalAllocd && pQuery != NULL) LocalFree(pQuery);
    return(dwRet);

} // End of GetIpAddrByDnsNameW()

#define  DEFAULT_HOSTLOOKUP_QUERY_SIZE  300

DWORD 
GetDnsHostNameW(
    IN OUT  VOID **                    ppPrivData,
    IN      LPWSTR                     pszNameToLookup,
    OUT     LPWSTR *                   ppszDnsHostName)
/*++

Routine Description:

    This routine will return the next alias name it finds for a given hostname

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW().
    pszNameToLookup - The name, common, or netbios to lookup.
    ppszDnsHostName (OUT) - returned pointer to the string of the alias name.  This
        string name will need to be copied out before the next call to a GetDnsXXX()
        function, using this handle.

Return Value:

    NO_ERROR if the host lookup is returned.
    A WSA error on an unsuccessful lookup.
        WSASERVICE_NOT_FOUND:  Will be returned if there is not such hostname.
        any other WSA error from WSALookupServiceBegin() or WSALookupServiceNext().

Notes:

    Don't forget 2 things:
    A) Must copy out the string for the DNS host name if you wish to use it later
    B) Must call GetDnsFreeW() to clean up the ppPrivData handle only if this function
        did not return an error.

--*/
{
    PDNSRESL_GET_DNS_PD                pPD = NULL;
    PWSAQUERYSETW                      pQuery = NULL;
    GUID                               ServiceGuid = SVCID_INET_HOSTADDRBYNAME;
    DWORD                              dwRet;

    if(ppPrivData == NULL){
        return(ERROR_INVALID_PARAMETER);
    }
    // Setting up the Private Data structure to keep state between function calls
    pPD = (PDNSRESL_GET_DNS_PD) malloc(sizeof(DNSRESL_GET_DNS_PD));
    if(pPD == NULL){
        *ppPrivData = NULL;
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    *ppPrivData = pPD;
    pPD->iQueryBufferSize = DEFAULT_HOSTLOOKUP_QUERY_SIZE;
    pPD->pQuery = NULL;
    pPD->hWsaLookup = NULL;

    // adding to the Private Data the pQuery (WSAQUERYSET) structure.
    pQuery = (PWSAQUERYSETW) malloc(pPD->iQueryBufferSize);
    if(pQuery == NULL){
        GetDnsFreeW(ppPrivData);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    memset(pQuery, 0, pPD->iQueryBufferSize);
    pPD->pQuery = pQuery;

    // Initializing the pQuery (WSAQUERYSET) structure.
    pQuery->lpszServiceInstanceName = pszNameToLookup;
    pQuery->dwSize = sizeof(WSAQUERYSETW);
    pQuery->dwNameSpace = NS_ALL;
    pQuery->lpServiceClassId = &ServiceGuid;

    // Begin the query.
    if(WSALookupServiceBeginW(pQuery,
                              LUP_RETURN_ALIASES | LUP_RETURN_NAME,
                              &pPD->hWsaLookup ) == SOCKET_ERROR ){
        dwRet = GetLastError();
        Assert(dwRet != WSAEFAULT && "Need to increase the size of DEFAULT_HOSTLOOKUP_QUERY_SIZE");
        GetDnsFreeW(ppPrivData);
        return(dwRet);
    }

 retryWithBiggerBuffer:
    // Do the actual query.
    if(WSALookupServiceNextW(pPD->hWsaLookup, LUP_RETURN_NAME, &(pPD->iQueryBufferSize), pQuery) == NO_ERROR){
        if(ppszDnsHostName != NULL){
            *ppszDnsHostName = pQuery->lpszServiceInstanceName;
        }
        return(NO_ERROR);
    } else {
        dwRet = GetLastError();
        if(dwRet == WSAEFAULT){
            // This means the pQuery buffer was too small, make a bigger buffer and retry.
            pQuery = realloc(pQuery, pPD->iQueryBufferSize);
            pPD->pQuery = pQuery;
            if(pQuery == NULL){
                GetDnsFreeW(ppPrivData);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            goto retryWithBiggerBuffer;
        }
        GetDnsFreeW(ppPrivData);
        return(dwRet);
    }
}

DWORD 
GetDnsAliasNamesW(
    IN OUT  VOID **                    ppPrivData,
    OUT     LPWSTR *                   ppszDnsHostName)
/*++

Routine Description:

    This routine will return the next alias name it finds for a given hostname

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW().
    ppszDnsHostName (OUT) - returned pointer to the string of the alias name.  This
        string name will need to be copied out before the next call to a GetDnsXXX()
        function, using this handle.

Return Value:

    NO_ERROR if the host lookup is returned.
    A WSA error on an unsuccessful lookup.
        WSASERVICE_NOT_FOUND:  Will be returned if there are no aliases.
        WSA_E_NO_MORE:  Will be returned if there is no more aliases.
        any other WSA error from WSALookupServiceNext().

Notes:

    Don't forget 2 things:
    A) Must copy out the string for the DNS alias name if you wish to use it later
    B) Must call GetDnsFreeW() to clean up the ppPrivData handle.

--*/
{
    PDNSRESL_GET_DNS_PD                pPD = NULL;
    PWSAQUERYSETW                      pQuery = NULL;
    DWORD                              dwRet;

    if(ppPrivData == NULL || *ppPrivData == NULL || 
       ((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery == NULL){
        return(ERROR_INVALID_PARAMETER);
    }
    pPD = *ppPrivData;
    pQuery = pPD->pQuery;

 retryWithBiggerBuffer:
    // Query for the next alias.
    if(WSALookupServiceNextW(pPD->hWsaLookup, LUP_RETURN_NAME | LUP_RETURN_ALIASES, 
                             &(pPD->iQueryBufferSize), pQuery ) == NO_ERROR ){
        *ppszDnsHostName = pQuery->lpszServiceInstanceName;
        return(NO_ERROR);
    } else {
        dwRet = GetLastError();
        if(dwRet == WSAEFAULT){
            // This means the pQuery buffer was too small, make a bigger buffer and retry.
            pQuery = realloc(pQuery, pPD->iQueryBufferSize);
            pPD->pQuery = pQuery;
            if(pQuery == NULL){
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
            goto retryWithBiggerBuffer;
        }
        return(dwRet);
    }
    Assert(!"We should not hit here ever");
    return (2);
}

VOID 
GetDnsFreeW(
    IN      VOID **                     ppPrivData)
/*++

Routine Description:

    This routine will clean up the handle passed back by GetDnsHostNameW() or by
    GetDnsAliasNamesW()

Arguments:

    ppPrivData (IN/OUT) - handle returned by GetDnsHostNameW() or by GetDnsAliasNamesW()

Notes:

    The only time this function needs to not be called is if, GetDnsHostNameW() returns
    an error (ie not NO_ERROR).

--*/

{
    if(ppPrivData == NULL || *ppPrivData == NULL){
        return;
    }
    if(((PDNSRESL_GET_DNS_PD)*ppPrivData)->hWsaLookup != NULL){
        WSALookupServiceEnd(((PDNSRESL_GET_DNS_PD)*ppPrivData)->hWsaLookup);
    }
    if(((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery != NULL){
        free(((PDNSRESL_GET_DNS_PD)*ppPrivData)->pQuery);
    }
    free(*ppPrivData);
    *ppPrivData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\atq.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    atq.cxx

Abstract:

    Dump functions for types used by private\security\kerberos\atqnew.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    13-July-99   RRandall     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

extern "C" {

#include "dsexts.h"
}
#include <isatq.hxx>

#define DPRINT4(_x,_a,_b,_c,_d,_e)
#define Assert(_x)  
#undef new
#undef delete


BOOL
Dump_ATQ_CONTEXT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATQCONTEXT dump routine.  

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATQ_ENDPOINT in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    ATQ_CONTEXT     *pAtqContextd, *pAtqCon;

    Printf("%sATQ_CONTEXT:\n", Indent(nIndents));
    nIndents++;

    if (NULL != (pAtqContextd = (ATQ_CONTEXT *)ReadMemory(pvProcess, sizeof(ATQ_CONTEXT)))) {
        pAtqCon = (ATQ_CONTEXT *)pvProcess;

        Printf("%shAsyncIO       = 0x%x\n", Indent(nIndents), pAtqContextd->hAsyncIO);

        Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
        Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContextd->Overlapped.Internal);
        Printf("%sSignature      = %x\n", Indent(nIndents), pAtqContextd->Signature);
        Printf("\n");
        Printf("%sm_acState      = %x\n", Indent(nIndents), pAtqContextd->m_acState);
        Printf("%sm_acFlags      = %x\n", Indent(nIndents), pAtqContextd->m_acFlags);
        Printf("\n");
        Printf("%spEndpoint       @ %p\n", Indent(nIndents), pAtqContextd->pEndpoint);
        Printf("%sContextList     @ %p\n", Indent(nIndents), pAtqContextd->ContextList);
        Printf("%sClientContext   @ %p\n", Indent(nIndents), pAtqContextd->ClientContext);
        Printf("%spfnCompletion   @ %p\n", Indent(nIndents), pAtqContextd->pfnCompletion);
        Printf("\n");
        Printf("%slSyncTimeout   = %x\n", Indent(nIndents), pAtqContextd->lSyncTimeout);
        Printf("%sTimeOut        = %x\n", Indent(nIndents), pAtqContextd->TimeOut);
        Printf("%sNextTimeout    = %x\n", Indent(nIndents), pAtqContextd->NextTimeout);
        Printf("%sTimeOutScanID  = %x\n", Indent(nIndents), pAtqContextd->TimeOutScanID);
        Printf("\n");
        Printf("%sBytesSent      = %x\n", Indent(nIndents), pAtqContextd->BytesSent);
        Printf("%spvBuff          @ %p\n", Indent(nIndents), pAtqContextd->pvBuff);
        Printf("%sm_nIO          = %x\n", Indent(nIndents), pAtqContextd->m_nIO);
        Printf("\n");
        Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContextd->fDatagramContext ? "TRUE" : "FALSE");
        Printf("%sAddressInformation @ %p\n", Indent(nIndents), pAtqContextd->AddressInformation);
        Printf("%sAddressLength  = %x\n", Indent(nIndents), pAtqContextd->AddressLength);
        
        FreeMemory(pAtqContextd);
        fSuccess = TRUE;
    }

    return fSuccess;
}


BOOL
Dump_ATQ_ENDPOINT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATQ_ENDPOINT dump routine.  

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATQ_ENDPOINT in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PATQ_ENDPOINT   pEndpointd;

    Printf("%sATQ_ENDPOINT:\n", Indent(nIndents));
    nIndents++;

    if (NULL != (pEndpointd = (PATQ_ENDPOINT)ReadMemory(pvProcess, sizeof(ATQ_ENDPOINT)))) {

        Printf("%sSignature       = 0x%x\n", Indent(nIndents), pEndpointd->Signature);
        Printf("\n");
        Printf("%sm_refCount      = 0x%x\n", Indent(nIndents), pEndpointd->m_refCount);
        Printf("%sState           = 0x%x\n", Indent(nIndents), pEndpointd->State);
        Printf("\n");
        Printf("%sUseAcceptEx     = %s\n", Indent(nIndents), pEndpointd->UseAcceptEx ? "TRUE" : "FALSE");
        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpointd->fDatagram ? "TRUE" : "FALSE");
        Printf("%sfExclusive      = %s\n", Indent(nIndents), pEndpointd->fExclusive ? "TRUE" : "FALSE");
        Printf("\n");
        Printf("%snSocketsAvail   = 0x%x\n", Indent(nIndents), pEndpointd->nSocketsAvail);
        Printf("%sInitialRecvSize = 0x%x\n", Indent(nIndents), pEndpointd->InitialRecvSize);
        Printf("%sListenSocket        @ %p\n", Indent(nIndents), &pEndpointd->ListenSocket);
        Printf("\n");
        Printf("%sConnectCompletion   @ %p\n", Indent(nIndents), pEndpointd->ConnectCompletion);
        Printf("%sConnectExCompletion @ %p\n", Indent(nIndents), pEndpointd->ConnectExCompletion);
        Printf("%sIoCompletion        @ %p\n", Indent(nIndents), pEndpointd->IoCompletion);
        Printf("\n");
        Printf("%sContext             @ %p\n", Indent(nIndents), pEndpointd->Context);
        Printf("%sShutdownCallback    @ %p\n", Indent(nIndents), pEndpointd->ShutdownCallback);
        Printf("%sShutdownCallbackContext @ %p\n", Indent(nIndents), pEndpointd->ShutdownCallbackContext);
        Printf("%spListenAtqContext   @ %p\n", Indent(nIndents), pEndpointd->pListenAtqContext);
        Printf("\n");
        Printf("%shListenThread   = 0x%x\n", Indent(nIndents), pEndpointd->hListenThread);
        Printf("%sPort            = %d\n", Indent(nIndents), pEndpointd->Port);
        Printf("%sIpAddress       = 0x%x\n", Indent(nIndents), pEndpointd->IpAddress);
        Printf("%sAcceptExTimeout = 0x%x\n", Indent(nIndents), pEndpointd->AcceptExTimeout);
        Printf("%snAcceptExOutstanding = 0x%x\n", Indent(nIndents), pEndpointd->nAcceptExOutstanding);
        Printf("%sfAddingSockets  = %s\n", Indent(nIndents), pEndpointd->fAddingSockets ? "TRUE" : "FALSE");
        Printf("%snAvailDuringTimeOut  = 0x%x\n", Indent(nIndents), pEndpointd->nAvailDuringTimeOut);
        Printf("%sConsumerType    = 0x%x\n", Indent(nIndents), pEndpointd->ConsumerType);

        FreeMemory(pEndpointd);
        fSuccess = TRUE;
    }

    return fSuccess;
}



BOOL
Dump_ATQC_ACTIVE_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Give a pointer to the global list of ATQ_CONTEXT's dumps the active portion of the list.  
    This is made difficult by the fact that there are really multiple lists.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of AtqActiveContextList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                   fSuccess = FALSE;
    DWORD                  i, j = 0;
    PATQ_ENDPOINT          pEndpoint;
    PATQ_CONT              pAtqContext, pAtqCon;
    PATQ_CONTEXT_LISTHEAD  pContListHead;
    PVOID                  pTmp;
    LIST_ENTRY             *pListHead, pListEntry;

    if (NULL != (pContListHead = (PATQ_CONTEXT_LISTHEAD)ReadMemory(pvProcess, (ATQ_NUM_CONTEXT_LIST * sizeof(ATQ_CONTEXT_LISTHEAD))))) {
        for (i = 0; i < ATQ_NUM_CONTEXT_LIST; i++) {
            pListHead = &(pContListHead[i].ActiveListHead); 
            pTmp = pListHead->Flink;
            pListHead = &(((PATQ_CONTEXT_LISTHEAD)pvProcess)[i].PendingAcceptExListHead);
            while (pTmp != pListHead) {
                // Get the address of the ATQ_CONTEXT in the process space.
                pAtqCon = CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout);
                Printf("%sATQ_CONTEXT @ %p\n", Indent(nIndents), pAtqCon);
                nIndents++; j++;

                // Convert to this memory space.
                pAtqContext = (PATQ_CONT)ReadMemory(pAtqCon, sizeof(ATQ_CONTEXT));
                if (pAtqContext && 
                    pAtqContext->pEndpoint && 
                    (pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT)))) {

                    Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContext->fDatagramContext ? "TRUE" : "FALSE");
                    Printf("%sSignature     = 0x%x\n", pAtqContext->Signature);
                    Printf("%shAsyncIO      = %x\n", Indent(nIndents), pAtqContext->hAsyncIO);
                    Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
                    Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContext->Overlapped.Internal);
                    Printf("%spEndpoint     @ %p\n", Indent(nIndents), pAtqContext->pEndpoint);
                    Printf("%spfnCompletion @ %p\n", Indent(nIndents), pAtqContext->pfnCompletion);

                    // Get the some info from the associated ATQ_ENDPOINT so that we have a better
                    // idea what this context is for.
                    pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT));
                    if (pEndpoint) {
                        Printf("%sEndpoint info:\n", Indent(nIndents));
                        nIndents++;
                        Printf("%sPort            = %d\n", Indent(nIndents), pEndpoint->Port);
                        Printf("%sListenSocket    = 0x%x\n", Indent(nIndents), &pEndpoint->ListenSocket);
                        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpoint->fDatagram ? "TRUE" : "FALSE");
                        nIndents--;
                        FreeMemory(pEndpoint);
                        pEndpoint = NULL;
                    } else {
                        Printf("%sEndpoint info NOT AVAILABLE.\n", Indent(nIndents));
                    }

                    nIndents--;                  
                } else {
                    nIndents--;
                    Printf("%sFAILED TO READ ATQ_CONTEXT @ %p\n", Indent(nIndents), CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout));
                    break;
                }
                Printf("\n");
                pTmp = pAtqContext->m_leTimeout.Flink;
                FreeMemory(pAtqContext);
                if (1000 < j) {
                    Printf("%sASSUMING LOOP:Since 1000 ATQ_CONTEXTS were printed, assuming this is a loop and quiting.\n",
                        Indent(nIndents));
                    break;
                }
            }

        }

        FreeMemory(pContListHead);
        fSuccess = TRUE;
    }

    return fSuccess;

}



BOOL
Dump_ATQC_PENDING_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Give a pointer to the global list of ATQ_CONTEXT's dumps the pending AcceptEx portion of the list.  
    This is made difficult by the fact that there are really multiple lists.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of AtqActiveContextList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                   fSuccess = FALSE;
    DWORD                  i, j = 0;
    PATQ_ENDPOINT          pEndpoint;
    PATQ_CONT              pAtqContext, pAtqCon;
    PATQ_CONTEXT_LISTHEAD  pContListHead;
    PVOID                  pTmp;
    LIST_ENTRY             *pListHead, pListEntry;

    if (NULL != (pContListHead = (PATQ_CONTEXT_LISTHEAD)ReadMemory(pvProcess, (ATQ_NUM_CONTEXT_LIST * sizeof(ATQ_CONTEXT_LISTHEAD))))) {
        for (i = 0; i < ATQ_NUM_CONTEXT_LIST; i++) {
            pListHead = &(pContListHead[i].PendingAcceptExListHead); 
            pTmp = pListHead->Flink;
            pListHead = &(((PATQ_CONTEXT_LISTHEAD)pvProcess)[i].PendingAcceptExListHead);
            while (pTmp != pListHead) {
                // Get the address of the ATQ_CONTEXT in the process space.
                pAtqCon = CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout);
                Printf("%sATQ_CONTEXT @ %p\n", Indent(nIndents), pAtqCon);
                nIndents++;
                j++;

                // Convert to this memory space.
                pAtqContext = (PATQ_CONT)ReadMemory(pAtqCon, sizeof(ATQ_CONTEXT));
                if (pAtqContext) {
                    Printf("%sfDatagramContext = %s\n", Indent(nIndents), pAtqContext->fDatagramContext ? "TRUE" : "FALSE");
                    Printf("%sSignature     = 0x%x\n", Indent(nIndents), pAtqContext->Signature);
                    Printf("%shAsyncIO      = %x\n", Indent(nIndents), pAtqContext->hAsyncIO);
                    Printf("%sOverlapped      @ %p\n", Indent(nIndents), &pAtqCon->Overlapped);
                    Printf("%sOverlapped->Internal = 0x%x\n", Indent(nIndents), pAtqContext->Overlapped.Internal);
                    Printf("%spEndpoint     @ %p\n", Indent(nIndents), pAtqContext->pEndpoint);
                    Printf("%spfnCompletion @ %p\n", Indent(nIndents), pAtqContext->pfnCompletion);

                    // Get the some info from the associated ATQ_ENDPOINT so that we have a better
                    // idea what this context is for.
                    if (pAtqContext->pEndpoint && (pEndpoint = (PATQ_ENDPOINT)ReadMemory(pAtqContext->pEndpoint, sizeof(ATQ_ENDPOINT)))) {
                        Printf("%sEndpoint info:\n", Indent(nIndents));
                        nIndents++;
                        Printf("%sPort            = %d\n", Indent(nIndents), pEndpoint->Port);
                        Printf("%sListenSocket    = 0x%x\n", Indent(nIndents), &pEndpoint->ListenSocket);
                        Printf("%sfDatagram       = %s\n", Indent(nIndents), pEndpoint->fDatagram ? "TRUE" : "FALSE");
                        nIndents--;
                        FreeMemory(pEndpoint);
                        pEndpoint = NULL;
                    } else {
                        Printf("%sEndpoint info NOT AVAILABLE.\n", Indent(nIndents));
                    }

                    nIndents--;                  
                } else {
                    nIndents--;
                    Printf("%sFAILED TO READ ATQ_CONTEXT @ %p\n", Indent(nIndents), CONTAINING_RECORD(pTmp, ATQ_CONTEXT, m_leTimeout));
                    break;
                }
                Printf("\n");
                pTmp = pAtqContext->m_leTimeout.Flink;
                FreeMemory(pAtqContext);
                if (1000 < j) {
                    Printf("%sASSUMING LOOP:Since 1000 ATQ_CONTEXTS were printed, assuming this is a loop and quiting.\n",
                        Indent(nIndents));
                    break;
                }
            }

        }

        FreeMemory(pContListHead);
        fSuccess = TRUE;
    }

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\backrest.c ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    backrest.c

ABSTRACT:

    Routines to dump backup/restore structures.

DETAILS:

CREATED:

    99/08/05    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include <ntdsbcli.h>
#include "util.h"
#include "jetbp.h"

BOOL
Dump_JETBACK_SHARED_HEADER(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                    fSuccess = FALSE;
    JETBACK_SHARED_HEADER * pHdr = NULL;
    const DWORD             cchFieldWidth = 24;

    Printf("%sJETBACK_SHARED_HEADER @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pHdr = (JETBACK_SHARED_HEADER *)
                ReadMemory(pvProcess, sizeof(JETBACK_SHARED_HEADER));

    if (NULL != pHdr) {
        fSuccess = TRUE;

        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cbSharedBuffer", pHdr->cbSharedBuffer);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cbPage", pHdr->cbPage);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "dwReadPointer", pHdr->dwReadPointer);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "dwWritePointer", pHdr->dwWritePointer);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "cbReadDataAvailable", pHdr->cbReadDataAvailable);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hrApi", pHdr->hrApi);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fReadBlocked", pHdr->fReadBlocked ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fWriteBlocked", pHdr->fWriteBlocked ? "TRUE" : "FALSE");

        FreeMemory((VOID *) pHdr);
    }

    return fSuccess;
}

BOOL
Dump_JETBACK_SHARED_CONTROL(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    JETBACK_SHARED_CONTROL *  pCtrl = NULL;
    const DWORD               cchFieldWidth = 24;

    Printf("%sJETBACK_SHARED_CONTROL @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtrl = (JETBACK_SHARED_CONTROL *)
                ReadMemory(pvProcess, sizeof(JETBACK_SHARED_CONTROL));

    if (NULL != pCtrl) {
        fSuccess = TRUE;

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hSharedMemoryMapping", pCtrl->hSharedMemoryMapping);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "heventRead", pCtrl->heventRead);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "heventWrite", pCtrl->heventWrite);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hmutexSection", pCtrl->hmutexSection);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "pjshSection", pCtrl->pjshSection);
        
        fSuccess
            = Dump_JETBACK_SHARED_HEADER(
                nIndents+1,
                (VOID *) pCtrl->pjshSection);
        
        FreeMemory(pCtrl);
    }

    return fSuccess;
}

BOOL
Dump_BackupContext(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    BackupContext * pCtx = NULL;
    const DWORD     cchFieldWidth = 24;

    Printf("%sBackupContext @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtx = (BackupContext *)
                ReadMemory(pvProcess, sizeof(BackupContext));

    if (NULL != pCtx) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "hBinding", pCtx->hBinding);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "cxh", pCtx->cxh);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fLoopbacked", pCtx->fLoopbacked ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fUseSockets", pCtx->fUseSockets ? "TRUE" : "FALSE");
        Printf("%s%-*s: @ %p\n",
               Indent(nIndents), cchFieldWidth,
               "rgsockSocketHandles",
               (BYTE *) pvProcess + offsetof(BackupContext, rgsockSocketHandles));
        Printf("%s%-*s: @ %p\n",
               Indent(nIndents), cchFieldWidth,
               "rgprotvalProtocolsUsed",
               (BYTE *) pvProcess + offsetof(BackupContext, rgprotvalProtocolsUsed));
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "cSockets", pCtx->cSockets);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "sock",
               (BYTE *) pvProcess + offsetof(BackupContext, sock));
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hReadThread", pCtx->hReadThread);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "tidThreadId", pCtx->tidThreadId);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hPingThread", pCtx->hPingThread);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "tidThreadIdPing", pCtx->tidThreadIdPing);
        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "hrApiStatus", pCtx->hrApiStatus);

        FreeMemory(pCtx);
    }

    return fSuccess;
}

BOOL
Dump_JETBACK_SERVER_CONTEXT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    JETBACK_SERVER_CONTEXT *  pCtx = NULL;
    const DWORD               cchFieldWidth = 34;

    Printf("%sJETBACK_SERVER_CONTEXT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCtx = (JETBACK_SERVER_CONTEXT *)
                ReadMemory(pvProcess, sizeof(JETBACK_SERVER_CONTEXT));

    if (NULL != pCtx) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fRestoreOperation", pCtx->fRestoreOperation ? "TRUE" : "FALSE");
        if (pCtx->fRestoreOperation) {
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.fJetCompleted",
                   pCtx->u.Restore.fJetCompleted ? "TRUE" : "FALSE");
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.cUnitDone",
                   pCtx->u.Restore.cUnitDone);
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "u.Restore.cUnitTotal",
                   pCtx->u.Restore.cUnitTotal);
        }
        else {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.hFile", pCtx->u.Backup.hFile);
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fHandleIsValid",
                   pCtx->u.Backup.fHandleIsValid ? "TRUE" : "FALSE");
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.cbReadHint", pCtx->u.Backup.cbReadHint);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.sockClient",
                   (BYTE *) pvProcess
                        + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.sockClient));
            Printf("%s%-*s: %I64u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.liFileSize", pCtx->u.Backup.liFileSize);
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwHighestLogNumber", pCtx->u.Backup.dwHighestLogNumber);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.wszBackupAnnotation", pCtx->u.Backup.wszBackupAnnotation);
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwFileSystemGranularity", pCtx->u.Backup.dwFileSystemGranularity);
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fUseSockets",
                   pCtx->u.Backup.fUseSockets ? "TRUE" : "FALSE");
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fUseSharedMemory",
                   pCtx->u.Backup.fUseSharedMemory ? "TRUE" : "FALSE");
            Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.fBackupIsRegistered", pCtx->u.Backup.fBackupIsRegistered ? "TRUE" : "FALSE");
            Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.dwClientIdentifier", pCtx->u.Backup.dwClientIdentifier);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "u.Backup.jsc",
                   (BYTE *) pvProcess + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.jsc));

            fSuccess
                = Dump_JETBACK_SHARED_CONTROL(
                    nIndents+1,
                    (BYTE *) pvProcess + offsetof(JETBACK_SERVER_CONTEXT, u.Backup.jsc));
        }

        FreeMemory(pCtx);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\dra.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dra.c

ABSTRACT:

    Routines to dump replication structures.

DETAILS:

CREATED:

    97/11/24    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include "ntdsa.h"
#include "drs.h"
#include "dsexts.h"
#include "objids.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "draasync.h"
#include <debug.h>
#include "dsatools.h"
#include "dsutil.h"
#include "mdlocal.h"
#include "drautil.h"
#include "drsuapi.h"

struct {
    USHORT  usOp;
    LPSTR   pszOp;
} gAsyncOpCode[] =  {
                        { AO_OP_REP_ADD,    "REP_ADD"    },
                        { AO_OP_REP_DEL,    "REP_DEL"    },
                        { AO_OP_REP_MOD,    "REP_MOD"    },
                        { AO_OP_REP_SYNC,   "REP_SYNC"   },
                        { AO_OP_UPD_REFS,   "UPD_REFS"   }
                    };
#define gcNumAsyncOpCodes (sizeof(gAsyncOpCode)/sizeof(gAsyncOpCode[0]))


LPSTR
DraUuidToStr(
    IN  UUID *  puuid,
    OUT LPSTR   pszUuid     OPTIONAL
    )
/*++

Routine Description:

    Stringize a UUID.

Arguments:

    puuid (IN) - UUID to stringize.
    pszUuid (OUT, OPTIONAL) - Buffer to hold stringized UUID.  If NULL, uses
        static internal buffer.

Return Values:

--*/
{
    LPSTR pszUuidBuffer;
    static CHAR szUuid[1 + 2*sizeof(GUID)];

    if (NULL == pszUuid) {
        pszUuid = szUuid;
    }

    pszUuidBuffer = DsUuidToStructuredString(puuid, pszUuid);
    if (pszUuidBuffer == NULL) {
        strcpy(pszUuid, "bad uuid format");
    }

    return pszUuid;
}


LPSTR
UsnVecToStr(
    IN  USN_VECTOR *    pusnvec,
    OUT LPSTR           pszUsnVec   OPTIONAL
    )
/*++

Routine Description:

    Stringize a USN_VECTOR.

Arguments:

    pusnvec (IN) - USN_VECTOR to stringize.
    pszUsnVec (OUT, OPTIONAL) - Buffer to hold stringized USN_VECTOR.  If NULL,
        uses static internal buffer.

Return Values:

--*/
{
    static CHAR szUsnVec[128];

    if (NULL == pszUsnVec) {
        pszUsnVec = szUsnVec;
    }

    sprintf(pszUsnVec, "%I64d/Obj, %I64d/Prop",
            pusnvec->usnHighObjUpdate, pusnvec->usnHighPropUpdate);

    return pszUsnVec;
}



LPSTR
DrsExtendedOpToStr(
    IN  ULONG   ulExtendedOp,
    OUT LPSTR   pszExtendedOp
    )
{
    static CHAR szExtendedOp[80];

    if (NULL == pszExtendedOp) {
        pszExtendedOp = szExtendedOp;
    }

    switch ( ulExtendedOp ) {
    case 0:
        strcpy(pszExtendedOp, "none");
        break;
    case FSMO_REQ_ROLE:
        strcpy(pszExtendedOp, "FSMO_REQ_ROLE");
        break;
    case FSMO_REQ_RID_ALLOC:
        strcpy(pszExtendedOp, "FSMO_REQ_RID_ALLOC");
        break;
    case FSMO_RID_REQ_ROLE:
        strcpy(pszExtendedOp, "FSMO_RID_REQ_ROLE");
        break;
    case FSMO_REQ_PDC:
        strcpy(pszExtendedOp, "FSMO_REQ_PDC");
        break;
    case FSMO_ABANDON_ROLE:
        strcpy(pszExtendedOp, "FSMO_ABANDON_ROLE");
        break;
    default:
        // Bad parameter or dsexts out of date.
        sprintf(pszExtendedOp, "0x%x", ulExtendedOp);
        break;
    }

    return pszExtendedOp;
}


LPSTR
DrsExtendedRetToStr(
    IN  ULONG   ulExtendedRet,
    OUT LPSTR   pszExtendedRet
    )
{
    static CHAR szExtendedRet[80];

    if (NULL == pszExtendedRet) {
        pszExtendedRet = szExtendedRet;
    }

    switch (ulExtendedRet) {
    case 0:
        strcpy(pszExtendedRet, "none");
        break;
    case FSMO_ERR_SUCCESS:
        strcpy(pszExtendedRet, "FSMO_ERR_SUCCESS");
        break;
    case FSMO_ERR_UNKNOWN_OP:
        strcpy(pszExtendedRet, "FSMO_ERR_UNKNOWN_OP");
        break;
    case FSMO_ERR_NOT_OWNER:
        strcpy(pszExtendedRet, "FSMO_ERR_NOT_OWNER");
        break;
    case FSMO_ERR_UPDATE_ERR:
        strcpy(pszExtendedRet, "FSMO_ERR_UPDATE_ERR");
        break;
    case FSMO_ERR_EXCEPTION:
        strcpy(pszExtendedRet, "FSMO_ERR_EXCEPTION");
        break;
    case FSMO_ERR_UNKNOWN_CALLER:
        strcpy(pszExtendedRet, "FSMO_ERR_UNKNOWN_CALLER");
        break;
    case FSMO_ERR_RID_ALLOC:
        strcpy(pszExtendedRet, "FSMO_ERR_RID_ALLOC");
        break;
    case FSMO_ERR_OWNER_DELETED:
        strcpy(pszExtendedRet, "FSMO_ERR_OWNER_DELETED");
        break;
    case FSMO_ERR_PENDING_OP:
        strcpy(pszExtendedRet, "FSMO_ERR_PENDING_OP");
        break;
    case FSMO_ERR_COULDNT_CONTACT:
        strcpy(pszExtendedRet, "FSMO_ERR_COULDNT_CONTACT");
        break;
    case FSMO_ERR_REFUSING_ROLES:
        strcpy(pszExtendedRet, "FSMO_ERR_REFUSING_ROLES");
        break;
    case FSMO_ERR_DIR_ERROR:
        strcpy(pszExtendedRet, "FSMO_ERR_DIR_ERROR");
        break;
    case FSMO_ERR_MISSING_SETTINGS:
        strcpy(pszExtendedRet, "FSMO_ERR_MISSING_SETTINGS");
        break;
    case FSMO_ERR_ACCESS_DENIED:
        strcpy(pszExtendedRet, "FSMO_ERR_ACCESS_DENIED");
        break;
    default:
        // Bad parameter or dsexts out of date.
        sprintf(pszExtendedRet, "0x%x", ulExtendedRet);
        break;
    }

    return pszExtendedRet;
}


BOOL
Dump_REPLTIMES_local(
    IN DWORD        nIndents,
    IN REPLTIMES *  prt
    )
/*++

Routine Description:

    REPLTIMES dump routine.

Arguments:

    nIndents - Indentation level desired.

    puuid - address of REPLTIMES in *local* address space (i.e., address space
        of the debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    static LPCSTR rgpszDays[] =
    {"SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"};

    DWORD   iDay, ib;

    printf("%sREPLTIMES\n", Indent(nIndents));
    for (iDay = 0; iDay < 7; iDay++) {
        Printf("%s%s ", Indent(nIndents + 2), rgpszDays[iDay]);

        for (ib = 0; ib < 12; ib++) {
            Printf(" %02x", prt->rgTimes[iDay*12 + ib]);
        }

        Printf("\n");
    }

    return TRUE;
}


BOOL
Dump_REPLTIMES(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    REPLTIMES (replication schedule) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLTIMES in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            ok = FALSE;
    REPLTIMES *     prt;

    prt = (REPLTIMES *) ReadMemory(pvProcess, sizeof(REPLTIMES));

    if (NULL != prt) {
        ok = Dump_REPLTIMES_local(nIndents, prt);
    }

    return ok;
}


BOOL
Dump_UUID_local(
    IN DWORD    nIndents,
    IN UUID *   puuid
    )
/*++

Routine Description:

    UUID dump routine.

Arguments:

    nIndents - Indentation level desired.

    puuid - address of UUID in *local* address space (i.e., address space of the
        debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    Printf("%sUUID %s\n", Indent(nIndents), DraUuidToStr(puuid, NULL));

    return TRUE;
}


BOOL
Dump_UUID(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    UUID dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of UUID in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok = FALSE;
    UUID *  puuid;

    puuid = (UUID *) ReadMemory(pvProcess, sizeof(UUID));

    if (NULL != puuid) {
        ok = Dump_UUID_local(nIndents, puuid);
    }

    return ok;
}


BOOL
Dump_MTX_ADDR(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    MTX_ADDR (replication network address) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MTX_ADDR in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL        ok = FALSE;
    MTX_ADDR *  pmtx;
    DWORD       cb;

    pmtx = (MTX_ADDR *) ReadMemory(pvProcess, sizeof(MTX_ADDR));

    if (NULL != pmtx) {
        cb = MTX_TSIZE(pmtx);
        Printf("%sMTX_ADDR (struct size %d, name length %d)\n",
               Indent(nIndents), cb, pmtx->mtx_namelen);

        FreeMemory(pmtx);
        pmtx = (MTX_ADDR *) ReadMemory(pvProcess, cb);
        if (NULL != pmtx) {
            ok = TRUE;

            if (1 + lstrlenA(pmtx->mtx_name) != (int) pmtx->mtx_namelen) {
                Printf("%s!! mtx_namelen (%d) != 1 + lstrlenA(pmtx->mtx_name) (%d) !!\n",
                       Indent(nIndents+2), pmtx->mtx_namelen, 1 + lstrlenA(pmtx->mtx_name));
                ok = FALSE;
            }

            Printf("%s%s\n", Indent(nIndents+2), pmtx->mtx_name);
        }
    }

    return ok;
}


BOOL
Dump_AO_local(
    IN DWORD nIndents,
    IN AO *  pao
    )
/*++

Routine Description:

    AO (async replication op structure) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pao - address of PAO in *local* address space (i.e., address space of the
        debugger, not that of the process being debugged).

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL ok = FALSE;
    CHAR szTime[SZDSTIME_LEN];

    Printf("%sNext AO               @ 0x%p\n", Indent(nIndents), pao->paoNext);
    Printf("%sTime enqueued           %s\n", Indent(nIndents),
           DSTimeToDisplayString(pao->timeEnqueued, szTime));
    Printf("%sSerial number           0x%x\n", Indent(nIndents), pao->ulSerialNumber);
    Printf("%sPriority                0x%x\n", Indent(nIndents), pao->ulPriority);
    Printf("%sOptions                 0x%x\n", Indent(nIndents), pao->ulOptions);
    Printf("%sResult                  0x%x\n", Indent(nIndents), pao->ulResult);
    Printf("%shDone                   0x%I64x\n", Indent(nIndents), pao->hDone);

    switch (pao->ulOperation) {
      case AO_OP_REP_ADD:
        Printf("%sREP_ADD\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_add.pNC);

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.pDSASMtx_addr);
            ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_add.pDSASMtx_addr);
        }

        if (ok) {
            Printf("%sSource Dom DNS Name   @ 0x%p\n", Indent(nIndents+2),
                   pao->args.rep_add.pszSourceDsaDnsDomainName);

            Printf("%sSchedule              @ 0x%p\n", Indent(nIndents+2), pao->args.rep_add.preptimesSync);
            if (NULL != pao->args.rep_add.preptimesSync) {
                ok = Dump_REPLTIMES(nIndents+3, pao->args.rep_add.preptimesSync);
            }
        }
        break;

      case AO_OP_REP_DEL:
        Printf("%sREP_DEL\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_del.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_del.pNC);

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_del.pSDSAMtx_addr);
            if (NULL != pao->args.rep_del.pSDSAMtx_addr) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_del.pSDSAMtx_addr);
            }
        }
        break;

      case AO_OP_REP_MOD:
        Printf("%sREP_MOD\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_mod.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.puuidSourceDRA);
            if (NULL != pao->args.rep_mod.puuidSourceDRA) {
                ok = Dump_UUID(nIndents+3, pao->args.rep_mod.puuidSourceDRA);
            }
        }

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.rep_mod.pmtxSourceDRA);
            if (NULL != pao->args.rep_mod.pmtxSourceDRA) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.rep_mod.pmtxSourceDRA);
            }
        }

        if (ok) {
            Printf("%sSchedule              @ 0x%p\n", Indent(nIndents+2), &pao->args.rep_mod.rtSchedule);
            ok = Dump_REPLTIMES_local(nIndents+3, &pao->args.rep_mod.rtSchedule);
        }

        if (ok) {
            Printf("%sReplica flags           0x%x\n", Indent(nIndents+2), pao->args.rep_mod.ulReplicaFlags);
            Printf("%sModify fields           0x%x\n", Indent(nIndents+2), pao->args.rep_mod.ulModifyFields);
        }
        break;

      case AO_OP_REP_SYNC:
        Printf("%sREP_SYNC\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.rep_sync.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.rep_sync.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), &pao->args.rep_sync.invocationid);
            ok = Dump_UUID_local(nIndents+3, &pao->args.rep_sync.invocationid);
        }

        if (ok) {
            Printf("%sSource DSA Name       @ 0x%p\n", Indent(nIndents+2), pao->args.rep_sync.pszDSA);
        }
        break;

      case AO_OP_UPD_REFS:
        Printf("%sUPD_REFS\n", Indent(nIndents));
        Printf("%sNC                    @ 0x%p\n", Indent(nIndents+2), pao->args.upd_refs.pNC);
        ok = Dump_DSNAME(nIndents+3, pao->args.upd_refs.pNC);

        if (ok) {
            Printf("%sSource DSA UUID       @ 0x%p\n", Indent(nIndents+2), &pao->args.upd_refs.invocationid);
            ok = Dump_UUID_local(nIndents+3, &pao->args.upd_refs.invocationid);
        }

        if (ok) {
            Printf("%sSource DSA MTX        @ 0x%p\n", Indent(nIndents+2), pao->args.upd_refs.pDSAMtx_addr);
            if (NULL != pao->args.upd_refs.pDSAMtx_addr) {
                ok = Dump_MTX_ADDR(nIndents+3, pao->args.upd_refs.pDSAMtx_addr);
            }
        }
        break;

      default:
        Printf("%sUnknown op 0x%x!\n", Indent(nIndents), pao->ulOperation);
        break;
    }

    return ok;
}


BOOL
Dump_AO(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    AO (async replication op structure) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PAO in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok = FALSE;
    AO *    pao;

    Printf("%sAO @ 0x%p\n", Indent(nIndents), pvProcess);

    pao = (AO *) ReadMemory(pvProcess, sizeof(AO));

    if (NULL != pao) {
        ok = Dump_AO_local(nIndents+2, pao);

        FreeMemory(pao);
    }

    return ok;
}


BOOL
Dump_AOLIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    AO (async replication op structure) list dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of first PAO in address space of process being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL    ok;
    AO *    pao;

    do {
        Printf("%sAO @ 0x%p\n", Indent(nIndents), pvProcess);

        pao = (AO *) ReadMemory(pvProcess, sizeof(AO));

        if (NULL != pao) {
            ok = Dump_AO_local(nIndents+2, pao);

            pvProcess = pao->paoNext;

            FreeMemory(pao);
        }
        else {
            ok = FALSE;
        }
    } while (ok && (NULL != pvProcess));

    return ok;
}


BOOL
Dump_DRS_MSG_GETCHGREQ_V4(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V2 dump routine.  DRS_MSG_GETCHGREQ_V2 is the
    message sent from replication sink to replication source to request changes
    from a given NC.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V2 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V4 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V4 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V4 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V4));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA:          %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->V3.uuidDsaObjDest, NULL));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->V3.uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->V3.pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->V3.usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->V3.pUpToDateVecDestV1);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->V3.ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->V3.cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->V3.cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->V3.ulExtendedOp, NULL));

        Printf("%sReply via transport:      %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidTransportObj, NULL));

        Printf("%sReturn address:         @ %p\n", Indent(nIndents),
               pmsg->pmtxReturnAddress);
        if (!Dump_MTX_ADDR(nIndents+3, pmsg->pmtxReturnAddress)) {
            fSuccess = FALSE;
        }

        FreeMemory(pmsg);
    }

    return fSuccess;
}


BOOL
Dump_DRS_MSG_GETCHGREQ_V5(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V5 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V5 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V5 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V5 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V5 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V5));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA objGuid:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjDest, NULL));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecDestV1);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->ulExtendedOp, NULL));

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREQ_V8(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREQ_V8 dump routine.
Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V8 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                    fSuccess = FALSE;
    DRS_MSG_GETCHGREQ_V8 *  pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREQ_V8 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREQ_V8 *) ReadMemory(pvProcess,
                                               sizeof(DRS_MSG_GETCHGREQ_V8));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sDestination DSA objGuid:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjDest, NULL));

        Printf("%sSource DSA Invocation ID: %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sDestination UTD vector: @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecDest);

        Printf("%sFlags:                    0x%x\n", Indent(nIndents),
               pmsg->ulFlags);

        Printf("%sMax objects to return:    %d\n", Indent(nIndents),
               pmsg->cMaxObjects);

        Printf("%sMax bytes to return:      %d\n", Indent(nIndents),
               pmsg->cMaxBytes);

        Printf("%sExtended operation:       %s\n", Indent(nIndents),
               DrsExtendedOpToStr(pmsg->ulExtendedOp, NULL));

        Printf("%sFsmo Info:                %I64d\n", Indent(nIndents),
              pmsg->liFsmoInfo);

        Printf("%spPartialAttrSet:        @ %p\n", Indent(nIndents),
               pmsg->pPartialAttrSet);

        Printf("%spPartialAttrSetEx:      @ %p\n", Indent(nIndents),
               pmsg->pPartialAttrSetEx);

        Printf("%sPrefixTableDest.PrefixCount:     %d\n", Indent(nIndents),
               pmsg->PrefixTableDest.PrefixCount);

        Printf("%sPrefixTableDest.pPrefixEntry:  @ %p\n", Indent(nIndents),
               pmsg->PrefixTableDest.pPrefixEntry);

        FreeMemory(pmsg);
    }

    return fSuccess;
}



BOOL
Dump_DRS_MSG_GETCHGREPLY_V1(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V1 dump routine.  DRS_MSG_GETCHGREQ_V1 is the
    message sent from replication sink to replication source to request changes
    from a given NC.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREQ_V1 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V1 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V1 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V1 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V1));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrcV1);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_V3(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V3 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V3 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V3 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V3 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V3 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V3));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrcV1);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_V5(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V5 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V5 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V5 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V5 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V5 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V3));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrc);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);
        
        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_V6(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_MSG_GETCHGREPLY_V6 dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V6 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V6 * pmsg = NULL;

    Printf("%sDRS_MSG_GETCHGREPLY_V6 @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V6 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V6));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sSource DSA objectGuid:    %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidDsaObjSrc, NULL));

        Printf("%sSource DSA invocationId:  %s\n", Indent(nIndents),
               DraUuidToStr(&pmsg->uuidInvocIdSrc, NULL));

        Printf("%sNC:\n", Indent(nIndents));
        if (!Dump_DSNAME(2 + nIndents, pmsg->pNC)) {
            fSuccess = FALSE;
        }

        Printf("%sFrom USN vector:          %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecFrom, NULL));

        Printf("%sTo USN vector:            %s\n", Indent(nIndents),
               UsnVecToStr(&pmsg->usnvecTo, NULL));

        Printf("%sSource UTD vector:      @ %p\n", Indent(nIndents),
               pmsg->pUpToDateVecSrc);

        Printf("%sNum bytes returned:       %d\n", Indent(nIndents),
               pmsg->cNumBytes);

        Printf("%sNum objects returned:     %d\n", Indent(nIndents),
               pmsg->cNumObjects);

        Printf("%sObjects:                @ %p\n", Indent(nIndents),
               pmsg->pObjects);

        Printf("%sExtended return code:     %s\n", Indent(nIndents),
               DrsExtendedRetToStr(pmsg->ulExtendedRet, NULL));

        Printf("%sMore Data:                %s\n", Indent(nIndents),
               pmsg->fMoreData ? "yes" : "no");

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);
        
        Printf("%sdwDRSError:               %d\n", Indent(nIndents),
               pmsg->dwDRSError);

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_DRS_MSG_GETCHGREPLY_VALUES(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Dump the values array out of a GETCHGREPLY structure. It doesn't matter which
    version of the reply structure you pass in here, as long as the rgValues
    field hasn't changed position.

    Note also that you do not pass the address of rgValues.  You pass the address of the
    GETCHGREPLY structure. This is because we need to dig out the count of values in
    the array, which is kept in this containing structure.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_MSG_GETCHGREPLY_V6 in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL                     fSuccess = FALSE;
    DRS_MSG_GETCHGREPLY_V6 * pmsg = NULL;
    DWORD                    i;

    Printf("%sDRS_MSG_GETCHGREPLY_Vx @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmsg = (DRS_MSG_GETCHGREPLY_V6 *) ReadMemory(pvProcess,
                                                 sizeof(DRS_MSG_GETCHGREPLY_V6));

    if (NULL != pmsg) {
        fSuccess = TRUE;

        Printf("%sNum values returned:      %d\n", Indent(nIndents),
               pmsg->cNumValues);

        Printf("%sValues:                 @ %p\n", Indent(nIndents),
               pmsg->rgValues);
        
        for( i = 0; i < pmsg->cNumValues; i++ ) {
            REPLVALINF *pReplValInf = pmsg->rgValues + i;
            Dump_REPLVALINF( nIndents + 1, pReplValInf );
        }

        FreeMemory(pmsg);
    }

    return fSuccess;
}

BOOL
Dump_NCSYNCSOURCE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    NCSYNCSOURCE *pncss = NULL;
    DWORD size, length;
    BOOL fFollowLinks = TRUE;

    nIndents++;
    do {
        if (!pvProcess) {
            break;
        }
        Printf("%sNCSYNCSOURCE @ %p\n", Indent(nIndents - 1), pvProcess);

        // Deal with variable length structure. Read base structure to get length
        size = sizeof( NCSYNCSOURCE );
        pncss = (NCSYNCSOURCE *) ReadMemory(pvProcess, size );
        if (pncss == NULL) {
            fSuccess = FALSE;
            break;
        }
        if (pncss->cchDSA < 256) {
            size += (pncss->cchDSA + 1) * sizeof(WCHAR);
            pncss = (NCSYNCSOURCE *) ReadMemory(pvProcess, size );
            if (pncss == NULL) {
                fSuccess = FALSE;
                break;
            }
        } else {
            *(pncss->szDSA) = L'\0';
        }

        Printf("%sDSA:           %ws\n", Indent(nIndents),
               pncss->szDSA);
        Printf("%sfCompletedSrc: %d\n", Indent(nIndents),
               pncss->fCompletedSrc);
        Printf("%sulResult:      %d\n", Indent(nIndents),
               pncss->ulResult);

        pvProcess = pncss->pNextSource;
        FreeMemory(pncss);

    } while (fFollowLinks && fSuccess);

    return fSuccess;
}

BOOL
Dump_NCSYNCDATA(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    NCSYNCDATA *pncsd = NULL;
    BOOL fFollowLinks = TRUE;

    nIndents++;
    do {
        if (!pvProcess) {
            break;
        }
        Printf("%sNCSYNCDATA @ %p\n", Indent(nIndents - 1), pvProcess);

        Printf("%sNC:\n", Indent(nIndents));
        // Re-reads same memory as below
        if (!Dump_DSNAME(2 + nIndents, ((BYTE *)pvProcess) +
                         offsetof( NCSYNCDATA, NC ) )) {
            fSuccess = FALSE;
            break;
        }

        pncsd = (NCSYNCDATA *) ReadMemory(pvProcess, sizeof(NCSYNCDATA));
        if (pncsd == NULL) {
            fSuccess = FALSE;
            break;
        }

        Printf("%sulUntriedSrcs:       %d\n", Indent(nIndents),
               pncsd->ulUntriedSrcs);
        Printf("%sulTriedSrcs:         %d\n", Indent(nIndents),
               pncsd->ulTriedSrcs);
        Printf("%sulLastTriedSrcs:     %d\n", Indent(nIndents),
               pncsd->ulLastTriedSrcs);
        Printf("%sulReplicaFlags:      0x%x\n", Indent(nIndents),
               pncsd->ulReplicaFlags);
        Printf("%sfSyncedFromOneSrc:   %d\n", Indent(nIndents),
               pncsd->fSyncedFromOneSrc);
        Printf("%sfNCComplete:         %d\n", Indent(nIndents),
               pncsd->fNCComplete);
        Printf("%spFirstSource:\n", Indent(nIndents));
        fSuccess = Dump_NCSYNCSOURCE( nIndents, pncsd->pFirstSource );

        pvProcess = pncsd->pNCSDNext;

        FreeMemory(pncsd);

    } while (fFollowLinks && fSuccess);

    return fSuccess;
}

BOOL
Dump_INITSYNC(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL fSuccess = TRUE;
    PVOID pAddress;
    LPDWORD pdwValue;

#define DUMPSYMD( sym ) \
    pAddress = (VOID *) GetExpr("ntdsa!" #sym); \
    if (NULL == pAddress) { \
        Printf("Can't Locate the Address of %s - Sorry\n", #sym); \
        return FALSE; \
    } else { \
        pdwValue = (LPDWORD) ReadMemory(pAddress, sizeof(DWORD)); \
        if (pdwValue == NULL) { \
            Printf("Can't read address 0x%x - Sorry\n", pAddress); \
            return FALSE; \
        } else { \
            Printf("%s(0x%x) = %d (0x%x)\n", #sym, pAddress, *pdwValue, *pdwValue ); \
        } \
    }

    DUMPSYMD( gfIsSynchronized );
    DUMPSYMD( gfInitSyncsFinished );
    DUMPSYMD( gfDsaWritable );
    DUMPSYMD( gpNCSDFirst );
    if (*pdwValue != 0) {
        Printf( "!dsexts.dump NCSYNCDATA %x\n", *pdwValue );
    }
    DUMPSYMD( gulNCUnsynced );
    DUMPSYMD( gulNCUnsyncedWrite );
    DUMPSYMD( gulNCUnsyncedReadOnly );
    DUMPSYMD( gfWasPreviouslyPromotedGC );
    DUMPSYMD( gulGCPartitionOccupancy );

    DUMPSYMD( gAnchor );
    if (pAddress != 0) {
        Printf( "!dsexts.dump DSA_ANCHOR %x\n", pAddress );
    }


    return fSuccess;
}


BOOL
Dump_DRS_ASYNC_RPC_STATE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public DRS_ASYNC_RPC_STATE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DRS_ASYNC_RPC_STATE in address space of process
        being debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    static struct {
        DRS_CALL_TYPE   CallType;
        LPSTR           pszCallType;
    } rgCallTypeTable[] = {
        {DRS_CALL_GET_CHANGES, "GetChanges"},
    };
    const DWORD cchFieldWidth = 29;

    BOOL                  fSuccess = FALSE;
    DRS_ASYNC_RPC_STATE * pAsyncState = NULL;
    CHAR                  szTime[SZDSTIME_LEN];
    DWORD                 i;
    LPSTR                 pszCallType;

    Printf("%sDRS_ASYNC_RPC_STATE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pAsyncState = (DRS_ASYNC_RPC_STATE *) ReadMemory(pvProcess,
                                                     sizeof(DRS_ASYNC_RPC_STATE));

    if (NULL != pAsyncState) {
        fSuccess = TRUE;

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "ListEntry.Flink", pAsyncState->ListEntry.Flink);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "ListEntry.Blink", pAsyncState->ListEntry.Blink);

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "timeInitialized",
               DSTimeToDisplayString(pAsyncState->timeInitialized, szTime));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "RpcState.u.hEvent", pAsyncState->RpcState.u.hEvent);

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "dwCallerTID", pAsyncState->dwCallerTID);

        pszCallType = "Unknown!";
        for (i = 0; i < ARRAY_SIZE(rgCallTypeTable); i++) {
            if (pAsyncState->CallType == rgCallTypeTable[i].CallType) {
                pszCallType = rgCallTypeTable[i].pszCallType;
                break;
            }
        }
        Printf("%s%-*s: %d (%s)\n", Indent(nIndents), cchFieldWidth,
               "CallType", pAsyncState->CallType, pszCallType);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "CallArgs.pszServerName", pAsyncState->CallArgs.pszServerName);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "CallArgs.pszDomainName", pAsyncState->CallArgs.pszDomainName);

        switch (pAsyncState->CallType) {
        case DRS_CALL_GET_CHANGES:
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pmsgIn",
                   pAsyncState->CallArgs.GetChg.pmsgIn);
            Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.dwOutVersion",
                   pAsyncState->CallArgs.GetChg.dwOutVersion);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pmsgOut",
                   pAsyncState->CallArgs.GetChg.pmsgOut);
            Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
                   "CallArgs.GetChg.pSchemaInfo",
                   pAsyncState->CallArgs.GetChg.pSchemaInfo);
            break;

        default:
            break;
        }

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "SessionKey.SessionKey", pAsyncState->SessionKey.SessionKey);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "SessionKey.SessionKeyLength",
               pAsyncState->SessionKey.SessionKeyLength);

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "pContextInfo", pAsyncState->pContextInfo);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "fIsCallInProgress", pAsyncState->fIsCallInProgress);

        FreeMemory(pAsyncState);
    }

    return fSuccess;
}

// Stolen from mdnotify.c, since the datastructure is not published.

// Notify element.
// This list is shared between the ReplicaNotify API and the ReplNotifyThread.
// The elements on this list are fixed size.
// NC's to be notified are identified by NCDNT

typedef struct _ne {
    struct _ne *pneNext;
    ULONG ulNcdnt;          // NCDNT to notify
    DWORD dwNotifyTime;     // Time to send notification
    BOOL fUrgent;           // Notification was queued urgently
} NE;

BOOL Dump_ReplNotifyElement(
        IN DWORD nIndents,
        IN OPTIONAL PVOID pvProcess)
/*++

Routine Description:

    Public NE (replication notification element) dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of NE in address space of process being debugged.
               If left NULL, we automatically try to look up the one known
               global NE root pointer and use that.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    NE * pneLocal;
    DWORD cTickNow = GetTickCount();
    BOOL bSucceeded = TRUE;

    if (pvProcess == NULL) {
        // Nothing specified, so find the global list head
        pvProcess = (VOID*)GetExpr("ntdsa!pneHead");
        if (pvProcess) {
            // and read the address of the first entry
            NE ** ppAddr;
            ppAddr = ReadMemory(pvProcess, sizeof(PVOID));
            if (ppAddr) {
                pvProcess = *ppAddr;
                FreeMemory(ppAddr);
            }
            else {
                bSucceeded = FALSE;
                pvProcess = NULL;
            }
        }
    }

    while (pvProcess) {
        pneLocal = ReadMemory(pvProcess, sizeof(NE));
        if (pneLocal) {
            pvProcess = pneLocal->pneNext;
            Printf("%sNC DNT        %u\n",
                   Indent(nIndents),
                   pneLocal->ulNcdnt);
            Printf("%sNotify Time   %u ticks (%us from now)\n",
                   Indent(nIndents),
                   pneLocal->dwNotifyTime,
                   (pneLocal->dwNotifyTime > cTickNow)
                   ? (pneLocal->dwNotifyTime - cTickNow)/1000
                   : 0);
            Printf("%sUrgent        %s\n",
                   Indent(nIndents),
                   pneLocal->fUrgent
                   ? "True"
                   : "False");
            Printf("%spNext        @ %p\n\n",
                   Indent(nIndents),
                   pvProcess);
            FreeMemory(pneLocal);
        }
        else {
            pvProcess = NULL;
            bSucceeded = FALSE;
        }
    }
    return bSucceeded;
}

BOOL
Dump_UPTODATE_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public UPTODATE_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of UPTODATE_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    UPTODATE_VECTOR *putodvec = NULL;
    DWORD           cNumCursors = 0;
    DWORD           iCursor;
    DWORD           cb;
    CHAR            szTime[SZDSTIME_LEN];

    Printf("%sUPTODATE_VECTOR @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    putodvec = (UPTODATE_VECTOR *) ReadMemory(pvProcess,
                                              UpToDateVecV1SizeFromLen(0));
    if (NULL != putodvec) {
        if (1 == putodvec->dwVersion) {
            cNumCursors = putodvec->V1.cNumCursors;
            cb = UpToDateVecV1Size(putodvec);
        } else if (2 == putodvec->dwVersion) {
            cNumCursors = putodvec->V2.cNumCursors;
            cb = UpToDateVecV2Size(putodvec);
        } else {
            Printf("%sInvalid UPTODATE_VECTOR version (%d).\n", Indent(nIndents), putodvec->dwVersion);
        }

        FreeMemory(putodvec);

        if (0 != cNumCursors) {
            putodvec = (UPTODATE_VECTOR *) ReadMemory(pvProcess, cb);

            if (NULL != putodvec) {
                for (iCursor = 0; iCursor < cNumCursors; iCursor++) {
                    if (1 == putodvec->dwVersion) {
                        Printf("%sDSA Invoc ID: %s  USN: %I64d\n",
                               Indent(nIndents),
                               DraUuidToStr(&putodvec->V1.rgCursors[iCursor].uuidDsa, NULL),
                               putodvec->V1.rgCursors[iCursor].usnHighPropUpdate);
                    } else {
                        Printf("%sDSA Invoc ID: %s | USN: %I64d | Timestamp: %s\n",
                               Indent(nIndents),
                               DraUuidToStr(&putodvec->V2.rgCursors[iCursor].uuidDsa, NULL),
                               putodvec->V2.rgCursors[iCursor].usnHighPropUpdate,
                               DSTimeToDisplayString(putodvec->V2.rgCursors[iCursor].timeLastSyncSuccess,
                                                     szTime));
                    }
                }

                FreeMemory(putodvec);
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dscntl\dscntl.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    dscntl.c

Abstract:

Author:

    Colin Brace (ColinBr) 21-Jan-98

Environment:

    User Mode - Win32

Revision History:

    21-Jan-1997 ColinBr
        Created initial file.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>

#include <ntdsapi.h>    

//
// Forward decl's
//
VOID
GetWinErrorMessage(
    IN  DWORD WinError,
    OUT LPSTR *WinMsg
    );

//
// Small helper routines
//
void
Usage(
    VOID
    )
{
    printf("dscntl is a command line utility used to perform control operations\n");
    printf("on a directory service.\n" );
    printf("\nOptions\n\n");
    printf("-s      the target server on which to perform the operation(s).\n");
    printf("-rs     specifies the server to remove.\n");
    printf("-rd     specifies the domain to remove.\n");
    printf("-commit indicates whether to commit the changes.\n");

    exit( ERROR_INVALID_PARAMETER );
}

//
// Executable entry point
//
int _cdecl 
main(
    int   argc, 
    char  *argv[]
    )
{

    int   Index;
    int   WinError = ERROR_SUCCESS;
    char  *Option;

    HANDLE hDs = 0;

    LPSTR Server           = NULL;
    LPSTR RemoveServerDN   = NULL;
    LPSTR RemoveDomainDN   = NULL;
    BOOL  fCommit          = FALSE;

    for ( Index = 1; Index < argc; Index++ )
    {
        Option = argv[Index];

        if ( *Option == '/' || *Option == '-' )
        {
            Option++;
        }

        if ( !_strnicmp( Option, "s", 1 ) )
        {
            Option++;
            if ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                Server = argv[Index];
            } else {
                Server = Option;
            }
        }
        else if ( !_strnicmp( Option, "rs", 2 )  )
        {
            Option += 2;
            while ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                RemoveServerDN = argv[Index];
            } else {
                RemoveServerDN = Option;
            }
        }
        else if ( !_strnicmp( Option, "rd", 2 )  )
        {
            Option += 2;
            while ( *Option == ':' ) {
                Option++;
            }
            if ( *Option == '\0' ) {
                Index++;
                RemoveDomainDN = argv[Index];
            } else {
                RemoveDomainDN = Option;
            }
        }
        else if ( !_stricmp( Option, "commit" )  )
        {
            fCommit = TRUE;
        }
        else
        {
            Usage();
        }
        
    }

    if ( !Server )
    {
        Usage();
    }

    //
    // Get a server handle
    //
    WinError = DsBindA( Server,
                        NULL,   // domain name
                        &hDs );

    if ( ERROR_SUCCESS != WinError )
    {
        printf( "Unable to establish a connection with %s because error %d occurred.\n",
                 Server, WinError );
        goto ErrorCase;
    }


    if ( RemoveServerDN )
    {

        BOOL fLastDcInDomain = FALSE;

        WinError = DsRemoveDsServerA( hDs,
                                      RemoveServerDN,
                                      RemoveDomainDN,
                                      &fLastDcInDomain,
                                      fCommit );

        if ( ERROR_SUCCESS != WinError )
        {
            printf( "The remove server operation failed with %d.\n", WinError );
            goto ErrorCase;
        }
        else
        {
            if ( RemoveDomainDN )
            {
                if ( fLastDcInDomain )
                {
                    printf( "The dsa %s is the last dc in domain %s\n", 
                            RemoveServerDN, RemoveDomainDN );
                }
                else
                {
                    printf( "The dsa %s is not the last dc in domain %s\n", 
                             RemoveServerDN, RemoveDomainDN );
                }
            }
    
            printf( "The dsa %s has been removed successfully.\n", RemoveServerDN );
        }
    }

    if ( !RemoveServerDN && RemoveDomainDN )
    {

        WinError = DsRemoveDsDomainA( hDs,
                                      RemoveDomainDN );
        
        if ( ERROR_SUCCESS != WinError )
        {
            printf( "The remove server operation failed with %d.\n", WinError );
            goto ErrorCase;
        }
        else
        {
            printf( "The domain %s has been removed successfully.\n", RemoveDomainDN );
        }

        goto ErrorCase;
    }


ErrorCase:

    if ( hDs )
    {
        DsUnBind( hDs );
    }

    if ( ERROR_SUCCESS == WinError )
    {
        printf( "\nThe command completely successfully.\n" );
    }
    else
    {
        LPSTR Tmp;

        GetWinErrorMessage( WinError, &Tmp );

        printf( "\nError %d: %s\n", WinError, Tmp );
        LocalFree( Tmp );

    }

    return WinError;

}

VOID
GetWinErrorMessage(
    IN  DWORD WinError,
    OUT LPSTR *WinMsg
    )
{
    LPSTR   DefaultMessageString = "Unknown failure";
    ULONG   Size = sizeof( DefaultMessageString ) + sizeof(char);
    LPSTR   MessageString = NULL;
    ULONG   Length;

    Length = (USHORT) FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                      FORMAT_MESSAGE_FROM_SYSTEM ,
                                      NULL, // ResourceDll,
                                      WinError,
                                      0,       // Use caller's language
                                      (LPSTR)&MessageString,
                                      0,       // routine should allocate
                                      NULL );
    if ( MessageString )
    {
        // Messages from a message file have a cr and lf appended
        // to the end
        MessageString[Length-2] = L'\0';
        Size = ( Length + 1) * sizeof(char);
    }

    if ( !MessageString )
    {
        MessageString = DefaultMessageString;
    }

    if ( WinMsg )
    {
        *WinMsg = ( LPSTR ) LocalAlloc( 0, Size );
        if ( *WinMsg )
        {
            strcpy( (*WinMsg), MessageString );
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\dsexts.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsexts.h

Abstract:

    Declares helpers and globals for the DS ntsd/windbg debugger extensions
    DLL.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry()

    24-Apr-96   DaveStr     Created

--*/

#include <ntsdexts.h>       // debugger extension helpers

//
// Globals
//

extern PNTSD_EXTENSION_APIS     gpExtApis;
extern HANDLE                   ghDbgThread;
extern HANDLE                   ghDbgProcess;
extern LPSTR                    gpszCommand;

//
// Global flag to control verbosity of misc. routines.  Should be
// used to debug the DLL itself, not to report operation progress
// to DLL users.
//

extern BOOL                     gfVerbose;

//
// Macros to easily access extensions helper routines for printing, etc.
// In particular, Printf() takes the same arguments as the CRT printf().
//

#define Printf          (gpExtApis->lpOutputRoutine)
#define GetSymbol       (gpExtApis->lpGetSymbolRoutine)
#define GetExpr         (gpExtApis->lpGetExpressionRoutine)
#define CheckC          (gpExtApis->lpCheckControlCRoutine)

//
// Macros to simplify declaration and globals setup of debugger extension DLL
// entry points.  See DEBUG_EXT(help) in dsexts.c for usage example.
//

#define DEBUG_EXT(cmd)                                  \
                                                        \
VOID                                                    \
cmd(                                                    \
    HANDLE                  hProcess,                   \
    HANDLE                  hThread,                    \
    DWORD                   dwCurrentPc,                \
    PNTSD_EXTENSION_APIS    lpExt,                      \
    LPSTR                   pszCommand)

#define INIT_DEBUG_EXT                                  \
    ghDbgProcess = hProcess;                            \
    ghDbgThread = hThread;                              \
    gpExtApis = lpExt;                                  \
    gpszCommand = pszCommand;

//
// Macro for getting the byte offset of an object/struct member.
// s == struct, m == member
//

#define OFFSET(s,m) ((size_t)((BYTE*)&(((s*)0)->m)-(BYTE*)0))

//
// Helper function prototypes
//

extern PVOID                // address of debugger local memory
ReadMemory(
    IN PVOID  pvAddr,       // address to read in process being debugged
    IN DWORD  dwSize);      // byte count to read

PVOID                       // address of debugger local memory
ReadStringMemory(
    IN PVOID  pvAddr,       // address to read in process being debugged
    IN DWORD  dwSize);      // maximum byte count to read


extern BOOL
WriteMemory(
    IN PVOID  pvProcess,    // address to write in process being debugged
    IN PVOID  pvLocal,      // address of debugger local memory
    IN DWORD  dwSize) ;     // byte count to write

extern VOID
FreeMemory(
    IN PVOID p);            // address returned by ReadMemory

extern VOID
ShowBinaryData(             // pretty prints binary data to debugger output
    IN DWORD   nIndents,    // number of indent levels desired
    IN PVOID   pvData,      // debugger local memory address
    IN DWORD   dwSize);     // count of bytes to dump

extern PCHAR
Indent(
    IN DWORD nIndents);     // number of indent levels desired

extern PCHAR                // '_' prefix so as not to conflict with oidconv.c
_DecodeOID(                 // produces a printable decoded OID
    IN PVOID   pvOID,       // pointer to buffer holding encoded OID
    IN DWORD   cbOID);      // count of bytes in encoded OID

// defined in md.c
extern LPSTR
DraUuidToStr(
    IN  UUID *  puuid,
    OUT LPSTR   pszUuid     OPTIONAL
    );

//
// Externs for all dump routines.  These are made global so dump routines
// can call one another.  They should all have the same signature.
//
// BOOL
// Dump_TYPENAME(
//      IN DWORD nIndents
//      IN PVOID pvProcess);
//
extern BOOL Dump_Binary(DWORD, PVOID);
extern BOOL Dump_BinaryCount(DWORD, PVOID, DWORD);
extern BOOL Dump_DSNAME(DWORD, PVOID);
extern BOOL Dump_DSNAME_local( DWORD, PVOID pName);
extern BOOL Dump_BINDARG(DWORD, PVOID);
extern BOOL Dump_BINDRES(DWORD, PVOID);
extern BOOL Dump_THSTATE(DWORD, PVOID);
extern BOOL Dump_SAMP_LOOPBACK_ARG(DWORD, PVOID);
extern BOOL Dump_Context(DWORD, PVOID);
extern BOOL Dump_ContextList(DWORD, PVOID);
extern BOOL Dump_ATQ_CONTEXT(DWORD, PVOID);
extern BOOL Dump_ATQ_ENDPOINT(DWORD, PVOID);
extern BOOL Dump_ATQC_ACTIVE_list(DWORD, PVOID);
extern BOOL Dump_ATQC_PENDING_list(DWORD, PVOID);
extern BOOL Dump_AttrBlock(DWORD, PVOID);
extern BOOL Dump_AttrBlock_local(DWORD, PVOID, BOOL);
extern BOOL Dump_AttrValBlock(DWORD, PVOID);
extern BOOL Dump_AttrVal(DWORD, PVOID);
extern BOOL Dump_Attr(DWORD, PVOID);
extern BOOL Dump_Attr_local(DWORD, PVOID, BOOL);
extern BOOL Dump_UPTODATE_VECTOR(DWORD, PVOID);
extern BOOL Dump_DSA_ANCHOR(DWORD, PVOID);
extern BOOL Dump_DBPOS(DWORD, PVOID);
extern BOOL Dump_DirWaitArray64(DWORD, PVOID);
extern BOOL Dump_DirWaitArray256(DWORD, PVOID);
extern BOOL Dump_DirWaitHead(DWORD, PVOID);
extern BOOL Dump_DirWaitItem(DWORD, PVOID);
extern BOOL Dump_EscrowInfo(DWORD, PVOID);
extern BOOL Dump_TransactionalData(DWORD, PVOID);
extern BOOL Dump_KEY(DWORD, PVOID);
extern BOOL Dump_KEY_INDEX(DWORD, PVOID);
extern BOOL Dump_CommArg(DWORD, PVOID);
extern BOOL Dump_USN_VECTOR(DWORD, PVOID);
extern BOOL Dump_PROPERTY_META_DATA_VECTOR(DWORD, PVOID);
extern BOOL Dump_PROPERTY_META_DATA_EXT_VECTOR(DWORD, PVOID);
extern BOOL Dump_ENTINF(DWORD, PVOID);
extern BOOL Dump_ENTINFSEL(DWORD, PVOID);
extern BOOL Dump_REPLENTINFLIST(DWORD, PVOID);
extern BOOL Dump_ReplNotifyElement(DWORD, PVOID);
extern BOOL Dump_REPLVALINF(DWORD, PVOID);
extern BOOL Dump_REPLICA_LINK(DWORD, PVOID);
extern BOOL Dump_AddArg(DWORD,PVOID);
extern BOOL Dump_AddRes(DWORD,PVOID);
extern BOOL Dump_ReadArg(DWORD,PVOID);
extern BOOL Dump_ReadRes(DWORD,PVOID);
extern BOOL Dump_SCHEMAPTR(DWORD,PVOID);
extern BOOL Dump_RemoveArg(DWORD,PVOID);
extern BOOL Dump_RemoveRes(DWORD,PVOID);
extern BOOL Dump_SearchArg(DWORD,PVOID);
extern BOOL Dump_SearchRes(DWORD,PVOID);
extern BOOL Dump_CLASSCACHE(DWORD,PVOID);
extern BOOL Dump_ATTCACHE(DWORD,PVOID);
extern BOOL Dump_FILTER(DWORD,PVOID);
extern BOOL Dump_SUBSTRING(DWORD,PVOID);
extern BOOL Dump_GLOBALDNREADCACHE(DWORD, PVOID);
extern BOOL Dump_LOCALDNREADCACHE(DWORD, PVOID);
extern BOOL Dump_BHCache(DWORD, PVOID);
extern BOOL Dump_MODIFYARG(DWORD, PVOID);
extern BOOL Dump_REQUEST(DWORD, PVOID);
extern BOOL Dump_REQUEST_list(DWORD, PVOID);
extern BOOL Dump_LIMITS(DWORD, PVOID);
extern BOOL Dump_PAGED(DWORD, PVOID);
extern BOOL Dump_USERDATA(DWORD, PVOID);
extern BOOL Dump_USERDATA_list(DWORD, PVOID);
extern BOOL Dump_PARTIAL_ATTR_VECTOR(DWORD, PVOID);
extern BOOL Dump_GCDeletionList(DWORD, PVOID);
extern BOOL Dump_GCDeletionListProcessed(DWORD, PVOID);
extern BOOL Dump_UUID(DWORD, PVOID);
extern BOOL Dump_REPLTIMES(DWORD, PVOID);
extern BOOL Dump_AO(DWORD, PVOID);
extern BOOL Dump_AOLIST(DWORD, PVOID);
extern BOOL Dump_MTX_ADDR(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V4(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V5(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREQ_V8(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V1(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V3(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V5(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_V6(DWORD, PVOID);
extern BOOL Dump_DRS_MSG_GETCHGREPLY_VALUES(DWORD, PVOID);
extern BOOL Dump_MODIFYDNARG(DWORD, PVOID);
extern BOOL Dump_d_tagname(DWORD, PVOID);
extern BOOL Dump_d_memname(DWORD, PVOID);
extern BOOL Dump_ProxyVal(DWORD, PVOID);
extern BOOL Dump_Sid(DWORD, PVOID);
extern BOOL Dump_DefinedDomain(DWORD, PVOID);
extern BOOL Dump_DefinedDomains(DWORD, PVOID);
extern BOOL Dump_FixedLengthDomain_local(DWORD, PVOID);
extern BOOL Dump_KCC_SITE(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_DSA(DWORD, PVOID);
extern BOOL Dump_KCC_DSA_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_CONNECTION(DWORD, PVOID);
extern BOOL Dump_KCC_INTRASITE_CONNECTION_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_INTERSITE_CONNECTION_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_REPLICATED_NC(DWORD, PVOID);
extern BOOL Dump_KCC_REPLICATED_NC_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_DS_CACHE(DWORD, PVOID);
extern BOOL Dump_KCC_CROSSREF(DWORD, PVOID);
extern BOOL Dump_KCC_CROSSREF_LIST(DWORD, PVOID);
extern BOOL Dump_KCC_DSNAME_ARRAY(DWORD, PVOID);
extern BOOL Dump_KCC_TRANSPORT(DWORD, PVOID);
extern BOOL Dump_KCC_TRANSPORT_LIST(DWORD, PVOID);
extern BOOL Dump_SCHEMA_PREFIX_TABLE(DWORD, PVOID);
extern BOOL Dump_SD(DWORD, PVOID);
extern BOOL Dump_STAT(DWORD, PVOID);
extern BOOL Dump_INDEXSIZE(DWORD, PVOID);
extern BOOL Dump_SPropTag(DWORD, PVOID);
extern BOOL Dump_SRowSet(DWORD, PVOID);
extern BOOL Dump_NCSYNCSOURCE(DWORD, PVOID);
extern BOOL Dump_NCSYNCDATA(DWORD, PVOID);
extern BOOL Dump_INITSYNC(DWORD, PVOID);
extern BOOL Dump_JETBACK_SHARED_HEADER(DWORD, PVOID);
extern BOOL Dump_JETBACK_SHARED_CONTROL(DWORD, PVOID);
extern BOOL Dump_BackupContext(DWORD, PVOID);
extern BOOL Dump_JETBACK_SERVER_CONTEXT(DWORD, PVOID);
extern BOOL Dump_DRS_ASYNC_RPC_STATE(DWORD, PVOID);
extern BOOL Dump_ISM_PENDING_ENTRY(DWORD, PVOID);
extern BOOL Dump_ISM_PENDING_LIST(DWORD, PVOID);
extern BOOL Dump_ISM_TRANSPORT(DWORD, PVOID);
extern BOOL Dump_ISM_TRANSPORT_LIST(DWORD, PVOID);
extern BOOL Dump_ISM_SERVICE(DWORD, PVOID);
extern BOOL Dump_VALUE_META_DATA(DWORD, PVOID);
extern BOOL Dump_VALUE_META_DATA_EXT(DWORD, PVOID);
extern BOOL Dump_KCC_SITE_LINK(DWORD,PVOID);
extern BOOL Dump_KCC_SITE_LINK_LIST(DWORD,PVOID);
extern BOOL Dump_KCC_BRIDGE(DWORD,PVOID);
extern BOOL Dump_KCC_BRIDGE_LIST(DWORD,PVOID);
extern BOOL Dump_TOPL_REPL_INFO(DWORD,PVOID);
extern BOOL Dump_ToplGraphState(DWORD,PVOID);
extern BOOL Dump_ToplInternalEdge(DWORD,PVOID);
extern BOOL Dump_ToplVertex(DWORD,PVOID);
extern BOOL Dump_TOPL_SCHEDULE(DWORD,PVOID);
extern BOOL Dump_PSCHEDULE(DWORD,PVOID);
extern BOOL Dump_DynArray(DWORD,PVOID);
extern BOOL Dump_TOPL_MULTI_EDGE(DWORD,PVOID);
extern BOOL Dump_TOPL_MULTI_EDGE_SET(DWORD,PVOID);
extern BOOL Dump_KCC_DSNAME_SITE_ARRAY(DWORD, PVOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\ism.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcc.cxx

ABSTRACT:

    Routines to dump KCC structures.

DETAILS:

CREATED:

    99/01/19    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop

extern "C" {
#include "ntdsa.h"
#include "debug.h"
#include "dsutil.h"
#include "dsexts.h"
}

#include "ismapi.h"
#include "ismserv.hxx"


BOOL
Dump_ISM_PENDING_ENTRY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    ISM_PENDING_ENTRY * pEntry = NULL;
    const DWORD         cchFieldWidth = 24;

    Printf("%sISM_PENDING_ENTRY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pEntry = (ISM_PENDING_ENTRY *) ReadMemory(pvProcess,
                                              sizeof(ISM_PENDING_ENTRY));

    if (NULL != pEntry) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "hEvent", pEntry->hEvent);
        
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "szServiceName",
               (BYTE *) pvProcess + offsetof(ISM_PENDING_ENTRY, szServiceName));

        FreeMemory(pEntry);
    }

    return fSuccess;
}

BOOL
Dump_ISM_PENDING_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    ISM_PENDING_LIST *  pList = NULL;
    const DWORD         cchFieldWidth = 24;
    DWORD               iEntry;
    ISM_PENDING_ENTRY * pEntry;

    Printf("%sISM_PENDING_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (ISM_PENDING_LIST *) ReadMemory(pvProcess,
                                            sizeof(ISM_PENDING_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_Lock",
               (BYTE *) pvProcess + offsetof(ISM_PENDING_LIST, m_Lock));

        for (iEntry = 0, pEntry = pList->m_pPending;
             NULL != pEntry;
             iEntry++, pEntry = pEntry->pNext) {
            if (!Dump_ISM_PENDING_ENTRY(nIndents+1, pEntry)) {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_ISM_TRANSPORT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    ISM_TRANSPORT * pTransport = NULL;
    const DWORD     cchFieldWidth = 26;

    Printf("%sISM_TRANSPORT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pTransport = (ISM_TRANSPORT *) ReadMemory(pvProcess,
                                              sizeof(ISM_TRANSPORT));

    if (NULL != pTransport) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized",
               pTransport->m_fIsInitialized ? "TRUE" : "FALSE");
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportDN", pTransport->m_pszTransportDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportDll", pTransport->m_pszTransportDll);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_TransportGuid",
               DraUuidToStr(&pTransport->m_TransportGuid, NULL));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hIsm", pTransport->m_hIsm);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_PendingList",
               (BYTE *) pvProcess + offsetof(ISM_TRANSPORT, m_PendingList));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hDll", pTransport->m_hDll);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pStartup", pTransport->m_pStartup);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pRefresh", pTransport->m_pRefresh);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSend", pTransport->m_pSend);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pReceive", pTransport->m_pReceive);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeMsg", pTransport->m_pFreeMsg);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetConnectivity", pTransport->m_pGetConnectivity);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeConnectivity", pTransport->m_pFreeConnectivity);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetTransportServers", pTransport->m_pGetTransportServers);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeTransportServers", pTransport->m_pFreeTransportServers);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pGetConnectionSchedule", pTransport->m_pGetConnectionSchedule);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pFreeConnectionSchedule", pTransport->m_pFreeConnectionSchedule);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pShutdown", pTransport->m_pShutdown);

        FreeMemory(pTransport);
    }

    return fSuccess;
}

BOOL
Dump_ISM_TRANSPORT_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    ISM_TRANSPORT_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 26;
    ISM_TRANSPORT **      ppTransports;
    DWORD                 iTransport;

    Printf("%sISM_TRANSPORT_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (ISM_TRANSPORT_LIST *) ReadMemory(pvProcess,
                                              sizeof(ISM_TRANSPORT_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_Lock",
               (BYTE *) pvProcess + offsetof(ISM_TRANSPORT_LIST, m_Lock));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hLdap", pList->m_hLdap);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hTransportMonitorThread", pList->m_hTransportMonitorThread);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hSiteMonitorThread", pList->m_hSiteMonitorThread);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_ulTransportNotifyMsgNum", pList->m_ulTransportNotifyMsgNum);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_ulSiteNotifyMsgNum", pList->m_ulSiteNotifyMsgNum);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszTransportContainerDN", pList->m_pszTransportContainerDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszSiteContainerDN", pList->m_pszSiteContainerDN);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hChangeEvent", pList->m_hChangeEvent);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumTransports", pList->m_cNumTransports);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppTransport", pList->m_ppTransport);

        ppTransports = (ISM_TRANSPORT **)
                            ReadMemory(pList->m_ppTransport,
                                       sizeof(ISM_TRANSPORT *)
                                            * pList->m_cNumTransports);
        if (NULL == ppTransports) {
            fSuccess = FALSE;
        }
        else {
            for (iTransport = 0;
                 iTransport < pList->m_cNumTransports;
                 iTransport++) {
                Printf("%sm_ppTransport[%d]:\n",  Indent(nIndents), iTransport);
                if (!Dump_ISM_TRANSPORT(nIndents+1,
                                        ppTransports[iTransport])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppTransports);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_ISM_SERVICE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    ISM_SERVICE *   pService = NULL;
    const DWORD     cchFieldWidth = 24;

    Printf("%sISM_SERVICE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pService = (ISM_SERVICE *) ReadMemory(pvProcess,
                                              sizeof(ISM_SERVICE));

    if (NULL != pService) {
        fSuccess = TRUE;

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized",
               pService->m_fIsInitialized ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsRunningAsService",
               pService->m_fIsRunningAsService ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsStopPending",
               pService->m_fIsStopPending ? "TRUE" : "FALSE");
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsRpcServerListening",
               pService->m_fIsRpcServerListening ? "TRUE" : "FALSE");
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_TransportList",
               (BYTE *) pvProcess + offsetof(ISM_SERVICE, m_TransportList));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hShutdown", pService->m_hShutdown);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hLogLevelChange", pService->m_hLogLevelChange);
        Printf("%s%-*s: %u\n", Indent(nIndents), cchFieldWidth,
               "m_Status", pService->m_Status);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hStatus", pService->m_hStatus);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pServiceCtrlHandler", pService->m_pServiceCtrlHandler);

        FreeMemory(pService);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\ldap.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src - i.e. the mini-directory.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    08-May-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

#include "dsexts.h"
#include "objids.h"
#include "drs.h"
#include "ntdsa.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "mappings.h"
#include "mdlocal.h"
#include "anchor.h"
#include "direrr.h"
#include "filtypes.h"
#include <dsjet.h>
#include "dbintrnl.h"
#include "dsatools.h"
#include "bhcache.h"
#include <winsock2.h>
#include <winldap.h>
#include <atq.h>
#include <ldap.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <ntdsctr.h>
#ifdef __cplusplus
}
#endif //__cplusplus

#define DPRINT4(_x,_a,_b,_c,_d,_e)
#define Assert(_x)  
#undef new
#undef delete
#include <const.hxx>
#include <limits.hxx>
#include <cache.hxx>
#include <connect.hxx>
#include <request.hxx>
#include <secure.hxx>
#include <userdata.hxx>
#include <ldaptype.hxx>
#include <globals.hxx>

#define TF(exp) ( exp ? "TRUE" : "FALSE" )


BOOL
Dump_USERDATA(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Dumps an LDAP_CONN object.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LDAP_CONN in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PLDAP_CONN      pUDd = NULL;
    PLDAP_CONN      pLdapConnUserSpace;
    DWORD           i;
    char            *c;
    SOCKADDR_IN     *pSockAddr;
    IN_ADDR         InetAddr;
    
    Printf("%sUSER_DATA\n", Indent(nIndents));
    nIndents++;

    pLdapConnUserSpace = (PLDAP_CONN)pvProcess;
    if (NULL != (pUDd = (PLDAP_CONN)ReadMemory(pvProcess,
                                               sizeof(LDAP_CONN))))
    {
        c = (char *)&pUDd->m_signature;
        Printf("%sSignature = %c%c%c%c\n", Indent(nIndents), c[0], c[1], c[2], c[3]);
        Printf("%sIs UDP connection %s\n",Indent(nIndents),TF(pUDd->m_fUDP));
        Printf("%sIs SSL connection %s\n",Indent(nIndents),TF(pUDd->m_fSSL));
        Printf("%sIs TLS connection %s\n",Indent(nIndents),TF(pUDd->m_fTLS));
        Printf("%sIs GC connection  %s\n",Indent(nIndents),TF(pUDd->m_fGC));

        Printf("%sSealing Enabled   %s\n",Indent(nIndents),TF(pUDd->m_fSeal));
        Printf("%sSigning Enabled   %s\n",Indent(nIndents),TF(pUDd->m_fSign));

        Printf("\n");
        Printf("%sDigest Bind       %s\n",Indent(nIndents),TF(pUDd->m_fDigest));

        Printf("%sSimple Bind       %s\n",Indent(nIndents),TF(pUDd->m_fSimple));
        Printf("%sGSSAPI Bind       %s\n",Indent(nIndents),TF(pUDd->m_fGssApi));
        Printf("%sSPNEGO Bind       %s\n",Indent(nIndents),TF(pUDd->m_fSpNego));

        Printf("\n");
        Printf("%sCanScatterGather  %s\n",Indent(nIndents),TF(pUDd->m_fCanScatterGather));
        Printf("%sNeedsHeader       %s\n",Indent(nIndents),TF(pUDd->m_fNeedsHeader));
        Printf("%sNeedsTrailer      %s\n",Indent(nIndents),TF(pUDd->m_fNeedsTrailer));

        Printf("%sVersion                       %d\n",
               Indent(nIndents),pUDd->m_Version);
        Printf("%sClientID                      %d\n",
               Indent(nIndents),pUDd->m_dwClientID);
        Printf("%sm_listEntry                 @ %p\n", Indent(nIndents), &pUDd->m_listEntry);
        Printf("%sm_cipherStrength =            %d\n", Indent(nIndents), pUDd->m_cipherStrength);

        switch(pUDd->m_CodePage) {
        case CP_UTF8:
            Printf("%sUTF-8 code page\n",Indent(nIndents));
            break;

        case CP_ACP:
            Printf("%sACP code page\n",Indent(nIndents));
            break;

        default:
            Printf("%sUnknown code page (0x%X)\n",
                   Indent(nIndents),pUDd->m_CodePage);
            break;
        }
        
        Printf("%sReferences                    %d\n",
               Indent(nIndents),pUDd->m_RefCount);
        
        Printf("%sCurrently servicing %d calls ",
               Indent(nIndents), pUDd->m_nRequests);
        
        switch(pUDd->m_CallState) {
        case inactive:
            Printf("(no binds)\n");
            break;
        case activeNonBind:
            Printf("(Odd, active-non-bind is set)\n");
            break;
        case activeBind:
            Printf("(1 bind)\n");
            break;
        default:
            Printf("(Unknown Call State-%d)\n",pUDd->m_CallState);
            break;
        }
        
        Printf("%sm_nTotalRequests        =     %d\n",
               Indent(nIndents), pUDd->m_nTotalRequests);
        Printf("%sState  =           ", Indent(nIndents));
        switch(pUDd->m_State) {
        case BlockStateInvalid:
            Printf("BlockStateInvalid");
            break;
        case BlockStateCached:
            Printf("BlockStateCached");
            break;
        case BlockStateActive:
            Printf("BlockStateActive");
            break;
        case BlockStateClosed:
            Printf("BlockStateClosed");
            break;
        default:
            Printf("Unknown Block State");
        }
        Printf("\n");

        Printf("%sm_requestObject              @ %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_requestObject);
        Printf("%sRequest                     @ %p\n",
               Indent(nIndents),pUDd->m_request);
        Printf("%sRequest List                @ %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_requestList);
        Printf("%sRequest List Critical Section %p\n",
               Indent(nIndents),&pLdapConnUserSpace->m_csLock);
        Printf("%spAtqContext                 @ %p\n",
               Indent(nIndents),pUDd->m_atqContext);
        
        Printf("%sNotifications               @ %p\n",
               Indent(nIndents),pUDd->m_Notifications);
        Printf("%sNotify Count                  %d\n",
               Indent(nIndents),pUDd->m_countNotifies);

        Printf("%sCookie count                  %d\n",
               Indent(nIndents),pUDd->m_CookieCount);
        Printf("%sCooke list head             @ %p\n",
               Indent(nIndents), &pLdapConnUserSpace->m_CookieList);

        Printf("%sSecurity Context            @ %X\n",
               Indent(nIndents), pUDd->m_pSecurityContext);
        Printf("%sSSL State                     %X\n",
               Indent(nIndents),pUDd->m_SslState);
        Printf("%sSSL Security Context          %X\n",
               Indent(nIndents),pUDd->m_hSslSecurityContext);
        Printf("%sUserName Buffer               %X\n",
               Indent(nIndents),pUDd->m_userName);
        Printf("%sm_bIsAdmin              =     %s\n",
               Indent(nIndents), TF(pUDd->m_bIsAdmin));
        Printf("%sm_csLock                    @ %p\n",
               Indent(nIndents), &pUDd->m_csLock);
        
        pSockAddr = (SOCKADDR_IN *)&(pUDd->m_RemoteSocket);
        InetAddr.S_un.S_addr = ntohl(pSockAddr->sin_addr.S_un.S_addr);

        Printf("%sRemote Socket = ip %d.%d.%d.%d port - %d\n",
            Indent(nIndents), InetAddr.S_un.S_un_b.s_b4,InetAddr.S_un.S_un_b.s_b3,
            InetAddr.S_un.S_un_b.s_b2,InetAddr.S_un.S_un_b.s_b1,ntohs(pSockAddr->sin_port));

        Printf("%sm_MsgIdsPos                 = %d\n",
               Indent(nIndents), pUDd->m_MsgIdsPos);

        if (!pUDd->m_fUDP) {
        
            Printf("%sMsgIds:\n", Indent(nIndents));
            i = 0;
            while (i < MSGIDS_BUFFER_SIZE) {
                Printf("%s", Indent(nIndents));

                while ( (((i+1) % 10) != 0) && (i < MSGIDS_BUFFER_SIZE)) {

                    if ( (i + 1) == pUDd->m_MsgIdsPos ) {
                        // We are positioned right before the current position pointer.
                        Printf("(");
                    } else if (i == pUDd->m_MsgIdsPos && (i % 10) != 0) {
                        // We are positioned right after the current position pointer, 
                        // but not at the begginning of a new line.
                        Printf(")");
                    } else {
                        Printf(" ");
                    }
                    
                    Printf("%.4x", pUDd->m_MsgIds[i]);

                    i++;
                }
                // Take care of the last entry on the line.
                if (i < MSGIDS_BUFFER_SIZE) {
                    if ( (i + 1) == pUDd->m_MsgIdsPos ) {
                        Printf("(");
                    } else if (i == pUDd->m_MsgIdsPos) {
                        Printf(")");
                    } else {
                        Printf(" ");
                    }
                    
                    Printf("%.4x", pUDd->m_MsgIds[i]);

                    if ( (i + 1) == pUDd->m_MsgIdsPos) {
                        // We are at the end of a line, so if this is the current
                        // positon, print the close paren now.
                        Printf(")");
                    }
                    i++;
                }
                Printf("\n");
            }
        }

        FreeMemory(pUDd);
        fSuccess = TRUE;
    }

    return(fSuccess);
}



BOOL
Dump_USERDATA_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA_list dump routine.  Dumps a list of LDAP_CONN's.  The most useful of which
    is the ntdsa!ActiveConnectionsList

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of LDAP_CONN list head in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = TRUE;
    PLDAP_CONN pUDd = NULL;                  // Debugger pointer to LDAP_CONN.
    PVOID           pUD;                     // Process pointer to LDAP_CONN.
    DWORD           count=0;
    LIST_ENTRY      *pActiveConnectionsList; // Debugger pointer.
    LIST_ENTRY      *pFlink;                 // Should always contain process pointers.
    SOCKADDR_IN     *pSockAddr;
    IN_ADDR         InetAddr;

    
    Printf("%sUSER_DATA list\n", Indent(nIndents));
    nIndents++;

    if (NULL != 
        (pActiveConnectionsList = (LIST_ENTRY*)ReadMemory(pvProcess, sizeof(LIST_ENTRY))))
    {
        pFlink = pActiveConnectionsList->Flink;
        Printf("\n%spvProcess = %p, ActiveConnectionsList = %p, Blink = %p\n",
            Indent(nIndents), pvProcess, pActiveConnectionsList, pActiveConnectionsList->Blink);

        while (pFlink != pvProcess) {

            if (NULL !=
                (pUDd = (PLDAP_CONN)ReadMemory(pUD = CONTAINING_RECORD(pFlink, LDAP_CONN, m_listEntry), sizeof(LDAP_CONN))))
            {

                Printf("\n%s%d) @ %X\n",Indent(nIndents),++count,pUD);

                Printf("%sFlink = %p\n",Indent(nIndents), pFlink);

                Printf("%sIs UDP connection = %s\n",Indent(nIndents),TF(pUDd->m_fUDP));
                Printf("%sIs SSL connection = %s\n",Indent(nIndents),TF(pUDd->m_fSSL));
                Printf("%sIs GC connection  = %s\n",Indent(nIndents),TF(pUDd->m_fGC));
                Printf("%sIs TLS connection = %s\n",Indent(nIndents),TF(pUDd->m_fTLS));
                Printf("%sDigest Bind       = %s\n",Indent(nIndents),TF(pUDd->m_fDigest));

                Printf("%sClientID                      %d\n",
                       Indent(nIndents),pUDd->m_dwClientID);

                Printf("%sReferences                    %d\n",
                       Indent(nIndents),pUDd->m_RefCount);

                Printf("%sCurrently servicing %d calls\n",
                       Indent(nIndents), pUDd->m_nRequests);
                Printf("%sm_nTotalRequests        =     %d\n",
                       Indent(nIndents), pUDd->m_nTotalRequests);

                pSockAddr = (SOCKADDR_IN *)&(pUDd->m_RemoteSocket);
                InetAddr.S_un.S_addr = ntohl(pSockAddr->sin_addr.S_un.S_addr);

                Printf("%sRemote Socket = ip %d.%d.%d.%d port - %d\n",
                    Indent(nIndents), InetAddr.S_un.S_un_b.s_b4,InetAddr.S_un.S_un_b.s_b3,
                    InetAddr.S_un.S_un_b.s_b2,InetAddr.S_un.S_un_b.s_b1,ntohs(pSockAddr->sin_port));
 
                pFlink = pUDd->m_listEntry.Flink;
                FreeMemory(pUDd);
            } else {
                Printf("%sThe list is corrupt, aborting!\n",Indent(nIndents));
                fSuccess = FALSE;
                break;
            }
            if (5000 < count) {
                Printf("%sASSUMING LOOP: Too many LDAP_CONN's, must be in a loop, exiting.", Indent(nIndents));
                fSuccess = FALSE;
                break;
            }
        }
        FreeMemory(pActiveConnectionsList);
    } else {
        Printf("%sBad pointer for ActiveConnectionsList!\n",Indent(nIndents));
        fSuccess = FALSE;
    }

    return(fSuccess);
}



BOOL
Dump_REQUEST(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dump routine for an LDAP_REQUEST structure.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of an LDAP_REQUEST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLDAP_REQUEST   pReq = NULL;
    char            *c;
    
    Printf("%sREQUEST\n", Indent(nIndents));
    nIndents++;
    
    if (NULL != (pReq = (PLDAP_REQUEST)ReadMemory(pvProcess,
                                                  sizeof(LDAP_REQUEST))))
        {
            c = (char *)&pReq->m_signature;
            Printf("%sSignature = %c%c%c%c\n", Indent(nIndents), c[0], c[1], c[2], c[3]);

            Printf("%sMessageID                     %d\n",
               Indent(nIndents),pReq->m_MessageId);            

            if(pReq->m_fAbandoned) {
                Printf("%sMarked as abandonded\n",Indent(nIndents));
            }
            else {
                Printf("%sNot marked as abandonded\n",Indent(nIndents));
            }
            Printf("\n");
            Printf("%sIs SSL Connection       = %s\n",Indent(nIndents),TF(pReq->m_fSSL));
            Printf("%sIs TLS Connection       = %s\n",Indent(nIndents),TF(pReq->m_fTLS));
            Printf("%sIs Sign/Seal Connection = %s\n",Indent(nIndents),TF(pReq->m_fSignSeal));
            Printf("%sCanScatterGather        = %s\n",Indent(nIndents),TF(pReq->m_fCanScatterGather));
            Printf("%sNeedsHeader             = %s\n",Indent(nIndents),TF(pReq->m_fNeedsHeader));
            Printf("%sHeader Size             = %d bytes\n",Indent(nIndents),TF(pReq->m_HeaderSize));
            Printf("%sNeedsTrailer            = %s\n",Indent(nIndents),TF(pReq->m_fNeedsTrailer));
            Printf("%sTrailer Size            = %d bytes\n",Indent(nIndents),TF(pReq->m_TrailerSize));

            if(pReq->m_fDeleteBuffer) {
                Printf("%sReceive buffer will be deleted.\n",Indent(nIndents));
            }
            else {
                Printf("%sReceive buffer won't be deleted.\n",Indent(nIndents));
            }
            
            Printf("%scchReceiveBufferUsed          %d\n",
                   Indent(nIndents),pReq->m_cchReceiveBufferUsed);
            Printf("%scchReceiveBuffer              %d\n",
                   Indent(nIndents),pReq->m_cchReceiveBuffer);            
            Printf("%spReceiveBuffer              @ %X\n",
                   Indent(nIndents),pReq->m_pReceiveBuffer);            
            Printf("%sEmbedded Receive Buffer     @ %X\n",
                   Indent(nIndents),
                   ((DWORD_PTR)pvProcess + OFFSET(LDAP_REQUEST,m_ReceiveBuffer)));

            Printf("%sWsaBufferCount                %d\n",
                   Indent(nIndents),pReq->m_wsaBufCount);            
            Printf("%sWsaBuf                        %x\n",
                   Indent(nIndents),pReq->m_wsaBuf);            
            Printf("%sCurrentBufferPtr               %x\n",
                   Indent(nIndents),pReq->m_nextBufferPtr);            
            
            Printf("%spAtqContext                   %X\n",
                   Indent(nIndents),pReq->m_patqContext);
            Printf("%spLdapConn                   @ %p\n",
                   Indent(nIndents),pReq->m_LdapConnection);
            
            FreeMemory(pReq);
            fSuccess = TRUE;
        }
    
    return(fSuccess);
} // DUMP request


BOOL
Dump_REQUEST_list(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Prints a summary of all the requests in a list.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of the head of a list of LDAP_REQUESTs.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = TRUE;
    PLDAP_REQUEST   pReqProc = NULL;        // Request in process memory.
    LIST_ENTRY      *pListEntryDeb = NULL;  // List entry in debugger memory.
    LIST_ENTRY      *pListEntryProc = NULL; // List entry in process memory.
    LIST_ENTRY      *pListHeadDeb = NULL;   // List head in debugger memory.
    DWORD           dwReqCount = 1;

    Printf("%sREQUEST list\n", Indent(nIndents));
    nIndents++;
    
    pListHeadDeb = (LIST_ENTRY *) ReadMemory(pvProcess, sizeof(LIST_ENTRY));
    if (!pListHeadDeb) {
        Printf("%sUnable to read list head @ %p\n", Indent(nIndents), pvProcess);
        return FALSE;
    }

    pListEntryProc = pListHeadDeb->Flink;
    FreeMemory(pListHeadDeb);
    if (pListEntryProc == pvProcess) {
        Printf("%sThe list is empty.\n", Indent(nIndents));
        return TRUE;
    }

    while (pListEntryProc != pvProcess) {
        pReqProc = CONTAINING_RECORD(pListEntryProc, LDAP_REQUEST, m_listEntry);
        Printf("%s%d) @ %p\n", Indent(nIndents), dwReqCount, pReqProc);
        nIndents++;

        if (!Dump_REQUEST(nIndents, pReqProc)) {
            nIndents--;
            fSuccess = FALSE;
            Printf("%sFailed to print Request @ %p\n", Indent(nIndents), pReqProc);
            break;
        } 
        
        nIndents--;
        pListEntryDeb = (LIST_ENTRY *) ReadMemory(pListEntryProc, sizeof(LIST_ENTRY));

        if (!pListEntryDeb) {
            fSuccess = FALSE;
            Printf("%sFailed to read next Request list entry @ %p\n", Indent(nIndents), pListEntryProc);
            break;
        }

        pListEntryProc = pListEntryDeb->Flink;
        FreeMemory(pListEntryDeb);
        dwReqCount++;
    }

    return fSuccess;
}



BOOL
Dump_LIMITS(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Extremely hacky.  Assumes way too much about
    the internals of a USERDATA object because it's a c++ thing, and I don't
    know how to deal with that cleanly here.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLIMIT_BLOCK    pBlock = NULL;
    BOOL            ok = TRUE;
    CHAR            name[MAX_PATH+1];        
    Printf("%sLIMITS\n", Indent(nIndents));
    nIndents++;
    
    do {

        if (NULL != (pBlock = (PLIMIT_BLOCK)ReadMemory(pvProcess,
                                                   sizeof(LIMIT_BLOCK)))) {
            
            PCHAR   pName;
            PDWORD  pLimit;
            DWORD   MinLimit;
            DWORD   MaxLimit;

            if ( pBlock->Limit != NULL ) {

                if (NULL != (pName = (PCHAR)ReadMemory(
                                                pBlock->Name.value,
                                                pBlock->Name.length))) {


                    if (NULL != (pLimit = (PDWORD)ReadMemory(
                                                    pBlock->Limit,
                                                    sizeof(DWORD)))) {

                        CopyMemory(name, pName, pBlock->Name.length);
                        name[pBlock->Name.length] = '\0';
                        Printf("%s%-23s  %8d\t(min: %d, max: %d)\n",
                               Indent(nIndents),
                               name,
                               *pLimit,
                               pBlock->MinLimit,
                               pBlock->MaxLimit);
                        FreeMemory(pLimit);
                    }
                    FreeMemory(pName);
                }
                pvProcess = (PCHAR)pvProcess + sizeof(LIMIT_BLOCK);
            } else {
                ok = FALSE;
            }
            FreeMemory(pBlock);
            fSuccess = TRUE;
        }
    
    } while ( ok && (pBlock != NULL) );
    return(fSuccess);

} // Dump LIMITS



BOOL
Dump_PAGED(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USER_DATA dump routine.  Extremely hacky.  Assumes way too much about
    the internals of a USERDATA object because it's a c++ thing, and I don't
    know how to deal with that cleanly here.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    
    BOOL            fSuccess = FALSE;
    PLIST_ENTRY     ListEntry;
    PLIST_ENTRY     headList, ulo;
    BOOL            ok = TRUE;
    CHAR            name[MAX_PATH+1];        
    PLDAP_PAGED_BLOB    pPaged;
    PCHAR pTmp;

    Printf("%sPaged Cookies\n", Indent(nIndents));
    nIndents++;
    
    headList = (PLIST_ENTRY)pvProcess;

    do {

        if (NULL != (ListEntry = (PLIST_ENTRY)ReadMemory(pvProcess,
                                                       sizeof(LIST_ENTRY)))) {
                
            if ( ListEntry->Flink != headList ) {


                pTmp = (PCHAR)CONTAINING_RECORD(ListEntry->Flink,
                                        LDAP_PAGED_BLOB,
                                        ListEntry
                                        );

                pPaged = (PLDAP_PAGED_BLOB)ReadMemory(pTmp,
                                    sizeof(LDAP_PAGED_BLOB));

                if ( pPaged != NULL ) {
                    
                    Printf("%sCookie   %x\n",Indent(nIndents),pTmp);
                    Printf("%sBlobId   %d\n",Indent(nIndents),pPaged->BlobId);
                    Printf("%sBlobSize %d\n",Indent(nIndents),pPaged->BlobSize);
                    Printf("%sLdapConn %x\n",Indent(nIndents),pPaged->LdapConn);
                    Printf("%sBlob     %x\n\n",Indent(nIndents),
                           ((PLDAP_PAGED_BLOB)pTmp)->Blob);

                    pvProcess = ListEntry->Flink;
                    FreeMemory(pPaged);
                } else {
                    ok = FALSE;
                }

            } else {
                ok = FALSE;
            }

            FreeMemory(ListEntry);
            fSuccess = TRUE;
        } else {
            ok = FALSE;
        }
    } while ( ok );

    return(fSuccess);

} // Dump PAGED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\dsexts.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsexts.c

Abstract:

    Implements public entry points for the DS ntsd/windbg extensions DLL.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry() into rDumpItems

    24-Apr-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop
#include "dsexts.h"
#include <ntverp.h>
#include <debug.h>

//
// Globals
//

PNTSD_EXTENSION_APIS    gpExtApis;
HANDLE                  ghDbgThread;
HANDLE                  ghDbgProcess;
LPSTR                   gpszCommand;
BOOL                    gfVerbose = FALSE;

//
// Dump declarations.  A new element should be added to rDumpItems[] for each
// new type which the extension knows how to dump.  The help entry point
// automatically generates help based on ?DumpItems as well.
//
// Individual dump functions return a BOOL success code so that dump functions
// can call each other and break out on error.  I.e. as soon as the first
// nested dump function encounters a bogus pointer, for example.  First
// argument (DWORD) indicates indentation level, second argument (PVOID) is
// address of struct in address space of process being debugged.  This way
// Dump_* routines can easily construct an indented output by incrementing the
// indentation level and calling one another.
//
// Dump functions should dump all values in hex for consistency - i.e. "%x".
//

typedef struct _DumpItem {
    CHAR    *pszType;
    BOOL    (*pFunc)(DWORD nIndents, PVOID pvProcess);
} DumpItem;

DumpItem rDumpItems[] = {
    { "AddArg",                         Dump_AddArg},
    { "AddRes",                         Dump_AddRes},
    { "AO",                             Dump_AO},
    { "AOLIST",                         Dump_AOLIST},
    { "ATQ_CONTEXT",                    Dump_ATQ_CONTEXT},
    { "ATQ_ENDPOINT",                   Dump_ATQ_ENDPOINT},
    { "ATQC_ACTIVE_list",               Dump_ATQC_ACTIVE_list},
    { "ATQC_PENDING_list",              Dump_ATQC_PENDING_list},
    { "ATTCACHE",                       Dump_ATTCACHE},
    { "ATTR",                           Dump_Attr},
    { "ATTRBLOCK",                      Dump_AttrBlock},
    { "ATTRVALBLOCK",                   Dump_AttrValBlock},
    { "BackupContext",                  Dump_BackupContext},
    { "BHCache",                        Dump_BHCache},
    { "Binary",                         Dump_Binary},
    { "BINDARG",                        Dump_BINDARG},
    { "BINDRES",                        Dump_BINDRES},
    { "CLASSCACHE",                     Dump_CLASSCACHE},
    { "COMMARG",                        Dump_CommArg},
    { "CONTEXT",                        Dump_Context},
    { "CONTEXTLIST",                    Dump_ContextList},
    { "d_memname",                      Dump_d_memname},
    { "d_tagname",                      Dump_d_tagname},
    { "DBPOS",                          Dump_DBPOS},
    { "DirWaitArray64",                 Dump_DirWaitArray64},
    { "DirWaitArray256",                Dump_DirWaitArray256},
    { "DirWaitHead",                    Dump_DirWaitHead},
    { "DirWaitItem",                    Dump_DirWaitItem},
    { "GLOBALDNREADCACHE",              Dump_GLOBALDNREADCACHE},
    { "LOCALDNREADCACHE",               Dump_LOCALDNREADCACHE},
    { "DefinedDomain",                  Dump_DefinedDomain},
    { "DefinedDomains",                 Dump_DefinedDomains},
    { "DRS_ASYNC_RPC_STATE",            Dump_DRS_ASYNC_RPC_STATE},
    { "DRS_MSG_GETCHGREQ_V4",           Dump_DRS_MSG_GETCHGREQ_V4},
    { "DRS_MSG_GETCHGREQ_V5",           Dump_DRS_MSG_GETCHGREQ_V5},
    { "DRS_MSG_GETCHGREQ_V8",           Dump_DRS_MSG_GETCHGREQ_V8},
    { "DRS_MSG_GETCHGREPLY_V1",         Dump_DRS_MSG_GETCHGREPLY_V1},
    { "DRS_MSG_GETCHGREPLY_V3",         Dump_DRS_MSG_GETCHGREPLY_V3},
    { "DRS_MSG_GETCHGREPLY_V5",         Dump_DRS_MSG_GETCHGREPLY_V5},
    { "DRS_MSG_GETCHGREPLY_V6",         Dump_DRS_MSG_GETCHGREPLY_V6},
    { "DRS_MSG_GETCHGREPLY_VALUES",     Dump_DRS_MSG_GETCHGREPLY_VALUES},
    { "DSA_ANCHOR",                     Dump_DSA_ANCHOR},
    { "DSNAME",                         Dump_DSNAME},
    { "DynArray",                       Dump_DynArray},
    { "ENTINF",                         Dump_ENTINF},
    { "ENTINFSEL",                      Dump_ENTINFSEL},
    { "EscrowInfo",                     Dump_EscrowInfo},
    { "FILTER",                         Dump_FILTER},
    { "GCDeletionList",                 Dump_GCDeletionList},
    { "GCDeletionListProcessed",        Dump_GCDeletionListProcessed},
    { "GUID",                           Dump_UUID},
    { "INDEXSIZE",                      Dump_INDEXSIZE},
    { "INITSYNC",                       Dump_INITSYNC},
    { "ISM_PENDING_ENTRY",              Dump_ISM_PENDING_ENTRY},
    { "ISM_PENDING_LIST",               Dump_ISM_PENDING_LIST},
    { "ISM_SERVICE",                    Dump_ISM_SERVICE},
    { "ISM_TRANSPORT",                  Dump_ISM_TRANSPORT},
    { "ISM_TRANSPORT_LIST",             Dump_ISM_TRANSPORT_LIST},
    { "JETBACK_SERVER_CONTEXT",         Dump_JETBACK_SERVER_CONTEXT},
    { "JETBACK_SHARED_CONTROL",         Dump_JETBACK_SHARED_CONTROL},
    { "JETBACK_SHARED_HEADER",          Dump_JETBACK_SHARED_HEADER},
    { "KCC_BRIDGE",                     Dump_KCC_BRIDGE},
    { "KCC_BRIDGE_LIST",                Dump_KCC_BRIDGE_LIST},
    { "KCC_DS_CACHE",                   Dump_KCC_DS_CACHE},
    { "KCC_CONNECTION",                 Dump_KCC_CONNECTION},
    { "KCC_CROSSREF",                   Dump_KCC_CROSSREF},
    { "KCC_CROSSREF_LIST",              Dump_KCC_CROSSREF_LIST},
    { "KCC_DSA",                        Dump_KCC_DSA},
    { "KCC_DSA_LIST",                   Dump_KCC_DSA_LIST},
    { "KCC_DSNAME_ARRAY",               Dump_KCC_DSNAME_ARRAY},
    { "KCC_DSNAME_SITE_ARRAY",          Dump_KCC_DSNAME_SITE_ARRAY},
    { "KCC_INTERSITE_CONNECTION_LIST",  Dump_KCC_INTERSITE_CONNECTION_LIST},
    { "KCC_INTRASITE_CONNECTION_LIST",  Dump_KCC_INTRASITE_CONNECTION_LIST},
    { "KCC_REPLICATED_NC",              Dump_KCC_REPLICATED_NC},
    { "KCC_REPLICATED_NC_ARRAY",        Dump_KCC_REPLICATED_NC_ARRAY},
    { "KCC_SITE",                       Dump_KCC_SITE},
    { "KCC_SITE_ARRAY",                 Dump_KCC_SITE_ARRAY},
    { "KCC_SITE_LINK",                  Dump_KCC_SITE_LINK},
    { "KCC_SITE_LINK_LIST",             Dump_KCC_SITE_LINK_LIST},
    { "KCC_SITE_LIST",                  Dump_KCC_SITE_LIST},
    { "KCC_TRANSPORT",                  Dump_KCC_TRANSPORT},
    { "KCC_TRANSPORT_LIST",             Dump_KCC_TRANSPORT_LIST},
    { "KEY",                            Dump_KEY},
    { "KEY_INDEX",                      Dump_KEY_INDEX},
    { "LDAP_CONN",                      Dump_USERDATA},
    { "LDAP_CONN_list",                 Dump_USERDATA_list},
    { "LIMITS",                         Dump_LIMITS},
    { "MODIFYARG",                      Dump_MODIFYARG},
    { "MODIFYDNARG",                    Dump_MODIFYDNARG},
    { "MTX_ADDR",                       Dump_MTX_ADDR},
    { "NCSYNCDATA",                     Dump_NCSYNCDATA},
    { "NCSYNCSOURCE",                   Dump_NCSYNCSOURCE},
    { "PAGED",                          Dump_PAGED},
    { "PARTIAL_ATTR_VECTOR",            Dump_PARTIAL_ATTR_VECTOR},
    { "PROPERTY_META_DATA_EXT_VECTOR",  Dump_PROPERTY_META_DATA_EXT_VECTOR},
    { "PROPERTY_META_DATA_VECTOR",      Dump_PROPERTY_META_DATA_VECTOR},
    { "ProxyVal",                       Dump_ProxyVal},
    { "PSCHEDULE",                      Dump_PSCHEDULE},
    { "ReadArg",                        Dump_ReadArg},
    { "ReadRes",                        Dump_ReadRes},
    { "RemoveArg",                      Dump_RemoveArg},
    { "RemoveRes",                      Dump_RemoveRes},
    { "REPLENTINFLIST",                 Dump_REPLENTINFLIST},
    { "REPLICA_LINK",                   Dump_REPLICA_LINK},
    { "ReplNotifyElement",              Dump_ReplNotifyElement},
    { "REPLTIMES",                      Dump_REPLTIMES},
    { "REPLVALINF",                     Dump_REPLVALINF},
    { "REQUEST",                        Dump_REQUEST},
    { "REQUEST_list",                   Dump_REQUEST_list},
    { "SAMP_LOOPBACK_ARG",              Dump_SAMP_LOOPBACK_ARG},
    { "SearchArg",                      Dump_SearchArg},
    { "SearchRes",                      Dump_SearchRes},
    { "SCHEMAPTR",                      Dump_SCHEMAPTR},
    { "SCHEMA_PREFIX_TABLE",            Dump_SCHEMA_PREFIX_TABLE},
    { "SD",                             Dump_SD},
    { "SID",                            Dump_Sid},
    { "SPROPTAG",                       Dump_SPropTag},
    { "SROWSET",                        Dump_SRowSet},
    { "STAT",                           Dump_STAT},
    { "SUBSTRING",                      Dump_SUBSTRING},
    { "THSTATE",                        Dump_THSTATE},
    { "TOPL_MULTI_EDGE",                Dump_TOPL_MULTI_EDGE},
    { "TOPL_MULTI_EDGE_SET",            Dump_TOPL_MULTI_EDGE_SET},
    { "TOPL_REPL_INFO",                 Dump_TOPL_REPL_INFO},
    { "TOPL_SCHEDULE",                  Dump_TOPL_SCHEDULE},
    { "ToplGraphState",                 Dump_ToplGraphState},
    { "ToplInternalEdge",               Dump_ToplInternalEdge},
    { "ToplVertex",                     Dump_ToplVertex},
    { "TransactionalData",              Dump_TransactionalData},
    { "UPTODATE_VECTOR",                Dump_UPTODATE_VECTOR},
    { "USN_VECTOR",                     Dump_USN_VECTOR},
    { "USER_DATA",                      Dump_USERDATA},
    { "USER_DATA_list",                 Dump_USERDATA_list},
    { "UUID",                           Dump_UUID},
    { "VALUE_META_DATA",                Dump_VALUE_META_DATA},
    { "VALUE_META_DATA_EXT",            Dump_VALUE_META_DATA_EXT},
};

DWORD cDumpItems = sizeof(rDumpItems) / sizeof(DumpItem);

DEBUG_EXT(help)

/*++

Routine Description:

    Extensions DLL "help" entry point.  Dumps a synopsis of permissible
    commands.

Arguments:

    See DEBUG_EXT macro in dbexts.h.

Return Value:

    None.

--*/

{
    DWORD i = VER_PRODUCTBUILD;

    INIT_DEBUG_EXT;

    Printf("\n\t*** NT DS Debugger Extensions - v%u ***\n\n", i);
    Printf("\thelp            - prints this help\n");
    Printf("\tdprint cmd arg  - controls DS DPRINT behavior\n");
    Printf("\t\twhere cmd is one of: help, show,level, add, remove, thread\n");
    Printf("\tdump type addr  - dumps object of 'type' at 'addr'\n");
    Printf("\t\tuse 'dump help' for list of types\n");
    Printf("\tassert [cmd]    - controls disabled asserts\n" );
}

void
Dump_Help(void)
{
    DWORD i;

    Printf("\tdump type addr  - dumps object of 'type' at 'addr'\n");
    Printf("\t\twhere type is one of:\n");

    for ( i = 0; i < cDumpItems; i++ )
    {
        Printf("\t\t\t%s\n", rDumpItems[i].pszType);
    }
}

DWORD ExceptionHandler(DWORD dwException, LPEXCEPTION_POINTERS pInfo){

   Printf("Exception 0x%x: dsexts exception failure.\n", dwException);
   if ( pInfo ) {
       Printf("\tContextRecord   :    0x%p\n"       \
              "\tExceptionRecord :    0x%p\n",
              pInfo->ContextRecord,
              pInfo->ExceptionRecord );
   }

   return EXCEPTION_EXECUTE_HANDLER;
}

DEBUG_EXT(dump)

/*++

Routine Description:

    Extensions DLL "dump" entry point.  Dumps a struct or object in
    human readable form.

Arguments:

    See DEBUG_EXT macro in dbexts.h.

Return Value:

    None.

--*/

{
    CHAR    *pszType;
    VOID    *pvProcess;
    CHAR    *pszToken;
    CHAR    *pszDelimiters = " \t";
    DWORD   i;
    CHAR    *p;
    STRING  str1, str2;
    BOOL    fGoodSyntax = FALSE;

    INIT_DEBUG_EXT;

    __try {
        //
        // Derive object type and dump address from command line.
        // First token in gpszCommand is the type of object/struct to dump.
        //

        if ( NULL != (pszType = strtok(gpszCommand, pszDelimiters)) )
        {
            //
            // Second token is the address to dump.
            //

            if ( NULL != (pszToken = strtok(NULL, pszDelimiters)) )
            {
                //
                // Convert token to address.
                //

                if ( NULL != (pvProcess = (VOID *) GetExpr(pszToken)) )
                {
                    //
                    // Verify there is no third token.
                    //

                    if ( NULL == strtok(NULL, pszDelimiters) )
                    {
                        fGoodSyntax = TRUE;
                    }
                }
            }
            else {
                // No address, see if type was "help"
                if (0 == _strcmpi(pszType, "help")) {
                    Dump_Help();
                    return;
                }
            }
        }

        if ( !fGoodSyntax )
        {
            Printf("Dump command parse error!\n");
            return;
        }

        //
        // Find pszType in rDumpItems[] and call corresponding dump routine.
        //

        for ( i = 0; i < cDumpItems; i++ )
        {
            //
            // Suspect we shouldn't call CRTs in a debugger extension so
            // just use RtlCompareString instead.
            //

            for ( str1.Length = 0, p = pszType; '\0' != *p; p++ )
            {
                str1.Length++;
            }

            str1.MaximumLength = str1.Length;
            str1.Buffer = pszType;

            for ( str2.Length = 0, p = rDumpItems[i].pszType; '\0' != *p; p++ )
            {
                str2.Length++;
            }

            str2.MaximumLength = str2.Length;
            str2.Buffer = rDumpItems[i].pszType;

            if ( !RtlCompareString(&str1, &str2, TRUE) )
            {
                (rDumpItems[i].pFunc)(0, pvProcess);
                break;
            }
        }

        if ( i >= cDumpItems )
        {
            Printf("Dump routine for '%s' not found!\n", pszType);
        }

    }
    __except(ExceptionHandler(GetExceptionCode(), GetExceptionInformation())) {
        //
        // Handle all dump exceptions so that we don't stall in the debugger.
        // we assume that can at least printf in the debugger (prety safe
        // for the most part)
        //
        Printf("Aborting dump function\n");

    }
}


void
AssertHelp(void)
{
    Printf( "\tassert help - this message\n" );
    Printf( "\tassert show - list disabled assertions\n" );
    Printf( "\tassert enable index - enable disabled assertions\n" );
    Printf( "\tassert add filename line - add new disabled assertion\n" );
    Printf( "\t\tUse /m:<module> to specify dll: ntdsa, ntdskcc, ismsmtp, etc\n" );
}

typedef enum _ASSERTOP {
    eInvalid = 0,
    eHelp,
    eShow,
    eEnable,
    eAdd
} ASSERTOP;

typedef struct _ASSERTCMD {
    char      * pszCmd;
    ASSERTOP    op;
} ASSERTCMD;

ASSERTCMD aACmd[] = {
    {"help", eHelp},
    {"show", eShow},
    {"enable", eEnable},
    {"add", eAdd}
};

#define countACmd (sizeof(aACmd)/sizeof(ASSERTCMD))


DEBUG_EXT(assert)

/*++

Routine Description:

Debugger extension entrypoint for the assert command. Handles disabled
assertions.

Arguments:

Standard debugger extension entry signature

Return Value:

    None

--*/

{
    CHAR *pszModule = "ntdsa", *argv[10];
    CHAR *pszDelimiters = " \t";
    DWORD argc, i, j;
    ASSERTOP op;
    ASSERTARG *pvProcess, *pvLocal = NULL;
    CHAR szSymbol[50];
    BOOL fUpdateNeeded = FALSE;

    INIT_DEBUG_EXT;

    // Construct arg vector. Also parse out options.
    argc = 0;
    argv[argc] = strtok(gpszCommand, pszDelimiters);
    while (argv[argc] != NULL) {
        argc++;
        argv[argc] = strtok(NULL, pszDelimiters);

        if ( (NULL != argv[argc]) &&
             (_strnicmp( argv[argc], "/m:", 3 ) == 0) ) {
            pszModule = argv[argc] + 3;
            argv[argc] = strtok(NULL, pszDelimiters);
        }
    }

    // Command is mandatory
    if (argv[0] == NULL) {
        Printf( "subcommand must be specified.\n" );
        AssertHelp();
        return;
    }

    // See which command it is
    op = eInvalid;
    for (i=0; i<countACmd; i++) {
	if (0 == _stricmp(argv[0], aACmd[i].pszCmd)) {
	    op = aACmd[i].op;
	    break;
	}
    }
    if ( (op == eHelp) || (op == eInvalid) ) {
        AssertHelp();
        return;
    }

    // Construct the symbol name of the assertion info structure
    strcpy( szSymbol, pszModule );
    strcat( szSymbol, "!AssertInfo" );
    pvProcess = (ASSERTARG *) GetExpr( szSymbol );
    if (pvProcess == NULL) {
	Printf("Can't locate address of '%s' - sorry\n", szSymbol);
	return;
    }
    pvLocal = (ASSERTARG*)ReadMemory(pvProcess,
				   sizeof(ASSERTARG));
    if (pvLocal == NULL) {
	Printf("Can't read assert arg - sorry\n");
	return;
    }

    // Handle commands
    switch (op) {
    case eShow:
        if (pvLocal->dwCount == 0) {
            Printf( "\tNo assertions are disabled in %s.\n", szSymbol );
            break;
        }
        Printf( "\t%d assertions are disabled in %s.\n",
                pvLocal->dwCount, szSymbol );
        for( i = 0; i < pvLocal->dwCount; i++ ) {
            Printf( "\t%d - %s:%d\n",
                    i,
                    pvLocal->Entry[i].szFile,
                    pvLocal->Entry[i].dwLine );
        }
        break;
    case eEnable:
        if (argv[1] == NULL) {
            Printf( "enable command requires index\n" );
            AssertHelp();
            goto cleanup;
        }
        i = strtoul( argv[1], NULL, 10 );
        if (i >= pvLocal->dwCount) {
            Printf( "index out of range\n" );
            goto cleanup;
        }
        Printf( "\t%d - %s:%d - removed from disabled table in %s\n",
                i,
                pvLocal->Entry[i].szFile,
                pvLocal->Entry[i].dwLine,
                szSymbol);
        // shrink table and write back
        pvLocal->dwCount--;
        for( j = i; j < pvLocal->dwCount; j++ ) {
            pvLocal->Entry[j] = pvLocal->Entry[j+1];
        }
        fUpdateNeeded = TRUE;
        break;
    case eAdd:
        if ( (argv[1] == NULL) || (argv[2] == NULL) ) {
            Printf( "missing command arguments\n" );
            AssertHelp();
            goto cleanup;
        }
        j = strtoul( argv[2], NULL, 10 );
        if (pvLocal->dwCount < MAX_DISABLED_ASSERTIONS) {
            ASSERT_ENTRY *pae = pvLocal->Entry + pvLocal->dwCount;

            strncpy( pae->szFile, argv[1], MAX_ASSERT_FILE_SIZE );
            pae->szFile[MAX_ASSERT_FILE_SIZE] = '\0';
            pae->dwLine = j;
            pvLocal->dwCount++;
            fUpdateNeeded = TRUE;
        } else {
            Printf( "Maximum number of %d disabled assertions has been reached!\n",
                    MAX_DISABLED_ASSERTIONS );
        }
        break;
    default:
	Printf("Invalid command\n");
        AssertHelp();
    }

cleanup:

    if (fUpdateNeeded) {
	if (WriteMemory(pvProcess, pvLocal, sizeof(ASSERTARG))) {
	    Printf("Updated!\n");
	}
	else {
	    Printf("Failed to update\n");
	}
    }
    if (pvLocal) {
        FreeMemory( pvLocal );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\kcc.cxx ===
/*++

Copyright (c) 1999 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    kcc.cxx

ABSTRACT:

    Routines to dump KCC structures.

DETAILS:

CREATED:

    99/01/19    Jeff Parham (jeffparh)

REVISION HISTORY:

--*/

#include <NTDSpch.h>
#pragma hdrstop
#include "kcc.hxx"
#include "kccsite.hxx"
#include "kccdsa.hxx"
#include "kccconn.hxx"
#include "kccsconn.hxx"
#include "kccdynar.hxx"

extern "C" {
#include "dsutil.h"
#include "dsexts.h"
#include "schedman.h"
#include "stalg.h"
#include "stda.h"
}

BOOL
Dump_KCC_SITE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL        fSuccess = FALSE;
    KCC_SITE *  pSite = NULL;
    const DWORD cchFieldWidth = 24;
    CHAR        szTime[SZDSTIME_LEN];

    Printf("%sKCC_SITE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSite = (KCC_SITE *) ReadMemory(pvProcess, sizeof(KCC_SITE));

    if (NULL != pSite) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSite->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pSite->m_dwOptions);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSiteObject", pSite->m_pdnSiteObject);
        if (pSite->m_pdnSiteObject
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnSiteObject)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnNtdsSiteSettings", pSite->m_pdnNtdsSiteSettings);
        if (pSite->m_pdnNtdsSiteSettings
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnNtdsSiteSettings)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSiteGenerator", pSite->m_pdnSiteGenerator);
        if (pSite->m_pdnSiteGenerator
            && !Dump_DSNAME(1 + nIndents, pSite->m_pdnSiteGenerator)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSiteGeneratorDSA", pSite->m_pSiteGeneratorDSA);
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_timeSiteGenSet",
               DSTimeToDisplayString(pSite->m_timeSiteGenSet, szTime));
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pDsaList", pSite->m_pDsaList);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumTransportDsaLists", pSite->m_cNumTransportDsaLists);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pTransportDsaLists", pSite->m_pTransportDsaLists);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_destSiteConnMapSize", pSite->m_destSiteConnMapSize);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pDestSiteConnMap", pSite->m_pDestSiteConnMap);

        FreeMemory(pSite);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_LIST *   pSiteList = NULL;
    const DWORD       cchFieldWidth = 20;

    Printf("%sKCC_SITE_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteList = (KCC_SITE_LIST *) ReadMemory(pvProcess,
                                            sizeof(KCC_SITE_LIST));

    if (NULL != pSiteList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteList->m_fIsInitialized);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteArray));
        fSuccess = Dump_KCC_SITE_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteArray));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteNameArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteNameArray));

//        fSuccess = Dump_KCC_DSNAME_SITE_ARRAY( nIndents + 1,
//               (BYTE *) pvProcess + offsetof(KCC_SITE_LIST, m_SiteNameArray));

        FreeMemory(pSiteList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_ARRAY *  pSiteArray = NULL;
    const DWORD       cchFieldWidth = 20;
    KCC_SITE **       ppSites;
    DWORD             iSite;

    Printf("%sKCC_SITE_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteArray = (KCC_SITE_ARRAY *) ReadMemory(pvProcess,
                                               sizeof(KCC_SITE_ARRAY));

    if (NULL != pSiteArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pSiteArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pSiteArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pSiteArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pSiteArray->m_Array);

        ppSites = (KCC_SITE **) ReadMemory(pSiteArray->m_Array,
                                           sizeof(KCC_SITE *) * pSiteArray->m_Count);
        if (NULL == ppSites) {
            fSuccess = FALSE;
        }
        else {
            for (iSite = 0; iSite < pSiteArray->m_Count; iSite++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iSite);
                if (!Dump_KCC_SITE(nIndents+1, ppSites[iSite])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppSites);
        }

        FreeMemory(pSiteArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSNAME_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_DSNAME_ARRAY *  pArray = NULL;
    const DWORD         cchFieldWidth = 20;
    KCC_DSNAME_SORT_ELEMENT *pElements;
    DWORD               iElem;

    Printf("%sKCC_DSNAME_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_DSNAME_ARRAY *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSNAME_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        pElements = (KCC_DSNAME_SORT_ELEMENT *) ReadMemory(pArray->m_Array,
                                           sizeof(KCC_DSNAME_SORT_ELEMENT) * pArray->m_Count);
        if (NULL == pElements) {
            fSuccess = FALSE;
        } else {
            for (iElem = 0; iElem < pArray->m_Count; iElem++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iElem);
                Printf("%spszStringKey: %p\n",Indent(nIndents+1), pElements[iElem].pszStringKey );
                if (!Dump_DSNAME(nIndents+1, pElements[iElem].pDn)) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(pElements);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSNAME_SITE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_DSNAME_SITE_ARRAY *  pArray = NULL;
    const DWORD         cchFieldWidth = 20;
    KCC_DSNAME_SITE_ELEMENT *pElements;
    DWORD               iElem;

    Printf("%sKCC_DSNAME_SITE_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_DSNAME_SITE_ARRAY *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSNAME_SITE_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        pElements = (KCC_DSNAME_SITE_ELEMENT *) ReadMemory(pArray->m_Array,
                             sizeof(KCC_DSNAME_SITE_ELEMENT) * pArray->m_Count);
        if (NULL == pElements) {
            fSuccess = FALSE;
        } else {
            for (iElem = 0; iElem < pArray->m_Count; iElem++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iElem);
                Printf("%spszStringKey: %p\n",Indent(nIndents+1), pElements[iElem].pszStringKey );
                if (!Dump_KCC_SITE(nIndents+1, pElements[iElem].pSite)) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(pElements);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                   fSuccess = FALSE;
    KCC_SITE_LINK_ARRAY *  pSiteLinkArray = NULL;
    const DWORD            cchFieldWidth = 20;
    KCC_SITE_LINK **       ppSiteLinks;
    DWORD                  iSiteLink;

    Printf("%sKCC_SITE_LINK_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteLinkArray = (KCC_SITE_LINK_ARRAY *) ReadMemory(pvProcess,
                                                        sizeof(KCC_SITE_LINK_ARRAY));

    if (NULL != pSiteLinkArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteLinkArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pSiteLinkArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pSiteLinkArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pSiteLinkArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pSiteLinkArray->m_Array);

        ppSiteLinks = (KCC_SITE_LINK **) ReadMemory(pSiteLinkArray->m_Array,
                                           sizeof(KCC_SITE_LINK *) * pSiteLinkArray->m_Count);
        if (NULL == ppSiteLinks) {
            fSuccess = FALSE;
        }
        else {
            for (iSiteLink = 0; iSiteLink < pSiteLinkArray->m_Count; iSiteLink++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iSiteLink);
                if (!Dump_KCC_SITE_LINK(nIndents+1, ppSiteLinks[iSiteLink])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppSiteLinks);
        }

        FreeMemory(pSiteLinkArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                   fSuccess = FALSE;
    KCC_BRIDGE_ARRAY *     pBridgeArray = NULL;
    const DWORD            cchFieldWidth = 20;
    KCC_BRIDGE **          ppBridges;
    DWORD                  iBridge;

    Printf("%sKCC_BRIDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pBridgeArray = (KCC_BRIDGE_ARRAY *) ReadMemory(pvProcess,
                                                      sizeof(KCC_BRIDGE_ARRAY));

    if (NULL != pBridgeArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pBridgeArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pBridgeArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pBridgeArray->m_Count);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSorted", pBridgeArray->m_fIsSorted);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pBridgeArray->m_Array);

        ppBridges = (KCC_BRIDGE **) ReadMemory(pBridgeArray->m_Array,
                                           sizeof(KCC_BRIDGE *) * pBridgeArray->m_Count);
        if (NULL == ppBridges) {
            fSuccess = FALSE;
        }
        else {
            for (iBridge = 0; iBridge < pBridgeArray->m_Count; iBridge++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iBridge);
                if (!Dump_KCC_BRIDGE(nIndents+1, ppBridges[iBridge])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppBridges);
        }

        FreeMemory(pBridgeArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSA(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_DSA *       pDsa = NULL;
    const DWORD     cchFieldWidth = 22;
    CHAR            szTime[SZDSTIME_LEN];
    DWORD           idn;
    DSNAME **       ppdn;
    KCC_DSA_ADDR *  pAddrs;
    DWORD           iAddr;

    Printf("%sKCC_DSA @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pDsa = (KCC_DSA *) ReadMemory(pvProcess, sizeof(KCC_DSA));

    if (NULL != pDsa) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pDsa->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnDSA", pDsa->m_pdnDSA);
        if (pDsa->m_pdnDSA
            && !Dump_DSNAME(1 + nIndents, pDsa->m_pdnDSA)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cMasterNCs", pDsa->m_cMasterNCs);
        ppdn = (DSNAME **) ReadMemory(pDsa->m_ppdnMasterNCs,
                                  sizeof(DSNAME *) * pDsa->m_cMasterNCs);
        if (NULL == ppdn) {
            fSuccess = FALSE;
        }
        else {
            for( idn = 0; idn < pDsa->m_cMasterNCs; idn++ ) {
                Printf("%sm_ppdnMasterNCs[%d]:\n",  Indent(nIndents), idn);
                if (ppdn[idn]
                    && !Dump_DSNAME(1 + nIndents, ppdn[idn])) {
                    fSuccess = FALSE;
                }
            }
            FreeMemory( ppdn );
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cFullReplicaNCs", pDsa->m_cFullReplicaNCs);
        ppdn = (DSNAME **) ReadMemory(pDsa->m_ppdnFullReplicaNCs,
                                  sizeof(DSNAME *) * pDsa->m_cFullReplicaNCs);
        if (NULL == ppdn) {
            fSuccess = FALSE;
        }
        else {
            for( idn = 0; idn < pDsa->m_cFullReplicaNCs; idn++ ) {
                Printf("%sm_ppdnFullReplicaNCs[%d]:\n",Indent(nIndents), idn);
                if (ppdn[idn]
                    && !Dump_DSNAME(1 + nIndents, ppdn[idn])) {
                    fSuccess = FALSE;
                }
            }
            FreeMemory( ppdn );
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fAddrsRead", pDsa->m_fAddrsRead);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cNumAddrs", pDsa->m_cNumAddrs);
        pAddrs = (KCC_DSA_ADDR *)
                    ReadMemory(pDsa->m_pAddrs,
                               sizeof(KCC_DSA_ADDR) * pDsa->m_cNumAddrs);
        if (NULL == pAddrs) {
            fSuccess = FALSE;
        }
        else {
            for (iAddr = 0; iAddr < pDsa->m_cNumAddrs; iAddr++) {
                Printf("%spDsa->m_pAddrs[%d]:\n",Indent(nIndents), iAddr);
                if (ATT_SMTP_MAIL_ADDRESS == pAddrs[iAddr].attrType) {
                    Printf("%sATT_SMTP_MAIL_ADDRESS (psz @ %p, pmtx @ %p):\n",
                           Indent(1 + nIndents),
                           pAddrs[iAddr].pszAddr,
                           pAddrs[iAddr].pmtxAddr);
                }
                else {
                    Printf("%sAttr 0x%x (psz @ %p, pmtx @ %p):\n",
                           Indent(1 + nIndents),
                           pAddrs[iAddr].attrType,
                           pAddrs[iAddr].pszAddr,
                           pAddrs[iAddr].pmtxAddr);
                }

                if (!Dump_MTX_ADDR(2 + nIndents, pAddrs[iAddr].pmtxAddr)) {
                    fSuccess = FALSE;
                }
            }
            
            FreeMemory(pAddrs);
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pDsa->m_dwOptions);
 
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSite", pDsa->m_pdnSite);
        if (pDsa->m_pdnSite
            && !Dump_DSNAME(1 + nIndents, pDsa->m_pdnSite)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwBehaviorVersion", pDsa->m_dwBehaviorVersion);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pIntraSiteCnList", pDsa->m_pIntraSiteCnList);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pInterSiteCnList", pDsa->m_pInterSiteCnList);

        FreeMemory(pDsa);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DSA_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_DSA_LIST *    pDsaList = NULL;
    const DWORD       cchFieldWidth = 20;
    KCC_DSA **        ppDsas;
    DWORD             iDsa;

    Printf("%sKCC_DSA_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pDsaList = (KCC_DSA_LIST *) ReadMemory(pvProcess,
                                             sizeof(KCC_DSA_LIST));

    if (NULL != pDsaList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pDsaList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pfnSortedBy", pDsaList->m_pfnSortedBy);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cdsa", pDsaList->m_cdsa);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppdsa", pDsaList->m_ppdsa);

        ppDsas = (KCC_DSA **) ReadMemory(pDsaList->m_ppdsa,
                                           sizeof(KCC_DSA *) * pDsaList->m_cdsa);
        if (NULL == ppDsas) {
            fSuccess = FALSE;
        }
        else {
            for (iDsa = 0; iDsa < pDsaList->m_cdsa; iDsa++) {
                Printf("%sm_ppdsa[%d]:\n",  Indent(nIndents), iDsa);
                if (!Dump_KCC_DSA(nIndents+1, ppDsas[iDsa])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppDsas);
        }

        FreeMemory(pDsaList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CONNECTION(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_CONNECTION *  pConn = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_CONNECTION @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pConn = (KCC_CONNECTION *) ReadMemory(pvProcess, sizeof(KCC_CONNECTION));

    if (NULL != pConn) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnConnection", pConn->m_pdnConnection);
        if (pConn->m_pdnConnection
            && !Dump_DSNAME(1 + nIndents, pConn->m_pdnConnection)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsEnabled", pConn->m_fIsEnabled);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pSourceDSA", pConn->m_pSourceDSA);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnDestinationDSA", pConn->m_pdnDestinationDSA);
        if (pConn->m_pdnDestinationDSA
            && !Dump_DSNAME(1 + nIndents, pConn->m_pdnDestinationDSA)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnTransport", pConn->m_pdnTransport);
        if (pConn->m_pdnTransport
            && !Dump_DSNAME(1 + nIndents, pConn->m_pdnTransport)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pConn->m_dwOptions);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_toplSchedule",
               (BYTE *) pvProcess + offsetof(KCC_CONNECTION, m_toplSchedule));
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_timeCreated",
               DSTimeToDisplayString(pConn->m_timeCreated, szTime));
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ReasonForConnection", pConn->m_ReasonForConnection);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ReplicatedNCArray",
               (BYTE *) pvProcess + offsetof(KCC_CONNECTION, m_ReplicatedNCArray));
        if (!Dump_KCC_REPLICATED_NC_ARRAY(1 + nIndents,
                                          (BYTE *) pvProcess
                                          + offsetof(KCC_CONNECTION,
                                                     m_ReplicatedNCArray))) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedOptions", pConn->m_fUpdatedOptions);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedSchedule", pConn->m_fUpdatedSchedule);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fUpdatedTransport", pConn->m_fUpdatedTransport);

        FreeMemory(pConn);
    }

    return fSuccess;
}

BOOL
Dump_KCC_REPLICATED_NC_ARRAY(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                      fSuccess = FALSE;
    KCC_REPLICATED_NC_ARRAY * pArray = NULL;
    KCC_REPLICATED_NC **      ppReplNCs = NULL;
    const DWORD               cchFieldWidth = 24;
    DWORD                     iReplNC;

    Printf("%sKCC_REPLICATED_NC_ARRAY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pArray = (KCC_REPLICATED_NC_ARRAY *)
                ReadMemory(pvProcess, sizeof(KCC_REPLICATED_NC_ARRAY));

    if (NULL != pArray) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pArray->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ElementsAllocated", pArray->m_ElementsAllocated);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_Count", pArray->m_Count);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_Array", pArray->m_Array);

        ppReplNCs = (KCC_REPLICATED_NC **)
                        ReadMemory(pArray->m_Array,
                                   sizeof(KCC_REPLICATED_NC *) * pArray->m_Count);
        if (NULL == ppReplNCs) {
            fSuccess = FALSE;
        }
        else {
            for (iReplNC = 0; iReplNC < pArray->m_Count; iReplNC++) {
                Printf("%sm_Array[%d]:\n",  Indent(nIndents), iReplNC);
                if (!Dump_KCC_REPLICATED_NC(nIndents+1, ppReplNCs[iReplNC])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppReplNCs);
        }

        FreeMemory(pArray);
    }

    return fSuccess;
}

BOOL
Dump_KCC_REPLICATED_NC(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_REPLICATED_NC * pReplNC = NULL;
    const DWORD         cchFieldWidth = 24;

    Printf("%sKCC_REPLICATED_NC @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pReplNC = (KCC_REPLICATED_NC *) ReadMemory(pvProcess,
                                               sizeof(KCC_REPLICATED_NC));
    if (NULL != pReplNC) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "pNC", pReplNC->pNC);
        if (pReplNC->pNC
            && !Dump_DSNAME(1 + nIndents, pReplNC->pNC)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "fReadOnly",
               pReplNC->fReadOnly ? "yes" : "no");

        FreeMemory(pReplNC);
    }

    return fSuccess;
}

BOOL
Dump_KCC_INTRASITE_CONNECTION_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                            fSuccess = FALSE;
    KCC_INTRASITE_CONNECTION_LIST * pList = NULL;
    const DWORD                     cchFieldWidth = 20;
    KCC_CONNECTION **               ppConns;
    DWORD                           iConn;

    Printf("%sKCC_INTRASITE_CONNECTION_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_INTRASITE_CONNECTION_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_INTRASITE_CONNECTION_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccn", pList->m_ccn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppcn", pList->m_ppcn);

        ppConns = (KCC_CONNECTION **)
                        ReadMemory(pList->m_ppcn,
                                   sizeof(KCC_CONNECTION *) * pList->m_ccn);
        if (NULL == ppConns) {
            fSuccess = FALSE;
        }
        else {
            for (iConn = 0; iConn < pList->m_ccn; iConn++) {
                Printf("%sm_ppcn[%d]:\n",  Indent(nIndents), iConn);
                if (!Dump_KCC_CONNECTION(nIndents+1, ppConns[iConn])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppConns);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_INTERSITE_CONNECTION_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                            fSuccess = FALSE;
    KCC_INTERSITE_CONNECTION_LIST * pList = NULL;
    const DWORD                     cchFieldWidth = 20;
    KCC_CONNECTION **               ppConns;
    DWORD                           iConn;

    Printf("%sKCC_INTERSITE_CONNECTION_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_INTERSITE_CONNECTION_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_INTERSITE_CONNECTION_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccn", pList->m_ccn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_ppcn", pList->m_ppcn);

        ppConns = (KCC_CONNECTION **)
                        ReadMemory(pList->m_ppcn,
                                   sizeof(KCC_CONNECTION *) * pList->m_ccn);
        if (NULL == ppConns) {
            fSuccess = FALSE;
        }
        else {
            for (iConn = 0; iConn < pList->m_ccn; iConn++) {
                Printf("%sm_ppcn[%d]:\n",  Indent(nIndents), iConn);
                if (!Dump_KCC_CONNECTION(nIndents+1, ppConns[iConn])) {
                    fSuccess = FALSE;
                    break;
                }
            }

            FreeMemory(ppConns);
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_TRANSPORT(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_TRANSPORT *   pTransport = NULL;
    const DWORD       cchFieldWidth = 24;

    Printf("%sKCC_TRANSPORT @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pTransport = (KCC_TRANSPORT *) ReadMemory(pvProcess, sizeof(KCC_TRANSPORT));

    if (NULL != pTransport) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pTransport->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pTransport->m_pdn);
        if (pTransport->m_pdn
            && !Dump_DSNAME(1 + nIndents, pTransport->m_pdn)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: 0x%x\n", Indent(nIndents), cchFieldWidth,
               "m_attAddressType", pTransport->m_attAddressType);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pTransport->m_dwOptions);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwReplInterval", pTransport->m_dwReplInterval);

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsSiteLinkListInitialized",
               pTransport->m_fIsSiteLinkListInitialized);

        if (pTransport->m_fIsSiteLinkListInitialized) {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "m_SiteLinkList",
                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_SiteLinkList));
//            fSuccess = Dump_KCC_SITE_LINK_LIST( nIndents + 1,
//                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_SiteLinkList));
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsBridgeListInitialized",
               pTransport->m_fIsBridgeListInitialized);

        if (pTransport->m_fIsBridgeListInitialized) {
            Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
                   "m_BridgeList",
                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_BridgeList));
//            fSuccess = Dump_KCC_BRIDGE_LIST( nIndents + 1,
//                   (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_BridgeList));
        }

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_AllExplicitBridgeheadArray",
               (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_AllExplicitBridgeheadArray));

//        fSuccess = Dump_KCC_DSNAME_ARRAY( nIndents + 1,
//               (BYTE *) pvProcess + offsetof(KCC_TRANSPORT, m_AllExplicitBridgeheadArray));

        FreeMemory(pTransport);
    }

    return fSuccess;
}

BOOL
Dump_KCC_TRANSPORT_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_TRANSPORT_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;
    BYTE *                pTransport;
    DWORD                 iTransport;

    Printf("%sKCC_TRANSPORT_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_TRANSPORT_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_TRANSPORT_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_cTransports", pList->m_cTransports);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pTransports", pList->m_pTransports);


        // This is a pointer to an array of the objects themselves.
        pTransport = (BYTE *) pList->m_pTransports;
        if (pTransport) {
            for (iTransport = 0; iTransport < pList->m_cTransports; iTransport++) {
                printf("%sm_pTransports[%d]:\n",  Indent(nIndents), iTransport);
                if (!Dump_KCC_TRANSPORT(nIndents+1, pTransport)) {
                    fSuccess = FALSE;
                    break;
                }
                pTransport += sizeof( KCC_TRANSPORT );
            }
        }

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_DS_CACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_DS_CACHE *  pCache = NULL;
    const DWORD     cchFieldWidth = 20;

    Printf("%sKCC_DS_CACHE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCache = (KCC_DS_CACHE *) ReadMemory(pvProcess,
                                         sizeof(KCC_DS_CACHE));

    if (NULL != pCache) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_initializationStage", pCache->m_initializationStage);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fRunningUnderAltID", pCache->m_fRunningUnderAltID);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnLocalDSA", pCache->m_pdnLocalDSA);
        if (pCache->m_pdnLocalDSA
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnLocalDSA)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnConfiguration", pCache->m_pdnConfiguration);
        if (pCache->m_pdnConfiguration
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnConfiguration)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnSchema", pCache->m_pdnSchema);
        if (pCache->m_pdnSchema
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnSchema)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnIpTransport", pCache->m_pdnIpTransport);
        if (pCache->m_pdnIpTransport
            && !Dump_DSNAME(1 + nIndents, pCache->m_pdnIpTransport)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pszForestDnsName", pCache->m_pszForestDnsName);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_CrossRefList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_CrossRefList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_TransportList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_TransportList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteList",
               (BYTE *) pvProcess + offsetof(KCC_DS_CACHE, m_SiteList));
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLocalSite", (BYTE *) pCache->m_pLocalSite);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLocalDSA", pCache->m_pLocalDSA);

        FreeMemory(pCache);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CROSSREF(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL            fSuccess = FALSE;
    KCC_CROSSREF *  pCR = NULL;
    const DWORD     cchFieldWidth = 30;
    CHAR            szTime[SZDSTIME_LEN];
    LPSTR           pszType;
    BYTE *          pb;

    Printf("%sKCC_CROSSREF @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCR = (KCC_CROSSREF *) ReadMemory(pvProcess, sizeof(KCC_CROSSREF));

    if (NULL != pCR) {
        fSuccess = TRUE;

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdnNC", pCR->m_pdnNC);
        if (pCR->m_pdnNC
            && !Dump_DSNAME(1 + nIndents, pCR->m_pdnNC)) {
            fSuccess = FALSE;
        }

        switch (pCR->m_NCType) {
        case KCC_NC_TYPE_INVALID:   pszType = "KCC_NC_TYPE_INVALID";   break;
        case KCC_NC_TYPE_CONFIG:    pszType = "KCC_NC_TYPE_CONFIG";    break;
        case KCC_NC_TYPE_SCHEMA:    pszType = "KCC_NC_TYPE_SCHEMA";    break;
        case KCC_NC_TYPE_DOMAIN:    pszType = "KCC_NC_TYPE_DOMAIN";    break;
        case KCC_NC_TYPE_NONDOMAIN: pszType = "KCC_NC_TYPE_NONDOMAIN"; break;
        default:                    pszType = "!!UNKNOWN!!";           break;
        }

        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_NCType", pszType);
        
        Printf("%s%-*s: %s\n", Indent(nIndents), cchFieldWidth,
               "m_fIsReplicatedToGCs",
               pCR->m_fIsReplicatedToGCs ? "TRUE" : "FALSE");
        
        pb = (BYTE *) pvProcess + offsetof(KCC_CROSSREF, m_NCReplicaLocationsArray);
        Printf("%s%-*s: @ %p\n", Indent(nIndents), cchFieldWidth,
               "m_NCReplicaLocationsArray", pb);
        if (!Dump_KCC_DSNAME_ARRAY(nIndents + 1, pb)) {
            fSuccess = FALSE;
        }
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pLinkList", pCR->m_pLinkList);

        
        FreeMemory(pCR);
    }

    return fSuccess;
}

BOOL
Dump_KCC_CROSSREF_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                fSuccess = FALSE;
    KCC_CROSSREF_LIST * pCRList = NULL;
    const DWORD         cchFieldWidth = 20;
    DWORD               iCR;

    Printf("%sKCC_CROSSREF_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pCRList = (KCC_CROSSREF_LIST *) ReadMemory(pvProcess,
                                               sizeof(KCC_CROSSREF_LIST));

    if (NULL != pCRList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pCRList->m_fIsInitialized);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwForestVersion", pCRList->m_dwForestVersion);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_ccref", pCRList->m_ccref);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pcref", pCRList->m_pcref);

        for (iCR = 0; iCR < pCRList->m_ccref; iCR++) {
            Printf("%sm_pcref[%d]:\n",  Indent(nIndents), iCR);
            if (!Dump_KCC_CROSSREF(nIndents+1,
                                   &pCRList->m_pcref[iCR])) {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(pCRList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_SITE_LINK *   pSiteLink = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_SITE_LINK @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pSiteLink = (KCC_SITE_LINK *) ReadMemory(pvProcess, sizeof(KCC_SITE_LINK));

    if (NULL != pSiteLink) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pSiteLink->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pSiteLink->m_pdnSiteLinkObject);
        if (pSiteLink->m_pdnSiteLinkObject
            && !Dump_DSNAME(1 + nIndents, pSiteLink->m_pdnSiteLinkObject)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwOptions", pSiteLink->m_dwOptions);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwCost", pSiteLink->m_dwCost);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_dwReplInterval", pSiteLink->m_dwReplInterval);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_hSchedule", pSiteLink->m_hSchedule);

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK, m_SiteArray));

        fSuccess = Dump_KCC_SITE_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK, m_SiteArray));

        FreeMemory(pSiteLink);
    }

    return fSuccess;
}

BOOL
Dump_KCC_SITE_LINK_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_SITE_LINK_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;

    Printf("%sKCC_SITE_LINK_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_SITE_LINK_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_SITE_LINK_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteLinkArray",
               (BYTE *) pvProcess + offsetof(KCC_SITE_LINK_LIST, m_SiteLinkArray));

        Dump_KCC_SITE_LINK_ARRAY( nIndents + 1,
                 (BYTE *) pvProcess + offsetof(KCC_SITE_LINK_LIST, m_SiteLinkArray));

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    KCC_BRIDGE *      pBridge = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sKCC_BRIDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pBridge = (KCC_BRIDGE *) ReadMemory(pvProcess, sizeof(KCC_BRIDGE));

    if (NULL != pBridge) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pBridge->m_fIsInitialized);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_pdn", pBridge->m_pdnBridgeObject);
        if (pBridge->m_pdnBridgeObject
            && !Dump_DSNAME(1 + nIndents, pBridge->m_pdnBridgeObject)) {
            fSuccess = FALSE;
        }

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_SiteLinkArray",
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE, m_SiteLinkArray));

        fSuccess = Dump_KCC_SITE_LINK_ARRAY( nIndents + 1,
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE, m_SiteLinkArray));

        FreeMemory(pBridge);
    }

    return fSuccess;
}

BOOL
Dump_KCC_BRIDGE_LIST(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL                  fSuccess = FALSE;
    KCC_BRIDGE_LIST *  pList = NULL;
    const DWORD           cchFieldWidth = 20;

    Printf("%sKCC_BRIDGE_LIST @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pList = (KCC_BRIDGE_LIST *)
                ReadMemory(pvProcess, sizeof(KCC_BRIDGE_LIST));

    if (NULL != pList) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "m_fIsInitialized", pList->m_fIsInitialized);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "m_BridgeArray",
               (BYTE *) pvProcess + offsetof(KCC_BRIDGE_LIST, m_BridgeArray));

        Dump_KCC_BRIDGE_ARRAY( nIndents + 1,
                 (BYTE *) pvProcess + offsetof(KCC_BRIDGE_LIST, m_BridgeArray));

        FreeMemory(pList);
    }

    return fSuccess;
}

BOOL
Dump_TOPL_REPL_INFO(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_REPL_INFO   pRI = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sTOPL_REPL_INFO @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pRI = (PTOPL_REPL_INFO) ReadMemory(pvProcess, sizeof(TOPL_REPL_INFO));

    if (NULL != pRI) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "cost", pRI->cost);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "repIntvl", pRI->repIntvl);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "options", pRI->options);
        fSuccess &= Dump_TOPL_SCHEDULE( nIndents + 1, (BYTE*) pRI->schedule );

        FreeMemory(pRI);
    }

    return fSuccess;
}

BOOL
Dump_ToplVertex(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplVertex       v = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplVertex @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    v = (PToplVertex) ReadMemory(pvProcess, sizeof(ToplVertex));

    if (NULL != v) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "vtxId", v->vtxId);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertexName", v->vertexName);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "edgeList", v->edgeList);
        
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplVertex, edgeList));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "color", v->color);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "acceptRedRed", v->acceptRedRed);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "acceptBlack", v->acceptBlack);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(ToplVertex, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "heapLocn", v->heapLocn);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "root", v->root);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "demoted", v->demoted);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "componentId", v->componentId);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "componentIndex", v->componentIndex);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "distToRed", v->distToRed);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "parent", v->parent);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "nextChild", v->nextChild);
    }

    return fSuccess;
}


BOOL
Dump_ToplGraphState(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplGraphState   g = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplGraphState @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    g = (PToplGraphState) ReadMemory(pvProcess, sizeof(ToplGraphState));

    if (NULL != g) {
        fSuccess = TRUE;

        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicStart", g->magicStart);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertexNames", g->vertexNames);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vertices", g->vertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numVertices", g->numVertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "melSorted", g->melSorted);
        
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "masterEdgeList", g->masterEdgeList);
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplGraphState, masterEdgeList));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "edgeSets", g->edgeSets);
        fSuccess &= Dump_DynArray( nIndents + 1,
               (BYTE*) pvProcess + offsetof(ToplGraphState, edgeSets));

        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "vnCompFunc", g->vnCompFunc);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "schedCache", g->schedCache);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicEnd", g->magicEnd);
    }

    return fSuccess;
}


BOOL
Dump_ToplInternalEdge(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PToplInternalEdge e = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    Printf("%sToplInternalEdge @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    e = (PToplInternalEdge) ReadMemory(pvProcess, sizeof(ToplInternalEdge));

    if (NULL != e) {
        fSuccess = TRUE;

        fSuccess &= Dump_ToplVertex( nIndents + 1, e->v1 );
        fSuccess &= Dump_ToplVertex( nIndents + 1, e->v2 );

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "redRed", e->redRed);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(ToplInternalEdge, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "edgeType", e->edgeType);
    }

    return fSuccess;
}


BOOL
Dump_TOPL_SCHEDULE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    ToplSched        *s = NULL;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];

    if( pvProcess==NULL ) {
        Printf("%sToplSchedule: NULL (Always Schedule)\n", Indent(nIndents), pvProcess);
        return TRUE;
    } 

    Printf("%sToplSchedule @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    s = (ToplSched*) ReadMemory(pvProcess, sizeof(ToplSched));

    if (NULL != s) {
        fSuccess = TRUE;

        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicStart", s->magicStart);

        fSuccess &= Dump_PSCHEDULE( nIndents + 1, (BYTE *) s->s );

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "duration", s->duration);
        Printf("%s%-*s: %x\n", Indent(nIndents), cchFieldWidth,
               "magicEnd", s->magicEnd);
    }

    return fSuccess;
}


BOOL
Dump_PSCHEDULE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PSCHEDULE         s;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sSCHEDULE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    s = (PSCHEDULE) ReadMemory(pvProcess, sizeof(SCHEDULE));

    if (NULL != s) {
        fSuccess = TRUE;

        if( s->Size!=sizeof(SCHEDULE)+SCHEDULE_DATA_ENTRIES
         || s->NumberOfSchedules!=1
         || s->Schedules[0].Type!=SCHEDULE_INTERVAL
         || s->Schedules[0].Offset!=sizeof(SCHEDULE) )
        {
            Printf("%s%-*s: \n", Indent(nIndents), cchFieldWidth,
                   "Unsupported Schedule Type!");
            return FALSE;
        }

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "Size", s->Size);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "Bandwidth", s->Bandwidth);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "NumberOfSchedules", s->NumberOfSchedules);

        Printf("%s%-*s: \n", Indent(nIndents), cchFieldWidth,
               "Data" );
        data = (PBYTE) ReadMemory( ((PBYTE)pvProcess)+sizeof(SCHEDULE),
            SCHEDULE_DATA_ENTRIES );
        if( NULL != data ) {
            for( i=0; i<SCHEDULE_DATA_ENTRIES; i++ ) {
                Printf("%02x ",data[i]);
            }
        }
        Printf("\n");
    }

    return fSuccess;
}


BOOL
Dump_DynArray(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PDynArray         da;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sDynArray @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    da = (PDynArray) ReadMemory(pvProcess, sizeof(DynArray));

    if (NULL != da) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "elementSize", da->elementSize);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "logicalElements", da->logicalElements);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "physicalElements", da->physicalElements);
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "data", da->data );
    }

    return fSuccess;
}


BOOL
Dump_TOPL_MULTI_EDGE(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_MULTI_EDGE  e;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sPTOPL_MULTI_EDGE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    e = (PTOPL_MULTI_EDGE) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE));
    if (NULL != e) {
        e = (PTOPL_MULTI_EDGE) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE)
            + sizeof(TOPL_NAME_STRUCT)*(e->numVertices-1) );
    }

    if (NULL != e) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numVertices", e->numVertices);
        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "edgeType", e->edgeType);

        fSuccess &= Dump_TOPL_REPL_INFO( nIndents + 1,
               (BYTE *) pvProcess + offsetof(TOPL_MULTI_EDGE, ri));

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "fDirectedEdge", e->fDirectedEdge);

        if( e->numVertices <= 8 ) {
            for( i=0; i<e->numVertices; i++ ) {
                Printf("%s%-*s[%d].name: %p\n", Indent(nIndents), cchFieldWidth,
                       "vertexNames", i, e->vertexNames[i].name );
                Printf("%s%-*s[%d].reserved: %d\n", Indent(nIndents), cchFieldWidth,
                       "vertexNames", i, e->vertexNames[i].reserved );
            }
        }
    }

    return fSuccess;
}


BOOL
Dump_TOPL_MULTI_EDGE_SET(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    BOOL              fSuccess = FALSE;
    PTOPL_MULTI_EDGE_SET  eSet;
    const DWORD       cchFieldWidth = 24;
    CHAR              szTime[SZDSTIME_LEN];
    PBYTE             data;
    DWORD             i;

    Printf("%sPTOPL_MULTI_EDGE_SET @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    eSet = (PTOPL_MULTI_EDGE_SET) ReadMemory(pvProcess, sizeof(TOPL_MULTI_EDGE_SET));

    if (NULL != eSet) {
        fSuccess = TRUE;

        Printf("%s%-*s: %d\n", Indent(nIndents), cchFieldWidth,
               "numMultiEdges", eSet->numMultiEdges );
        Printf("%s%-*s: %p\n", Indent(nIndents), cchFieldWidth,
               "multiEdgeList", eSet->multiEdgeList );
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\mapi.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    mapi.c

Abstract:

    Dump functions for MAPI related types

Environment:

Revision History:

    22-Mar-99   MariosZ     Created

--*/


#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
// Core headers.
#include <ntdsa.h>                      // Core data types
#include <scache.h>                     // Schema cache code
#include <dbglobal.h>                   // DBLayer header.
#include <mdglobal.h>                   // THSTATE definition
#include <dsatools.h>                   // Memory, etc.


// Assorted MAPI headers.
#include <mapidefs.h>                   // These four files
#include <mapitags.h>                   //  define MAPI
#include <mapicode.h>                   //  stuff that we need
#include <mapiguid.h>                   //  in order to be a provider.

// Nspi interface headers.
#include "nspi.h"                       // defines the nspi wire interface
#include <nsp_both.h>                   // a few things both client/server need
#include <_entryid.h>                   // Defines format of an entryid
#include "abdefs.h"


BOOL
Dump_STAT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public STAT dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PSTAT pstat = 0;

    pstat = (PSTAT) ReadMemory(pvProcess, sizeof(STAT));
        
    if ( pstat ) {

        Printf("%s hIndex:       0x%x\n", Indent(nIndents), pstat->hIndex);
        Printf("%s ContainerID:  0x%x\n", Indent(nIndents), pstat->ContainerID);
        Printf("%s CurrentRec:   %lu\n", Indent(nIndents), pstat->CurrentRec);
        Printf("%s Delta:        %ld\n", Indent(nIndents), pstat->Delta);
        Printf("%s NumPos:       %lu\n", Indent(nIndents), pstat->NumPos);
        Printf("%s TotalRecs:    %lu\n", Indent(nIndents), pstat->TotalRecs);
        Printf("%s CodePage:     %lu\n", Indent(nIndents), pstat->CodePage);
        Printf("%s TemplateLoc:  %lu\n", Indent(nIndents), pstat->TemplateLocale );
        Printf("%s SortLocale:   %lu\n", Indent(nIndents), pstat->SortLocale );

        FreeMemory(pstat);
    }

    return(TRUE);
}

BOOL
Dump_INDEXSIZE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public INDEXSIZE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PINDEXSIZE pIndexSize = 0;


    pIndexSize = (PINDEXSIZE) ReadMemory(pvProcess, sizeof(INDEXSIZE));
        
    if ( pIndexSize ) {
        Printf("%s TotalCount:     %ld\n", Indent(nIndents), pIndexSize->TotalCount);
        Printf("%s ContainerID:     0x%x\n",Indent(nIndents), pIndexSize->ContainerID);
        Printf("%s ContainerCount: %ld\n", Indent(nIndents), pIndexSize->ContainerCount);
        
        FreeMemory(pIndexSize);
    }

    return(TRUE);
}



BOOL
Dump_SPropTag(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SPropTag dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    LPSPropTagArray_r     pPropTagArr_tmp = 0;
    LPSPropTagArray_r     pPropTagArr = 0;
    ULONG i;


    do {
        pPropTagArr_tmp = (LPSPropTagArray_r) ReadMemory(pvProcess, sizeof(SPropTagArray_r));
        
        if ( NULL == pPropTagArr_tmp )
            break;

        pPropTagArr = (LPSPropTagArray_r) ReadMemory(pvProcess, sizeof(SPropTagArray_r) + 
                                                                     sizeof (ULONG) * pPropTagArr_tmp->cValues);
        
        if ( NULL == pPropTagArr )
            break;

        
        Printf("%s SPropTagArr[%d]:\n", Indent(nIndents), pPropTagArr->cValues);
        
        for (i=0; i<pPropTagArr->cValues; i++) {
            Printf("%s aulPropTag[%d]: 0x%x\n", Indent(nIndents+1), i, pPropTagArr->aulPropTag[i]);
        }
    }
    while ( FALSE );


    if (pPropTagArr_tmp)
        FreeMemory(pPropTagArr_tmp);
    if (pPropTagArr)
        FreeMemory(pPropTagArr);

    return(TRUE);
}

BOOL
Dump_SRowSet(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SRowSet dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    LPLPSRowSet_r ppRows = 0;
    LPSRowSet_r   pRows_tmp = 0;
    LPSRowSet_r   pRows = 0;

    LPSPropValue_r lpProps = 0, lpProps_tmp = 0;

    DWORD tempSyntax;
    ULONG i, j;
    
    Printf("Reading Memory: %x\n", pvProcess);

    do {

        ppRows = (LPLPSRowSet_r) ReadMemory(pvProcess, sizeof (LPSRowSet_r));
        
        if ( NULL == ppRows )
            break;
        
        Printf("Reading Memory: %x\n", *ppRows);
        
        pRows_tmp = (LPSRowSet_r) ReadMemory(*ppRows, sizeof(SRowSet_r));
        
        if ( NULL == pRows_tmp )
            break;

        pRows = (LPSRowSet_r) ReadMemory(*ppRows, sizeof(SRowSet_r) + 
                                                  sizeof (SRow_r) * pRows_tmp->cRows);
        
        if ( NULL == pRows )
            break;

        
        Printf("%s SRowSet[%d]:\n", Indent(nIndents), pRows->cRows);
        
        for (i=0; i<pRows->cRows; i++) {
            Printf("%s aRow[%d]:\n", Indent(nIndents+1), i);
            Printf("%s ulAdrEntryPad:  0x%x\n", Indent(nIndents+2), pRows->aRow[i].ulAdrEntryPad);
            Printf("%s cValues:       %d\n",   Indent(nIndents+2), pRows->aRow[i].cValues);

            lpProps_tmp = lpProps = (LPSPropValue_r) ReadMemory(pRows->aRow[i].lpProps, sizeof (LPSPropValue_r) * pRows->aRow[i].cValues);
            if ( NULL == lpProps )
                break;

            Printf("%s PropValue[%d]:\n", Indent(nIndents+2), pRows->aRow[i].cValues);
            for (j=0; j<pRows->aRow[i].cValues; j++) {

                Printf("%s ulPropTag[%d]:  0x%x\n", Indent(nIndents+3), j, lpProps->ulPropTag);
                //Printf("%s dwAlignPad[%d]: %d\n",   Indent(nIndents+3), j, lpProps->dwAlignPad);
                
                tempSyntax = PROP_TYPE(lpProps->ulPropTag);
                if (tempSyntax == PT_STRING8 ) {
                    LPWSTR lpszW;

                    lpszW = (LPWSTR) ReadStringMemory (lpProps->Value.lpszW, 40);

                    Printf("%s value[%d]:      %s\n",   Indent(nIndents+3), j, lpszW);

                    if (lpszW)
                        FreeMemory(lpszW);

                } else {
                    Printf("%s value[%d]:      0x%x\n",   Indent(nIndents+3), j, lpProps->Value.l);
                }

                lpProps++;
            }

            if (lpProps_tmp) 
                FreeMemory(lpProps_tmp);
        }
    }
    while ( FALSE );


    if (ppRows)
        FreeMemory(ppRows);
    if (pRows_tmp)
        FreeMemory(pRows_tmp);
    if (pRows)
        FreeMemory(pRows);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\md.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src - i.e. the mini-directory.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Jan-00   XinHe       Added Dump_TQEntry()

    08-May-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop
#include "winsock.h"            // htonl and ntohl
#include "dsexts.h"
#include "objids.h"
#include <ntdsa.h>
#include "drs.h"
#include "scache.h"
#include "dbglobal.h"
#include "mdglobal.h"
#include "mappings.h"
#include "mdlocal.h"
#include "anchor.h"
#include "direrr.h"
#include "filtypes.h"
#include <dsjet.h>
#include "dbintrnl.h"
#include "dsatools.h"
#include "bhcache.h"
#include <debug.h>
#include <dsutil.h>
#include <xdommove.h>
#include <lmcons.h>
#include <checkacl.h>
#include <seopaque.h>
#include <taskq.h>

typedef struct _AttrSelectionCode {
    UCHAR chCode;
    CHAR  *pszCode;
} AttrSelectionCode;

AttrSelectionCode rAttrSelectionCode[] = {
    {'A',   "EN_ATTSEL_ALL"},
    {'B',   "EN_ATTSEL_ALL_WITH_LIST"},
    {'L',   "EN_ATTSET_LIST"},
    {'E',   "EN_ATTSET_LIST_DRA"},
    {'D',   "EN_ATTSET_ALL_DRA"},
    {'F',   "EN_ATTSET_LIST_DRA_EXT"},
    {'G',   "EN_ATTSET_ALL_DRA_EXT"},
    {'H',   "EN_ATTSET_LIST_DRA_PUBLIC"},
    {'I',   "EN_ATTSET_ALL_DRA_PUBLIC"},
    {'T',   "EN_INFOTYPES_TYPES_ONLY"},
    {'V',   "EN_INFOTYPES_TYPES_VALS"},
    {'S',   "EN_INFOTYPES_SHORTNAMES"},
    {'M',   "EN_INFOTYPES_MAPINAMES"},
};


DWORD cAttrSelectionCode = sizeof(rAttrSelectionCode) / sizeof(AttrSelectionCode);

#define UNKNOWN_SELECTION_CODE "Unknown Selection Code"

char *PszSelCodeToString(UCHAR ch);


typedef struct GuidCache
{
    CHAR                *name;
    GUID                guid;
    int                 type;
} GuidCache;


GuidCache guidCache[] = {
    #include "..\aclguids\guidcache.h"
};

#define NUM_KNOWN_GUIDS  (sizeof (guidCache) / sizeof (GuidCache) -1 )


LPSTR
DraUuidToStr(
    IN  UUID *  puuid,
    OUT LPSTR   pszUuid     OPTIONAL
    );


BOOL
Dump_DSNAME(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DSNAME dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSNAME in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    DSNAME          *pName = NULL;
    ULONG           structLen;
    int             cDelta;

    Printf("%sDSNAME", Indent(nIndents));
    nIndents++;

    if ( NULL != (pName = (DSNAME *) ReadMemory(pvProcess,
                                                sizeof(DSNAME))))
    {
        structLen = pName->structLen;

        Printf("\n%s", Indent(nIndents));
        Printf("total size: %u, name len: %u",
               pName->structLen, pName->NameLen);
        cDelta = pName->structLen - DSNameSizeFromLen(pName->NameLen);
        if (cDelta) {
            Printf(" Sizes are inconsistent, %d bytes %sallocated",
                   cDelta, (cDelta > 0) ? "over" : "UNDER");
        }
        Printf("\n%sGuid: %s",
               Indent(nIndents), DraUuidToStr(&(pName->Guid), NULL));

        FreeMemory(pName);

        if (pName->SidLen) {
            WCHAR SidText[128];
            UNICODE_STRING us;

            SidText[0] = L'\0';
            us.MaximumLength = sizeof(SidText);
            us.Length = 0;
            us.Buffer = SidText;

            RtlConvertSidToUnicodeString(&us, &pName->Sid, FALSE);
            Printf("\n%sSID: %S", Indent(nIndents), SidText);
        }

        if ( NULL != (pName = (DSNAME *) ReadMemory(
                                                    pvProcess,
                                                    structLen)) )
        {
            Printf("\n%s", Indent(nIndents));
            Printf("Name: ");
            Printf("%S\n", pName->StringName);

            FreeMemory(pName);
            fSuccess = TRUE;
        }
    }

    return(fSuccess);
}


BOOL
Dump_DSNAME_local(
    IN DWORD nIndents,
    IN PVOID pvLocal)

/*++

Routine Description:

    Public DSNAME dump routine.
    Assumes the whole DNSAME (pDN->structLen worth) is already in memory

Arguments:

    nIndents - Indentation level desired.

    pLocal - the DSNAME in local memory

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    DSNAME          *pName = (DSNAME *) pvLocal;
    ULONG           structLen;
    int             cDelta;

    Printf("%sDSNAME", Indent(nIndents));
    nIndents++;

    structLen = pName->structLen;

    Printf("\n%s", Indent(nIndents));
    Printf("total size: %u, name len: %u",
           pName->structLen, pName->NameLen);
    cDelta = pName->structLen - DSNameSizeFromLen(pName->NameLen);
    if (cDelta) {
        Printf(" Sizes are inconsistent, %d bytes %sallocated",
               cDelta, (cDelta > 0) ? "over" : "UNDER");
    }
    Printf("\n%sGuid: %s",
           Indent(nIndents), DraUuidToStr(&(pName->Guid), NULL));

    if (pName->SidLen) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, &pName->Sid, FALSE);
        Printf("\n%sSID: %S", Indent(nIndents), SidText);
    }

    Printf("\n%s", Indent(nIndents));
    Printf("Name: ");
    Printf("%S\n", pName->StringName);

    fSuccess = TRUE;

    return(fSuccess);
}

BOOL
Dump_NC_Entry(
    IN DWORD nIndents,
    IN PVOID pNCL,
    OUT PVOID *pNextNC)
/*++

Routine Description:

    Public NAMING_CONTEXT_LIST entry dump routine.

Arguments:

    nIndents - Indentation level desired.

    pNCL - address of NAMING_CONTEXT_LIST entry in debugee address space

    pNextNC - address of next NAMING_CONTEXT_LIST entry in debugee address space

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    NAMING_CONTEXT_LIST *pNCListTmp;

    Assert(pNextNC);
    pNCListTmp = ReadMemory(pNCL, sizeof(NAMING_CONTEXT_LIST));

    if ( NULL == pNCListTmp )
        return(FALSE);

    Printf("%sNC Entry @%p\n",
           Indent(nIndents),
           pNCL);
    nIndents++;
    Dump_DSNAME(nIndents, pNCListTmp->pNC);
    Printf("%sNCDNT          0x%x\n",
           Indent(nIndents),
           pNCListTmp->NCDNT);
    Printf("%sDelContDNT     0x%x\n",
           Indent(nIndents),
           pNCListTmp->DelContDNT);
    Printf("%sLost&FoundDNT  0x%x\n",
           Indent(nIndents),
           pNCListTmp->LostAndFoundDNT);
    Printf("%sfReplNotify    %s\n",
           Indent(nIndents),
           pNCListTmp->fReplNotify ? "True": "False");
    Printf("%sNextNC is    @ %p\n", Indent(nIndents), pNCListTmp->pNextNC);

    *pNextNC = pNCListTmp->pNextNC;
    FreeMemory(pNCListTmp);

    return TRUE;
}


BOOL
Dump_NAMING_CONTEXT_LIST(
    IN DWORD nIndents,
    IN PCHAR pNCname,
    IN PVOID pNCL)

/*++

Routine Description:

    Public NAMING_CONTEXT_RC dump routine.

Arguments:

    nIndents - Indentation level desired.

    pNCname -- name of the list

    pNCL - address of NAMING_CONTEXT_LIST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    DWORD   nTmp;

    Printf("%s%s @ %p\n", Indent(nIndents), pNCname, pNCL);

    nTmp = nIndents + 1;
    while ( NULL != pNCL )
    {
        if (!Dump_NC_Entry(nTmp, pNCL, &pNCL)) {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL
Dump_RESOBJ (
    IN DWORD nIndents,
    IN PVOID pvProcess)
{
    RESOBJ * pResObj;

    if (NULL == pvProcess) {
        Printf("%sNo resolved object\n", Indent(nIndents));
        return FALSE;
    }

    pResObj = (RESOBJ*) ReadMemory(pvProcess, sizeof(READARG));
    if (pResObj) {
        Dump_DSNAME(nIndents, pResObj->pObj);
        Printf("%sDNT = 0x%x, PDNT = 0x%x, NCDNT = 0x%x\n",
               Indent(nIndents),
               pResObj->DNT,
               pResObj->PDNT,
               pResObj->NCDNT);
        Printf("%sInstance Type = 0x%x\n",
               Indent(nIndents),
               pResObj->InstanceType);
        Printf("%sObjectClass   = 0x%x\n",
               Indent(nIndents),
               pResObj->MostSpecificObjClass);
        Printf("%sIs Deleted    = %s\n",
               Indent(nIndents),
               pResObj->IsDeleted ? "True" : "False" );
        FreeMemory(pResObj);
    }
    return TRUE;
}

BOOL
Dump_BINDARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BINDARG dump routine.  BINDARG is one of the parameters to
    DSA_DirBind().

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BINDARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL    fSuccess = FALSE;
    BINDARG *pBind = NULL;
    BYTE    *pVal = NULL;

    Printf("%sBINDARG:\n", Indent(nIndents));
    nIndents++;

    if ( NULL != (pBind = (BINDARG *) ReadMemory(
                                            pvProcess,
                                            sizeof(BINDARG))) )
    {
        if ( NULL != (pVal = (BYTE *) ReadMemory(
                                            pBind->Versions.pVal,
                                            pBind->Versions.len)) )
        {
            Printf("%sVersions - length(0x%x)\n",
                   Indent(nIndents),
                   pBind->Versions.len);
            ShowBinaryData(nIndents + 1, pVal, pBind->Versions.len);

            Printf("%sCredentials @ %p\n",
                   Indent(nIndents),
                   pBind->pCredents);

            if ( NULL == pBind->pCredents )
            {
                fSuccess = TRUE;
            }
            else
            {
                fSuccess = Dump_DSNAME(nIndents + 1, pBind->pCredents);
            }

            FreeMemory(pVal);
        }

        FreeMemory(pBind);
    }

    return(fSuccess);
}

BOOL
Dump_BINDRES(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BINDRES dump routine.  BINDRES is the return parameter from
    DSA_DirBind().

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BINDRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    //
    // BINDRES is the same as a BINDARG.
    //

    Printf("%sBINDRES: (same as BINDARG)\n", Indent(nIndents));
    return(Dump_BINDARG(nIndents, pvProcess));
}

// aux data structures for error dumping (below)

//
// We want the following Table both in Free and Checked Build
//
typedef struct
{
    char* ErrStr;
    ULONG ErrNo;
}ERRINFOSTRUCT;


static ERRINFOSTRUCT ProblemTable[]=
{
{"NO_ATTRIBUTE_OR_VAL", PR_PROBLEM_NO_ATTRIBUTE_OR_VAL},
{"INVALID_ATT_SYNTAX", PR_PROBLEM_INVALID_ATT_SYNTAX },
{"UNDEFINED_ATT_TYPE", PR_PROBLEM_UNDEFINED_ATT_TYPE },
{"WRONG_MATCH_OPER", PR_PROBLEM_WRONG_MATCH_OPER},
{"CONSTRAINT_ATT_TYPE", PR_PROBLEM_CONSTRAINT_ATT_TYPE},
{"ATT_OR_VALUE_EXISTS", PR_PROBLEM_ATT_OR_VALUE_EXISTS},
{"NO_OBJECT", NA_PROBLEM_NO_OBJECT},
{"NO_OBJ_FOR_ALIAS", NA_PROBLEM_NO_OBJ_FOR_ALIAS },
{"BAD_ATT_SYNTAX", NA_PROBLEM_BAD_ATT_SYNTAX},
{"ALIAS_NOT_ALLOWED", NA_PROBLEM_ALIAS_NOT_ALLOWED},
{"NAMING_VIOLATION", NA_PROBLEM_NAMING_VIOLATION},
{"BAD_NAME", NA_PROBLEM_BAD_NAME},
{"INAPPROPRIATE_AUTH", SE_PROBLEM_INAPPROPRIATE_AUTH},
{"INVALID_CREDENTS", SE_PROBLEM_INVALID_CREDENTS},
{"INSUFF_ACCESS_RIGHTS", SE_PROBLEM_INSUFF_ACCESS_RIGHTS},
{"INVALID_SIGNATURE", SE_PROBLEM_INVALID_SIGNATURE},
{"PROTECTION_REQUIRED", SE_PROBLEM_PROTECTION_REQUIRED},
{"NO_INFORMATION", SE_PROBLEM_NO_INFORMATION},
{"BUSY", SV_PROBLEM_BUSY},
{"UNAVAILABLE", SV_PROBLEM_UNAVAILABLE},
{"WILL_NOT_PERFORM", SV_PROBLEM_WILL_NOT_PERFORM},
{"CHAINING_REQUIRED", SV_PROBLEM_CHAINING_REQUIRED},
{"UNABLE_TO_PROCEED", SV_PROBLEM_UNABLE_TO_PROCEED},
{"INVALID_REFERENCE", SV_PROBLEM_INVALID_REFERENCE},
{"TIME_EXCEEDED", SV_PROBLEM_TIME_EXCEEDED},
{"ADMIN_LIMIT_EXCEEDED", SV_PROBLEM_ADMIN_LIMIT_EXCEEDED},
{"LOOP_DETECTED", SV_PROBLEM_LOOP_DETECTED},
{"UNAVAIL_EXTENSION", SV_PROBLEM_UNAVAIL_EXTENSION},
{"OUT_OF_SCOPE", SV_PROBLEM_OUT_OF_SCOPE},
{"DIR_ERROR", SV_PROBLEM_DIR_ERROR},
{"NAME_VIOLATION", UP_PROBLEM_NAME_VIOLATION},
{"OBJ_CLASS_VIOLATION", UP_PROBLEM_OBJ_CLASS_VIOLATION},
{"CANT_ON_NON_LEAF", UP_PROBLEM_CANT_ON_NON_LEAF},
{"CANT_ON_RDN", UP_PROBLEM_CANT_ON_RDN},
{"ENTRY_EXISTS", UP_PROBLEM_ENTRY_EXISTS},
{"AFFECTS_MULT_DSAS", UP_PROBLEM_AFFECTS_MULT_DSAS},
{"CANT_MOD_OBJ_CLASS", UP_PROBLEM_CANT_MOD_OBJ_CLASS},
{"Huh?", 0}};


// Codes should be win32 error codes, defined in winerror.h
static ERRINFOSTRUCT CodeTable[]=
{
{"ADD_REPLICA_INHIBITED", ERROR_DS_ADD_REPLICA_INHIBITED},
{"ALIASED_OBJ_MISSING", ERROR_DS_ALIASED_OBJ_MISSING},
{"ALIAS_POINTS_TO_ALIAS", ERROR_DS_ALIAS_POINTS_TO_ALIAS},
{"ATTRIBUTE_OWNED_BY_SAM", ERROR_DS_ATTRIBUTE_OWNED_BY_SAM},
{"ATT_ALREADY_EXISTS", ERROR_DS_ATT_ALREADY_EXISTS},
{"ATT_IS_NOT_ON_OBJ", ERROR_DS_ATT_IS_NOT_ON_OBJ},
{"ATT_NOT_DEF_FOR_CLASS", ERROR_DS_ATT_NOT_DEF_FOR_CLASS},
{"ATT_NOT_DEF_IN_SCHEMA", ERROR_DS_ATT_NOT_DEF_IN_SCHEMA},
{"ATT_SCHEMA_REQ_ID", ERROR_DS_ATT_SCHEMA_REQ_ID},
{"ATT_SCHEMA_REQ_SYNTAX", ERROR_DS_ATT_SCHEMA_REQ_SYNTAX},
{"ATT_VAL_ALREADY_EXISTS", ERROR_DS_ATT_VAL_ALREADY_EXISTS},
{"AUX_CLS_TEST_FAIL", ERROR_DS_AUX_CLS_TEST_FAIL},
{"BAD_ATT_SCHEMA_SYNTAX", ERROR_DS_BAD_ATT_SCHEMA_SYNTAX},
{"BAD_ATT_SYNTAX", ERROR_DS_INVALID_ATTRIBUTE_SYNTAX},
{"BAD_HIERARCHY_FILE", ERROR_DS_BAD_HIERARCHY_FILE},
{"BAD_INSTANCE_TYPE", ERROR_DS_BAD_INSTANCE_TYPE},
{"BAD_NAME_SYNTAX", ERROR_DS_BAD_NAME_SYNTAX},
{"BAD_RDN_ATT_ID_SYNTAX", ERROR_DS_BAD_RDN_ATT_ID_SYNTAX},
{"BUILD_HIERARCHY_TABLE_FAILED", ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED},
{"CANT_ADD_ATT_VALUES", ERROR_DS_CANT_ADD_ATT_VALUES},
{"CANT_ADD_SYSTEM_ONLY", ERROR_DS_CANT_ADD_SYSTEM_ONLY},
{"CANT_CACHE_ATT", ERROR_DS_CANT_CACHE_ATT},
{"CANT_CACHE_CLASS", ERROR_DS_CANT_CACHE_CLASS},
{"CANT_DELETE", ERROR_DS_CANT_DELETE},
{"CANT_DELETE_DSA_OBJ", ERROR_DS_CANT_DELETE_DSA_OBJ},
{"CANT_DEL_MASTER_CROSSREF", ERROR_DS_CANT_DEL_MASTER_CROSSREF},
{"CANT_DEREF_ALIAS", ERROR_DS_CANT_DEREF_ALIAS},
{"CANT_FIND_DSA_OBJ", ERROR_DS_CANT_FIND_DSA_OBJ},
{"CANT_FIND_EXPECTED_NC", ERROR_DS_CANT_FIND_EXPECTED_NC},
{"CANT_FIND_NC_IN_CACHE", ERROR_DS_CANT_FIND_NC_IN_CACHE},
{"CANT_MIX_MASTER_AND_REPS", ERROR_DS_CANT_MIX_MASTER_AND_REPS},
{"CANT_MOD_SYSTEM_ONLY", ERROR_DS_CANT_MOD_SYSTEM_ONLY},
{"CANT_REMOVE_ATT_CACHE", ERROR_DS_CANT_REMOVE_ATT_CACHE},
{"CANT_REMOVE_CLASS_CACHE", ERROR_DS_CANT_REMOVE_CLASS_CACHE},
{"CANT_REM_MISSING_ATT", ERROR_DS_CANT_REM_MISSING_ATT},
{"CANT_REM_MISSING_ATT_VAL", ERROR_DS_CANT_REM_MISSING_ATT_VAL},
{"CANT_REPLACE_HIDDEN_REC", ERROR_DS_CANT_REPLACE_HIDDEN_REC},
{"CANT_RETRIEVE_CHILD", ERROR_DS_CANT_RETRIEVE_CHILD},
{"CANT_RETRIEVE_DN", ERROR_DS_CANT_RETRIEVE_DN},
{"CANT_RETRIEVE_INSTANCE", ERROR_DS_CANT_RETRIEVE_INSTANCE},
{"CHILDREN_EXIST", ERROR_DS_CHILDREN_EXIST},
{"CLASS_MUST_BE_CONCRETE", ERROR_DS_CLASS_MUST_BE_CONCRETE},
{"CLASS_NOT_DSA", ERROR_DS_CLASS_NOT_DSA},
{"CODE_INCONSISTENCY", ERROR_DS_CODE_INCONSISTENCY},
{"CONFIG_PARAM_MISSING", ERROR_DS_CONFIG_PARAM_MISSING},
{"COULDNT_CONTACT_FSMO", ERROR_DS_COULDNT_CONTACT_FSMO},
{"COUNTING_AB_INDICES_FAILED", ERROR_DS_COUNTING_AB_INDICES_FAILED},
{"CROSS_NC_DN_RENAME", ERROR_DS_CROSS_NC_DN_RENAME},
{"CROSS_REF_EXISTS", ERROR_DS_CROSS_REF_EXISTS},
{"DATABASE_ERROR", ERROR_DS_DATABASE_ERROR},
{"DRA_SCHEMA_MISMATCH", ERROR_DS_DRA_SCHEMA_MISMATCH},
{"DSA_MUST_BE_INT_MASTER", ERROR_DS_DSA_MUST_BE_INT_MASTER},
{"DUP_LDAP_DISPLAY_NAME", ERROR_DS_DUP_LDAP_DISPLAY_NAME},
{"DUP_MAPI_ID", ERROR_DS_DUP_MAPI_ID},
{"DUP_OID", ERROR_DS_DUP_OID},
{"DUP_RDN", ERROR_DS_DUP_RDN},
{"DUP_SCHEMA_ID_GUID", ERROR_DS_DUP_SCHEMA_ID_GUID},
{"EXISTS_IN_AUX_CLS", ERROR_DS_EXISTS_IN_AUX_CLS},
{"EXISTS_IN_MAY_HAVE", ERROR_DS_EXISTS_IN_MAY_HAVE},
{"EXISTS_IN_MUST_HAVE", ERROR_DS_EXISTS_IN_MUST_HAVE},
{"EXISTS_IN_POSS_SUP", ERROR_DS_EXISTS_IN_POSS_SUP},
{"EXISTS_IN_SUB_CLS", ERROR_DS_EXISTS_IN_SUB_CLS},
{"GCVERIFY_ERROR", ERROR_DS_GCVERIFY_ERROR},
{"GENERIC_ERROR", ERROR_DS_GENERIC_ERROR},
{"GOVERNSID_MISSING", ERROR_DS_GOVERNSID_MISSING},
{"HIERARCHY_TABLE_MALLOC_FAILED", ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED},
{"ILLEGAL_MOD_OPERATION", ERROR_DS_ILLEGAL_MOD_OPERATION},
{"ILLEGAL_SUPERIOR", ERROR_DS_ILLEGAL_SUPERIOR},
{"INSUFF_ACCESS_RIGHTS", ERROR_DS_INSUFF_ACCESS_RIGHTS},
{"INTERNAL_FAILURE", ERROR_DS_INTERNAL_FAILURE},
{"INVALID_DMD", ERROR_DS_INVALID_DMD},
{"INVALID_ROLE_OWNER", ERROR_DS_INVALID_ROLE_OWNER},
{"MASTERDSA_REQUIRED", ERROR_DS_MASTERDSA_REQUIRED},
{"MAX_OBJ_SIZE_EXCEEDED", ERROR_DS_MAX_OBJ_SIZE_EXCEEDED},
{"MISSING_EXPECTED_ATT", ERROR_DS_MISSING_EXPECTED_ATT},
{"MISSING_REQUIRED_ATT", ERROR_DS_MISSING_REQUIRED_ATT},
{"MISSING_SUPREF", ERROR_DS_MISSING_SUPREF},
{"NAME_REFERENCE_INVALID", ERROR_DS_NAME_REFERENCE_INVALID},
{"NAME_TOO_LONG", ERROR_DS_NAME_TOO_LONG},
{"NAME_TOO_MANY_PARTS", ERROR_DS_NAME_TOO_MANY_PARTS},
{"NAME_TYPE_UNKNOWN", ERROR_DS_NAME_TYPE_UNKNOWN},
{"NAME_UNPARSEABLE", ERROR_DS_NAME_UNPARSEABLE},
{"NAME_VALUE_TOO_LONG", ERROR_DS_NAME_VALUE_TOO_LONG},
{"NCNAME_MISSING_CR_REF", ERROR_DS_NCNAME_MISSING_CR_REF},
{"NCNAME_MUST_BE_NC", ERROR_DS_NCNAME_MUST_BE_NC},
{"NONEXISTENT_MAY_HAVE", ERROR_DS_NONEXISTENT_MAY_HAVE},
{"NONEXISTENT_MUST_HAVE", ERROR_DS_NONEXISTENT_MUST_HAVE},
{"NONEXISTENT_POSS_SUP", ERROR_DS_NONEXISTENT_POSS_SUP},
{"NOTIFY_FILTER_TOO_COMPLEX", ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX},
{"NOT_AN_OBJECT", ERROR_DS_NOT_AN_OBJECT},
{"NOT_ON_BACKLINK", ERROR_DS_NOT_ON_BACKLINK},
{"NO_CHAINED_EVAL", ERROR_DS_NO_CHAINED_EVAL},
{"NO_CHAINING", ERROR_DS_NO_CHAINING},
{"NO_CROSSREF_FOR_NC", ERROR_DS_NO_CROSSREF_FOR_NC},
{"NO_DELETED_NAME", ERROR_DS_NO_DELETED_NAME},
{"NO_PARENT_OBJECT", ERROR_DS_NO_PARENT_OBJECT},
{"NO_RDN_DEFINED_IN_SCHEMA", ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA},
{"NO_REQUESTED_ATTS_FOUND", ERROR_DS_NO_REQUESTED_ATTS_FOUND},
{"OBJECT_CLASS_REQUIRED", ERROR_DS_OBJECT_CLASS_REQUIRED},
{"OBJ_CLASS_NOT_DEFINED", ERROR_DS_OBJ_CLASS_NOT_DEFINED},
{"OBJ_CLASS_NOT_SUBCLASS", ERROR_DS_OBJ_CLASS_NOT_SUBCLASS},
{"OBJ_GUID_EXISTS", ERROR_DS_OBJ_GUID_EXISTS},
{"OBJ_NOT_FOUND", ERROR_DS_OBJ_NOT_FOUND},
{"OBJ_STRING_NAME_EXISTS", ERROR_DS_OBJ_STRING_NAME_EXISTS},
{"OBJ_TOO_LARGE", ERROR_DS_OBJ_TOO_LARGE},
{"OUT_OF_SCOPE", ERROR_DS_OUT_OF_SCOPE},
{"PARENT_IS_AN_ALIAS", ERROR_DS_PARENT_IS_AN_ALIAS},
{"RANGE_CONSTRAINT", ERROR_DS_RANGE_CONSTRAINT},
{"RDN_DOESNT_MATCH_SCHEMA", ERROR_DS_RDN_DOESNT_MATCH_SCHEMA},
{"RECALCSCHEMA_FAILED", ERROR_DS_RECALCSCHEMA_FAILED},
{"REFERRAL", ERROR_DS_REFERRAL},
{"REPLICATOR_ONLY", ERROR_DS_REPLICATOR_ONLY},
{"ROOT_CANT_BE_SUBREF", ERROR_DS_ROOT_CANT_BE_SUBREF},
{"ROOT_MUST_BE_NC", ERROR_DS_ROOT_MUST_BE_NC},
{"ROOT_REQUIRES_CLASS_TOP", ERROR_DS_ROOT_REQUIRES_CLASS_TOP},
{"SCHEMA_ALLOC_FAILED", ERROR_DS_SCHEMA_ALLOC_FAILED},
{"SCHEMA_NOT_LOADED", ERROR_DS_SCHEMA_NOT_LOADED},
{"SECURITY_CHECKING_ERROR", ERROR_DS_SECURITY_CHECKING_ERROR},
{"SECURITY_ILLEGAL_MODIFY", ERROR_DS_SECURITY_ILLEGAL_MODIFY},
{"SEC_DESC_INVALID", ERROR_DS_SEC_DESC_INVALID},
{"SEC_DESC_TOO_SHORT", ERROR_DS_SEC_DESC_TOO_SHORT},
{"SEMANTIC_ATT_TEST", ERROR_DS_SEMANTIC_ATT_TEST},
{"SHUTTING_DOWN", ERROR_DS_SHUTTING_DOWN},
{"SINGLE_VALUE_CONSTRAINT", ERROR_DS_SINGLE_VALUE_CONSTRAINT},
{"SUBREF_MUST_HAVE_PARENT", ERROR_DS_SUBREF_MUST_HAVE_PARENT},
{"SUBTREE_NOTIFY_NOT_NC_HEAD", ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD},
{"SUB_CLS_TEST_FAIL", ERROR_DS_SUB_CLS_TEST_FAIL},
{"SYNTAX_MISMATCH", ERROR_DS_SYNTAX_MISMATCH},
{"TREE_DELETE_NOT_FINISHED", ERROR_DS_TREE_DELETE_NOT_FINISHED},
{"UNKNOWN_ERROR", ERROR_DS_UNKNOWN_ERROR},
{"UNKNOWN_OPERATION", ERROR_DS_UNKNOWN_OPERATION},
{"USER_BUFFER_TO_SMALL", ERROR_DS_USER_BUFFER_TO_SMALL},
{"Undefined error (look in winerror.h)", 0}};


char * GetProblemString(USHORT problem)
{
    ERRINFOSTRUCT * pEI = ProblemTable;

    while (pEI->ErrNo != problem && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}

char * GetCodeString(ULONG code)
{
    ERRINFOSTRUCT * pEI = CodeTable;

    while (pEI->ErrNo != code && pEI->ErrNo)
      ++pEI;

    return pEI->ErrStr;
}


void
Dump_Error(IN DWORD nIndents,
           IN DWORD errCode,
           IN PVOID pErrInfoProcess)
/*++
 *
 * Routine description: helper for Dump_THSTATE
 *
 */
{
    DIRERR * pErrInfo;
    PROBLEMLIST *pplProcess, *ppl;
    DSA_ADDRESS_LIST *pdal, *pdalProcess;
    WCHAR *pw;
    unsigned long u, size;

    if (NULL == (pErrInfo = ReadMemory(pErrInfoProcess, sizeof(DIRERR)))) {
        return;
    }

    Printf("%spErrInfo    @ %p\n", Indent(nIndents), pErrInfoProcess);
    nIndents++;
    switch (errCode) {
      case 0:
        /* no error */
        break;

      case attributeError:
        Printf("%sAttribute error with %u attribute problems, DSID-%08X:\n",
               Indent(nIndents),
               pErrInfo->AtrErr.count,
               pErrInfo->AtrErr.FirstProblem.intprob.dsid);
        Printf("%s%u: att %x problem %u (%s) code %d (%s)\n",
               Indent(nIndents+1),
               0,
               pErrInfo->AtrErr.FirstProblem.intprob.type,
               pErrInfo->AtrErr.FirstProblem.intprob.problem,
               GetProblemString(pErrInfo->AtrErr.FirstProblem.intprob.problem),
               pErrInfo->AtrErr.FirstProblem.intprob.extendedErr,
               GetCodeString(pErrInfo->AtrErr.FirstProblem.intprob.extendedErr));
        ppl =  &pErrInfo->AtrErr.FirstProblem;
        pplProcess = ppl->pNextProblem;
        for (u=1; u<pErrInfo->AtrErr.count; u++) {
            ppl = ReadMemory(pplProcess, sizeof(PROBLEMLIST));
            if (ppl) {
                Printf("%s%u: att %x problem %u (%s) code %d (%s)\n",
                       Indent(nIndents+1),
                       u,
                       ppl->intprob.type,
                       ppl->intprob.problem,
                       GetProblemString(ppl->intprob.problem),
                       ppl->intprob.extendedErr,
                       GetCodeString(ppl->intprob.extendedErr));
                FreeMemory(ppl);
            }
        }
        break;

      case nameError:
        Printf("%sName Error with problem %u (%s), code %d (%s), DSID %08X\n",
               Indent(nIndents),
               pErrInfo->NamErr.problem,
               GetProblemString(pErrInfo->NamErr.problem),
               pErrInfo->NamErr.extendedErr,
               GetCodeString(pErrInfo->NamErr.extendedErr),
               pErrInfo->NamErr.dsid);
        break;

      case updError:
        Printf("%sUpdate Error with problem %u (%s), code %d (%s), and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->UpdErr.problem,
               GetProblemString(pErrInfo->UpdErr.problem),
               pErrInfo->UpdErr.extendedErr,
               GetCodeString(pErrInfo->UpdErr.extendedErr),
               pErrInfo->UpdErr.dsid);
        break;

      case systemError:
        // Note that problems are from a different space
        Printf("%sSystem Error with problem %u (%s), code %d (%s), and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->UpdErr.problem,
               strerror(pErrInfo->UpdErr.problem),
               pErrInfo->UpdErr.extendedErr,
               GetCodeString(pErrInfo->UpdErr.extendedErr),
               pErrInfo->UpdErr.dsid);
        break;

      case referralError:
        Printf("%sReferral with code %d (%s) and %u access points, DSID %08X\n",
               Indent(nIndents),
               pErrInfo->RefErr.extendedErr,
               GetCodeString(pErrInfo->RefErr.extendedErr),
               pErrInfo->RefErr.Refer.count,
               pErrInfo->RefErr.dsid);

        pdalProcess = pErrInfo->RefErr.Refer.pDAL;
        while (pdalProcess) {
            pdal = ReadMemory(pdalProcess, sizeof(DSA_ADDRESS_LIST));
            if (!pdal) {
                pdalProcess = NULL;
                break;
            }
            pw = ReadMemory(pdal->Address.Buffer, pdal->Address.Length + 2);
            if (pw) {
                // Our string isn't null terminated, so we
                // over-fetch by two bytes and then blast the extra
                // to null.  This is in the debugger (not debuggee)
                // space, so it's ok.  What if the page ended less
                // than two bytes after the end of the string? Well,
                // then the ReadMemory should have failed.
                pw[pdal->Address.Length/2] = L'\0';
                Printf("%sAP: %S\n",
                       Indent(nIndents+1),
                       pw);
                FreeMemory(pw);
            }
            pdalProcess = pdal->pNextAddress;
            FreeMemory(pdal);
        }
        break;

      case securityError:
        Printf("%sSecurity Error with problem %u (%s), code %d (%s) and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->SecErr.problem,
               GetProblemString(pErrInfo->SecErr.problem),
               pErrInfo->SecErr.extendedErr,
               GetCodeString(pErrInfo->SecErr.extendedErr),
               pErrInfo->SecErr.dsid);
        break;

      case serviceError:
        Printf("%sService Error with problem %u (%s), code %d (%s) and DSID %08X\n",
               Indent(nIndents),
               pErrInfo->SvcErr.problem,
               GetProblemString(pErrInfo->SvcErr.problem),
               pErrInfo->SvcErr.extendedErr,
               GetCodeString(pErrInfo->SvcErr.extendedErr),
               pErrInfo->SvcErr.dsid);
        break;

      default:
        Printf("%sUnknown error code of %u\n",
               Indent(nIndents),
               errCode);
        break;
    }
    nIndents--;

    FreeMemory(pErrInfo);
}

void
Dump_CommRes(IN DWORD nIndents,
             IN PVOID pCommResProcess)
/*++
 *
 * Routine description: helper for Dump_XxxRes routines
 *
 */
{
    COMMRES * pCommRes;

    Printf( "%sCOMMRES:\n", Indent(nIndents) );
    nIndents++;

    if (NULL == (pCommRes = ReadMemory(pCommResProcess, sizeof(COMMRES)))) {
        return;
    }

    Printf("%sAlias dereferenced: %s\n",
           Indent(nIndents),
           pCommRes->aliasDeref ? "yes": "no");

    Dump_Error(nIndents,
               pCommRes->errCode,
               (BYTE *) pCommResProcess + offsetof( COMMRES, pErrInfo )
        );

    FreeMemory(pCommRes);
}

void
DumpZone(IN MEMZONE *pZone,
         IN DWORD nIndents)
{
    if (pZone->Base) {
        Printf("%sZone Base        @ %p  (zone end at @ %p)\n",
               Indent(nIndents),
               pZone->Base,
               pZone->Base + ZONETOTALSIZE);
        Printf("%sZone Current     @ %p\n",
               Indent(nIndents),
               pZone->Cur);
        if (pZone->Full) {
            Printf("%sZone is full (all %d blocks used)\n",
                   Indent(nIndents),
                   ZONETOTALSIZE / ZONEBLOCKSIZE);
        }
        else {
            Printf("%sZone has used %d of %d available blocks \n",
                   Indent(nIndents),
                   (pZone->Cur - pZone->Base) / ZONEBLOCKSIZE,
                   ZONETOTALSIZE / ZONEBLOCKSIZE);
        }
    }
    else {
        Printf("%sNo zone present\n",
               Indent(nIndents));
    }
}

BOOL
Dump_THSTATE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public THSTATE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of THSTATE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    THSTATE *pState = NULL;
    DWORD   cBytes;
    CHAR    szTime[ SZDSTIME_LEN ];
    CHAR    szUuid[ 40 ];
    DWORD   cTickNow = GetTickCount();
    DSTIME  dsTimeNow = GetSecondsSince1601();
    DSTIME  dsTimeTransStarted;
    char *pStrTmp;
    PAUTHZ_CLIENT_CONTEXT pAuthzCC;

    Printf("%sTHSTATE @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    //
    // THSTATE has some DBG-only fields at the end.  Always read the
    // non-DBG amount of memory since the process being debugged may
    // not be a DBG version although the extensions DLL is.  Although
    // we tried doing that by taking the offset of the last non-DBG-only
    // field, that didn't work because people added new fields and forgot
    // to update this count.  We can't just use the offset of the first
    // DBG only field, because that would break in a non-DBG build!
    // Hence, the revolting solution below:

#if DBG
    cBytes = OFFSET(THSTATE, Size) + sizeof(DWORD);
#else
    cBytes = sizeof(THSTATE);
#endif

    if ( NULL == (pState = ReadMemory(pvProcess, cBytes)) )

    {
        return(FALSE);
    }

    Printf("%shThread              0x%x\n",
           Indent(nIndents),
           pState->hThread);
    Printf("%shHeap                0x%x\n",
           Indent(nIndents),
           pState->hHeap);
    Printf("%scAllocs              0x%x\n",
           Indent(nIndents),
           pState->cAllocs);
    DumpZone(&pState->Zone,
             nIndents + 1);
    Printf("%sdwClientID           0x%x\n",
           Indent(nIndents),
           pState->dwClientID);
    Printf("%serrCode              0x%x\n",
           Indent(nIndents),
           pState->errCode);
    if (pState->errCode) {
        Dump_Error(nIndents,
                   pState->errCode,
                   pState->pErrInfo);
    }
    Printf("%spDB                @ %p\n",
           Indent(nIndents),
           pState->pDB);

    Printf("%sJetCache:\n", Indent(nIndents));
    ++nIndents;
    Printf("%stransLevel            %d\n",
           Indent(nIndents),
           pState->JetCache.transLevel);

    dsTimeTransStarted
        = dsTimeNow
          - (cTickNow - pState->JetCache.cTickTransLevel1Started) / 1000;
    Printf("%scTickTransLevel1Started %u (== %s)\n",
           Indent(nIndents),
           pState->JetCache.cTickTransLevel1Started,
           DSTimeToDisplayString(dsTimeTransStarted, szTime));

    Printf("%sSessionID            0x%x\n",
           Indent(nIndents),
           pState->JetCache.sesid);
    Printf("%sDataBaseID           0x%x\n",
           Indent(nIndents),
           pState->JetCache.dbid);
    Printf("%sObjTable             0x%x\n",
           Indent(nIndents),
           pState->JetCache.objtbl);
    Printf("%sSearchTbl            0x%x\n",
           Indent(nIndents),
           pState->JetCache.searchtbl);
    Printf("%sLinkTbl              0x%x\n",
           Indent(nIndents),
           pState->JetCache.linktbl);
    Printf("%sSDPropTbl            0x%x\n",
           Indent(nIndents),
           pState->JetCache.sdproptbl);
    Printf("%sSDTbl                0x%x\n",
           Indent(nIndents),
           pState->JetCache.sdtbl);
    Printf("%sTablesInUse?         %s\n",
           Indent(nIndents),
           pState->JetCache.tablesInUse ? "true": "false");
    Printf("%stransactionalDataPtr @%p\n",
           Indent(nIndents),
           pState->JetCache.dataPtr);
    --nIndents;

    // The goofy dump value is because the local DN read cache is an array
    // embedded inside the thstate, and we need to dump its base address
    // in the process space, not in debugger space.
    Printf("%sLocalDNReadCache        @ %p\n",
           Indent(nIndents),
           ((PBYTE)(pState->LocalDNReadCache) - (PBYTE)pState)
           + (PBYTE)pvProcess);

    Printf("%sGlobalDNReadCache        @ %p\n",
           Indent(nIndents),
           pState->Global_DNReadCache);

    //BITFIELD BLOCK

    Printf("%stransType                 %s\n",
           Indent(nIndents),
           (pState->transType == SYNC_READ_ONLY)
               ? "SYNC_READ_ONLY"
               : (pState->transType == SYNC_WRITE)
                   ? "SYNC_WRITE"
                   : "!!! Unknown !!!");
    Printf("%stransControl              %s\n",
           Indent(nIndents),
           (pState->transControl == TRANSACT_BEGIN_END)
               ? "TRANSACT_BEGIN_END"
               : (pState->transControl == TRANSACT_DONT_BEGIN_END)
                   ? "TRANSACT_DONT_BEGIN_END"
                   : (pState->transControl == TRANSACT_BEGIN_DONT_END)
                       ? "TRANSACT_BEGIN_DONT_END"
                       : (pState->transControl == TRANSACT_DONT_BEGIN_DONT_END)
                           ? "TRANSACT_DONT_BEGIN_DONT_END"
                           : "!!! Unknown !!!");

    // Start dumping the thstate bit field:
    Printf("%sDumping the THSTATE bitfield bits (only printed bit if TRUE):\n", Indent(nIndents));
    nIndents++;
    { // Just for indentational clarity of printing
#define DUMP_THSTATE_BITFIELD_BIT(fStr, fBit)   if (pState->fBit) { Printf("%s" fStr "\n", Indent(nIndents), 1 & pState->fBit); }

        DUMP_THSTATE_BITFIELD_BIT("fSyncSet", fSyncSet);

        DUMP_THSTATE_BITFIELD_BIT("fCatalogCacheTouched", fCatalogCacheTouched);

        DUMP_THSTATE_BITFIELD_BIT("fSDP", fSDP);

        DUMP_THSTATE_BITFIELD_BIT("fDRA", fDRA);

        DUMP_THSTATE_BITFIELD_BIT("fEOF", fEOF);

        DUMP_THSTATE_BITFIELD_BIT("fLazyCommit", fLazyCommit);

        DUMP_THSTATE_BITFIELD_BIT("fDSA", fDSA);

        DUMP_THSTATE_BITFIELD_BIT("fSAM", fSAM);

        DUMP_THSTATE_BITFIELD_BIT("fSamDoCommit", fSamDoCommit);

        DUMP_THSTATE_BITFIELD_BIT("fSamWriteLockHeld", fSamWriteLockHeld);

        DUMP_THSTATE_BITFIELD_BIT("UpdateDITStructure", UpdateDITStructure);

        DUMP_THSTATE_BITFIELD_BIT("RecalcSchemaNow", RecalcSchemaNow);

        DUMP_THSTATE_BITFIELD_BIT("fLsa", fLsa);

        DUMP_THSTATE_BITFIELD_BIT("fAccessChecksCompleted", fAccessChecksCompleted);

        DUMP_THSTATE_BITFIELD_BIT("fGCLocalCleanup", fGCLocalCleanup);

        DUMP_THSTATE_BITFIELD_BIT("fDidInvalidate", fDidInvalidate);

        DUMP_THSTATE_BITFIELD_BIT("fBeginDontEndHoldsSamLock", fBeginDontEndHoldsSamLock);

        DUMP_THSTATE_BITFIELD_BIT("fCrossDomainMove", fCrossDomainMove);

        DUMP_THSTATE_BITFIELD_BIT("fNlSubnetNotify", fNlSubnetNotify);

        DUMP_THSTATE_BITFIELD_BIT("fNlSiteObjNotify", fNlSiteObjNotify);

        DUMP_THSTATE_BITFIELD_BIT("fNlSiteNotify", fNlSiteNotify);

        DUMP_THSTATE_BITFIELD_BIT("fDefaultLcid", fDefaultLcid);

        DUMP_THSTATE_BITFIELD_BIT("fPhantomDaemon", fPhantomDaemon);

        DUMP_THSTATE_BITFIELD_BIT("fAnchorInvalidated", fAnchorInvalidated);

        DUMP_THSTATE_BITFIELD_BIT("fSchemaConflict", fSchemaConflict);

        DUMP_THSTATE_BITFIELD_BIT("fExecuteKccOnCommit", fExecuteKccOnCommit);

        DUMP_THSTATE_BITFIELD_BIT("fLinkedValueReplication", fLinkedValueReplication);

        DUMP_THSTATE_BITFIELD_BIT("fNlDnsRootAliasNotify", fNlDnsRootAliasNotify);
        
        DUMP_THSTATE_BITFIELD_BIT("fSingleUserModeThread", fSingleUserModeThread);
          
        DUMP_THSTATE_BITFIELD_BIT("fDeletingTree", fDeletingTree);

        DUMP_THSTATE_BITFIELD_BIT("fBehaviorVersionUpdate", fBehaviorVersionUpdate);

        DUMP_THSTATE_BITFIELD_BIT("fIsValidLongRunningTask", fIsValidLongRunningTask);

    }
    nIndents--;       
    //END BITFIELD BLOCK

    Printf("%spSamNotificationTail @ %p\n",
           Indent(nIndents),
           pState->pSamNotificationTail);
    Printf("%spSamNotificationHead @ %p\n",
           Indent(nIndents),
           pState->pSamNotificationHead);
    Printf("%sUnCommUsn            %I64d\n",
           Indent(nIndents),
           pState->UnCommUsn);
    Printf("%shHeapOrg             0x%x\n",
           Indent(nIndents),
           pState->hHeapOrg);
    Printf("%scAllocsOrg           0x%x\n",
           Indent(nIndents),
           pState->cAllocsOrg);
    DumpZone(&pState->ZoneOrg,
             nIndents + 1);
    Printf("%spSpareTHS          @ %p\n",
           Indent(nIndents),
           pState->pSpareTHS);
    Printf("%sdwLcid               0x%x\n",
           Indent(nIndents),
           pState->dwLcid);
    Printf("%sCipherStrength       %d bits\n",
           Indent(nIndents),
           pState->CipherStrength);
    Printf("%spSamLoopbak        @ %p\n",
           Indent(nIndents),
           pState->pSamLoopback);
    Printf("%sSessionKeyLength     0x%x\n",
           Indent(nIndents),
           pState->SessionKey.SessionKeyLength);
    Printf("%sSessionKey         @ %p\n",
           Indent(nIndents),
           pState->SessionKey.SessionKey);

    Printf("%spAuthzCC           @ %p\n",
           Indent(nIndents),
           pState->pAuthzCC);
    if (pState->pAuthzCC != NULL) {
        if ( NULL == (pAuthzCC = ReadMemory(pState->pAuthzCC, sizeof(AUTHZ_CLIENT_CONTEXT))) ) {
            Printf("%sError reading pAuthzCC data\n", Indent(nIndents));
            return(FALSE);
        }
        Printf("%sAuthzContextHandle   %p\n",
               Indent(nIndents+1),
               pAuthzCC->hAuthzContext);
        Printf("%srefCount             %d\n",
               Indent(nIndents+1),
               pAuthzCC->lRefCount);
    }
    Printf("%shAuthzAuditInfo          %p\n",
           Indent(nIndents),
           pState->hAuthzAuditInfo);

    Printf("%sSearchEntriesReturned      %d\n",
           Indent(nIndents),
           pState->searchLogging.SearchEntriesReturned);

    Printf("%sSearchEntriesVisited       %d\n",
           Indent(nIndents),
           pState->searchLogging.SearchEntriesVisited);

    Printf("%sFilter Used               @ %p\n",
       Indent(nIndents),
       pState->searchLogging.pszFilter);

    Printf("%sIndexes Used             @ %p\n",
           Indent(nIndents),
           pState->searchLogging.pszIndexes);

    if ( NULL != pState->pSamLoopback)
    {
        Dump_SAMP_LOOPBACK_ARG(nIndents, pState->pSamLoopback);
    }

    Printf("%spSamSearchInformation @ %p\n",
           Indent(nIndents),
           pState->pSamSearchInformation);
    Printf("%sNTDSErrorFlag        0x%1.1x\n",
           Indent(nIndents),
           1 & pState->NTDSErrorFlag);
    Printf("%sphSecurityContext  @ %p\n",
           Indent(nIndents),
           pState->phSecurityContext);
    Printf("%simpState             0x%x\n",
       Indent(nIndents),
       pState->impState);
    Printf("%spCtxtHandle        @ %p\n",
           Indent(nIndents),
           pState->pCtxtHandle);
    Printf("%simpState             %s\n",
           Indent(nIndents),
           ((ImpersonateNone == pState->impState)
            ? "ImpersonateNone"
            : ((ImpersonateRpcClient == pState->impState)
                ? "ImpersonateRpcClient"
                : ((ImpersonateNullSession == pState->impState)
                    ? "ImpersonateNullSession"
                    : ((ImpersonateSspClient == pState->impState)
                        ? "ImpersonateSspClient"
                        : ((ImpersonateDelegatedClient == pState->impState)
                            ? "ImpersonateDelegatedClient"
                            : "*** bad impState ***"))))) );
    Printf("%sulTickCreated        0x%x\n",
           Indent(nIndents),
           pState->ulTickCreated);

    {
        FILETIME localft;
        SYSTEMTIME st;

        FileTimeToLocalFileTime(&pState->TimeCreated,
                                &localft);

        FileTimeToSystemTime(&localft,&st);

        Printf("%sTimeCreated          (Hi 0x%08x Lo 0x%08x) %04d-%02d-%02d %02d:%02d.%02d\n",
               Indent(nIndents),
               pState->TimeCreated.dwHighDateTime,
               pState->TimeCreated.dwLowDateTime,
               st.wYear % 10000,
               st.wMonth,
               st.wDay,
               st.wHour,
               st.wMinute,
               st.wSecond);
    }

    Printf("%sCurrSchemaPtr      @ %p\n",
           Indent(nIndents),
           pState->CurrSchemaPtr);
    Printf("%sNewPrefix          @ %p\n",
           Indent(nIndents),
           pState->NewPrefix);
    Printf("%scNewPrefix           0x%x\n",
       Indent(nIndents),
       pState->cNewPrefix);
    Printf("%sGCVerifyCache      @ %p\n",
           Indent(nIndents),
           pState->GCVerifyCache);
    Printf("%spextRemote         @ %p\n",
           Indent(nIndents),
           pState->pextRemote);
    Printf("%sopendbcount          0x%x\n",
           Indent(nIndents),
           pState->opendbcount);
    Printf("%spNotifyNCs         @ %p\n",
           Indent(nIndents),
           pState->pNotifyNCs);
    // This switch should match the CALLERTYPE enum in ntdsa.h
    switch (pState->CallerType) {
      case CALLERTYPE_NONE:  pStrTmp = "NONE"; break;
      case CALLERTYPE_SAM:   pStrTmp = "SAM";  break;
      case CALLERTYPE_DRA:   pStrTmp = "DRA";  break;
      case CALLERTYPE_LDAP:  pStrTmp = "LDAP"; break;
      case CALLERTYPE_LSA:   pStrTmp = "LSA";  break;
      case CALLERTYPE_KCC:   pStrTmp = "KCC";  break;
      case CALLERTYPE_NSPI:  pStrTmp = "NSPI"; break;
      case CALLERTYPE_INTERNAL:  pStrTmp = "Internal"; break;
      case CALLERTYPE_NTDSAPI:  pStrTmp = "NTDSAPI"; break;
      default:  pStrTmp = "unknown"; break;
    }
    Printf("%sCallerType           %d (%s)\n",
           Indent(nIndents),
           pState->CallerType,
           pStrTmp);
    Printf("%sClient IP address    0x%x\n",
           Indent(nIndents),
           pState->ClientIP);
    Printf("%sdsidOrigin           0x%x\n",
           Indent(nIndents),
           pState->dsidOrigin);

    Printf("%sInvocationID         %s\n",
           Indent(nIndents),
           DsUuidToStructuredString(&pState->InvocationID, szUuid));

#if DBG
    Printf("%sSize                 %d\n",
           Indent(nIndents),
           pState->Size);
    Printf("%sSizeOrg              0x%x\n",
           Indent(nIndents),
           pState->SizeOrg);
    Printf("%sTotaldbpos           %d\n",
           Indent(nIndents),
           pState->Totaldbpos);
    Printf("%spDBList[]            @ %p\n",
           Indent(nIndents),
           pState->pDBList);
#endif

    FreeMemory(pState);
    return(TRUE);
}

BOOL
Dump_SAMP_LOOPBACK_ARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SAMP_LOOPBACK_ARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SAMP_LOOPBACK_ARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    SAMP_LOOPBACK_ARG   *pArg = NULL;
    SAMP_CALL_MAPPING   *rMap = NULL;
    ULONG               i;

    Printf("%sSAM_LOOPBACK_ARG @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pArg = ReadMemory(pvProcess, sizeof(SAMP_LOOPBACK_ARG))) )
    {
        Printf("Error reading memory at %p\n", pvProcess);
        return(FALSE);
    }

    Printf("%stype:             ", Indent(nIndents));

    switch ( pArg->type )
    {
    case LoopbackAdd:

        Printf("LoopbackAdd\n");
        break;

    case LoopbackModify:

        Printf("LoopbackModify\n");
        break;

    case LoopbackRemove:

        Printf("LoopbackRemove\n");
        break;

    default:

        Printf("Unknown - 0x%x\n", pArg->type);
        break;
    }

    if ( NULL != pArg->pObject )
    {
        Dump_DSNAME(nIndents, pArg->pObject);
    }

    Printf("%scCallMap:         0x%d\n", Indent(nIndents), pArg->cCallMap);
    Printf("%srCallMap:       @ %p\n", Indent(nIndents), pArg->cCallMap);

    if ( NULL != pArg->rCallMap )
    {
        if ( NULL == (rMap = ReadMemory(
                                pArg->rCallMap,
                                pArg->cCallMap * sizeof(SAMP_CALL_MAPPING))) )
        {
            Printf("Error reading memory at %p\n", pArg->rCallMap);
        }
        else
        {
            for ( i = 0; i < pArg->cCallMap; i++ )
            {
                Printf("%sfSamWriteRequired:    %x\n",
                       Indent(nIndents+1),
                       rMap[i].fSamWriteRequired);
                Printf("%sfIgnore:  %x\n",
                       Indent(nIndents+1),
                       rMap[i].fIgnore);
                Printf("%siAttr:    %x\n",
                       Indent(nIndents+1),
                       rMap[i].iAttr);
                Printf("%schoice:               %s\n",
                       Indent(nIndents+1),
                       rMap[i].choice == 'A'
                         ? "AT_CHOICE_ADD_ATT"
                         : rMap[i].choice == 'R'
                           ? "AT_CHOICE_REMOVE_ATT"
                           : rMap[i].choice == 'a'
                             ? "AT_CHOICE_ADD_VALUES"
                             : rMap[i].choice == 'r'
                               ? "AT_CHOICE_REMOVE_VALUES"
                               : rMap[i].choice == 'C'
                                 ? "AT_CHOICE_REPLACE_ATT"
                                 : "Unknown choice");
                Printf("%sAttr type:            0x%x\n",
                       Indent(nIndents),
                       rMap[i].attr.attrTyp);
                Printf("%sAttr value len:       0x%x\n",
                       Indent(nIndents),
                       rMap[i].attr.AttrVal.valCount);
                Printf("%sAttr value at:       %p\n",
                       Indent(nIndents),
                       rMap[i].attr.AttrVal.pAVal);
                Printf("%sAttCache:    %x\n",
                       Indent(nIndents),
                       rMap[i].pAC);
            }

            FreeMemory(rMap);
        }
    }

    FreeMemory(pArg);
    return(TRUE);
}

BOOL
Dump_DSA_ANCHOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DSA_ANCHOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DSA_ANCHOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    DSA_ANCHOR          *pAnchor = NULL;
    CROSS_REF_LIST      *pCRList, *pCRListTmp;
    SUBREF_LIST         *pSRList, *pSRListTmp;
    DWORD               nTmp;
    DWORD               *pDNTs;
    ULONG               i;
    ULONG               cDomainSubrefList;
    ULONG *             pcbSidSize = NULL;
    PSID                pSidTmp = NULL;
    COUNTED_LIST *      pNoGCSearchList = NULL;
    DWORD *             paNonGCNcsDNTs = NULL;
    DWORD               dwPrevDNT = 0;

    Printf("%sDSA_ANCHOR @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pAnchor = ReadMemory(pvProcess, sizeof(DSA_ANCHOR))) )
    {
        return(FALSE);
    }

    Printf("%sCSUpdate           @ %p\n",
           Indent(nIndents),
           pvProcess);

    Dump_NAMING_CONTEXT_LIST(nIndents, "pMasterNC", pAnchor->pMasterNC);
    Dump_NAMING_CONTEXT_LIST(nIndents, "pReplicaNC", pAnchor->pReplicaNC);

    Printf("%spCRL               @ %p\n",
           Indent(nIndents),
           pAnchor->pCRL);

    pCRList = pAnchor->pCRL;
    nTmp = nIndents + 1;
    while ( NULL != pCRList )
    {
        pCRListTmp = ReadMemory(pCRList, sizeof(CROSS_REF_LIST));

        if ( NULL == pCRListTmp )
            return(FALSE);

        Printf("%sCross ref NC name\n", Indent(nTmp));
        Dump_DSNAME(nTmp, pCRListTmp->CR.pNC);
        Printf("%sObject holding info for this cross ref\n", Indent(nTmp));
        Dump_DSNAME(nTmp, pCRListTmp->CR.pObj);

        if ( pCRListTmp->CR.NetbiosName ) {
            WCHAR* pnbname = ReadMemory(pCRListTmp->CR.NetbiosName,
                                        (DNLEN+1)*sizeof(WCHAR) );
            if ( pnbname ) {
                Printf("%sNetbios name of domain: %ls\n",
                       Indent(nTmp), pnbname);
                FreeMemory( pnbname );

            } else {
                Printf("%sNetbios name of domain is unreadable\n",
                       Indent(nTmp) );
            }
        }

        if ( pCRListTmp->CR.DnsName ) {
            WCHAR* dnsname = ReadMemory(pCRListTmp->CR.DnsName,
                                        (255+1)*sizeof(WCHAR) );
            if ( dnsname ) {
                Printf("%sDns name of NC: %ls\n", Indent(nTmp), dnsname);
                FreeMemory( dnsname );
            } else {
                Printf("%sDns name of NC is unreadable\n", Indent(nTmp) );
            }
        }
        if (pCRListTmp->CR.DnsReferral.valCount) {
            DWORD nVal;
            ATTRVAL *pAVal = ReadMemory(pCRListTmp->CR.DnsReferral.pAVal,
                                        pCRListTmp->CR.DnsReferral.valCount
                                        * sizeof (ATTRVAL));
            if (pAVal) {
                for (nVal = 0; 
                     nVal < pCRListTmp->CR.DnsReferral.valCount;
                     ++nVal) {
                    UCHAR *pVal = ReadMemory(pAVal[nVal].pVal,
                                             pAVal[nVal].valLen + sizeof(WCHAR));
                    if (pVal) {
                        pVal[pAVal[nVal].valLen / sizeof(WCHAR)] = L'\0';
                        Printf("%sDns referral: %ls\n", Indent(nTmp), pVal);
                        FreeMemory(pVal);
                    } else {
                        Printf("%sDns referral @ %p is unreadable\n", Indent(nTmp), pAVal[nVal].pVal);
                    }
                }
                FreeMemory(pAVal);
            } else {
                Printf("%sDns referrals @ %p are unreadable\n", Indent(nTmp),
                       pCRListTmp->CR.DnsReferral.pAVal );
            }

        }
        if ( pCRListTmp->CR.DnsAliasName ) {
            WCHAR* dnsname = ReadMemory(pCRListTmp->CR.DnsAliasName,
                                        (255+1)*sizeof(WCHAR) );
            if ( dnsname ) {
                Printf("%sDns Alias name of NC: %ls\n", Indent(nTmp), dnsname);
                FreeMemory( dnsname );
            } else {
                Printf("%sDns Alias name of NC is unreadable\n", Indent(nTmp) );
            }
        }

        Printf("%sCrossRef Flags are 0x%x\n",
               Indent(nTmp), pCRListTmp->CR.flags);

        Printf("%sFirst DSA Replication Delay is %d seconds\n", Indent(nTmp),
            pCRListTmp->CR.dwFirstNotifyDelay);

        Printf("%sFirst DSA Replication Delay is %d seconds\n", Indent(nTmp),
            pCRListTmp->CR.dwSubsequentNotifyDelay);

        Printf("%sbEnabled is %d\n", Indent(nTmp), pCRListTmp->CR.bEnabled);

        if(pCRListTmp->CR.pdnSDRefDom){

            Printf("%sThe Security Descriptor Reference Domain:\n", Indent(nTmp));
            Dump_DSNAME(nIndents+1, pCRListTmp->CR.pdnSDRefDom);

            if(pCRListTmp->CR.pSDRefDomSid){
                WCHAR SidText[128];
                UNICODE_STRING us;

                SidText[0] = L'\0';
                us.MaximumLength = sizeof(SidText);
                us.Length = 0;
                us.Buffer = SidText;

                Printf("%sSecurity Descriptor Reference Domain SID Cache:", Indent(nTmp));

                // First 4 bytes of the Sid is the SID Length.
                pcbSidSize = (ULONG *) ReadMemory(pCRListTmp->CR.pSDRefDomSid, 4);
                if(pcbSidSize == NULL){
                    Printf(" unreadeable\n");
                } else {
                    pSidTmp = ReadMemory(pCRListTmp->CR.pSDRefDomSid, *pcbSidSize);
                    if(pSidTmp == NULL){
                        Printf(" unreadeable, but size is supposed to be %d\n", *((ULONG *) pSidTmp));
                    } else {
                        RtlConvertSidToUnicodeString(&us, pSidTmp, FALSE);
                        Printf("%S\n", SidText);
                        FreeMemory(pSidTmp);
                    }
                    FreeMemory(pcbSidSize);
                }
            } else {
                Printf("%sNo SID is cached\n", Indent(nTmp+1));
            }
        }


        Printf("%sNextCR is @ %p\n\n", Indent(nTmp), pCRListTmp->pNextCR);
        pCRList = pCRListTmp->pNextCR;
        FreeMemory(pCRListTmp);


    }

    Printf("%spRootDomain        @ %p\n",
           Indent(nIndents),
           pAnchor->pRootDomainDN);

    if ( NULL != pAnchor->pRootDomainDN )
        Dump_DSNAME(nIndents+1, pAnchor->pRootDomainDN);

    Printf("%spDMD               @ %p\n",
           Indent(nIndents),
           pAnchor->pDMD);

    if ( NULL != pAnchor->pDMD )
        Dump_DSNAME(nIndents+1, pAnchor->pDMD);

    Printf("%spLDAPDMD           @ %p\n",
           Indent(nIndents),
           pAnchor->pLDAPDMD);

    if ( NULL != pAnchor->pLDAPDMD )
        Dump_DSNAME(nIndents+1, pAnchor->pLDAPDMD);

    Printf("%sulDntLdapDmd          0x%x\n",
           Indent(nIndents),
           pAnchor->ulDntLdapDmd);

    Printf("%spDSA               @ %p\n",
           Indent(nIndents),
           pAnchor->pDSA);

    Printf("%spDSADN             @ %p\n",
           Indent(nIndents),
           pAnchor->pDSADN);

    if ( NULL != pAnchor->pDSADN )
        Dump_DSNAME(nIndents+1, pAnchor->pDSADN);

    Printf("%spDomainDN          @ %p\n",
           Indent(nIndents),
           pAnchor->pDomainDN);

    if ( NULL != pAnchor->pDomainDN )
        Dump_DSNAME(nIndents+1, pAnchor->pDomainDN);

    Printf("%spConfigDN          @ %p\n",
           Indent(nIndents),
           pAnchor->pConfigDN);

    if ( NULL != pAnchor->pConfigDN )
        Dump_DSNAME(nIndents+1, pAnchor->pConfigDN);

    Printf("%spPartitionsDN      @ %p\n",
           Indent(nIndents),
           pAnchor->pPartitionsDN);

    if ( NULL != pAnchor->pPartitionsDN )
        Dump_DSNAME(nIndents+1, pAnchor->pPartitionsDN);

    Printf("%spDsSvcConfigDN     @ %p\n",
           Indent(nIndents),
           pAnchor->pDsSvcConfigDN);

    if ( NULL != pAnchor->pDsSvcConfigDN )
        Dump_DSNAME(nIndents+1, pAnchor->pDsSvcConfigDN);

    Printf("%spExchangeDN        @ %p\n",
           Indent(nIndents),
           pAnchor->pExchangeDN);

    if ( NULL != pAnchor->pExchangeDN )
        Dump_DSNAME(nIndents+1, pAnchor->pExchangeDN);

    Printf("%spmtxDSA            @ %p\n",
           Indent(nIndents),
           pAnchor->pmtxDSA);

    Printf("%spwszRootDomainDnsName @ %p\n",
           Indent(nIndents),
           pAnchor->pwszRootDomainDnsName);

    Printf("%spwszHostDnsName @ %p\n",
           Indent(nIndents),
           pAnchor->pwszHostDnsName);

    Printf("%sfAmGC                0x%x\n",
           Indent(nIndents),
           pAnchor->fAmGC );

    Printf("%sfAmVirtualGC         0x%x\n",
           Indent(nIndents),
           pAnchor->fAmVirtualGC );

    Printf("%suDomainsInForest     0x%x\n",
           Indent(nIndents),
           pAnchor->uDomainsInForest );

    Printf("%sfDisableInboundRepl  0x%x\n",
           Indent(nIndents),
           pAnchor->fDisableInboundRepl );

    Printf("%sfDisableOutboundRepl 0x%x\n",
           Indent(nIndents),
           pAnchor->fDisableOutboundRepl );

    if (pAnchor->AncestorsNum) {
        Printf("%s%u Ancestors:",
               Indent(nIndents),
               pAnchor->AncestorsNum);
        pDNTs = ReadMemory(pAnchor->pAncestors,
                           pAnchor->AncestorsNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->AncestorsNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Ancestors\n",
               Indent(nIndents));
    }

    if (pAnchor->UnDelAncNum) {
        Printf("%s%u Protected Ancestor DNTs:",
               Indent(nIndents),
               pAnchor->UnDelAncNum);
        pDNTs = ReadMemory(pAnchor->pUnDelAncDNTs,
                           pAnchor->UnDelAncNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->UnDelAncNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Protected Ancestor DNTs\n",
               Indent(nIndents));
    }

    if (pAnchor->UnDeletableNum) {
        Printf("%s%u Protected DNTs:",
               Indent(nIndents),
               pAnchor->UnDeletableNum);
        pDNTs = ReadMemory(pAnchor->pUnDeletableDNTs,
                           pAnchor->UnDeletableNum * sizeof(DWORD));
        if (pDNTs) {
            for (i=0; i<pAnchor->UnDeletableNum; i++) {
                Printf(" 0x%x", pDNTs[i]);
            }
            FreeMemory(pDNTs);
        }
        Printf("\n");
    }
    else {
        Printf("%sNo Protected DNTs\n",
               Indent(nIndents));
    }

    Printf("%sGlobal DNread cache @ %p\n",
           Indent(nIndents),
           pAnchor->MainGlobal_DNReadCache);

    Printf("%spDomainSD:         @ %p\n",
           Indent(nIndents),
           pAnchor->pDomainSD);

    //
    // Dump cache of ATT_SUB_REFS
    //
    Printf("%spDomainSubrefList %p\n",
           Indent(nIndents),
           pAnchor->pDomainSubrefList);
    Printf("%sfDomainSubrefList %s\n",
           Indent(nIndents + 1),
           pAnchor->fDomainSubrefList ? "True": "False");
    Printf("%scDomainSubrefList %u\n",
           Indent(nIndents + 1),
           pAnchor->cDomainSubrefList);
    cDomainSubrefList = 0;
    pSRList = pAnchor->pDomainSubrefList;
    while ( NULL != pSRList )
    {
        ++cDomainSubrefList;
        pSRListTmp = ReadMemory(pSRList, sizeof(SUBREF_LIST));
        if (NULL == pSRListTmp)
        {
            Printf("%sCannot read memory @ %p; giving up\n",
                   Indent(nIndents + 1),
                   pSRList);
            break;
        }
        Dump_DSNAME(nIndents + 1, pSRListTmp->pDSName);
        if (pSRListTmp->cAncestors) {
            Printf("%s%u Ancestors (obj -> root):",
                   Indent(nIndents + 1),
                   pSRListTmp->cAncestors);
            pDNTs = ReadMemory(pSRListTmp->pAncestors,
                               pSRListTmp->cAncestors * sizeof(DWORD));
            if (pDNTs) {
                for (i=0; i<pSRListTmp->cAncestors; i++) {
                    Printf(" 0x%x", pDNTs[i]);
                }
                FreeMemory(pDNTs);
            }
            Printf("\n");
        }
        else {
            Printf("%sNo Ancestors\n",
                   Indent(nIndents + 1));
        }

        /* print a spacer between SRs */
        Printf("\n");

        pSRList = pSRListTmp->pNextSubref;
        FreeMemory(pSRListTmp);
    }
    if (cDomainSubrefList == pAnchor->cDomainSubrefList) {
        Printf("%scDomainSubrefList is okay (%u == %u)\n",
               Indent(nIndents + 1),
               cDomainSubrefList,
               pAnchor->cDomainSubrefList);
    } else {
        Printf("%sPOSSIBLE BUG: cDomainSubrefList is off (%u != %u)\n",
               Indent(nIndents + 1),
               cDomainSubrefList,
               pAnchor->cDomainSubrefList);
    }

    Printf("%sfAmRootDomainDC      0x%x\n",
           Indent(nIndents),
           pAnchor->fAmRootDomainDC );


    Printf("%spInfraStructureDN        @ %p\n",
           Indent(nIndents),
           pAnchor->pInfraStructureDN);

    if ( NULL != pAnchor->pInfraStructureDN )
        Dump_DSNAME(nIndents+1, pAnchor->pInfraStructureDN);


    Printf("%sMaxPasswordAge        0x%x 0x%x\n",
           Indent(nIndents),
           pAnchor->MaxPasswordAge.LowPart, pAnchor->MaxPasswordAge.HighPart);


    Printf("%sLockoutDuration        0x%x 0x%x\n",
           Indent(nIndents),
           pAnchor->LockoutDuration.LowPart, pAnchor->LockoutDuration.HighPart);

    Printf("%sForestBehaviorVersion %d\n",
           Indent(nIndents),
           pAnchor->ForestBehaviorVersion);

    Printf("%sDomainBehaviorVersion %d\n",
           Indent(nIndents),
           pAnchor->DomainBehaviorVersion);

    Printf("%spCurrInvocationID     %p\n",
           Indent(nIndents),
           pAnchor->pCurrInvocationID);

    Printf("%sfSchemaUpgradeInProgress %d\n",
           Indent(nIndents),
           pAnchor->fSchemaUpgradeInProgress);

    if(pAnchor->pNoGCSearchList){
        Printf("%spNoGCSearchList = %p\n", Indent(nIndents), pAnchor->pNoGCSearchList);
        if ( NULL == (pNoGCSearchList = ReadMemory(pAnchor->pNoGCSearchList,
                                                   sizeof(COUNTED_LIST))) ){
            Printf("%sCannot read memory @ %p; giving up\n.",
                   pAnchor->pNoGCSearchList);
            return(FALSE);
        }
        if(pNoGCSearchList->pList){
            Printf("%s->cNCs = %ul\n", Indent(nIndents+2), pNoGCSearchList->cNCs);
            Printf("%s->p = %p\n", Indent(nIndents+2), pNoGCSearchList->pList);
            if( NULL == (paNonGCNcsDNTs = ReadMemory(pNoGCSearchList->pList,
                                        (pNoGCSearchList->cNCs * sizeof(DWORD))))){
                Printf("%sCannot read memory @ %p; giving up.\n",
                       pNoGCSearchList->pList);
                FreeMemory(pNoGCSearchList);
                return(FALSE);
            }

            // This is the normal case.
            // Walk and print out the list of
            Printf("%s ", Indent(nIndents+4));
            for(i = 0; i < pNoGCSearchList->cNCs; i++){
                if(dwPrevDNT < paNonGCNcsDNTs[i]){
                    Printf("0x%X ", paNonGCNcsDNTs[i]);
                    dwPrevDNT = paNonGCNcsDNTs[i];
                } else {
                    Printf("%s\n\nCONSISTENCY ERROR dsexts\\md.c Line: %ul !?!, Contact the AD/DS group.\n\n",
                                       Indent(nIndents), __LINE__);
                    break;
                }
            }
            Printf("\n");

            FreeMemory(paNonGCNcsDNTs);
        } else {
            Printf("%s\n\nCONSISTENCY ERROR dsexts\\md.c Line: %ul !?!, Contact the AD/DS group.\n\n",
                   Indent(nIndents), __LINE__);
        }
        FreeMemory(pNoGCSearchList);
    } else {
        // This is the other normal case.
        Printf("%spNoGCSearchList = (NULL)\n", Indent(nIndents));
    }

    FreeMemory(pAnchor);
    return(TRUE);
}

BOOL
Dump_KEY(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public KEY dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of KEY in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    KEY   *pKey = NULL;
    VLV_SEARCH  *pVLVsearch = NULL;
    VLV_REQUEST *pVLVrequest = NULL;

    Printf("%sKEY @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pKey = ReadMemory(pvProcess, sizeof(KEY)))) {
        return(FALSE);
    }

    Printf("%sSearch in progress:      %s\n",
           Indent(nIndents),
           (pKey->fSearchInProgress ? "TRUE": "FALSE"));


    Printf("%spIndex:                @ %p\n",
           Indent(nIndents),
           pKey->pIndex);


    Printf("%sSearch Root DNT:         %x\n",
           Indent(nIndents),
           pKey->ulSearchRootDnt);

    Printf("%sSearch Root PDNT:        %x\n",
           Indent(nIndents),
           pKey->ulSearchRootPDNT);

    Printf("%sSearch Root NCDNT:       %x\n",
           Indent(nIndents),
           pKey->ulSearchRootNcdnt);

    Printf("%sSearch Type:             ",Indent(nIndents));
    switch(pKey->ulSearchType) {
    case SE_CHOICE_BASE_ONLY:
        Printf("Base object\n");
        break;

    case SE_CHOICE_IMMED_CHLDRN:
        Printf("One level\n");
        break;

    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("Whole subtree\n");
        break;

    default:
        Printf("Invalid choice\n");
        break;
    }

    Dump_FILTER(nIndents+1,pKey->pFilter);

    Printf("%spFilterSecurity:       @ %p\n",
           Indent(nIndents),
           pKey->pFilterSecurity);

    Printf("%spFilterResults:        @ %p\n",
           Indent(nIndents),
           pKey->pFilterResults);

    Printf("%spFilterSecuritySize:     %d\n",
           Indent(nIndents),
           pKey->FilterSecuritySize);


    Printf("%sIndex Type:             ",Indent(nIndents));
    switch(pKey->indexType) {
    case INVALID_INDEX_TYPE:
        Printf("Invalid index type\n");
        break;

    case UNSET_INDEX_TYPE:
        Printf("Unset index type\n");
        break;

    case GENERIC_INDEX_TYPE:
        Printf("Generic index type\n");
        break;

    case TEMP_TABLE_INDEX_TYPE:
        Printf("Temp table index type\n");
        break;

    case ANCESTORS_INDEX_TYPE:
        Printf("Ancestors index type\n");
        break;

    case INTERSECT_INDEX_TYPE:
        Printf("Intersect index type\n");
        break;

    case TEMP_TABLE_MEMORY_ARRAY_TYPE:
        Printf("InMemory array type\n");
        break;

    default:
        Printf("Invalid choice (%d)\n", pKey->indexType);
        break;
    }

    Printf("%sSort Type:               ",Indent(nIndents));
    switch(pKey->ulSorted) {
    case SORT_NEVER:
        Printf("NEVER\n");
        break;
    case SORT_OPTIONAL:
        Printf("OPTIONAL\n");
        break;
    case SORT_MANDATORY:
        Printf("MANDATORY\n");
        break;
    default:
        Printf("Invalid choice %d\n", pKey->ulSorted);
        break;
    }

    if ((pKey->indexType == TEMP_TABLE_INDEX_TYPE) ||
        (pKey->indexType == TEMP_TABLE_MEMORY_ARRAY_TYPE) ) {
        Printf("%sEntriesInTempTable:      %d\n",
                   Indent(nIndents),
                   pKey->ulEntriesInTempTable);
    }

    if (pKey->pVLV) {
        if ( NULL == (pVLVsearch = ReadMemory(pKey->pVLV, sizeof(VLV_SEARCH)))) {
            Printf("%sError Reading pVLV:@ %p\n",
                   Indent(nIndents),
                   pKey->pVLV);
        }
    }

    if (pVLVsearch) {
        Printf("%sVLV Present\n", Indent(nIndents));

        if ( NULL == (pVLVrequest = ReadMemory(pVLVsearch->pVLVRequest, sizeof(VLV_REQUEST)))) {
            Printf("%sError Reading pVLVRequest:@ %p\n",
                   Indent(nIndents),
                   pVLVsearch->pVLVRequest);
        }

        if (pVLVrequest) {
            Printf("%sOriginal VLV Request\n",
                   Indent(nIndents + 1));

            Printf("%sfseekToValue:            %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->fseekToValue);
            Printf("%sbeforeCount:             %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->beforeCount);
            Printf("%safterCount:              %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->afterCount);
            Printf("%stargetPosition:          %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->targetPosition);
            Printf("%scontentCount:            %d\n",
                   Indent(nIndents + 2),
                   pVLVrequest->contentCount);
            Printf("%sseekValue:             @ %p\n",
                   Indent(nIndents),
                   pVLVrequest->seekValue.pVal);
            Printf("%spVLVRestart:           @ %p\n",
                   Indent(nIndents),
                   pVLVrequest->pVLVRestart);
        }


        Printf("%spositionOp:              %d\n",
               Indent(nIndents + 1),
               pVLVsearch->positionOp);
        Printf("%sclnCurrPos:              %d\n",
               Indent(nIndents + 1),
               pVLVsearch->clnCurrPos);
        Printf("%sclnContentCount:         %d\n",
               Indent(nIndents + 1),
               pVLVsearch->clnContentCount);
        Printf("%scurrPosition:            %d\n",
               Indent(nIndents + 1),
               pVLVsearch->currPosition);
        Printf("%scontentCount:            %d\n",
               Indent(nIndents + 1),
               pVLVsearch->contentCount);
        Printf("%srequestedEntries:        %d\n",
               Indent(nIndents + 1),
               pVLVsearch->requestedEntries);
        Printf("%sAttrType:                %d\n",
               Indent(nIndents + 1),
               pVLVsearch->SortAttr);
        if (pVLVsearch->bUsingMAPIContainer) {
            Printf("%sMAPIContainerDNT:        %d\n",
                   Indent(nIndents + 1),
                   pVLVsearch->MAPIContainerDNT);
        }
        Printf("%sErr:                     %d\n",
               Indent(nIndents + 1),
               pVLVsearch->Err);
    }

    if (pKey->asqRequest.fPresent) {
        Printf("%sASQ Present\n", Indent(nIndents));
        Printf("%sASQ Attr from GC:        %d\n",
                   Indent(nIndents+1),
                   pKey->asqRequest.fMissingAttributesOnGC);
        Printf("%sASQ AttrType:            %d\n",
                   Indent(nIndents + 1),
                   pKey->asqRequest.attrType);

        Printf("%sASQ Err:                 %d\n",
                   Indent(nIndents + 1),
                   pKey->asqRequest.Err);

        Printf("%sASQ Mode:                 ", Indent(nIndents+1));

        if (pKey->asqMode) {

            if (pKey->asqMode & ASQ_SORTED) {
                Printf("SORTED ");
            }
            if (pKey->asqMode & ASQ_PAGED) {
                Printf("PAGED ");
            }
            if (pKey->asqMode & ASQ_VLV) {
                Printf("VLV ");
            }
            Printf("\n");
        }
        else {
            Printf("SIMPLE\n");
        }
        Printf("%sulASQLastUpperBound:     %d\n",
                   Indent(nIndents + 1),
                   pKey->ulASQLastUpperBound);

        Printf("%sulASQSizeLimit:          %d\n",
                   Indent(nIndents + 1),
                   pKey->ulASQSizeLimit);
    }

    if (pKey->cdwCountDNTs) {
        Printf("%scdwCountDNTs:            %d\n",
                   Indent(nIndents),
                   pKey->cdwCountDNTs);
        Printf("%spDNTs:                 @ %p\n",
                   Indent(nIndents),
                   pKey->pDNTs);
        Printf("%scurrRecPos:              %d\n",
                   Indent(nIndents),
                   pKey->currRecPos);
    }

    FreeMemory(pKey);
    return(TRUE);
}

BOOL
Dump_KEY_INDEX(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public KEY dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of KEY in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    KEY_INDEX   *pIndex = NULL;

    Printf("%sKEY_INDEX @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pIndex = ReadMemory(pvProcess, sizeof(KEY_INDEX)))) {
        return(FALSE);
    }

    if(pIndex->szIndexName) {
        char * pszIndex;
        DWORD cb;
        cb = min(64, (DWORD)(4095 - (((DWORD_PTR)pIndex->szIndexName) & 4095)));
        pszIndex = ReadMemory(pIndex->szIndexName, cb);
        if (NULL == pszIndex) {
            FreeMemory(pIndex);
            return FALSE;
        }
        // Null terminate, just in case
        pszIndex[cb-1]= 0;
        Printf("%sIndex Name:              %s\n",
               Indent(nIndents),
               pszIndex);
        FreeMemory(pszIndex);
    }
    else {
        Printf("%sIndex Name:              No Index\n");
    }

    Printf("%sIndex is PDNT based:     %s\n",
           Indent(nIndents),
           (pIndex->bIsPDNTBased ? "TRUE" : "FALSE"));

    Printf("%sEstimated Recs In Range: %d\n",
           Indent(nIndents),
           pIndex->ulEstimatedRecsInRange);

    Printf("%scbKeyLower:              %d\n",
           Indent(nIndents),
           pIndex->cbDBKeyLower);

    Printf("%srgbKeyLower:           @ %p\n",
           Indent(nIndents),
           pIndex->rgbDBKeyLower);

    Printf("%scbKeyUpper:              %d\n",
           Indent(nIndents),
           pIndex->cbDBKeyUpper);

    Printf("%srgbKeyUpper:           @ %p\n",
           Indent(nIndents),
           pIndex->rgbDBKeyUpper);


    Printf("%spNext:                 @ %p\n",
           Indent(nIndents),
           pIndex->pNext);

    FreeMemory(pIndex);
    return(TRUE);
}

BOOL
Dump_DBPOS(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DBPOS dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DBPOS in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    DBPOS   *pDBPOS = NULL;
    DWORD   cBytes;


    Printf("%sDBPOS @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    //
    // DBPOS has some DBG-only fields at the end.  Always read the
    // non-DBG amount of memory since the process being debugged may
    // not be a DBG version although the extensions DLL is.
    //

    cBytes = OFFSET(DBPOS, NewlyCreatedDNT) + sizeof(ULONG);

    if ( NULL == (pDBPOS = ReadMemory(pvProcess, cBytes)) )
    {
        return(FALSE);
    }

    Printf("%spTHS               @ %p\n",
           Indent(nIndents),
           pDBPOS->pTHS);
    Printf("%svalBufSize           0x%x\n",
           Indent(nIndents),
           pDBPOS->valBufSize);
    Printf("%spValBuf            @ %p\n",
           Indent(nIndents),
           pDBPOS->pValBuf);
    Printf("%sDNT                  0x%x\n",
           Indent(nIndents),
           pDBPOS->DNT);
    Printf("%sPDNT                 0x%x\n",
           Indent(nIndents),
           pDBPOS->PDNT);
    Printf("%sSDNT                 0x%x\n",
           Indent(nIndents),
           pDBPOS->SDNT);
    Printf("%sNCDNT                0x%x\n",
           Indent(nIndents),
           pDBPOS->NCDNT);
    Printf("%sJetDBID              0x%x\n",
           Indent(nIndents),
           pDBPOS->JetDBID);
    Printf("%sJetSessID            0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSessID);
    Printf("%sJetObjTbl            0x%x\n",
           Indent(nIndents),
           pDBPOS->JetObjTbl);
    Printf("%sJetSearchTbl         0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSearchTbl);
    Printf("%sJetLinkTbl           0x%x\n",
           Indent(nIndents),
           pDBPOS->JetLinkTbl);
    Printf("%sJetSDPropTbl         0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSDPropTbl);
    Printf("%sJetSDTbl             0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSDTbl);
    Printf("%sJetSortTbl           0x%x\n",
           Indent(nIndents),
           pDBPOS->JetSortTbl);
    Printf("%sSortColumns          [0x%x,0x%x]\n",
           Indent(nIndents),
           pDBPOS->SortColumns[0],
           pDBPOS->SortColumns[1]);
    Printf("%sJetRetrieveBits      0x%x\n",
           Indent(nIndents),
           pDBPOS->JetRetrieveBits);
    Printf("%sSDEvents             0x%x\n",
           Indent(nIndents),
           pDBPOS->SDEvents);
    Printf("%stransType            0x%x\n",
           Indent(nIndents),
           (pDBPOS->transType) & 3);
    Printf("%sroot                 0x%x\n",
           Indent(nIndents),
           (pDBPOS->root) & 1);
    Printf("%sfHidden              0x%x\n",
           Indent(nIndents),
           (pDBPOS->fHidden) & 1);
    Printf("%sJetNewRec            0x%x\n",
           Indent(nIndents),
           (pDBPOS->JetNewRec) & 1);
    Printf("%sfFlushCacheOnUpdate  0x%x\n",
           Indent(nIndents),
           (pDBPOS->fFlushCacheOnUpdate) & 1);
    Printf("%sfScopeLegacyLinks  0x%x\n",
           Indent(nIndents),
           (pDBPOS->fScopeLegacyLinks) & 1);
    Printf("%spDNsAdded          @ %p\n",
           Indent(nIndents),
           pDBPOS->pDNsAdded);
    Printf("%sKEY                @ %p\n",
           Indent(nIndents),
           ((DWORD_PTR)pvProcess +
            OFFSET(DBPOS, Key)));
    Printf("%sfIsMetaDataCached    %s\n",
           Indent(nIndents),
           pDBPOS->fIsMetaDataCached ? "yes" : "no");
    Printf("%sfIsLinkMetaDataCached    %s\n",
           Indent(nIndents),
           pDBPOS->fIsLinkMetaDataCached ? "yes" : "no");
    Printf("%sfMetaDataWriteOptimizable    %s\n",
           Indent(nIndents),
           pDBPOS->fMetaDataWriteOptimizable ? "yes" : "no");
    Printf("%scbMetaDataVecAlloced 0x%x\n",
           Indent(nIndents),
           pDBPOS->cbMetaDataVecAlloced);
    Printf("%spMetaDataVec       @ %p\n",
           Indent(nIndents),
           pDBPOS->pMetaDataVec);
    Printf("%spLinkMetaData       @ %p\n",
           Indent(nIndents),
           pDBPOS->pLinkMetaData);
    Printf("%stransincount         0x%x\n",
           Indent(nIndents),
           pDBPOS->transincount);
    Printf("%sSearchEntriesVisited  %d\n",
           Indent(nIndents),
           pDBPOS->SearchEntriesVisited);
    Printf("%sSearchEntriesReturned %d\n",
           Indent(nIndents),
           pDBPOS->SearchEntriesReturned);
    Printf("%sNewlyCreatedDNT      0x%x\n",
           Indent(nIndents),
           pDBPOS->NewlyCreatedDNT);


    FreeMemory(pDBPOS);
    return(TRUE);
}

BOOL Dump_DirWaitArray(
    IN DWORD nIndents,
    IN PVOID pvProcess,
    IN DWORD numEntries
    )
{
    DirWaitHead  **ppDirWaitArray = NULL;
    DWORD   cBytes;
    DWORD   cnt;

    Printf("%sDirWaitArray @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof (DirWaitHead *) * 256;

    if ( NULL == (ppDirWaitArray = ReadMemory(pvProcess, cBytes))) {
        return(FALSE);
    }

    for (cnt = 0; cnt<numEntries; cnt++) {
        if (ppDirWaitArray[cnt]) {
            Printf("%s[%d] = @ %p\n",
                   Indent(nIndents),
                   cnt,
                   ppDirWaitArray[cnt]);

            if (!Dump_DirWaitHead (nIndents, ppDirWaitArray[cnt])) {
                break;
            }
        }
    }

    FreeMemory(ppDirWaitArray);
    return(TRUE);
}

BOOL Dump_DirWaitArray64(
    IN DWORD nIndents,
    IN PVOID pvProcess)
{
    return Dump_DirWaitArray (nIndents, pvProcess, 64);
}

BOOL Dump_DirWaitArray256(
    IN DWORD nIndents,
    IN PVOID pvProcess)
{
    return Dump_DirWaitArray (nIndents, pvProcess, 256);
}



BOOL Dump_DirWaitHead(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    DirWaitHead  *pDirWaitHead = NULL;
    DWORD   cBytes;
    DWORD   cnt;

    Printf("%sDirWaitHead @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof (DirWaitHead);

    if ( NULL == (pDirWaitHead = ReadMemory(pvProcess, cBytes))) {
        return(FALSE);
    }

    Printf("%sDNT = %d\n",
           Indent(nIndents),
           pDirWaitHead->DNT);

    if (pDirWaitHead->pList) {
        if (!Dump_DirWaitItem (nIndents, pDirWaitHead->pList)) {
            FreeMemory(pDirWaitHead);
            return FALSE;
        }
    }

    if (pDirWaitHead->pNext) {
        if (!Dump_DirWaitHead (nIndents-1, pDirWaitHead->pNext)) {
            FreeMemory(pDirWaitHead);
            return FALSE;
        }
    }

    FreeMemory(pDirWaitHead);
    return(TRUE);
}

BOOL Dump_DirWaitItem(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
{
    DirWaitItem  *pDirWaitItem = NULL;
    DWORD   cBytes;
    DWORD   cnt;

    Printf("%sDirWaitItem @ %p \n", Indent(nIndents), pvProcess);
    nIndents++;

    cBytes = sizeof (DirWaitItem);

    if ( NULL == (pDirWaitItem = ReadMemory(pvProcess, cBytes))) {
        return(FALSE);
    }

    Printf("%shServer = 0x%x\n",
           Indent(nIndents),
           pDirWaitItem->hServer);

    Printf("%shClient = 0x%x\n",
           Indent(nIndents),
           pDirWaitItem->hClient);

    Printf("%spfPrepareForImpersonate = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfPrepareForImpersonate);

    Printf("%spfTransmitData = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfTransmitData);

    Printf("%spfStopImpersonating = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pfStopImpersonating);

    Printf("%sDNT = %d\n",
           Indent(nIndents),
           pDirWaitItem->DNT);

    Printf("%sbOneNC = %d\n",
           Indent(nIndents),
           pDirWaitItem->bOneNC);

    Printf("%spSel = @%p\n",
           Indent(nIndents),
           pDirWaitItem->pSel);

    if (pDirWaitItem->pNextItem) {
        if (!Dump_DirWaitItem (nIndents-1, pDirWaitItem->pNextItem)) {
            FreeMemory(pDirWaitItem);
            return FALSE;
        }
    }

    FreeMemory(pDirWaitItem);
    return(TRUE);
}

char * rgszSortType[] = { "none", "optional", "mandatory", "bogus value!" };
void
Dump_CommArgLocal(
             IN DWORD nIndents,
             IN COMMARG* pState)

/*++

Routine Description:

    Private CommArg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pState - address of CommArg in this process

Return Value:

    None

--*/

{
    SVCCNTL Svc;

    Svc = pState->Svccntl;
    Printf("%sSvccntl:\n",
           Indent(nIndents));
    nIndents += 2;
    {
        Printf("%sSecDescFlags:  0x%x\n",
               Indent(nIndents),
               Svc.SecurityDescriptorFlags);
        Printf("%sChaining: %s\n",
               Indent(nIndents),
               Svc.preferChaining ? "preferred" : "not preferred");
        Printf("%sChaining: %s\n",
               Indent(nIndents),
               Svc.chainingProhibited ? "prohibited" : "not prohibited");
        Printf("%slocalScope: %s\n",
               Indent(nIndents),
               Svc.localScope ? "yes" : "no");
        Printf("%sUseCopy: %s\n",
               Indent(nIndents),
               Svc.dontUseCopy ? "forbidden" : "allowed");
        Printf("%sDeletionsAvailable: %s\n",
               Indent(nIndents),
               Svc.makeDeletionsAvail ? "yes" : "no");
        Printf("%sUnicodeSupport: %s\n",
               Indent(nIndents),
               Svc.fUnicodeSupport ? "yes" : "no");
        Printf("%sStringNames: %s\n",
               Indent(nIndents),
               Svc.fStringNames ? "yes" : "no");
        Printf("%sPermissiveModify: %s\n",
               Indent(nIndents),
               Svc.fPermissiveModify ? "yes" : "no");
        Printf("%sUrgentReplication: %s\n",
               Indent(nIndents),
               Svc.fUrgentReplication ? "yes" : "no");
        Printf("%sAuthoritativeModify: %s\n",
               Indent(nIndents),
               Svc.fAuthoritativeModify ? "yes" : "no");
        Printf("%sMaintainSelOrder: %s\n",
               Indent(nIndents),
               Svc.fMaintainSelOrder ? "yes" : "no");
        Printf("%sDontOptimizeSel: %s\n",
               Indent(nIndents),
               Svc.fDontOptimizeSel ? "yes" : "no");
    Printf("%spGCVerifyHint: %p\n",
           Indent(nIndents),
           Svc.pGCVerifyHint);
    }
    nIndents -= 2;

    Printf("%sPagedResult:\n", Indent(nIndents));
    nIndents += 1;
    {
        Printf("%spRestart:     @ %p\n",
               Indent(nIndents),
               pState->PagedResult.pRestart);
        Printf("%sfPresent:       %x\n",
               Indent(nIndents),
               pState->PagedResult.fPresent);
    }
    nIndents -= 1;

    nIndents += 2;

//    Printf("%sOpsate                  0x%x\n",
//         Indent(nIndents),
//         pState->Opsate);
    Printf("%saliasRDN                  0x%x\n",
           Indent(nIndents),
           pState->aliasRDN);
    Printf("%sulSizeLimit               0x%x\n",
           Indent(nIndents),
           pState->ulSizeLimit);
    Printf("%sfForwardSeek              0x%x\n",
           Indent(nIndents),
           (pState->fForwardSeek) & 1);
    Printf("%sSortType                  0x%x (%s)\n",
           Indent(nIndents),
           (pState->SortType) & 3,
           rgszSortType[(pState->SortType) & 3]);
    Printf("%sSortAttr                  0x%x\n",
           Indent(nIndents),
           pState->SortAttr);
    Printf("%sDelta                     0x%x\n",
           Indent(nIndents),
           pState->Delta);
    Printf("%sStartTick                 0x%x\n",
           Indent(nIndents),
           pState->StartTick);
    Printf("%sDeltaTick                 0x%x\n",
           Indent(nIndents),
           pState->DeltaTick);
    Printf("%sfLazyCommit               %s\n",
           Indent(nIndents),
           pState->fLazyCommit ? "True" : "False");
    Printf("%sfFindSidWithinNC          %s\n",
        Indent(nIndents),
        pState->fFindSidWithinNc? "True" : "False");

}
BOOL
Dump_CommArg(
             IN DWORD nIndents,
             IN PVOID pvProcess)

/*++

Routine Description:

    Public CommArg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CommArg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    COMMARG *pState = NULL;

    Printf("%sCommArg @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if ( NULL == (pState = ReadMemory(pvProcess, sizeof(COMMARG)))) {
        return(FALSE);
    }

    Dump_CommArgLocal(nIndents,
                      pState);

    FreeMemory(pState);

    return(TRUE);
}

BOOL
Dump_USN_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public USN_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of USN_VECTOR in the address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    USN_VECTOR      *pUsnVec = NULL;

    Printf("%sUSN_VECTOR\n", Indent(nIndents));
    nIndents += 2;

    pUsnVec = (USN_VECTOR *) ReadMemory(pvProcess,
                                              sizeof(USN_VECTOR));

    if ( NULL != pUsnVec )
    {
        Printf("%susnHighObjUpdate: %I64d\n",
               Indent(nIndents),
               pUsnVec->usnHighObjUpdate);

        Printf("%susnHighPropUpdate: %I64d\n",
               Indent(nIndents),
               pUsnVec->usnHighPropUpdate);

        FreeMemory(pUsnVec);

        fSuccess = TRUE;

    }

    return(fSuccess);
}


BOOL
Dump_PROPERTY_META_DATA_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PROPERTY_META_DATA_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PROPERTY_META_DATA_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    PROPERTY_META_DATA_VECTOR   *pMetaData = NULL;
    DWORD                       cNumProps = 0;
    DWORD                       iCursor;

    Printf("%sPROPERTY_META_DATA_VECTOR\n", Indent(nIndents));

    pMetaData = (PROPERTY_META_DATA_VECTOR *) ReadMemory(pvProcess,
                                              MetaDataVecV1SizeFromLen(0));

    if (NULL != pMetaData)
    {
        if (VERSION_V1 == pMetaData->dwVersion)
        {
            cNumProps = pMetaData->V1.cNumProps;
        }
        else
        {
            Printf("%sProperty meta data vector version is NOT %d\n!!!", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory(pMetaData);

        if (0 != cNumProps)
        {
            Printf("%s%d entries.\n", Indent(nIndents), cNumProps);
            pMetaData = (PROPERTY_META_DATA_VECTOR *) ReadMemory(pvProcess,
                                                      MetaDataVecV1SizeFromLen(cNumProps));

            if (NULL != pMetaData)
            {
                DWORD   iprop;
                DWORD   ib;

                Printf(
                    "\n%s%6s%6s%8s%37s%8s%18s\n",
                    Indent(nIndents+1),
                    "AttID",
                    "Ver",
                    "Loc.USN",
                    "Originating DSA",
                    "Org.USN",
                    "Org.Time/Date"
                    );

                Printf(
                    "%s%6s%6s%8s%37s%8s%18s\n",
                    Indent(nIndents+1),
                    "=====",
                    "===",
                    "=======",
                    "===============",
                    "=======",
                    "============="
                    );

                for ( iprop = 0; iprop < pMetaData->V1.cNumProps; iprop++ )
                {
                    CHAR        szLocalUSN[ 40 ];
                    CHAR        szOriginatingUUID[ 40 ];
                    CHAR        szTime[ SZDSTIME_LEN ];
                    struct tm * ptm;

                    if ( 0xffffffffffffffff == pMetaData->V1.rgMetaData[ iprop ].usnProperty )
                    {
                        // Interim in-memory state signifying that this property has
                        // been touched and its meta data will be updated before the
                        // vector is put in the db.
                        strcpy( szLocalUSN, "touched" );
                    }
                    else
                    {
                        RtlLargeIntegerToChar(
                            (LARGE_INTEGER *) &pMetaData->V1.rgMetaData[ iprop ].usnProperty,
                            10,
                            sizeof( szLocalUSN ),
                            szLocalUSN
                            );
                    }

                    DraUuidToStr(
                        &pMetaData->V1.rgMetaData[ iprop ].uuidDsaOriginating,
                        szOriginatingUUID );

                    Printf(
                        "%s%6x%6x%8s%37s%8I64d%18s\n",
                        Indent(nIndents+1),
                        pMetaData->V1.rgMetaData[ iprop ].attrType,
                        pMetaData->V1.rgMetaData[ iprop ].dwVersion,
                        szLocalUSN,
                        szOriginatingUUID,
                        pMetaData->V1.rgMetaData[ iprop ].usnOriginating,
                        DSTimeToDisplayString(pMetaData->V1.rgMetaData[iprop].timeChanged, szTime)
                        );
                }

                FreeMemory(pMetaData);
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}


BOOL
Dump_PROPERTY_META_DATA_EXT_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PROPERTY_META_DATA_EXT_VECTOR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PROPERTY_META_DATA_EXT_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                            fSuccess = FALSE;
    PROPERTY_META_DATA_EXT_VECTOR   *pMetaDataExt = NULL;
    DWORD                           cNumProps;
    DWORD                           iCursor;

    Printf("%sPROPERTY_META_DATA_EXT_VECTOR\n", Indent(nIndents));

    pMetaDataExt = (PROPERTY_META_DATA_EXT_VECTOR *) ReadMemory(pvProcess,
                                              MetaDataExtVecSizeFromLen(0));

    if (NULL != pMetaDataExt)
    {
        cNumProps = pMetaDataExt->cNumProps;
        FreeMemory(pMetaDataExt);

        Printf("%s%d entries.\n", Indent(nIndents), cNumProps);

        pMetaDataExt = (PROPERTY_META_DATA_EXT_VECTOR *) ReadMemory(pvProcess,
                                                  MetaDataExtVecSizeFromLen(cNumProps));

        if (NULL != pMetaDataExt)
        {
            DWORD   iprop;
            DWORD   ib;

            Printf(
                "\n%s%6s%37s%8s%18s\n",
                Indent(nIndents+1),
                "Ver",
                "Originating DSA",
                "Org.USN",
                "Org.Time/Date"
                );

            Printf(
                "%s%6s%37s%8s%18s\n",
                Indent(nIndents+1),
                "===",
                "===============",
                "=======",
                "============="
                );

            for ( iprop = 0; iprop < pMetaDataExt->cNumProps; iprop++ )
            {
                CHAR        szOriginatingUUID[ 40 ];
                CHAR        szTime[ SZDSTIME_LEN ];
                struct tm * ptm;

                DraUuidToStr(
                    &pMetaDataExt->rgMetaData[ iprop ].uuidDsaOriginating,
                    szOriginatingUUID );

                Printf(
                    "%s%6x%37s%8I64d%18s\n",
                    Indent(nIndents+1),
                    pMetaDataExt->rgMetaData[ iprop ].dwVersion,
                    szOriginatingUUID,
                    pMetaDataExt->rgMetaData[ iprop ].usnOriginating,
                    DSTimeToDisplayString(pMetaDataExt->rgMetaData[iprop].timeChanged, szTime)
                    );
            }

            FreeMemory(pMetaDataExt);
            fSuccess = TRUE;
        }
    }

    return(fSuccess);
}


BOOL
Dump_VALUE_META_DATA(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public VALUE_META_DATA dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of VALUE_META_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    VALUE_META_DATA             *pMetaData = NULL;

    Printf("%sVALUE_META_DATA\n", Indent(nIndents));

    pMetaData = (VALUE_META_DATA *) ReadMemory(pvProcess,
                                               sizeof(VALUE_META_DATA));

    if (NULL != pMetaData)
    {
        CHAR        szLocalUSN[ 40 ];
        CHAR        szOriginatingUUID[ 40 ];
        CHAR        szTime[ SZDSTIME_LEN ];
        CHAR        szTime1[ SZDSTIME_LEN ];
        struct tm * ptm;

        Printf(
            "\n%s%18s%6s%8s%37s%8s%18s\n",
            Indent(nIndents+1),
            "Cre.Time/Date",
            "Ver",
            "Loc.USN",
            "Originating DSA",
            "Org.USN",
            "Org.Time/Date"
            );

        Printf(
            "%s%18s%6s%8s%37s%8s%18s\n",
            Indent(nIndents+1),
            "============="
            "===",
            "=======",
            "===============",
            "=======",
            "============="
            );

        RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &pMetaData->MetaData.usnProperty,
            10,
            sizeof( szLocalUSN ),
            szLocalUSN
            );

        DraUuidToStr(
            &pMetaData->MetaData.uuidDsaOriginating,
            szOriginatingUUID );

        Printf(
            "%s%18s%6d%8s%37s%8I64d%18s\n",
            Indent(nIndents+1),
            DSTimeToDisplayString(pMetaData->timeCreated, szTime),
            pMetaData->MetaData.dwVersion,
            szLocalUSN,
            szOriginatingUUID,
            pMetaData->MetaData.usnOriginating,
            DSTimeToDisplayString(pMetaData->MetaData.timeChanged, szTime1)
            );

        FreeMemory(pMetaData);
        fSuccess = TRUE;
    }

    return(fSuccess);
}


BOOL
Dump_VALUE_META_DATA_EXT(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public VALUE_META_DATA dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of VALUE_META_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                        fSuccess = FALSE;
    VALUE_META_DATA_EXT        *pMetaData = NULL;

    Printf("%sVALUE_META_DATA_EXT\n", Indent(nIndents));

    pMetaData = (VALUE_META_DATA_EXT *) ReadMemory(pvProcess,
                                                   sizeof(VALUE_META_DATA_EXT));

    if (NULL != pMetaData)
    {
        CHAR        szOriginatingUUID[ 40 ];
        CHAR        szTime[ SZDSTIME_LEN ];
        CHAR        szTime1[ SZDSTIME_LEN ];
        struct tm * ptm;

        Printf(
            "\n%s%18s%6s%37s%8s%18s\n",
            Indent(nIndents+1),
            "Cre.Time/Date",
            "Ver",
            "Originating DSA",
            "Org.USN",
            "Org.Time/Date"
            );

        Printf(
            "%s%18s%6s%37s%8s%18s\n",
            Indent(nIndents+1),
            "=============",
            "===",
            "===============",
            "=======",
            "============="
            );

        DraUuidToStr(
            &pMetaData->MetaData.uuidDsaOriginating,
            szOriginatingUUID );

        Printf(
            "%s%18s%6d%37s%8I64d%18s\n",
            Indent(nIndents+1),
            DSTimeToDisplayString(pMetaData->timeCreated, szTime),
            pMetaData->MetaData.dwVersion,
            szOriginatingUUID,
            pMetaData->MetaData.usnOriginating,
            DSTimeToDisplayString(pMetaData->MetaData.timeChanged, szTime1)
            );

        FreeMemory(pMetaData);
        fSuccess = TRUE;
    }

    return(fSuccess);
}


BOOL
Dump_ENTINF(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ENTINF dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ENTINF in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL     fSuccess = FALSE;
    ENTINF   *pEntInf = NULL;
    DWORD    iCursor;

    Printf("%sENTINF\n", Indent(nIndents));

    pEntInf = (ENTINF *) ReadMemory(pvProcess, sizeof(ENTINF));

    if (NULL != pEntInf)
    {
        fSuccess = Dump_DSNAME(nIndents+1, pEntInf->pName);

        if (fSuccess)
        {
            Printf("%sulFlags: 0x%x\n", Indent(nIndents+1), pEntInf->ulFlags);

            fSuccess = Dump_AttrBlock(nIndents+1, (BYTE *) pvProcess + offsetof(ENTINF, AttrBlock));
        }

        FreeMemory(pEntInf);
    }

    return(fSuccess);
}


BOOL
Dump_ENTINFSEL(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ENTINFSEL dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ENTINFSEL in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    ENTINFSEL   *pEntInfSel = NULL;
    DWORD       iCursor;

    Printf("%sENTINFSEL\n", Indent(nIndents));

    pEntInfSel = (ENTINFSEL *) ReadMemory(pvProcess, sizeof(ENTINFSEL));

    if (NULL != pEntInfSel)
    {
        Printf("%sattSel: %s\n",
               Indent(nIndents+1),
               PszSelCodeToString(pEntInfSel->attSel));

        Printf("%sinfoTypes: %s\n",
               Indent(nIndents+1),
               PszSelCodeToString(pEntInfSel->infoTypes));

        fSuccess = Dump_AttrBlock_local(
                nIndents+1,
                &(pEntInfSel->AttrTypBlock),
                FALSE);

        FreeMemory(pEntInfSel);
    }

    return fSuccess;
}


BOOL
Dump_RANGEINFSEL(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public RANGEINFSEL dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of RANGEINFSEL in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    RANGEINFSEL *pRangeInfSel = NULL;
    DWORD       iCursor=0;
    RANGEINFOITEM *pInfo = NULL;

    Printf("%sRANGEINFSEL\n", Indent(nIndents));

    pRangeInfSel = (RANGEINFSEL *) ReadMemory(pvProcess, sizeof(RANGEINFSEL));

    if (NULL != pRangeInfSel)
    {
        Printf("%svalueLimit: %d\n",
               Indent(nIndents+1),
               pRangeInfSel->valueLimit);

        Printf("%sranges [%d]:\n",Indent(nIndents+1),pRangeInfSel->count);
        if(pRangeInfSel->count) {
            pInfo =
                (RANGEINFOITEM *)ReadMemory(
                        pvProcess,
                        min(50,pRangeInfSel->count) * sizeof(RANGEINFOITEM));
            if(pInfo) {
                while(iCursor < 50 && iCursor < pRangeInfSel->count) {
                    Printf("%sATT %d = %d - %d\n",
                           Indent(nIndents+1),
                           pInfo->AttId,
                           pInfo->lower,
                           pInfo->upper);
                    iCursor++;
                }
                if(iCursor == 50 && iCursor < pRangeInfSel->count) {
                    Printf("%sMore not shown.\n",Indent(nIndents+1));
                }
                FreeMemory(pInfo);
            }
        }

        FreeMemory(pRangeInfSel);
    }

    return fSuccess;
}


BOOL
Dump_REPLENTINFLIST(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REPLENTINFLIST dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLENTINFLIST in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    REPLENTINFLIST  *pReplEntInfList = NULL;

    Printf("%sREPLENTINFLIST\n", Indent(nIndents));

    pReplEntInfList = (REPLENTINFLIST *) ReadMemory(pvProcess, sizeof(REPLENTINFLIST));

    if (NULL != pReplEntInfList)
    {
        Printf("%spNextEntInf: @ 0x%x\n", Indent(nIndents+1), pReplEntInfList->pNextEntInf);

        fSuccess = Dump_ENTINF(nIndents+1, ((BYTE *) pvProcess + offsetof(REPLENTINFLIST, Entinf)));

        if (fSuccess)
        {
            fSuccess = Dump_PROPERTY_META_DATA_EXT_VECTOR(nIndents+1, pReplEntInfList->pMetaDataExt);
        }

        FreeMemory(pReplEntInfList);
    }

    return fSuccess;
}


BOOL
Dump_REPLVALINF(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REPLVALINF dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLVALINF in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    REPLVALINF     *pReplValInf = NULL;
    UCHAR          *pVal = NULL;

    Printf("%sREPLVALINF @ %p\n", Indent(nIndents), pvProcess);

    pReplValInf = (REPLVALINF *) ReadMemory(pvProcess, sizeof(REPLVALINF));

    if (NULL != pReplValInf)
    {
        // pObject
        Dump_DSNAME(nIndents, pReplValInf->pObject);
        // attrtyp
        Printf("%sAttr type:            0x%x\n",
               Indent(nIndents),  pReplValInf->attrTyp);
        // Aval
        Printf("%sAVal: @ %p, len 0x%x\n", Indent(nIndents+1),
               pReplValInf->Aval.pVal, pReplValInf->Aval.valLen);

        pVal = (UCHAR *) ReadMemory(pReplValInf->Aval.pVal, pReplValInf->Aval.valLen);
        if (NULL != pVal) {
            // I need a way to know which attributes have which syntax. The only syntaxes
            // possible in this context are the DSNAME based ones. Of those, only a handfull
            // at present are DB-BINARY ones. We use a hardcoded list for these.
            // Note the use of "local" dump routines at this point since the blob
            // is now in local memory.
            switch (pReplValInf->attrTyp) {
            case ATT_MS_DS_HAS_INSTANTIATED_NCS:
            case ATT_MS_DS_REPLICATES_NC_REASON:
            case ATT_OTHER_WELL_KNOWN_OBJECTS:
            case ATT_PROXIED_OBJECT_NAME:
            case ATT_WELL_KNOWN_OBJECTS:
            {
                // SYNTAX_DISTNAME_BINARY_TYPE
                SYNTAX_DISTNAME_STRING *pDA =
                    (SYNTAX_DISTNAME_STRING *)pVal;

                if (pReplValInf->Aval.valLen >= NAME_DATA_SIZE(pDA))
                {
                    DSNAME *pDN = NAMEPTR( pDA );
                    SYNTAX_ADDRESS *pSA = DATAPTR( pDA );

                    // Make sure value is good
                    if (pDN->structLen >= DSNameSizeFromLen(0)) {
                        Dump_DSNAME_local( nIndents + 1, pDN );
                    } else {
                        Printf( "invalid DSNAME, too short\n" );
                    }
                    Printf("%sDATA: len 0x%x\n", Indent(nIndents+1), pSA->structLen );
                    ShowBinaryData( nIndents, pSA->uVal, pSA->structLen );
                } else {
                    Printf( "invalid DSNAME_BINARY, too short\n" );
                }

                break;
            }
            default:
            {
                // SYNTAX_DISTNAME_TYPE
                DSNAME *pDN = (DSNAME *)pVal;
                if ( (pReplValInf->Aval.valLen >= pDN->structLen) &&
                     (pDN->structLen >= DSNameSizeFromLen(0)) ) {
                    Dump_DSNAME_local( nIndents + 1, pDN );
                } else {
                    Printf( "invalid DSNAME, too short\n" );
                }
            }
            }
            FreeMemory(pVal);
        }
        // fIsPresent
        Printf("%sIsPresent             0x%x\n",
               Indent(nIndents), pReplValInf->fIsPresent);
        // ValueMetaData
        fSuccess = Dump_VALUE_META_DATA_EXT(nIndents+1,
                     ((PBYTE) pvProcess) + offsetof( REPLVALINF, MetaData )  );

        FreeMemory(pReplValInf);
    }

    return fSuccess;
}


char *PszSelCodeToString(UCHAR ch)
/*++

Routine Description:

    This routine returns the string form of attribute selection code
    corresponding to the given character code.

Arguments:

    ch - character code for the type of attribute selection

Return Value:

    String corresponding to the code, or "Unknown Selection Code" if
    the given selection code is unknown.

--*/

{
    DWORD i;

    for (i = 0; i < cAttrSelectionCode; i++)
    {
        if (ch == rAttrSelectionCode[i].chCode)
            return rAttrSelectionCode[i].pszCode;
    }

    return UNKNOWN_SELECTION_CODE;

}

BOOL
Dump_REPLICA_LINK(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )

/*++

Routine Description:

    Public REPLICA_LINK dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REPLICA_LINK in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        DWORD dw;
        LPSTR psz;
    } rgFlags[] =   {
                        { DRS_INIT_SYNC            , "INIT_SYNC"             },
                        { DRS_PER_SYNC             , "PER_SYNC"              },
                        { DRS_WRIT_REP             , "WRIT_REP"              },
                        { DRS_MAIL_REP             , "MAIL_REP"              },
                        { DRS_DISABLE_AUTO_SYNC    , "DISABLE_AUTO_SYNC"     },
                        { DRS_DISABLE_PERIODIC_SYNC, "DISABLE_PERIODIC_SYNC" },
                        { DRS_FULL_SYNC_IN_PROGRESS, "FULL_SYNC_IN_PROGRESS" },
                        { DRS_FULL_SYNC_PACKET     , "FULL_SYNC_PACKET"      },
                        { DRS_USE_COMPRESSION      , "USE_COMPRESSION"       },
                        { DRS_NEVER_NOTIFY         , "NEVER_NOTIFY"          },
                        { DRS_NEVER_SYNCED         , "NEVER_SYNCED"          },
                        { DRS_TWOWAY_SYNC          , "TWOWAY_SYNC"           },
                        { DRS_SYNC_PAS             , "SYNC_PAS"              },
                        { 0,                         NULL                    }
                    };

    static LPCSTR rgpszDays[] =
    { "SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT" };

    static UUID uuidNull = { 0 };

    BOOL            fSuccess = FALSE;
    REPLICA_LINK *  prl;
    DWORD           dwFlags;
    DWORD           iFlag;
    CHAR            szTime[ SZDSTIME_LEN ];
    struct tm *     ptm;
    DWORD           cb;

    prl = (REPLICA_LINK *) ReadMemory( pvProcess, offsetof( REPLICA_LINK, V1.cb ) + sizeof( DWORD ) );

    if ( NULL != prl && VERSION_V1 == prl->dwVersion)
    {
        cb = prl->V1.cb;
        FreeMemory( prl );

        prl = (REPLICA_LINK *) ReadMemory( pvProcess, cb );

        if ( NULL != prl )
        {
            Printf( "%sREPLICA_LINK (Version 1)\n", Indent( nIndents ) );

            cb = sizeof( *prl ) + prl->V1.cbOtherDra;
            if ( prl->V1.cbPASDataOffset ) {
                // calc alignment offset
                cb += prl->V1.cbPASDataOffset - (prl->V1.cbOtherDraOffset + prl->V1.cbOtherDra);
                // and PAS struct contents
                cb += RL_PPAS_DATA(prl)->size;
            }

            if ( prl->V1.cb != cb )
            {
                Printf( "%s!! ReplicaLink length is invalid -- %d != %d  !!\n",
                        Indent( nIndents ), prl->V1.cb, cb);
            }

            if ( prl->V1.cbOtherDraOffset != offsetof( REPLICA_LINK, V1.rgb ) )
            {
                Printf( "%s!! ReplicaLink Other-DRA-Offset is invalid -- %d != %d !!\n",
                        Indent( nIndents ), prl->V1.cbOtherDraOffset, offsetof( REPLICA_LINK, V1.rgb ) );
            }

            //
            // Display server name.
            //

            Printf( "%s%s\n", Indent( nIndents + 2 ), RL_POTHERDRA( prl )->mtx_name );


            //
            // Display DSA objectGuid.
            //

            Printf( "%snstdDsa objectGuid:   ", Indent( nIndents + 2 ) );

            Printf( "%s\n", DraUuidToStr( &prl->V1.uuidDsaObj, NULL ) );

            if (memcmp(&prl->V1.uuidInvocId, &uuidNull, sizeof(UUID))) {
                //
                // Display DSA invocationId.
                //

                Printf( "%snstdDsa invocationId: ", Indent( nIndents + 2 ) );

                Printf( "%s\n", DraUuidToStr( &prl->V1.uuidInvocId, NULL ) );
            }

            //
            // Display replica flags.
            //

            Printf( "%s", Indent( nIndents + 2 ) );

            dwFlags = prl->V1.ulReplicaFlags;

            for ( iFlag = 0; NULL != rgFlags[ iFlag ].psz; iFlag++ )
            {
                if ( dwFlags & rgFlags[ iFlag ].dw )
                {
                    Printf( "%s ", rgFlags[ iFlag ].psz );
                    dwFlags &= ~rgFlags[ iFlag ].dw;
                }
            }

            if ( dwFlags )
            {
                Printf( "0x%X", dwFlags );
            }

            Printf( "\n" );


            if ( prl->V1.ulReplicaFlags & DRS_PER_SYNC )
            {
                DWORD   iDay;
                DWORD   ib;

                //
                // Display schedule.
                //

                Printf( "%sPeriodic schedule:\n", Indent( nIndents + 2 ) );
                for ( iDay = 0; iDay < 7; iDay++ )
                {
                    Printf( "%s%s ", Indent( nIndents + 4 ), rgpszDays[ iDay ] );

                    for ( ib = 0; ib < 12; ib++ )
                    {
                        Printf( " %02x", prl->V1.rtSchedule.rgTimes[ iDay * 12 + ib ] );
                    }

                    Printf( "\n" );
                }
            }


            //
            // Display USNs.
            //

            Printf("%sUSNs: %I64d/OU, %I64d/PU\n",
                   Indent( nIndents + 2 ),
                   prl->V1.usnvec.usnHighObjUpdate,
                   prl->V1.usnvec.usnHighPropUpdate);

            //
            // Display status and time of last replication attempt.
            //

            Printf("%sLast attempt %s, result %d.\n",
                   Indent(nIndents + 2),
                   DSTimeToDisplayString(prl->V1.timeLastAttempt, szTime),
                   prl->V1.ulResultLastAttempt);


            //
            // Display time of last successful replication.
            //

            Printf("%sLast success %s.\n",
                   Indent( nIndents + 2 ),
                   DSTimeToDisplayString(prl->V1.timeLastSuccess, szTime));


            Printf( "%s%u consecutive failure(s).\n", Indent(nIndents + 2), prl->V1.cConsecutiveFailures );


//          Printf( "%s dwReserved1: 0x%x\n", Indent(nIndents + 2), prl->V1.dwReserved1 );
            Printf( "%s PAS Data offset: %u\n", Indent(nIndents + 2), prl->V1.cbPASDataOffset);
            if ( prl->V1.cbPASDataOffset) {
                Printf( "%sPAS Data:\n", Indent(nIndents + 2));
                Printf( "%sversion: %d\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->version );
                Printf( "%ssize: %lu\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->size );
                Printf( "%sflag: %lu\n", Indent(nIndents + 3), RL_PPAS_DATA(prl)->flag );
                Printf( "%sPARTIAL_ATTR_VECTOR: %d attrs\n",
                        Indent(nIndents + 3),
                        RL_PPAS_DATA(prl)->PAS.V1.cAttrs );
            }


            FreeMemory( prl );
            fSuccess = TRUE;
        }
    }

    return fSuccess;
}

BOOL
Dump_CreateNcInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public CREATENCINFO struct dump routine.  Note really needed, but just to follow suit.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CREATENCINFO in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    CREATENCINFO *  pCreateNC;

    pCreateNC = ReadMemory(pvProcess, sizeof(CREATENCINFO));
    if (!pCreateNC) {
        return FALSE;
    }

    Printf("%sCreateNcInfo Struct Object:\n",
           Indent(nIndents));

    if(pCreateNC){
        Printf("%siKind = %X\n", Indent(nIndents), pCreateNC->iKind);
        Printf("%sfNcAbove = %s\n", Indent(nIndents),
               (pCreateNC->fNcAbove) ? "TRUE" : "FALSE");
        Printf("%sfTestAdd = %s\n", Indent(nIndents),
               (pCreateNC->fTestAdd) ? "TRUE" : "FALSE");
        Printf("%sfNullNcGuid = %s\n", Indent(nIndents),
               (pCreateNC->fNullNcGuid) ? "TRUE" : "FALSE");
        Printf("%sfSetRefDom = %s\n", Indent(nIndents),
               (pCreateNC->fSetRefDom) ? "TRUE" : "FALSE");

        if(pCreateNC->pSDRefDomCR){
            Printf("%spSDRefDomCR @ %p\n", Indent(nIndents), pCreateNC->pSDRefDomCR);
        }
    }

    FreeMemory(pCreateNC);

    return TRUE;

}

BOOL
Dump_CrossRefInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public ADDCROSSREFINFO struct dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ADDCROSSREFINFO in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    BOOL            fSuccess = FALSE;
    ADDCROSSREFINFO *  pCRInfo;

    pCRInfo = ReadMemory(pvProcess, sizeof(ADDCROSSREFINFO));
    if (!pCRInfo) {
        return FALSE;
    }

    Printf("%sAddCrossRefInfo Struct Object:\n",
           Indent(nIndents));

    Printf("%spNCName @ %p\n", Indent(nIndents), pCRInfo->pdnNcName);
    Printf("%sbEnabled = %X\n", Indent(nIndents), pCRInfo->bEnabled);
    Printf("%sulSysFlags = %ul\n", Indent(nIndents), pCRInfo->ulSysFlags);

    Printf("%sulDsCrackChild = %X\n", Indent(nIndents), pCRInfo->ulDsCrackChild);
    Printf("%sulChildCheck = %X\n", Indent(nIndents), pCRInfo->ulChildCheck);
    Printf("%swszChildCheck @ %p\n", Indent(nIndents), pCRInfo->wszChildCheck);

    Printf("%sulDsCrackParent = %X\n", Indent(nIndents), pCRInfo->ulDsCrackParent);
    Printf("%sulParentCheck = %X\n", Indent(nIndents), pCRInfo->ulParentCheck);
    Printf("%sGuid: %s\n", Indent(nIndents), DraUuidToStr(&(pCRInfo->ParentGuid), NULL));

    FreeMemory(pCRInfo);

    return TRUE;
}

BOOL
Dump_AddArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public addarg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of Addarg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    ADDARG        * pAddArg;

    pAddArg = ReadMemory(pvProcess, sizeof(ADDARG));
    if (!pAddArg) {
        return FALSE;
    }

    Printf("%sAddArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pAddArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pAddArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pAddArg->pMetaDataVecRemote);

    fSuccess = Dump_AttrBlock(nIndents+1,
                              (BYTE *) pvProcess + offsetof(ADDARG, AttrBlock));

    Printf("%sResolved parent object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pAddArg->pResParent));

    Printf("%spCreateNC: @ %p\n", Indent(nIndents), pAddArg->pCreateNC);
    if (pAddArg->pCreateNC) {
        Dump_CreateNcInfo(nIndents+1, (PVOID) (pAddArg->pCreateNC));
    }

    Printf("%spCRInfo: @ %p\n", Indent(nIndents), pAddArg->pCRInfo);
    if(pAddArg->pCRInfo){
        Dump_CrossRefInfo(nIndents+1, (PVOID) (pAddArg->pCRInfo));
    }

    FreeMemory(pAddArg);

    return TRUE;
}

BOOL
Dump_AddRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ADDRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ADDRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ADDRES *pAddRes;

    Printf("%sADDRES", Indent(nIndents));
    nIndents++;

    if (NULL == (pAddRes = ReadMemory(pvProcess, sizeof(ADDRES)))) {
        return FALSE;
    }

    Printf("%sAlias dereferenced: %s\n",
           Indent(nIndents),
           pAddRes->CommRes.aliasDeref ? "yes" : "no");

    Dump_Error(nIndents,
               pAddRes->CommRes.errCode,
               pAddRes->CommRes.pErrInfo);

    FreeMemory(pAddRes);

    return TRUE;
}

BOOL
Dump_SearchArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SEARCHARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SEARCHARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    SEARCHARG       * pSearchArg;

    pSearchArg = ReadMemory(pvProcess, sizeof(SEARCHARG));
    if (!pSearchArg) {
        return FALSE;
    }

    Printf("%sSearchArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pSearchArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    switch(pSearchArg->choice) {
    case SE_CHOICE_BASE_ONLY:
        Printf("%sScope: Base Object\n",Indent(nIndents));
        break;
    case SE_CHOICE_IMMED_CHLDRN:
        Printf("%sScope: One Level\n",Indent(nIndents));
        break;
    case SE_CHOICE_WHOLE_SUBTREE:
        Printf("%sScope: Whole Subtree\n",Indent(nIndents));
        break;
    default:
        Printf("%sScope: invalid %d\n",Indent(nIndents),pSearchArg->choice);
        break;
    }

    Printf("%sRestrict to NC: %s\n",
           Indent(nIndents),
           (pSearchArg->bOneNC ? "TRUE" : "FALSE"));

    Printf("%sSearchArg Filter:\n",Indent(nIndents));
    fSuccess = Dump_FILTER(nIndents+1,pSearchArg->pFilter);

    Printf("%sSearch Aliases NC: %s\n",
           Indent(nIndents),
           (pSearchArg->searchAliases ? "TRUE" : "FALSE"));

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pSearchArg->CommArg);


    fSuccess = Dump_ENTINFSEL(nIndents+1,
                              pSearchArg->pSelection);


    fSuccess = Dump_RANGEINFSEL(nIndents+1,
                                pSearchArg->pSelectionRange);

    Printf("%sResolved search base:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pSearchArg->pResObj));

    FreeMemory(pSearchArg);

    return fSuccess;
}

BOOL
Dump_SearchRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SEARCHRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SEARCHRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = TRUE;
    SEARCHRES * pSearchRes;

    Printf("%sSEARCHRES\n", Indent(nIndents));
    nIndents++;

    pSearchRes = ReadMemory(pvProcess, sizeof(SEARCHRES));
    if (!pSearchRes) {
        return FALSE;
    }

    Printf("%sBase object:\n", Indent(nIndents));
    if (pSearchRes->pBase) {
        fSuccess = Dump_DSNAME(nIndents+1, pSearchRes->pBase);
    }
    else {
        Printf("%s(NULL)\n", Indent(nIndents+1));
    }

    if (fSuccess) {
        Printf("%sbaseProvided               0x%x\n",
               Indent(nIndents), pSearchRes->baseProvided);
        Printf("%sbSorted                    0x%x\n",
               Indent(nIndents), pSearchRes->bSorted);
        Printf("%scount                      %d (0x%x)\n",
               Indent(nIndents), pSearchRes->count, pSearchRes->count);

        Printf("%sFirstEntInf              @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, FirstEntInf));

        Printf("%sFirstRangeInf            @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, FirstRangeInf));

        Printf("%spPartialOutcomeQualifier @ %p\n",
               Indent(nIndents),
               pSearchRes->pPartialOutcomeQualifier);

        Printf("%sPagedResult              @ %p\n",
               Indent(nIndents),
               (BYTE *) pvProcess + offsetof(SEARCHRES, PagedResult));

        Dump_CommRes(nIndents,
                     (BYTE *) pvProcess + offsetof(SEARCHRES, CommRes));
    }

    return fSuccess;
}

BOOL
Dump_ReadArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public READARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of READARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    READARG       * pReadArg;

    pReadArg = ReadMemory(pvProcess, sizeof(READARG));
    if (!pReadArg) {
        return FALSE;
    }

    Printf("%sReadArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pReadArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pReadArg->CommArg);


    fSuccess = Dump_ENTINFSEL(nIndents+1,
                              pReadArg->pSel);

    Printf("%sResolved object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pReadArg->pResObj));

    FreeMemory(pReadArg);

    return fSuccess;
}

BOOL
Dump_ReadRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public READRES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of READRES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL fSuccess;

    Printf("%sREADRES\n", Indent(nIndents));
    nIndents++;

    /* ENTINF */
    fSuccess = Dump_ENTINF( nIndents, ((BYTE *) pvProcess + offsetof( READRES, entry )));
    /* COMMRES */
    if (fSuccess) {
        Dump_CommRes( nIndents, ((BYTE *) pvProcess + offsetof( READRES, CommRes )));
    }

    return fSuccess;
}

BOOL
Dump_RemoveArg(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public removearg dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of removearg in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL        fSuccess = FALSE;
    REMOVEARG * pRemoveArg;

    pRemoveArg = ReadMemory(pvProcess, sizeof(REMOVEARG));
    if (!pRemoveArg) {
        return FALSE;
    }

    Printf("%sRemoveArg Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pRemoveArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pRemoveArg->CommArg);

    Printf("%sfPreserveRDN         0x%x\n",
           Indent(nIndents),
           pRemoveArg->fPreserveRDN);

    Printf("%sfGarbCollectASAP     0x%x\n",
           Indent(nIndents),
           pRemoveArg->fGarbCollectASAP);

    Printf("%sfTreeDelete          0x%x\n",
           Indent(nIndents),
           pRemoveArg->fTreeDelete);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pRemoveArg->pMetaDataVecRemote);

    Printf("%sResolved object:\n", Indent(nIndents));
    fSuccess = Dump_RESOBJ(nIndents+1,
                           (PVOID)(pRemoveArg->pResObj));

    FreeMemory(pRemoveArg);

    return fSuccess;
}

BOOL
Dump_RemoveRes(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public REMOVERES dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of REMOVERES in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    REMOVERES * pRemoveRes;

    Printf("%sREMOVERES", Indent(nIndents));
    nIndents++;

    if (NULL == (pRemoveRes = ReadMemory(pvProcess, sizeof(REMOVERES)))) {
        return FALSE;
    }

    Dump_Error(nIndents,
               pRemoveRes->CommRes.errCode,
               pRemoveRes->CommRes.pErrInfo);

    FreeMemory(pRemoveRes);

    return TRUE;
}

BOOL
Dump_FILTER(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public FILTER dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of FILTER in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    FILTER          *pFilter;
    USHORT          i;
    SUBSTRING       *pSubStr;
    ANYSTRINGLIST   *pAny;
    BOOLEAN         bogus = FALSE;


    Printf("%sFILTER @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    if (NULL == (pFilter = ReadMemory(pvProcess, sizeof(FILTER)))) {
        return FALSE;
    }

    switch ( pFilter->choice )
    {
    case FILTER_CHOICE_ITEM:

        Printf("%sFILTER_CHOICE_ITEM\n", Indent(nIndents));
        nIndents++;

        switch ( pFilter->FilterTypes.Item.choice )
        {
        case FI_CHOICE_EQUALITY:

            Printf("%sFI_CHOICE_EQUALITY - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_SUBSTRING:

            Printf("%sFI_CHOICE_SUBSTRING\n", Indent(nIndents));
            Dump_SUBSTRING(nIndents+1,
                           pFilter->FilterTypes.Item.FilTypes.pSubstring);
            break;

        case FI_CHOICE_GREATER:

            Printf("%sFI_CHOICE_GREATER - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_GREATER_OR_EQ:

            Printf("%sFI_CHOICE_GREATER_OR_EQ - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_LESS:

            Printf("%sFI_CHOICE_LESS - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_LESS_OR_EQ:

            Printf("%sFI_CHOICE_LESS_OR_EQ - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_NOT_EQUAL:

            Printf("%sFI_CHOICE_NOT_EQUAL - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_PRESENT:

            Printf("%sFI_CHOICE_PRESENT - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.present);

            break;

        case FI_CHOICE_TRUE:

            Printf("%sFI_CHOICE_TRUE\n", Indent(nIndents));
            break;

        case FI_CHOICE_FALSE:

            Printf("%sFI_CHOICE_FALSE\n", Indent(nIndents));
            break;

        case FI_CHOICE_BIT_AND:

            Printf("%sFI_CHOICE_BIT_AND - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        case FI_CHOICE_BIT_OR:

            Printf("%sFI_CHOICE_BIT_OR - attr(0x%x)\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.FilTypes.ava.type);
            Dump_BinaryCount(
                   nIndents+1,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.pVal,
                   pFilter->FilterTypes.Item.FilTypes.ava.Value.valLen);
            break;

        default:
            Printf("%s*** Unknown choice 0x%x\n",
                   Indent(nIndents),
                   pFilter->FilterTypes.Item.choice);
            bogus = TRUE;
            break;

        }

        Printf("%sExpected Size %d\n", Indent(nIndents), pFilter->FilterTypes.Item.expectedSize);

        nIndents--;
        break;

    case FILTER_CHOICE_AND:

        Printf("%sFILTER_CHOICE_AND[0x%x]\n",
               Indent(nIndents),
               pFilter->FilterTypes.And.count);
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.And.pFirstFilter);

        break;

    case FILTER_CHOICE_OR:

        Printf("%sFILTER_CHOICE_OR[0x%x]\n",
               Indent(nIndents),
               pFilter->FilterTypes.Or.count);
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.Or.pFirstFilter);

        break;

    case FILTER_CHOICE_NOT:

        Printf("%sFILTER_CHOICE_NOT\n", Indent(nIndents));
        Dump_FILTER(nIndents+1, pFilter->FilterTypes.pNot);
        break;

    case FI_CHOICE_UNDEFINED:
        Printf("%sFILTER_CHOICE_UNDEFINED\n", Indent(nIndents));
        break;

    default:

        Printf("%s*** Unknown choice 0x%x\n",
               Indent(nIndents),
               pFilter->choice);
        bogus = TRUE;
        break;
    }

    nIndents--;

    if ( NULL != pFilter->pNextFilter) {
        if (bogus) {
            Printf("%sIgnoring supposed next filter @ %p\n",
                   Indent(nIndents),
                   pFilter->pNextFilter);
        }
        else {
            Dump_FILTER(nIndents, pFilter->pNextFilter);
        }
    }

    FreeMemory(pFilter);

    return(TRUE);
}

BOOL
Dump_SUBSTRING(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SUBSTRING dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SUBSTRING in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    USHORT          i;
    SUBSTRING       *pSubStr;
    ANYSTRINGLIST   *pAnyAddr;
    ANYSTRINGLIST   *pAny;

    Printf("%sSUBSTRING @ %p\n", Indent(nIndents), pvProcess);

    if ( NULL == (pSubStr = ReadMemory(pvProcess, sizeof(SUBSTRING))) )
        return(FALSE);

    Printf("%sATTRTYP(0x%x)\n",
           Indent(nIndents),
           pSubStr->type);

    Printf("%sinitialProvided(0x%x)\n",
           Indent(nIndents),
           pSubStr->initialProvided);

    if ( pSubStr->initialProvided )
        Dump_BinaryCount(nIndents+1,
                         pSubStr->InitialVal.pVal,
                         pSubStr->InitialVal.valLen);

    pAny = &pSubStr->AnyVal.FirstAnyVal;

    for ( i = 0; i < pSubStr->AnyVal.count; i++ )
    {
        Printf("%sAnyVal[%d]\n", Indent(nIndents), i);
        if ( 0 != i )
            if ( NULL == (pAny = ReadMemory(pAnyAddr, sizeof(ANYSTRINGLIST))) )
                break;
        Dump_BinaryCount(nIndents+1, pAny->AnyVal.pVal, pAny->AnyVal.valLen);
        pAnyAddr = pAny->pNextAnyVal;
        if ( 0 != i )
            FreeMemory(pAny);
    }

    Printf("%sfinalProvided(0x%x)\n",
           Indent(nIndents),
           pSubStr->finalProvided);

    if ( pSubStr->finalProvided )
        Dump_BinaryCount(nIndents+1,
                         pSubStr->FinalVal.pVal,
                         pSubStr->FinalVal.valLen);

    FreeMemory(pSubStr);

    return(TRUE);
}

BOOL
Dump_LOCALDNREADCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DNREADCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DNREADCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    DNREADCACHEBUCKET *pLocalDNReadCache = NULL;
    BYTE *          pb;
    DWORD           i,j;
    UUID            uuidNull = { 0 };
    WCHAR          *pName=NULL;
    Printf("%sLOCALDNREADCACHE\n", Indent( nIndents ) );
    nIndents += 2;

    pLocalDNReadCache = (DNREADCACHEBUCKET *)
        ReadMemory( pvProcess,
                   LOCAL_DNREAD_CACHE_SIZE * sizeof(DNREADCACHEBUCKET));

    if(!pLocalDNReadCache) {
        Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
    }
    else {
        Printf("%s\t:DNT\tPDNT\tHits\tRDNLen\tHashKey\tpMemname\n",
               Indent(nIndents));
        for(i=0;i<LOCAL_DNREAD_CACHE_SIZE;i++) {
            Printf("%sBucket %d:\n",Indent(nIndents),i);
            // First, the slots
            if(!pLocalDNReadCache[i].index.ulRDNLen) {
                Printf("%sEmpty\n",Indent(nIndents));
            }
            else {
                BOOL fFoundUnused = FALSE;

                for(j=0;j<DN_READ_CACHE_SLOT_NUM;j++) {
                    switch(pLocalDNReadCache[i].slot[j].DNT) {
                    case 0:
                        // slot is empty
                        Printf("%s%d   \tUNUSED\n",
                               Indent(nIndents),
                               j);
                        fFoundUnused = TRUE;
                        break;
                    case INVALIDDNT:
                        // Empty slot (used to have a value in it).
                        Printf("%s%d   \tEMPTY\n",
                               Indent(nIndents),
                               j);
                        break;

                    default:
                        // Normally full slot.
                        Printf("%s%d\t0x%x\t0x%x\t%d\t%d\t0x%x\t@0x%x\n",
                               Indent(nIndents),
                               j,
                               pLocalDNReadCache[i].slot[j].DNT,
                               pLocalDNReadCache[i].slot[j].PDNT,
                               pLocalDNReadCache[i].slot[j].hitCount,
                               pLocalDNReadCache[i].slot[j].ulRDNLen,
                               pLocalDNReadCache[i].slot[j].dwHashKey,
                               pLocalDNReadCache[i].slot[j].pName
                               );
                        if(fFoundUnused) {
                            // We've already found a never used slot.  This
                            // shouldn't happen.
                            Printf("%s\tERROR! full slot found after UNUSED!\n",
                                   Indent(nIndents));
                        }
                    }
                }

                switch(pLocalDNReadCache[i].hold.DNT) {
                case 0:
                    // slot is empty
                    Printf("%shold\tUNUSED\n",
                           Indent(nIndents),
                           j);
                    fFoundUnused = TRUE;
                    break;
                case INVALIDDNT:
                    // Empty slot (used to have a value in it).
                    Printf("%shold\tEMPTY\n",
                           Indent(nIndents),
                           j);
                    break;

                default:
                    // Normally full hold
                    Printf("%shold\t0x%x\t0x%x\t%d\t%d\t0x%x\t@0x%x\n",
                           Indent(nIndents),
                           pLocalDNReadCache[i].hold.DNT,
                           pLocalDNReadCache[i].hold.PDNT,
                           pLocalDNReadCache[i].hold.hitCount,
                           pLocalDNReadCache[i].hold.ulRDNLen,
                           pLocalDNReadCache[i].hold.dwHashKey,
                           pLocalDNReadCache[i].hold.pName);
                }

                Printf("%sindx\t0x%x\t0x%x\t%d\t%d\t0x%x\t@0x%x\n",
                       Indent(nIndents),
                       pLocalDNReadCache[i].index.DNT,
                       pLocalDNReadCache[i].index.PDNT,
                       pLocalDNReadCache[i].index.hitCount,
                       pLocalDNReadCache[i].index.ulRDNLen,
                       pLocalDNReadCache[i].index.dwHashKey,
                       pLocalDNReadCache[i].index.pName);
            }
        }

        FreeMemory( pLocalDNReadCache );
    }

    return ( NULL == pLocalDNReadCache );
}

BOOL
Dump_GLOBALDNREADCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public DNREADCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of DNREADCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    GLOBALDNREADCACHE    *pGlobalDNReadCache = NULL;
    GLOBALDNREADCACHESLOT  * pData=NULL;
    DWORD           i,j;
    UUID            uuidNull = { 0 };
    WCHAR          *pName=NULL;

    Printf("%sGLOBALDNREADCACHE\n", Indent( nIndents ) );
    nIndents += 2;

    pGlobalDNReadCache = (GLOBALDNREADCACHE *)
        ReadMemory( pvProcess, sizeof( GLOBALDNREADCACHE ) );

    if(!pGlobalDNReadCache) {
        Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
    }
    else {
        Printf("%s%d elements:\n",Indent(nIndents), pGlobalDNReadCache->count);
        Printf("%s  at 0x%x\n",Indent(nIndents), pGlobalDNReadCache->pData);
        pData = (GLOBALDNREADCACHESLOT *)
            ReadMemory(
                    pGlobalDNReadCache->pData,
                    pGlobalDNReadCache->count * sizeof(GLOBALDNREADCACHESLOT));

        Printf("%s%d elements:\n",Indent(nIndents), pGlobalDNReadCache->count);
        Printf("%s  at 0x%x\n",Indent(nIndents), pGlobalDNReadCache->pData);
        if(!pData) {
            Printf("%sFAILED TO READ DATA\n",Indent(nIndents));
        }
        else {
            for(i=0;i < pGlobalDNReadCache->count;i++) {
                d_memname * pmemname = &pData[i].name;

                if(pData[i].valid) {
                    Printf("%s%03d:   VALID",Indent(nIndents), i);
                }
                else {
                    Printf("%s%03d: INVALID",Indent(nIndents), i);
                }
                Printf(
                       " DNT:0x%x  PDNT:0x%x  rdntype:0x%x  (%s)\n",
                       pmemname->DNT,
                       pmemname->tag.PDNT,
                       pmemname->tag.rdnType,
                       pmemname->objflag ? "OBJECT" : "PHANTOM"
                       );


                Printf( "%s", Indent(nIndents) );
                pName = ReadMemory( pmemname->tag.pRdn,
                                   pmemname->tag.cbRdn);
                if(pName) {
                    for ( j = 0;
                         j < pmemname->tag.cbRdn / sizeof( WCHAR ); j++ ) {
                        Printf( "%C", pName[j]);
                    }
                    FreeMemory(pName);
                }
                else {
                    Printf("%s Unavailable RDN",Indent(nIndents));
                    j=15;
                }
                if ( j < 20 ) {
                    CHAR szSpaces[ 21 ];

                    memset( szSpaces, ' ', sizeof( szSpaces ) - 1 );
                    szSpaces[ sizeof( szSpaces ) - 1 ] = '\0';

                    Printf( &szSpaces[ j ] );
                }
                Printf( "hash(0x%x)", pData[i].dwHashKey );
                if ( !memcmp( &pmemname->Guid, &uuidNull, sizeof( GUID ) ) ) {
                    Printf( "(GUID none)\n\n" );
                }
                else {
                    Printf( "(GUID %s)\n\n",
                            DraUuidToStr( &pmemname->Guid, NULL ) );
                }
            }
            FreeMemory(pData);
        }
        FreeMemory( pGlobalDNReadCache );
    }

    return ( NULL == pGlobalDNReadCache );
}

BOOL
Dump_BHCache(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public BHCache dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of BHCache in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        DWORD   dw;
        CHAR *  psz;
    } rgExtensions[] =  {
                          { DRS_EXT_BASE, "BASE" },
                          { DRS_EXT_ASYNCREPL, "Asyncronous replication" },
                          { DRS_EXT_REMOVEAPI, "Remove Server/Domain" } ,
                          { DRS_EXT_MOVEREQ_V2, "InterNCMove version 2" },
                          { DRS_EXT_GETCHG_COMPRESS, "GetChReply v2" },
                          { DRS_EXT_DCINFO_V1, "DS_DOMAIN_CONTROLLER_INFO_1" },
                          { DRS_EXT_STRONG_ENCRYPTION, "Strong encryption"},
                          { DRS_EXT_ADDENTRY, "Remoted AddEntry (OLD)" },
                          { DRS_EXT_KCC_EXECUTE, "KCC Execute" },
                          { DRS_EXT_DCINFO_V2, "DS_DOMAIN_CONTROLLER_INFO_2" },
                          { DRS_EXT_DCINFO_VFFFFFFFF, "DS_DOMAIN_CONTROLLER_INFO_FFFFFFFF" },
                          { DRS_EXT_ADDENTRY_V2, "Remoted AddEntry V2" },
                          { DRS_EXT_INSTANCE_TYPE_NOT_REQ_ON_MOD, "InstType not req on mod" },
                          { DRS_EXT_GET_REPL_INFO, "GetReplInfo" },
                          { DRS_EXT_TRANSITIVE_MEMBERSHIP, "Transitive group Membership" },
                          { DRS_EXT_ADD_SID_HISTORY, "Add SID History" },
                          { DRS_EXT_POST_BETA3, "Post beta 3" },
                          { DRS_EXT_RESTORE_USN_OPTIMIZATION, "Restore USN optimization" },
                          { DRS_EXT_GETMEMBERSHIPS2, "GetMemberships2 (Batchable)" },
                          { DRS_EXT_LINKED_VALUE_REPLICATION, "Linked Value Replication" },
                          { DRS_EXT_GETCHGREQ_V6, "GetChReq V6 (whistler preview)" },
                          { DRS_EXT_GETCHGREQ_V8, "GetChReq V8 (whistler)" },
                          { DRS_EXT_ADDENTRYREPLY_V3, "RemoteAddEntry reply V3 (whistler beta 3)" },
                          { DRS_EXT_GETCHGREPLY_V7, "GetChgReply V7 (whistler beta 3)" },
                          { DRS_EXT_VERIFY_OBJECT, "added IDL_DRSReplicaVerifyObjects() (whistler beta 3)" },
                          { DRS_EXT_XPRESS_COMPRESSION, "Xpress Compression" },
                        };
    static DWORD cNumExtensions = sizeof(rgExtensions) / sizeof(rgExtensions[0]);

    BHCacheElement  *rgBHCache = NULL;
    DWORD           cBytes = BHCacheSize * sizeof(BHCacheElement);
    DWORD           i;
    BOOL            fSuccess;
    char *          pszServer;
    DWORD           iExt;
    DRS_EXTENSIONS *pext;
    DWORD           cbOffset;
    BYTE            bMask;

    Printf("%srgBHCache\n", Indent(nIndents));
    nIndents++;

    rgBHCache = (BHCacheElement *) ReadMemory(pvProcess, cBytes);

    if ( NULL == rgBHCache )
        return(FALSE);

    for ( i = 0, fSuccess = TRUE; fSuccess && (i < BHCacheSize); i++ )
    {
        if ( rgBHCache[i].pszServer )
        {
            pszServer = ReadMemory( rgBHCache[i].pszServer,
                                    rgBHCache[i].cchServer * sizeof(WCHAR) );
            fSuccess = ( NULL != pszServer );

            if ( fSuccess )
            {
                Printf("%s[%4d] - server(%ls) pszServerPrincName(%p) hDrs(%p) "
                            "cRefs(0x%x) fDontUse(0x%x) ext(",
                       Indent(nIndents),
                       i,
                       pszServer,
                       rgBHCache[i].pszServerPrincName,
                       rgBHCache[i].hDrs,
                       rgBHCache[i].cRefs,
                       rgBHCache[i].fDontUse);

                // Dump extensions we know about.
                pext = &rgBHCache[i].extRemote;
                for (iExt = 0; iExt < cNumExtensions; iExt++) {
                    cbOffset = rgExtensions[ iExt ].dw / 8;
                    bMask = 1 << (rgExtensions[ iExt ].dw % 8);

                    if ((cbOffset <= pext->cb)
                        && (bMask & pext->rgb[ cbOffset ])) {
                        // Remote server supports this extension.
                        Printf("%s ", rgExtensions[ iExt ].psz);
                    }
                }

                Printf( ")\n" );

                FreeMemory( pszServer );
            }
        }
    }

    FreeMemory(rgBHCache);
    return(TRUE);
}

BOOL
Dump_MODIFYARG(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public MODIFYARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MODIFYARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    static struct
    {
        USHORT  usChoice;
        CHAR *  pszChoice;
    } rgChoices[] = {
                        { AT_CHOICE_ADD_ATT,       "ADD_ATT"        },
                        { AT_CHOICE_REMOVE_ATT,    "REMOVE_ATT"     },
                        { AT_CHOICE_ADD_VALUES,    "ADD_VALUES"     },
                        { AT_CHOICE_REMOVE_VALUES, "REMOVE_VALUES"  },
                        { AT_CHOICE_REPLACE_ATT,   "REPLACE_ATT"    },
                    };
    static DWORD cNumChoices = sizeof(rgChoices) / sizeof(rgChoices[0]);

    BOOL            fSuccess = FALSE;
    MODIFYARG *     pModifyArg;
    DWORD           iMod;
    DWORD           iChoice;
    CHAR *          pszChoice;
    ATTRMODLIST *   pMod;
    ATTRMODLIST *   pNextMod;

    pModifyArg = ReadMemory(pvProcess, sizeof(MODIFYARG));
    if (!pModifyArg) {
        return FALSE;
    }

    Printf("%sMODIFYARG Object:\n",
           Indent(nIndents));

    fSuccess = Dump_DSNAME(nIndents+1,
                           pModifyArg->pObject);
    if (!fSuccess) {
        return FALSE;
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pModifyArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents),
           pModifyArg->pMetaDataVecRemote);

    Printf("%sResolved object:\n", Indent(nIndents));
    Dump_RESOBJ(nIndents+1,
                (PVOID)(pModifyArg->pResObj));

    Printf("%sATTRMODLIST (%d attributes):\n",
           Indent(nIndents),
           pModifyArg->count);

    pMod = (ATTRMODLIST *) &pModifyArg->FirstMod;

    for ( iMod = 0; fSuccess && (iMod < pModifyArg->count); iMod++ ) {
        // Translate choice to string.
        pszChoice = "???";
        for ( iChoice = 0; iChoice < cNumChoices; iChoice++ ) {
            if ( pMod->choice == rgChoices[ iChoice ].usChoice ) {
                pszChoice = rgChoices[ iChoice ].pszChoice;
                break;
            }
        }

        Printf("%s%s\n",
               Indent(nIndents+1),
               pszChoice);

        fSuccess = Dump_Attr_local(nIndents+2, &pMod->AttrInf, TRUE);

        if ( fSuccess && ( NULL != pMod->pNextMod ) )
        {
            pNextMod = ReadMemory(pMod->pNextMod, sizeof(ATTRMODLIST));
            if (!pNextMod) {
                fSuccess = FALSE;
            }
        }

        if ( iMod != 0 ) {
            FreeMemory(pMod);
        }

        pMod = pNextMod;
    }

    FreeMemory(pModifyArg);

    return TRUE;
}

BOOL
Dump_MODIFYDNARG(
    IN DWORD nIndents,
    IN PVOID pvProcess
    )
/*++

Routine Description:

    Public MODIFYDNARG dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of MODIFYDNARG in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    MODIFYDNARG *   pModDNArg;

    pModDNArg = ReadMemory(pvProcess, sizeof(MODIFYARG));
    if (!pModDNArg) {
        return FALSE;
    }

    Printf("%sMODIFYDNARG Object:\n",
           Indent(nIndents));

    Printf("%spObject             @ %p\n",
           Indent(nIndents), pModDNArg->pObject);
    if (NULL != pModDNArg->pObject)
    {
        fSuccess = Dump_DSNAME(nIndents+1,
                               pModDNArg->pObject);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sNew parent          @ %p\n",
           Indent(nIndents), pModDNArg->pNewParent);
    if (NULL != pModDNArg->pNewParent) {
        fSuccess = Dump_DSNAME(nIndents+1,
                               pModDNArg->pNewParent);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sNew RDN ATTR        @ %p\n",
           Indent(nIndents), pModDNArg->pNewRDN);
    if (NULL != pModDNArg->pNewRDN) {
        fSuccess = Dump_Attr(nIndents+1,
                             pModDNArg->pNewRDN);
        if (!fSuccess) {
            return FALSE;
        }
    }

    Printf("%sCommArg:\n",
           Indent(nIndents));
    Dump_CommArgLocal(nIndents+1,
                      &pModDNArg->CommArg);

    Printf("%spMetaDataVecRemote @ %p\n",
           Indent(nIndents), pModDNArg->pMetaDataVecRemote);

    Printf("%spDSAName           @ %p\n",
           Indent(nIndents), pModDNArg->pDSAName);

    Printf("%sResolved object    @ %p\n",
           Indent(nIndents), pModDNArg->pResObj);
    if (NULL != pModDNArg->pResObj) {
        Dump_RESOBJ(nIndents+1,
                    pModDNArg->pResObj);
    }

    Printf("%sResolved parent    @ %p\n",
           Indent(nIndents), pModDNArg->pResParent);
    if (NULL != pModDNArg->pResParent) {
        Dump_RESOBJ(nIndents+1,
                    pModDNArg->pResParent);
    }

    FreeMemory(pModDNArg);

    return TRUE;
}

typedef enum _DPRINTOP {
    eInvalid = 0,
    eHelp,
    eShow,
    eLevel,
    eAdd,
    eRemove,
    eThread
} DPRINTOP;

typedef struct _DPRINTCMD {
    char      * pszCmd;
    DPRINTOP    op;
} DPRINTCMD;



DPRINTCMD aDCmd[] = {
    {"help", eHelp},
    {"show", eShow},
    {"level", eLevel},
    {"add", eAdd},
    {"remove", eRemove},
    {"thread", eThread}
};

#define countDCmd (sizeof(aDCmd)/sizeof(DPRINTCMD))

DEBUG_EXT(dprint)
{
    CHAR    *pszCmd;
    DPRINTOP op;
    CHAR    *pszToken;
    CHAR    *pszDelimiters = " \t";
    DWORD   i;
    CHAR    *p, *s;
    BOOL    fGoodSyntax = FALSE;
    BOOL    fUpdate = FALSE;
    DEBUGARG *pProcess, *pLocal;
    CHAR    *pszModule = "ntdsa", szSymbol[30];
    DWORD   len;

    INIT_DEBUG_EXT;

    //
    // Derive command and value from command line.
    //

    // Check for alternate module specification
    pszCmd = strtok(gpszCommand, pszDelimiters);
    if ( NULL != (pszCmd) ) {
        if (strstr( pszCmd, "/m:" ) == pszCmd) {
            pszModule = pszCmd + 3;
            pszCmd = strtok(NULL, pszDelimiters);
        }
    }

    // First token in gpszCommand is the command
    if ( NULL != (pszCmd) ) {
        //
        // Second token is the (optional) argument
        //

        if ( NULL != (pszToken = strtok(NULL, pszDelimiters)) ) {
            //
            // Verify there is no third token.
            //

            if ( NULL == strtok(NULL, pszDelimiters) ) {
                fGoodSyntax = TRUE;
            }
            else {
                fGoodSyntax = FALSE;
            }
        }
        else {
            pszToken = NULL;
            fGoodSyntax = TRUE;
        }
    }

    if ( !fGoodSyntax )
    {
        Printf("Dump command parse error!\n");
        return;
    }

    op = eInvalid;
    for (i=0; i<countDCmd; i++) {
        if (0 == _stricmp(pszCmd, aDCmd[i].pszCmd)) {
            op = aDCmd[i].op;
            break;
        }
    }

    strcpy( szSymbol, pszModule );
    strcat( szSymbol, "!DebugInfo" );
    pProcess = (DEBUGARG*)GetExpr( szSymbol );
    if (pProcess == NULL) {
        Printf("Can't locate address of '%s' - sorry\n", szSymbol);
        return;
    }
    pLocal = (DEBUGARG*)ReadMemory(pProcess,
                                   sizeof(DEBUGARG));
    if (pLocal == NULL) {
        Printf("Can't read debug arg - sorry\n");
        return;
    }

    switch (op) {
      case eHelp:
        Printf("Possible dprint sub-commands include:\n");
        Printf("\t/m:<module>\tSpecify alternate dll symbol scope (default ntdsa)\n");
        Printf("\tadd subsys\tadds new subsystem to dprint list\n");
        Printf("\thelp\t\tshow this message\n");
        Printf("\tlevel newlevel\tset the print level to newlevel (0-5)\n");
        Printf("\tremove subsys\tremoves subsystem from dprint list\n");
        Printf("\tshow\t\tshow the current dprint settings\n");
        Printf("\tthread threadid\tset the thread id (0 = all threads)\n");
        break;

      case eShow:
        Printf("Current dprint state:\n");
        Printf("\tLevel is %d\n", pLocal->severity);
        Printf("\tThread id is %u (0x%x)\n",
               pLocal->threadId, pLocal->threadId);
        Printf("\tSubSystem list is '%s'\n", pLocal->DebSubSystems);
        break;

      case eLevel:
        if (pszToken) {
            i = atoi(pszToken);
            Printf("Setting DPRINT level to %d\n", i);
            pLocal->severity = i;
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify a new level\n");
        }
        break;

      case eAdd:
        if (pszToken) {
            if (pLocal->DebSubSystems[0] == '*') {
                pLocal->DebSubSystems[0] = ':';
            }
            strcat(pLocal->DebSubSystems, pszToken);
            strcat(pLocal->DebSubSystems, ":");
            Printf("Adding '%s' to list\n", pszToken);
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify something to add\n");
        }
        break;

      case eRemove:
        if (pszToken) {
            len = strlen(pszToken);
            p = alloca(len+3);
            p[0] = ':';
            strcpy(&p[1],pszToken);
            strcat(p,":");
            s = strstr(pLocal->DebSubSystems, p);
            if (s) {
                p = s + len + 1;
                while (*p) {
                    *s++ = *p++;
                }
                *s = '\0';
                if (pLocal->DebSubSystems[1] == '\0') {
                    pLocal->DebSubSystems[0] = '*';
                }
                fUpdate = TRUE;
                Printf("Removing '%s' from list\n", pszToken);
            }
            else {
                Printf("'%s' wasn't in list\n", pszToken);
            }
        }
        else {
            Printf("You've got to specify something to remove\n");
        }
        break;

      case eThread:
        if (pszToken) {
            i = atoi(pszToken);
            Printf("Setting thread id to %d (0x%x)\n", i, i);
            pLocal->threadId = i;
            fUpdate = TRUE;
        }
        else {
            Printf("You've got to specify a new thread id\n");
        }
        break;


      case eInvalid:
      default:
        Printf("Invalid command\n");
    }

    if (fUpdate) {
        fUpdate = WriteMemory(pProcess,
                              pLocal,
                              sizeof(DEBUGARG));
        if (fUpdate) {
            Printf("Updated!\n");
        }
        else {
            Printf("Failed to updated\n");
        }
    }

}

BOOL
Dump_EscrowInfoLocal(
        DWORD nIndents,
        IN ESCROWINFO *pInfo)

/*++

Routine Description:

    Worker routine to dump escrow info from already read memory.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of EscrowItem in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ESCROWITEM      *rItems = NULL;
    DWORD           cBytes = sizeof(ESCROWINFO);
    DWORD           i;

    Printf("%sESCROWINFO\n", Indent(nIndents));
    nIndents++;

    if ( NULL == pInfo )
        return(FALSE);

    Printf("%scItems      0x%x\n", Indent(nIndents), pInfo->cItems);
    Printf("%scItemsMax   0x%x\n", Indent(nIndents), pInfo->cItemsMax);

    nIndents++;

    if ( (0 != pInfo->cItems) && (NULL != pInfo->rItems) )
    {
        cBytes = pInfo->cItems * sizeof(ESCROWITEM);
        rItems = (ESCROWITEM *) ReadMemory(pInfo->rItems, cBytes);

        if ( NULL == rItems )
        {
            FreeMemory(pInfo);
            return(FALSE);
        }

        for ( i = 0; i < pInfo->cItems; i++ )
        {
            Printf("%sDNT(0x%x) - delta(0x%x)\n",
                   Indent(nIndents),
                   rItems[i].DNT,
                   rItems[i].delta);
        }

        FreeMemory(rItems);
    }

    return(TRUE);
}

BOOL
Dump_EscrowInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public EscrowItem dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of EscrowItem in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ESCROWINFO      *pInfo = NULL;
    DWORD           cBytes = sizeof(ESCROWINFO);

    pInfo = (ESCROWINFO *) ReadMemory(pvProcess, cBytes);

    Dump_EscrowInfoLocal(nIndents, pInfo);

    FreeMemory(pInfo);

    return(TRUE);
}

BOOL
Dump_ModifiedObjectInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ModifiedObjectInfo dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GroupCacheInfo in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    MODIFIED_OBJ_INFO   *pInfo2,*pInfo = NULL;
    DWORD               i, cBytes = sizeof(MODIFIED_OBJ_INFO);

    if (pvProcess == NULL) {
        Printf("%sno MODIFIED_OBJ_INFO present\n", Indent(nIndents));
        return TRUE;
    }

    Printf("%sMODIFIED_OBJ_INFO\n", Indent(nIndents));
    nIndents++;

    pInfo = (MODIFIED_OBJ_INFO *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pInfo )
        return(FALSE);


    Printf("%sNCDNT, cAncestors, pAncestors, fNotifyWaiters\n",Indent(nIndents));
    for(i=0;i<pInfo->cItems;i++) {
        Printf("%s%d, %d, %p, %d\n",
               Indent(nIndents),
               pInfo->Objects[i].ulNCDNT,
               pInfo->Objects[i].cAncestors,
               pInfo->Objects[i].pAncestors,
               pInfo->Objects[i].fNotifyWaiters
               );
    }

    while(pInfo->pNext) {
        pInfo2 = (MODIFIED_OBJ_INFO *) ReadMemory(pInfo->pNext, cBytes);
        FreeMemory(pInfo);
        pInfo=pInfo2;

        if ( NULL == pInfo ) {
            return(FALSE);
        }

        for(i=0;i<pInfo->cItems;i++) {
            Printf("%s%d, %d, %p, %d\n",
                   Indent(nIndents),
                   pInfo->Objects[i].ulNCDNT,
                   pInfo->Objects[i].cAncestors,
                   pInfo->Objects[i].pAncestors,
                   pInfo->Objects[i].fNotifyWaiters
                   );
        }
    }
    Printf("%s.\n", Indent(nIndents));

    FreeMemory(pInfo);

    return(TRUE);
}

BOOL
Dump_HierarchyTableInfo(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public HierarchyTableInfo dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of HierarchyTableInfo in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{

    HIERARCHYTABLEINFO *pInfo2,*pInfo = NULL;
    DWORD               i, cBytes = sizeof(HIERARCHYTABLEINFO);
    DWORD              *pConts;

    if (pvProcess == NULL) {
        Printf("%sno HierarchyTableInfo present\n", Indent(nIndents));
        return TRUE;
    }
    Printf("%sHierarchyTableInfo\n", Indent(nIndents));
    nIndents++;

    pInfo = (HIERARCHYTABLEINFO *) ReadMemory(pvProcess, cBytes);
    while(pInfo) {
        Printf("%sAdjust by %d:",Indent(nIndents),pInfo->adjustment);
        pConts = ReadMemory(pInfo->pABConts, pInfo->Count * sizeof(DWORD));
        if (!pConts) {
            FreeMemory(pInfo);
            return FALSE;
        }
        for(i=0;i<pInfo->Count;i++) {
            Printf("%d, ",pConts[i]);
        }
        Printf("\n");
        FreeMemory(pConts);
        pInfo2 = (HIERARCHYTABLEINFO *) ReadMemory(pInfo->Next, cBytes);
        FreeMemory(pInfo);
        pInfo = pInfo2;
    }

    return TRUE;
}

BOOL Dump_ObjCacheData(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public ObjCache data dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of OBJCACHE_DATA in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    OBJCACHE_DATA   *pOCD, *pOCDprocess;

    pOCDprocess = (OBJCACHE_DATA *)pvProcess;

    if (pOCDprocess == NULL) {
        Printf("%sno ObjCache data present\n", Indent(nIndents));
        return TRUE;
    }

    while (pOCDprocess) {
        pOCD = ReadMemory(pOCDprocess, sizeof(OBJCACHE_DATA));
        if (!pOCD) {
            Printf("%smemory read failure at %p\n",
                   Indent(nIndents),
                   pOCDprocess);
            return FALSE;
        }
        Printf("%sObjCache %s (%u) at %p\n",
               Indent(nIndents),
               ((pOCD->type == OBJCACHE_ADD) ? "Add" :
                ((pOCD->type == OBJCACHE_DEL) ? "Del" : "Error!")),
               pOCD->type,
               pOCDprocess);
        ++nIndents;
        Printf("%spCrossRefList     @%p\n", Indent(nIndents), pOCD->pCRL);
        Printf("%spMtxAddress       @%p\n", Indent(nIndents), pOCD->pMTX);
        Printf("%spRootDnsAddress   @%p\n", Indent(nIndents), pOCD->pRootDNS);
        Printf("%spDN (object)      @%p\n", Indent(nIndents), pOCD->pDN);
        --nIndents;

        pOCDprocess = pOCD->pNext;
        FreeMemory(pOCD);
    }
    return TRUE;
}

BOOL
Dump_CatalogUpdates(
    IN DWORD nIndents,
    IN CATALOG_UPDATES *pCatUpdates)
/*++

Routine Description:

    Public CatalogUpdates dump routine.

Arguments:

    nIndents - Indentation level desired.

    pCatUpdates - address of CatalogUpdates in local address space

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PVOID *pDeleted;
    PVOID pNextNC;
    DWORD i;

    if (pCatUpdates->pAddedEntries != NULL) {
        Dump_NAMING_CONTEXT_LIST(nIndents, "Added NCs:", pCatUpdates->pAddedEntries);
    }
    else {
        Printf("%sAdded NCs: (none)\n", Indent(nIndents));
    }

    if (pCatUpdates->dwDelCount > 0) {
        Printf("%sDeleted NCs:\n", Indent(nIndents));
        pDeleted = (PVOID*)ReadMemory(pCatUpdates->pDeletedEntries, pCatUpdates->dwDelCount*sizeof(PVOID));
        if (pDeleted == NULL) {
            return FALSE;
        }
        for (i = 0; i < pCatUpdates->dwDelCount; i++) {
            if (!Dump_NC_Entry(nIndents+1, pDeleted[i], &pNextNC)) {
                return FALSE;
            }
        }

        FreeMemory(pDeleted);
    }
    else {
        Printf("%sDeleted NCs: (none)\n", Indent(nIndents));
    }
    return TRUE;
}




BOOL
Dump_TransactionalData(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public TransactionalData dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of TransactionalData in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    NESTED_TRANSACTIONAL_DATA      *pInfo = NULL;
    DWORD           cBytes = sizeof(NESTED_TRANSACTIONAL_DATA);

    Printf("%sTRANSACTIONAL_DATA\n", Indent(nIndents));
    nIndents++;

    pInfo = (NESTED_TRANSACTIONAL_DATA *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pInfo )
        return(FALSE);

    Dump_EscrowInfoLocal(nIndents, &(pInfo->escrowInfo));

    // Now, the modified object info
    Dump_ModifiedObjectInfo(nIndents, pInfo->pModifiedObjects);
    Dump_HierarchyTableInfo(nIndents, pInfo->pHierarchyTableInfo);

    if (pInfo->objCachingInfo.fRecalcMapiHierarchy) {
        Printf("%sRequires Recalc of MAPI Hierarchy\n", Indent(nIndents));
    }
    if (pInfo->objCachingInfo.fSignalSCache) {
        Printf("%sWill signal Schema Cache rebuild\n", Indent(nIndents));
    }

    Dump_ObjCacheData(nIndents, pInfo->objCachingInfo.pData);

    Printf("%spMasterNC updates:\n", Indent(nIndents));
    Dump_CatalogUpdates(nIndents + 1, &pInfo->objCachingInfo.masterNCUpdates);

    Printf("%spReplicaNC updates:\n", Indent(nIndents));
    Dump_CatalogUpdates(nIndents + 1, &pInfo->objCachingInfo.replicaNCUpdates);

    if ( NULL != pInfo->pOuter )
        Dump_TransactionalData(nIndents + 1, pInfo->pOuter);

    FreeMemory(pInfo);

    return(TRUE);
}


BOOL
Dump_d_tagname(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public d_tagname dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of d_tagname in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    d_tagname * ptagname;
    WCHAR *     pRDN = NULL;

    Printf("%sd_tagname @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    ptagname = (d_tagname *) ReadMemory(pvProcess, sizeof(d_tagname));

    if (NULL == ptagname) {
        return FALSE;
    }

    if (NULL != ptagname->pRdn) {
        pRDN = (WCHAR *) ReadMemory(ptagname->pRdn, ptagname->cbRdn);
        if (NULL == pRDN) {
            FreeMemory(ptagname);
            return FALSE;
        }
    }

    Printf("%sPDNT = 0x%x, RDN Type = 0x%x, cbRDN = %d, RDN (@ %p) = \"%*.*ls\"\n",
           Indent(nIndents), ptagname->PDNT, ptagname->rdnType, ptagname->cbRdn,
           ptagname->pRdn,
           ptagname->cbRdn / sizeof(WCHAR), ptagname->cbRdn / sizeof(WCHAR),
           pRDN);

    if (NULL != pRDN) {
        FreeMemory(pRDN);
    }

    FreeMemory(ptagname);

    return TRUE;
}

BOOL
Dump_d_memname(
    IN DWORD nIndents,
    IN PVOID pvProcess)
/*++

Routine Description:

    Public d_memname dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of d_memname in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    d_memname * pmemname;
    BOOL        fSuccess = TRUE;
    DWORD *     pAncestors;

    Printf("%sd_memname @ %p\n", Indent(nIndents), pvProcess);
    nIndents++;

    pmemname = (d_memname *) ReadMemory(pvProcess, sizeof(d_memname));

    if (NULL == pmemname) {
        return FALSE;
    }

    Printf("%sDNT       = 0x%x\n", Indent(nIndents), pmemname->DNT);
    Printf("%sNCDNT     = 0x%x\n", Indent(nIndents), pmemname->NCDNT);

    if (!Dump_d_tagname(nIndents,
                        (BYTE *) pvProcess + offsetof(d_memname, tag))) {
        fSuccess = FALSE;
    }

    Printf("%sGuid      = %s\n",
           Indent(nIndents), DraUuidToStr(&pmemname->Guid, NULL));

    if (pmemname->SidLen) {
        WCHAR SidText[128];
        UNICODE_STRING us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, &pmemname->Sid, FALSE);
        Printf("%sSID       = %ls\n", Indent(nIndents), SidText);
    }
    else {
        Printf("%sSID       = (none)\n", Indent(nIndents));
    }

    Printf("%sobjflag   = 0x%x (%s)\n", Indent(nIndents), pmemname->objflag,
           pmemname->objflag ? "is an object" : "is a phantom");

    Printf("%sancestors = %d @ %p\n", Indent(nIndents), pmemname->cAncestors,
           pmemname->pAncestors);

    if (pmemname->pAncestors) {
        pAncestors = (DWORD *) ReadMemory(pmemname->pAncestors,
                                          pmemname->cAncestors
                                          * sizeof(pmemname->pAncestors[0]));
        if (NULL == pAncestors) {
            fSuccess = FALSE;
        }
        else {
            DWORD i;

            Printf("%s(", Indent(nIndents+1));

            for (i=0; i < pmemname->cAncestors; i++) {
                Printf(" 0x%x", pAncestors[i]);
            }

            Printf(")\n");

            FreeMemory(pAncestors);
        }
    }

    FreeMemory(pmemname);

    return fSuccess;
}

BOOL
Dump_ProxyVal(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps a proxy value.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of proxy value in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    SYNTAX_DISTNAME_BINARY  *pVal = NULL;
    DWORD                   cBytes;
    DWORD                   type;
    DWORD                   epoch;

    Printf("%sProxy Value\n", Indent(nIndents));
    nIndents++;

    // Know that a SYNTAX_DISTNAME_BINARY always starts with a DSNAME,
    // so go for the minimal DSNAME first.

    cBytes = sizeof(DSNAME);
    pVal = (SYNTAX_DISTNAME_BINARY *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pVal )
        return(FALSE);

    // Now get the full size.
    cBytes = PADDEDNAMESIZE(&pVal->Name) + PROXY_BLOB_SIZE;
    FreeMemory(pVal);
    pVal = (SYNTAX_DISTNAME_BINARY *) ReadMemory(pvProcess, cBytes);

    if ( NULL == pVal )
        return(FALSE);

    // Dump it.
    type = ntohl(* PROXY_DWORD_ADDR(pVal, PROXY_TYPE_OFFSET));
    epoch = ntohl(* PROXY_DWORD_ADDR(pVal, PROXY_EPOCH_OFFSET));
    Printf("%sProxy type:   0x%x (%s)\n",
           Indent(nIndents),
           type,
           ((PROXY_TYPE_MOVED_OBJECT == type)
                ? "PROXY_TYPE_MOVED_OBJECT"
                : ((PROXY_TYPE_PROXY == type)
                      ? "PROXY_TYPE_PROXY"
                      : "PROXY_TYPE_UNKOWN")) );
    Printf("%sProxy epoch: 0x%x\n",
           Indent(nIndents),
           epoch);
    Dump_DSNAME(nIndents, pvProcess);

    FreeMemory(pVal);
    return(TRUE);
}

int __cdecl CompareGuidCache(const void * pv1, const void * pv2)
{
    return memcmp ( &((GuidCache *)pv1)->guid, &((GuidCache *)pv2)->guid, sizeof (GUID));
}

void
LookupGuid(
    GUID    *pg,            // IN
    CHAR    **ppName,       // OUT
    CHAR    **ppLabel,      // OUT
    BOOL    *pfIsClass      // OUT
    )
{
    static CHAR         name[1024];
    static CHAR         label[1024];
    GuidCache           *pGuidCache;
    GuidCache           Key;
    CHAR                *p = NULL;

    *pfIsClass = FALSE;
    *ppName = name;
    *ppLabel = label;

    Key.guid = *pg;

    if (pGuidCache = (GuidCache *)bsearch(&Key,
                                          guidCache,
                                          NUM_KNOWN_GUIDS-1,
                                          sizeof(GuidCache),
                                          CompareGuidCache)) {

        p = pGuidCache->name;
    }

    if (p) {
        strcpy (label, p);
    }
    else {
        strcpy(label, "???");
    }

    sprintf(name,
            "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
            pg->Data1,
            pg->Data2,
            pg->Data3,
            pg->Data4[0],
            pg->Data4[1],
            pg->Data4[2],
            pg->Data4[3],
            pg->Data4[4],
            pg->Data4[5],
            pg->Data4[6],
            pg->Data4[7]);
}

BOOL DumpAclHelper (PACL pAcl)
{
    ACE_HEADER *pAce, *ReadAce;
    PSID SidStart = NULL;
    PVOID AcePtr;
    DWORD i;
    DWORD aceSize;
    PACL ReadAcl;
    PSID pSid = NULL;


    ReadAcl = (PACL)ReadMemory(pAcl, sizeof( ACL ));
    if ( NULL == ReadAcl )
        return(FALSE);
    DumpAclHeader (ReadAcl, (AclPrintFunc)Printf);

    AcePtr = ( PUCHAR )pAcl + sizeof( ACL );
    for ( i = 0; i < ReadAcl->AceCount; i++ ) {

        Printf("\tAce[%d]\n", i);
        // First, we need to read the Size/Type of the ace
        ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( ACE_HEADER ));
        if ( NULL == ReadAce )
            return(FALSE);

        aceSize = ReadAce->AceSize;

        switch ( ReadAce->AceType ) {
        case ACCESS_ALLOWED_ACE_TYPE:
        case ACCESS_DENIED_ACE_TYPE:
        case SYSTEM_AUDIT_ACE_TYPE:
        case SYSTEM_ALARM_ACE_TYPE:
            FreeMemory(ReadAce);

            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_ACE ) - sizeof( ULONG ) );
            pSid = (PSID)ReadMemory(SidStart, sizeof( SID ));
            if ( NULL == pSid )
                return(FALSE);

            ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( KNOWN_ACE )
                                                + RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ) );
            if ( NULL == ReadAce )
                return(FALSE);

            DumpAce (ReadAce, (AclPrintFunc)Printf, LookupGuid, NULL);
            FreeMemory(pSid);

            break;

        case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
        case ACCESS_DENIED_OBJECT_ACE_TYPE:
        case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
        case SYSTEM_ALARM_OBJECT_ACE_TYPE:
            FreeMemory(ReadAce);

            SidStart = ( PSID )( ( PUCHAR )AcePtr + sizeof( KNOWN_OBJECT_ACE ) - sizeof( ULONG ) );

            pSid = (PSID)ReadMemory(SidStart, sizeof( SID ));
            if ( NULL == pSid )
                return(FALSE);


            ReadAce = (ACE_HEADER *)ReadMemory( AcePtr, sizeof( KNOWN_OBJECT_ACE ) + 2 * sizeof( GUID ) + RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
            if ( NULL == ReadAce )
                return(FALSE);


            DumpAce (ReadAce, (AclPrintFunc)Printf, LookupGuid, NULL);
            FreeMemory(pSid);
            break;

        case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        default:
            Printf( "Unsupported AceType %lu encountered... skipping\n", ReadAce->AceType );
            break;
        }
        FreeMemory(ReadAce);

        AcePtr = ( PUCHAR )AcePtr + aceSize;
    }

    return TRUE;
}


BOOL
Dump_SD(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps a Security Descriptor

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SD value in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    #define CONTROL_OFFSET ((ULONGLONG)(&( ((SECURITY_DESCRIPTOR *) NULL)->Control )))
    SECURITY_DESCRIPTOR *pSD = NULL;
    SECURITY_DESCRIPTOR_RELATIVE *pSDRelative = NULL;
    SECURITY_DESCRIPTOR_CONTROL *pSDControl;
    PSID pOwner = NULL, pGroup = NULL;
    PACL pDacl = NULL, pSacl = NULL;
    PSID pSid = NULL;
    PSID ReadSid;

    //
    // Just get the Control element of the struct so that we know
    // how big the SD is since on 64bit archs self relative SD's are
    // a different size than absolute SD's.
    //
    pSDControl = (SECURITY_DESCRIPTOR_CONTROL *) ReadMemory(((PUCHAR)pvProcess) + CONTROL_OFFSET,
                                                  sizeof(SECURITY_DESCRIPTOR_CONTROL));

    if ( NULL == pSDControl )
        return(FALSE);


    if (  ( *pSDControl & SE_SELF_RELATIVE ) == SE_SELF_RELATIVE ) {
        pSDRelative = (SECURITY_DESCRIPTOR_RELATIVE *) ReadMemory(pvProcess,
                                                                  sizeof(SECURITY_DESCRIPTOR_RELATIVE));
        FreeMemory(pSDControl);
        if ( NULL == pSDRelative ) {
            return(FALSE);
        }

        DumpSDHeader ((SECURITY_DESCRIPTOR *)pSDRelative, (AclPrintFunc)Printf);

        if ( pSDRelative->Owner != 0 ) {

            pOwner = ( PSID )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Owner );
        }

        if ( pSDRelative->Group != 0 ) {

            pGroup = ( PSID )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Group );
        }

        if ( pSDRelative->Dacl != 0 ) {

            pDacl = ( PACL )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Dacl );
        }

        if ( pSDRelative->Sacl != 0 ) {

            pSacl = ( PACL )( ( PUCHAR )pvProcess + ( ULONG_PTR )pSDRelative->Sacl );
        }

    } else {
        pSD = (SECURITY_DESCRIPTOR *) ReadMemory(pvProcess,
                                                sizeof(SECURITY_DESCRIPTOR));
        FreeMemory(pSDControl);
        if ( NULL == pSD ) {
            return(FALSE);
        }

        DumpSDHeader (pSD, (AclPrintFunc)Printf);

        pOwner = pSD->Owner;
        pGroup = pSD->Group;
        pDacl = pSD->Dacl;
        pSacl = pSD->Sacl;
    }


    // read the owner
    if (pOwner) {
        Printf("Owner:");
        pSid = (PSID)ReadMemory(pOwner, sizeof( SID ));
        if ( NULL == pSid )
            return(FALSE);

        ReadSid = (PSID)ReadMemory(pOwner, RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
        if ( NULL == ReadSid )
            return(FALSE);

        DumpSID (ReadSid, (AclPrintFunc)Printf);
        FreeMemory(pSid);
        FreeMemory(ReadSid);
        Printf("\n");
    }


    // read the group
    if (pGroup) {
        Printf("Group:");
        pSid = (PSID)ReadMemory(pGroup, sizeof( SID ));
        if ( NULL == pSid )
            return(FALSE);

        ReadSid = (PSID)ReadMemory(pGroup, RtlLengthRequiredSid( ((SID *)pSid)->SubAuthorityCount ));
        if ( NULL == ReadSid )
            return(FALSE);

        DumpSID (ReadSid, (AclPrintFunc)Printf);
        FreeMemory(pSid);
        FreeMemory(ReadSid);
        Printf("\n");
    }


    // read the DACL
    if (pDacl) {
        Printf("DACL:\n");

        if (!DumpAclHelper (pDacl)) {
             return FALSE;
        }
    }


    // read the SACL
    if (pSacl) {
        Printf("SACL:\n");

        if (!DumpAclHelper (pSacl)) {
             return FALSE;
        }
    }

    if (pSD) {
        FreeMemory(pSD);
    }
    if (pSDRelative) {
        FreeMemory(pSDRelative);
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\scache.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    md.c

Abstract:

    Dump functions for types used by dsamain\src\scache.c.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    28-Feb-97   DaveStr     Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include "objids.h"
#include "drs.h"
#include "scache.h"
#include <ntdsa.h>
#include "mdglobal.h"             // for REPLICA_LINK
#include "drasch.h"               // uses REPLICA_LINK

#define MAX_INDEX_NAME 128        // we can also #include "..dsmain/dblayer/dbintrnl.h"

BOOL
Dump_ArrayOfUlong(
    IN DWORD nIndents,
    IN DWORD count,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps an array of ULONG in pretty print format - 4 to a line.

Arguments:

    nIndents - Indentation level desired.

    count - number of elements in array.

    pvProcess - address of ULONG[] in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG   *rul;
    DWORD   i;

    rul = ReadMemory(pvProcess, count * sizeof(ULONG));

    if ( NULL == rul )
        return(FALSE);

    for ( i = 0; i < count; i++ )
    {
        if ( 0 == (i % 4) )
            Printf("%s", Indent(nIndents));

        Printf("%08x    ", rul[i]);

        if ( (0 == ((i+1) % 4)) || ((i+1) == count) )
            Printf("\n");
    }

    FreeMemory(rul);

    return(TRUE);
}

int __cdecl
sortaux(
    const void * pv1,
    const void * pv2)
{
    // Function to compare two HASHCACHESTRING values.

    HASHCACHESTRING *pHCS1 = (HASHCACHESTRING *) pv1;
    HASHCACHESTRING *pHCS2 = (HASHCACHESTRING *) pv2;
    UCHAR           *value1 = NULL;
    UCHAR           *value2 = NULL;
    int             retVal = 0;

    if ( NULL == pHCS1->value )
        return(-1);

    if ( NULL == pHCS2->value )
        return(1);

    value1 = ReadMemory(
                pHCS1->value,
                sizeof(UCHAR) * (1 + pHCS1->length));

    if ( NULL != value1 )
    {
        value1[pHCS1->length] = '\0';

        value2 = ReadMemory(
                    pHCS2->value,
                    sizeof(UCHAR) * (1 + pHCS2->length));

        if ( NULL != value2 )
        {
            value2[pHCS2->length] = '\0';

            retVal = _stricmp(value1, value2);
        }
    }

    FreeMemory(value1);
    FreeMemory(value2);

    return(retVal);
}

BOOL
Dump_SCHEMAPTR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public SCHEMAPTR dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMAPTR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG               i, j, cBytes;
    BYTE                *addr;
    SCHEMAPTR           *pSchema = NULL;
    HASHCACHESTRING     *pHCS;
    PrefixTableEntry    *pPTE;
    UCHAR               *value;
    ATTRTYP             *pid;
    BYTE                *pb;
    PVOID               pPFX;
    UCHAR               temp[512];

    do
    {
        pSchema = (SCHEMAPTR *) ReadMemory(pvProcess, sizeof(SCHEMAPTR));

        if ( NULL == pSchema )
            break;

        Printf("%sSCHEMAPTR:\n", Indent(nIndents));
        nIndents++;

        Printf("%sATTCOUNT            0x%x\n",
               Indent(nIndents),
               pSchema->ATTCOUNT);

        Printf("%sCLSCOUNT            0x%x\n",
               Indent(nIndents),
               pSchema->CLSCOUNT);

        Printf("%sPREFIXCOUNT         0x%x\n",
               Indent(nIndents),
               pSchema->PREFIXCOUNT);

        Printf("%snAttInDB            0x%x\n",
               Indent(nIndents),
               pSchema->nAttInDB);

        Printf("%snClsInDB            0x%x\n",
               Indent(nIndents),
               pSchema->nClsInDB);

        Printf("%sPrefixCount         0x%x\n",
               Indent(nIndents),
               pSchema->PrefixTable.PrefixCount);

        Printf("%sahcId             @ %p\n",
               Indent(nIndents),
               pSchema->ahcId);

        Printf("%sahcCol            @ %p\n",
               Indent(nIndents),
               pSchema->ahcCol);

        Printf("%sahcMapi           @ %p\n",
               Indent(nIndents),
               pSchema->ahcMapi);

        Printf("%sahcLink           @ %p\n",
               Indent(nIndents),
               pSchema->ahcLink);

        Printf("%sahcName           @ %p\n",
               Indent(nIndents),
               pSchema->ahcName);

        Printf("%sahcClass          @ %p\n",
               Indent(nIndents),
               pSchema->ahcClass);

        Printf("%sahcClassName      @ %p\n",
               Indent(nIndents),
               pSchema->ahcClassName);

        Printf("%sahcClassAll       @ %p\n",
               Indent(nIndents),
               pSchema->ahcClassAll);

        Printf("%spPrefixEntry      @ %p\n",
               Indent(nIndents),
               pSchema->PrefixTable.pPrefixEntry);

        Printf("%ssysTime             0x%x\n",
               Indent(nIndents),
               pSchema->sysTime);

        Printf("%spPartialAttrVec     @ %p\n",
               Indent(nIndents),
               pSchema->pPartialAttrVec);

        Printf("%sSchemaInfo         ",
               Indent(nIndents));
        pb = (UCHAR *) &(pSchema->SchemaInfo);
        for ( i = 0; i < SCHEMA_INFO_LENGTH; pb++, i++ )
            Printf("%02x", *pb);
        Printf("\n");        
    
        Printf("%sEntryTTLId          0x%x\n",
               Indent(nIndents),
               pSchema->EntryTTLId);
    
        Printf("%sDynamicObjectId     0x%x\n",
               Indent(nIndents),
               pSchema->DynamicObjectId);
    
        Printf("%sForestBehaviorVersion 0x%x\n",
               Indent(nIndents),
               pSchema->ForestBehaviorVersion);
    
        // Now print out the prefix table

        Dump_SCHEMA_PREFIX_TABLE(nIndents+1, ((BYTE *) pvProcess) + OFFSET(SCHEMAPTR, PrefixTable));

        // Now be nice and dump all the class names and pointers.

        Printf("\n%s*** Classes ***\n", Indent(nIndents));
        nIndents++;

        cBytes = pSchema->CLSCOUNT * sizeof(HASHCACHESTRING);
        pHCS = (HASHCACHESTRING *) ReadMemory(pSchema->ahcClassName, cBytes);
        if ( NULL == pHCS )
            break;

        qsort(pHCS, pSchema->CLSCOUNT, sizeof(HASHCACHESTRING), sortaux);

        for ( i = 0; i < pSchema->CLSCOUNT; i++ )
        {
            if ( NULL != pHCS[i].value )
            {
                value = ReadMemory(pHCS[i].value,
                                   sizeof(UCHAR) * (1 + pHCS[i].length));

                if ( NULL != value )
                {
                    value[pHCS[i].length] = '\0';

                    addr = ((BYTE *) pHCS[i].pVal) + OFFSET(CLASSCACHE, ClassId),
                    pid = ReadMemory(addr, sizeof(ULONG));

                    if ( NULL != pid )
                    {
                        Printf("%s%s(%08x) @ %p\n",
                               Indent(nIndents),
                               value,
                               *pid,
                               pHCS[i].pVal);

                        FreeMemory(pid);
                    }

                    FreeMemory(value);
                }
            }
        }

        FreeMemory(pHCS);
        nIndents--;

        // Now be nice and dump all the attr names and pointers.
        Printf("\n%s*** Attributes ***\n", Indent(nIndents));
        nIndents++;

        cBytes = pSchema->ATTCOUNT * sizeof(HASHCACHESTRING);
        pHCS = (HASHCACHESTRING *) ReadMemory(pSchema->ahcName, cBytes);
        if ( NULL == pHCS )
            break;

        qsort(pHCS, pSchema->ATTCOUNT, sizeof(HASHCACHESTRING), sortaux);

        for ( i = 0; i < pSchema->ATTCOUNT; i++ )
        {
            if ( NULL != pHCS[i].value )
            {
                value = ReadMemory(pHCS[i].value,
                                   sizeof(UCHAR) * (1 + pHCS[i].length));

                if ( NULL != value )
                {
                    value[pHCS[i].length] = '\0';

                    addr = ((BYTE *) pHCS[i].pVal) + OFFSET(ATTCACHE, id),
                    pid = ReadMemory(addr, sizeof(ULONG));

                    if ( NULL != pid )
                    {
                        Printf("%s%s(%08x) @ %p\n",
                               Indent(nIndents),
                               value,
                               *pid,
                               pHCS[i].pVal);

                        FreeMemory(pid);
                    }

                    FreeMemory(value);
                }
            }
        }

        FreeMemory(pHCS);
        nIndents--;

    }
    while ( FALSE );

    FreeMemory(pSchema);

    return(TRUE);
}

BOOL
Dump_SCHEMA_PREFIX_TABLE(
    IN DWORD nIndents,
    IN     IN PVOID pvProcess)
/*++

Routine Description:

    Public SCHEMA_PREFIX_TABLE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of SCHEMA_PREFIX_TABLE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    SCHEMA_PREFIX_TABLE *pPrefixTbl;
    PrefixTableEntry    *pPTE;
    DWORD               cBytes, i, j;
    BYTE                *pb;
    PVOID               pPFX;
    UCHAR               temp[512];

    Printf("\n%s*** Prefixes ***\n", Indent(nIndents));
    nIndents++;

    pPrefixTbl = (SCHEMA_PREFIX_TABLE *) ReadMemory(pvProcess, sizeof(SCHEMA_PREFIX_TABLE));

    if ( NULL == pPrefixTbl ) return FALSE;

    cBytes = (pPrefixTbl->PrefixCount) * sizeof(PrefixTableEntry);
    pPTE = (PrefixTableEntry *) ReadMemory(pPrefixTbl->pPrefixEntry, cBytes);
    if ( NULL == pPTE )
        return FALSE;

    for ( i = 0; i < pPrefixTbl->PrefixCount; i++ )
    {
      pPFX = pPTE[i].prefix.elements;
      if (pPFX != NULL) {
          pb = (LPBYTE) ReadMemory(pPTE[i].prefix.elements, pPTE[i].prefix.length);
          if (NULL == pb) {
              FreeMemory(pPrefixTbl);
              FreeMemory(pPTE);
              return FALSE;
          }
          for ( j = 0; j < pPTE[i].prefix.length; j++ )
          {
             sprintf( &temp[ j * 2 ], "%.2x", *(pb++) );
          }
          temp[2*pPTE[i].prefix.length]='\0';
          Printf("%2d. Ndx=%-4d Length=%-3d Prefix=%s\n",i,pPTE[i].ndx, pPTE[i].prefix.length, temp);
      }
    }

   FreeMemory(pb);
   FreeMemory(pPrefixTbl);
   FreeMemory(pPTE);
   return TRUE;

}


BOOL
Dump_CLASSCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public CLASSCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of CLASSCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG           i, cBytes;
    UCHAR           *pG;
    CLASSCACHE      *pCC = NULL;
    UCHAR           *name = NULL;
    ULONG           *pSubClassOf = NULL;
    UCHAR           *propPage = NULL;
    CHAR            *pStrSD;

    do
    {
        cBytes = sizeof(CLASSCACHE);
        pCC = ReadMemory(pvProcess, cBytes);
        if ( NULL == pCC )
            break;

        cBytes = sizeof(UCHAR) * (1 + pCC->nameLen);
        name = ReadMemory(pCC->name, cBytes);
        if ( NULL == name )
            break;
        name[pCC->nameLen] = '\0';

        Printf("%sCLASSCACHE(%s)\n",
               Indent(nIndents),
               name);
        nIndents++;

        Printf("%sClassId               0x%x\n",
               Indent(nIndents),
               pCC->ClassId);

        Printf("%spSD[SDLen]          @ %p[0x%x]\n",
               Indent(nIndents),
               pCC->pSD,
               pCC->SDLen);

        if(pCC->pStrSD){
            pStrSD = ReadMemory(pCC->pStrSD, pCC->cbStrSD);
            if(pStrSD){
                Printf("%spStrSD                %ls\n",
                       Indent(nIndents),
                       pStrSD);
                FreeMemory(pStrSD);
            } else {
                Printf("%sCouldn't read the pStrSD\n", Indent(nIndents));
            }
        } else {
            Printf("%spStrSD                (Not Cached yet)\n");
        }

        Printf("%sRDNAttIdPresent       0x%x\n",
               Indent(nIndents),
               pCC->RDNAttIdPresent);

        Printf("%sRdnExtId              0x%x\n",
               Indent(nIndents),
               pCC->RdnExtId);

        Printf("%sRdnIntId              0x%x\n",
               Indent(nIndents),
               pCC->RdnIntId);

        Printf("%sClassCategory         0x%x\n",
               Indent(nIndents),
               pCC->ClassCategory);

        Printf("%spDefaultObjectCategory   @ %p\n",
               Indent(nIndents),
               pCC->pDefaultObjCategory);

        Printf("%sSystemOnly            0x%x\n",
               Indent(nIndents),
               pCC->bSystemOnly);

        Printf("%sClosed                0x%x\n",
               Indent(nIndents),
               pCC->bClosed);

        Printf("%sbClosureInProgress    0x%x\n",
               Indent(nIndents),
               pCC->bClosureInProgress);

        Printf("%sbUsesMultInherit      0x%x\n",
               Indent(nIndents),
               pCC->bUsesMultInherit);

        Printf("%sbHideFromAB           0x%x\n",
               Indent(nIndents),
               pCC->bHideFromAB);

        Printf("%sbDefunct              0x%x\n",
               Indent(nIndents),
               pCC->bDefunct);

        Printf("%sbIsBaseScheObj        0x%x\n",
               Indent(nIndents),
               pCC->bIsBaseSchObj);

        Printf("%sbDupLDN               0x%x\n",
               Indent(nIndents),
               pCC->bDupLDN);

        Printf("%sbDupOID               0x%x\n",
               Indent(nIndents),
               pCC->bDupOID);

        Printf("%sbDupPropGuid          0x%x\n",
               Indent(nIndents),
               pCC->bDupPropGuid);

        Printf("%spropGuid              ",
               Indent(nIndents));
        pG = (UCHAR *) &(pCC->propGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%sMySubClass            0x%x\n",
               Indent(nIndents),
               pCC->MySubClass);

        if ( 0 == pCC->SubClassCount )
        {
            Printf("%sSubClasses[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sSubClasses[0x%x]\n",
                   Indent(nIndents),
                   pCC->SubClassCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->SubClassCount,
                              pCC->pSubClassOf);
        }

        if ( 0 == pCC->AuxClassCount )
        {
            Printf("%sAuxClasses[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sAuxClasses[0x%x]\n",
                   Indent(nIndents),
                   pCC->AuxClassCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->AuxClassCount,
                              pCC->pAuxClass);
        }

        if ( 0 == pCC->PossSupCount )
        {
            Printf("%sPossSup[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sPossSup[0x%x]\n",
                   Indent(nIndents),
                   pCC->PossSupCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->PossSupCount,
                              pCC->pPossSup);
        }

        if ( 0 == pCC->MyPossSupCount )
        {
            Printf("%sMyPossSup[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyPossSup[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyPossSupCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyPossSupCount,
                              pCC->pMyPossSup);
        }

        if ( 0 == pCC->MustCount )
        {
            Printf("%sMustAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMustAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MustCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MustCount,
                              pCC->pMustAtts);
        }

        if ( 0 == pCC->MyMustCount )
        {
            Printf("%sMyMustAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyMustAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyMustCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyMustCount,
                              pCC->pMyMustAtts);
        }

        if ( 0 == pCC->MayCount )
        {
            Printf("%sMayAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMayAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MayCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MayCount,
                              pCC->pMayAtts);
        }

        if ( 0 == pCC->MyMayCount )
        {
            Printf("%sMyMayAtts[0]\n",
                   Indent(nIndents));
        }
        else
        {
            Printf("%sMyMayAtts[0x%x]\n",
                   Indent(nIndents),
                   pCC->MyMayCount);

            Dump_ArrayOfUlong(nIndents + 1,
                              pCC->MyMayCount,
                              pCC->pMyMayAtts);
        }

        Printf("%sobjectGuid            ",
               Indent(nIndents));
        pG = (UCHAR *) &(pCC->objectGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");
    }
    while ( FALSE );

    FreeMemory(propPage);
    FreeMemory(pSubClassOf);
    FreeMemory(name);
    FreeMemory(pCC);

    return TRUE;
}

BOOL
Dump_ATTCACHE(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public ATTCACHE dump routine.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of ATTCACHE in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    ULONG           i, cBytes;
    UCHAR           *pG;
    ATTCACHE        *pAC = NULL;
    UCHAR           *name = NULL;
    char            *pszPdntIndex = NULL;
    char            *pszIndex = NULL;

    do
    {
        cBytes = sizeof(ATTCACHE);
        pAC = ReadMemory(pvProcess, cBytes);
        if ( NULL == pAC )
            break;

        cBytes = sizeof(UCHAR) * (1 + pAC->nameLen);
        name = ReadMemory(pAC->name, cBytes);
        if ( NULL == name )
            break;
        name[pAC->nameLen] = '\0';

        Printf("%sATTCACHE(%s)\n",
               Indent(nIndents),
               name);
        nIndents++;

        Printf("%sATTRTYP               0x%x\n",
               Indent(nIndents),
               pAC->id);

        Printf("%sExtATTRTYP            0x%x\n",
               Indent(nIndents),
               pAC->Extid);

        Printf("%ssyntax                0x%x\n",
               Indent(nIndents),
               pAC->syntax);

        Printf("%sisSingleValued        0x%x\n",
               Indent(nIndents),
               pAC->isSingleValued);

        if ( pAC->rangeLowerPresent )
        {
            Printf("%srangeLower            0x%x\n",
                   Indent(nIndents),
                   pAC->rangeLower);
        }

        if ( pAC->rangeUpperPresent )
        {
            Printf("%srangeUpper            0x%x\n",
                   Indent(nIndents),
                   pAC->rangeUpper);
        }

        Printf("%sjColid                0x%x\n",
               Indent(nIndents),
               pAC->jColid);

        Printf("%sulMapiID              0x%x\n",
               Indent(nIndents),
               pAC->ulMapiID);

        Printf("%sulLinkID              0x%x\n",
               Indent(nIndents),
               pAC->ulLinkID);

        Printf("%spropGuid              ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->propGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%spropSetGuid           ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->propSetGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");

        Printf("%sfSearchFlags          0x%x\n",
               Indent(nIndents),
               pAC->fSearchFlags);

        Printf("%sbSystemOnly           0x%x\n",
               Indent(nIndents),
               pAC->bSystemOnly);

        Printf("%sbExtendedChars        0x%x\n",
               Indent(nIndents),
               pAC->bExtendedChars);

        Printf("%sbMemberOfPartialSet   0x%x\n",
               Indent(nIndents),
               pAC->bMemberOfPartialSet);

        Printf("%sbDefunct              0x%x\n",
               Indent(nIndents),
               pAC->bDefunct);

        Printf("%sbIsBaseSchObj         0x%x\n",
               Indent(nIndents),
               pAC->bIsBaseSchObj);

        Printf("%sbIsConstructed        0x%x\n",
               Indent(nIndents),
               pAC->bIsConstructed);

        Printf("%sbIsNotReplicated      0x%x\n",
               Indent(nIndents),
               pAC->bIsNotReplicated);

        Printf("%sbIsOperational        0x%x\n",
               Indent(nIndents),
               pAC->bIsOperational);

        Printf("%sbDupLDN               0x%x\n",
               Indent(nIndents),
               pAC->bDupLDN);

        Printf("%sbDupOID               0x%x\n",
               Indent(nIndents),
               pAC->bDupOID);

        Printf("%sbDupPropGuid          0x%x\n",
               Indent(nIndents),
               pAC->bDupPropGuid);

        Printf("%sbDupMapiID            0x%x\n",
               Indent(nIndents),
               pAC->bDupMapiID);

        Printf("%sbIsRdn                0x%x\n",
               Indent(nIndents),
               pAC->bIsRdn);

        Printf("%sbFlagIsRdn            0x%x\n",
               Indent(nIndents),
               pAC->bFlagIsRdn);

        Printf("%sOMsyntax              0x%x\n",
               Indent(nIndents),
               pAC->OMsyntax);

//      Printf("%sOM_object_identifier\n",
//             Indent(nIndents));
//      Dump_OM_object(nIndents + 1,
//                     ((BYTE *) pvProcess) + OFFSET(ATTCACHE, OMObjClass));

        if (pAC->pszPdntIndex) {
            pszPdntIndex = ReadStringMemory (pAC->pszPdntIndex, MAX_INDEX_NAME);
            if ( NULL == pszPdntIndex )
                break;
            Printf("%spszPdntIndex          %s\n",
                   Indent(nIndents),
                   pszPdntIndex);
        }
        else {
            Printf("%spszPdntIndex          %x\n",
                   Indent(nIndents),
                   pAC->pszPdntIndex);
        }

        if (pAC->pszIndex) {
            pszIndex = ReadStringMemory (pAC->pszIndex, MAX_INDEX_NAME);
            if ( NULL == pszIndex )
                break;

            Printf("%spszIndex              %s\n",
                   Indent(nIndents),
                   pszIndex);
        }
        else {
            Printf("%spszIndex              %x\n",
                   Indent(nIndents),
                   pAC->pszIndex);
        }

        Printf("%sobjectGuid            ",
               Indent(nIndents));
        pG = (UCHAR *) &(pAC->objectGuid);
        for ( i = 0; i < sizeof(GUID); pG++, i++ )
            Printf("%02x", *pG);
        Printf("\n");
    }
    while ( FALSE );

    FreeMemory(name);
    FreeMemory(pszPdntIndex);
    FreeMemory(pszIndex);
    FreeMemory(pAC);

    return(TRUE);
}

BOOL
Dump_PARTIAL_ATTR_VECTOR(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public PARTIAL_ATTR_VECTOR dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of PARTIAL_ATTR_VECTOR in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    PARTIAL_ATTR_VECTOR *pPartialAttrVec = NULL;
    DWORD cAttrs = 0;
    DWORD i;

    Printf("%sPARTIAL_ATTR_VECTOR:\n\n", Indent(nIndents));
    nIndents += 2;

    pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) ReadMemory(pvProcess,
                                              PartialAttrVecV1SizeFromLen(0));

    if ( NULL != pPartialAttrVec )
    {
        if (VERSION_V1 == pPartialAttrVec->dwVersion)
        {
            cAttrs = pPartialAttrVec->V1.cAttrs;
        }
        else
        {
            Printf("%sPARTIAL_ATTR_VECTOR version is NOT %d!!!\n", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory( pPartialAttrVec );

        if (0 != cAttrs)
        {

            pPartialAttrVec = (PARTIAL_ATTR_VECTOR *) ReadMemory(pvProcess,
                                                      PartialAttrVecV1SizeFromLen(cAttrs));

            if ( NULL != pPartialAttrVec )
            {
                for ( i = 0; i < cAttrs; i++ )
                {
                    if (!(i % 4))
                        Printf("%s", Indent(nIndents));

                    Printf("0x%-8x    ", pPartialAttrVec->V1.rgPartialAttr[i]);

                    if (!((i+1) % 4) || ((i+1) == cAttrs))
                        Printf("\n");
                }

                FreeMemory( pPartialAttrVec );
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}

BOOL
Dump_GCDeletionList(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public GCDeletionList dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GCDeletionList in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL            fSuccess = FALSE;
    GCDeletionList *pGCDList = NULL;
    DWORD cAttrs = 0;
    DWORD i;

    Printf("%sGCDeletionList:\n\n", Indent(nIndents));
    nIndents += 2;

    pGCDList = (GCDeletionList *) ReadMemory(pvProcess,
                                              GCDeletionListSizeFromLen(0));

    if ( NULL != pGCDList )
    {
        if (VERSION_V1 == pGCDList->PartialAttrVecDel.dwVersion)
        {
            cAttrs = pGCDList->PartialAttrVecDel.V1.cAttrs;
        }
        else
        {
            Printf("%sEmbedded PARTIAL_ATTR_VECTOR version is NOT %d!!!\n", Indent(nIndents), VERSION_V1);
            fSuccess = TRUE;
        }

        FreeMemory( pGCDList );

        if (0 != cAttrs)
        {

            pGCDList = (GCDeletionList *) ReadMemory(pvProcess,
                                                      GCDeletionListSizeFromLen(cAttrs));

            if ( NULL != pGCDList )
            {
                Printf("%susnLastProcessed: %I64d\n", Indent(nIndents),
                       pGCDList->usnLastProcessed);

                Printf("%sDeletion List: \n", Indent(nIndents));

                nIndents += 2;

                for ( i = 0; i < cAttrs; i++ )
                {
                    if (!(i % 4))
                        Printf("%s", Indent(nIndents));

                    Printf("0x%-8x    ", pGCDList->PartialAttrVecDel.V1.rgPartialAttr[i]);

                    if (!((i+1) % 4) || ((i+1) == cAttrs))
                        Printf("\n");
                }

                FreeMemory( pGCDList );
                fSuccess = TRUE;
            }
        }
    }

    return(fSuccess);
}

BOOL
Dump_GCDeletionListProcessed(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Public GCDeletionListProcessed dump routine - print attids for in
    a row.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - address of GCDeletionListProcessed in address space of process being
        debugged.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    BOOL                    fSuccess = FALSE;
    GCDeletionListProcessed *pGCDListProcessed = NULL;
    DWORD cAttrs, i;

    Printf("%sGCDeletionListProcessed:\n\n", Indent(nIndents));
    nIndents += 2;

    pGCDListProcessed = (GCDeletionListProcessed *) ReadMemory(pvProcess,
                                                        sizeof(GCDeletionListProcessed));

    if ( NULL != pGCDListProcessed )
    {
        if (!pGCDListProcessed->pNC)
        {
            Printf("%sNo Deletion List is currently processed\n", Indent(nIndents));
        }
        else
        {
            Dump_DSNAME(nIndents, pGCDListProcessed->pNC);
            Printf("%spGCDList @ %p\n", Indent(nIndents),
                        pGCDListProcessed->pGCDList);
            Printf("%spurgeCount - %d\n", Indent(nIndents),
                        pGCDListProcessed->purgeCount);
            Printf("%sfReload - %s\n", Indent(nIndents),
                        pGCDListProcessed->fReload ? "true" : "false");
            Printf("%sfNCHeadPurged - %s\n", Indent(nIndents),
                        pGCDListProcessed->fNCHeadPurged ? "true" : "false");
        }

        FreeMemory(pGCDListProcessed);
    }

    return(fSuccess);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\util.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    util.c

Abstract:

    Helper functions for dsexts.dll ntsd/windbg debugger extensions.

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    24-Apr-96   DaveStr     Created

--*/
#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"

PVOID
ReadMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads memory from the address space of the process
    being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    Pointer to debugger local memory.

--*/

{
    SIZE_T cRead;
    PVOID pv;

    if ( gfVerbose )
        Printf("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    if ( gfVerbose )
        Printf("ReadProcessMemory(0x%x @ %p)\n", dwSize, pvAddr);

    if ( !ReadProcessMemory(ghDbgProcess, pvAddr, pv, dwSize, &cRead) )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory error %x (%x@%p)\n",
               GetLastError(),
               dwSize,
               pvAddr);
        return(NULL);
    }

    if ( dwSize != cRead )
    {
        FreeMemory(pv);
        Printf("ReadProcessMemory size error - off by %x bytes\n",
               (dwSize > cRead) ? dwSize - cRead : cRead - dwSize);
        return(NULL);
    }

    return(pv);
}

PVOID
ReadStringMemory(
    IN PVOID  pvAddr,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function reads a NULL terminated string from the address space of
    the process being debugged and copies its contents to newly allocated memory
    in the debuggers address space.  NULL is returned on error. Returned
    memory should be deallocated via FreeMemory().

Arguments:

    pvAddr - Address of memory block to read in the address space of the
        process being debugged.

    dwSize - Maximum size of string

Return Value:

    Pointer to debugger local memory.

--*/

{
    PVOID pv;
    DWORD count;

    if ( gfVerbose )
        Printf("HeapAlloc(0x%x)\n", dwSize);

    if ( NULL == (pv = HeapAlloc(GetProcessHeap(), 0, dwSize)) )
    {
        Printf("Memory allocation error for %x bytes\n", dwSize);
        return(NULL);
    }

    if ( gfVerbose )
        Printf("ReadStringMemory(0x%x @ %p)\n", dwSize, pvAddr);

    for (count =0; count < dwSize; count++) {
        if ( !ReadProcessMemory(ghDbgProcess, (LPVOID)((char *)pvAddr+count), (LPVOID)((char *)pv+count), 1, NULL) )
        {
            FreeMemory(pv);
            Printf("ReadProcessMemory error %x (%x@%p)\n",
                   GetLastError(),
                   1,
                   (char *)pvAddr+count);
            return(NULL);
        }
        if (*((char *)pv+count) == '\0') {
            break;
        }
    }
    *((char *)pv + dwSize - 1) = '\0';

    return(pv);
}

VOID
FreeMemory(
    IN PVOID pv)

/*++

Routine Description:

    Frees memory returned by ReadMemory.

Arguments:

    pv - Address of debugger local memory to free.

Return Value:

    None.

--*/

{
    if ( gfVerbose )
        Printf("HeapFree(%p)\n", pv);

    if ( NULL != pv )
    {
        if ( !HeapFree(GetProcessHeap(), 0, pv) )
        {
            Printf("Error %x freeing memory at %p\n", GetLastError(), pv);
        }
    }
}

VOID
ShowBinaryData(
    IN DWORD   nIndents,
    IN PVOID   pvData,
    IN DWORD   dwSize)

/*++

Routine Description:

    Pretty prints debugger local memory to debugger output.

Arguments:

    nIndents - Number of indentation levels desired.

    pvData - Address of debugger local memory to dump.

    dwSize -  Count of bytes to dump.

Return Value:

    None.

--*/

{
    DWORD   i;
    char    line[20];
    PBYTE   pb = (PBYTE) pvData;

    line[16] = '\0';

    if ( dwSize > 65536 )
    {
        Printf("%sShowBinaryData - truncating request to 65536\n",
               Indent(nIndents));
        dwSize = 65536;
    }

    for ( ; dwSize > 0 ; )
    {
        Printf("%s", Indent(nIndents));

        for ( i = 0; (i < 16) && (dwSize > 0) ; i++, dwSize-- )
        {
            Printf("%02x ", (unsigned) *pb);

            if ( isprint(*pb) )
                line[i] = *pb;
             else
                line[i] = '.';

            pb++;
        }

        if ( i < 16 )
        {
            for ( ; i < 16 ; i++ )
            {
                Printf("   ");
                line[i] = ' ';
            }
        }

        Printf("\t%s\n", line);

        if ( CheckC() )
            break;
    }
}

BOOL
Dump_Binary(
    IN DWORD nIndents,
    IN PVOID pvProcess)

/*++

Routine Description:

    Dumps binary data - defaults to 100 bytes.  Most debuggers have
    a native command for this but it serves as a test case for the
    dump mechanism.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - Address in process being debugged to dump.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    PVOID pvLocal;

    if ( NULL != (pvLocal = ReadMemory(pvProcess, 100)) )
    {
        ShowBinaryData(1, pvLocal, 100);
        FreeMemory(pvLocal);
        return(TRUE);
    }

    return(FALSE);
}

BOOL
Dump_BinaryCount(
    IN DWORD nIndents,
    IN PVOID pvProcess,
    IN DWORD cBytes)

/*++

Routine Description:

    Dumps cBytes of binary data.

Arguments:

    nIndents - Indentation level desired.

    pvProcess - Address in process being debugged to dump.

    cBytes - Count of bytes to dump.

Return Value:

    TRUE on success, FALSE otherwise.

--*/

{
    PVOID pvLocal;

    if ( NULL != (pvLocal = ReadMemory(pvProcess, cBytes)) )
    {
        ShowBinaryData(nIndents, pvLocal, cBytes);
        FreeMemory(pvLocal);
        return(TRUE);
    }

    return(FALSE);
}

#define MAX_INDENT          50
#define SPACES_PER_INDENT   2

CHAR    _indents[(SPACES_PER_INDENT * MAX_INDENT) + 1];
DWORD   _lastIndent = (MAX_INDENT + 1);

PCHAR
Indent(
    IN DWORD nIndents)

/*++

Routine Description:

    Returns a pointer to a string with spaces representing the desired
    indentation level.  This function is to be used as follows:

        Printf("%sDataLabel - %d\n", Indent(5), value);

Arguments:

    nIndents - number of indentation levels desired.

Return Value:

    Pointer to indentation string.

--*/

{
    if ( _lastIndent > MAX_INDENT )
    {
        memset(_indents, ' ', sizeof(_indents));
        _lastIndent = 0;
    }

    //
    // Replace NULL character from last call and insert new NULL
    // character as required.
    //

    _indents[SPACES_PER_INDENT * _lastIndent] = ' ';

    if ( nIndents >= MAX_INDENT )
        nIndents = MAX_INDENT;

    _lastIndent = nIndents;

    _indents[SPACES_PER_INDENT * nIndents] = '\0';

    return(_indents);
}

CHAR _oidstring[64];

PCHAR
_DecodeOID(                 // produces a printable decoded OID
    IN PCHAR   pbOID,       // pointer to buffer holding encoded OID
    IN DWORD   cbOID)       // count of bytes in encoded OID
{
    PCHAR pTmp;
    DWORD val;
    DWORD i,j;

    if (cbOID < 2) {
        strcpy(_oidstring, "bogus OID");
	return _oidstring;
    }

    _oidstring[0] = 'O';
    _oidstring[1] = 'I';
    _oidstring[2] = 'D';

    pTmp = &_oidstring[3];

    val = pbOID[0] / 40;
    sprintf(pTmp, ".%u", val);
    while(*pTmp)
      ++pTmp;

    val = pbOID[0] % 40;
    sprintf(pTmp, ".%u", val);
    while(*pTmp)
      ++pTmp;

    i = 1;

    while (i < cbOID) {
	j = 0;
	val = pbOID[i] & 0x7f;
	while (pbOID[i] & 0x80) {
	    val <<= 7;
	    ++i;
	    if (++j > 4 || i >= cbOID) {
		// Either this value is bigger than we can handle (we
		// don't handle values that span more than four octets)
		// -or- the last octet in the encoded string has its
		// high bit set, indicating that it's not supposed to
		// be the last octet.  In either case, we're sunk.
		strcpy (_oidstring, "really bogus OID");
		return _oidstring;
	    }
	    val |= pbOID[i] & 0x7f;
	}
	sprintf(pTmp, ".%u", val);
	while(*pTmp)
	  ++pTmp;
	++i;
    }

    *pTmp = '\0';

    return _oidstring;
}

BOOL
WriteMemory(
    IN PVOID  pvProcess,
    IN PVOID  pvLocal,
    IN DWORD  dwSize)

/*++

Routine Description:

    This function writes memory into the address space of the process
    being debugged

Arguments:

    pvProcess - Address of memory block to write in the address space of the
        process being debugged.

    pvLocal - Address of the local block to be copied

    dwSize - Count of bytes to read/allocate/copy.

Return Value:

    TRUE on success, FALSE on failure

--*/

{
    BOOL fSuccess;
    SIZE_T cWritten;

    fSuccess = WriteProcessMemory(ghDbgProcess,
				  pvProcess,
				  pvLocal,
				  dwSize,
				  &cWritten);
    if (fSuccess && (dwSize != cWritten)) {
	Printf("WriteProcessMemory succeeded, but wrote %u bytes instead of %u\n",
	       cWritten,
	       dwSize);
    }

    return fSuccess;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsexts\sam.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sam.c

Abstract:

    Helper functions for dsexts.dll ntsd/windbg debugger extensions.
    This contains routines to dump out SAM structures

Environment:

    This DLL is loaded by ntsd/windbg in response to a !dsexts.xxx command
    where 'xxx' is one of the DLL's entry points.  Each such entry point
    should have an implementation as defined by the DEBUG_EXT() macro below.

Revision History:

    24-Aug-96   MURLIS     Created

--*/

#include <NTDSpch.h>
#pragma hdrstop

#include "dsexts.h"
#include <samsrvp.h>


BOOL
Dump_Sid(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SID

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of SID


  Return Values:

    TRUE on Success
    FALSE Otherwise

  --*/
{
    PSID            PSid = NULL;
    BOOL            fSuccess = FALSE;

    if (NULL != (PSid = (PSID) ReadMemory(pvProcess, sizeof(NT4SID))))
    {
        WCHAR   SidText[128];
        UNICODE_STRING  us;

        SidText[0] = L'\0';
        us.MaximumLength = sizeof(SidText);
        us.Length = 0;
        us.Buffer = SidText;

        RtlConvertSidToUnicodeString(&us, PSid, FALSE);
        Printf("%sSID = %S\n", Indent(nIndents), SidText);

        FreeMemory(PSid);

        fSuccess = TRUE;
    }

    return fSuccess;

}


BOOL
Dump_Context(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SAM context Block

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of Context Block


  Return Values:

    TRUE on Success
    FALSE Otherwise

  --*/
{
    PSAMP_OBJECT    Context = NULL;
    BOOL            fSuccess = FALSE;


    Printf("%sContext Block\n", Indent(nIndents));
    nIndents++;

    if (NULL!=(Context=(PSAMP_OBJECT) ReadMemory(
                                        pvProcess,
                                        sizeof(SAMP_OBJECT))))
    {


        Printf("%sLIST_ENTRY Flink = %p\n",
            Indent(nIndents),Context->ContextListEntry.Flink);
        Printf("%sLIST_ENTRY Blink = %p\n",
            Indent(nIndents),Context->ContextListEntry.Blink);
        Printf("%sObjectType = %x\n",
            Indent(nIndents),(ULONG) (Context->ObjectType));
        Printf("%sFixedValid = %x\n",
            Indent(nIndents),(ULONG) (Context->FixedValid));
        Printf("%sVariableValid = %x\n",
            Indent(nIndents),(ULONG) (Context->VariableValid));
        Printf("%sFixedDirty = %x\n",
            Indent(nIndents),(ULONG) (Context->FixedDirty));
        Printf("%sVariableDirty = %x\n",
            Indent(nIndents),(ULONG) (Context->VariableDirty));
        Printf("%sOnDisk = %p\n",
            Indent(nIndents),Context->OnDisk);
        Printf("%sOnDiskAllocated = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskAllocated));
        Printf("%sOnDiskUsed = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskUsed));
        Printf("%sOnDiskFree = %x\n",
            Indent(nIndents),(ULONG) (Context->OnDiskFree));
        Printf("%sReferenceCount = %x\n",
            Indent(nIndents),(ULONG) (Context->ReferenceCount));
        Printf("%sGrantedAccess = %x\n",
            Indent(nIndents),(ULONG) (Context->GrantedAccess));
        Printf("%sRootKey = %p\n",
            Indent(nIndents),Context->RootKey);

        //
        // Print Root Key Name
        //

        Printf("%sRootName = \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n",
                Indent(nIndents+4), (ULONG)(Context->RootName.MaximumLength));
        Printf("%sLength = %x\n",
                Indent(nIndents+4), (ULONG) (Context->RootName.Length));

        Printf("%sBuffer = %p\n",
                Indent(nIndents+4), Context->RootName.Buffer);


        //
        // Print Out DS Name
        //

        Printf("%sObjectNameInDs = %p \n", Indent(nIndents),
                 Context->ObjectNameInDs);
        if (NULL!=Context->ObjectNameInDs)
        {
            if (!Dump_DSNAME(nIndents+4,Context->ObjectNameInDs))
                Printf("%sError Could Not Evaluate Expression",Indent(nIndents));
        }

        Printf("%sObjectFlags = %x\n",
                Indent(nIndents), (ULONG) Context->ObjectFlags);

        Printf("%sDomainIndex = %x\n",
                Indent(nIndents), (ULONG) Context->DomainIndex);

        Printf("%sClientRevision = %x\n",
                Indent(nIndents), (ULONG) Context->ClientRevision);

        if (Context->MarkedForDelete)
            Printf("%sMarkedForDelete = TRUE\n",Indent(nIndents));
        else
            Printf("%sMarkedForDelete = FALSE\n",Indent(nIndents));

        if (Context->TrustedClient)
            Printf("%sTrustedClient = TRUE\n",Indent(nIndents));
        else
            Printf("%sTrustedClient = FALSE\n",Indent(nIndents));

        if (Context->AuditOnClose)
            Printf("%sAuditOnClose = TRUE\n",Indent(nIndents));
        else
            Printf("%sAuditOnClose = FALSE\n",Indent(nIndents));

        if (Context->LoopbackClient)
            Printf("%sLoopbackClient = TRUE\n",Indent(nIndents));
        else
            Printf("%sLoopbackClient = FALSE\n",Indent(nIndents));


        if (Context->Valid)
            Printf("%sValid = TRUE\n",Indent(nIndents));
        else
            Printf("%sValid = FALSE\n",Indent(nIndents));

        Printf("%sSignature = %x\n", Indent(nIndents), Context->Signature);

        if (Context->NotSharedByMultiThreads)
            Printf("%sNotSharedByMultiThreads = TRUE\n",Indent(nIndents));
        else
            Printf("%sNotSharedByMultiThreads = FALSE\n",Indent(nIndents));

        if (Context->OpenedByDCPromo)
            Printf("%sOpenedByDCPromo = TRUE\n", Indent(nIndents));
        else
            Printf("%sOpenedByDCPromo = FALSE\n", Indent(nIndents));

        Printf("%sTYPE BODY IS",Indent(nIndents));

        switch(Context->ObjectType)
        {
        case SampDomainObjectType:
                Printf(" DOMAIN\n");
                break;

        case SampUserObjectType:
                Printf(" USER\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.User.Rid
                    );

                Printf("%sLockoutTime %x %x\n", 
                       Indent(nIndents+4),
                       Context->TypeBody.User.LockoutTime.HighPart,
                       Context->TypeBody.User.LockoutTime.LowPart
                       );

                Printf("%sLastLogonTimeStamp %x %x\n", 
                       Indent(nIndents+4),
                       Context->TypeBody.User.LastLogonTimeStamp.HighPart,
                       Context->TypeBody.User.LastLogonTimeStamp.LowPart
                       );

                if (Context->TypeBody.User.CachedSupplementalCredentialsValid)
                {
                    Printf("%sCachedSupplementalCredentialsValid= TRUE\n",
                           Indent(nIndents+4) );
                    Printf("%sCachedSupplementalCredentialsLength= %ld\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedSupplementalCredentialLength);
                    Printf("%sCachedSupplementalCredentials= %p\n",
                        Indent(nIndents+4),
                        Context->TypeBody.User.CachedSupplementalCredentials);
                }
                else
                {
                    Printf("%sCachedSupplementalCredentialsValid= FALSE\n",
                        Indent(nIndents+4));
                }


                Printf("%sSupplementalCredentialsToWrite= %p\n",
                       Indent(nIndents+4),
                       Context->TypeBody.User.SupplementalCredentialsToWrite
                       );




                if (Context->TypeBody.User.CachedOrigUserParmsIsValid)
                {
                    Printf("%sCachedOrigUserParmsIsValid = TRUE\n",
                           Indent(nIndents+4));
                    Printf("%sCachedOrigUserParmsLength = %ld\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedOrigUserParmsLength);
                    Printf("%sCachedOrigUserParms = %p\n",
                           Indent(nIndents+4),
                           Context->TypeBody.User.CachedOrigUserParms);
                }
                else
                {
                    Printf("%sCachedOrigUserParmsIsValid = FALSE\n",
                           Indent(nIndents+4));
                }

                if (Context->TypeBody.User.DomainPasswordInformationAccessible)
                    Printf("%sDomainPasswordInformationAccessible = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sDomainPasswordInformationAccessible = FALSE\n",
                           Indent(nIndents+4));

                if (Context->TypeBody.User.PrivilegedMachineAccountCreate)
                    Printf("%sPrivilegedMachineAccountCreate = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sPrivilegedMachineAccountCreate = FALSE\n",
                           Indent(nIndents+4));

                if (Context->TypeBody.User.UparmsInformationAccessible)
                    Printf("%sUparmsInformationAccessible = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sUparmsInformationAccessible = FALSE\n",
                           Indent(nIndents+4));

                Printf("%sDomainSidForNt4SdConversion = %p\n", 
                       Indent(nIndents+4), 
                       Context->TypeBody.User.DomainSidForNt4SdConversion);

                Printf("%sUPN \n", Indent(nIndents+4));
                Printf("%sMaximum Length = %x\n", Indent(nIndents+8),
                       (ULONG) (Context->TypeBody.User.UPN.MaximumLength));
                Printf("%sLength = %x\n", Indent(nIndents+8),
                       (ULONG) (Context->TypeBody.User.UPN.Length));
                Printf("%sBuffer = %p\n", Indent(nIndents+8),
                       Context->TypeBody.User.UPN.Buffer);

                if (Context->TypeBody.User.UpnDefaulted)
                    Printf("%sUpnDefaulted = TRUE\n",
                           Indent(nIndents+4));
                else
                    Printf("%sUpnDefaulted = FALSE\n",
                           Indent(nIndents+4));

                break;

        case SampGroupObjectType:
                Printf(" GROUP\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.Rid
                    );
                Printf("%sNT4GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.NT4GroupType
                    );
                Printf("%sNT5GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.NT5GroupType
                    );
                Printf("%sSecurityEnabled = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.SecurityEnabled
                    );
                Printf("%sCachedMembershipOperationsListMaxLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsListMaxLength
                    );
                Printf("%sCachedMembershipOperationsListLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsListLength
                    );
                Printf("%sCachedMembershipOperationsList = %p\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Group.CachedMembershipOperationsList
                    );

                break;

         case SampAliasObjectType:
                Printf(" ALIAS\n");
                Printf("%sRid = %x\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.Rid
                    );
                Printf("%sNT4GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.NT4GroupType
                    );
                Printf("%sNT5GroupType= %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.NT5GroupType
                    );
                Printf("%sSecurityEnabled = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.SecurityEnabled
                    );
                Printf("%sCachedMembershipOperationsListMaxLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength
                    );
                Printf("%sCachedMembershipOperationsListLength = %d\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsListLength
                    );
                Printf("%sCachedMembershipOperationsList = %p\n",
                    Indent(nIndents+4),
                    Context->TypeBody.Alias.CachedMembershipOperationsList
                    );

                break;

         case SampServerObjectType:
                Printf(" SERVER\n");
                break;

         default:
                Printf(" UNKNOWN\n");
                break;
        }

        FreeMemory(Context);

        fSuccess = TRUE;
    }
    return fSuccess;
}


ULONG   MAX_CONTEXTS_COUNT = 500;


BOOL
Dump_ContextList(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
{
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    Context = NULL;
    BOOL            fSuccess = FALSE;
    ULONG           ContextListCount = 0;

    Printf("%sSAM Context List\n", Indent(nIndents));
    nIndents++;

    if (NULL != (Head=(PLIST_ENTRY) ReadMemory(pvProcess, sizeof(LIST_ENTRY))))
    {
        fSuccess = TRUE;
        NextEntry = Head->Flink;

        while ((NextEntry != Head) && (ContextListCount < MAX_CONTEXTS_COUNT))
        {
            ContextListCount++;
            if (NULL != (Context = (PSAMP_OBJECT) ReadMemory((PVOID)NextEntry, 
                                                             sizeof(SAMP_OBJECT))))
            {
                Printf("%sLIST_ENTRY Flink = %p\n",
                       Indent(nIndents),Context->ContextListEntry.Flink);
                Printf("%sLIST_ENTRY Blink = %p\n",
                       Indent(nIndents),Context->ContextListEntry.Blink);
                Printf("%sReferenceCount = %x\n",
                    Indent(nIndents),(ULONG) (Context->ReferenceCount));
                if (Context->MarkedForDelete)
                    Printf("%sMarkedForDelete = TRUE\n",Indent(nIndents));
                else
                    Printf("%sMarkedForDelete = FALSE\n",Indent(nIndents));

                if (Context->NotSharedByMultiThreads)
                    Printf("%sNotSharedByMultiThreads = TRUE\n",Indent(nIndents));
                else
                    Printf("%sNotSharedByMultiThreads = FALSE\n",Indent(nIndents));

                switch (Context->ObjectType)
                {
                case SampServerObjectType:
                    Printf("%sObjectType = SERVER\n", Indent(nIndents));
                    break;
                case SampDomainObjectType:
                    Printf("%sObjectType = DOMAIN\n", Indent(nIndents));
                    break;
                case SampUserObjectType:
                    Printf("%sObjectType = USER\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.User.Rid);
                    break;
                case SampGroupObjectType:
                    Printf("%sObjectType = GROUP\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.Group.Rid);
                    break;
                case SampAliasObjectType:
                    Printf("%sObjectType = ALIAS\n", Indent(nIndents));
                    Printf("%sRid = %x\n", Indent(nIndents+4), 
                           Context->TypeBody.Alias.Rid);
                    break;
                default:
                    Printf("%sUNKNOWN Object Type\n", Indent(nIndents));
                    break;
                }

                NextEntry = Context->ContextListEntry.Flink;
                FreeMemory(Context);
            }
            else
            {
                fSuccess = FALSE;
                break;
            }
        }

        FreeMemory(Head);
    }

    return fSuccess;
}




BOOL
Dump_DefinedDomain(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

  Routine Description:

    Dumps a SAM Defined Domain

  Arguments:

    nIndents    Desired Indentation Level
    pvProcess   Address of Defined Domain


  Return Values:

    TRUE on Success
    FALSE Otherwise

--*/

{

    PSAMP_DEFINED_DOMAINS    DefinedDomain = NULL;
    BOOL            fSuccess = FALSE;
    CHAR            szNetLogonChangeLogSerialNumber[20];


    Printf("%sDefined Domain\n", Indent(nIndents));
    nIndents++;

    if (NULL!=(DefinedDomain=(PSAMP_DEFINED_DOMAINS) ReadMemory(
                                                        pvProcess,
                                                        sizeof(SAMP_DEFINED_DOMAINS))))
    {
        if (!Dump_Context(nIndents+4,DefinedDomain->Context))
            Printf("%sError Could Not Evaluate Expression\n",Indent(nIndents));

        Printf("%sSID Address = %p\n", Indent(nIndents), DefinedDomain->Sid);
        if (DefinedDomain->Sid)
        {
            Dump_Sid(nIndents+4, DefinedDomain->Sid);
        }
        else
        {
            Printf("%sSID = NULL\n", Indent(nIndents+4));
        }

        Printf("%sExternalName \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->ExternalName.MaximumLength));
        Printf("%sLength = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->ExternalName.Length));
        Printf("%sBuffer = %p\n", Indent(nIndents+4),
               DefinedDomain->ExternalName.Buffer);

        Printf("%sInternalName \n", Indent(nIndents));
        Printf("%sMaximum Length = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->InternalName.MaximumLength));
        Printf("%sLength = %x\n", Indent(nIndents+4),
               (ULONG) (DefinedDomain->InternalName.Length));
        Printf("%sBuffer = %p\n", Indent(nIndents+4),
               DefinedDomain->InternalName.Buffer);

        Printf("%sAdminUserSD = %p\n", Indent(nIndents), DefinedDomain->AdminUserSD);
        Printf("%sAdminGroupSD = %p\n", Indent(nIndents), DefinedDomain->AdminGroupSD);
        Printf("%sNormalUserSD = %p\n", Indent(nIndents), DefinedDomain->NormalUserSD);
        Printf("%sNormalGroupSD = %p\n", Indent(nIndents), DefinedDomain->NormalGroupSD);
        Printf("%sNormalAliasSD = %p\n", Indent(nIndents), DefinedDomain->NormalAliasSD);

        Printf("%sAdminUserRidPointer = %p\n", Indent(nIndents), DefinedDomain->AdminUserRidPointer);
        Printf("%sNormalUserRidPointer = %p\n", Indent(nIndents), DefinedDomain->NormalUserRidPointer);

        Printf("%sAdminUserSDLength = %x\n", Indent(nIndents), DefinedDomain->AdminUserSDLength);
        Printf("%sAdminGroupSDLength = %x\n", Indent(nIndents), DefinedDomain->AdminGroupSDLength);
        Printf("%sNormalUserSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalUserSDLength);
        Printf("%sNormalGroupSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalGroupSDLength);
        Printf("%sNormalAliasSDLength = %x\n", Indent(nIndents), DefinedDomain->NormalAliasSDLength);

        Printf("%sCurrentFixed\n", Indent(nIndents));
        Dump_FixedLengthDomain_local(nIndents+4, &(DefinedDomain->CurrentFixed));

        Printf("%sUnmodifiedFixed\n", Indent(nIndents));
        Dump_FixedLengthDomain_local(nIndents+4, &(DefinedDomain->UnmodifiedFixed));


        if (DefinedDomain->FixedValid)
            Printf("%sFixedValid = TRUE\n", Indent(nIndents));
        else
            Printf("%sFixedValid = FALSE\n", Indent(nIndents));



        RtlLargeIntegerToChar((LARGE_INTEGER *) &(DefinedDomain->NetLogonChangeLogSerialNumber),
                              16,
                              sizeof(szNetLogonChangeLogSerialNumber),
                              szNetLogonChangeLogSerialNumber
                              );

        Printf("%sNetLogonChangeLogSerialNumber = %16s\n", Indent(nIndents),
               szNetLogonChangeLogSerialNumber);


        if (DefinedDomain->IsBuiltinDomain)
            Printf("%sIsBuiltinDomain = TRUE\n", Indent(nIndents));
        else
            Printf("%sIsBuiltinDomain = FALSE\n", Indent(nIndents));


        if (DefinedDomain->IsMixedDomain)
            Printf("%sIsMixedDomain = TRUE\n", Indent(nIndents));
        else
            Printf("%sIsMixedDomain = FALSE\n", Indent(nIndents));

        Printf("%sBehaviorVersion = %x\n", Indent(nIndents), DefinedDomain->BehaviorVersion);

        Printf("%sLastLogonTimeStampSyncInterval = %x\n", Indent(nIndents), DefinedDomain->LastLogonTimeStampSyncInterval);


        switch (DefinedDomain->ServerRole)
        {
        case DomainServerRoleBackup:
            Printf("%sServerRole = DomainServerRoleBackup\n", Indent(nIndents));
            break;

        case DomainServerRolePrimary:
            Printf("%sServerRole = DomainServerRolePrimary\n", Indent(nIndents));
            break;

        default:
            Printf("%sServerRole = UNKNOWN\n", Indent(nIndents));
            break;
        }


        Printf("%sDsDomainHandle = %p\n", Indent(nIndents), DefinedDomain->DsDomainHandle);

        FreeMemory(DefinedDomain);

        fSuccess = TRUE;
    }

    return fSuccess;

}

BOOL
Dump_DefinedDomains(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
/*++

    Routine Description:

        Dumps out all Defined Domains in the SampDefinedDomains Array

    Arguments:
        nIndents    Desired Indentation Level
        pvProcess   Address of Defined Domains

    Return Values:

        TRUE on success
        FALSE on Failure

--*/

{
    BOOL    fSuccess = TRUE;
    PULONG  pDefinedDomainsCount = NULL;
    PVOID   pAddress = NULL;
    ULONG   Count = 0;
    ULONG_PTR DefinedDomainAddress;

    pAddress = (VOID *) GetExpr("samsrv!SampDefinedDomainsCount");

    if (NULL == pAddress) {
        Printf("Can't Locate the Address of samsrv!SampDefinedDomainsCount - Sorry\n");
        return FALSE;
    }

    pDefinedDomainsCount = (ULONG *) ReadMemory(pAddress, sizeof(ULONG));

    if (NULL == pDefinedDomainsCount)
    {
        Printf("Can't Read Memory - Sorry\n");
        return FALSE;
    }

    for (Count = 0; Count < *pDefinedDomainsCount; Count ++)
    {
        DefinedDomainAddress = (ULONG_PTR)pvProcess + Count*sizeof(SAMP_DEFINED_DOMAINS);

        Printf("\n%sDefined Domain %d: Address Starts From %p\n",
               Indent(nIndents),
               Count,
               DefinedDomainAddress
              );

        if (!Dump_DefinedDomain(nIndents+2, (PVOID) DefinedDomainAddress) )
        {
            Printf("%sError Could Not Evaluate Defined Domain %d\n", Indent(nIndents), Count+1);
            fSuccess = FALSE;
        }
    }

    FreeMemory(pDefinedDomainsCount);

    return fSuccess;

}


BOOL
Dump_FixedLengthDomain_local(
    IN DWORD    nIndents,
    IN PVOID    pvProcess
    )
/*++

    Routine Description:

        Dumps out SAMP_V1_0A_FIXED_LENGTH_DOMAIN

    Arguments:

        seee Dump_Context

    Return Values:

        TRUE on success
        FALSE on failure
--*/
{
    BOOL    fSuccess = FALSE;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN Fixed = pvProcess;
    CHAR    szCreationTime[20];
    CHAR    szModifiedCount[20];
    CHAR    szMaxPasswordAge[20];
    CHAR    szMinPasswordAge[20];
    CHAR    szForceLogoff[20];
    CHAR    szLockoutDuration[20];
    CHAR    szLockoutObservationWindow[20];
    CHAR    szModifiedCountAtLastPromotion[20];

    Printf("%sRevision = %x\n", Indent(nIndents), Fixed->Revision);
    Printf("%sUnused1 = %x\n", Indent(nIndents), Fixed->Unused1);

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->CreationTime,
            16,
            sizeof( szCreationTime ),
            szCreationTime
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ModifiedCount,
            16,
            sizeof( szModifiedCount ),
            szModifiedCount
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->MaxPasswordAge,
            16,
            sizeof( szMaxPasswordAge ),
            szMaxPasswordAge
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->MinPasswordAge,
            16,
            sizeof( szMinPasswordAge ),
            szMinPasswordAge
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ForceLogoff,
            16,
            sizeof( szForceLogoff ),
            szForceLogoff
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->LockoutDuration,
            16,
            sizeof( szLockoutDuration ),
            szLockoutDuration
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->LockoutObservationWindow,
            16,
            sizeof( szLockoutObservationWindow ),
            szLockoutObservationWindow
            );

    RtlLargeIntegerToChar(
            (LARGE_INTEGER *) &Fixed->ModifiedCountAtLastPromotion,
            16,
            sizeof( szModifiedCountAtLastPromotion ),
            szModifiedCountAtLastPromotion
            );

    Printf("%sCreationTime = %16s\n", Indent(nIndents), szCreationTime);
    Printf("%sModifiedCount = %16s\n", Indent(nIndents), szModifiedCount);
    Printf("%sMaxPasswordAge = %16s\n", Indent(nIndents), szMaxPasswordAge);
    Printf("%sMinPasswordAge = %16s\n", Indent(nIndents), szMinPasswordAge);
    Printf("%sForceLogoff = %16s\n", Indent(nIndents), szForceLogoff);
    Printf("%sLockoutDuration = %16s\n", Indent(nIndents), szLockoutDuration);
    Printf("%sLockoutObservationWindow = %16s\n", Indent(nIndents), szLockoutObservationWindow);
    Printf("%sModifiedCountAtLastPromotion = %16s\n", Indent(nIndents), szModifiedCountAtLastPromotion);

    Printf("%sNextRid = %x\n", Indent(nIndents), Fixed->NextRid);
    Printf("%sPasswordProperties = %x\n", Indent(nIndents), Fixed->PasswordProperties);
    Printf("%sMinPasswordLength = %x\n", Indent(nIndents), Fixed->MinPasswordLength);
    Printf("%sPasswordHistoryLength = %x\n", Indent(nIndents), Fixed->PasswordHistoryLength);
    Printf("%sLockoutThreshold = %x\n", Indent(nIndents), Fixed->LockoutThreshold);

    switch (Fixed->ServerState)
    {
    case DomainServerEnabled:
        Printf("%sServerState = DomainServerEnabled\n", Indent(nIndents));
        break;

    case DomainServerDisabled:
        Printf("%sServerState = DomainServerDisabled\n", Indent(nIndents));
        break;

    default:
        Printf("%sServerState = UNKNOWN\n", Indent(nIndents));
        break;
    }

    switch (Fixed->ServerRole)
    {
    case DomainServerRoleBackup:
        Printf("%sServerRole = DomainServerRoleBackup\n", Indent(nIndents));
        break;

    case DomainServerRolePrimary:
        Printf("%sServerRole = DomainServerRolePrimary\n", Indent(nIndents));
        break;

    default:
        Printf("%sServerRole = UNKNOWN\n", Indent(nIndents));
        break;
    }

    if (Fixed->UasCompatibilityRequired)
        Printf("%sUasCompatibilityRequired = TRUE\n", Indent(nIndents));
    else
        Printf("%sUasCompatibilityRequired = FALSE\n", Indent(nIndents));

    Printf("%sUnused2 = %3c\n", Indent(nIndents), Fixed->Unused2);

    Printf("%sDomainKeyAuthType = %x\n", Indent(nIndents), Fixed->DomainKeyAuthType);

    Printf("%sDomainKeyFlags = %x\n", Indent(nIndents), Fixed->DomainKeyFlags);

    Printf("%sAddress of DomainKeyInformation = %x\n",
           Indent(nIndents),
           &(Fixed->DomainKeyInformation)
           );

    return fSuccess;

}


BOOL
Dump_AttrBlock(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attr Block.

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTRBLOCK   *pAttrBlock=NULL;
    DWORD       iCursor = 0;
    BOOL        fSuccess = FALSE;


    pAttrBlock = (ATTRBLOCK *)ReadMemory(pvProcess,sizeof(ATTRBLOCK));
    fSuccess = Dump_AttrBlock_local(nIndents, pAttrBlock, TRUE);
    if (NULL!=pAttrBlock)
        {
        FreeMemory(pAttrBlock);
    }

    return fSuccess;
}

BOOL
Dump_AttrBlock_local(
        IN  DWORD   nIndents,
        IN  ATTRBLOCK *pAttrBlock,
        BOOL fHasValues
    )
/*++

      Routine Description:

            Dumps out a DS Attr Block.

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    DWORD       iCursor = 0;
    BOOL        fSuccess = FALSE;
    ATTR        *pAttr = NULL;


    Printf("%sATTRBLOCK\n",Indent(nIndents));

    if (NULL!=pAttrBlock)
    {
        Printf("%sattrCount: %u\n",Indent(nIndents+1), pAttrBlock->attrCount);

        fSuccess = TRUE;

        // pAttrBlock->pAttr's value is an address space of the debugee.
        // So, we can add appropriate offsets to it to dump subsequent ATTR
        // structures
        for (iCursor = 0;
             fSuccess && (iCursor < pAttrBlock->attrCount);
             iCursor++)  {

            Printf("%spAttr[%u]: (@ 0x%x)\n", Indent(nIndents+1), iCursor,
                   pAttrBlock->pAttr + iCursor);

            pAttr = (ATTR *) ReadMemory(pAttrBlock->pAttr + iCursor,
                                        sizeof(ATTR));
            fSuccess = (NULL != pAttr);

            if (fSuccess) {
                fSuccess = Dump_Attr_local(nIndents+1, pAttr, fHasValues);
                FreeMemory(pAttr);
            }
        }
    }

    return fSuccess;
}

BOOL
Local_Dump_AttrValBlock(
    IN  DWORD   nIndents,
    IN  ATTRVALBLOCK *pAttrValBlock
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTRVAL      *pAVal = NULL;
    ULONG        i,j;
    BOOL         fSuccess = FALSE;

    Printf("%svalCount = %u\n",Indent(nIndents+1),pAttrValBlock->valCount);

    if (0 == pAttrValBlock->valCount) {
        return TRUE;
    }

    pAVal =(ATTRVAL *) ReadMemory(pAttrValBlock->pAVal,
                                  (sizeof(ATTRVAL) *
                                   pAttrValBlock->valCount));
    if (NULL!=pAVal) {
        for (i=0;i<pAttrValBlock->valCount;i++) {

            Printf("%spAVal[%u]: @ %p, len 0x%x\n", Indent(nIndents+1), i,
                   pAVal[i].pVal, pAVal[i].valLen);
        }

        FreeMemory(pAVal);

        fSuccess = TRUE;
    }

    return fSuccess;
}



Dump_AttrValBlock(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    BOOL        fSuccess = FALSE;
    ATTRVALBLOCK *pAttrValBlock = NULL;

    pAttrValBlock = (ATTRVALBLOCK *) ReadMemory(pvProcess,sizeof(ATTRVALBLOCK));

    if (NULL!=pAttrValBlock) {
        fSuccess = Local_Dump_AttrValBlock(nIndents, pAttrValBlock);
    }

    return fSuccess;
}



BOOL
Dump_Attr_local(
        IN  DWORD   nIndents,
        IN  ATTR    *pAttr,
        IN  BOOL    fHasValues
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ULONG       i;
    BOOL        fSuccess = FALSE;

    if (NULL!=pAttr)
    {
        Printf("%sattrType: 0x%x\n",Indent(nIndents+1),pAttr->attrTyp);
        if(fHasValues) {
            fSuccess = Local_Dump_AttrValBlock(nIndents+1,&(pAttr->AttrVal));
        }
        else {
            // This isn't supposed to have values.
            if(pAttr->AttrVal.valCount) {
                // But it does
                Printf("%sINCORRECTLY HAS VALUES!\n");
                fSuccess =
                    Local_Dump_AttrValBlock(nIndents+1,&(pAttr->AttrVal));
            }
            else {
                fSuccess = TRUE;
            }
        }
    }

    return fSuccess;
}




BOOL
Dump_Attr(
    IN  DWORD   nIndents,
    IN  PVOID   pvProcess
    )
/*++

      Routine Description:

            Dumps out a DS Attribute

      Arguments:

            See Dump_Context

      Return Values

            TRUE on success
            FALSE on Failure

  --*/
{
    ATTR        *pAttr = NULL;
    ATTRVAL     *pAVal = NULL;
    ULONG       i;
    BOOL        fSuccess = FALSE;

    pAttr = (ATTR *) ReadMemory(pvProcess,sizeof(ATTR));

    if (NULL!=pAttr)
    {
        fSuccess = Dump_Attr_local(nIndents, pAttr, TRUE);
        FreeMemory(pAttr);
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dsid\dsid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       dsid.c
//
//--------------------------------------------------------------------------

#include <NTDSpch.h>
#pragma hdrstop

#include <fileno.h>



struct namepair {
    int key;
    char * name;
};

struct namepair dirtbl [] = {
    {DIRNO_COMMON, "common"},
    {DIRNO_DRA, "dra"},
    {DIRNO_DBLAYER, "dblayer"},
    {DIRNO_SRC, "src"},
    {DIRNO_NSPIS, "nspis"},
    {DIRNO_DRS, "drsserv"},
    {DIRNO_XDS, "xdsserv"},
    {DIRNO_BOOT, "boot"},
    {DIRNO_PERMIT, "permit"},
    {DIRNO_ALLOCS, "allocs"},
    {DIRNO_LIBXDS, "libxds"},
    {DIRNO_SAM, "SAM"},
    {DIRNO_LDAP, "ldap"},
    {DIRNO_SDPROP, "sdprop"},
    {DIRNO_TASKQ, "taskq"},
    {DIRNO_KCC, "kcc"},
    {DIRNO_ISMSERV, "ism\\server"},
    {DIRNO_NTDSETUP, "ntdsetup"},
    {DIRNO_NTDSAPI, "ntdsapi"},
    {DIRNO_NTDSCRIPT, "util\\ntdscript"},
    {DIRNO_JETBACK, "jetback"},
    {0,0}
};

// Please add constants to this table alphabetically by constant, or
// we'll never find the ones we've missed.

struct namepair filetbl [] = {
    {FILENO_NSPSERV,"nspserv.c"},
    {FILENO_MODPROP,"modprop.c"},
    {FILENO_ABSERV,"abserv.c"},
    {FILENO_MSNOTIF,"msnotif.c"},
    {FILENO_MSDSSERV,"msdsserv.c"},
    {FILENO_DETAILS,"details.c"},
    {FILENO_ABTOOLS,"abtools.c"},
    {FILENO_ABBIND,"abbind.c"},
    {FILENO_ABSEARCH,"absearch.c"},
    {FILENO_ABNAMEID,"abnameid.c"},
    {FILENO_NSPNOTIF,"nspnotif.c"},
    {FILENO_ALERT,"alert.c"},
    {FILENO_ALLOCS,"allocs.c"},
    {FILENO_ATTRLIST,"attrlist.c"},
    {FILENO_CHECKSD,"checksd.c"},
    {FILENO_CLIENT,"client.c"},
    {FILENO_COMPRES,"compres.c"},
    {FILENO_LDAP_COMMAND,"command.cxx"},
    {FILENO_LDAP_GLOBALS,"globals.cxx"},
    {FILENO_LDAP_CONN,"connect.cxx"},
    {FILENO_CONTEXT,"context.c"},
    {FILENO_DEBUG,"debug.c"},
    {FILENO_DRSUAPI,"drsuapi.c"},
    {FILENO_XDSNOTIF,"xdsnotif.c"},
    {FILENO_DSCONFIG,"dsconfig.c"},
    {FILENO_DSEVENT,"dsevent.c"},
    {FILENO_DSEXCEPT,"dsexcept.c"},
    {FILENO_IDLNOTIF,"idlnotif.c"},
    {FILENO_IDLTRANS,"idltrans.c"},
    {FILENO_INFSEL,"infsel.c"},
    {FILENO_LISTRES,"listres.c"},
    {FILENO_XDSAPI,"xdsapi.c"},
    {FILENO_MODIFY,"modify.c"},
    {FILENO_SYNTAX,"syntax.c"},
    {FILENO_OMTODSA,"omtodsa.c"},
    {FILENO_SEARCHR,"searchr.c"},
    {FILENO_READRES,"readres.c"},
    {FILENO_DSWAIT,"dswait.c"},
    {FILENO_DBEVAL,"dbeval.c"},
    {FILENO_DBFILTER,"dbfilter.c"},
    {FILENO_DBINIT,"dbinit.c"},
    {FILENO_DBISAM,"dbisam.c"},
    {FILENO_DBJETEX,"dbjetex.c"},
    {FILENO_DBOBJ,"dbobj.c"},
    {FILENO_DBOPEN,"dbopen.c"},
    {FILENO_DBSEARCH,"dbsearch.c"},
    {FILENO_DBSUBJ,"dbsubj.c"},
    {FILENO_DBSYNTAX,"dbsyntax.c"},
    {FILENO_DBTOOLS,"dbtools.c"},
    {FILENO_DBINDEX,"dbindex.c"},
    {FILENO_DBMETA,"dbmeta.c"},
    {FILENO_DBESCROW, "dbescrow.c"},
    {FILENO_DBCACHE, "dbcache.c"},
    {FILENO_DBCONSTR, "dbconstr.c"},
    {FILENO_DIRTY,"dirty.c"},
    {FILENO_DRAASYNC,"draasync.c"},
    {FILENO_DRADIR,"dradir.c"},
    {FILENO_DRAERROR,"draerror.c"},
    {FILENO_DRAGTCHG,"dragtchg.c"},
    {FILENO_DRAINST,"drainst.c"},
    {FILENO_DRAMAIL,"dramail.c"},
    {FILENO_DRAMETA,"drameta.c"},
    {FILENO_DRANCADD,"drancadd.c"},
    {FILENO_DRANCDEL,"drancdel.c"},
    {FILENO_DRANCREP,"drancrep.c"},
    {FILENO_DRASERV,"draserv.c"},
    {FILENO_DRASYNC,"drasync.c"},
    {FILENO_DRAUPDRR,"draupdrr.c"},
    {FILENO_DRAUTIL,"drautil.c"},
    {FILENO_DRARFMOD,"drarfmod.c"},
    {FILENO_DRAMDERR, "dramderr.c"},
    {FILENO_DSAMAIN,"dsamain.c"},
    {FILENO_DSANOTIF,"dsanotif.c"},
    {FILENO_DSATOOLS,"dsatools.c"},
    {FILENO_DSTASKQ,"dstaskq.c"},
    {FILENO_HIERTAB,"hiertab.c"},
    {FILENO_LDAP_INIT,"init.cxx"},
    {FILENO_LDAP_LDAP,"ldap.cxx"},
    {FILENO_LDAP_CONV,"ldapconv.cxx"},
    {FILENO_LOG,"log.cxx"},
    {FILENO_LOOPBACK,"loopback.c"},
    {FILENO_MAPPINGS,"mappings.c"},
    {FILENO_MDADD,"mdadd.c"},
    {FILENO_MDBIND,"mdbind.c"},
    {FILENO_MDCHAIN,"mdchain.c"},
    {FILENO_MDCOMP,"mdcomp.c"},
    {FILENO_MDDEL,"mddel.c"},
    {FILENO_MDDIT,"mddit.c"},
    {FILENO_MDERRMAP,"mderrmap.c"},
    {FILENO_MDERROR,"mderror.c"},
    {FILENO_MDINIDSA,"mdinidsa.c"},
    {FILENO_MDFIND,"mdfind.c"},
    {FILENO_MDLIST,"mdlist.c"},
    {FILENO_MDMOD,"mdmod.c"},
    {FILENO_MDMODDN,"mdmoddn.c"},
    {FILENO_MDNAME,"mdname.c"},
    {FILENO_MDNDNC, "mdndnc.c"},
    {FILENO_MDNOTIFY,"mdnotify.c"},
    {FILENO_MDREAD,"mdread.c"},
    {FILENO_MDREMOTE,"mdremote.c"},
    {FILENO_MDSEARCH,"mdsearch.c"},
    {FILENO_MDUPDATE,"mdupdate.c"},
    {FILENO_MSRPC,"msrpc.c"},
    {FILENO_NTUTILS,"ntutils.c"},
    {FILENO_PICKEL,"pickel.c"},
    {FILENO_LDAP_REQ,"request.cxx"},
    {FILENO_IMPERSON,"imperson.c"},
    {FILENO_SAM,"SAM"},
    {FILENO_SCACHE,"scache.c"},
    {FILENO_SAMLOGON,"samlogon.c"},
    {FILENO_SAMWRITE,"samwrite.c"},
    {FILENO_LDAP_SECURE,"secure.cxx"},
    {FILENO_LDAP_USER,"userdata.cxx"},
    {FILENO_X500PERM,"x500perm.c"},
    {FILENO_LDAP_CORE,"ldapcore.cxx"},
    {FILENO_LDAP_LIMITS,"limits.cxx"},
    {FILENO_LDAP_MISC,"misc.cxx"},
    {FILENO_LDAP_ENCODE,"encode.cxx"},
    {FILENO_LDAP_LDAPBER,"ldapber.cxx"},
    {FILENO_LDAP_DECODE,"decode.cxx"},
    {FILENO_DRAXUUID,"draxuuid.c"},
    {FILENO_DRAUPTOD,"drauptod.c"},
    {FILENO_CRACKNAM,"cracknam.c"},
    {FILENO_SPNOP,"spnop.c"},
    {FILENO_DOMINFO,"dominfo.c"},
    {FILENO_DBPROP,"dbprop.c"},
    {FILENO_PROPDMON,"propdmon.c"},
    {FILENO_PROPQ,"propq.c"},
    {FILENO_TASKQ_TASKQ,"taskq.c"},
    {FILENO_TASKQ_TIME,"time.c"},
    {FILENO_KCC_KCCMAIN,"kccmain.cxx"},
    {FILENO_KCC_KCCLINK,"kcclink.cxx"},
    {FILENO_KCC_KCCCONN,"kccconn.cxx"},
    {FILENO_KCC_KCCCREF,"kcccref.cxx"},
    {FILENO_KCC_KCCDSA,"kccdsa.cxx"},
    {FILENO_KCC_KCCDUAPI,"kccduapi.cxx"},
    {FILENO_KCC_KCCTASK,"kcctask.cxx"},
    {FILENO_KCC_KCCTOPL,"kcctopl.cxx"},
    {FILENO_KCC_KCCSITE,"kccsite.cxx"},
    {FILENO_KCC_KCCTOOLS,"kcctools.cxx"},
    {FILENO_KCC_KCCDYNAR,"kccdynar.cxx"},
    {FILENO_KCC_KCCNCTL,"kccnctl.cxx"},
    {FILENO_KCC_KCCCACHE_HXX,"kcccache.hxx"},
    {FILENO_KCC_KCCCACHE,"kcccache.cxx"},
    {FILENO_KCC_KCCSITELINK,"kccsitelink.cxx"},
    {FILENO_KCC_KCCBRIDGE, "kccbridge.cxx"},
    {FILENO_GCVERIFY,"gcverify.c"},
    {FILENO_GCLOGON, "gclogon.c"},
    {FILENO_MDCTRL, "mdctrl.c"},
    {FILENO_DISKBAK,"diskbak.c"},
    {FILENO_NTDSAPI, "ntdsapi.c"},
    {FILENO_NTDSCRIPT, "script.cxx"},
    {FILENO_PARSEDN, "parsedn.c"},
    {FILENO_DRACHKPT,"drachkpt.c"},
    {FILENO_RPCCANCL, "rpccancl.c"},
    {FILENO_GTCACHE, "gtcache.c"},
    {FILENO_DSTRACE, "dstrace.c"},
    {FILENO_ISMSERV_TRANSPRT, "transprt.cxx"},
    {FILENO_ISMSERV_PENDING, "pending.cxx"},
    {FILENO_DRACRYPT, "dracrypt.c"},
    {FILENO_ADDSERV, "addserv.c"},
    {FILENO_INSTALL, "install.cxx"},
    {FILENO_FPOCLEAN, "fpoclean.c"},
    {FILENO_SERVINFO, "servinfo.c"},
    {FILENO_PHANTOM, "phantom.c"},
    {FILENO_ISMSERV_LDAPOBJ, "ldapobj.c"},
    {FILENO_ISMSERV_ISMAPI, "ismapi.cxx"},
    {FILENO_ISMSERV_SERVICE, "service.cxx"},
    {FILENO_ISMSERV_MAIN, "main.cxx"},
    {FILENO_ISMSERV_IPSEND, "ip\\sendrecv.c"},
    {FILENO_ADDOBJ, "addobj.cxx"},
    {FILENO_ISMSERV_XMITRECV, "smtp\\xmitrecv.c"},
    {FILENO_NTDSCRIPT_NTDSCONTENT, "NTDSConent.cxx"},
    {FILENO_NTDSETUP_NTDSETUP, "ntdsetup\\ntdsetup.c"},
    {FILENO_XDOMMOVE, "xdommove.c"},
    {FILENO_ISMSERV_ROUTE, "route.c"},
    {FILENO_ISMSERV_ADSISUPP, "smtp\\adsisupp.cxx"},
    {FILENO_ISMSERV_ISMSMTP, "smtp\\ismsmtp.c"},
    {FILENO_ISMSERV_CDOSUPP, "smtp\\cdosupp.c"},
    {FILENO_NTDSAPI_REPLICA, "replica.c"},
    {FILENO_DRAINFO, "drainfo.c"},
    {FILENO_MAPSPN, "mapspn.c"},
    {FILENO_PEK, "pek.c"},
    {FILENO_ADDSID, "addsid.c"},
    {FILENO_DRASCH, "drasch.c"},
    {FILENO_DRAINIT,"drainit.c"},
    {FILENO_SCCHK,"scchk.c"},
    {FILENO_ISMSERV_ISMIP, "ip\\ismip.c"},
    {FILENO_SAMCACHE, "samcache.c"},
    {FILENO_LINKCLEAN, "linkclean.c"},
    {FILENO_DRADEMOT, "drademot.c"},
    {FILENO_DRAMSG, "dramsg.c"},
    {FILENO_DRARPC, "drarpc.c"},
    {FILENO_JETBACK, "jetback.c"},
    {FILENO_JETREST, "jetrest.c"},
    {FILENO_SNAPSHOT, "snapshot.cxx"},
    {FILENO_DIRAPI, "dirapi.c"},
    {FILENO_LHT, "lht.c"},
    {0, 0}
};




void __cdecl main(int argc, char ** argv)
{
    int line;
    int fileno;
    int dirno;
    int dirfile;
    int i;
    char * stopstring;
    char * dirname;
    char * filename;

    dirname = filename = "huh?";

    if (argc != 2) {
        printf("usage: %s id\n", argv[0]);
        exit(1);
    }

    dirfile = strtol(argv[1], &stopstring, 16);
    if (dirfile == 0) {
        printf("I can't make sense of %s\n", argv[1]);
        exit(1);
    }

    line = dirfile & 0x0000ffff;
    dirno = (dirfile & 0xff000000) >> 24;
    fileno = (dirfile & 0x00ff0000) >> 16;
    dirfile >>= 16;

    for (i=0; dirtbl[i].name; i++) {
        if (dirtbl[i].key == dirno << 8) {
            dirname = dirtbl[i].name;
            break;
        }
    }
    for (i=0; filetbl[i].name; i++) {
        if (filetbl[i].key == dirfile) {
            filename = filetbl[i].name;
            break;
        }
    }

    printf("dir %u, file %u (%s\\%s), line %u\n", dirno, fileno, dirname,
           filename, line);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dslogs\main.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       main.cxx
//
//--------------------------------------------------------------------------

/*******************************************************************
*
*    File        : main.cxx
*    Author      : Eyal Schwartz
*    Copyrights  : Microsoft Corp (C) 1996
*    Date        : 3/9/1998
*    Description : Main entry point for dslogs
*
*    Revisions   : <date> <name> <description>
*******************************************************************/



#ifndef MAIN_CXX
#define MAIN_CXX



// include //
#include "helper.h"
#include <stdlib.h>
#include <winldap.h>    // for LDAP handles
#include <rpc.h>        // for SEC_WINNT_AUTH_IDENTITY
#include <algorithm>    // stl for find
#include <string>
#include <winsock2.h>
#include "evtlog.hxx"
#include "cfgstore.hxx"
#include "excpt.hxx"
using   namespace std;


// defines //
// constant strings



// types //
typedef enum _Target { T_ENTERPRISE, T_DOMAIN, T_SERVER, T_NULL } TARGETTYPE;

typedef struct _CmdLine{

   //
   // general
   //
   TARGETTYPE TargetType;
   LPTSTR pszTarget;             // target servers string (see usage)
   //
   //  filters
   //
   ULONG  ulSeconds;             // period filter
   DWORD type;
   //
   // output
   //
   LPTSTR pszLogfile;
   EVTFORMAT format;

} CMDLINE;



// global variables //
CMDLINE g_CmdLine;

// prototypes //
VOID usage(LPTSTR lpProgram);
BOOL ProcessArgs(INT argc, CHAR *argv[]);
VOID InitializeProcess(void);


// functions //




/*+++
Function   : ProcessArgs
Description: process command line arguments, validates & assign globals
Parameters :
Return     :
Remarks    : none.
---*/
BOOL ProcessArgs(INT argc, TCHAR *argv[]){

   INT i;
   LPTSTR pTmp, pEsc, pVal;
   BOOL bStatus = TRUE;
   DWORD EventType=0;
   //
   // init command line defaults
   //
   g_CmdLine.TargetType=T_DOMAIN;
   g_CmdLine.pszTarget=NULL;
   g_CmdLine.ulSeconds=3600*24;        // one day
   g_CmdLine.pszLogfile=(LPTSTR)&(szDefLogfile[0]);
   g_CmdLine.format = EF_TAB;
   g_CmdLine.type = EVENTLOG_ERROR_TYPE|EVENTLOG_WARNING_TYPE;



   _tprintf(_T("Command arguments:\n"));
   dprintf(DBG_FLOW, _T("Call: ProcessArgs"));
   for(i=1; i<argc; i++){

      if((argv[i][0] != '-' &&
         argv[i][0] != '/') ||
         (_tcslen(argv[i]) <= 1))
         usage(argv[0]);          // exit point.

      pEsc = &(argv[i][sizeof(TCHAR)]);

      //
      // get targets
      //
      if(_tcsnicmp(pEsc, _T("ent"), _tcslen(_T("ent"))) == 0){
            g_CmdLine.TargetType=T_ENTERPRISE;
            g_CmdLine.pszTarget = NULL;
            _tprintf(_T("Target: ENTERPRISE\n"));
      }
      else if(_tcsnicmp(pEsc, _T("dmn:"), _tcslen(_T("dmn:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("dmn:"))]);
         if(pVal[0] == '\0'){
            g_CmdLine.TargetType=T_DOMAIN;
            g_CmdLine.pszTarget=NULL;
            _tprintf(_T("Target: Default domain\n"), pVal);
         }
         else{
            g_CmdLine.TargetType=T_DOMAIN;
            g_CmdLine.pszTarget=pVal;
            _tprintf(_T("Target: DOMAINS {%s}\n"), pVal);
         }
      }
      else if(_tcsnicmp(pEsc, _T("svr:"), _tcslen(_T("svr:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("svr:"))]);
         if(pVal[0] == '\0'){
            g_CmdLine.TargetType=T_SERVER;
            g_CmdLine.pszTarget=NULL;
            _tprintf(_T("Target: Default server\n"), pVal);
         }
         else{
            g_CmdLine.TargetType=T_SERVER;
            g_CmdLine.pszTarget= pVal;
            _tprintf(_T("Target: SERVERS {%s}\n"), g_CmdLine.pszTarget);
         }
      }
      //
      // Event type
      //
      else if(_tcsnicmp(pEsc, _T("type:"), _tcslen(_T("type:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("type:"))]);
         if(pVal[0] == '\0'){
            usage(argv[0]);
         }
         else{
            string strType(pVal);
            ctype<TCHAR> cType;
            cType.tolower(strType.begin(), strType.end());
            if(strType.find(_T("all")) != string::npos){
               EventType |= (DWORD)-1;
            }
            if(strType.find(_T("success")) != string::npos){
               EventType |= EVENTLOG_SUCCESS;
            }
            if(strType.find(_T("error")) != string::npos){
               EventType |= EVENTLOG_ERROR_TYPE;
            }
            if(strType.find(_T("warn")) != string::npos){
               EventType |= EVENTLOG_WARNING_TYPE;
            }
            if(strType.find(_T("info")) != string::npos){
               EventType |= EVENTLOG_INFORMATION_TYPE;
            }
            if(strType.find(_T("audit_success")) != string::npos){
               EventType |= EVENTLOG_AUDIT_SUCCESS;
            }
            if(strType.find(_T("audit_failure")) != string::npos){
               EventType |= EVENTLOG_AUDIT_FAILURE;
            }
            _tprintf(_T("Event Type: 0x%x\n"), EventType);
         }
      }
      //
      // get period
      //
      else if(_tcsnicmp(pEsc, _T("period:"), _tcslen(_T("period:"))) == 0){
         pVal = &(pEsc[_tcslen(_T("period:"))]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            ULONG ulFactor = 3600;
            if(pVal[_tcslen(pVal)-sizeof(TCHAR)] == 'd'){
               ulFactor *=24;
               pVal[_tcslen(pVal)-sizeof(TCHAR)] = '\0';
            }
            else if(pVal[_tcslen(pVal)-sizeof(TCHAR)] == 'h'){
               pVal[_tcslen(pVal)-sizeof(TCHAR)] = '\0';
            }

            LONG lTmp = _ttol(pVal);
            if(lTmp <= 0)
               usage(argv[0]);
            g_CmdLine.ulSeconds = (ULONG)lTmp;
            g_CmdLine.ulSeconds *= ulFactor;
            _tprintf(_T("Period: %lu (sec)\n"), g_CmdLine.ulSeconds);
         }
      }
      //
      // get output file
      //
      else if(_tcsnicmp(pEsc, _T("file:"), _tcslen(_T("file:"))) == 0){
         pVal = &(pEsc[_tcslen("file:")]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            g_CmdLine.pszLogfile = pVal;
            _tprintf(_T("Output file: %s\n"), g_CmdLine.pszLogfile);
         }
      }
      //
      // get output format
      //
      else if(_tcsnicmp(pEsc, _T("format:"), _tcslen(_T("format:"))) == 0){
         pVal = &(pEsc[_tcslen("format:")]);
         if(pVal[0] == '\0')
            usage(argv[0]);
         else{
            if(!(_tcsicmp(_T("TAB"), pVal))){
               g_CmdLine.format = EF_TAB;
            }
            else if(!(_tcsicmp(_T("COMMA"), pVal))){
               g_CmdLine.format = EF_COMMA;
            }
            else if(!(_tcsicmp(_T("RECORD"), pVal))){
               g_CmdLine.format = EF_RECORD;
            }
            else{
               usage(argv[0]);
            }
            _tprintf(_T("Output format: %s\n"), pVal);
         }
      }
      //
      // take the rest (inc help)
      //
      else
         usage(argv[0]);
   }

   if(EventType != 0){
      g_CmdLine.type = EventType;
   }

   return bStatus;
}



/*+++
Function   : usage
Description: print usage message & aborts.
Parameters :
Return     :
Remarks    : none.
---*/
VOID usage(LPTSTR lpProgram){

   dprintf(DBG_ERROR, _T("[DsLogs!usage] Error: Invalid usage"));
   _tprintf(_T("Usage: %s [target] [operation] [filters] [output]\n"), lpProgram);

   _tprintf(_T("target: -[ent|dmn:<dmnlist>|svr:<dclist>]\n"));
   _tprintf(_T(" -ent: get enterprise logs OR \n"));
   _tprintf(_T(" -dmn:domain1;domain2;... get domain's logs OR\n"));
   _tprintf(_T(" -svr:dc1;dc2... get specified machine logs\n"));
   _tprintf(_T("filters: -[period:#[d|h] [type:<type combination>]]\n"));
   _tprintf(_T(" -period:#[d|h] where # is number of d for days, h for hours (def: 24h)\n"));
   _tprintf(_T(" -type:[ALL|SUCCESS|ERROR|WARN|INFO|AUDIT_SUCESS|AUDIT_FAILURE]\n\tany combination is valid but none\n"));
   _tprintf(_T("output: [file:<logfile>] [type:[TAB|COMMA|RECORD]]\n"));
   _tprintf(_T(" -file:<logfile> to specify results log file name (def:%s)\n"), szDefLogfile);
   _tprintf(_T(" -format:[TAB|COMMA|RECORD] output format style\n"));
   _tprintf(_T("Notes:\n"));
   _tprintf(_T(" - No spaces in Option formats i.e. Option:value\n"));
   _tprintf(_T(" - Default run is to retreive all type events forthe last\nday from the enterprise.\n"));
   _tprintf(_T(" - Have ntdsmsg.dll in your path to get full event parsing.\n"));
   ExitProcess(1);
}






/*+++
Function   : InitializeProcess
Description: initialize debug info & process command line
Parameters :
Return     :
Remarks    : none.
---*/
VOID InitializeProcess(void){

   WORD wVersionRequested=0;
   WSADATA wsaData;
   INT iStatus=0;

   //
   // initialize winsock
   //
   wVersionRequested = MAKEWORD( 2, 2 );
   iStatus = WSAStartup(wVersionRequested, &wsaData);
   if ( LOBYTE( wsaData.wVersion ) != 2 ||
      HIBYTE( wsaData.wVersion ) != 2 ) {
      WSACleanup( );
      fatal(_T("Cannot initialize winsock"));
   }

   //
   // Set automatic memory diagnostics
   //
#ifdef _DEBUG_MEMLEAK
   _CrtSetDbgFlag(_CRTDBG_CHECK_ALWAYS_DF |
                  _CRTDBG_CHECK_CRT_DF |
                  _CRTDBG_LEAK_CHECK_DF |
                  _CRTDBG_ALLOC_MEM_DF |
                  _CRTDBG_DELAY_FREE_MEM_DF);
#endif

   //
   // application debugging flags
   //
//  g_dwDebugLevel=DBG_ERROR|DBG_FLOW ;
   g_dwDebugLevel=DBG_ERROR;

}





/*+++
Function   : main
Description: PROGRAM ENTRY POINT
Parameters :
Return     :
Remarks    : none.
---*/
INT _cdecl main(INT argc, TCHAR *argv[]){

   //
   // general vars
   //
   ULONG ulStatus = 0;
   INT i=0;

   InitializeProcess();

   dprintf(DBG_FLOW, _T("*** %s entry point ***\n"), argv[0]);
   //
   // program initialization
   //
   if(!ProcessArgs(argc, argv)){
      usage(argv[0]);            // program exit point
   }


   //
   // Get enterprise configuration
   //

   //
   // variables for config parsing
   //
   ConfigStore *cfg  = NULL;
   vector<ServerInfo*> EntSvrLst;
   vector<DomainInfo*>::iterator itDmn;
   vector<ServerInfo*>::iterator itSvr;
   vector<ServerInfo*> ServerList;
   vector<DomainInfo*> Domains;
   LPTSTR pszDmns=NULL, pszSvrs=NULL;
   LPTSTR tkn;

   //
   // skip config fetching if a list of DC's was specified
   //
   if(g_CmdLine.TargetType != T_SERVER){

      _tprintf(_T("> Getting enterprise configuration information...\n"));

      cfg  = new ConfigStore();
      assert(cfg);

      if(!cfg->valid()){
         _tprintf(_T("Failed to create configuration store\n"));
         fatal(_T("Failed to create configuration store\n"));
      }


      Domains = cfg->GetDomainList();

      //
      // Print for debugging
      //
      for(itDmn=Domains.begin();
          itDmn != Domains.end();
          itDmn++){

         _tprintf(_T("Domain %s is hosted on:\n"), (*itDmn)->GetFlatName());

         for(i=1, itSvr=(*itDmn)->ServerList.begin();
             itSvr != (*itDmn)->ServerList.end();
             itSvr++, i++){
            _tprintf(_T(" %d> %s\n"), i, (*itSvr)->m_lpszFlatName);
         }

      }

      EntSvrLst = cfg->GetServerList();
   }



   //
   // Process target
   //
   switch(g_CmdLine.TargetType){
   case T_ENTERPRISE:
      ServerList = EntSvrLst;
      break;
   case T_DOMAIN:
      //
      // For each domain, if we find it, add it's servers to the list of
      // servers.
      //
      if(g_CmdLine.pszTarget == NULL){
         ServerInfo svr;
         if(!svr.valid()){
            _tprintf(_T("Cannot find default domain\n"));
            fatal(_T("Cannot find default domain\n"));
         }
         pszDmns = new TCHAR[_tcslen(svr.m_lpszDomain)+1];
         _tcscpy(pszDmns, svr.m_lpszDomain);
      }
      else{
         pszDmns = new TCHAR[_tcslen(g_CmdLine.pszTarget)+1];
         _tcscpy(pszDmns, g_CmdLine.pszTarget);
      }

      for(i=0, tkn = _tcstok(pszDmns, _T(" ;\0\n"));
             tkn != NULL;
             tkn = _tcstok(NULL, _T(" ;\0\n")), i++){
         //
         // domain string is in tkn. Find it in the domain list & append svr list
         // to global svr list
         //
         vector<ServerInfo*> TmpSvrLst;
         if(cfg->GetServerList(tkn, TmpSvrLst)){
            ServerList.insert(ServerList.end(), TmpSvrLst.begin(), TmpSvrLst.end());

         }

      }

      break;
   case T_SERVER:
      pszSvrs = _strdup(g_CmdLine.pszTarget);
      for(i=0, tkn = _tcstok(pszSvrs, _T(" ;\0\n"));
             tkn != NULL;
             tkn = _tcstok(NULL, _T(" ;\0\n")), i++){
         //
         // No free, but never mind since it's in the program scope
         //
         ServerList.push_back(new ServerInfo(tkn));

      }
      break;
   default:
      _tprintf(_T("Unknown switch case for TargetType\n"));
      fatal(_T("Unknown switch case for TargetType\n"));
   }



   //
   // Fetching event logs
   //
   INT ServerCount = ServerList.size();

   DsEventLogMgr **pDsLogs = new DsEventLogMgr *[ServerCount];
   assert(pDsLogs);

   _tprintf(_T("> Opening %d event logs...\n"), ServerCount);
   //
   // Create & open logs
   //
   for(i=0, itSvr=ServerList.begin();
       itSvr != ServerList.end();
       itSvr++, i++){
      _tprintf(_T(" %d> %s\n"), i+1, (*itSvr)->m_lpszFlatName);
      pDsLogs[i] = new DsEventLogMgr((*itSvr)->m_lpszFlatName);
      assert(pDsLogs[i]);
   }

   //
   // Fork threads & fetch logs
   //
   HANDLE *hThrds = new HANDLE[ServerCount+1];
   INT iThrds=0;
   for(i=0; i<ServerCount; i++){
      if(pDsLogs[i]->valid()){
         if(pDsLogs[i]->startThread())
            hThrds[iThrds++] = pDsLogs[i]->GetThreadHandle();

      }
      else{
         _tprintf(_T("Warning <%lu>: Skipping invalid server %s\n"),
                        pDsLogs[i]->GetLastError(), pDsLogs[i]->name());
      }
   }
   hThrds[i] = NULL;

   //
   // Wait
   //
   _tprintf(_T("Waiting for results...\n"));
   WaitForMultipleObjects(iThrds, hThrds, TRUE, INFINITE);




   //
   // construct event view filter
   //
   EVTFILTER Filter;
   Filter.dwBacklog = g_CmdLine.ulSeconds;
   Filter.bAppend = TRUE;                 // if we overwrite w/ mult threads, we're overwitting ourselves.
   Filter.OutStyle = g_CmdLine.format;
   Filter.dwEvtType = g_CmdLine.type;
   Filter.pMsgLib = (LPTSTR)szMessageLib;


   //
   // print logs
   //
   for(i=0; i<ServerCount; i++){
      _tprintf(_T("Processing Server %s records...\n"), pDsLogs[i]->name());
      INT j=0;
      if(pDsLogs[i]->valid()){
         if(!(pDsLogs[i]->PrintLog(g_CmdLine.pszLogfile, &Filter))){
            _tprintf(_T("Error<%lu>: Failed to write event log\n"), pDsLogs[i]->GetLastError());
         }
         Sleep(500);       // give enough time for close before next open...(nt5 features...)

      }
   }


   dprintf(DBG_FLOW, _T("*** %s exit point ***\n"), argv[0]);

   delete cfg;
   delete []hThrds;
   delete []pDsLogs;
   delete pszDmns;

   return (INT)ulStatus;
}






#endif

/******************* EOF *********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ReplProv.rc
//
#define IDS_PROJNAME                    100
#define IDS_RPCREPLPROV_DESC            101
#define IDR_RpcReplProv                 102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\replprov.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    replprov.cpp

Abstract:

    Contains dll entry points for replprov.dll

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000

Environment:

    User Mode - Win32

Revision History:

Notes:
    This cpp file was generated by Visual Studio...(Visual C++ 6.0)

--*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ReplProvps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ReplProv.h"

#include "ReplProv_i.c"
#include "RpcReplProv.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RpcReplProv, CRpcReplProv)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_REPLPROVLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry
//
// AjayR 7-22-00 modified to add runonce key and then call the
// CComModule::RegisterServer method.
//

STDAPI DllRegisterServer(void)
{
    HKEY hk;
    DWORD dwData, dwErr = 0;
    WCHAR wszFilePath[2*MAX_PATH];HRESULT hr = S_OK;
    DWORD dwFailed = 1;

    dwErr = GetModuleFileNameW(
                _Module.GetModuleInstance(),
                wszFilePath,
                2*MAX_PATH
                );
    //
    // GetModuleFileName returns the length of fileName.
    //
    if (!dwErr) {
        return GetLastError();
    }

    //
    // Add a RunOnce value to do the MOF compile.
    //
    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",
            0,
            KEY_WRITE,
            &hk
            )) {
        return GetLastError();
    }
    else {
        //
        // This will call the DoMofComp on this dll.
        //
        LPWSTR pszString = NULL;
        DWORD dwLen = wcslen(wszFilePath) 
                     + wcslen(L"rundll32.exe ,DoMofComp")
                     + 1;
        pszString = (LPWSTR) AllocADsMem(sizeof(WCHAR) * dwLen);

        if (!pszString) {
            RegCloseKey(hk);
            return ERROR_OUTOFMEMORY;
        }

        wcscpy(pszString, L"rundll32.exe ");
        wcscat(pszString, wszFilePath);
        wcscat(pszString, L",DoMofComp");

        if (RegSetValueExW(
                hk,
                L"ReplProv",
                0,
                REG_SZ,
                (LPBYTE)pszString,
                wcslen(pszString) * sizeof(WCHAR)
                )
            ) {
            dwErr = GetLastError();
        } 
        else {
            dwErr = 0;
        }

        FreeADsMem(pszString);
        RegCloseKey(hk);
    }

    if (dwErr) {
        return dwErr;
    }

    //
    // Create the key for the event log.
    //
    if (!RegCreateKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\DSReplicationProvider",
            0, // dwReserved,
            L"", // class name
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &hk,
            NULL // disposition does not matter
            )
        ) {

        DWORD dwLenFile = wcslen(wszFilePath) 
                        + 1;

        if (!RegSetValueExW(
                hk,
                L"EventMessageFile",
                0,
                REG_EXPAND_SZ,
                (LPBYTE)wszFilePath,
                dwLenFile * sizeof(WCHAR)
                )
            ) {
            //
            // Set the supported event types in the TypesSupported subkey.
            //
            DWORD dwData = EVENTLOG_ERROR_TYPE 
                          | EVENTLOG_WARNING_TYPE 
                          | EVENTLOG_INFORMATION_TYPE;

            if (!RegSetValueExW(
                    hk,
                    L"TypesSupported",
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwData,
                    sizeof(DWORD))
                ) {
                dwFailed = 0;
            }
        }

        if (dwFailed != 0) {
            //
            // Setting one of the value failed.
            //
            dwFailed = GetLastError();
        }

        //
        // We opened the key successfully so need to close it.
        //
        RegCloseKey(hk);
    }   // event log keys and values.
    else {
        //
        // Creating key failed.
        //
        return GetLastError();
    }

    if (dwFailed) {
        return dwFailed;
    }

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}


//+----------------------------------------------------------------------------
//
//  Function:  DoMofComp
//
//  Purpose:   Adds the provider classes to the WMI repository.
//
//-----------------------------------------------------------------------------
VOID WINAPI 
DoMofComp(
    HWND hWndParent,
    HINSTANCE hModule,
    PCTSTR ptzCommandLine,
    INT nShowCmd
    )
{
   UNREFERENCED_PARAMETER(hWndParent);
   UNREFERENCED_PARAMETER(hModule);
   UNREFERENCED_PARAMETER(ptzCommandLine);
   UNREFERENCED_PARAMETER(nShowCmd);
   HRESULT hr;
   IMofCompiler *pmc = NULL;
   LPWSTR pszPath = NULL;
   WCHAR wszFilePath[2*MAX_PATH];
   UINT nLen;
   DWORD dwLen = 0;
   HANDLE hEvent = NULL;

   CoInitialize(NULL);

   hr = CoCreateInstance(
            CLSID_MofCompiler,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IMofCompiler,
            (PVOID *)&pmc
            );
   
   if (FAILED(hr)) {
       ASSERT(!"CoInitializeFailed In Replprov Setup.");
       return;
   }

   nLen = GetSystemWindowsDirectoryW(wszFilePath, 2*MAX_PATH);
   if (nLen == 0)
   {
      ASSERT(!"Could not get system direcotry in Replprov Setup.");
      goto cleanup;
   }

   //
   // Issue 7-22-00 AjayR - define constant for the name.
   //
   dwLen = wcslen(wszFilePath) + wcslen(L"\\System32\\replprov.mof") + 1;
   pszPath = (LPWSTR) AllocADsMem(dwLen * sizeof(WCHAR));
   if (!pszPath) {
       ASSERT(!"Could not allocate memory - Replprov runonce failed.");
       goto cleanup;
   }
   
   wcscpy(pszPath, wszFilePath);
   wcscat(pszPath, L"\\System32\\replprov.mof");

   WBEM_COMPILE_STATUS_INFO Info;

   hr = pmc->CompileFile(
            pszPath,
            NULL,
            NULL,
            NULL,
            NULL,
            WBEM_FLAG_AUTORECOVER,
            0,
            0,
            &Info
            );

   hEvent = RegisterEventSourceW(NULL, L"DSReplicationProvider");
   
   if (!hEvent) {
       //
       // Could not Register event source to update log file.
       //
       ASSERT(!"Could not RegisterEventSource - Replprov runonce");
       goto cleanup;
   }

   if (WBEM_S_NO_ERROR != hr) {
       //
       // Send failure to EventLog.
       //
       WCHAR pszHr[25];
       wsprintfW(pszHr, L"%d", Info.hRes);
       WCHAR pszErrorString[] = 
           L"MofComp failed on %systemRoot%\\system32\\replprov.mof with code";
       const PWSTR rgArgs[2] = {pszErrorString, pszHr};
       
       ReportEventW(hEvent,
                   EVENTLOG_ERROR_TYPE,
                   0,                       // wCategory
                   REPLPROV_MOFCOMP_FAILED, // dwEventID
                   NULL,                    // lpUserSID
                   0,                       // wNumStrings
                   0,                       // dwDataSize
                   NULL,                    // lpStrings
                   NULL);                   // lpRawData
   }
   else
   {
       //
       // Send success notice to EventLog.
       //
       ReportEventW(hEvent,
                   EVENTLOG_INFORMATION_TYPE,
                   0,                        // wCategory
                   REPLPROV_MOFCOMP_SUCCESS, // dwEventID
                   NULL,                     // lpUserSID
                   0,                        // wNumStrings
                   0,                        // dwDataSize
                   NULL,                     // lpStrings
                   NULL                      // lpRawData
                   );
   }



cleanup:
    
    if (pszPath) {
        FreeADsMem(pszPath);
    }

    if (hEvent) {
        DeregisterEventSource(hEvent);
    }

    if (pmc) {
        pmc->Release();
    }

    CoUninitialize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED_)
#define AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif
#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <wbemprov.h>
#include <stdio.h>
#include "repmsg.h"

//added
#include <ntdsapi.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <ntdsadef.h>
#include <iads.h> // IADsPathname
#include <adshlp.h> // ADSI helper functions
#include <wchar.h>
#include <adserr.h>

#define SECURITY_WIN32 1
#include <sspi.h>
#include <secext.h>

//MACROS!
#if DBG == 1 
#define ASSERT(f) if (!(f)) {_ASSERTE(false);}
#else
#define ASSERT(f) if (false && !(f)) {_ASSERTE(false);}
#endif
#define BAD_IN_STRING_PTR(p) (NULL == p || IsBadStringPtrW(p,0))
#define BAD_IN_STRING_PTR_OPTIONAL(p) (NULL != p && IsBadStringPtrW(p,0))
#define BAD_IN_READ_PTR(p,size) (NULL == p || IsBadReadPtr(p,size))
#define BAD_IN_STRUCT_PTR(p,s) BAD_IN_READ_PTR(p,sizeof(s))
#define BAD_IN_MULTISTRUCT_PTR(p,s,n) BAD_IN_READ_PTR(p,n*sizeof(s))
#define ASSERT_AND_RETURN {ASSERT(false); return WBEM_E_INVALID_PARAMETER;}
#define ASSERT_AND_BREAK {ASSERT(false); break;}
#define BREAK_ON_FAIL if (FAILED(hr)) ASSERT_AND_BREAK;
#define WBEM_VALIDATE_READ_PTR(p,size) \
            if (BAD_IN_READ_PTR(p,size)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRUCT_PTR(p,s) \
            WBEM_VALIDATE_READ_PTR(p,sizeof(s));
#define WBEM_VALIDATE_IN_MULTISTRUCT_PTR(p,s,n) \
            WBEM_VALIDATE_READ_PTR(p,n*sizeof(s));
#define WBEM_VALIDATE_OUT_STRUCT_PTR(p,s) \
            if (NULL == p || IsBadWritePtr(p,sizeof(s))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_OUT_PTRPTR(p) \
            if (NULL == p || IsBadWritePtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_INTF_PTR(p) \
            if (NULL == p || IsBadReadPtr(p,sizeof(void*))) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR(p) \
            if (BAD_IN_STRING_PTR(p)) ASSERT_AND_RETURN;
#define WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(p) \
            if (BAD_IN_STRING_PTR_OPTIONAL(p)) ASSERT_AND_RETURN;
#define BAIL_ON_FAILURE(hr) if (FAILED((hr))) goto cleanup;



//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__987EF1F3_2F82_469E_889E_316F39649396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\rpcreplprov.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    RpcReplProv.cpp

Abstract:

    This file contains the implementation of the CRpcReplProv class. 
    The CRpcReplProv class is derived from the WMI classes; IWbemServices,
    IWbemProviderInit.

    The following WMI methods are implemented. 
            
    1) IWbemProviderInit::Initialize    
    2) IWbemServices::CreateInstanceEnumAsync
    3) IWbemServices::GetObjectAsync
    4) IWbemServices::ExecMethodAsync

       <Note that the synchronous version of 2,3 & 4, can still be
     called by a WMI client, but need not be implemented in the actual
     provider. This is because winmgmt.exe (WMI) has its own special
     code that makes turns ExecMethodAsync into a synchronous version etc...>
      
    For definition of the WMI schema outlining the objects,attributes
    and methods supports by this WMI Provider, please refer to replprov.mof
  
Important Notes:

    With respect to the Cursor and PendingOps classes, orginally the 
    Cursors and PendingOps were implemented as an array of embedded
    objects on the NamingContext and DomainController class repectively.
    However, it has been decided that the WMI schema would be better
    organized by using Associations and by eliminating the prescence of 
    embedded objects. Support for 'Association by Rule' will be available
    in Whistler. Please see Lev Novik as a WMI contact with respect to this 
    concept.

    As far as the code is concerned there are two functions that were
    written to support embedded objects (CreateCursors and
    CreatePendingOps) This code and any other associated code has been
    "removed" with an '#ifdef EMBEDDED_CODE_SUPPORT' where 
    EMBEDDED_CODE_SUPPORT is defined as 0 If, for some reason, it is
    desired to revert back to embedded objects, then search for the 
    symbol EMBEDDED_CODE_SUPPORT and remove the handling of these
    classes in CreateInstanceEnumAsync and GetObjectAsync.

    The current implementation generates a flat list of PendingOps and
    Cursors objects. WMI will be able to filter this based on the
    Association rules.

    Note that the PendingOps class will not need to be filtered, since
    only one instance of the DomainController object exists. For that reason
    there does NOT need to be any Association between PendingOps and
    the DomainController class. 
    However, since there can be multiple instances of the NamingContext
    class, and many instances of Cursors per NamingContext, Associations
    are required in this case. 
    Also note this code currently generates a flatlist of Cursors with
    a joint key of NamingContextDN and SrcInvocationUUID

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000


Revision History:
    AjayR made name changes and added param support to methods 27-Jul-2000.

--*/


#include "stdafx.h"
#include "ReplProv.h"
#include "RpcReplProv.h"
#include <lmcons.h>
#include <lmapibuf.h>
#include <adshlp.h>
#include <lmaccess.h>
/////////////////////////////////////////////////////////////////////////////
//


const LPWSTR strReplNeighbor = L"MSAD_ReplNeighbor";
const LPWSTR strDomainController = L"MSAD_DomainController";
const LPWSTR strNamingContext = L"MSAD_NamingContext";
const LPWSTR strDsReplPendingOp = L"MSAD_ReplPendingOp";
const LPWSTR strDsReplCursor = L"MSAD_ReplCursor";
const LPWSTR strKeyReplNeighbor = 
                 L"MSAD_ReplNeighbor.NamingContextDN=\"";
const LPWSTR strKeyReplNeighborGUID = L"SourceDsaObjGuid=\"";
const LPWSTR strKeySettings = L"MSAD_DomainController.DistinguishedName=\"";
const LPWSTR strKeyNamingContext = 
                 L"MSAD_NamingContext.DistinguishedName=\"";
const LPWSTR strKeyPendingOps = L"MSAD_ReplPendingOp.lserialNumber=";
const LPWSTR strKeyCursors = L"MSAD_DsReplCursor.SourceDsaInvocationID=\"";
const LPWSTR strKeyCursors2 = L"\",NamingContextDN=\"";
const LONG   lLengthOfStringizedUuid = 36;


CRpcReplProv::CRpcReplProv()
{
}

CRpcReplProv::~CRpcReplProv()
{
}

/*++    IWbemProviderInit

Routine Description:

    This method is required to be implemented by all WMI providers
    The IWbemProviderInitSink::SetStatus() method must be called to
    register the provider with WMI

    1) creates instances of class definitions 
    2) calls IWbemProviderInitSink::SetStatus()

Parameters:

    pNamespace  -  Pointer to a namespace (allows callbacks to WMI)
    pInitSink    -  IWbemProviderInitSink pointer



Return Values:

    Always WBEM_S_NO_ERROR 
    
--*/
STDMETHODIMP
CRpcReplProv::Initialize(
     IN LPWSTR pszUser,
     IN LONG lFlags,
     IN LPWSTR pszNamespace,
     IN LPWSTR pszLocale,
     IN IWbemServices *pNamespace,
     IN IWbemContext *pCtx,
     IN IWbemProviderInitSink *pInitSink
     )
{
    HRESULT hrSetStatus        = WBEM_S_NO_ERROR;
    HRESULT hr2            = WBEM_S_NO_ERROR;
    CComBSTR sbstrObjectName    = strReplNeighbor; 

    if (pNamespace == NULL || pInitSink == NULL)
        return WBEM_E_FAILED;    
        
    //
    // Get the class definitions of the WMI objects supported
    // by this provider... 
    //
    m_sipNamespace = pNamespace;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &m_sipClassDefReplNeighbor,
                NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;
    
    sbstrObjectName = strDomainController;
    hrSetStatus = m_sipNamespace->GetObject( 
                                      sbstrObjectName,
                                      WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                      NULL,
                                      &m_sipClassDefDomainController,
                                      NULL
                                      );
    if(FAILED(hrSetStatus))
         goto cleanup;
    
    sbstrObjectName = strNamingContext;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefNamingContext,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;
    

    sbstrObjectName = strDsReplPendingOp;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefPendingOps,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;    

    
    sbstrObjectName = strDsReplCursor;
    hrSetStatus = m_sipNamespace->GetObject( sbstrObjectName,
                                    WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                    NULL,
                                    &m_sipClassDefCursor,
                                    NULL );
    if(FAILED(hrSetStatus))
         goto cleanup;    
   
    //If we got this far, everything went okay
    hrSetStatus = WBEM_S_INITIALIZED;    
    
cleanup:
    
    //Must call this to complete the initialization process
    hr2 = pInitSink->SetStatus( hrSetStatus , 0 );
    ASSERT( !FAILED(hr2) );

    return hr2;
}



/*++    CreateInstanceEnumAsync

Routine Description:

    This method is required to be implemented by all WMI instance providers
    It handles the creation of all instances of a particular class.  
    Using the IWbemProviderObjectSink pointer, that is an IN param, the
    following methods must be called; IWbemProviderObjectSink::Indicate
    and IWbemProviderObjectSink::SetStatus.(See WMI documentation for a
    better understanding of these methods)

    Note that, the helper funciton, EnumAndIndicateReplicaSourcePartner()
    calls IWbemProviderObjectSink::Indicate and SetStatus internally
    (since these functions were hijacked from the WMI provider 
    adreplprov, written by Jon Newman) Whereas the other helper functions
    do not call the ::Indicate and ::SetStatus methods internally.
    
    
Parameters:

    bstrClass        -  BSTR, containing name of class
    pResponseHandler -  IWbemProviderObjectSink pointer, so that we can
                       call ::Indicate and ::SetStatus
Return Values:

      - HRESULT values from internal helper functions...    
      - WBEM_E_INVALID_CLASS, the class name is not serviced
        by this WMI provider

Notes:
      This method checks to make sure that the local machine is
      in fact a Domain Controller. (Fails if not a DC)
--*/
STDMETHODIMP 
CRpcReplProv::CreateInstanceEnumAsync( 
    IN const BSTR bstrClass,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    HRESULT hr3 = WBEM_E_FAILED;

    if (pResponseHandler == NULL)
        return WBEM_E_FAILED;
    
    
    if (NULL == bstrClass || IsBadStringPtrW(bstrClass,0))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    
    if (FAILED(CheckIfDomainController()))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    
    if (lstrcmpiW(bstrClass, strReplNeighbor) == 0)
    {    
        hr = EnumAndIndicateReplicaSourcePartner(pResponseHandler );
    }
    else if (lstrcmpiW(bstrClass, strDomainController) == 0)
    {
        IWbemClassObject*   pIndicateItem = NULL;
        hr2 = CreateDomainController( &pIndicateItem );
        if (SUCCEEDED(hr2))
        {
            ASSERT(pIndicateItem != NULL);

            //
            // We know that there will be one and only one instance
            // of the DomainController object
            //
            hr2 = pResponseHandler->Indicate( 1, &pIndicateItem );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT(!FAILED(hr));
    }
    else if (lstrcmpW(bstrClass, strNamingContext) == 0)
    {
        IWbemClassObject**    ppFullNCObject = NULL;
        IWbemClassObject**    ppPartialNCObject = NULL;
        LONG                nObjectCount = 0L;

        //
        // Full Naming Contexts, if we couldn't create masterNC
        // objects, then something is terribly wrong
        //
        hr2 = CreateNamingContext(TRUE, &nObjectCount, &ppFullNCObject);
        if (SUCCEEDED(hr2))
        {
            hr2 = pResponseHandler->Indicate( nObjectCount, ppFullNCObject );
            
            //
            // Partial Naming Contexts, if we couldn't
            // create partialNC, then continue
            //
            hr3 = CreateNamingContext(
                      FALSE,
                      &nObjectCount,
                      &ppPartialNCObject
                      );
            if (SUCCEEDED(hr3))
            {
                hr3 = pResponseHandler->Indicate(
                          nObjectCount,
                          ppPartialNCObject
                          );
            }    
        }        

        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrcmpW(bstrClass, strDsReplPendingOp) == 0)
   {
        IWbemClassObject**    ppPendingOp = NULL;
        LONG                nObjectCount = 0L;

        hr2 = CreateFlatListPendingOps(&nObjectCount, &ppPendingOp);
        if (SUCCEEDED(hr2))
        {
            hr2 = pResponseHandler->Indicate( nObjectCount, ppPendingOp );
        }        
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrcmpW(bstrClass, strDsReplCursor) == 0)
    {
        //
        // IWbemObjectSink::Indicate is called inside CreateFlatListCursors()
        //
        hr2 = CreateFlatListCursors(pResponseHandler);
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
    }
    else
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_INVALID_CLASS,
                 NULL,
                 NULL
                 );
    }
    
cleanup:
    return hr;
}

/*++    GetObjectAsync

Routine Description:

    This method is required to be implemented by all WMI instance
    providers. Given a WMI object path, this method should return
    an instance of that object.
    
    The following WMI methods must be called; 
    IWbemProviderObjectSink::Indicate and IWbemProviderObjectSink::SetStatus.
    (See WMI documentation for a better understanding of these methods)

Parameters:

    bstrObjectPath   -  BSTR, containing name of class
    pResponseHandler -  IWbemProviderObjectSink pointer, so that we
                       can call ::Indicate and ::SetStatus


Return Values:

    - HRESULT values from internal helper functions...    
    - WBEM_E_INVALID_OBJECT_PATH, bad object path
     
Notes:
    This method checks to make sure that the local machine is
    in fact a Domain Controller. (Fails if not a DC)

--*/
STDMETHODIMP 
CRpcReplProv::GetObjectAsync( 
    IN const BSTR bstrObjectPath,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    LONG rootlen = 0;
    LONG rootlen2 = 0;

    if (pResponseHandler == NULL)
        return WBEM_E_FAILED;
    
    if (NULL == bstrObjectPath || IsBadStringPtrW(bstrObjectPath,0))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    if (FAILED(CheckIfDomainController()))
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_FAILED,
                 NULL,
                 NULL
                 );
        goto cleanup;
    }

    /*******************************************
    * Need to fix this one, not sure how I handle multiple keys.
    ********************************************/
    if (   lstrlenW(bstrObjectPath) > 
            ( (rootlen = lstrlenW(strKeyReplNeighbor))
              + (rootlen2 = lstrlenW(strKeyReplNeighborGUID))
              )
        && 0 == _wcsnicmp(bstrObjectPath, strKeyReplNeighbor, rootlen)
       )
    {
        //
        // The path is being used as the key iteslf, rather than
        // splitting it up. When the comparision is made, the 
        // whole path is used.
        //
        //CComBSTR sbstrKeyValue = bstrObjectPath;
        hr = EnumAndIndicateReplicaSourcePartner(pResponseHandler,
                                                 bstrObjectPath );
    }
    else if (   lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeySettings))
            && 0 == _wcsnicmp(bstrObjectPath, strKeySettings, rootlen))
    {
        IWbemClassObject*  pIndicateItem = NULL;
        CComBSTR sbstrKeyValue = L"";

        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        //
        // remove trailing doublequote
        //
        sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';
            
        hr2 = GetDomainController( sbstrKeyValue,&pIndicateItem );
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            hr2 = pResponseHandler->Indicate( 1, &pIndicateItem );
        }
        
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
    else if (lstrlenW(bstrObjectPath) 
                 > (rootlen = lstrlenW(strKeyNamingContext))
            && 0 == _wcsnicmp(bstrObjectPath, strKeyNamingContext, rootlen)
            )
    {
        CComPtr<IWbemClassObject> spIndicateItem;
        CComBSTR sbstrKeyValue = L"";
        IWbemClassObject*    pTemp = NULL;
        
        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        //
        // remove trailing doublequote
        //
        sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';
        
        hr2 = GetNamingContext( sbstrKeyValue, &spIndicateItem);
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            pTemp = spIndicateItem;
            hr2 = pResponseHandler->Indicate( 1, &pTemp );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
            ASSERT( !FAILED(hr) );
   }
   else if ( lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeyPendingOps))
            && 0 == _wcsnicmp(bstrObjectPath, strKeyPendingOps, rootlen)
             )
   {
        CComPtr<IWbemClassObject> spIndicateItem;
        CComBSTR sbstrKeyValue = L"";
        IWbemClassObject*    pTemp = NULL;
        LONG    lNumber = 0L;

        //
        // remove prefix
        //
        sbstrKeyValue = (BSTR)bstrObjectPath + rootlen;
        lNumber = _wtol(sbstrKeyValue);

        hr2 = GetPendingOps( lNumber, &spIndicateItem);
        if (SUCCEEDED(hr2))
        {
            //
            // Need do do this because ATL ASSERTS on CComPTR ptr,
            // if &ptr and ptr != NULL
            //
            pTemp = spIndicateItem;
            hr2 = pResponseHandler->Indicate( 1, &pTemp );
        }
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 hr2,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
        }
        else if (lstrlenW(bstrObjectPath) > (rootlen = lstrlenW(strKeyCursors))
                 && 0 == _wcsnicmp(bstrObjectPath, strKeyCursors, rootlen)
                 )
        {
            //
            // Cursors have multiple keys, so we need to handle
            // this a bit differently
            //
        
            CComPtr<IWbemClassObject> spIndicateItem;
            IWbemClassObject*    pTemp = NULL;
            CComBSTR  sbstrNamingContextValue;
            CComBSTR  sbstrUUIDValue;
        
            //
            // remove prefix, and extract the two key values...
            // since the length of a stringized UUID is fixed,
            // we can easily parse the multiple keys...
            //
            rootlen2 = lstrlenW(strKeyCursors2);
        
            sbstrUUIDValue = (BSTR)bstrObjectPath + rootlen;
            sbstrNamingContextValue = (BSTR)sbstrUUIDValue 
                                      + lLengthOfStringizedUuid 
                                      + rootlen2;
        
            //
            // put null character at the end of the Uuid value...
            //
            sbstrUUIDValue[lLengthOfStringizedUuid] = L'\0';
       
            //
            // remove trailing double quote
            //
            sbstrNamingContextValue[
                lstrlenW(sbstrNamingContextValue) - 1
                ] = L'\0';
        
            hr2 = GetCursor(
                     sbstrNamingContextValue,
                     sbstrUUIDValue,
                     &spIndicateItem
                     );
            if (SUCCEEDED(hr2))
            {

                //
                // Need do do this because ATL ASSERTS on CComPTR ptr,
                // if &ptr and ptr != NULL
                //
                pTemp = spIndicateItem;
                hr2 = pResponseHandler->Indicate( 1, &pTemp );
            }
            hr = pResponseHandler->SetStatus(
                     WBEM_STATUS_COMPLETE,
                     hr2,
                     NULL,
                     NULL
                     );
            ASSERT( !FAILED(hr) );
        }
    else
    {
        hr = pResponseHandler->SetStatus(
                 WBEM_STATUS_COMPLETE,
                 WBEM_E_INVALID_OBJECT_PATH,
                 NULL,
                 NULL
                 );
        ASSERT( !FAILED(hr) );
    }
cleanup:    
    return hr;
}

/*++    ExecMethodAsync

Routine Description:

    This method is required to be implemented by all WMI method 
    providers Given a WMI method name, and the object path of a
    class instance, a method will be executed.Note that all methods
    defined in replprov.mof are dynamic, meaning they require a class
    instance in order to execute (See WMI documentation for more info)
    
    The following WMI methods must be called; IWbemProviderObjectSink::Indicate
     and IWbemProviderObjectSink::SetStatus.
    (See WMI documentation for a better understanding of these methods)


Parameters:

    strMethodName    -  BSTR, containing name of method
    strObjectPath    -  BSTR, containing object path of instance
                        (needed since the methods are dynamic)
    pInParams        -  Contains the parameters the method takes. This is 
                        needed only if the method takes paramters.
    pResultSink      -  IWbemProviderObjectSink pointer, so that we can
                        call ::Indicate and ::SetStatus


Return Values:

      - HRESULT values from internal helper functions...    
      - WBEM_E_INVALID_METHOD

Notes:
      This method checks to make sure that the local machine is in
      fact a Domain Controller. (Fails if not a DC)

--*/
STDMETHODIMP 
CRpcReplProv::ExecMethodAsync( 
    IN const BSTR strObjectPath,
    IN const BSTR strMethodName,
    IN long lFlags,
    IN IWbemContext *pCtx,
    IN IWbemClassObject *pInParams,
    IN IWbemObjectSink *pResultSink
    )
{   
    HRESULT hr = WBEM_E_FAILED;
    HRESULT hr2 = WBEM_E_FAILED;
    
    if (pResultSink == NULL)
        return WBEM_E_FAILED;
  
    if ((NULL == strObjectPath || IsBadStringPtrW(strObjectPath,0))
        || (NULL == strMethodName || IsBadStringPtrW(strMethodName,0))
        )
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    
    if (lstrcmpiW(strMethodName, L"ExecuteKCC") == 0)
    {    
        int rootlen = lstrlenW(strKeySettings);
        

        if (   lstrlenW(strObjectPath) > rootlen
            && 0 == _wcsnicmp(strObjectPath, strKeySettings, rootlen)
            && NULL != pInParams
           )
        {
            //
            // remove prefix and then trailing doublequote
            //
            CComBSTR sbstrKeyValue = (BSTR)strObjectPath + rootlen;
            sbstrKeyValue[lstrlenW(sbstrKeyValue)-1] = L'\0';

            IWbemClassObject* pIndicateItem = NULL;
            //
            // Parameters to function.
            //
            CComVariant vardwTaskId;
            CComVariant vardwFlags;

            hr = pInParams->Get(L"TaskID", 0, &vardwTaskId, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = pInParams->Get(L"dwFlags", 0, &vardwFlags, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = GetDomainController( sbstrKeyValue, &pIndicateItem);
            ASSERT(pIndicateItem != NULL);
            if (SUCCEEDED(hr))
            {    
                hr = ExecuteKCC(
                         pIndicateItem,
                         vardwTaskId.ulVal,
                         vardwFlags.ulVal
                         );
            }
        }
    }
    else if (lstrcmpiW(strMethodName, L"SyncNamingContext") == 0)
        {
        int rootlen = lstrlenW(strKeyReplNeighbor);
        if (lstrlenW(strObjectPath) > rootlen
            && 0 == _wcsnicmp(
                         strObjectPath,
                         strKeyReplNeighbor,
                         rootlen
                         )
            && NULL != pInParams
           )
        {
            //
            // The key value used for comparisions is precisely the
            // object path.
            //
            CComVariant vardwOptions;

            hr = pInParams->Get(L"Options", 0, &vardwOptions, NULL, NULL);
            if (FAILED(hr)) {
                goto cleanup;
            }

            hr = ProvDSReplicaSync(
                     strObjectPath,
                     vardwOptions.ulVal
                     );
        }
    }
    else
    {
        hr = WBEM_E_INVALID_METHOD;
    }
cleanup:
    hr2 = pResultSink->SetStatus(WBEM_STATUS_COMPLETE,hr,NULL,NULL);
    return hr2;
}

/*++    GetNamingContext

Routine Description:

    This is a helper function that retrieves an instance of a
    MSAD_NamingContext object (given an object path). See definition
    of MSAD_NamingContext class in replprov.mof. The object's only key
    is the DN of the naming context. Thus a search is done on the
    NTDS-Settings object of the local server looking at the hasMastersNC
    and hasPartialNCs attribute. If a match is found, then the object is
    returned, otherwise the method returns WBEM_E_FAILED

Parameters:

    bstrKeyValue    -  BSTR, from which the Naming Context DN is extracted.
    ppIndicateItem  -  pointer to IWbemClassObject* (contains the instance,
                       if found)
    

Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
HRESULT CRpcReplProv::GetNamingContext(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        )
{
    HRESULT hr = WBEM_E_FAILED;
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarArray;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    
    LONG lstart, lend;
    LONG index = 0L;
    SAFEARRAY *sa = NULL;
    CComVariant varItem;
    bool isFullReplica;
    bool bImpersonate = false;
    
    
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrKeyValue);
    ASSERT(ppIndicateItem != NULL);
    if (ppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    bImpersonate = true;
        
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL)

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarDN.bstrVal != NULL);

    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    for(int x = 0; x < 2; x++)
    {
        if (x == 0)
        {
            isFullReplica = true;
            hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
            if (FAILED(hr))
                goto cleanup;
        }
        else
        {
            isFullReplica = false;
            hr = spIADsDSA->GetEx(L"hasPartialNCs", &svarArray );
            if (FAILED(hr))
                goto cleanup;
        }

        sa = svarArray.parray;

        // Get the lower and upper bound
        hr = SafeArrayGetLBound( sa, 1, &lstart );
        if (FAILED(hr))
            goto cleanup;
    
        hr = SafeArrayGetUBound( sa, 1, &lend );
        if (FAILED(hr))
            goto cleanup;

        for (index = lstart; index <= lend; index++)
        {
            hr = SafeArrayGetElement( sa, &index, &varItem );
            if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
            {
                if (NULL != bstrKeyValue
                        && (lstrcmpiW(varItem.bstrVal, bstrKeyValue) == 0))
                {
                    //KeyValue matches
                    hr = m_sipClassDefNamingContext->SpawnInstance(
                             0,
                             ppIndicateItem
                             );
                    if (SUCCEEDED(hr))
                    {    
                        CComVariant vTemp = isFullReplica;
                        
                        #ifdef EMBEDDED_CODE_SUPPORT
                        /*EMBEDDED_CODE_SUPPORT*/
                        SAFEARRAY*  pArray = NULL;
                        VARIANT vArray;
                        #endif

                         hr = (*ppIndicateItem)->Put( 
                                  L"DistinguishedName",
                                  0,
                                  &varItem,
                                  0
                                  );
                         if (FAILED(hr))
                             goto cleanup;
                                                
                         hr = (*ppIndicateItem)->Put(
                                  L"IsFullReplica",
                                  0,
                                  &vTemp,
                                  0
                                  );
                             goto cleanup;
                            
                         #ifdef EMBEDDED_CODE_SUPPORT
                         /*EMBEDDED_CODE_SUPPORT*/
        
                         hr = CreateCursors(bstrKeyValue,&pArray);
                         if (FAILED(hr))
                             goto cleanup;
                        
                         VariantInit(&vArray);
                         vArray.vt = VT_ARRAY|VT_UNKNOWN;
                         vArray.parray = pArray;
                         hr = (*ppIndicateItem)->Put(
                                  L"cursorArray",
                                  0,
                                  &vArray,
                                  0
                                  );
                         //goto cleanup irrespective of return value hr...
                         VariantClear(&vArray);
                         #endif
                    }            
                }
            }
        }
    }

cleanup:
    if (FAILED(hr)&&((*ppIndicateItem) != NULL))
    {
        (*ppIndicateItem)->Release();
        *ppIndicateItem = NULL;
    }
        
    if(bImpersonate)
        CoRevertToSelf();
    return hr;
}


/*++    GetCursor

Routine Description:

    GetCursor is retrieves a Cursor object based on the InvocationUUID
    and NamingContext (as multiple keys)
    

Parameters:
    bstrNamingContext         - Naming context DN used to when calling
                                DsReplicaGetInfoW
    bstrSourceDsaInvocationID - Other component of the key
    ppIndicateItem            - Pointer to the instance found
  
Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and 
        information is extracted from there... then a search is
        conducted on each cursor (trying to match the InvocationUUID)

--*/
HRESULT 
CRpcReplProv::GetCursor(
    IN BSTR bstrNamingContext,
    IN BSTR bstrSourceDsaInvocationID,
    OUT IWbemClassObject** ppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS_3W*  pCursors3 = NULL;
    DS_REPL_CURSORS*     pCursors = NULL;
    LONG nIndex = 0;
    LONG objectCount = 0L;
    BOOL fOldReplStruct = FALSE;

    ASSERT(ppIndicateItem != NULL);
    if (ppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
        if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             UnicodeDnsComputerName,
             &DnsComputerNameLength
             ) 
        )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(
             DsBindW(
                 UnicodeDnsComputerName,
                 NULL,
                 &hDS
                 )
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    //
    // First try the newer level 3 call and then drop down.
    //
    hr = HRESULT_FROM_WIN32(
             DsReplicaGetInfoW(
                hDS,                           // hDS
                DS_REPL_INFO_CURSORS_3_FOR_NC, // InfoType
                bstrNamingContext,             // pszObject
                NULL,                          // puuidForSourceDsaObjGuid,
                (void**)&pCursors3             // ppinfo
                )
             );

    if (FAILED(hr)
        && hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)
        ) {
        fOldReplStruct = TRUE;
        //
        // Need to try the lower level call as that might be supported.
        //
        hr = HRESULT_FROM_WIN32(
                 DsReplicaGetInfoW(
                     hDS,                         // hDS
                     DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
                     bstrNamingContext,             // pszObject
                     NULL,                          // puuidForSourceDsaObjGuid,
                     (void**)&pCursors              // ppinfo
                     )
                 );
    }

    if (FAILED(hr))
        goto cleanup;


    if (fOldReplStruct) {
        ASSERT(NULL != pCursors);
        objectCount = (LONG)pCursors->cNumCursors;
    }
    else {
        ASSERT(NULL != pCursors3);
        objectCount = (LONG)pCursors3->cNumCursors;
    }

    for (nIndex = 0; nIndex < objectCount; nIndex++)
    {
        DS_REPL_CURSOR  TempCursor;
        DS_REPL_CURSOR_3W TempCursor3;
        LPWSTR   UuidString = NULL;

        if (fOldReplStruct) {
             TempCursor = pCursors->rgCursor[nIndex];
        }
        else {
            TempCursor3 = pCursors3->rgCursor[nIndex];
        }

        if (UuidToStringW(
                fOldReplStruct ? 
                    &(TempCursor.uuidSourceDsaInvocationID) :
                    &(TempCursor3.uuidSourceDsaInvocationID),
                &UuidString
                ) 
            ==  RPC_S_OK
            )
        {
       
            if (lstrcmpiW(bstrSourceDsaInvocationID, UuidString) == 0)
            {
                 RpcStringFreeW(&UuidString);
                   
                 LPUNKNOWN    pTempUnknown = NULL;
                 CComVariant varItem;
    
                 hr = m_sipClassDefCursor->SpawnInstance(0, ppIndicateItem);
                 if (FAILED(hr))
                     goto cleanup;
                 ASSERT((*ppIndicateItem) != NULL);
      
                 varItem = bstrNamingContext;  
                 hr = (*ppIndicateItem)->Put(
                          L"NamingContextDN",
                          0,
                          &varItem,
                          0
                          );
                 if (FAILED(hr))
                     goto cleanup;
        
                 hr = PutLONGLONGAttribute(
                          (*ppIndicateItem),
                          L"usnattributefilter",
                          fOldReplStruct ?
                              TempCursor.usnAttributeFilter :
                              TempCursor3.usnAttributeFilter
                     );
                 if (FAILED(hr))
                     goto cleanup;
            
                 hr = PutUUIDAttribute(
                          (*ppIndicateItem),
                          L"SourceDsaInvocationID",
                          fOldReplStruct ?
                              TempCursor.uuidSourceDsaInvocationID :
                              TempCursor3.uuidSourceDsaInvocationID
                     );
                 if (FAILED(hr)) {
                     goto cleanup;
                 }
                 

                 if (!fOldReplStruct) {
                     //
                     // In this case we can populate the new attributes.
                     //
                     hr = PutFILETIMEAttribute(
                              (*ppIndicateItem),
                              L"TimeOfLastSuccessfulSync",
                              TempCursor3.ftimeLastSyncSuccess
                              );
                     if (FAILED(hr)) {
                         goto cleanup;
                     }

                     varItem =  TempCursor3.pszSourceDsaDN;
                     hr = (*ppIndicateItem)->Put(
                              L"SourceDsaDN",
                              0,
                              &varItem,
                              0
                              );
                     if (FAILED(hr))
                         goto cleanup;

                 }

                 break; // have a match, do not need to go through rest.
            }
            else {
                RpcStringFreeW(&UuidString);
            }
        }
    }
    
cleanup:
    
    if (FAILED(hr)&& (*ppIndicateItem) != NULL)
    //something failed, make sure to deallocate the spawned instance
    {
        (*ppIndicateItem)->Release();
        (*ppIndicateItem) = NULL;
    }
    
    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (pCursors3 != NULL) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    }

    if (hDS != NULL){
        DsUnBind(&hDS);
    }

    if (bImpersonate){    
        CoRevertToSelf();
    }
    return hr;
}

/*++    CreateFlatListCursors

Routine Description:

    CreateFlatListCursors is creates instances of the MSAD_ReplCursor
    object. It retrieves a list of all naming-contexts, then calls
    CreateCursorHelper, passing in the NamingContext DN. Note that this
    method calls IWbemObjectSink::Indicate for each set of cursors retrieved.

Parameters:
       NONE
  
Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and
        information is extracted from there...

--*/
HRESULT
CRpcReplProv::CreateFlatListCursors(
    IN IWbemObjectSink *pResponseHandler
    )
{
    HRESULT hr = WBEM_E_FAILED;
        
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    

        
    if (pResponseHandler == NULL)
        goto cleanup;
    
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL);    

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarDN.bstrVal != NULL);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    for (int x = 0; x < 2; x++)
    {
        CComVariant      svarArray;
        CComVariant varItem;
        SAFEARRAY *sa = NULL;
        LONG lstart, lend;
        LONG index = 0L;
    

        if (x == 0)
        {
            hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
            //
            // if we couldn't get the Master NC's then something is
            // terribly wrong, forget about the PartialNCs
            //
            if (FAILED(hr))
                goto cleanup;
        }
        else
        {
            hr = spIADsDSA->GetEx(L"hasPartialNCs", &svarArray );
            if (FAILED(hr))
            {
                //May or may not have partialNCs so don't fail
                hr = WBEM_S_NO_ERROR;
                goto cleanup;
            }
        }
            
        sa = svarArray.parray;
       // Get the lower and upper bound
       hr = SafeArrayGetLBound( sa, 1, &lstart );
       if (FAILED(hr))
          goto cleanup;

       hr = SafeArrayGetUBound( sa, 1, &lend );
       if (FAILED(hr))
           goto cleanup;
                
       for (index = lstart; index <= lend; index++)
       {
            hr = SafeArrayGetElement( sa, &index, &varItem );
            if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
            {                                
                IWbemClassObject** ppCursors = NULL;
                LONG               lObjectCount = 0L;

                //
                // Call the helper function, if it fails keep going
                //
                hr = CreateCursorHelper(
                         varItem.bstrVal,
                         &lObjectCount,
                         &ppCursors
                         );
                if (SUCCEEDED(hr))
                    pResponseHandler->Indicate( lObjectCount, ppCursors );
            }               
        }
    }
cleanup:    
    return hr;
}

/*++    CreateCursorHelper

Routine Description:

    CreateCursorHelper is a helper function that creates instances
    of the MSAD_ReplCursor object. An array of IWbemClassObject* is
    returned (as an out parameter)

Parameters:
        bstrNamingContext : Naming context DN used to create the cursors
        pObjectCount      : Pointer to number of instances returned
        pppIndicateItem   : Pointer to an array of IWbemClassObject* 's
  
Return Values:

      - WBEM_S_NO_ERROR, objects created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*,
        and information is extracted from there...

--*/
HRESULT
CRpcReplProv::CreateCursorHelper(
    IN BSTR bstrNamingContext,
    OUT LONG* pObjectCount,
    OUT IWbemClassObject*** pppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS*    pCursors  = NULL;
    DS_REPL_CURSORS_3W* pCursors3 = NULL;
    LONG nIndex = 0;
    IWbemClassObject** paIndicateItems = NULL;
    BOOL fOldReplStruct = FALSE;

    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(DsBindW(UnicodeDnsComputerName,NULL,&hDS));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    hr = HRESULT_FROM_WIN32(
             DsReplicaGetInfoW(
                 hDS,                           // hDS
                 DS_REPL_INFO_CURSORS_3_FOR_NC, // InfoType
                 bstrNamingContext,             // pszObject
                 NULL,                          // puuidForSourceDsaObjGuid
                 (void **) &pCursors3           // ppinfo
                 )
         );

    if (FAILED(hr)
        && hr == HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED)
        ) {
        fOldReplStruct = TRUE;

        hr = HRESULT_FROM_WIN32(DsReplicaGetInfoW(
                 hDS,                        // hDS
                 DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
                 bstrNamingContext,          // pszObject
                 NULL,                       // puuidForSourceDsaObjGuid,
                 (void**)&pCursors           // ppinfo
                 ));
        if (FAILED(hr))
            goto cleanup;
    }

    if (fOldReplStruct) {
        ASSERT(NULL != pCursors);
        *pObjectCount = (LONG)pCursors->cNumCursors;
    }
    else {
        ASSERT(NULL != pCursors3);
        *pObjectCount = (LONG)pCursors3->cNumCursors;
    }

    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory(paIndicateItems,(*pObjectCount) * sizeof(IWbemClassObject*));
    
        
    for (nIndex = 0; nIndex < (*pObjectCount); nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_CURSOR  TempCursor;
        DS_REPL_CURSOR_3W TempCursor3;
        CComVariant varItem;

        if (fOldReplStruct) {
             TempCursor = pCursors->rgCursor[nIndex];
        }
        else {
            TempCursor3 = pCursors3->rgCursor[nIndex];
        }
   
        hr = m_sipClassDefCursor->SpawnInstance(0, &(paIndicateItems[nIndex]));
        if (FAILED(hr))
            goto cleanup;
        ASSERT(paIndicateItems[nIndex] != NULL);
      
        varItem = bstrNamingContext;  
        hr = paIndicateItems[nIndex]->Put( L"NamingContextDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
        
        hr = PutLONGLONGAttribute(
                 paIndicateItems[nIndex],
                 L"usnattributefilter",
                 fOldReplStruct ?
                     TempCursor.usnAttributeFilter :
                     TempCursor3.usnAttributeFilter
                 );
        if (FAILED(hr))
            goto cleanup;
                        
        hr = PutUUIDAttribute(
                 paIndicateItems[nIndex],
                 L"SourceDsaInvocationID",
                 fOldReplStruct ?
                     TempCursor.uuidSourceDsaInvocationID :
                     TempCursor3.uuidSourceDsaInvocationID
                 );
        if (FAILED(hr))
            goto cleanup;

        //
        // If we have the new struct, we need to set the additional attributes.
        //
        if (!fOldReplStruct) {
            //
            // In this case we can populate the new attributes.
            //
            hr = PutFILETIMEAttribute(
                     paIndicateItems[nIndex],
                     L"TimeOfLastSuccessfulSync",
                     TempCursor3.ftimeLastSyncSuccess
                     );
            if (FAILED(hr)) {
                goto cleanup;
            }

            varItem =  TempCursor3.pszSourceDsaDN;
            hr = (paIndicateItems[nIndex])->Put(
                     L"SourceDsaDN",
                     0,
                     &varItem,
                     0
                     );
            if (FAILED(hr))
                goto cleanup;

        }
     }
    

cleanup:
    
    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (NULL != pCursors3) {
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_3_FOR_NC, pCursors3);
    }

    if (hDS != NULL)
    {
    DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}


 #ifdef EMBEDDED_CODE_SUPPORT
 /*EMBEDDED_CODE_SUPPORT*/
        HRESULT CRpcReplProv::CreateCursors(
        IN  BSTR bstrNamingContext,
        OUT SAFEARRAY** ppArray
        )
{
/*++    CreateCursors

Routine Description:

    CreateCursors is a helper function that creates instances of the MicrosoftAD_DsReplCursors object. 
    Cursors are stored as an array of embedded objects on the MicrosoftAD_DsReplNamingContext object
    This function returns a SAFEARRAY containing pointers to each instances of Cursors (as IUnknown pointers)
    
Parameters:

    bstrNamingContext    -  name of naming context used to create the cursors
    ppArray             -  array of cursors (returned)

Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplCursors*, and information is extracted from there...

--*/
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_CURSORS*    pCursors = NULL;
    IWbemClassObject* pTempInstance = NULL;
    LONG nIndex = 0;
    LONG lNumberOfCursors = 0L;
    SAFEARRAY*  pArray = NULL;

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(DsBindW(UnicodeDnsComputerName,NULL,&hDS));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    //
    // Note ********************************
    // This is not currently called as it is in an ifdef.
    // If for some reason, that is changed, then you should add
    // code similar to the other instances of cursors over here too.
    // That is you need to add l3 cursor support - AjayR - 02-10-01.
    //
    hr = HRESULT_FROM_WIN32(DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_CURSORS_FOR_NC, // InfoType
            bstrNamingContext,          // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pCursors           // ppinfo
            ));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pCursors);


    SAFEARRAYBOUND rgsabound[1];
    lNumberOfCursors = (LONG)pCursors->cNumCursors;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumberOfCursors;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
    if(pArray == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    for (nIndex = 0; nIndex < lNumberOfCursors; nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_CURSOR  TempCursor = pCursors->rgCursor[nIndex];
        CComVariant varItem;
    
        hr = m_sipClassDefCursor->SpawnInstance(0, &pTempInstance);
        if (FAILED(hr))
            goto cleanup;
           ASSERT(pTempInstance != NULL);
      
        hr = PutLONGLONGAttribute( pTempInstance,
                                    L"usnattributefilter",
                                    TempCursor.usnAttributeFilter);
        if (FAILED(hr))
            goto cleanup;
                        
        hr = PutUUIDAttribute( pTempInstance,
                          L"SourceDsaInvocationID",
                          TempCursor.uuidSourceDsaInvocationID);
        if (FAILED(hr))
            goto cleanup;
           
        hr = pTempInstance->QueryInterface(IID_IUnknown, (void**)&pTempUnknown);
        if (FAILED(hr))
            goto cleanup;
        
        hr = SafeArrayPutElement(pArray, &nIndex, pTempUnknown);          
        if (FAILED(hr))
            goto cleanup;
     }

cleanup:
    
    //In case we failed, deallocate the SafeArray
    if (FAILED(hr))
    {
        if (pArray != NULL)
        {
            SafeArrayDestroy(pArray);
            *ppArray = NULL;
        }
    }
    else
    {
        *ppArray = pArray;
    }


    if (pCursors!= NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_CURSORS_FOR_NC, pCursors);
        pCursors = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}
#endif

#ifdef EMBEDDED_CODE_SUPPORT
/*EMBEDDED_CODE_SUPPORT*/


/*++    CreatePendingOps

Routine Description:

    CreatePendingOps is a helper function that creates instances of
    the MicrosoftAD_DsReplPendingOps object. PendingOps are stored
         as an array of embedded objects on the MSAD_ReplSettings object
    This function returns a SAFEARRAY containing pointers to each instances of PendingOps (as IUnknown pointers)
    
Parameters:

    ppArray        -  pointer to SAFEARRAY*, array of pending ops

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*, and information is extracted from there...

--*/
HRESULT CRpcReplProv::CreatePendingOps(
        OUT SAFEARRAY**  ppArray 
        )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    IWbemClassObject* pTempInstance = NULL;
    LONG nIndex = 0;
    LONG lNumberOfPendingOps = 0L;
    SAFEARRAY*  pArray = NULL;

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(DsBindW(UnicodeDnsComputerName,NULL,&hDS));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    hr = HRESULT_FROM_WIN32(DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_PENDING_OPS,   // InfoType
            NULL,                       // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pPendingOps        // ppinfo
            ));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    SAFEARRAYBOUND rgsabound[1];
    lNumberOfPendingOps = (LONG)pPendingOps->cNumPendingOps;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = lNumberOfPendingOps;
    pArray = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
    if(pArray == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    for (nIndex = 0; nIndex < lNumberOfPendingOps; nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
        CComVariant varItem;
    
        hr = m_sipClassDefPendingOps->SpawnInstance(0, &pTempInstance);
        if (FAILED(hr))
            goto cleanup;
           ASSERT(pTempInstance != NULL);
      
        varItem = (LONG)TempPendingOp.ulSerialNumber;
        hr = pTempInstance->Put( L"lserialNumber", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.ulPriority;
        hr = pTempInstance->Put( L"lPriority", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.OpType;
        hr = pTempInstance->Put( L"lOpType", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           

        varItem = (LONG)TempPendingOp.ulOptions;
        hr = pTempInstance->Put( L"lOptions", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszNamingContext;
        hr = pTempInstance->Put( L"NamingContext", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaDN;
        hr = pTempInstance->Put( L"DsaDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaAddress;
        hr = pTempInstance->Put( L"DsaAddress", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
                   
        hr = PutUUIDAttribute( pTempInstance,
                          L"uuidNamingContextObjGuid",
                          TempPendingOp.uuidNamingContextObjGuid);
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutUUIDAttribute( pTempInstance,
                          L"uuidDsaObjGuid",
                          TempPendingOp.uuidDsaObjGuid);
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutFILETIMEAttribute( pTempInstance,
                            L"ftimeEnqueued",
                            TempPendingOp.ftimeEnqueued);
        if (FAILED(hr))
            goto cleanup;
           
        hr = pTempInstance->QueryInterface(IID_IUnknown, (void**)&pTempUnknown);
        if (FAILED(hr))
            goto cleanup;
        
        hr = SafeArrayPutElement(pArray, &nIndex, pTempUnknown);          
        if (FAILED(hr))
            goto cleanup;
    }
    
cleanup:
    
    //In case we failed, deallocate the SafeArray
    if (FAILED(hr))
    {
        if (pArray != NULL)
        {
            SafeArrayDestroy(pArray);
            *ppArray = NULL;
        }
    }
    else
    {
        *ppArray = pArray;
    }


    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}
#endif


HRESULT CRpcReplProv::GetPendingOps(
        IN LONG    lSerialNumber,                
        OUT IWbemClassObject** ppIndicateItem
        )
{
/*++    GetPendingOps

Routine Description:

    GetPendingOps is a helper function that gets an instance of the MicrosoftAD_DsReplPendingOps object. 
    based on the serialNumber of that PendingOp
    
Parameters:

    lSerialNumber        -  serial number
    ppIndicateItem     -  pointer to IWbemClassObject*

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*, and information is extracted from there...

--*/
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    LONG nIndex = 0;
    LONG nTotalPendingOps = 0L;  
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
    goto cleanup;
    else
    bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( ComputerNameDnsFullyQualified,
                              UnicodeDnsComputerName,
                              &DnsComputerNameLength ) )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
    goto cleanup;
    
    hr = HRESULT_FROM_WIN32(DsBindW(UnicodeDnsComputerName,NULL,&hDS));
    if (FAILED(hr))
    goto cleanup;
    ASSERT(NULL != hDS);
    
    
    hr = HRESULT_FROM_WIN32(DsReplicaGetInfoW(
            hDS,                        // hDS
            DS_REPL_INFO_PENDING_OPS,   // InfoType
            NULL,                       // pszObject
            NULL,                       // puuidForSourceDsaObjGuid,
            (void**)&pPendingOps        // ppinfo
            ));
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    for (nIndex = 0; nIndex < (LONG)pPendingOps->cNumPendingOps; nIndex++)
    {
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
            
        if (lSerialNumber == (LONG)TempPendingOp.ulSerialNumber)
        {
            //We have found a pending op
            LPUNKNOWN    pTempUnknown = NULL;
            CComVariant varItem;
    
            hr = m_sipClassDefPendingOps->SpawnInstance(0, ppIndicateItem);
            if (FAILED(hr))
                goto cleanup;
               ASSERT((*ppIndicateItem) != NULL);
      
            varItem = (LONG)TempPendingOp.ulSerialNumber;
            hr = (*ppIndicateItem)->Put( L"lserialNumber", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = (LONG)TempPendingOp.ulPriority;
            hr = (*ppIndicateItem)->Put( L"lPriority", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = (LONG)TempPendingOp.OpType;
            hr = (*ppIndicateItem)->Put( L"lOpType", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               

            varItem = (LONG)TempPendingOp.ulOptions;
            hr = (*ppIndicateItem)->Put( L"lOptions", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszNamingContext;
            hr = (*ppIndicateItem)->Put( L"NamingContext", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszDsaDN;
            hr = (*ppIndicateItem)->Put( L"DsaDN", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
               
            varItem = TempPendingOp.pszDsaAddress;
            hr = (*ppIndicateItem)->Put( L"DsaAddress", 0, &varItem, 0 );
            if (FAILED(hr))
                goto cleanup;
                       
            hr = PutUUIDAttribute( (*ppIndicateItem),
                              L"uuidNamingContextObjGuid",
                              TempPendingOp.uuidNamingContextObjGuid);
            if (FAILED(hr))
                goto cleanup;
               
            hr = PutUUIDAttribute( (*ppIndicateItem),
                              L"uuidDsaObjGuid",
                              TempPendingOp.uuidDsaObjGuid);
            if (FAILED(hr))
                goto cleanup;
               
            hr = PutFILETIMEAttribute( (*ppIndicateItem),
                                L"ftimeEnqueued",
                                TempPendingOp.ftimeEnqueued);
        }
    }
    

cleanup:
    
    if (FAILED(hr)&&((*ppIndicateItem) != NULL))
    {
        (*ppIndicateItem)->Release();
        *ppIndicateItem = NULL;
    }
        
    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}

/*++    CreateFlatListPendingOps

Routine Description:

    CreateFlatListPendingOps is a helper function that creates
    instances of the MicrosoftAD_DsReplPendingOps object. An 
    array of IWbemClassObject* is returned (as an OUT param)

Parameters:

    pObjectCount        -  pointer to number of instances
    pppIndicateItem     -  pointer to array of IWbemClassObject*

Return Values:

      - WBEM_S_NO_ERROR, array created    
      - WBEM_E_FAILED, error

Notes:
        DsReplicaGetInfo is used to get at a DsReplPendingOps*,
     and information is extracted from there...

--*/
HRESULT 
CRpcReplProv::CreateFlatListPendingOps(
    OUT LONG* pObjectCount,
    OUT IWbemClassObject*** pppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR UnicodeDnsComputerName[MAX_PATH + 1];
    ULONG DnsComputerNameLength = 
        sizeof(UnicodeDnsComputerName) / sizeof(WCHAR);
    HANDLE hDS = NULL;
    BOOL    bImpersonate = FALSE;
    DS_REPL_PENDING_OPSW*    pPendingOps = NULL;
    LONG nIndex = 0;
    IWbemClassObject** paIndicateItems = NULL;
        
    
    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if ( !GetComputerNameExW( 
              ComputerNameDnsFullyQualified,
              UnicodeDnsComputerName,
              &DnsComputerNameLength
              )
         )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(
             DsBindW(
                 UnicodeDnsComputerName,
                 NULL,
                 &hDS
                 )
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    
    
    hr = HRESULT_FROM_WIN32(
             DsReplicaGetInfoW(
                 hDS,                        // hDS
                 DS_REPL_INFO_PENDING_OPS,   // InfoType
                 NULL,                       // pszObject
                 NULL,                       // puuidForSourceDsaObjGuid,
                 (void**)&pPendingOps        // ppinfo
                 )
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != pPendingOps);


    (*pObjectCount) = (LONG)pPendingOps->cNumPendingOps;
    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory(
          paIndicateItems,
          (*pObjectCount) * sizeof(IWbemClassObject*)
          );
    
    for (nIndex = 0; nIndex < (*pObjectCount); nIndex++)
    {
        LPUNKNOWN    pTempUnknown = NULL;
        DS_REPL_OPW  TempPendingOp = pPendingOps->rgPendingOp[nIndex];
        CComVariant varItem;
    
        //
        // Create and populate the objects corresponding to the
        // pending ops data returned.
        //
        hr = m_sipClassDefPendingOps->SpawnInstance(
                 0,
                 &(paIndicateItems[nIndex])
                 );
        if (FAILED(hr))
            goto cleanup;
           ASSERT(paIndicateItems[nIndex] != NULL);
      
        varItem = (LONG)TempPendingOp.ulSerialNumber;
        hr = paIndicateItems[nIndex]->Put( L"serialNumber", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;

        varItem = nIndex;
        hr = paIndicateItems[nIndex]->Put(
                 L"PositionInQ",
                 0,
                 &varItem,
                 0
                 );
        if (FAILED(hr)) {
            goto cleanup;
        }
           
        varItem = (LONG)TempPendingOp.ulPriority;
        hr = paIndicateItems[nIndex]->Put( L"Priority", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = (LONG)TempPendingOp.OpType;
        hr = paIndicateItems[nIndex]->Put( L"OpType", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           

        varItem = (LONG)TempPendingOp.ulOptions;
        hr = paIndicateItems[nIndex]->Put( L"Options", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszNamingContext;
        hr = paIndicateItems[nIndex]->Put( L"NamingContext", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaDN;
        hr = paIndicateItems[nIndex]->Put( L"DsaDN", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
           
        varItem = TempPendingOp.pszDsaAddress;
        hr = paIndicateItems[nIndex]->Put( L"DsaAddress", 0, &varItem, 0 );
        if (FAILED(hr))
            goto cleanup;
                   
        hr = PutUUIDAttribute(
                paIndicateItems[nIndex],
                L"NamingContextObjGuid",
                TempPendingOp.uuidNamingContextObjGuid
                );
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutUUIDAttribute(
                 paIndicateItems[nIndex],
                 L"DsaObjGuid",
                 TempPendingOp.uuidDsaObjGuid
                 );
        if (FAILED(hr))
            goto cleanup;
           
        hr = PutFILETIMEAttribute(
                paIndicateItems[nIndex],
                L"timeEnqueued",
                TempPendingOp.ftimeEnqueued
                );
        if (FAILED(hr))
            goto cleanup;

        //
        // For the first item alone we can tell when it was started.
        //
        if (0 == nIndex) {
            hr = PutFILETIMEAttribute(
                     paIndicateItems[nIndex],
                     L"StartTime",
                     pPendingOps->ftimeCurrentOpStarted
                     );

            if (FAILED(hr)) {
                goto cleanup;
            }
        }
           
    }
    

cleanup:
    
    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    
    if (pPendingOps != NULL)
    {    
        DsReplicaFreeInfo(DS_REPL_INFO_PENDING_OPS, pPendingOps);
        pPendingOps = NULL;
    }

    if (hDS != NULL)
    {
        DsUnBind(&hDS);
    }
    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    return hr;
}


    
HRESULT CRpcReplProv::CreateNamingContext(
        IN BOOL    bGetMasterReplica,                
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        )
{
/*++    CreateNamingContext

Routine Description:

    This is a helper function that creates all instances of naming
    context objects.This routine reads the hasMastersNC OR the
    hasPartialNCs object off the NTDS-Settings object of the local server.
    

Parameters:

    bGetMasterReplica -  BOOLEAN, specifying whether to create partial
                         or master NamingContexts
    pppIndicateItem   -  pointer to address of array of objects
                         (IWbemClassObject**) 
    pObjectCount      -  LONG*, pointer to number of objects
                         (instances that were created)

Return Values:

     - WBEM_S_NO_ERROR, objects were created    
     - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
    
    HRESULT hr = WBEM_E_FAILED;
    *pObjectCount = 0L;

    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant      svarArray;
    CComVariant      svarDN;
    CComBSTR      bstrDSADN;    
    LONG lstart, lend;
    LONG index = 0L;
    SAFEARRAY *sa = NULL;
    CComVariant varItem;
    IWbemClassObject** paIndicateItems = NULL;
    
    

    ASSERT(pppIndicateItem != NULL);
    if (pppIndicateItem == NULL)
    {
    hr = WBEM_E_FAILED;
    goto cleanup;
    }
    
    hr = ADsOpenObject( L"LDAP://RootDSE",
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsRootDSE);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsRootDSE != NULL);    

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
    goto cleanup;

    ASSERT(svarDN.bstrVal != NULL);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( bstrDSADN,
                        NULL, NULL, ADS_SECURE_AUTHENTICATION,
                        IID_IADs, OUT (void **)&spIADsDSA);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    
    if (bGetMasterReplica)
        hr = spIADsDSA->GetEx(L"hasMasterNCs", &svarArray);
    else
        hr = spIADsDSA->GetEx(L"hasPartialReplicaNCs", &svarArray );
    
    if (FAILED(hr))
        goto cleanup;
        
    sa = svarArray.parray;
    // Get the lower and upper bound
    hr = SafeArrayGetLBound( sa, 1, &lstart );
    if (FAILED(hr))
        goto cleanup;

    hr = SafeArrayGetUBound( sa, 1, &lend );
    if (FAILED(hr))
        goto cleanup;
    
    (*pObjectCount) = (lend-lstart)+1;
    paIndicateItems = new IWbemClassObject*[(*pObjectCount)];
    if (NULL == paIndicateItems)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        goto cleanup;
    }
    ::ZeroMemory( paIndicateItems, (*pObjectCount) * sizeof(IWbemClassObject*) );
        
    for (index = lstart; index <= lend; index++)
    {
        hr = SafeArrayGetElement( sa, &index, &varItem );
        if (SUCCEEDED(hr)&&varItem.vt == VT_BSTR)
        {
            hr = m_sipClassDefNamingContext->SpawnInstance( 0, &(paIndicateItems[index]) );
            if (SUCCEEDED(hr)&&paIndicateItems[index] != NULL)
            {    
                CComVariant vTemp = bGetMasterReplica;
                #ifdef EMBEDDED_CODE_SUPPORT
                /*EMBEDDED_CODE_SUPPORT*/
                SAFEARRAY*  pArray = NULL;
                VARIANT vArray;
                #endif

                hr = paIndicateItems[index]->Put( L"DistinguishedName", 0, &varItem, 0 );
                if (FAILED(hr))
                    goto cleanup;
                                        
                hr = paIndicateItems[index]->Put( L"IsFullReplica", 0, &vTemp, 0 );
                if (FAILED(hr))
                    goto cleanup;
                
                #ifdef EMBEDDED_CODE_SUPPORT
                /*EMBEDDED_CODE_SUPPORT*/
                hr = CreateCursors(varItem.bstrVal,&pArray);
                if (FAILED(hr))
                    goto cleanup;
                
                VariantInit(&vArray);
                vArray.vt = VT_ARRAY|VT_UNKNOWN;
                vArray.parray = pArray;
                hr = paIndicateItems[index]->Put( L"cursorArray", 0, &vArray, 0 );
                VariantClear(&vArray);
                if (FAILED(hr))
                    goto cleanup;
                #endif
             }
        }
    }

cleanup:    

    if (FAILED(hr))
    {
       ReleaseIndicateArray( paIndicateItems, (*pObjectCount) );
       (*pObjectCount) = 0L;
       *pppIndicateItem = NULL;
    }
    else
    {
        *pppIndicateItem = paIndicateItems;
    }
    
    return hr;
}


/*++    GetDomainController

Routine Description:

    GetDomainContorller is a helper function that matches the "key" of
    the DomainController object to an object path (bstrKeyValue).
    Note that in this case the key is the DN of the server.

Parameters:

    bstrKeyValue    -  BSTR, from which the Server DN is extracted.
    ppIndicateItem  -  pointer to IWbemClassObject* 
                       (contains the instance, if found).

Return Values:

      - WBEM_S_NO_ERROR, object found    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object 
        (instead of direct ldap calls).

--*/
HRESULT CRpcReplProv::GetDomainController(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant svarDN;
    CComVariant svarNC;
    CComPtr<IADsPathname> spPathCracker;
    CComBSTR    bstrDSADN;    
    IWbemClassObject* pIndicateItem = NULL;
    BOOL    bImpersonate = FALSE;

    if (NULL == bstrKeyValue || IsBadStringPtrW(bstrKeyValue,0))
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }

    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
        bImpersonate = TRUE;
        
    hr = ADsOpenObject(
             L"LDAP://RootDSE",
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsRootDSE
             );
    if (FAILED(hr))
        goto cleanup;

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT( VT_BSTR == svarDN.vt );
    
    //
    // If the DN doesn't match the key value, then exit!
    // (since an incorrect DN has been provided)
    //
    if (  NULL != bstrKeyValue
        && (lstrcmpiW(svarDN.bstrVal, bstrKeyValue) != 0)
        )
    {
        hr = WBEM_E_FAILED;
        goto cleanup;
    }
    
    //
    // The defaultNamingContext attribute is also needed.
    //
    hr = spIADsRootDSE->Get(L"defaultNamingContext", &svarNC);
    if (FAILED(hr)) {
        goto cleanup;
    }
    ASSERT( VT_BSTR == svarNC.vt);

    //
    // Key value matched, so lets create an instance
    //
    hr= m_sipClassDefDomainController->SpawnInstance( 0, &pIndicateItem );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(pIndicateItem != NULL);
    
    //
    // Get the DSA object
    //
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject(
             bstrDSADN,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsDSA
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    //
    // Prepare a path cracker object
    //
    hr = CoCreateInstance(
             CLSID_Pathname,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsPathname,
             (PVOID *)&spPathCracker
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spPathCracker != NULL);

    hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    if (FAILED(hr))
        goto cleanup;

    hr = PutAttributesDC(
            pIndicateItem,
            spPathCracker,
            spIADsDSA,
            svarDN.bstrVal,
            svarNC.bstrVal
            );

cleanup:
    
    *ppIndicateItem = pIndicateItem;
    if (FAILED(hr))
    {
        //
        // Error getting DomainController object, deallocate it,
        // if SpawnInstance has been called.
        //
        if (pIndicateItem != NULL)
        {
            pIndicateItem->Release();
            pIndicateItem = NULL;
        }
    }
    if(bImpersonate)
    {    
        CoRevertToSelf();
    }    
    return hr;
}

/*++    CreateDomainController

Routine Description:

    CreateDomeainController is a helper function that creates instances of 
    the MSAD_DomainController object 
    
Parameters:

    pIndicateItem  -  pointer to IWbemClassObject* 
                     (contains the instance, if found)
    

Return Values:

      - WBEM_S_NO_ERROR, object created    
      - WBEM_E_FAILED, error

Notes:
        ADSI is used to get at the NTDS-Settings object (instead of direct
        ldap calls)

--*/
HRESULT 
CRpcReplProv::CreateDomainController(
    OUT IWbemClassObject** ppIndicateItem
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    CComPtr<IADs> spIADsRootDSE;
    CComPtr<IADs> spIADsDSA;
    CComVariant svarDN;
    CComVariant svarNC;
    CComPtr<IADsPathname> spPathCracker;
    CComBSTR    bstrDSADN;    
    IWbemClassObject* pIndicateItem = NULL;
    BOOL        bImpersonate = FALSE;

    hr= m_sipClassDefDomainController->SpawnInstance( 0, &pIndicateItem );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(pIndicateItem != NULL);
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    bImpersonate = TRUE;
        
    hr = ADsOpenObject(
             L"LDAP://RootDSE",
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsRootDSE
             );
    if (FAILED(hr))
        goto cleanup;

    hr = spIADsRootDSE->Get(L"dsServiceName", &svarDN);
    if (FAILED(hr))
        goto cleanup;
    ASSERT( VT_BSTR == svarDN.vt );

    hr = spIADsRootDSE->Get(L"defaultNamingContext", &svarNC);
    if (FAILED(hr)) {
        goto cleanup;
    }
    ASSERT( VT_BSTR == svarNC.vt);
    
    //Get the DSA object
    bstrDSADN = L"LDAP://";
    bstrDSADN += svarDN.bstrVal;
    hr = ADsOpenObject( 
             bstrDSADN,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADsDSA
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spIADsDSA != NULL);

    // Prepare a path cracker object
    hr = CoCreateInstance(
            CLSID_Pathname,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPathname,
            (PVOID *)&spPathCracker
            );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(spPathCracker != NULL);

    hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
    if (FAILED(hr))
        goto cleanup;

    hr = PutAttributesDC(
             pIndicateItem,
             spPathCracker,
             spIADsDSA,
             svarDN.bstrVal,
             svarNC.bstrVal
             );
cleanup:
    
    if(bImpersonate)
    {    
        CoRevertToSelf();
    }    
    
    if (FAILED(hr))
    {
        //
        // We failed to create DomainController object, deallocate object
        //
        pIndicateItem->Release();
        pIndicateItem = NULL;
    }
    *ppIndicateItem = pIndicateItem;
    return hr;
}


/*++    PutAttributesDC

Routine Description:

    This function fills attribute values on a 
    MSAD_DomainController object (via pIndicateItem)

Parameters:

    pPathCracker        -  pointer to path cracker object
    pIndicateItem       -  pointer to IWbemClassObject* 
    spIADsDSA           -  pointer to IADs
    bstrDN              -  DN of Server

Return Values:

     
Notes:
        ADSI is used to get at the NTDS-Settings object
        (instead of direct ldap calls)

--*/
HRESULT
CRpcReplProv::PutAttributesDC(
    IN IWbemClassObject*    pIndicateItem,
    IN IADsPathname*        pPathCracker,
    IN IADs*                spIADsDSA,
    IN BSTR                 bstrDN,
    IN BSTR                 bstrDefaultNC 
    )
{
    WBEM_VALIDATE_INTF_PTR( pIndicateItem );
    WBEM_VALIDATE_INTF_PTR( pPathCracker );

    HRESULT hr = WBEM_S_NO_ERROR;
    CComVariant svar;
    CComVariant svar2;
    BOOL fBoolVal;
    BOOL fBool;
    
    #ifdef EMBEDDED_CODE_SUPPORT
    /*EMBEDDED_CODE_SUPPORT*/
    SAFEARRAY*  pArray = NULL;    
    #endif

    CComBSTR sbstrServerCN, sbstrSite, sbstrObjectGUID;
    VARIANT vObjGuid;
    LPWSTR pszStrGuid = NULL;
    DWORD dwPercentRidAvailable;
    VariantInit(&vObjGuid);

    do 
    {
        hr = spIADsDSA->Get(L"objectGuid", &vObjGuid);
        BREAK_ON_FAIL;

        ASSERT( (VT_ARRAY|VT_UI1) == vObjGuid.vt);
        
        hr = ConvertBinaryGUIDtoUUIDString(
                 vObjGuid,
                 &pszStrGuid
                 );
        BREAK_ON_FAIL;

        //
        // The Guid needs to be put as a UUID attribute.
        //
        svar = pszStrGuid;
        ASSERT( VT_BSTR == svar.vt );

        hr = pIndicateItem->Put( L"NTDsaGUID", 0, &svar, 0 );
        BREAK_ON_FAIL;
        
        hr = pPathCracker->Set(bstrDN , ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 1L, &sbstrServerCN );
        BREAK_ON_FAIL;
        hr = pPathCracker->GetElement( 3L, &sbstrSite );
        BREAK_ON_FAIL;

        svar = bstrDN;
        hr = pIndicateItem->Put( L"DistinguishedName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrServerCN;
        hr = pIndicateItem->Put( L"CommonName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSite;
        hr = pIndicateItem->Put( L"SiteName", 0, &svar, 0 );
        BREAK_ON_FAIL;

        
        //check to see if DC is a GC...
        hr = spIADsDSA->Get(L"options", &svar);
        svar2 = false;
        if (hr == S_OK)
        {
            if  ((svar.vt == VT_I4)&&(NTDSDSA_OPT_IS_GC & svar.lVal))
            {
                svar2 = true;
            }
        }
        hr = pIndicateItem->Put( L"IsGC", 0, &svar2, 0 );
        BREAK_ON_FAIL;

        //
        // Query the status of DNS updates performed by netlogon.
        //
        hr = GetDNSRegistrationStatus(&fBool);
        //
        // For the the client whose server does not have support of NETLOGON_CONTROL_QUERY_DNS_REG
        // it is OK to fail
        //
        if(SUCCEEDED(hr)) {
            svar2 = fBool;
            hr = pIndicateItem->Put( L"IsRegisteredInDNS", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }

        //
        // IsAdvertisingToLocator.
        //
        hr = GetAdvertisingToLocator(&fBoolVal);
        //
        // This is defaulted to false, so even if the read
        // failed, it is ok to proceed.
        //      
        if (SUCCEEDED(hr)) {
            svar2 = fBoolVal;
            hr = pIndicateItem->Put(L"IsAdvertisingToLocator", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }
        
        hr = GetSysVolReady(&fBoolVal);
        if (SUCCEEDED(hr)) {
            svar2 = fBoolVal;
            hr = pIndicateItem->Put(L"IsSysVolReady", 0, &svar2, 0);
            BREAK_ON_FAIL;
        }

        hr = GetRidStatus(
                 bstrDefaultNC,
                 &fBoolVal,
                 &dwPercentRidAvailable
                 );
        BREAK_ON_FAIL;

        svar2 = fBoolVal;
        hr = pIndicateItem->Put(L"IsNextRIDPoolAvailable", 0, &svar2, 0);
        BREAK_ON_FAIL;

        svar2 = (LONG) dwPercentRidAvailable;
        hr = pIndicateItem->Put(L"PercentOfRIDsLeft", 0, &svar2, 0);
        BREAK_ON_FAIL;

        //
        // Now the queue statistics. The function will fail on Win2k platform. So for the compatibility with win2k, we
        // do not bail out and clear the error code
        //
        hr = GetAndUpdateQueueStatistics(pIndicateItem);
        hr = WBEM_S_NO_ERROR;
        
        
        #ifdef EMBEDDED_CODE_SUPPORT
        /*EMBEDDED_CODE_SUPPORT*/
        //Get PendingOps, note that these are embedded objects (stored in a SAFEARRAY)
        hr = CreatePendingOps(&pArray);
        BREAK_ON_FAIL;

        VARIANT vTemp;
        VariantInit(&vTemp);
        vTemp.vt = VT_ARRAY|VT_UNKNOWN;
        vTemp.parray = pArray;
        hr = pIndicateItem->Put( L"pendingOpsArray", 0, &vTemp, 0 );
        VariantClear(&vTemp);
        BREAK_ON_FAIL;
        #endif    
        
    } while (false);

    //
    // Cleanup strings and variant if need be.
    //
    if (pszStrGuid) {
        RpcStringFreeW(&pszStrGuid);
    }

    VariantClear(&vObjGuid);

    return hr;
}

HRESULT 
CRpcReplProv::GetDNSRegistrationStatus(
    OUT BOOL *pfBool
    )
{
    PNETLOGON_INFO_1 NetlogonInfo1 = NULL;
    LPBYTE InputDataPtr = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;
    NET_API_STATUS NetStatus = 0;
    DWORD dwSize = 0;
    LPWSTR pszName = NULL;

    *pfBool = FALSE;

    //
    // Get the length of this computers name and alloc buffer
    // and retrieve the name.
    //
    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (FAILED(hr))
            goto cleanup;
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             pszName,
             &dwSize
             )
        ) {
        //
        // Call failed for some reason.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        if (FAILED(hr))
            goto cleanup;
    }
        
    NetStatus = I_NetLogonControl2( pszName,    // this is the name of server where to execute this RPC call
                                     NETLOGON_CONTROL_QUERY_DNS_REG,
                                     1,
                                     (LPBYTE) &InputDataPtr,
                                     (LPBYTE *)&NetlogonInfo1
                                     );

    if ( NetStatus == NO_ERROR ) {
        if ( NetlogonInfo1->netlog1_flags & NETLOGON_DNS_UPDATE_FAILURE ) {
            *pfBool = FALSE;
        } 
        else {
            *pfBool = TRUE;
        }
    }

    hr = HRESULT_FROM_WIN32( NetStatus );

cleanup:

    if(pszName) {
    	delete [] pszName;
    }

    if(NetlogonInfo1) {
    	NetApiBufferFree( NetlogonInfo1 );
    }
    return hr;
    
}





/*++    THE FOLLOWING COMMENT APPLIES TO THE NEXT 11 functions

        EnumAndIndicateReplicaSourcePartner, EnumAndIndicateWorker, BuildIndicateArrayStatus, ReleaseIndicateArray
        BuildListStatus, ExtractDomainName: 
            Are helper functions that facilitate the creation or the retrieval of instances of the 
        MicrosoftAD_ReplicaSourcePartner object. 
        
        PutAttributesStatus, PutUUIDAttribute, PutLONGLONGAttribute, PutFILETIMEAttribute
        PutBooleanAttributes: 
        Are helper functions that fill attribute values on the MicrosoftAD_ReplicaSourcePartner object.

        The following steps occur:
            
            1) CoImpersonateClient is called
            2) DsReplicaGetInfo is called
            3) Information is extracted, to build an array of "connections"
            4) Object is checked against the key value 
                If kevalue != NULL, then 
                    If keyvalue matches "key" of object then, that object is returned, and the array is deallocated
                    Otherwise S_FALSE is returned and the array is deallocated
                If keyvalue == NULL
                    Then CreateInstanceEnumAsync is the caller. That means all instances are returned 
            5) IWbemObjectSink::Indicate and IWbemObjectSink::SetStatus are called  
            6) CoRevertToSelf is called

--*/

HRESULT 
CRpcReplProv::EnumAndIndicateReplicaSourcePartner(
    IN IWbemObjectSink *pResponseHandler,
    IN const BSTR bstrKeyValue
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HANDLE hDS = NULL;
    bool fImpersonating = false;

    TCHAR achComputerName[MAX_PATH];
    DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
    
    
    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        fImpersonating = true;

    if ( !GetComputerNameEx(
             ComputerNameDnsFullyQualified,  
             achComputerName,
             &dwSize 
             )
         )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(
             DsBind(
                 achComputerName, // DomainControllerName
                 NULL,            // DnsDomainName
                 &hDS             // phDS
                 )
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT( NULL != hDS );

    hr = EnumAndIndicateWorker(
             hDS,
             pResponseHandler,
             bstrKeyValue 
             );
cleanup:
        
    if (fImpersonating)
    {
        // CODEWORK do we want to keep impersonating and reverting?
        HRESULT hr2 = CoRevertToSelf();
        ASSERT( !FAILED(hr2) );
    }

    if (NULL != hDS)
    {
        (void) DsUnBind( &hDS );
    }
    return hr;
}


HRESULT 
CRpcReplProv::EnumAndIndicateWorker(
    IN HANDLE hDS,
    IN IWbemObjectSink *pResponseHandler,
    IN const BSTR bstrKeyValue,
    IN const BSTR bstrDnsDomainName
    )
{
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrKeyValue);
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL(bstrDnsDomainName);

    HRESULT hr = WBEM_S_NO_ERROR;
    HRESULT hr2 = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBORSW* pneighborsstruct = NULL;
    DS_DOMAIN_CONTROLLER_INFO_1 * pDCs = NULL; // BUGBUG not needed
    ULONG cDCs = 0;
    DWORD cIndicateItems = 0;
    IWbemClassObject** paIndicateItems = NULL;

    hr = BuildListStatus( hDS, &pneighborsstruct );
    if (FAILED(hr))
        goto cleanup;

    hr = BuildIndicateArrayStatus( 
             pneighborsstruct,
             bstrKeyValue,
             &paIndicateItems,
             &cIndicateItems
             );
    if (FAILED(hr))
        goto cleanup;

    //
    // Send the objects to the caller
    //
    // [In] param, no need to addref.
    hr2 = pResponseHandler->Indicate( cIndicateItems, paIndicateItems );

    // Let CIMOM know you are finished
    // return value and SetStatus param should be consistent, so ignore
    // the return value from SetStatus itself (in retail builds)
    hr = pResponseHandler->SetStatus( WBEM_STATUS_COMPLETE, hr2,
                                              NULL, NULL );
    ASSERT( !FAILED(hr) );

cleanup:
        
    ReleaseIndicateArray( paIndicateItems, cIndicateItems );

    if ( NULL != pneighborsstruct )
    {
        (void) DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pneighborsstruct );
    }
    if ( NULL != pDCs )
    {
        (void) NetApiBufferFree( pDCs );
    }

    return hr;
}


HRESULT 
CRpcReplProv::BuildIndicateArrayStatus(
    IN  DS_REPL_NEIGHBORSW*  pneighborstruct,
    IN  const BSTR          bstrKeyValue,
    OUT IWbemClassObject*** ppaIndicateItems,
    OUT DWORD*              pcIndicateItems
    )
{
    WBEM_VALIDATE_IN_STRUCT_PTR( pneighborstruct, DS_REPL_NEIGHBORSW );
    WBEM_VALIDATE_IN_MULTISTRUCT_PTR( pneighborstruct->rgNeighbor,
                                      DS_REPL_NEIGHBORSW,
                                      pneighborstruct->cNumNeighbors );
    WBEM_VALIDATE_IN_STRING_PTR_OPTIONAL( bstrKeyValue );
    WBEM_VALIDATE_OUT_PTRPTR( ppaIndicateItems );
    WBEM_VALIDATE_OUT_STRUCT_PTR( pcIndicateItems, DWORD );

    HRESULT hr = WBEM_S_NO_ERROR;
    DS_REPL_NEIGHBORW* pneighbors = pneighborstruct->rgNeighbor;
    DWORD cneighbors = pneighborstruct->cNumNeighbors;
    if (0 == cneighbors)
        return WBEM_S_NO_ERROR;

    IWbemClassObject** paIndicateItems = NULL;
    DWORD cIndicateItems = 0;

    *ppaIndicateItems = NULL;
    *pcIndicateItems = 0;

    do
    {
        paIndicateItems = new IWbemClassObject*[cneighbors];
        if (NULL == paIndicateItems)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }
        ::ZeroMemory( paIndicateItems, cneighbors * sizeof(IWbemClassObject*) );
        for (DWORD i = 0; i < cneighbors; i++)
        {
            DS_REPL_NEIGHBORW* pneighbor = &(pneighbors[i]);

            hr = PutAttributesStatus(
                     &paIndicateItems[cIndicateItems],
                     bstrKeyValue,
                     pneighbor
                     );
            if (S_FALSE == hr)
                continue;
            cIndicateItems++;
            BREAK_ON_FAIL;
        }

    } while (false);

    if (!FAILED(hr))
    {
        *ppaIndicateItems = paIndicateItems;
        *pcIndicateItems  = cIndicateItems;
    }
    else
    {
        ReleaseIndicateArray( paIndicateItems, cneighbors );
    }

    if (bstrKeyValue 
        && *bstrKeyValue
        && *pcIndicateItems
        && hr == S_FALSE ) {
        //
        // We were looking for just one entry and we found it
        //
        hr = S_OK;
    }
    return hr;
}

void CRpcReplProv::ReleaseIndicateArray(
    IWbemClassObject**  paIndicateItems,
    DWORD               cIndicateItems,
    bool                fReleaseArray)
{
    if (paIndicateItems != NULL)
    {
        for (DWORD i = 0; i < cIndicateItems; i++)
        {
            if (NULL != paIndicateItems[i])
                paIndicateItems[i]->Release();
        }
        if (fReleaseArray)
        {
            delete[] paIndicateItems;
        }
        else
        {
            ::ZeroMemory( *paIndicateItems,
                          cIndicateItems * sizeof(IWbemClassObject*) );

        }
    }
}


// does not validate resultant structs coming from API
HRESULT CRpcReplProv::BuildListStatus(
    IN HANDLE hDS,
    OUT DS_REPL_NEIGHBORSW** ppneighborsstruct )
{
   WBEM_VALIDATE_OUT_STRUCT_PTR(ppneighborsstruct,DS_REPL_NEIGHBORSW*);

   HRESULT hr = WBEM_S_NO_ERROR;

   do {
       hr = HRESULT_FROM_WIN32(
                DsReplicaGetInfoW(
                    hDS,                        // hDS
                    DS_REPL_INFO_NEIGHBORS,     // InfoType
                    NULL,                       // pszObject
                    NULL,                       // puuidForSourceDsaObjGuid,
                    (void**)ppneighborsstruct   // ppinfo
                    )
                );
       BREAK_ON_FAIL;

       if ( BAD_IN_STRUCT_PTR(*ppneighborsstruct,DS_REPL_NEIGHBORSW) )
       {
           break;
       }

   } while (false);

   return hr;
}

//
// if this returns S_FALSE, skip this connection but do not
// consider this an error
//
HRESULT 
CRpcReplProv::PutAttributesStatus(
    IWbemClassObject**  pipNewInst,
    const BSTR          bstrKeyValue,
    DS_REPL_NEIGHBORW*   pneighbor
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LPWSTR   UuidString = NULL;

    if (   BAD_IN_STRING_PTR(pneighbor->pszNamingContext)
        || BAD_IN_STRING_PTR(pneighbor->pszSourceDsaDN)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszSourceDsaAddress)
        || BAD_IN_STRING_PTR_OPTIONAL(pneighbor->pszAsyncIntersiteTransportDN)
       )
    {
        return S_FALSE;
    }

    CComPtr<IADsPathname> spPathCracker;
    CComBSTR sbstrReplicatedDomain, // DNS name of replicated domain
    sbstrSourceServer,     // CN= name of source server
    sbstrSourceSite,       // name of site containing source server
    sbstrCompositeName;    // composite name for WMI

    do {
        hr = ExtractDomainName(
                 pneighbor->pszNamingContext,
                 &sbstrReplicatedDomain
                 );
        BREAK_ON_FAIL;

        boolean bIsConfigNC = (0 == _wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Configuration,",
                                             17));
        boolean bIsSchemaNC = (0 == _wcsnicmp(pneighbor->pszNamingContext,
                                             L"CN=Schema,",
                                             10));
        boolean bIsDeleted = (pneighbor->pszSourceDsaDN 
                              && (wcsstr( 
                                      pneighbor->pszSourceDsaDN,
                                      L"\nDEL:"
                                      )
                                  || wcsstr(
                                      pneighbor->pszSourceDsaDN,
                                      L"\\0ADEL:"
                                      )
                                  )
                              );

        //
        // retrieve source server name and site name
        //
        hr = CoCreateInstance(
                 CLSID_Pathname,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IADsPathname,
                 (PVOID *)&spPathCracker
                 );
        BREAK_ON_FAIL;
        ASSERT( !!spPathCracker );
        hr = spPathCracker->Set( pneighbor->pszSourceDsaDN, ADS_SETTYPE_DN );
        BREAK_ON_FAIL;
        hr = spPathCracker->SetDisplayType( ADS_DISPLAY_VALUE_ONLY );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 1L, &sbstrSourceServer );
        BREAK_ON_FAIL;
        hr = spPathCracker->GetElement( 3L, &sbstrSourceSite );
        BREAK_ON_FAIL;

        //
        // Build the composite name.
        // This will be something like :
        // MSAD_ReplNeighbor.NamingContextDN="dc=config,dc=mycom ...",
        // SourceDsaObjGuid="245344d6-018e-49a4-b592-f1974fd91cc6"
        //
        sbstrCompositeName = strKeyReplNeighbor;
        sbstrCompositeName += pneighbor->pszNamingContext;
        sbstrCompositeName += L"\",";
        sbstrCompositeName += strKeyReplNeighborGUID;
        //
        // Need to get the UUID in the correct format now.
        //

        if (UuidToStringW(
                &pneighbor->uuidSourceDsaObjGuid,
                &UuidString
                ) != RPC_S_OK
            ) {
            hr = WBEM_E_FAILED;
        }
        BREAK_ON_FAIL;

        sbstrCompositeName += UuidString;
        sbstrCompositeName += L"\"";

        if(UuidString != NULL)
            RpcStringFreeW(&UuidString);

        //
        // Test the composite name against the key value
        //
        if (   NULL != bstrKeyValue
            && (lstrcmpiW(sbstrCompositeName, bstrKeyValue) != 0)
        )
        {
            hr = S_FALSE;
            break;
        }

        //
        // Create a new instance of the data object
        //
        hr = m_sipClassDefReplNeighbor->SpawnInstance( 0, pipNewInst );
        BREAK_ON_FAIL;
        IWbemClassObject* ipNewInst = *pipNewInst;
        if (NULL == ipNewInst)
        {
            hr = S_FALSE;
            break;
        }

        CComVariant svar;

        svar = pneighbor->pszNamingContext;
        hr = ipNewInst->Put( L"NamingContextDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaDN;
        hr = ipNewInst->Put( L"SourceDsaDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszSourceDsaAddress;
        hr = ipNewInst->Put( L"SourceDsaAddress", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = pneighbor->pszAsyncIntersiteTransportDN;
        hr = ipNewInst->Put( L"AsyncIntersiteTransportDN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwReplicaFlags;
        hr = ipNewInst->Put( L"ReplicaFlags", 0, &svar, 0 );
        BREAK_ON_FAIL;

        if (bIsDeleted)
        {
            svar = TRUE;
            hr = ipNewInst->Put( L"IsDeletedSourceDsa", 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
        
        svar = sbstrSourceSite;
        hr = ipNewInst->Put( L"SourceDsaSite", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrSourceServer;
        hr = ipNewInst->Put( L"SourceDsaCN", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = sbstrReplicatedDomain;
        hr = ipNewInst->Put( L"Domain", 0, &svar, 0 );
        BREAK_ON_FAIL;

LPCWSTR aBooleanAttrNames[12] = {
    L"Writeable",
    L"SyncOnStartup",
    L"DoScheduledSyncs",
    L"UseAsyncIntersiteTransport",
    L"TwoWaySync",
    L"FullSyncInProgress",
    L"FullSyncNextPacket",
    L"NeverSynced",
    L"IgnoreChangeNotifications",
    L"DisableScheduledSync",
    L"CompressChanges",
    L"NoChangeNotifications"
    };

DWORD aBitmasks[12] = {
    DS_REPL_NBR_WRITEABLE,
    DS_REPL_NBR_SYNC_ON_STARTUP,
    DS_REPL_NBR_DO_SCHEDULED_SYNCS,
    DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT,
    DS_REPL_NBR_TWO_WAY_SYNC,
    DS_REPL_NBR_FULL_SYNC_IN_PROGRESS,
    DS_REPL_NBR_FULL_SYNC_NEXT_PACKET,
    DS_REPL_NBR_NEVER_SYNCED,
    DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS,
    DS_REPL_NBR_DISABLE_SCHEDULED_SYNC,
    DS_REPL_NBR_COMPRESS_CHANGES,
    DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS
    };

    hr = PutBooleanAttributes(
             ipNewInst,
             12,
             aBooleanAttrNames,
             aBitmasks,
             pneighbor->dwReplicaFlags
             );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"NamingContextObjGuid",
                                pneighbor->uuidNamingContextObjGuid );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                               L"SourceDsaObjGuid",
                               pneighbor->uuidSourceDsaObjGuid );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"SourceDsaInvocationID",
                                pneighbor->uuidSourceDsaInvocationID );
        BREAK_ON_FAIL;

        hr = PutUUIDAttribute( ipNewInst,
                                L"AsyncIntersiteTransportObjGuid",
                                pneighbor->uuidAsyncIntersiteTransportObjGuid );
        BREAK_ON_FAIL;

        hr = PutLONGLONGAttribute( ipNewInst,
                                    L"USNLastObjChangeSynced",
                                    pneighbor->usnLastObjChangeSynced);
        BREAK_ON_FAIL;

        hr = PutLONGLONGAttribute( ipNewInst,
                                    L"USNAttributeFilter",
                                    pneighbor->usnAttributeFilter);
        BREAK_ON_FAIL;

        hr = PutFILETIMEAttribute( ipNewInst,
                                    L"TimeOfLastSyncSuccess",
                                    pneighbor->ftimeLastSyncSuccess);
        BREAK_ON_FAIL;

        hr = PutFILETIMEAttribute( ipNewInst,
                                    L"TimeOfLastSyncAttempt",
                                    pneighbor->ftimeLastSyncAttempt);
        BREAK_ON_FAIL;

        svar = (long)pneighbor->dwLastSyncResult;
        hr = ipNewInst->Put( L"LastSyncResult", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)pneighbor->cNumConsecutiveSyncFailures;
        hr = ipNewInst->Put( L"NumConsecutiveSyncFailures", 0, &svar, 0 );
        BREAK_ON_FAIL;

        svar = (long)((bIsDeleted) ? 
                      0L 
                      : pneighbor->cNumConsecutiveSyncFailures);
        hr = ipNewInst->Put( 
                 L"ModifiedNumConsecutiveSyncFailures",
                 0,
                 &svar,
                 0
                 );
        BREAK_ON_FAIL;

    } while (false);

    return hr;
}


HRESULT CRpcReplProv::PutUUIDAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    UUID&             refuuid)
{
    LPWSTR   UuidString = NULL;
    HRESULT hr = WBEM_E_FAILED;
    CComVariant svar;
     
    if (UuidToStringW(&refuuid, &UuidString) == RPC_S_OK)
    {
        svar = UuidString;
        hr = ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
    }
    else
    {
        hr = WBEM_E_FAILED;
    }

    if(UuidString != NULL)
        RpcStringFreeW(&UuidString);    
        
    return hr; 
}


HRESULT CRpcReplProv::PutLONGLONGAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    LONGLONG          longlong)
{
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    _ui64tow( longlong, ach, 10 );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT CRpcReplProv::PutFILETIMEAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    FILETIME&         reffiletime)
{
    SYSTEMTIME systime;
    ::ZeroMemory( &systime, sizeof(SYSTEMTIME) );
    if ( !FileTimeToSystemTime( &reffiletime, &systime ) )
    {
        return HRESULT_FROM_WIN32(::GetLastError());
    }
    CComVariant svar;
    OLECHAR ach[MAX_PATH];
    ::ZeroMemory( ach, sizeof(ach) );
    swprintf( ach, L"%04u%02u%02u%02u%02u%02u.%06u+000", 
        systime.wYear,
        systime.wMonth,
        systime.wDay,
        systime.wHour,
        systime.wMinute,
        systime.wSecond,
        systime.wMilliseconds
        );
    svar = ach;
    return ipNewInst->Put( pcszAttributeName, 0, &svar, 0 );
}


HRESULT CRpcReplProv::PutBooleanAttributes(
    IWbemClassObject* ipNewInst,
    UINT              cNumAttributes,
    LPCWSTR*          aAttributeNames,
    DWORD*            aBitmasks,
    DWORD             dwValue)
{
    WBEM_VALIDATE_READ_PTR( aAttributeNames, cNumAttributes*sizeof(LPCTSTR) );
    WBEM_VALIDATE_READ_PTR( aBitmasks,       cNumAttributes*sizeof(DWORD) );

    HRESULT hr = WBEM_S_NO_ERROR; 
    CComVariant svar = true;
    for (UINT i = 0; i < cNumAttributes; i++)
    {
        WBEM_VALIDATE_IN_STRING_PTR( aAttributeNames[i] );
        if (dwValue & aBitmasks[i])
        {
            hr = ipNewInst->Put( aAttributeNames[i], 0, &svar, 0 );
            BREAK_ON_FAIL;
        }
    }
    return hr;
}


HRESULT CRpcReplProv::ExtractDomainName(
    IN LPCWSTR pszNamingContext,
    OUT BSTR*   pbstrDomainName )
{
    WBEM_VALIDATE_IN_STRING_PTR( pszNamingContext );
    WBEM_VALIDATE_OUT_PTRPTR( pbstrDomainName );

    PDS_NAME_RESULTW pDsNameResult = NULL;
    HRESULT hr = WBEM_S_NO_ERROR;

    do {
        DWORD dwErr = DsCrackNamesW(
                (HANDLE)-1,
                DS_NAME_FLAG_SYNTACTICAL_ONLY,
                DS_FQDN_1779_NAME,
                DS_CANONICAL_NAME,
                1,
                &pszNamingContext,
                &pDsNameResult);
        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32( dwErr );
            break;
        }
        if (   BAD_IN_STRUCT_PTR(pDsNameResult,DS_NAME_RESULT)
            || 1 != pDsNameResult->cItems
            || DS_NAME_NO_ERROR != pDsNameResult->rItems->status
            || BAD_IN_STRUCT_PTR(pDsNameResult->rItems,DS_NAME_RESULT_ITEM)
            || BAD_IN_STRING_PTR(pDsNameResult->rItems->pDomain)
           )
        {
            hr = WBEM_E_FAILED;
            break;
        }

        *pbstrDomainName = ::SysAllocString(pDsNameResult->rItems->pDomain);
        if (NULL == *pbstrDomainName)
        {
            hr = WBEM_E_OUT_OF_MEMORY;
            break;
        }

    } while (false);

    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}

/*++  ExecuteKCC

Routine Description:

    This function is a helper function that is a wrapper for
    the DsReplicaConsistencyCheck RPC call.

Parameters:

    pInstance        -  pointer to instance of MSAD_DomainContoller class

Return Values:

      - WBEM_S_NO_ERROR, success    
      - WBEM_E_FAILED, error
      - RPC errors (translated to HRESULTS)

Notes:
        CoImpersonateClient and CoRevertToSelf are used "around" the RPC call.

--*/
HRESULT 
CRpcReplProv::ExecuteKCC(
    IN IWbemClassObject* pInstance,
    IN DWORD dwTaskId,
    IN DWORD dwFlags
    )
{
    HANDLE            hDS            = NULL;
    HRESULT            hr            = WBEM_E_FAILED;
    CComVariant        vDRA;
    CComBSTR        bstrCommonName = L"CommonName"; 
    BOOLEAN            bImpersonate = FALSE;

    hr = pInstance->Get(
             bstrCommonName,
             0,
             &vDRA,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(vDRA.bstrVal != NULL);
    
    hr = CoImpersonateClient();
        if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    hr = HRESULT_FROM_WIN32(
             DsBindW(
                 vDRA.bstrVal,    // DomainControllerName
                 NULL,            // DnsDomainName
                 &hDS             // phDS
                 )
             );
    ASSERT(NULL != hDS);
    if (FAILED(hr))
        goto cleanup;
    ASSERT(hDS != NULL);

    hr = HRESULT_FROM_WIN32(
             DsReplicaConsistencyCheck(
                 hDS,
                 (DS_KCC_TASKID)dwTaskId,
                 dwFlags
                 )
             );    //only use synchronous ExecKCC

cleanup: 
    if (hDS)
        DsUnBindW(&hDS);

    if(bImpersonate)
        CoRevertToSelf();
       
    return hr;
}

/*++    ProvDSReplicaSync

Routine Description:

    This function is a helper function that is a wrapper
    for the DsReplicaSync RPC call


Parameters:

    bstrKeyValue  -  KeyValue containing object path of
                     MSAD_Connections object.
                     That should be MSAD_ReplNeighbors class.
    dwOptions     -  Type of sync call to make.                 


Return Values:

      - WBEM_S_NO_ERROR, success    
      - WBEM_E_FAILED, error
      - RPC errors (translated to HRESULTS)

Notes:
        CoImpersonateClient and CoRevertToSelf are used "around" the RPC call.

--*/
HRESULT 
CRpcReplProv::ProvDSReplicaSync(
    IN BSTR    bstrKeyValue,
    IN ULONG   dwOptions
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    HANDLE hDS = NULL;
    DS_REPL_NEIGHBORSW* pneighborsstruct = NULL;
    DWORD cIndicateItems = 0;
    IWbemClassObject** paIndicateItems = NULL;
    TCHAR achComputerName[MAX_PATH];
    DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
    CComBSTR    sbstrNamingContextDN = L"NamingContextDN";
    CComBSTR    sbstrObjectGUID = L"SourceDsaObjGuid";
    CComVariant    svarUUID;
    CComVariant    svarNamingContextDN;
    UUID        uuid;
    BOOL    bImpersonate = FALSE;


    hr = CoImpersonateClient();
    if (FAILED(hr))
        goto cleanup;
    else
        bImpersonate = TRUE;
    
    
    if (!GetComputerNameEx(
             ComputerNameDnsFullyQualified,  
             achComputerName,
             &dwSize
             )
        )
    {
        hr = HRESULT_FROM_WIN32(::GetLastError());
    }
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(
             DsBind(
                 achComputerName, // DomainControllerName
                 NULL,            // DnsDomainName
                 &hDS             // phDS
                 )
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(NULL != hDS);
    

    hr = BuildListStatus( hDS, &pneighborsstruct );
    if (FAILED(hr))
        goto cleanup;

    hr = BuildIndicateArrayStatus(
             pneighborsstruct,
             bstrKeyValue,
             &paIndicateItems,
             &cIndicateItems
             );
    if (FAILED(hr))
        goto cleanup;

    if (hr == S_FALSE) {
        //
        // We could not find the matching entry
        //
        hr = WBEM_E_NOT_FOUND;
        goto cleanup;
    }
    
    if (cIndicateItems < 1) {
        hr = WBEM_E_INVALID_OBJECT_PATH;
    }
    
    hr = paIndicateItems[0]->Get(
             sbstrNamingContextDN,
             0,
             &svarNamingContextDN,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarNamingContextDN.bstrVal != NULL);

    hr = paIndicateItems[0]->Get(
             sbstrObjectGUID,
             0,
             &svarUUID,
             NULL,
             NULL
             );
    if (FAILED(hr))
        goto cleanup;
    ASSERT(svarUUID.bstrVal != NULL);

    
    hr = HRESULT_FROM_WIN32(UuidFromStringW(svarUUID.bstrVal, &uuid));
    if (FAILED(hr))
        goto cleanup;
    
    hr = HRESULT_FROM_WIN32(
             DsReplicaSyncW(
                 hDS, 
                 svarNamingContextDN.bstrVal,           
                 &uuid,
                 dwOptions
                 )
             );
 
cleanup:
    
    ReleaseIndicateArray( paIndicateItems, cIndicateItems );

    if (bImpersonate)
    {    
        CoRevertToSelf();
    }
    if (NULL != pneighborsstruct)
    {
        (void) DsReplicaFreeInfo( DS_REPL_INFO_NEIGHBORS, pneighborsstruct );
    }
    if (NULL != hDS)
    {
        DsUnBind(&hDS);
    }
    return hr;
}


HRESULT CRpcReplProv::CheckIfDomainController()
{
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomaininfo = NULL;
    HRESULT hr = WBEM_E_FAILED;
    
    hr = HRESULT_FROM_WIN32(DsRoleGetPrimaryDomainInformation(
        NULL,                           // lpServer = local machine
        DsRolePrimaryDomainInfoBasic,   // InfoLevel
        (PBYTE*)&pdomaininfo            // pBuffer
        ));
    if (FAILED(hr))
        goto cleanup;
    ASSERT( NULL != pdomaininfo );
    
    if((pdomaininfo->MachineRole == DsRole_RoleBackupDomainController)||
        (pdomaininfo->MachineRole == DsRole_RolePrimaryDomainController))
    {
        // this is a DC
        hr = WBEM_S_NO_ERROR;
    }

cleanup:    
    if (NULL != pdomaininfo)
        {
            DsRoleFreeMemory( pdomaininfo );
        }
    return hr;
}

/*
Input should be a variant that is a VT_ARRAY | VT_UI1 that is the 
length of a GUID. Output is the equivalen UUID in readable string format.
*/
HRESULT CRpcReplProv::ConvertBinaryGUIDtoUUIDString(
    IN  VARIANT vObjGuid,
    OUT LPWSTR * ppszStrGuid
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0, dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    DWORD dwLength = 0;
    UUID uuidTemp;

    if (vObjGuid.vt != (VT_ARRAY | VT_UI1)) {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(&vObjGuid),
             1,
             (long FAR *) &dwSLBound
             );
    if FAILED(hr) 
        goto cleanup;

    hr = SafeArrayGetUBound(
             V_ARRAY(&vObjGuid),
             1,
             (long FAR *) &dwSUBound
             );
    if FAILED(hr) 
        goto cleanup;

    dwLength = dwSUBound - dwSLBound + 1;

    if (dwLength != sizeof(UUID)) {
        hr = E_FAIL;
        goto cleanup;
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vObjGuid),
             (void HUGEP * FAR *) &pArray
             );
    if FAILED(hr) 
        goto cleanup;

    memcpy(
        &uuidTemp,
        pArray,
        sizeof(UUID)
        );

    if (UuidToStringW( &uuidTemp, ppszStrGuid ) != RPC_S_OK) {
        hr = E_FAIL;
        goto cleanup;
    }

    SafeArrayUnaccessData( V_ARRAY(&vObjGuid) );

    return hr;

cleanup:

    if (pArray) {
        SafeArrayUnaccessData( V_ARRAY(&vObjGuid));
    }
 
    return hr;
}

/*
       Simple routine that returns true if dns registration
   for the DC is correct and false otherwise.
*/
HRESULT 
CRpcReplProv::GetDnsRegistration(
    BOOL *pfBool
    )
{
    return E_NOTIMPL;
}
    
/*
       This routine verifies that the host computer name and the
   name returned by DsGetDCName are the same. In that case the 
   return value is true, if not it is false.
*/
HRESULT 
CRpcReplProv::GetAdvertisingToLocator(
    BOOL *pfBool
    )
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    LPWSTR pszName = NULL;
    DOMAIN_CONTROLLER_INFOW *pDcInfo = NULL;

    *pfBool = FALSE;
    //
    // Get the length of this computers name and alloc buffer
    // and retrieve the name.
    //
    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!GetComputerNameExW(
             ComputerNameDnsFullyQualified,
             pszName,
             &dwSize
             )
        ) {
        //
        // Call failed for some reason.
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    //
    // We now need the name from DsGetDcName
    //
    dwErr = DsGetDcNameW(
                NULL, // ComputerName
                NULL, // DomainName
                NULL, // DomainGUID
                NULL, // SiteName
                DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                &pDcInfo
                );

    if (dwErr) {
        hr = HRESULT_FROM_WIN32(dwErr);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Make sure the names are valid and compare them.
    // We need to go past the \\ in the name.
    //
    if (pDcInfo->DomainControllerName
        && pszName
        && !lstrcmpiW(pszName, pDcInfo->DomainControllerName+2)
        ) {
        *pfBool = TRUE;
    }

cleanup:

    delete pszName;

    if (pDcInfo) {
        NetApiBufferFree(pDcInfo);
    }
    return hr;
}

HRESULT
CRpcReplProv::GetSysVolReady(
    BOOL *pfBool
    )
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    DWORD dwKeyVal = 0;
    DWORD dwType;
    DWORD dwBufSize = sizeof(DWORD);
    
    *pfBool = FALSE;

    if (RegOpenKeyExW(
            HKEY_LOCAL_MACHINE,
            L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters",
            0,
            KEY_QUERY_VALUE,
            &hKey
            )
        ) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    if (!RegQueryValueExW(
             hKey,
             L"SysVolReady",
             NULL,
             &dwType,
             (LPBYTE)&dwKeyVal,
             &dwBufSize
             ) 
        ) {
        if ((dwType == REG_DWORD)
            && (dwKeyVal == 1)) {
            *pfBool = TRUE;
        }
    }

cleanup:

    if (hKey != NULL) {
        RegCloseKey(hKey);
    }
    return hr;
}

/***
    This routine first locates the computer object for the domain
    controller and reads the rIDSetReference from this object.
    Then the Rid detailsa re read from the rIDSetReference (this is
    a dn value) and the return values computed accrodingly.
***/
HRESULT
CRpcReplProv::GetRidStatus(
    LPWSTR pszDefaultNamingContext,
    PBOOL  pfNextRidAvailable,
    PDWORD pdwPercentRidAvailable
    )
{
    HRESULT hr = S_OK;
    CComPtr<IADs> spIADs;
    CComPtr<IDirectoryObject> spIDirObj;
    CComBSTR bstrCompName;
    CComVariant svarRid;
    ADS_ATTR_INFO *pAttrInfo = NULL;
    LPWSTR pszCompObjName = NULL;
    LPWSTR  pszAttrNames[] = {
        L"rIDNextRID",
        L"rIDPreviousAllocationPool",
        L"rIDAllocationPool"
    };
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    DWORD dwNextRID = 0;
    ULONGLONG ridPrevAllocPool = 0;
    ULONGLONG ridAllocPool = 0;
    ULONGLONG Hvalue, Lvalue;


    *pfNextRidAvailable = FALSE;
    *pdwPercentRidAvailable = 0;

    //
    // First get the compter object name length.
    //
    dwErr = GetComputerObjectNameW(
                NameFullyQualifiedDN,
                NULL,
                &dwSize
                );
    if (dwSize > 0) {
        pszCompObjName = new WCHAR[dwSize];
        
        if (!pszCompObjName) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        dwErr = GetComputerObjectNameW(
                    NameFullyQualifiedDN,
                    pszCompObjName,
                    &dwSize
                    );
    }

    if (!dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // Now get the object and from it the ridSetReference.
    //
    bstrCompName = L"LDAP://";
    bstrCompName += pszCompObjName;
    
    hr = ADsOpenObject(
             bstrCompName,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IADs,
             OUT (void **)&spIADs
             );
    BAIL_ON_FAILURE(hr);

    hr = spIADs->Get(L"rIDSetReferences", &svarRid);
    BAIL_ON_FAILURE(hr);

    bstrCompName = L"LDAP://";
    bstrCompName += svarRid.bstrVal;

    hr = ADsOpenObject(
             bstrCompName,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
             OUT (void **)&spIDirObj
             );
    BAIL_ON_FAILURE(hr);

    dwSize = 0;
    hr = spIDirObj->GetObjectAttributes(
             pszAttrNames,
             3,
             &pAttrInfo,
             &dwSize
             );
    BAIL_ON_FAILURE(hr);

    //
    // Go through the attributes and update values accrodingly.
    //
    for (DWORD dwCtr = 0; dwCtr < dwSize; dwCtr++) {

        if (pAttrInfo && pAttrInfo[dwCtr].pszAttrName) {
            
            LPWSTR pszTmpStr = pAttrInfo[dwCtr].pszAttrName;

            if (!_wcsicmp(pszAttrNames[0], pszTmpStr)) {
                //
                // Found rIDNextRID.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_INTEGER)) {

                         dwNextRID = pAttrInfo[dwCtr].pADsValues[0].Integer;
                }
            }
            else if (!_wcsicmp(pszAttrNames[1], pszTmpStr)) {
                //
                // Found rIDPreviousAllocationPool.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_LARGE_INTEGER)) {
                    ridPrevAllocPool = (ULONGLONG)
                        pAttrInfo[dwCtr].pADsValues[0].LargeInteger.QuadPart;
                }
            }
            else if (!_wcsicmp(pszAttrNames[2], pszTmpStr)) {
                //
                // Found rIDAllocationPool.
                //
                if ((pAttrInfo[dwCtr].dwNumValues == 1)
                    && (pAttrInfo[dwCtr].dwADsType == ADSTYPE_LARGE_INTEGER)) {
                    ridAllocPool = (ULONGLONG)
                        pAttrInfo[dwCtr].pADsValues[0].LargeInteger.QuadPart;

                }
            }

        }
    }

    if (ridAllocPool != ridPrevAllocPool) {
        //
        // New pool has not been allocated.
        //
        *pfNextRidAvailable = TRUE;
    }

    Hvalue = Lvalue = ridPrevAllocPool;

    Lvalue<<=32;
    Lvalue>>=32;

    Hvalue>>=32;

    dwSize = (DWORD) (Hvalue-Lvalue);

    if (dwSize != 0) {
        *pdwPercentRidAvailable 
            = (DWORD)(100-((dwNextRID-Lvalue)*100/dwSize));
    }

cleanup:

    if (pszCompObjName) {
        delete pszCompObjName;
    }

    if (pAttrInfo) {
        FreeADsMem(pAttrInfo);
    }

    return hr;
}

/***
    This routine gets the statistics for the replication queue
    on the DC and sets then on the DomainController object.
***/
HRESULT
CRpcReplProv::GetAndUpdateQueueStatistics(
    IN IWbemClassObject* pIndicateItem
    )
{
    HRESULT hr = E_NOTIMPL;
    CComVariant svar;
    CComPtr<IDirectoryObject> spRootDSE;
    CComBSTR sbstrPath;
    LPWSTR pszAttrs[1] = { L"msDS-ReplQueueStatistics;binary"};
    DWORD dwSize = 0;
    DWORD dwErr = 0;
    LPWSTR pszName = NULL;
    PADS_ATTR_INFO pAttrInfo = NULL;
    DS_REPL_QUEUE_STATISTICSW dsReplStat;
    BOOL fFoundStats = FALSE;

    GetComputerNameExW(
        ComputerNameDnsFullyQualified,
        NULL,
        &dwSize
        );

    if (dwSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    pszName = new WCHAR[dwSize];

    if (!pszName) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    dwErr = GetComputerNameExW(
                ComputerNameDnsFullyQualified,
                pszName,
                &dwSize
                );
    if (!dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // The path has to be GC://CompName:389
    // as then we will get back an IADs ptr that we can call
    // GetInfoEx on to retrieve the replication queue stats.
    // LDAP://CompName will go the default NC and going to 
    // LDAP://CompName/RootDSE will not help as RootDSE does
    // not support the GetInfoEx method.
    //
    sbstrPath = L"GC://";
    sbstrPath += pszName;
    sbstrPath += L":389";

    hr = ADsOpenObject(
             sbstrPath,
             NULL,
             NULL,
             ADS_SECURE_AUTHENTICATION,
             IID_IDirectoryObject,
              OUT (void **)&spRootDSE
             );
    BAIL_ON_FAILURE(hr);

    ASSERT(spRootDSE != NULL);

    hr = spRootDSE->GetObjectAttributes(
             pszAttrs,
             1,
             &pAttrInfo,
             &dwSize
             );
    BAIL_ON_FAILURE(hr);

    if (!dwSize || !pAttrInfo) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    for (DWORD dwCtr = 0; dwCtr < dwSize; dwCtr++) {
        if (pAttrInfo[dwCtr].pszAttrName
            && !_wcsicmp(
                    pszAttrs[0],
                    pAttrInfo[dwCtr].pszAttrName
                    )
            ) {
            //
            // Found the attribute, verify type and copy to struct.
            //
            if ((pAttrInfo[dwCtr].dwNumValues == 1)
                && ((pAttrInfo[dwCtr].dwADsType == ADSTYPE_PROV_SPECIFIC)
                   || (pAttrInfo[dwCtr].dwADsType == ADSTYPE_OCTET_STRING))
                && (pAttrInfo[dwCtr].pADsValues[0].OctetString.dwLength 
                     == sizeof(DS_REPL_QUEUE_STATISTICSW))
                ) {
                //
                // This has to be the right data !
                //
                memcpy(
                    &dsReplStat, 
                    pAttrInfo[dwCtr].pADsValues[0].OctetString.lpValue,
                    sizeof(DS_REPL_QUEUE_STATISTICSW)
                    );
                fFoundStats = TRUE;
            } 
        } // does attribute match
    } // for - going through all the attributes

    if (!fFoundStats) {
        BAIL_ON_FAILURE(hr = E_ADS_PROPERTY_NOT_FOUND);
    }

    //
    // Now we finally get to put the data into the object.
    //
    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplSync",
            dsReplStat.ftimeOldestSync
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplAdd",
            dsReplStat.ftimeOldestAdd
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
            pIndicateItem,
            L"TimeOfOldestReplDel",
            dsReplStat.ftimeOldestDel
            );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
             pIndicateItem,
             L"TimeOfOldestReplMod",
             dsReplStat.ftimeOldestMod
             );
    BAIL_ON_FAILURE(hr);

    hr = PutFILETIMEAttribute(
             pIndicateItem,
             L"TimeOfOldestReplUpdRefs",
             dsReplStat.ftimeOldestUpdRefs
             );
    BAIL_ON_FAILURE(hr);

cleanup:   

    if (pszName) {
        delete pszName;
    }

    if (pAttrInfo) {
        FreeADsMem(pAttrInfo);
    }

    return hr;
}
/**************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\gpfixup\resource.h ===
#ifndef __RESOURCE_H
#define __RESOURCE_H

#define IDS_GPFIXUP1      1

#endif // __RESOURCE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\gpfixup\gpfixup.cpp ===
#define UNICODE
#define _UNICODE

#include <ole2.h>
#include <ole2ver.h>
#include <iads.h>
#include <adshlp.h>
#include <stdio.h>
#include <activeds.h>
#include <string.h>
#include <Dsgetdc.h>
#include <Dsrole.h>
#include <Lm.h>
#include <lmcons.h>
#include <windns.h>
#include "resource.h"
#include "helper.h"

#define CR                  L'\r'
#define BACKSPACE           L'\b'
#define NULLC               L'\0'
#define PADDING             256
#define MAX_DNSNAME         DNS_MAX_NAME_LENGTH + PADDING
#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\




struct TokenInfo
{
	BOOL     fPasswordToken;
	BOOL     fHelpToken;
	BOOL     fOldDNSToken;
    BOOL     fNewDNSToken;
    BOOL     fOldNBToken;
    BOOL     fNewNBToken;
    BOOL     fDCNameToken;
	TokenInfo() 
	{
		fPasswordToken = FALSE;
		fHelpToken = FALSE;
		fOldDNSToken = FALSE;
		fNewDNSToken = FALSE;
		fOldNBToken = FALSE;
		fNewNBToken = FALSE;
		fDCNameToken = FALSE;
	}
};


struct ArgInfo
{
	WCHAR*   pszUser;
	WCHAR*   pszPassword;
	WCHAR*   pszOldDNSName;
	WCHAR*   pszNewDNSName;
	WCHAR*   pszOldNBName;
	WCHAR*   pszNewNBName;
	WCHAR*   pszDCName;
        
	ArgInfo()
	{
		pszUser = NULL;
		pszPassword = NULL;
		pszOldDNSName = NULL;
		pszNewDNSName = NULL;
		pszOldNBName = NULL;
		pszNewNBName = NULL;
		pszDCName = NULL;
	}

};

//---------------------------------------------------------------------------- 
// Function:   PrintGPFixupErrorMessage                                        
//                                                                             
// Synopsis:   This function prints out the win32 error msg corresponding      
//             to the error code it receives                                   
//                                                                             
// Arguments:                                                                  
//                                                                             
// dwErr       The win32 error code                                            
//                                                                             
// Returns:    Nothing                                                         
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

void PrintGPFixupErrorMessage(DWORD dwErr)
{

    WCHAR   wszMsgBuff[512];  // Buffer for text.

    DWORD   dwChars;  // Number of chars returned.

	

    // Try to get the message from the system errors.
    dwChars = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM |
                             FORMAT_MESSAGE_IGNORE_INSERTS,
                             NULL,
                             dwErr,
                             0,
                             wszMsgBuff,
                             512,
                             NULL );

    if (0 == dwChars)
    {
        // The error code did not exist in the system errors.
        // Try ntdsbmsg.dll for the error code.

        HINSTANCE hInst;

        // Load the library.
        hInst = LoadLibrary(L"ntdsbmsg.dll");
        if ( NULL == hInst )
        {
            
			fwprintf(stderr, DLL_LOAD_ERROR);
            return;  
        }

        // Try getting message text from ntdsbmsg.
        dwChars = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_IGNORE_INSERTS,
                                 hInst,
                                 dwErr,
                                 0,
                                 wszMsgBuff,
                                 512,
                                 NULL );

        // Free the library.
        FreeLibrary( hInst );

    }

    // Display the error message, or generic text if not found.
    fwprintf(stderr, L" %ws\n", dwChars ? wszMsgBuff : ERRORMESSAGE_NOT_FOUND );

}



//---------------------------------------------------------------------------- 
// Function:   GetDCName                                                       
//                                                                             
// Synopsis:   This function locates a DC in the renamed domain given by       
//             NEWDNSNAME or NEWFLATNAME                                       
//                                                                             
// Arguments:                                                                  
//                                                                             
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
GetDCName(
	ArgInfo* argInfo
	)
{
	LPCWSTR     ComputerName = NULL;
    GUID*       DomainGuid = NULL;
    LPCWSTR     SiteName = NULL;
    PDOMAIN_CONTROLLER_INFO pDomainControllerInfo = NULL;
    DWORD       dwStatus = 0;
    LPWSTR      pszNetServerName = NULL;
    HRESULT     hr = S_OK;
    ULONG       ulDsGetDCFlags = DS_WRITABLE_REQUIRED;

	dwStatus =  DsGetDcName(
                        ComputerName,
                        argInfo->pszNewDNSName,
                        DomainGuid,
                        SiteName,
                        ulDsGetDCFlags,
                        &pDomainControllerInfo
                        );

	if (dwStatus == NO_ERROR)
	{
		argInfo->pszDCName = AllocADsStr(pDomainControllerInfo->DomainControllerName);
		if(!argInfo->pszDCName)
		{
		    hr = E_OUTOFMEMORY;
		
		    fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		    PrintGPFixupErrorMessage(hr);
		    BAIL_ON_FAILURE(hr);
		}
		
		hr = S_OK;
		fwprintf(stdout, L"%s%s\n", DC_NAME, argInfo->pszDCName);
	}
	else
	{
		hr = HRESULT_FROM_WIN32(dwStatus);
		fwprintf(stderr, L"%s%x\n", GETDCNAME_ERROR1, hr);
		PrintGPFixupErrorMessage(hr);

	}

	if (pDomainControllerInfo)
	{
		(void) NetApiBufferFree(pDomainControllerInfo);
	}

error:

	return hr;

}


//---------------------------------------------------------------------------- 
// Function:   VerifyName                                                      
//                                                                             
// Synopsis:   This function verifies that DC is writeable, and the domain DNS 
//             name as well as the domain NetBIOS name provided corresspond    
//             to the same domain naming context in the AD forest              |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// tokenInfo   Information about what switches user has turned on              |                                                                           
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
VerifyName(
	TokenInfo tokenInfo,
	ArgInfo argInfo
	)
{
	DSROLE_PRIMARY_DOMAIN_INFO_BASIC* pdomaininfo = NULL;
    HRESULT hr = E_FAIL;
    
    hr = HRESULT_FROM_WIN32(DsRoleGetPrimaryDomainInformation(
        argInfo.pszDCName,                      
        DsRolePrimaryDomainInfoBasic,   // InfoLevel
        (PBYTE*)&pdomaininfo            // pBuffer
        ));

    if (FAILED(hr))
	{
		fwprintf(stderr, L"%s%x\n", VERIFYNAME_ERROR1, hr);
		PrintGPFixupErrorMessage(hr);
        BAIL_ON_FAILURE(hr);
	}

	// determine that dc is writable, we assume that all win2k dc is writeable

	if(!(pdomaininfo->Flags & DSROLE_PRIMARY_DS_RUNNING))
	{
		fwprintf(stderr, VERIFYNAME_ERROR2);
		hr = E_FAIL;
		BAIL_ON_FAILURE(hr);
	}	

	// determine that new dns name is correct when compared with the dc name

	if(argInfo.pszNewDNSName && _wcsicmp(argInfo.pszNewDNSName, pdomaininfo->DomainNameDns))
	{
		fwprintf(stderr, VERIFYNAME_ERROR3);
		hr = E_FAIL;
		BAIL_ON_FAILURE(hr);
	}

	// determine that new netbios name is correct when compared with the dc name

	if(tokenInfo.fNewNBToken)
	{
		if(_wcsicmp(argInfo.pszNewNBName, pdomaininfo->DomainNameFlat))
		{
			fwprintf(stderr, VERIFYNAME_ERROR4);
			hr = E_FAIL;
			BAIL_ON_FAILURE(hr);			
		}
	}

error:
	if ( pdomaininfo )
	{
		DsRoleFreeMemory(pdomaininfo);
	}
	return hr;


}


//---------------------------------------------------------------------------- 
// Function:   PrintHelpFile                                                   
//                                                                             
// Synopsis:   This function prints out the help file for this tool            
//                                                                             
// Arguments:  Nothing                                                         
//                                                                             
//                                                                             
// Returns:    Nothing                                                         
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


void PrintHelpFile()
{
	WCHAR szBuffer[1200] = L"";

	LoadString(NULL, IDS_GPFIXUP1, szBuffer, 1200);
	fwprintf(stdout, L"%s\n", szBuffer);
	
}

//---------------------------------------------------------------------------- 
// Function:   GetPassword                                                     
//                                                                             
// Synopsis:   This function retrieves the password user passes in from        |
//             command line                                                    |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// szBuffer    Buffer to store the password                                    |                                                                           
// dwLength    Maximum length of the password                                  
// pdwLength   The length of the password user passes in                       | 
//                                                                             
// Returns:    TRUE on success, FALSE on failure                               
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR    ch;
    PWSTR    pszBufCur = szBuffer;
    DWORD    c;
    int      err;
    DWORD    mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putwchar(L'\n');

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}

//---------------------------------------------------------------------------- 
// Function:   Validations                                                     
//                                                                             
// Synopsis:   This function verifies whether the switch turned on by user is  
//             correct                                                         
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// tokenInfo   Information about what switches user has turned on              |                                                                           
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT
Validations( 
	TokenInfo tokenInfo,
	ArgInfo argInfo
	)
{
	HRESULT hr = S_OK;


	// At least one of the switches /newdsn or /newnb must be specified
	if(!(tokenInfo.fNewDNSToken | tokenInfo.fNewNBToken))
	{
		fwprintf(stderr, VALIDATIONS_ERROR1);
		return E_FAIL;
	}
	
	// The switch /newdns can be specified if and only if the switch /olddns is also specifed
	if((tokenInfo.fNewDNSToken && !tokenInfo.fOldDNSToken) || (!tokenInfo.fNewDNSToken && tokenInfo.fOldDNSToken))
	{
		fwprintf(stderr, VALIDATIONS_ERROR7);
		return E_FAIL;
	}
	
	// The switch /newnb can be specified if and only if the switch /oldnb is also specifed
	if((tokenInfo.fNewNBToken && !tokenInfo.fOldNBToken) || (!tokenInfo.fNewNBToken && tokenInfo.fOldNBToken))
	{
		fwprintf(stderr, VALIDATIONS_ERROR2);
		return E_FAIL;
	}
	
	// /newdns switch is not specified
	if(!tokenInfo.fNewDNSToken)
	{
		fwprintf(stderr, VALIDATIONS_ERROR3);
		return E_FAIL;
	}

	// compare whether the new and old DNS names are identical
	if(_wcsicmp(argInfo.pszNewDNSName, argInfo.pszOldDNSName) == 0)
	{
		fwprintf(stderr, VALIDATIONS_ERROR4);
		return E_FAIL;
	}

	// compare whether the new and old NetBIOS names are identical
	if(argInfo.pszNewNBName && argInfo.pszOldNBName && _wcsicmp(argInfo.pszNewNBName, argInfo.pszOldNBName) == 0)
	{
		fwprintf(stderr, VALIDATIONS_ERROR5);
	}

	
	if(SUCCEEDED(hr))
	{
		
		fwprintf(stdout, VALIDATIONS_RESULT);
	}

	return hr;


}

//---------------------------------------------------------------------------- 
// Function:   FixGPCFileSysPath                                               
//                                                                             
// Synopsis:   This function fixes the gpcFileSysPath attribute                
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszSysPath  value of the gpcFileSysPath attribute                           |
// pszDN       DN of the object                                                |                                                                          
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT
FixGPCFileSysPath(
	LPWSTR pszSysPath, 
	WCHAR* pszDN,
	const ArgInfo argInfo
	)
{
	HRESULT    hr = S_OK;
	WCHAR*     token = NULL;
	WCHAR*     newPath = NULL;
	WCHAR*     pszPathCopier = NULL;
	BOOL       fChange = FALSE;
	WCHAR*     pszLDAPPath = NULL;
	IADs*      pObject;
	VARIANT    var;
	WCHAR*     pszReleasePosition = NULL;
	DWORD      dwCount = 0;

	
	

	// copy the value over
	pszReleasePosition = new WCHAR[wcslen(pszSysPath) + 1];
	if(!pszReleasePosition)
	{		
		hr = E_OUTOFMEMORY;
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	pszPathCopier = pszReleasePosition;	
	wcscpy(pszReleasePosition, pszSysPath);

	// initialize the new property value
	newPath = new WCHAR[wcslen(pszSysPath) + MAX_DNSNAME];
	if(!newPath)
	{
		hr = E_OUTOFMEMORY;
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	wcscpy(newPath, L"");


	// process the old property

	// solving the possible problem of leading space
	while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
		dwCount ++;

	pszPathCopier = &pszReleasePosition[dwCount];

	

	// first do the check whether the value of property is what we expect
	if(wcscmp(pszPathCopier, L"") == 0)
	{
		
		goto error;
	}

	if( _wcsnicmp(pszPathCopier, L"\\", 1))
	{
		
		goto error;
	}

	token = wcstok( pszPathCopier, L"\\" );
	
    while( token != NULL )
	{               
	
		/* While there are tokens in "string" */
		
		if(!_wcsicmp(token, argInfo.pszOldDNSName))
		{
			if(!wcscmp(newPath, L""))
			{
				wcscpy(newPath, L"\\\\");
				wcscat(newPath, argInfo.pszNewDNSName);
				fChange = TRUE;
				
			}
			else
			{
				wcscat(newPath, argInfo.pszNewDNSName);
				fChange = TRUE;
				
			}
		}
		else
		{
			if(!wcscmp(newPath, L""))
			{
				wcscpy(newPath, L"\\\\");
				wcscat(newPath, token);
				
			}
			else
			{
				wcscat(newPath, token);
				
			}
		}   

        /* Get next token: */
		token = wcstok( NULL, L"\\" );
		if(token != NULL)
		{
			wcscat(newPath, L"\\");
		}
	}

    if(fChange)
	{
		// update the properties for the object
		
        if(argInfo.pszDCName)
        {
            pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/")];
        }
        else
        {
            pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://")];
        }
        
		if(!pszLDAPPath)
		{			
			hr = E_OUTOFMEMORY;
			
			fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		    PrintGPFixupErrorMessage(hr);
		}
		
		wcscpy(pszLDAPPath, L"LDAP://");
		if(argInfo.pszDCName)
		{
		    wcscat(pszLDAPPath, argInfo.pszDCName);
		    wcscat(pszLDAPPath, L"/");
		}
		wcscat(pszLDAPPath, pszDN);
		

		hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IADs,(void**)&pObject);

		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPCFILESYSPATH_ERROR1, hr);
			PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}


		VariantInit(&var);

		V_BSTR(&var) = SysAllocString(newPath);
        V_VT(&var) = VT_BSTR;
        hr = pObject->Put( L"gPCFileSysPath", var );

		VariantClear(&var);

		hr = pObject->SetInfo();

		pObject->Release();      

		
		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPCFILESYSPATH_ERROR2, hr);
			PrintGPFixupErrorMessage(hr);
		}
	}

error:

	
	// clear the memory
	if(newPath)
	{
		delete [] newPath;
	}

	if(pszReleasePosition)
	{
		delete [] pszReleasePosition;
	}

	if(pszLDAPPath)
	{
		delete [] pszLDAPPath;
	}
    
	return hr;


}

//---------------------------------------------------------------------------- 
// Function:   FixGPCWQLFilter                                                 
//                                                                             
// Synopsis:   This function fixes the gpcWQLFilter attribute                  
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszFilter   value of the gpcWQLFilter attribute                             |
// pszDN       DN of the object                                                
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
FixGPCWQLFilter(
	LPWSTR pszFilter, 
	WCHAR* pszDN,
	const ArgInfo argInfo
	)
{
	HRESULT    hr = S_OK;
	WCHAR*     token1 = NULL;
	WCHAR*     token2 = NULL;
	WCHAR*     temp = NULL;
	WCHAR*     pszFilterCopier = NULL;
	WCHAR*     newPath = NULL;
	IADs*      pObject;
	VARIANT    var;
	WCHAR*     pszLDAPPath = NULL;
	DWORD      dwToken1Pos = 0;
	BOOL       fChange = FALSE;
	WCHAR*     pszReleasePosition = NULL;
	DWORD      dwCount = 0;
    DWORD      dwFilterCount = 0;
    DWORD      dwIndex;
	
	// copy over the filter

	pszReleasePosition = new WCHAR[wcslen(pszFilter) + 1];
	if(!pszReleasePosition)
	{
		hr = E_OUTOFMEMORY;
			
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}
	pszFilterCopier = pszReleasePosition;
	wcscpy(pszReleasePosition, L"");
	wcscpy(pszReleasePosition, pszFilter);

    // find out how many filters are there
    for(dwIndex =0; dwIndex < wcslen(pszReleasePosition); dwIndex++)
    {
        if(L'[' == pszReleasePosition[dwIndex])
            dwFilterCount ++;
    }	
    
	// initilize the new property

	newPath = new WCHAR[wcslen(pszFilter) + DNS_MAX_NAME_LENGTH * dwFilterCount];
	if(!newPath)
	{
		hr = E_OUTOFMEMORY;
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}
	wcscpy(newPath, L"");


	// begin process the property

    // solving the possible problem of leading space
	while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
		dwCount ++;

	pszFilterCopier = &pszReleasePosition[dwCount];

	
	
	// first do the check whether the value of property is what we expect
	if(wcscmp(pszFilterCopier, L"") == 0)
	{
		
		goto error;
	}

	if( _wcsnicmp(pszFilterCopier, L"[", 1))
	{
		
		goto error;
	}


	token1 = wcstok(pszFilterCopier, L"[");
	if(token1 != NULL)
	{
		dwToken1Pos += wcslen(token1) + wcslen(L"[");
	}
		
	while(token1 != NULL)
	{

		WCHAR* mytoken = token1;

		token1 = token1 + wcslen(token1) + 1;

					
		token2 = wcstok( mytoken, L";" );
		if(token2 != NULL)
		{		        
		    if(_wcsicmp(token2, argInfo.pszOldDNSName) == 0)
			{
				wcscat(newPath, L"[");
				wcscat(newPath, argInfo.pszNewDNSName);
				wcscat(newPath, L";");				
				fChange = TRUE;
				
			}
			else
			{
				wcscat(newPath, L"[");
				wcscat(newPath, token2);
				wcscat(newPath, L";");				
				
			}

			token2 = wcstok(NULL, L"]");
			if(token2 != NULL)
			{
				wcscat(newPath, token2);
				wcscat(newPath, L"]");				
				
			}
		}
		
		if(dwToken1Pos < wcslen(pszFilter))
		{
    		token1 = wcstok( token1, L"[" );
    		dwToken1Pos = dwToken1Pos + wcslen(token1) + wcslen(L"[");
	    }
		else
		{
		    token1 = NULL;
		}       
				
	}
	
		
	// wrtie the new property back to the gpcWQLFilter of the object

	if(fChange)
	{
		// update the properties for the object

		if(argInfo.pszDCName)
		{
		    pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/")];
		}
		else
		{
		    pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://")];
		}
		
		if(!pszLDAPPath)
		{
			hr = E_OUTOFMEMORY;
		    
			fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		    PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}
		
		wcscpy(pszLDAPPath, L"LDAP://");
		if(argInfo.pszDCName)
		{
		    wcscat(pszLDAPPath, argInfo.pszDCName);
		    wcscat(pszLDAPPath, L"/");
		}
		wcscat(pszLDAPPath, pszDN);
		
		hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IADs,(void**)&pObject);

		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPCWQLFILTER_ERROR1, hr);
			PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}


		VariantInit(&var);

		V_BSTR(&var) = SysAllocString(newPath);
        V_VT(&var) = VT_BSTR;
        hr = pObject->Put( L"gPCWQLFilter", var );

		VariantClear(&var);

		hr = pObject->SetInfo();
        pObject->Release();

		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPCWQLFILTER_ERROR2, hr);
			PrintGPFixupErrorMessage(hr);
		}

		
	}
 
error:


	// clear the memory
	if(newPath)
	{
		delete [] newPath;
	}

	if(pszReleasePosition)
	{
		delete [] pszReleasePosition;
	}

	if(pszLDAPPath)
	{
		delete [] pszLDAPPath;
	}

	
	return hr;


}

//---------------------------------------------------------------------------- 
// Function:   SearchGroupPolicyContainer                                      
//                                                                             
// Synopsis:   This function searchs the group policy container and calls      
//             the FixGPCFileSysPath and FixGPCQWLFilter                       |
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT 
SearchGroupPolicyContainer(
	const ArgInfo argInfo
	)
{
	HRESULT    hr = S_OK;
	HRESULT    hrFix = S_OK;
	IDirectorySearch *m_pSearch;
	LPWSTR     pszAttr[] = { L"distinguishedName", L"gpcFileSysPath", L"gpcWQLFilter"};
        ADS_SEARCH_HANDLE hSearch;
        DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
	WCHAR*     dn = NULL;
	WCHAR*     pszLDAPPath = NULL;
	ADS_SEARCH_COLUMN col;
	ADS_SEARCHPREF_INFO prefInfo[1];
	BOOL       fBindObject = FALSE;
	BOOL       fSearch = FALSE;


	pszLDAPPath = new WCHAR[wcslen(argInfo.pszNewDNSName) + 1 + wcslen(L"LDAP://")];
	if(!pszLDAPPath)
	{
		hr = E_OUTOFMEMORY;
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	wcscpy(pszLDAPPath, L"LDAP://");
	wcscat(pszLDAPPath, argInfo.pszNewDNSName);

	hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch,(void**)&m_pSearch);

	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR1, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}


	// we successfully bind to the object
	fBindObject = TRUE;

	// set search preference, it is a paged search
	prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
        prefInfo[0].vValue.Integer = 100;

	hr = m_pSearch->SetSearchPreference( prefInfo, 1);

	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR2, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}
		

	// we successfully set the search preference, now execute search

	hr = m_pSearch->ExecuteSearch(L"(objectCategory=groupPolicyContainer)", pszAttr, dwCount, &hSearch );
		
	
	if(!SUCCEEDED(hr))
	{
		
		fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR3, hr);
		BAIL_ON_FAILURE(hr);
	}

	// we successfully execute the search
	fSearch = TRUE;

	// begin the search
	hr = m_pSearch->GetNextRow(hSearch);
    
	BAIL_ON_FAILURE(hr);

    while( hr != S_ADS_NOMORE_ROWS )    
	{
       // Get the distinguished name
       hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
       if ( SUCCEEDED(hr) )
	   {
           dn = new WCHAR[wcslen(col.pADsValues->CaseIgnoreString) + 1];
		   if(!dn)
		   {
			   hr = E_OUTOFMEMORY;
			   
			   fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
			   PrintGPFixupErrorMessage(hr);
			   BAIL_ON_FAILURE(hr);
		   }
		   wcscpy(dn, col.pADsValues->CaseIgnoreString);
           m_pSearch->FreeColumn( &col );
	   }
	   else if(hr == E_ADS_COLUMN_NOT_SET)
	   {
	       hr = m_pSearch->GetNextRow(hSearch);
	   	   continue;
	   }
	   else
	   {
		   
		   fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR4, hr);
		   PrintGPFixupErrorMessage(hr);
		   BAIL_ON_FAILURE(hr);
	   }

	   // Get the gpcFileSysPath
       hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );
	   
       if ( SUCCEEDED(hr) )
	   {
		   if(col.pADsValues != NULL)
		   {
			   // fix the possible problem for property gpcFileSysPath
			   			   
			   hrFix = FixGPCFileSysPath(col.pADsValues->CaseIgnoreString, dn, argInfo);
			   
			   m_pSearch->FreeColumn( &col );
		   }
	   }
	   else if(hr == E_ADS_COLUMN_NOT_SET)
	   {
	       // gpcFileSysPath must exist
	       fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR7, hr);
		   PrintGPFixupErrorMessage(hr);
	       hr = m_pSearch->GetNextRow(hSearch);
	   	   continue;
	   }
	   else
	   {
		   
		   fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR5, hr);
		   PrintGPFixupErrorMessage(hr);
		   BAIL_ON_FAILURE(hr);
	   }

	   // Get the gpcWQLFilter
       hr = m_pSearch->GetColumn( hSearch, pszAttr[2], &col );

	     
       if ( SUCCEEDED(hr) )
	   {
		   if(col.pADsValues != NULL)
		   {
			   
			   // fix the possible problem for property gpcWQLFilter
			   			   
			   hrFix = FixGPCWQLFilter(col.pADsValues->CaseIgnoreString, dn, argInfo);
			   
			   m_pSearch->FreeColumn( &col );
		   }
	   }
	   else if(hr == E_ADS_COLUMN_NOT_SET)
	   {
	       hr = m_pSearch->GetNextRow(hSearch);
	   	   continue;
	   }
	   else
	   {
		   
		   fwprintf(stderr, L"%s%x\n", SEARCH_GROUPPOLICY_ERROR6, hr);
		   PrintGPFixupErrorMessage(hr);
		   BAIL_ON_FAILURE(hr);
	   }

	   // go to next row
	   hr = m_pSearch->GetNextRow(hSearch);


	}

error:

	if(pszLDAPPath)
	{
		delete [] pszLDAPPath;
	}

	if(dn)
	{
		delete [] dn;
	}

	if(fSearch)
	{
		m_pSearch->CloseSearchHandle( hSearch );
	}

	if(fBindObject)
	{
		m_pSearch->Release();
	}

	if( SUCCEEDED(hr) )
	{
		
		fwprintf(stdout, SEARCH_GROUPPOLICY_RESULT);
	}
	
	return hr;



}

//---------------------------------------------------------------------------- 
// Function:   FixGPCLink                                                      
//                                                                             
// Synopsis:   This function fixes the gpLink attribute                        
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// pszSysPath  value of the gpLink attribute                                   |
// pszDN       DN of the object                                                |                                                                        
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
FixGPLink(
	LPWSTR pszLink,
	WCHAR* pszDN,
	const ArgInfo argInfo,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[]
	)
{
	HRESULT    hr = S_OK;
	WCHAR      seps1[] = L";";
	WCHAR      seps2[] = L",";	
	WCHAR      separator1 [] = L"DC";
	WCHAR      separator2 [] = L"0";
	WCHAR      DNSName [MAX_DNSNAME] = L"";
	
	WCHAR*     token1 = NULL;
	WCHAR*     token2 = NULL;
	
	WCHAR*     myPath = NULL;
	WCHAR      tempOldDNName [MAX_DNSNAME] = L"";
	DWORD      dwLength = 0;
	DWORD      dwToken1Pos = 0;
	WCHAR*     pszLinkCopier = NULL;
	BOOL       fChange = FALSE;
	WCHAR*     pszReleasePosition = NULL;
	IADs*      pObject;
	VARIANT    var;
	WCHAR*     pszLDAPPath = NULL;
	DWORD      i;
	DWORD      dwCount = 0;
	DWORD      dwLinkCount = 0;
    DWORD      dwIndex;

    	
	wcscpy(tempOldDNName, pszOldDomainDNName);
	wcscat(tempOldDNName, L",");


	pszReleasePosition = new WCHAR[wcslen(pszLink) + 1];

	if(!pszReleasePosition)
	{
		hr = E_OUTOFMEMORY;
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}
	
	wcscpy(pszReleasePosition, pszLink);
	pszLinkCopier = pszReleasePosition;
	

	dwLength = wcslen(pszLink);

	// find out how many filters are there
    for(dwIndex =0; dwIndex < wcslen(pszReleasePosition); dwIndex++)
    {
        if(L'[' == pszReleasePosition[dwIndex])
            dwLinkCount ++;
    }	

    myPath = new WCHAR[wcslen(pszLink) + DNS_MAX_NAME_LENGTH * dwLinkCount];
	
	if(!myPath)
	{
		
		fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		hr = E_FAIL;
		BAIL_ON_FAILURE(hr);
	}
	
	wcscpy(myPath, L"");

		
	// begin process the property

	// solving the possible problem of leading space
	while(pszReleasePosition[dwCount] != L'\0' && pszReleasePosition[dwCount] == L' ')
		dwCount ++;

	pszLinkCopier = &pszReleasePosition[dwCount];

	// first do the check whether the value of property is what we expect
	if(wcscmp(pszLinkCopier, L"") == 0)
	{
		
		goto error;
	}

	if( _wcsnicmp(pszLinkCopier, L"[", 1))
	{
		
		goto error;
	}

	 

	/* Establish string and get the first token: */
    token1 = wcstok( pszLinkCopier, seps1 );
	if(token1 != NULL)
	{
		dwToken1Pos += wcslen(token1) + wcslen(L";");
	}
	
    while( token1 != NULL )
    {
        /* While there are tokens in "string" */
		WCHAR* temp = token1;
		


		token1 = token1 + wcslen(token1) + 1;
		
        
		//GetToken2(temp);
		token2 = wcstok( temp, seps2 );
	    
        while( token2 != NULL )
		{
		    // not begin with dc
			if(_wcsnicmp(token2, separator1, wcslen(L"DC")) != 0)
			{
				// need to concat the domain DNS name
				if(wcsncmp(token2, separator2, wcslen(L"0")) == 0)
				{
					if(_wcsicmp(DNSName, tempOldDNName) == 0)
					{
						fChange = TRUE;
						wcscat(myPath, pszNewDomainDNName);
						wcscat(myPath, L";");
						wcscat(myPath, token2);
						wcscat(myPath, L",");
						wcscpy(DNSName, L"");
						
					}
					else
					{
						// remove the last ,
						DNSName[wcslen(DNSName) - 1] = '\0';
						wcscat(myPath, DNSName);
						wcscat(myPath, L";");
						wcscat(myPath, token2);
						wcscat(myPath, L",");
						wcscpy(DNSName, L"");
						
					}
				}
				else
				{
					wcscat(myPath, token2);
					wcscat(myPath, L",");
					
					
				}
			}
			// begin with dc
			else
			{
				wcscat(DNSName, token2);
				wcscat(DNSName, L",");
				
			}
			
				

            		
            token2 = wcstok( NULL, seps2 );
			
		}
		
        if(dwToken1Pos < wcslen(pszLink))
        {
            token1 = wcstok( token1, seps1 );
            dwToken1Pos = dwToken1Pos + wcslen(token1) + wcslen(L";");
        }
        else
        {
            token1 = NULL;
        }
        
    }

	myPath[wcslen(myPath) - 1] = '\0';

		
	// if fChange is true, then write the object property gpLink back with the given dn

	if(fChange)
	{
		// update the properties for the object

		if(argInfo.pszDCName)
		{
		    pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://") + wcslen(argInfo.pszDCName) + wcslen(L"/")];    
		}
		else
		{
		    pszLDAPPath = new WCHAR[wcslen(pszDN) + 1 + wcslen(L"LDAP://")];
		}
		
		if(!pszLDAPPath)
		{
			hr = E_OUTOFMEMORY;
		    
			fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
	    	PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}
		
		wcscpy(pszLDAPPath, L"LDAP://");
		if(argInfo.pszDCName)
		{
		    wcscat(pszLDAPPath, argInfo.pszDCName);
		    wcscat(pszLDAPPath, L"/");
		}
		wcscat(pszLDAPPath, pszDN);
		


		hr = ADsOpenObject(pszLDAPPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IADs,(void**)&pObject);

		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPLINK_ERROR1, hr);
			PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}


		VariantInit(&var);

		V_BSTR(&var) = SysAllocString(myPath);
        V_VT(&var) = VT_BSTR;
        hr = pObject->Put( L"gPLink", var );

		VariantClear(&var);

		hr = pObject->SetInfo();
        pObject->Release();

		if(!(SUCCEEDED(hr)))
		{
			
			fwprintf(stderr, L"%s%x\n", GPLINK_ERROR2, hr);
			PrintGPFixupErrorMessage(hr);
		}
	}

error:

	// clear the memory
	if(myPath)
	{
		delete [] myPath;
	}

	if(pszReleasePosition)
	{
		delete [] pszReleasePosition;
	}

	if(pszLDAPPath)
	{
		delete [] pszLDAPPath;
	}
		
	
	return hr;



}

//---------------------------------------------------------------------------- 
// Function:   SearchGPLinkofSite                                              
//                                                                             
// Synopsis:   This function searches for all objects of type site under       |
//             the Site container in the configuration naming context          |
//             and calls FixGPLink                                             
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 


HRESULT 
SearchGPLinkofSite(
	const ArgInfo argInfo,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[]
	)
{
	HRESULT    hr = S_OK;
	IDirectorySearch *m_pSearch;
	LPWSTR     pszAttr[] = { L"distinguishedName",L"gpLink"};
    ADS_SEARCH_HANDLE hSearch;
    DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
	ADS_SEARCH_COLUMN col;
	WCHAR*     dn = NULL;
	ADS_SEARCHPREF_INFO prefInfo[1];
	WCHAR      szForestRootDN [MAX_DNSNAME] = L"";
	IADs*      pObject;
	WCHAR      szTempPath [MAX_DNSNAME] = L"LDAP://";
	VARIANT    varProperty;
	BOOL       fBindRoot = FALSE;
	BOOL       fBindObject = FALSE;
	BOOL       fSearch = FALSE;

	


	// get the forestroot dn

	if(_wcsnicmp(argInfo.pszDCName, L"\\\\", wcslen(L"\\\\")) == 0)
	{
		wcscat(szTempPath, &argInfo.pszDCName[wcslen(L"\\\\")]);
	}
	else
	{
		wcscat(szTempPath, argInfo.pszDCName);
	}
	wcscat(szTempPath, L"/");
	wcscat(szTempPath, L"RootDSE");
	
	hr = ADsOpenObject(szTempPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IADs,(void**)&pObject);

	if(!SUCCEEDED(hr))
	{
		
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR1, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	// we get to the rootdse
	fBindRoot = TRUE;

	hr = pObject->Get(L"rootDomainNamingContext", &varProperty );
    if ( SUCCEEDED(hr) )
	{		
		wcscpy( szForestRootDN , V_BSTR( &varProperty ) );
		
	}
	else
	{
		
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR2, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	VariantClear(&varProperty);
	


	// bind to the forestrootdn
	wcscpy(szTempPath, L"LDAP://CN=Sites,CN=Configuration,");
	wcscat(szTempPath, szForestRootDN);
	

	hr = ADsOpenObject(szTempPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch,(void**)&m_pSearch);

	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR3, hr);
		PrintGPFixupErrorMessage(hr);		
		BAIL_ON_FAILURE(hr);
	}


	// set search preference, it is a paged search
	fBindObject = TRUE;

	prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = 100;
    
	hr = m_pSearch->SetSearchPreference( prefInfo, 1);

	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR4, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}	


	// execute the search
	hr = m_pSearch->ExecuteSearch(L"(objectCategory=site)", pszAttr, dwCount, &hSearch );
		
	
	if(!SUCCEEDED(hr))
	{
		
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR5, hr);
		BAIL_ON_FAILURE(hr);
	}

	// executeSearch succeeds
	fSearch = TRUE;


	// begin the search
	hr = m_pSearch->GetNextRow(hSearch);
    
	BAIL_ON_FAILURE(hr);

    while( hr != S_ADS_NOMORE_ROWS )
	{
       // Get the distinguished name
       hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
       if ( SUCCEEDED(hr) )
	   {
            
			dn = new WCHAR[wcslen(col.pADsValues->CaseIgnoreString) + 1];
		    if(!dn)
			{
			    hr = E_OUTOFMEMORY;
		        
				fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		        PrintGPFixupErrorMessage(hr);
			    BAIL_ON_FAILURE(hr);
			}
		    wcscpy(dn, col.pADsValues->CaseIgnoreString);
            m_pSearch->FreeColumn( &col );
	   }
	   else if(hr == E_ADS_COLUMN_NOT_SET)
	   {
	    	hr = m_pSearch->GetNextRow(hSearch);
			continue;
	   }
	   else
	   {
		    
			fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR6, hr);
			PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
	   }

	   // Get the gpLink
       hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );
	   
       if ( SUCCEEDED(hr) )
	   {
		   if(col.pADsValues != NULL)
		   {
			   
			   FixGPLink(col.pADsValues->CaseIgnoreString, dn, argInfo, pszOldDomainDNName, pszNewDomainDNName); 
			   m_pSearch->FreeColumn( &col );
		   }
	   }
	   else if(hr == E_ADS_COLUMN_NOT_SET)
	   {
	    	hr = m_pSearch->GetNextRow(hSearch);
			continue;
	   }
	   else
	   {
		    
			fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_SITE_ERROR7, hr);
			PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
	   }

	   // go to next row
	   hr = m_pSearch->GetNextRow(hSearch);

	   
	}

error:

	if(dn)
	{
		delete [] dn;
	}

	if(fBindRoot)
	{
		pObject->Release();
	}

	if(fSearch)
	{
		m_pSearch->CloseSearchHandle( hSearch );
	}

	if(fBindObject)
	{
		m_pSearch->Release();
	}
 
	if( SUCCEEDED(hr) )
	{
		
		fwprintf(stdout, SEARCH_GPLINK_SITE_RESULT);

	}
	

	return hr;



}


//---------------------------------------------------------------------------- 
// Function:   SearchGPLinkofOthers                                            
//                                                                             
// Synopsis:   This function searchs for all objects of type domainDNS or      |
//             organizationalUnit under the domain root of the renamed domain  |
//             and calls FixGPLink                                             
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argInfo     Information user passes in through command line                 
// pszOldDomainDNName                                                          |
//	           New Domain DN                                               |
// pszNewDomainDNName                                                          |
//             Old Domain DN                                                   |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

HRESULT
SearchGPLinkofOthers(
	const ArgInfo argInfo,
	const WCHAR  pszOldDomainDNName[],
	const WCHAR  pszNewDomainDNName[]
	)
{
	HRESULT    hr = S_OK;
	IDirectorySearch *m_pSearch;
	LPWSTR     pszAttr[] = { L"distinguishedName",L"gpLink"};
    ADS_SEARCH_HANDLE hSearch;
    DWORD      dwCount= sizeof(pszAttr)/sizeof(LPWSTR);
	ADS_SEARCH_COLUMN col;
	WCHAR*     dn = NULL;
	WCHAR      tempPath [MAX_DNSNAME] = L"";
	ADS_SEARCHPREF_INFO prefInfo[1];
	BOOL       fBindObject = FALSE;
	BOOL       fSearch = FALSE;

	 

	wcscpy(tempPath, L"LDAP://");
	wcscat(tempPath, argInfo.pszNewDNSName);

	hr = ADsOpenObject(tempPath, argInfo.pszUser, argInfo.pszPassword, ADS_SECURE_AUTHENTICATION, IID_IDirectorySearch,(void**)&m_pSearch);

	
	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR1, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}

	// we successfully bind to the object
	fBindObject = TRUE;

	// set search preference, it is a paged search
	prefInfo[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    prefInfo[0].vValue.dwType = ADSTYPE_INTEGER;
    prefInfo[0].vValue.Integer = 100;

	hr = m_pSearch->SetSearchPreference( prefInfo, 1);

	if(!SUCCEEDED(hr))
	{
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR2, hr);
		PrintGPFixupErrorMessage(hr);
		BAIL_ON_FAILURE(hr);
	}	

	// execute the search

	hr = m_pSearch->ExecuteSearch(L"(|(objectCategory=domainDNS)(objectCategory=organizationalUnit))", pszAttr, dwCount, &hSearch );
		
	
	if(!SUCCEEDED(hr))
	{
		
		fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR3, hr);
		BAIL_ON_FAILURE(hr);
	}

	// we successfully execute the search
	fSearch = TRUE;

	// begin the search
	hr = m_pSearch->GetNextRow(hSearch);
    
	BAIL_ON_FAILURE(hr);

    while( hr != S_ADS_NOMORE_ROWS )
	{
	    // Get the distinguished name
        hr = m_pSearch->GetColumn( hSearch, pszAttr[0], &col );
	   
        if ( SUCCEEDED(hr) )
		{
            
			dn = new WCHAR[wcslen(col.pADsValues->CaseIgnoreString) + 1];
		    if(!dn)
			{
			    hr = E_OUTOFMEMORY;
	        	
				fwprintf(stderr, L"%s%x\n", MEMORY_ERROR, hr);
		        PrintGPFixupErrorMessage(hr);
			    BAIL_ON_FAILURE(hr);
			}
			wcscpy(dn, col.pADsValues->CaseIgnoreString);
            m_pSearch->FreeColumn( &col );
		}
		else if(hr == E_ADS_COLUMN_NOT_SET)
		{
			hr = m_pSearch->GetNextRow(hSearch);
			continue;
		}
		else
		{
			
			fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR4, hr);
		    PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}

	    // Get the gpLink
        hr = m_pSearch->GetColumn( hSearch, pszAttr[1], &col );
	    
        if ( SUCCEEDED(hr) )
		{
	 	    if(col.pADsValues != NULL)
			{
			    
			    FixGPLink(col.pADsValues->CaseIgnoreString, dn, argInfo, pszOldDomainDNName, pszNewDomainDNName); 
			    m_pSearch->FreeColumn( &col );
			}
		}
		else if(hr == E_ADS_COLUMN_NOT_SET)
		{
			hr = m_pSearch->GetNextRow(hSearch);
			continue;
		}
		else
		{
			
			fwprintf(stderr, L"%s%x\n", SEARCH_GPLINK_OTHER_ERROR5, hr);
		    PrintGPFixupErrorMessage(hr);
			BAIL_ON_FAILURE(hr);
		}

		// go to next row
		hr = m_pSearch->GetNextRow(hSearch);

	   
	}

error:

	if(dn)
	{
		delete [] dn;
	}
	
	if(fSearch)
	{
		m_pSearch->CloseSearchHandle( hSearch );
	}

	if(fBindObject)
	{
		m_pSearch->Release();
	}

	if( SUCCEEDED(hr) )
	{
		
		fwprintf(stdout, SEARCH_GPLINK_OTHER_RESULT);
	}
	

	return hr;



}

//---------------------------------------------------------------------------- 
// Function:   wmain                                                           
//                                                                             
// Synopsis:   entry point of the program                                      
//                                                                             
// Arguments:                                                                  
//                                                                             |  
// argc        number of passed in arguments                                   
// argv        arguments                                                       |
//                                                                             
// Returns:    S_OK on success. Error code otherwise.                          
//                                                                             
// Modifies:   Nothing                                                         
//                                                                             
//---------------------------------------------------------------------------- 

__cdecl wmain(int argc, WCHAR* argv[])
{

    DWORD    dwLength;
    WCHAR    *token1 = NULL;
    WCHAR    tempParameters [MAX_DNSNAME] = L"";
	HRESULT  hr = S_OK;
	WCHAR    szBuffer[PWLEN+1];
	
	WCHAR    pszNewDomainDNName [MAX_DNSNAME] = L"";
	WCHAR    pszOldDomainDNName [MAX_DNSNAME] = L"";
	
	TokenInfo tokenInfo;
	ArgInfo argInfo;

	// the number of parameters passed in is not correct
	if(argc > 8 || argc == 1)
	{
		PrintHelpFile();
		return ;
	}

	// process the parameters passed in
	for(int i = 1; i < argc; i++)
	{
	
		// want help file
		if(_wcsicmp(argv[i], szHelpToken) == 0)
		{
			tokenInfo.fHelpToken = TRUE;
			break;
			
		}
		// get olddnsname
		else if(_wcsnicmp(argv[i], szOldDNSToken,wcslen(szOldDNSToken)) == 0)
		{
			tokenInfo.fOldDNSToken = TRUE;			
			argInfo.pszOldDNSName = &argv[i][wcslen(szOldDNSToken)];
			

		}
		// get newdnsname
		else if(_wcsnicmp(argv[i], szNewDNSToken,wcslen(szNewDNSToken)) == 0)
		{
			tokenInfo.fNewDNSToken = TRUE;
			argInfo.pszNewDNSName = &argv[i][wcslen(szNewDNSToken)];
			
		}
		// get oldnbname
		else if(_wcsnicmp(argv[i], szOldNBToken, wcslen(szOldNBToken)) == 0)
		{
			tokenInfo.fOldNBToken = TRUE;
			argInfo.pszOldNBName = &argv[i][wcslen(szOldNBToken)];
			
		}
		// get newnbname
		else if(_wcsnicmp(argv[i], szNewNBToken, wcslen(szNewNBToken)) == 0)
		{
			tokenInfo.fNewNBToken = TRUE;
			argInfo.pszNewNBName = &argv[i][wcslen(szNewNBToken)];
			
		}
		// get dcname
		else if(_wcsnicmp(argv[i], szDCNameToken, wcslen(szDCNameToken)) == 0)
		{
			tokenInfo.fDCNameToken = TRUE;
			argInfo.pszDCName = &argv[i][wcslen(szDCNameToken)];
			
		}
		// get the username
		else if(_wcsnicmp(argv[i], szUserToken, wcslen(szUserToken)) == 0)
		{
			argInfo.pszUser = &argv[i][wcslen(szUserToken)];
			
		}
		// get password
		else if(_wcsnicmp(argv[i], szPasswordToken, wcslen(szPasswordToken)) == 0)
		{
			argInfo.pszPassword = &argv[i][wcslen(szPasswordToken)];
			
			if(wcscmp(argInfo.pszPassword, L"*") == 0)
			{
				// prompt the user to pass in the password
				
				fwprintf( stdout, PASSWORD_PROMPT );

				if (GetPassword(szBuffer,PWLEN+1,&dwLength))
				{
					argInfo.pszPassword = AllocADsStr(szBuffer);   
					
					
				}
				else 
				{
					hr = ERROR_INVALID_PARAMETER;
					
					fwprintf(stderr, L"%s%x\n", PASSWORD_ERROR, hr);
					return;
				}
			}
			else
			{
				// we use the password user passes in directly
				tokenInfo.fPasswordToken = TRUE;
			}

			
			
		}
		else
		{
			fwprintf(stderr, WRONG_PARAMETER);
			PrintHelpFile();
			return;
		}
		
		

	}

	if(tokenInfo.fHelpToken)
	{
		// user wants the helpfile
		PrintHelpFile();
		return;
	}


	// Begin the validation process
	hr = Validations(tokenInfo, argInfo);

	if(!SUCCEEDED(hr))
	{
		
		BAIL_ON_FAILURE(hr);
	}

	// get the dc name
	if(!tokenInfo.fDCNameToken)
	{
		hr = GetDCName(&argInfo);
		// get dc name failed
		if(!SUCCEEDED(hr))
		{
			// we can't ge the dc name, fail here. exit gpfixup
			
			fwprintf(stderr, VALIDATIONS_ERROR6);
			BAIL_ON_FAILURE(hr);
		}

	}

	// verify dc is writeable, domain dns name and domain netbios name correspond to the same one
	hr = VerifyName(tokenInfo, argInfo);

	if(!SUCCEEDED(hr))
	{
		
		BAIL_ON_FAILURE(hr);
	}


	// get the new domain dn

	if(wcslen(argInfo.pszNewDNSName) > DNS_MAX_NAME_LENGTH)
	{
		fwprintf(stderr, L"%s\n", DNSNAME_ERROR, hr);
		BAIL_ON_FAILURE(hr);
	}
	
	wcscpy(tempParameters, argInfo.pszNewDNSName);

		
	token1 = wcstok( tempParameters, L"." );
	while( token1 != NULL )
    {
		wcscat(pszNewDomainDNName, L"DC=");
		wcscat(pszNewDomainDNName, token1);
				
		token1 = wcstok( NULL, L"." );
		if(token1 != NULL)
		{
			wcscat(pszNewDomainDNName, L",");
		}
	}

		
	// get the old domain dn

	if(wcslen(argInfo.pszOldDNSName) > DNS_MAX_NAME_LENGTH)
	{
		fwprintf(stderr, L"%s\n", DNSNAME_ERROR, hr);
		BAIL_ON_FAILURE(hr);
	}

	wcscpy(tempParameters, argInfo.pszOldDNSName);

	
	token1 = wcstok( tempParameters, L"." );
	while( token1 != NULL )
    {
		wcscat(pszOldDomainDNName, L"DC=");
		wcscat(pszOldDomainDNName, token1);
				
		token1 = wcstok( NULL, L"." );
		if(token1 != NULL)
		{
			wcscat(pszOldDomainDNName, L",");
		}
	}

	


	// Fix groupPolicyContainer
	CoInitialize(NULL);

	hr = SearchGroupPolicyContainer(argInfo);
	

	// Fix gpLink, first is the site, then is the objects of type domainDNS or organizationalUnit
	hr = SearchGPLinkofSite(argInfo, pszOldDomainDNName, pszNewDomainDNName);

    hr = SearchGPLinkofOthers(argInfo, pszOldDomainDNName, pszNewDomainDNName);


	CoUninitialize( );


error:

	// it means that we dynamically allocation memory for pszDCNane
	if(!tokenInfo.fDCNameToken && argInfo.pszDCName)
	{
		FreeADsStr(argInfo.pszDCName);
		
	}

	if(!tokenInfo.fPasswordToken && argInfo.pszPassword)
	{
		
		FreeADsStr(argInfo.pszPassword);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\dswmi\replprov\rpcreplprov.h ===
/*++

Copyright (c) 2000  Microsoft Corporation


Abstract:

    RpcReplProv.h: Definition of the RpcReplProv class
    

Author:

    Akshay Nanduri (t-aksnan)  26-Mar-2000


Revision History:


--*/


#if !defined(AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_)
#define AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "stdafx.h"
#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// RpcReplProv

class CRpcReplProv : 
    public IWbemProviderInit,
    public IWbemServices,
    public CComObjectRoot,
    public CComCoClass<CRpcReplProv,&CLSID_RpcReplProv>
{
public:
    CRpcReplProv();
    ~CRpcReplProv();
    
BEGIN_COM_MAP(CRpcReplProv)
    COM_INTERFACE_ENTRY(IWbemProviderInit)
    COM_INTERFACE_ENTRY(IWbemServices)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(RpcReplProv) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_RpcReplProv)

// IWbemProviderInit

    STDMETHOD(Initialize)(
         IN LPWSTR pszUser,
         IN LONG lFlags,
         IN LPWSTR pszNamespace,
         IN LPWSTR pszLocale,
         IN IWbemServices *pNamespace,
         IN IWbemContext *pCtx,
         IN IWbemProviderInitSink *pInitSink
         );

// IWbemServices

    
    //Implemented...
    STDMETHOD(CreateInstanceEnumAsync)( 
        IN const BSTR bstrClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);
    
    STDMETHOD(GetObjectAsync)( 
        IN const BSTR bstrObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler);

    
     STDMETHOD(ExecMethodAsync)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN IWbemObjectSink *pResponseHandler);
    
    
    //Not Implemented...
    
    STDMETHOD(CreateInstanceEnum)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
    { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(GetObject)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemClassObject **ppObject,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    

    STDMETHOD(OpenNamespace)( 
        IN const BSTR strNamespace,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemServices **ppWorkingNamespace,
        IN OUT IWbemCallResult **ppResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CancelAsyncCall)( 
        IN IWbemObjectSink *pSink)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(QueryObjectSink)( 
        IN long lFlags,
        OUT IWbemObjectSink **ppResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    
    STDMETHOD(PutClass)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutClassAsync)( 
        IN IWbemClassObject *pObject,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteClass)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
            
    STDMETHOD(DeleteClassAsync)( 
        IN const BSTR strClass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnum)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(CreateClassEnumAsync)( 
        IN const BSTR strSuperclass,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstance)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(PutInstanceAsync)( 
        IN IWbemClassObject *pInst,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstance)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(DeleteInstanceAsync)( 
        IN const BSTR strObjectPath,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecMethod)( 
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemClassObject *pInParams,
        IN OUT IWbemClassObject **ppOutParams,
        IN OUT IWbemCallResult **ppCallResult)
        { return WBEM_E_NOT_SUPPORTED; };
        
    STDMETHOD(ExecNotificationQuery)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        OUT IEnumWbemClassObject **ppEnum)
        { return WBEM_E_NOT_SUPPORTED; };
    
    STDMETHOD(ExecNotificationQueryAsync)( 
        IN const BSTR strQueryLanguage,
        IN const BSTR strQuery,
        IN long lFlags,
        IN IWbemContext *pCtx,
        IN IWbemObjectSink *pResponseHandler)
        { return WBEM_E_NOT_SUPPORTED; };

private:

    #ifdef EMBEDDED_CODE_SUPPORT
    HRESULT CreatePendingOps(
        OUT SAFEARRAY** ppArray
        );
    
    HRESULT CreateCursors(
        IN  BSTR bstrNamingContext,
        OUT SAFEARRAY** ppArray
        );
    #endif
        
    HRESULT CreateFlatListCursors(
        IN IWbemObjectSink *pResponseHandler
        );

    HRESULT CreateCursorHelper(
        IN  BSTR  bstrNamingContext,
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );
    
    HRESULT GetCursor(
        IN  BSTR  bstrNamingContext,
        IN  BSTR  bstrSrcDsanvocationUUID,
        OUT IWbemClassObject** ppIndicateItem
        );


    HRESULT GetPendingOps(
        IN LONG lSerialNumber,              
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT CreateFlatListPendingOps(
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );

        //bGetFullReplica == TRUE -> function returns the full replica NC's
    //bGetFullReplica == FALSE -> function returns the full replica NC's
    HRESULT CreateNamingContext(
        IN BOOL bGetFullReplica,                
        OUT LONG* pObjectCount,
        OUT IWbemClassObject*** pppIndicateItem
        );
    
    HRESULT GetNamingContext(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT GetDomainController(
        IN BSTR bstrKeyValue,
        OUT IWbemClassObject** ppIndicateItem
        );
    
    HRESULT CreateDomainController(
        IN IWbemClassObject** ppIndicateItem
        );


    HRESULT PutAttributesDC(
        IN IWbemClassObject*    pIndicateItem,
        IN IADsPathname*        pPathCracker,
        IN IADs*                pIADsDSA,
        IN BSTR                 bstrDN,
        IN BSTR                 bstrDefaultNC
        );
    
    HRESULT GetDNSRegistrationStatus(
    	OUT BOOL* pfool
    	);

    HRESULT PutUUIDAttribute(
    IN IWbemClassObject* ipNewInst,
    IN LPCWSTR           pstrAttributeName,
    IN UUID&             refuuid);

    HRESULT EnumAndIndicateReplicaSourcePartner(
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrKeyValue = NULL );

    HRESULT EnumAndIndicateWorker(
        IN HANDLE hDS,
        IN IWbemObjectSink *pResponseHandler,
        IN const BSTR bstrKeyValue = NULL,
        IN const BSTR bstrDnsDomainName = NULL );

    HRESULT BuildListStatus(
        IN HANDLE hDS,
        OUT DS_REPL_NEIGHBORSW** ppneighborsstruct);

    HRESULT BuildIndicateArrayStatus(
        IN  DS_REPL_NEIGHBORSW*  pneighborstruct,
        IN  const BSTR          bstrKeyValue,
        OUT IWbemClassObject*** ppaIndicateItems,
        OUT DWORD*              pcIndicateItems);

    void ReleaseIndicateArray(
        IWbemClassObject**  paIndicateItems,
        DWORD               cIndicateItems,
        bool                fReleaseArray = true);

    HRESULT PutAttributesStatus(
        IWbemClassObject**  pipNewInst,
        const BSTR          bstrKeyValue,
        DS_REPL_NEIGHBORW*   pneighbor);

    HRESULT PutBooleanAttributes(
    IWbemClassObject* ipNewInst,
    UINT              cNumAttributes,
    LPCWSTR*          aAttributeNames,
    DWORD*            aBitmasks,
    DWORD             dwValue);
    
    HRESULT PutFILETIMEAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    FILETIME&         reffiletime);
    
    HRESULT PutLONGLONGAttribute(
    IWbemClassObject* ipNewInst,
    LPCWSTR           pcszAttributeName,
    LONGLONG          longlong);

    HRESULT ExtractDomainName(
    LPCWSTR pszNamingContext,
    BSTR*   pbstrDomainName );

    
    //Method helper functions...    
    HRESULT ExecuteKCC(
        IWbemClassObject* pInstance,
        DWORD dwTaskId,
        DWORD dwFlags
        );

    HRESULT ProvDSReplicaSync(
        BSTR bstrFilter,
        ULONG dwOptions
        );

    HRESULT CheckIfDomainController();

    HRESULT ConvertBinaryGUIDtoUUIDString(
        IN  VARIANT vObjGuid,
        OUT LPWSTR * ppszStrGuid
        );
    HRESULT GetDnsRegistration(
        OUT BOOL *pfBool
        );

    HRESULT GetAdvertisingToLocator(
        OUT BOOL *pfBool
        );

    HRESULT GetSysVolReady(
        OUT BOOL *pfBool
        );

    HRESULT GetRidStatus(
        IN  LPWSTR pszDefaultNamingContext,
        OUT PBOOL  pfNextRidAvailable,
        OUT PDWORD  pdwPercentRidAvailable
        );

    HRESULT GetAndUpdateQueueStatistics(
        IN IWbemClassObject*    pIndicateItem
        );
    
    CComPtr<IWbemServices>      m_sipNamespace;
    CComPtr<IWbemClassObject>   m_sipClassDefReplNeighbor;
    CComPtr<IWbemClassObject>   m_sipClassDefDomainController;
    CComPtr<IWbemClassObject>   m_sipClassDefNamingContext;
    CComPtr<IWbemClassObject>   m_sipClassDefPendingOps;
    CComPtr<IWbemClassObject>   m_sipClassDefCursor;
};

#endif 
// !defined(AFX_RPCREPLPROV_H__46D0A58E_207D_4584_BBB4_A357CEB3A51C__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\gpfixup\helper.h ===
// Help information
#define PASSWORD_PROMPT                 L"Please type the password: "
#define PASSWORD_ERROR                  L"There is error in reading the password: "
#define WRONG_PARAMETER                 L"Invalid parameter\n"

#define VALIDATIONS_ERROR1              L"Invalid parameter, either /newdns or /newnb should be specified\n"
#define VALIDATIONS_ERROR7              L"Invalid parameter, /newdns and /olddns should be specified at the same time\n"
#define VALIDATIONS_ERROR2              L"Invalid parameter, /newnb and /oldnb should be specified at the same time\n"
#define VALIDATIONS_ERROR3              L"/newdns is not specifed\n"
#define VALIDATIONS_ERROR4              L"New domain DNS name is identical with old domain DNS name\n"
#define VALIDATIONS_ERROR5              L"New domain NetBIOS name is identical with old domain NetBIOS name. \n"
#define VALIDATIONS_ERROR6              L"Failed to get the DC name\n"
#define VALIDATIONS_RESULT              L"\nValiations of gpfixup passed\n\n"

#define VERIFYNAME_ERROR1               L"Failed to get the DC info : "
#define VERIFYNAME_ERROR2               L"DC is not writable, exit from gpfixup\n"
#define VERIFYNAME_ERROR3               L"New Domain DNS name does not match with the DC\n"
#define VERIFYNAME_ERROR4               L"New Domain NetBIOS name does not match with the DC\n"

#define MEMORY_ERROR                    L"Out of memory: "

#define GPCFILESYSPATH_ERROR1           L"Failed to bind to the object when trying to update gPCFileSysPath : "
#define GPCFILESYSPATH_ERROR2           L"Failed to do SetInfo when trying to update gPCFileSysPath : "
#define GPCWQLFILTER_ERROR1             L"Failed to bind to the object when trying to update gPCWQLFilter : "
#define GPCWQLFILTER_ERROR2             L"Failed to do SetInfo when trying to update gPCWQLFilter : "

#define GPLINK_ERROR1                   L"Failed to bind to the object when trying to update gPLink : "
#define GPLINK_ERROR2                   L"Failed to do SetInfo when trying to update gPLink : "

#define GETDCNAME_ERROR1                L"gpfixup could not get the DC name: "
#define DC_NAME                         L"DC name is "

#define SEARCH_GPLINK_OTHER_ERROR1       L"Failed to bind to the object when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_ERROR2       L"Failed to set the search preference when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_ERROR3       L"Failed to execute search when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_ERROR4       L"Failed to get dn when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_ERROR5       L"Failed to get gpLink when trying to do the search for fixing gpLink other than site : "
#define SEARCH_GPLINK_OTHER_RESULT       L"\nFix objects (not in site) for gPLink passed\n"

#define SEARCH_GPLINK_SITE_ERROR1        L"Failed to bind to the RootDSE when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR2        L"Failed to get rootDomainNamingContext when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR3        L"Failed to bind to the object when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR4        L"Failed to set the search preference when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR5        L"Failed to execute search when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR6        L"Failed to get dn when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_ERROR7        L"Failed to get gpLink when trying to do the search for fixing gpLink in site : "
#define SEARCH_GPLINK_SITE_RESULT        L"\nFix objects for gPLink in site passed\n"

#define SEARCH_GROUPPOLICY_ERROR1        L"Failed to bind to the object when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR2        L"Failed to set the search preference when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR3        L"Failed to execute search when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR4        L"Failed to get dn when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR5        L"Failed to get gpcFileSysPath when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR6        L"Failed to get gpcWQLFilter when trying to do the search in GroupPolicyContainer : "
#define SEARCH_GROUPPOLICY_ERROR7        L"gpcFileSysPath does not exist, it is a must-exist property : "
#define SEARCH_GROUPPOLICY_RESULT        L"\nFix objects in GroupPolicyContainer passed\n"

#define DLL_LOAD_ERROR                   L"Can't load ntdsbmsg.dll\n"
#define ERRORMESSAGE_NOT_FOUND           L"Error message not found\n"

#define DNSNAME_ERROR                    L"DNSName is too long (more than 1024 characters)\n"


const WCHAR    szHelpToken [] = L"/?";
const WCHAR    szOldDNSToken [] = L"/OLDDNS:";
const WCHAR    szNewDNSToken [] = L"/NEWDNS:";
const WCHAR    szOldNBToken [] = L"/OLDNB:";
const WCHAR    szNewNBToken [] = L"/NEWNB:";
const WCHAR    szDCNameToken [] = L"/DC:";
const WCHAR    szUserToken [] = L"/USER:";
const WCHAR    szPasswordToken [] = L"/PWD:";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\jetinfo\getinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       getinfo.c
//
//--------------------------------------------------------------------------

//getinfo.c

#include <windows.h>
#include <commdlg.h>
#include <dsjet.h>
#include <dbopen.h>
#include "jetinfo.h"

INT_PTR CALLBACK GetTableDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK GetColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK GetIndexDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
int PrintTableInfo( HWND hCombo );
int PrintColumnInfo( HWND hCombo1, HWND hCombo2 );
int GetIndexName( HWND hCombo1, HWND hCombo2 );
int PrintIndexInfo( HWND hCombo1, HWND hCombo2 );

char gszDbFilter[] = "Database Files (*.DIT)|*.DIT|Database Files (*.EDB)|*.EDB|All Files (*.*)|*.*|";

BOOL DoFileOpen( HWND hwnd, char* szFilter )
{
    OPENFILENAME ofn;
    int iLen;

    memset( &ofn, 0, sizeof(OPENFILENAME) );

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = achDbName;
    ofn.nMaxFile = MAX_PATH;
    ofn.Flags = OFN_FILEMUSTEXIST;

    for( iLen = strlen(szFilter); iLen > 0; iLen-- )
    {
        if( szFilter[iLen-1] == '|' )
            szFilter[iLen-1] = '\0';
    }

    return GetOpenFileName( &ofn );
}

int OpenDatabase( HWND hwnd )
{
    JET_ERR jError;
    
    if( !DoFileOpen( hwnd, gszDbFilter ) )
        return -1;

    CloseDatabase();

    if( gfDbId )
        return -1;

    //
    // Do JetInit, BeginSession, Attach/OpenDatabase
    //

    jError = DBInitializeJetDatabase( &gjInst, &gjSesId, &gjDbId, achDbName, FALSE);
    if( jError != JET_errSuccess )
    {
        JetError( jError, "DBInit" );
        return -1;
    }
    
    gfDbId = TRUE;
    gfSesId = TRUE;
    OutputMessage( achDbName );
    AppendLineMessage( " is open" );

    return 0;
}

int CloseDatabase()
{
    if( gfDbId )
    {
        if( JetError( JetCloseDatabase( gjSesId, gjDbId, 0 ), "JetCloseDatabase" )
                == JET_errSuccess )
        {
            gfDbId = FALSE;
            achDbName[0] = '\0';
            OutputMessage( "Database is closed" );
            gfTblId = FALSE;
            gszTblName[0] = '\0';
            
            if( gfSesId )
                JetError( JetEndSession( gjSesId, 0 ), "JetEndSession" );
            JetError( JetTerm( gjInst ), "JetTerm" );
            gfSesId = FALSE;
        }
    }

    return 0;
}

int GetTableInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG1), hwnd, GetTableDlgProc );

    return 0;
}

INT_PTR CALLBACK GetTableDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    PrintTableInfo( hCombo );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetTableName( HWND hCombo )
{
    JET_OBJECTLIST  jObjList;
    JET_ERR         jError;
    char szBuf[JET_cbNameMost+1];
    unsigned long ul;
    int iRet = 0;

    memset( szBuf, 0, JET_cbNameMost+1 );

	if( JetError( JetGetObjectInfo( gjSesId, gjDbId, JET_objtypTable, NULL, NULL, &jObjList, 
			sizeof(JET_OBJECTLIST), JET_ObjInfoList ), "JetGetObjectInfo" ) != JET_errSuccess )
        return -1;

	if( JetError( jError=JetMove( gjSesId, jObjList.tableid, JET_MoveFirst, 0 ), "JetMove" ) == JET_errSuccess )
	{
		do
		{
			if( JetError( JetRetrieveColumn( gjSesId, jObjList.tableid, jObjList.columnidobjectname, szBuf, 
						JET_cbNameMost, &ul, 0, NULL ), "JetRetrieveColumn" ) != JET_errSuccess )
			{
				iRet = -1;
				break;
			}

			if( ul <= JET_cbNameMost )
				szBuf[ul] = '\0';
			else
				szBuf[JET_cbNameMost] = '\0';

            SendMessage( hCombo, CB_ADDSTRING, 0, (LPARAM)szBuf );
		}
		while( (jError = JetMove( gjSesId, jObjList.tableid, JET_MoveNext, 0 )) == JET_errSuccess );
	}
	if( jError != JET_errNoCurrentRecord )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}
    
    JetError( JetCloseTable(gjSesId, jObjList.tableid), "JetCloseTable" );

    return iRet;
}

int PrintTableInfo( HWND hCombo )
{
    int iIndex;
    char szBuf[JET_cbNameMost+1];

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );

    if( iIndex == CB_ERR )
        return 0;

    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szBuf );

    OutputMessage( szBuf );

    return 0;
}

int GetColumnInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG2), hwnd, GetColumnDlgProc );

    return 0;
}

INT_PTR CALLBACK GetColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo1, hCombo2;

                    hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                    hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                    PrintColumnInfo( hCombo1, hCombo2 );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            if( LOWORD(wParam) == IDC_BUTTON1 )
                            {
                                HWND hCombo1, hCombo2;

                                hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                GetColumnName( hCombo1, hCombo2, CB_ADDSTRING );
                                return TRUE;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hCombo2;

                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                SendMessage( hCombo2, CB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetColumnName( HWND hCombo1, HWND hCombo2, UINT uMsg )
{
    JET_COLUMNLIST jColList;
    JET_ERR        jError;
    char szBuf[JET_cbNameMost+1];
    int iRet;
    unsigned long ulCount, ul;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szBuf );

	if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szBuf, NULL, &jColList, 
		sizeof(JET_COLUMNLIST), JET_ColInfoList ), "JetGetColumnInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jColList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( ulCount=0; ulCount<jColList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jColList.tableid, jColList.columnidcolumnname, szBuf, 
					JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szBuf[ul] = '\0';
        else
            szBuf[JET_cbNameMost] = '\0';
        SendMessage( hCombo2, uMsg, 0, (LPARAM)szBuf );

		jError = JetMove( gjSesId, jColList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jColList.cRecord )
		JetError( jError, "JetMove" );
    else
        SendMessage( hCombo2, CB_SETCURSEL, 0, 0 );

    JetError( JetCloseTable( gjSesId, jColList.tableid ), "JetCloseTable" );

    return iRet;
}

int PrintColumnInfo( HWND hCombo1, HWND hCombo2 )
{
    JET_COLUMNDEF   jColDef;
    char szTable[JET_cbNameMost+1];
    char szColumn[JET_cbNameMost+1];
    int iRet;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szTable );

    iRet = (int)SendMessage( hCombo2, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo2, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szColumn );

	if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szTable, szColumn, &jColDef, 
		    sizeof(JET_COLUMNDEF), JET_ColInfo ), "JetGetColumnInfo" ) != JET_errSuccess )
		return -1;

    OutputMessage( szTable );
    AppendMessage( szColumn );
    wsprintf( szColumn, "Column ID: %lu", jColDef.columnid );
    AppendMessage( szColumn );
    strcpy( szColumn, "Column Type: " );
    ColtypToStr( jColDef.coltyp, szColumn + strlen(szColumn) );
    AppendMessage( szColumn );
    wsprintf( szColumn, "cbMax: %lu", jColDef.cbMax );
    AppendMessage( szColumn );
    strcpy( szColumn, "Column grbit: " );
    GrbitToStr( jColDef.grbit, szColumn + strlen(szColumn) );
    AppendMessage( szColumn );

    return 0;
}

int GetIndexInfo( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG3), hwnd, GetIndexDlgProc );

    return 0;
}

INT_PTR CALLBACK GetIndexDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo1, hCombo2;

                    hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                    hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                    PrintIndexInfo( hCombo1, hCombo2 );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            if( LOWORD(wParam) == IDC_BUTTON1 )
                            {
                                HWND hCombo1, hCombo2;

                                hCombo1 = GetDlgItem( hwnd, IDC_COMBO1 );
                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                GetIndexName( hCombo1, hCombo2 );
                                return TRUE;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hCombo2;

                                hCombo2 = GetDlgItem( hwnd, IDC_COMBO2 );
                                SendMessage( hCombo2, CB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetIndexName( HWND hCombo1, HWND hCombo2 )
{
    int iRet;
    char szBuf[JET_cbNameMost+1];

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szBuf );

    return GetTableIndexName( szBuf, hCombo2 );
}

int GetTableIndexName( char* szTable, HWND hCombo2 )
{
    JET_INDEXLIST  jIndexList;
    JET_ERR        jError;
    char szBuf[JET_cbNameMost+1];
    int iRet = 0;
    unsigned long ulCount, ul;

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, szTable, NULL, &jIndexList, 
		sizeof(JET_INDEXLIST), JET_IdxInfoList ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( ulCount=0; ulCount<jIndexList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidindexname, szBuf, 
					JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szBuf[ul] = '\0';
        else
            szBuf[JET_cbNameMost] = '\0';

        if( SendMessage( hCombo2, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)szBuf ) == CB_ERR )
            SendMessage( hCombo2, CB_ADDSTRING, 0, (LPARAM)szBuf );

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jIndexList.cRecord )
		JetError( jError, "JetMove" );
    else
        SendMessage( hCombo2, CB_SETCURSEL, 0, 0 );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    return iRet;
}

int PrintIndexInfo( HWND hCombo1, HWND hCombo2 )
{
    JET_INDEXLIST  jIndexList;
    JET_GRBIT      jgrBit;
    JET_ERR         jError;
    char szTable[JET_cbNameMost+1];
    char szIndex[JET_cbNameMost+1];
    int iRet;
    unsigned long ul, ulCount;

    iRet = (int)SendMessage( hCombo1, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo1, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szTable );

    iRet = (int)SendMessage( hCombo2, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo2, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)szIndex );

    OutputMessage( szTable );
    AppendMessage( szIndex );

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, szTable, szIndex, &jIndexList, 
		    sizeof(JET_INDEXLIST), JET_IdxInfo ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

    if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidgrbitIndex, &jgrBit, 
					sizeof(JET_GRBIT), &ul, 0, NULL ) ) != JET_errSuccess )
	{
		JetError( jError, "JetRetrieveColumn" );
		return -1;
	}

    wsprintf( szTable, "Index grbit: 0X%lX", jgrBit );
    AppendMessage( szTable );

	for( ulCount=0; ulCount<jIndexList.cRecord && jError==JET_errSuccess; ulCount++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidcolumnname, 
                    szIndex, JET_cbNameMost, &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        if( ul <= JET_cbNameMost )
            szIndex[ul] = '\0';
        else
            szIndex[JET_cbNameMost] = '\0';

        AppendMessage( szIndex );

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( ulCount < jIndexList.cRecord )
		JetError( jError, "JetMove" );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\jetinfo\jetinfo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jetinfo.h
//
//--------------------------------------------------------------------------

//jetinfo.h

#ifndef _JETINFO_H
#define _JETINFO_H

#define     IDM_DA_OPEN     100
#define     IDM_DA_CLOSE    101
#define		IDM_DA_EXIT     102

#define	    IDM_IN_TABLE    200
#define	    IDM_IN_COLUMN   201
#define     IDM_IN_INDEX    203

#define	    IDM_RE_COLUMN   300
#define	    IDM_RE_SEEK     301
#define     IDM_RE_MODIFY   302
#define	    IDM_RE_FIRST    303
#define	    IDM_RE_LAST     304
#define	    IDM_RE_PREV     305
#define	    IDM_RE_NEXT     306

#define IDD_DIALOG1                     101
#define IDD_DIALOG2                     102
#define IDD_DIALOG3                     103
#define IDD_DIALOG4                     104
#define IDD_DIALOG5                     105
#define IDD_DIALOG6                     106

#define IDC_BUTTON1                     1000
#define IDC_BUTTON2                     1001
#define IDC_BUTTON3                     1002
#define IDC_BUTTON4                     1003
#define IDC_BUTTON5                     1004

#define IDC_COMBO1                      1010
#define IDC_COMBO2                      1011

#define IDC_CHECK1                      1020

#define IDC_LIST1                       1030
#define IDC_LIST2                       1031

#define IDC_EDIT1                       1040
#define IDC_EDIT2                       1041
#define IDC_EDIT3                       1042
#define IDC_EDIT4                       1043
#define IDC_EDIT5                       1044

#define IDC_STATIC                      -1

#define MAX_CHAR    110
#define MAX_LINE    64
extern int giLine;
extern char aLines[MAX_LINE][MAX_CHAR];
extern long aLen[MAX_LINE];

extern HINSTANCE   ghInstance;
extern char achDbName[MAX_PATH];

extern JET_INSTANCE    gjInst;
extern JET_SESID       gjSesId;
extern JET_DBID        gjDbId;
extern JET_TABLEID     gjTblId;
extern char            gszTblName[JET_cbNameMost+1];
extern JET_COLUMNDEF*  gpjColDef;
extern char**          gppColName;
extern long            glColCount;

//status flags
extern BOOL            gfSesId;
extern BOOL            gfDbId;     
extern BOOL            gfTblId;     

//Record page
#define RECORD_PAGE 10

int OutputMessage( char* szMsg );
int AppendMessage( char* szMsg );
int OutputBuffer( char* szMsg, long lLen );
int AppendBuffer( char* szMsg, long lLen );
int AppendLineMessage( char* szMsg );
int AppendLineOutput( char* szMsg, long lLen );
int ResetScreenContent();
JET_ERR JetError( JET_ERR jErr, char* sz );

int OpenDatabase( HWND hwnd );
int CloseDatabase();
int GetTableInfo( HWND hwnd );
int GetColumnInfo( HWND hwnd );
int GetIndexInfo( HWND hwnd );
int GetTableName( HWND hCombo );
int GetColumnName( HWND hCombo1, HWND hCombo2, UINT uMsg );
int GetTableIndexName( char* szTable, HWND hCombo );
int SelectColumn( HWND hwnd );
int PrintRecord( int iRecCount );
int DoSeekRecord( HWND hwnd );
int DoModifyRecord( HWND hwnd );
int ColtypToStr( JET_COLTYP coltyp, char* szBuf );
int GrbitToStr( JET_GRBIT grbit, char* szBuf );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\jetinfo\jetinfo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       jetinfo.c
//
//--------------------------------------------------------------------------

#define STRICT
#include <windows.h>
#include <dsjet.h>
#include <dbopen.h>
#include "jetinfo.h"
#include <stdlib.h>

LRESULT CALLBACK JetInfoWndProc(HWND, UINT, WPARAM, LPARAM);

HINSTANCE   ghInstance;
HWND        ghWnd;
char achWndClass[] = "JETINFO:MAIN";
char achAppName[] = "JetInfo";

char achDbName[MAX_PATH];

//screen data
//giLine is the number of lines containing content, or the next available line index (0 based)
int giLine = 0; 
char aLines[MAX_LINE][MAX_CHAR];
long aLen[MAX_LINE];

//JET variables
JET_INSTANCE    gjInst;
JET_SESID       gjSesId;
JET_DBID        gjDbId;
JET_TABLEID     gjTblId;
char            gszTblName[JET_cbNameMost+1];
JET_COLUMNDEF*  gpjColDef = NULL;
char**          gppColName = NULL;
long            glColCount = 0;

//status flags
BOOL            gfSesId = FALSE;
BOOL            gfDbId = FALSE;     
BOOL            gfTblId = FALSE;     

int PASCAL WinMain ( HINSTANCE hInstance,
					 HINSTANCE hPrevInstance,
					 LPSTR	lpszCmdLine,
					 int	cmdShow)
{
	HWND	hwnd;
	MSG		msg;
	WNDCLASS	wndclass;

	if (!hPrevInstance)
	{
		wndclass.lpszClassName	= achWndClass;
		wndclass.hInstance	    = hInstance;
		wndclass.lpfnWndProc	= JetInfoWndProc;
		wndclass.hCursor	    = LoadCursor (NULL, IDC_ARROW);
		wndclass.hIcon		    = LoadIcon (NULL, IDI_APPLICATION);
		wndclass.lpszMenuName	= "MainMenu";
		wndclass.hbrBackground	= (HBRUSH)(COLOR_WINDOW+1);
		wndclass.style		    = CS_HREDRAW | CS_VREDRAW;
		wndclass.cbClsExtra	    = 0;
		wndclass.cbWndExtra	    = 0;

		RegisterClass(&wndclass);
	} 
    else
        return 0;

    ghInstance = hInstance;
	
	hwnd = CreateWindowEx(0L,
						achWndClass,
						achAppName,
						WS_OVERLAPPEDWINDOW,
						CW_USEDEFAULT,
						0,
						CW_USEDEFAULT,
						0,
						NULL,
						NULL,
						hInstance,
						NULL);
	
    ghWnd = hwnd;
    					
	ShowWindow(hwnd, cmdShow);
   
	while (GetMessage(&msg,0,0,0))
	{	
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
    
	return 0;
}

LRESULT CALLBACK JetInfoWndProc (HWND	hwnd,
							 UINT	mMsg,
							 WPARAM	wParam,
							 LPARAM	lParam)
{
	switch (mMsg)
	{
        case WM_COMMAND:
        {
            switch ( wParam )
            {
                case IDM_DA_OPEN:
                    OpenDatabase( hwnd );
                    break;

                case IDM_DA_CLOSE:
                    CloseDatabase();
                    break;

                case IDM_DA_EXIT:
                    DestroyWindow( hwnd );
                    break;

                case IDM_IN_TABLE:
                    GetTableInfo( hwnd );
                    break;

                case IDM_IN_COLUMN:
                    GetColumnInfo( hwnd );
                    break;

                case IDM_IN_INDEX:
                    GetIndexInfo( hwnd );
                    break;

                case IDM_RE_COLUMN:
                    SelectColumn( hwnd );
                    break;

                case IDM_RE_SEEK:
                    DoSeekRecord( hwnd );
                    break;

                case IDM_RE_MODIFY:
                    DoModifyRecord( hwnd );
                    break;

                case IDM_RE_FIRST:
                    if( gfTblId )
                    {
                        if( JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                == JET_errSuccess )
                            PrintRecord( RECORD_PAGE );
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_LAST:
                    if( gfTblId )
                    {
                        JET_ERR jError;

                        if( JetError( JetMove( gjSesId, gjTblId, JET_MoveLast, 0 ), "JetMove" )
                                == JET_errSuccess )
                        {
                            jError = JetMove( gjSesId, gjTblId, 1 - RECORD_PAGE, 0 );
                            if( jError == JET_errSuccess
                             || ( jError == JET_errNoCurrentRecord 
                                && JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                    == JET_errSuccess ) )
                                PrintRecord( RECORD_PAGE );
                        }
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_PREV:
                    if( gfTblId )
                    {
                        JET_ERR jError;

                        jError = JetMove( gjSesId, gjTblId, -2 * RECORD_PAGE, 0 );
                        if( jError == JET_errSuccess
                         || ( jError == JET_errNoCurrentRecord 
                            && JetError( JetMove( gjSesId, gjTblId, JET_MoveFirst, 0 ), "JetMove" )
                                == JET_errSuccess ) )
                            PrintRecord( RECORD_PAGE );
                    }
                    else
                        OutputMessage( "Table not open" );
                    break;

                case IDM_RE_NEXT:
                    if( gfTblId )
                        PrintRecord( RECORD_PAGE );
                    else
                        OutputMessage( "Table not open" );
                    break;

                default:
                    break;
            }

            InvalidateRect(hwnd, NULL, TRUE);
        }
            break;

        case WM_CREATE:
            ResetScreenContent();

            DBSetRequiredDatabaseSystemParameters (&gjInst);

            break;

        case WM_DESTROY:
            CloseDatabase();
            if( gpjColDef )
            {
                free( gpjColDef );
                gpjColDef = NULL;
            }
            if( gppColName )
            {
                int i;

                for( i=0; i<glColCount; i++ )
                {
                    if( *(gppColName + i) )
                        free( *(gppColName + i) );
                }
                free( gppColName );
            }

			PostQuitMessage(0);
			break;
        
        case WM_PAINT:
        {
            PAINTSTRUCT ps;
            int iLine, ix, iy;
            TEXTMETRIC tm;
            HFONT hOldFont;

            BeginPaint( hwnd, &ps );
            hOldFont = SelectObject( ps.hdc, GetStockObject(ANSI_FIXED_FONT) );
            GetTextMetrics( ps.hdc, &tm );
            for( iLine=0, ix=tm.tmAveCharWidth/2, iy=(tm.tmHeight+tm.tmExternalLeading)/2; 
                iLine < giLine; iLine++, iy+=tm.tmHeight+tm.tmExternalLeading )
            {
                TextOut( ps.hdc, ix, iy, aLines[iLine], 
                        aLen[iLine] > MAX_CHAR ? MAX_CHAR : aLen[iLine] );
            }
            SelectObject( ps.hdc, hOldFont );
            EndPaint( hwnd, &ps );
        }
            break;

		default:
			return (DefWindowProc(hwnd,mMsg,wParam,lParam));
	}
	return 0L;
}

int OutputMessage( char* szMsg )
{
    return OutputBuffer( szMsg, strlen(szMsg) );
}

int OutputBuffer( char* szMsg, long lLen )
{
    ResetScreenContent();

    return AppendBuffer( szMsg, lLen );
}

int AppendMessage( char* szMsg )
{
    return AppendBuffer( szMsg, strlen(szMsg) );
}

int AppendBuffer( char* szMsg, long lLen )
{
    long lOffset = 0;

    while( lLen >= MAX_CHAR && giLine < MAX_LINE )
    {
        memcpy( aLines[giLine], szMsg + lOffset, MAX_CHAR );
        aLen[giLine] = MAX_CHAR;
        lOffset += MAX_CHAR;
        lLen -= MAX_CHAR;
        giLine++;
    }

    if( lLen > 0 && giLine < MAX_LINE )
    {
        memcpy( aLines[giLine], szMsg + lOffset, lLen );
        aLen[giLine] = lLen;
        giLine++;
    }

    return 0;
}

int ResetScreenContent()
{
    memset( aLines[0], 0, MAX_LINE*MAX_CHAR );
    memset( aLen, 0, MAX_LINE*sizeof(long) );
    giLine = 0;

    return 0;
}

int AppendLineMessage( char* szMsg )
{
    return AppendLineOutput( szMsg, strlen(szMsg) );
}

int AppendLineOutput( char* szMsg, long lLen )
{//This function appends szMsg to the end of last line (line index is giLine-1)
    if( giLine > MAX_LINE )
        return -1;

    if( aLen[giLine-1] + lLen < MAX_CHAR )
    {
        memcpy( aLines[giLine-1] + aLen[giLine-1], szMsg, lLen );
        aLen[giLine-1] += lLen;
    }
    else
    {//advance line
        long lOffset;

        memcpy( aLines[giLine-1] + aLen[giLine-1], szMsg, MAX_CHAR - aLen[giLine-1] );
        lOffset = MAX_CHAR - aLen[giLine-1];
        lLen -= (MAX_CHAR - aLen[giLine-1]);
        aLen[giLine-1] = MAX_CHAR;

        while( lLen >= MAX_CHAR && giLine < MAX_LINE )
        {
            memcpy( aLines[giLine], szMsg + lOffset, MAX_CHAR );
            aLen[giLine] = MAX_CHAR;
            lOffset += MAX_CHAR;
            lLen -= MAX_CHAR;
            giLine++;
        }

        if( lLen > 0 && giLine < MAX_LINE )
        {
            memcpy( aLines[giLine], szMsg + lOffset, lLen );
            aLen[giLine] = lLen;
            giLine++;
        }
    }

    return 0;
}

JET_ERR JetError( JET_ERR jErr, char* sz )
{
    if( jErr != JET_errSuccess )
    {
        wsprintf( aLines[giLine], "%s returns error: %li", sz, jErr );
        giLine++;
    }

    return jErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\jetinfo\record.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       record.c
//
//--------------------------------------------------------------------------

//record.c

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dsjet.h>
#include "jetinfo.h"

#define TEMP_BUF_SIZE   MAX_CHAR

INT_PTR CALLBACK SelectColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK SeekRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
INT_PTR CALLBACK ModifyRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

int OpenTable( HWND hCombo );
int MoveColumnName( HWND hList1, HWND hList2 );
int MoveSelectColumnName( HWND hList1, HWND hList2 );
int GetColumns( HWND hCombo, HWND hCtrl );
int SeekRecord( HWND hCombo, HWND hList );
int SelectCurrentIndex( HWND hCombo );
int AppendCurrentRecord();
int PrintCurrentRecord();
int GetOpenTableColumns( HWND hCombo );
int SetColumnProperties( int iCol, HWND hEditType, HWND hEditGrbit );
int GetColumnValue( int iCol, HWND hList );
int ResetNewValue( HWND hwnd );
int ModifyRecordColumn( int iCol, HWND hEditNewValue, HWND hEditTagSeq, HWND hEditLongOffset );

int SelectColumn( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfDbId || ! gfSesId )
    {
        OutputMessage( "Database not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG4), hwnd, SelectColumnDlgProc );

    return 0;
}

INT_PTR CALLBACK SelectColumnDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hList2;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    if( ! OpenTable( hCombo ) )
                    {
                        hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                        GetColumns( hCombo, hList2 );
                    }
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            switch( LOWORD(wParam) )
                            {
                                case IDC_BUTTON1:
                                {
                                    HWND hCombo, hList;

                                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                    GetColumnName( hCombo, hList, LB_ADDSTRING );
                                    //Clear the content in list box 2
                                    hList = GetDlgItem( hwnd, IDC_LIST2 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );

                                    return TRUE;
                                }

                                case IDC_BUTTON2:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveColumnName( hList1, hList2 );

                                    return TRUE;
                                }

                                case IDC_BUTTON3:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveSelectColumnName( hList1, hList2 );

                                    return TRUE;
                                }

                                case IDC_BUTTON4:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveSelectColumnName( hList2, hList1 );

                                    return TRUE;
                                }

                                case IDC_BUTTON5:
                                {
                                    HWND hList1, hList2;

                                    hList1 = GetDlgItem( hwnd, IDC_LIST1 );
                                    hList2 = GetDlgItem( hwnd, IDC_LIST2 );
                                    MoveColumnName( hList2, hList1 );

                                    return TRUE;
                                }

                                default:
                                    break;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hList;

                                hList = GetDlgItem( hwnd, IDC_LIST1 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                hList = GetDlgItem( hwnd, IDC_LIST2 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );

                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableName( hCombo );
            SendMessage( hCombo, CB_SETCURSEL, 0, 0 );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int OpenTable( HWND hCombo )
{
    int iRet;

    if( gfTblId )
    {
        if( JetError( JetCloseTable( gjSesId, gjTblId ), "JetCloseTable" ) == JET_errSuccess )
        {
            gfTblId = FALSE;
            gszTblName[0] = '\0';
        }
        else
            return -1;
    }

    //Gettable name
    iRet = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iRet == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iRet, (LPARAM)gszTblName );

    if( JetError( JetOpenTable( gjSesId, gjDbId, gszTblName, NULL, 0, 0, &gjTblId ), "JetOpenTable" )
            == JET_errSuccess )
    {
        gfTblId = TRUE;
        OutputMessage( gszTblName );
        AppendLineMessage( " is open" );
        return 0;
    }
    else
    {
        gszTblName[0] = '\0';
        return -1;
    }
}

int MoveColumnName( HWND hList1, HWND hList2 )
{
    char szBuf[JET_cbNameMost+1];
    int iCount, i;

    iCount = (int)SendMessage( hList1, LB_GETCOUNT, 0, 0 );
    for( i=0; i<iCount; i++ )
    {
        SendMessage( hList1, LB_GETTEXT, (WPARAM)i, (LPARAM)szBuf );
        SendMessage( hList2, LB_ADDSTRING, 0, (LPARAM)szBuf );
    }

    SendMessage( hList1, LB_RESETCONTENT, 0, 0 );

    return 0;
}

int MoveSelectColumnName( HWND hList1, HWND hList2 )
{
    char szBuf[JET_cbNameMost+1];
    int iIndex;

    iIndex = (int)SendMessage( hList1, LB_GETCURSEL, 0, 0 );
    if( iIndex == LB_ERR )
        return -1;

    SendMessage( hList1, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szBuf );
    SendMessage( hList2, LB_ADDSTRING, 0, (LPARAM)szBuf );
    SendMessage( hList1, LB_DELETESTRING, (WPARAM)iIndex, 0 );

    return 0;
}

int GetColumns( HWND hCombo, HWND hList )
{
    char szTable[JET_cbNameMost+1];
    char szColumn[JET_cbNameMost+1];
    int iIndex, i;

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iIndex == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szTable );

    iIndex = (int)SendMessage( hList, LB_GETCOUNT, 0, 0 );
    if( iIndex == LB_ERR )
        return -1;

    if( gppColName )
    {
        for( i=0; i<glColCount; i++ )
        {
            if( *(gppColName + i) )
                free( *(gppColName + i) );
        }
    }

    if( iIndex == 0 )
    {
        if( gpjColDef )
        {
            free( gpjColDef );
            gpjColDef = NULL;
        }

        if( gppColName )
        {
            free( gppColName );
            gppColName = NULL;
        }
    }

    gpjColDef = (JET_COLUMNDEF*)realloc( gpjColDef, iIndex * sizeof(JET_COLUMNDEF) );
    gppColName = (char**)realloc( gppColName, iIndex * sizeof(char*) );
    if( gpjColDef == NULL || gppColName == NULL )
        return -1;
    glColCount = iIndex;
    memset( gppColName, 0, iIndex * sizeof(char*) );

    for( i=0; i<iIndex; i++ )
    {
        SendMessage( hList, LB_GETTEXT, (WPARAM)i, (LPARAM)szColumn );
        
        *(gppColName + i) = (char*)malloc( strlen(szColumn) + 1);
        if( *(gppColName + i) == NULL )
            return -1;
        strcpy( *(gppColName + i), szColumn );
	    if( JetError( JetGetColumnInfo( gjSesId, gjDbId, szTable, szColumn, gpjColDef + i, 
		        sizeof(JET_COLUMNDEF), JET_ColInfo ), "JetGetColumnInfo" ) != JET_errSuccess )
		    return -1;
    }

    return 0;
}

int PrintRecord( int iRecCount )
{//Table cursor has been moved to the location of the first record to print
    int i;
    JET_ERR jError = JET_errSuccess;

    if( glColCount == 0 )
        return 0;
    OutputMessage( *gppColName );
    for( i=1; i<glColCount; i++ )
    {
        AppendLineOutput( ";", 1 );
        AppendLineOutput( *(gppColName+i), strlen(*(gppColName+i)) );
    }

    for( i=0; (i<iRecCount) && (jError==JET_errSuccess); i++ )
    {
        if( AppendCurrentRecord() )
            break;
        jError = JetMove( gjSesId, gjTblId, JET_MoveNext, 0 );
    }

    return 0;
}

int AppendCurrentRecord()
{
    int j, iOffset, iSize;
    char pBuf[TEMP_BUF_SIZE];
    char pCol[TEMP_BUF_SIZE];
    unsigned long ulActual;
    JET_ERR jError = JET_errSuccess;
    JET_COLUMNDEF* pjColDef;
    JET_RETINFO jRetInfo;

    jRetInfo.cbStruct = sizeof( JET_RETINFO );
    jRetInfo.ibLongValue = 0;

    for( j=0, iOffset=0; j<glColCount; j++ )
    {
        jRetInfo.itagSequence = 1;
        pjColDef = gpjColDef + j;

        do
        {
            jError = JetRetrieveColumn( gjSesId, gjTblId, pjColDef->columnid, pCol, TEMP_BUF_SIZE,
                        &ulActual, 0, &jRetInfo );

            if( jError != JET_errSuccess )
            {
                if( jError == JET_wrnColumnNull )
                {//If this is the first tag sequence, print "(0)", plus separator ";" when needed
                    if( jRetInfo.itagSequence == 1 )
                    {
                        if( j == 0 )
                            AppendMessage( "(0)" );
                        else
                            AppendLineMessage( ";(0)" );
                    }

                    break;
                }
                else if( jError != JET_wrnBufferTruncated )
                {
                    JetError( jError, "JetRetrieveColumn" );
                    return -1;
                }
            }

            wsprintf( pBuf, "(%lu)", ulActual );
            if( j==0 && jRetInfo.itagSequence == 1 )
                AppendMessage( pBuf );
            else
            {
                if( jRetInfo.itagSequence == 1 )
                    AppendLineMessage( ";" );
                else
                    AppendLineMessage( "," );
                AppendLineOutput( pBuf, strlen(pBuf) );
            }

            switch( pjColDef->coltyp )
            {
                case JET_coltypText:
                case JET_coltypLongText:
                    AppendLineOutput( pCol, (ulActual>TEMP_BUF_SIZE) ? TEMP_BUF_SIZE : (long)ulActual );
                    break;

                case JET_coltypLong:
                    iSize = wsprintf( pBuf, "%li", *(long*)pCol );
                    AppendLineOutput( pBuf, iSize );
                    break;

                default:
                    iSize = 0;
                    for( iOffset = 0; ulActual > 0 && iOffset < 8; ulActual--, iOffset++ )
                    {
                        iSize += wsprintf( pBuf + iSize, "%02X", *(pCol+iOffset) );
                    }
                    AppendLineOutput( pBuf, iSize );
                    break;
            }

            jRetInfo.itagSequence++;
        }
        while( JET_bitColumnTagged & pjColDef->grbit );
    }

    return 0;
}

int PrintCurrentRecord()
{//Table cursor has been moved to the location of the current record to print
    int i;

    if( glColCount == 0 )
        return 0;
    OutputMessage( *gppColName );
    for( i=1; i<glColCount; i++ )
    {
        AppendLineOutput( ";", 1 );
        AppendLineOutput( *(gppColName+i), strlen(*(gppColName+i)) );
    }

    AppendCurrentRecord();

    return 0;
}

int DoSeekRecord( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfTblId )
    {
        OutputMessage( "Table not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG5), hwnd, SeekRecordDlgProc );

    return 0;
}

INT_PTR CALLBACK SeekRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hList;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                    SeekRecord( hCombo, hList );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    switch( HIWORD(wParam) )
                    {
                        case BN_CLICKED: 
                            switch( LOWORD(wParam) )
                            {
                                case IDC_BUTTON1:
                                {
                                    HWND hEdit, hList;
                                    char pKey[TEMP_BUF_SIZE+1];

                                    hEdit = GetDlgItem( hwnd, IDC_EDIT1 );
                                    GetWindowText( hEdit, pKey, TEMP_BUF_SIZE );
                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_ADDSTRING, 0, (LPARAM)pKey );
                                    return TRUE;
                                }

                                case IDC_BUTTON2:
                                {
                                    HWND hList;

                                    hList = GetDlgItem( hwnd, IDC_LIST1 );
                                    SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                    return TRUE;
                                }

                                default:
                                    break;
                            }
                            break;

                        case CBN_SELCHANGE:
                            if( LOWORD(wParam) == IDC_COMBO1 )
                            {
                                HWND hList;

                                hList = GetDlgItem( hwnd, IDC_LIST1 );
                                SendMessage( hList, LB_RESETCONTENT, 0, 0 );
                                return TRUE;
                            }
                            break;

                        default:
                            break;
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetTableIndexName( gszTblName, hCombo );
            SelectCurrentIndex( hCombo );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int SelectCurrentIndex( HWND hCombo )
{
    char szIndex[JET_cbNameMost+1];
    int iIndex = 0;

    if( JetError( JetGetCurrentIndex( gjSesId, gjTblId, szIndex, JET_cbNameMost ), "JetGetCurrentIndex" ) 
            == JET_errSuccess )
    {
        iIndex = (int)SendMessage( hCombo, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)szIndex );
        iIndex = (iIndex == CB_ERR) ? 0 : iIndex;
    }

    SendMessage( hCombo, CB_SETCURSEL, (WPARAM)iIndex, 0 );

    return 0;
}

int SeekRecord( HWND hCombo, HWND hList )
{
    JET_INDEXLIST  jIndexList;
    JET_COLTYP      jColtyp;
    JET_ERR         jError;
    char szBuf[JET_cbNameMost+1];
    int iIndex, iCount, iLen, i, iRet;
    unsigned long ul;

    iIndex = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
    if( iIndex == CB_ERR )
        return -1;
    SendMessage( hCombo, CB_GETLBTEXT, (WPARAM)iIndex, (LPARAM)szBuf );

    iCount = (int)SendMessage( hList, LB_GETCOUNT, 0, 0 );

    if( JetError( JetSetCurrentIndex2(gjSesId, gjTblId, szBuf, JET_bitMoveFirst), "JetSetCurrentIndex" ) 
            != JET_errSuccess )
        return -1;

	if( JetError( JetGetIndexInfo( gjSesId, gjDbId, gszTblName, szBuf, &jIndexList, 
		    sizeof(JET_INDEXLIST), JET_IdxInfo ), "JetGetIndexInfo" ) != JET_errSuccess )
		return -1;

	jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveFirst, 0 );
	if( jError != JET_errSuccess )
	{
		JetError( jError, "JetMove" );
		iRet = -1;
	}

	for( iIndex=0; (iIndex<iCount) && (iIndex<(int)jIndexList.cRecord) && (jError==JET_errSuccess); 
            iIndex++ )
	{				
		if( (jError = JetRetrieveColumn( gjSesId, jIndexList.tableid, jIndexList.columnidcoltyp, 
                    &jColtyp, sizeof(JET_COLTYP), &ul, 0, NULL ) ) != JET_errSuccess )
		{
			JetError( jError, "JetRetrieveColumn" );
			iRet = -1;
			break;
		}

        iLen = (int)SendMessage( hList, LB_GETTEXTLEN, (WPARAM)iIndex, 0 );
        if( (iLen != LB_ERR) && (iLen <= JET_cbNameMost) )
            SendMessage( hList, LB_GETTEXT, (WPARAM)iIndex, (LPARAM)szBuf );
        else
        {
            OutputMessage( "Value too long" );
			iRet = -1;
			break;
        }

        switch( jColtyp )
        {
            case JET_coltypText:
            case JET_coltypLongText:
                break;

            case JET_coltypLong:
            {
                long lTemp;

                lTemp = atol(szBuf);
                memcpy( szBuf, &lTemp, sizeof(long) );
                iLen = sizeof(long);
            }
                break;

            default:
                //binary format
                iLen /= 2;
                for( i=0; i<iLen; i++ )
                {
                    unsigned long ulTemp;

                    sscanf( szBuf+2*i, "%2x", &ulTemp );
                    szBuf[i] = (char)((unsigned char)ulTemp);
                }
                break;
        }

		if( (jError = JetMakeKey( gjSesId, gjTblId, szBuf, (unsigned long)iLen, 
                iIndex ? 0 : JET_bitNewKey )) != JET_errSuccess )
		{
			JetError( jError, "JetMakeKey" );
			iRet = -1;
			break;
		}

		jError = JetMove( gjSesId, jIndexList.tableid, JET_MoveNext, 0 );
	}

    if( (iIndex != iCount) && (iIndex != (int)jIndexList.cRecord) )
		JetError( jError, "JetMove" );

    JetError( JetCloseTable( gjSesId, jIndexList.tableid ), "JetCloseTable" );

    jError = JetError( JetSeek( gjSesId, gjTblId, JET_bitSeekGE ), "JetSeek" );
    if( jError == JET_errSuccess 
     || jError == JET_wrnSeekNotEqual )
        PrintCurrentRecord();   //Cursor remains on current record

    return 0;
}

int DoModifyRecord( HWND hwnd )
{
    INT_PTR iRet;

    if( ! gfTblId )
    {
        OutputMessage( "Table not open" );
        return 0;
    }

    iRet = DialogBox( ghInstance, MAKEINTRESOURCE(IDD_DIALOG6), hwnd, ModifyRecordDlgProc );

    return 0;
}

INT_PTR CALLBACK ModifyRecordDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch( uMsg )
    {
        case WM_COMMAND:
        {
            switch( wParam )
            {
                case IDOK:
                {
                    HWND hCombo, hEditNewValue, hEditTagSeq, hEditLongOffset;
                    int iCol;

                    hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                    iCol = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
                    hEditNewValue = GetDlgItem( hwnd, IDC_EDIT3 );
                    hEditTagSeq = GetDlgItem( hwnd, IDC_EDIT4 );
                    hEditLongOffset = GetDlgItem( hwnd, IDC_EDIT5 );
                    ModifyRecordColumn( iCol, hEditNewValue, hEditTagSeq, hEditLongOffset );
                }
                case IDCANCEL:
                    EndDialog( hwnd, 0 );
                    break;

                default:
                    if( (HIWORD(wParam) == CBN_SELCHANGE) && (LOWORD(wParam) == IDC_COMBO1) )
                    {
                        HWND hCombo, hEditType, hEditGrbit, hList;
                        int iItem;

                        hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
                        iItem = (int)SendMessage( hCombo, CB_GETCURSEL, 0, 0 );
                        hEditType = GetDlgItem( hwnd, IDC_EDIT1 );
                        hEditGrbit = GetDlgItem( hwnd, IDC_EDIT2 );
                        SetColumnProperties( iItem, hEditType, hEditGrbit );
                        hList = GetDlgItem( hwnd, IDC_LIST1 );
                        GetColumnValue( iItem, hList );
                        ResetNewValue( hwnd );
                    }

                    return FALSE;
            }
        }
            break;

        case WM_INITDIALOG:
        {
            HWND hCombo, hEditType, hEditGrbit, hList;

            hCombo = GetDlgItem( hwnd, IDC_COMBO1 );
            GetOpenTableColumns( hCombo );
            hEditType = GetDlgItem( hwnd, IDC_EDIT1 );
            hEditGrbit = GetDlgItem( hwnd, IDC_EDIT2 );
            SetColumnProperties( 0, hEditType, hEditGrbit );
            hList = GetDlgItem( hwnd, IDC_LIST1 );
            GetColumnValue( 0, hList );
            ResetNewValue( hwnd );
        }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

int GetOpenTableColumns( HWND hCombo )
{
    long lCount;

	for( lCount=0; lCount<glColCount; lCount++ )
	{				
        SendMessage( hCombo, CB_ADDSTRING, 0, (LPARAM)*(gppColName + lCount) );
	}

    SendMessage( hCombo, CB_SETCURSEL, 0, 0 );

    return 0;
}

int SetColumnProperties( int iCol, HWND hEditType, HWND hEditGrbit )
{
    char szBuf[64];

    ColtypToStr( gpjColDef[iCol].coltyp, szBuf );
    SetWindowText( hEditType, szBuf );

    GrbitToStr( gpjColDef[iCol].grbit, szBuf );
    SetWindowText( hEditGrbit, szBuf );

    return 0;
}

int ColtypToStr( JET_COLTYP coltyp, char* szBuf )
{
    switch( coltyp )
    {
        case JET_coltypBit:
            strcpy( szBuf, "Bit" );
            break;
        case JET_coltypUnsignedByte:
            strcpy( szBuf, "UnsignedByte" );
            break;
        case JET_coltypShort:
            strcpy( szBuf, "Short" );
            break;
        case JET_coltypLong:
            strcpy( szBuf, "Long" );
            break;
        case JET_coltypCurrency:
            strcpy( szBuf, "Currency" );
            break;
        case JET_coltypIEEESingle:
            strcpy( szBuf, "IEEESingle" );
            break;
        case JET_coltypIEEEDouble:
            strcpy( szBuf, "IEEEDouble" );
            break;
        case JET_coltypDateTime:
            strcpy( szBuf, "DateTime" );
            break;
        case JET_coltypBinary:
            strcpy( szBuf, "Binary" );
            break;
        case JET_coltypText:
            strcpy( szBuf, "Text" );
            break;
        case JET_coltypLongBinary:
            strcpy( szBuf, "LongBinary" );
            break;
        case JET_coltypLongText:
            strcpy( szBuf, "LongText" );
            break;
        default:
            strcpy( szBuf, "Unknown" );
            break;
    }

    return 0;
}

int GrbitToStr( JET_GRBIT grbit, char* szBuf )
{
    szBuf[0] = '\0';
    if( grbit & JET_bitColumnFixed )
        strcat( szBuf, "Fixed;" );
    if( grbit & JET_bitColumnTagged )
        strcat( szBuf, "Tagged;" );
    if( grbit & JET_bitColumnNotNULL )
        strcat( szBuf, "NotNULL;" );
    if( grbit & JET_bitColumnVersion )
        strcat( szBuf, "Version;" );
    if( grbit & JET_bitColumnAutoincrement )
        strcat( szBuf, "Autoincrement;" );
    if( grbit & JET_bitColumnMultiValued )
        strcat( szBuf, "MultiValued;" );

    if( szBuf[0] != '\0' )
        szBuf[strlen(szBuf) - 1] = '\0';

    return 0;
}

int GetColumnValue( int iCol, HWND hList )
{
    JET_RETINFO jRetInfo;
    JET_ERR jError;
    char szBuf[TEMP_BUF_SIZE];
    unsigned long ulActual;

    SendMessage( hList, LB_RESETCONTENT, 0, 0 );

    jRetInfo.cbStruct = sizeof(JET_RETINFO);
    jRetInfo.ibLongValue = 0;
    jRetInfo.itagSequence = 0;
    do
    {
        jRetInfo.itagSequence++;
        jError = JetRetrieveColumn( gjSesId, gjTblId, gpjColDef[iCol].columnid, szBuf, TEMP_BUF_SIZE,
                        &ulActual, 0, &jRetInfo );

        if( jError != JET_errSuccess )
        {
            if( jError == JET_wrnColumnNull )
                break;
            else if( jError != JET_wrnBufferTruncated )
            {
                JetError( jError, "JetRetrieveColumn" );
                return -1;
            }
        }

        switch( gpjColDef[iCol].coltyp )
        {
            case JET_coltypText:
            case JET_coltypLongText:
                if( ulActual < TEMP_BUF_SIZE )
                    szBuf[ulActual] = '\0';
                else
                    szBuf[TEMP_BUF_SIZE - 1] = '\0';
                break;

            case JET_coltypLong:
            {
                long lTemp;

                lTemp = *(long*)szBuf;
                wsprintf( szBuf, "%li", lTemp );
            }
                break;

            default:
            {
                char szTemp[TEMP_BUF_SIZE];
                int iOffset;

                memcpy( szTemp, szBuf, TEMP_BUF_SIZE );
                iOffset = wsprintf( szBuf, "0X%02X", *szTemp );
                iOffset += wsprintf( szBuf + iOffset, "%02X", *(szTemp+1) );
                iOffset += wsprintf( szBuf + iOffset, "%02X", *(szTemp+2) );
                wsprintf( szBuf + iOffset, "%02X", *(szTemp+3) );
            }
                break;
        }

        SendMessage( hList, LB_ADDSTRING, 0, (LPARAM)szBuf );
    }
    while( gpjColDef[iCol].grbit & JET_bitColumnTagged );

    return 0;
}

int ResetNewValue( HWND hwnd )
{
    HWND hEdit;

    hEdit = GetDlgItem( hwnd, IDC_EDIT3 );
    SetWindowText( hEdit, "" );

    hEdit = GetDlgItem( hwnd, IDC_EDIT4 );
    SetWindowText( hEdit, "1" );

    hEdit = GetDlgItem( hwnd, IDC_EDIT5 );
    SetWindowText( hEdit, "0" );

    return 0;
}

int ModifyRecordColumn( int iCol, HWND hEditNewValue, HWND hEditTagSeq, HWND hEditLongOffset )
{
    JET_SETINFO jSetInfo;
    char* pData = NULL;          //initialized to avoid C4701
    unsigned long cbData, ulTemp;
    char szBuf[TEMP_BUF_SIZE + 1];

    if( GetWindowTextLength( hEditNewValue ) >= TEMP_BUF_SIZE )
    {
        OutputMessage( "Value too long" );
        return -1;
    }

    jSetInfo.cbStruct = sizeof( JET_SETINFO );
    GetWindowText( hEditLongOffset, szBuf, TEMP_BUF_SIZE );
    jSetInfo.ibLongValue = atol( szBuf );
    GetWindowText( hEditTagSeq, szBuf, TEMP_BUF_SIZE );
    jSetInfo.itagSequence = atol( szBuf );

    cbData = GetWindowText( hEditNewValue, szBuf, TEMP_BUF_SIZE );
    switch( gpjColDef[iCol].coltyp )
    {
        case JET_coltypText:
        case JET_coltypLongText:
            pData = (char*)szBuf;
            break;

        case JET_coltypLong:
            if( cbData )
            {
                ulTemp = (unsigned long)atol( szBuf );
                pData = (char*)&ulTemp;
                cbData = sizeof( unsigned long );
            }
            break;
                                                                  
        default:
        {//binary format
            unsigned long ul;

            cbData /= 2;
            for( ul=0; ul<cbData; ul++ )
            {
                sscanf( szBuf+2*ul, "%2x", &ulTemp );
                szBuf[ul] = (char)((unsigned char)ulTemp);
            }
            pData = (char*)szBuf;
        }
            break;
    }

    if( JetError( JetBeginTransaction( gjSesId ), "JetBeginTransaction" ) != JET_errSuccess 
     || JetError( JetPrepareUpdate( gjSesId, gjTblId, JET_prepReplace ), "JetPrepareUpdate" ) 
                != JET_errSuccess 
     || JetError( JetSetColumn( gjSesId, gjTblId, gpjColDef[iCol].columnid, pData, cbData, 0, &jSetInfo ), 
                "JetSetColumn" )!= JET_errSuccess 
     || JetError( JetUpdate( gjSesId, gjTblId, NULL, 0, &ulTemp ), "JetUpdate" ) != JET_errSuccess 
     || JetError( JetCommitTransaction( gjSesId, 0 ), "JetCommitTransaction" ) != JET_errSuccess )
        JetError( JetRollback( gjSesId, 0 ), "JetRollback" );
    else
        PrintCurrentRecord();   //Cursor remains on current record

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\dsldap\dsldap.h ===
// Function Prototypes for ldap calls for NTDS changes

ULONG NTDS_ldap_add_sW( LDAP *ld, PWCHAR dn, LDAPModW *attrs[] );
ULONG NTDS_ldap_add_sA( LDAP *ld, PCHAR dn, LDAPModA *attrs[] ); 


ULONG NTDS_ldap_modify_sW( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
ULONG NTDS_ldap_modify_sA( LDAP *ld, PCHAR dn, LDAPModA *mods[] );

ULONG NTDS_ldap_delete_sW( LDAP *ld, PWCHAR dn );
ULONG NTDS_ldap_delete_sA( LDAP *ld, PCHAR dn );

ULONG NTDS_ldap_modrdn2_sW( 
    LDAP    *ExternalHandle,
    PWCHAR  DistinguishedName,
    PWCHAR  NewDistinguishedName,
    INT     DeleteOldRdn
    );

ULONG NTDS_ldap_modrdn2_sA( 
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
    );




#ifdef UNICODE

#define NTDS_ldap_add_s      NTDS_ldap_add_sW
#define NTDS_ldap_modify_s   NTDS_ldap_modify_sW
#define NTDS_ldap_delete_s   NTDS_ldap_delete_sW
#define NTDS_ldap_modrdn2_s  NTDS_ldap_modrdn2_sW

#else

#define NTDS_ldap_add_s      NTDS_ldap_add_sA
#define NTDS_ldap_modify_s   NTDS_ldap_modify_sA
#define NTDS_ldap_delete_s   NTDS_ldap_delete_sA
#define NTDS_ldap_modrdn2_s  NTDS_ldap_modrdn2_sA

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\inc\async.h ===
/*++

Copyright (c) 1998-2000  Microsoft Corporation

Module Name:

    async.h

Abstract:

    Asynchronous LDAP support routines

Environment:

    User mode

Revision History:

    05/15/00 -mattrim-
        Created it

--*/

#ifndef _ASYNC_H_
#define _ASYNC_H_

#ifdef __cplusplus
extern "C" {
#endif

extern LDAP_TIMEVAL * g_pLdapTimeout;
extern LDAP_TIMEVAL   g_LdapTimeout;


ULONG LDAPAPI LdapResult(
    LDAP *ld, 
    ULONG msgnum,
    LDAPMessage **ppres
    );

#ifdef __cplusplus
}
#endif

#endif // _ASYNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\dsldap\dsldap.c ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    dsldap.c

ABSTRACT:

     Functions for dsldap.lib

DETAILS:

     Contains NTDS-specific functions corresponding to ldap_add_s,
     ldap_modify_s, ldap_delete_s, and ldap_modrdn2_s. The parameters
     are excatly same as the corresponding ldap calls. These functions
     are called by ldifde on NTDS-specific changetypes (ntdsSchemaAdd,
     ntdsSchemaModify, ntdsSchemaDelete, and ntdsSchemaModRdn) in an
     ldif file.

     The functions are similar to normal ldap calls, except that certain
     error codes are ignored in specific cases and success is returned
     instead to the calling function
  

CREATED:

    05/27/98    Arobinda Gupta (arobindg)

REVISION HISTORY:

--*/


//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

//
// LDAP Includes
//
#include <winldap.h>

#include "dsldap.h"
#include "async.h"

ULONG 
NTDS_ldap_add_sW(
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *attrs[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_addW(ld, dn, attrs);

    Ldap_err = LdapResult(ld, msgnum, NULL);


    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry


    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;

}


ULONG 
NTDS_ldap_modify_sW( 
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *mods[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_modifyW( ld, dn, mods );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_modrdn2_sW(
    LDAP    *ExternalHandle,
    PWCHAR  DistinguishedName,
    PWCHAR  NewDistinguishedName,
    INT     DeleteOldRdn
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;
    
    // make the normal ldap call

    msgnum = ldap_modrdn2W (
                      ExternalHandle,
                      DistinguishedName,
                      NewDistinguishedName,
                      DeleteOldRdn
               );

    Ldap_err = LdapResult(ExternalHandle, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_delete_sW(
    LDAP *ld, 
    PWCHAR dn 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_deleteW( ld, dn );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


// Implement the ascii versions

ULONG 
NTDS_ldap_add_sA(
    LDAP *ld, 
    PCHAR dn, 
    LDAPModA *attrs[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call
    
    msgnum = ldap_addA( ld, dn, attrs );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry


    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    } 

    return Ldap_err;
}


ULONG 
NTDS_ldap_modify_sA( 
    LDAP *ld, 
    PCHAR dn, 
    LDAPModA *mods[] 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_modifyA( ld, dn, mods );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ATTRIBUTE_OR_VALUE_EXISTS:
        case LDAP_NO_SUCH_ATTRIBUTE:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}


ULONG 
NTDS_ldap_delete_sA( 
    LDAP *ld, 
    PCHAR dn 
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;

    // make the normal ldap call

    msgnum = ldap_deleteA( ld, dn );

    Ldap_err = LdapResult(ld, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}

ULONG 
NTDS_ldap_modrdn2_sA(
    LDAP    *ExternalHandle,
    PCHAR   DistinguishedName,
    PCHAR   NewDistinguishedName,
    INT     DeleteOldRdn
)
{
    ULONG Ldap_err = 0;
    ULONG msgnum = 0;
    
    // make the normal ldap call

    msgnum = ldap_modrdn2A ( 
                      ExternalHandle,
                      DistinguishedName,
                      NewDistinguishedName,
                      DeleteOldRdn
               );

    Ldap_err = LdapResult(ExternalHandle, msgnum, NULL);

    // For errors to ignore, reset error code to success so that
    // ldifde will go on to the next entry

    switch (Ldap_err) {
        case LDAP_SUCCESS:
             break;
        case LDAP_ALREADY_EXISTS:
        case LDAP_NO_SUCH_OBJECT:
            Ldap_err = LDAP_SUCCESS;
            break;
        default: ;
    }

    return Ldap_err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\inc\memory.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    memory.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    10/08/98 -felixw-
        Created it

--*/

#ifndef _MEMORY
#define _MEMORY

#ifdef __cplusplus
extern "C" {
#endif

#define LL_MEMORY_ERROR    0x00000100 

STDAPI_(PSTR)
MemAllocStr_E(PSTR in);
STDAPI_(PWSTR)
MemAllocStrW_E(PWSTR in);
STDAPI_(LPVOID)
MemAlloc_E(DWORD dwBytes);
STDAPI_(LPVOID)
MemRealloc_E(LPVOID IpMem, DWORD dwBytes);

DWORD
MemSize(
   LPVOID pMem
);

LPVOID
MemAlloc(
    DWORD cb
);

BOOL
MemFree(
   LPVOID pMem
);

LPVOID
MemRealloc(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

PSTR
MemAllocStr(
    PSTR pStr
);

PWSTR
MemAllocStrW(
    PWSTR pStr
);


BOOL
MemReallocStr(
   PSTR *ppStr,
   PSTR pStr
);

int UnicodeToAnsiString(PCWSTR pszUnicode,PSTR pszAnsi);
PSTR AllocateAnsiString(PCWSTR  pszUnicodeString);
PWSTR AllocateUnicodeString(PCSTR  pszAnsiString);
int AnsiToUnicodeString(PCSTR pszAnsi,PWSTR pszUnicode);

#if DBG

extern LIST_ENTRY MemList ;

extern CRITICAL_SECTION MemCritSect ;

STDAPI_(VOID) InitMem(
    VOID
    ) ;

VOID AssertMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();

#else

#define InitMem()
#define AssertMemLeaks()
#define DumpMemoryTracker()

#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\inc\debug.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Debugging support for the DirSync project. None of these
    generate any code in the retail build.

Environment:

    User mode

Revision History:

    03/18/98 -srinivac-
        Created it

--*/


#ifndef _DEBUG_H_
#define _DEBUG_H_

#ifdef __cplusplus
extern "C" {
#endif

#if DBG

//
// External functions
//

STDAPI_(PCSTR) StripDirPrefixA(PCSTR);

//
// This variable maintains the current debug level. Any calls to generate
// debug messages succeeds if the requested level is greater than or equal
// to the current level.
//

extern DWORD gdwDebugLevel;

//
// List of debug levels for gdwDebugLevel
//

#define DBG_LEVEL_VERBOSE   0x00000001
#define DBG_LEVEL_INFO      0x00000002
#define DBG_LEVEL_WARNING   0x00000003
#define DBG_LEVEL_ERROR     0x00000004


//
// Internal macros. Don't call these directly
//

#define CHECK_DBG_LEVEL(level)  ((level) >= gdwDebugLevel)

#define DBGMSG(level, msg)                                              \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint("DirSync(%d): %s(%u): ",                       \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
            }                                                           \
        }


#define DBGPRINT(level, msg)                                            \
        {                                                               \
            if (CHECK_DBG_LEVEL(level))                                 \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }


//
// These are the main macros that you'll be using in your code.
// Note that you should enclose the msg in additional
// paranthesis as shown in the example below.
//
// WARNING(("Out of memory"));
// ERR(("Incorrect return value: %d", rc));
//

#define VERBOSE(msg)       DBGMSG(DBG_LEVEL_VERBOSE, msg)
#define INFO(msg)          DBGMSG(DBG_LEVEL_INFO,   msg)
#define WARNING(msg)       DBGMSG(DBG_LEVEL_WARNING, msg)
#define ERR(msg)           DBGMSG(DBG_LEVEL_ERROR,   msg)
#define ERR_RIP(msg)       DBGMSG(DBG_LEVEL_ERROR,   msg);RIP()
#define RIP()              DebugBreak()
#define DEBUGOUT(msg)      DbgPrint msg


//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//
// ASSERT(x > 0);
// ASSERTMSG(x > 0, ("x less than 0: x=%d", x));
//

#ifdef ASSERT
#undef ASSERT
#undef ASSERTMSG
#endif

#define ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                DbgPrint("DirSync(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DbgPrint msg;                                           \
                DbgPrint("\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

#else // !DBG

#define DBGMSG(level, msg)
#define VERBOSE(msg)
#define INFO(msg)
#define WARNING(msg)
#define ERR(msg)
#define ERR_RIP(msg)
#define RIP()
#define DEBUGOUT(msg)

#ifndef ASSERT
#define ASSERT(expr)
#endif

#ifndef ASSERTMSG
#define ASSERTMSG(expr, msg)
#endif

#endif

//
// The following macros let you enable debugging on a per feature basis.
// To use these macros, here is what you should do:
//
// At the beginning of the file (after header includes):
//
//  1. Define a bit constant for each capability you want to debug
//  2. For each feature, add the following line
//       DEFINE_FEATURE_FLAGS(featurename, flags);
//     where flags is a bit-wise OR of the capabilities you want to debug for
//     that feature
//  3. In your code add the following line wherever you want debug messages
//       FEATURE_DEBUG(featurename, flag, (msg));
//
//  E.g. let us say I am implementing a memory manager, and I would like to
//       trace memory allocations and frees. Here is what I would do
//
//       #define FLAG_ALLOCATE   1
//       #define FLAG_FREE       2
//
//       DEFINE_FEATURE_FLAGS(MemMgr, FLAG_ALLOCATE);
//
//       void *MemAlloc(DWORD dwSize)
//       {
//           FEATURE_DEBUG(MemMgr, FLAG_ALLOCATE, ("Memory of size %d allocated", dwSize));
//           ...
//       }
//
//       void MemFree(void *pvMem)
//       {
//           FEATURE_DEBUG(MemMgr, FKAG_FREE, ("Memory freed"));
//           ...
//       }
//
//  Note that I have set this up to send only alloc messages to the debugger,
//  but I can break into the debugger and modify dwMemMgrDbgFlags to
//  send free messages as well.
//
//  Once component testing of a feature is completed, flags parameter in
//  DEFINE_FEATURE_FLAGS should be changed to 0, so by default this feature
//  does not send debug messages to the debugger.
//

#if DBG

//
// Global debug flag that can used to set values to all other flags
//

extern DWORD gdwGlobalDbgFlags;

#define DEFINE_FEATURE_FLAGS(feature, flags)                            \
            DWORD gdw##feature##DbgFlags = (flags)

#define EXTERN_FEATURE_FLAGS(feature)                                   \
            extern DWORD gdw##feature##DbgFlags

#define FEATURE_DEBUG(feature, flag, msg)                               \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                DbgPrint msg;                                           \
            }                                                           \
        }

#define FEATURE_DEBUG_FN(feature, flag, func)                           \
        {                                                               \
            if (gdw##feature##DbgFlags & (flag) ||                      \
                gdwGlobalDbgFlags & (flag))                             \
            {                                                           \
                func;                                                   \
            }                                                           \
        }

#define FLAG_INFO               0x01
#define FLAG_VERBOSE            0x02
#define FLAG_FNTRACE            0x04
#define FLAG_FULLTRACE          0xFFFF

#else // !DBG

#define DEFINE_FEATURE_FLAGS(feature, flags)
#define EXTERN_FEATURE_FLAGS(feature)
#define FEATURE_DEBUG(feature, flag, msg)
#define FEATURE_DEBUG_FN(feature, flag, func)

#endif // !DBG

//
// Macros for error handling
//

#define BAIL_ON_FAILURE(hr)                             \
            if (FAILED(hr))                             \
            {                                           \
                goto error;                             \
            }

#define BAIL_ON_FAILURE_WITH_MSG(err, msg)              \
            if (FAILED(hr))                             \
            {                                           \
                ERR(msg);                               \
                goto error;                             \
            }

#define BAIL_ON_NULL(ptr)                               \
            if ((ptr) == NULL)                          \
            {                                           \
                ERR(("Error allocating memory\n"));     \
                hr = E_OUTOFMEMORY;                     \
                goto error;                             \
            }

#define BAIL()  goto error


#ifdef __cplusplus
}
#endif

#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifde\import.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    import.cxx

Abstract:
    
    Import operations of LDIF

Author:

    Felix Wong [FelixW]    22-Jul-1997
    
++*/

#include "ldifde.hxx"

//
// Multithreaded support structures
//

// the records that will be stored on the queues
#define QUEUE_ENTRIES 256
LdifRecordQueue g_LdifEntries[QUEUE_ENTRIES];

// FreeQueue
//   empty records, available for use
//   (only one thread ever accesses this list, so not
//    crit-sect protected)
LIST_ENTRY g_LFreeEntry;

// ParsedQueue
//   parsed records, waiting to send to server
LIST_ENTRY g_LParseList;
CRITICAL_SECTION g_csParseList;

// SentQueue
//   sent records, awaiting recycling to the FreeQueue
LIST_ENTRY g_LSentList; 
CRITICAL_SECTION g_csSentList;

// if the queue critical sections have been initialized
BOOL g_fCritSectInitialized = FALSE;

DWORD g_EofReached = 0; // has the parser reached the end of the LDIF file?
DWORD g_SentAllFileItems = 0;  // have all entries been sent?
LONG  g_cAdded = 0;     // count of the number of entries successfully added



void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc_E((dwLen + 1) * sizeof(WCHAR));

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *ppszUnicode = pszUnicode;
    *pdwLen = (nReturn + 1);//* sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
// Function:    DSImport
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     DWORD
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD DSImport(LDAP **pLdap, ds_arg *pArg)
{
    DWORD hr = ERROR_SUCCESS;
    DWORD hrWorker = ERROR_SUCCESS;     // overall worker thread exit code
    DWORD dwThreadCode = ERROR_SUCCESS; // worker thread exit code
    LDIF_Error    ll_err;
    LDIF_Record   *recReturned;
    BOOL        bEndOfFile = FALSE;
    DWORD       cLine = 0;
    DWORD       cLineReturn = 0;

    BOOL fLazyCommitAvail = TRUE;
    LdifRecordQueue *pRecEnt=NULL;
    BOOL fInitializedQueues = FALSE;
    BOOL fStartedThreads = FALSE;
    BOOL fErrorDuringParse = FALSE;
    
    tParameter LDIFParameter[MAX_LDAP_CONCURRENT];
    HANDLE LDAPSendThreadHandle[MAX_LDAP_CONCURRENT];
    DWORD ThreadId;
    DWORD dwNumThreads = 0;

    
    SelectivePrintW(PRT_STD|PRT_LOG,
                    MSG_LDIFDE_IMPORTDIR,
                    pArg->szFilename);
    ll_err = LDIF_InitializeImport(pLdap[0],
                                   pArg->szFilename,
                                   pArg->szFromDN,
                                   pArg->szToDN,
                                   &fLazyCommitAvail);
                                   
    if (ll_err.error_code!=LL_SUCCESS) {
        SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_ERR_INIT);
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If we asked for lazy commit and it is not available, output error message and
    // turn off lazy commit, but still go on
    // 
    if (pArg->fLazyCommit && (fLazyCommitAvail == FALSE)) {
        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_LAZYCOMMIT_NOTAVAIL); 
        pArg->fLazyCommit = FALSE;
    }

    //
    // init the MT part
    //
    InitLDIFDEMT();
    fInitializedQueues = TRUE;

    //
    // Call LDAP Send Threads
    //
    dwNumThreads = pArg->dwLDAPConcurrent;

    for (int i = 0; i < (int)pArg->dwLDAPConcurrent; i++) {
        LDIFParameter[i].pLdap=pLdap[i];
        LDIFParameter[i].pArg=pArg;
        LDIFParameter[i].dwThreadNum = i;

        LDAPSendThreadHandle[i] =
            CreateThread(
                NULL,       // default security
                0,          // default stack size
                (LPTHREAD_START_ROUTINE)LDIF_LoadRecordThread,
                (LPVOID)&LDIFParameter[i],          // parameter
                0,          // creation flag, no suspend
                &ThreadId );

        if( LDAPSendThreadHandle[i]  == NULL ) {
            hr = GetLastError();
            // print message on fail threadstart
            if (i==0) {
                //
                // Couldn't start any threads, give up
                //
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                 MSG_LDIFDE_THREADFAIL);            
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                //
                // failed to start this thread 
                // continue with whatever threads we
                // have so far
                //
                SelectivePrintW( PRT_STD|PRT_LOG,
                                 MSG_LDIFDE_THREADFAIL_SOME,
                                 i);            
                dwNumThreads = i;
                hr = ERROR_SUCCESS;
                break;	    
            }
        } 
    }

    fStartedThreads = TRUE;

    SelectivePrintW( PRT_STD|PRT_LOG,
                    MSG_LDIFDE_LOADING);
    SelectivePrint2W( PRT_STD_VERBOSEONLY|PRT_LOG,
                    L"\n");    
    TrackStatus();
    //
    // Parsing
    //
    while(!bEndOfFile && !g_SentAllFileItems) {
        
        if (!FreeQueueGetEntry(&pRecEnt)){
            // could not get the entry
            // Lets free some from the process list
            SentQueueFreeAllEntries();

            // now get another one
            if (!FreeQueueGetEntry(&pRecEnt)){
                //if none can be freed wait and try again later
                Sleep(1);
                continue;	      
            }
        }

        recReturned = &pRecEnt->i_record;

        memset(recReturned, 0, sizeof(LDIF_Record));

        ll_err = LDIF_Parse(recReturned);
        
        if((ll_err.error_code!=LL_SUCCESS)&&(ll_err.error_code!=LL_EOF)) {
            //
            // We'll narrow down the error and display the appropriate
            // message in the cleanup code.
            //
            fErrorDuringParse = TRUE;

            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        cLineReturn = ll_err.line_begin;
        cLine++;
        	
        pRecEnt->dwLineNumber = cLineReturn;
        pRecEnt->dwRecordIndex = cLine;

        //
        // Important: Adding the entry must be done BEFORE setting the
        // EOF flag.  In the worker thread, we'll test them in the reverse
        // order, thereby guaranteeing that if we read the EOF flag as true,
        // the parse thread will have completed adding any entries to the
        // parse queue.  Otherwise, we may read the flag as true when not
        // all entries have yet been added to the parsed queue, see that the
        // queue is empty, and terminate prematurely.
        //
        ParsedQueueAddEntry(pRecEnt);

        //
        // Checking EOF
        //
        if (ll_err.error_code==LL_EOF) {
            bEndOfFile = TRUE;
            InterlockedExchange((LONG*)&g_EofReached, 1);
        }

    }
    // end of parsing
    
error:

    if (fStartedThreads) {
    
        //
        // wait for sending threads to finish
        //
        InterlockedExchange((LONG*)&g_EofReached, 1);  // signal we're done, if we haven't already

        //if (fErrorDuringParse) {
        //    // error occurred in parser thread -> force immediate shutdown
        //    // of worker threads (don't wait for them to empty their queues)
        //    InterlockedIncrement((long *)&g_SentAllFileItems);
        //}
        
        WaitForMultipleObjects(dwNumThreads,
                               LDAPSendThreadHandle, 
                               TRUE,    // wait for all to terminate
                               INFINITE);
        for (i = 0; i < (int)dwNumThreads; i++) {

            //
            // Need to find out if the thread exited with an error
            // and, if so, preserve that error code so we can return it
            //
            if (GetExitCodeThread(LDAPSendThreadHandle[i], &dwThreadCode)) {
                if (dwThreadCode != ERROR_SUCCESS) {
                    hrWorker = dwThreadCode;
                }
            }
        
    	    CloseHandle(LDAPSendThreadHandle[i]);
        }
    }

    //
    // Now we cleanup and display any errors.
    // First, we display the results of the worker threads
    //  (this is done inside SentQueueFreeAllEntries)
    // Second, we display the parse error, if any.
    // Finally, we display the overall count of entries
    // modified successfull.
    //
    if (fInitializedQueues) {
        ParsedQueueFreeAllEntries();
        SentQueueFreeAllEntries();
    }

    if (fErrorDuringParse) {
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        if (ll_err.szTokenLast) {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                             MSG_LDIFDE_FAILLINETOKEN,
                             ll_err.szTokenLast, 
                             ll_err.line_number); 
        }
        else {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_FAILLINE,
                            ll_err.token_start, 
                            ll_err.line_number); 
        }
#if DBG
        if (ll_err.error_code == LL_SYNTAX) {
            ClarifyErr(&ll_err);
        }
#endif
    }

    if (g_cAdded == 1) {
        SelectivePrintW( PRT_STD|PRT_LOG,
                        MSG_LDIFDE_MODENTRYSUC_1);
    }
    else {
        SelectivePrintW( PRT_STD|PRT_LOG,
                        MSG_LDIFDE_MODENTRYSUC,
                        g_cAdded);
    }
    
    LDIF_CleanUp();
    CleanupLDIFDEMT();
    
    if (ll_err.szTokenLast) {
        MemFree(ll_err.szTokenLast);
    }

    //
    // We want to return the parse error if there was one, otherwise,
    // the worker thread error code (which will still be ERROR_SUCCESS
    // if no worker thread experienced an error)
    //
    return ( (hr != ERROR_SUCCESS) ? hr : hrWorker);
}


//+---------------------------------------------------------------------------
// Function:   PrintRecord 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintRecord(LDIF_Record *IpLLrec, DWORD dwType) {
    struct change_list  *c_current;
    
    if (IpLLrec->fIsChangeRecord==FALSE) {    
        SelectivePrint2W(dwType,L"\ndn: %s\n",IpLLrec->dn);
        PrintMod(IpLLrec->content, dwType);
    } else if (IpLLrec->fIsChangeRecord==TRUE) {
        SelectivePrint2W(dwType,L"Entry DN: %s\n", IpLLrec->dn);
        c_current=IpLLrec->changes;
        while(c_current!=NULL) {
            switch(c_current->operation) {
                case CHANGE_ADD:  
                    SelectivePrint2W(dwType,L"changetype: add\n");
                    PrintMod(c_current->mods_mem, dwType);
                    break;
                
                case CHANGE_DEL:
                    SelectivePrint2W(dwType,L"changetype: delete\n");
                    break;
                
                case CHANGE_DN:
                    SelectivePrint2W(dwType,L"changetype: dn\n");
                    SelectivePrint2W(dwType,L"Renaming to %s with deleteold of %d\n",
                                    c_current->dn_mem,
                                    c_current->deleteold);
                    break;
                case CHANGE_MOD:
                    SelectivePrint2W(dwType,L"changetype: modify\n");
                    PrintMod(c_current->mods_mem, dwType); 
                    break;
            } 
            c_current=c_current->next;
        } 
    } 
}


//+---------------------------------------------------------------------------
// Function:    PrintMod
//
// Synopsis:    Print out the values in the LDAP MOD structure
//
// Arguments:   LDAPMod **pMod
//
// Returns:     DWORD
//
// Modifies:      -
//
// History:    22-7-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD
PrintMod(LDAPModW **ppMod, DWORD dwType)
{
    DWORD        cAttribute = 0;
    PWSTR        *string_array;
    struct       berval **ber_array;
   
    if (!ppMod) {
        return ERROR_INVALID_PARAMETER;
    }
    
    while(*ppMod) {
        PLDAPModW_Ext pModExt = (PLDAPModW_Ext )(*ppMod);
        if (!pModExt->fString) {
            
            //
            // BVALUE
            //
            SelectivePrint2W(dwType,
                             L"Attribute %d) %s:",
                             cAttribute,
                             (*ppMod)->mod_type); 
            
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    SelectivePrint2W(dwType,
                                    L" UNPRINTABLE BINARY(%d)",
                                    (*ber_array)->bv_len);
                    ber_array++;
                }
            }
            SelectivePrint2W(dwType,
                            L"\n");
        } else {
            
            //
            // STRING
            //
            SelectivePrint2W(dwType,
                             L"Attribute %d) %s:",
                             cAttribute,
                             (*ppMod)->mod_type); 
            
            //
            // string is always UTF-8 --- we always read it in as Unicode, then
            // in GenereateModFromAttr we convert it to UTF-8, so by this time
            // it's UTF-8 no matter whether the source file was Unicode or not
            //
            ber_array=(*ppMod)->mod_bvalues;
            if (ber_array) {
                while (*ber_array) {
                    PSTR szString;
                    PWSTR pszUnicode;
                    DWORD dwLen;

                    ConvertUTF8ToUnicode(
                        (unsigned char*)(*ber_array)->bv_val,
                        (*ber_array)->bv_len,
                        &pszUnicode,
                        &dwLen
                        );

                    /*
                    szString = (PSTR)MemAlloc_E(((*ber_array)->bv_len)+1);
                    memcpy(szString,(*ber_array)->bv_val,(*ber_array)->bv_len);
                    szString[(*ber_array)->bv_len] = NULL;
                    */
                    SelectivePrint2W(dwType,
                                    L"%s",
                                    pszUnicode);
                    ber_array++;
                    //MemFree(szString);
                    MemFree(pszUnicode);
                }
            }
            
            SelectivePrint2W(dwType,
                           L"\n");
        }   
        
        ppMod++;
        cAttribute++;
    }
    SelectivePrint2W(dwType,
                   L"\n");
    return ERROR_SUCCESS;
}


//+---------------------------------------------------------------------------
// Function:   ClarifyErr 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void ClarifyErr(
    LDIF_Error* err
    ) 
{

    int RuleLastBig  = err->RuleLastBig;
    int lastsmall    = err->RuleLast;
    int RuleExpect   = err->RuleExpect;
    int expecttoken  =err->TokenExpect;
    
    //If there is an error in a wrapped line, it will be reported as the last 
    //line of the wrapped value in the original file. Please note that the token 
    //start indicates the point AT which or AFTER which the error occurred. The 
    //info below indicates the LAST correct rule and what was expected thereafter. 
    //Sometimes one of these pieces of info may be slightly grammatically ahead
    //of the other. However, a good knoweldge of the LDIF grammar, and these
    //two pieces of info should be more than enough to indicate the error. The 
    //error will be AT or AFTER the further one. It will also be AT OR BEFORE 
    //the indicated linenumber.
    
    wprintf(L"Last major rule: ");
    switch(RuleLastBig) {
        case R_VERSION:   wprintf(L"version-spec\n");
                          break;
        case R_REC:       wprintf(L"ldif-attrval-record\n");
                          break;
        case R_CHANGE:    wprintf(L"ldif-change-record\n");  
                          break;           
        case R_DN:        wprintf(L"dn-spec\n");
                          break;
        case R_AVS:       wprintf(L"attrval-spec.\n");
                          break;
        case R_C_ADD:     wprintf(L"change-add\n");
                          break;
        case R_C_DEL:     wprintf(L"change-delete\n");
                          break;
        case R_C_DN:      wprintf(L"change-moddn\n");
                          break;
        case R_C_NEWSUP:  wprintf(L"change-moddn + newsuperior\n");
                          break;
        case R_C_MOD:     wprintf(L"change-modify\n");
                          break;
        case R_C_MODSPEC: wprintf(L"mod-spec\n");
                          break;
        
    }

    wprintf(L"Last minor rule: ");
    switch(lastsmall) {
        case RS_VERNUM:     wprintf(L"version-number\n");
                            break;
        case RS_ATTRNAME:   wprintf(L"attrname:\n");
                            break;
        case RS_ATTRNAMENC: wprintf(L"attrname\n");
                            break;
        case RS_DND:        wprintf(L"dn::\n");
                            break;
        case RS_DN:         wprintf(L"dn:\n");
                            break;
        case RS_DIGITS:     wprintf(L"DIGITs\n");
                            break;
        case RS_VERSION:    wprintf(L"version:\n");
                            break;
        case RS_BASE64:     wprintf(L"base64 value\n");
                            break;
        case RS_SAFE:       wprintf(L"safe value\n");
                            break;
        case RS_DC:         wprintf(L"::\n"); 
                            break;
        case RS_URLC:       wprintf(L":<\n");
                            break;
        case RS_C:          wprintf(L":\n");
                            break;
        case RS_MDN:        wprintf(L"moddn | modrdn\n");
                            break;
        case RS_NRDNC:      wprintf(L"newrdn:\n");
                            break;
        case RS_NRDNDC:     wprintf(L"newrdn::\n"); 
                            break;
        case RS_DORDN:      wprintf(L"deleteoldrdn:\n");
                            break;
        case RS_NEWSUP:     wprintf(L"newsuperior:\n");
                            break;
        case RS_NEWSUPD:    wprintf(L"newsuperior::\n");
                            break;
        case RS_DELETEC:    wprintf(L"delete:\n");
                            break;
        case RS_ADDC:       wprintf(L"add:\n");
                            break;
        case RS_REPLACEC:   wprintf(L"replace:\n");
                            break;
        case RS_CHANGET:    wprintf(L"changetype:\n");
                            break;
        case RS_C_ADD:      wprintf(L"add\n");
                            break;
        case RS_C_DELETE:   wprintf(L"delete\n");
                            break;
        case RS_MINUS:      wprintf(L"-\n");
                            break;
        case RS_C_MODIFY:   wprintf(L"modify\n");
                            break;
    }

    wprintf(L"Expecting rule: ");
    switch(RuleExpect) {
        case RE_REC_OR_CHANGE:  wprintf(L"ldif-attrval-record | ldif-change-record\n");
                                break;
        case RE_REC:            wprintf(L"ldif-attrval-record\n");
                                break;
        case RE_CHANGE:         wprintf(L"ldif-change-record\n");
                                break;
        case RE_ENTRY:          wprintf(L"attrval-spec | changerecord\n");
                                break;
        case RE_AVS_OR_END:     wprintf(L"attrval-spec | end of list.\n");
                                break;
        case RE_CH_OR_NEXT:     wprintf(L"changetype: * | end of entry\n");
                                break;
        case RE_MODSPEC_END:    wprintf(L"mod-spec | end of entry\n");
                                break;
    }   

    wprintf(L"Expecting token: ");
    switch(expecttoken) {
        case RT_DN:              wprintf(L"dn: | dn::\n");
                                 break;
        case RT_ATTR_OR_CHANGE:  wprintf(L"attrname | changetype:\n");
                                 break;
        case RT_ATTR_MIN_SEP:    wprintf(L"attrname (:|::|:<) | '2+ separators'\n");
                                 break;
        case RT_CH_OR_SEP:       wprintf(L"changetype | separator\n");
                                 break;
        case RT_MODBEG_SEP:      wprintf(L"add: | delete: | replace: | separator\n");
                                 break;   
        case RT_C_VALUE:         wprintf(L": value | :: value\n");
                                 break;
        case RT_ATTRNAME:        wprintf(L"attrname:\n");
                                 break;
        case RT_VALUE:           wprintf(L"safe value\n");
                                 break;
        case RT_MANY:            wprintf(L"undetermined\n");
                                 break;
        case RT_DIGITS:          wprintf(L"DIGIT\n");
                                 break;
        case RT_BASE64:          wprintf(L"BASE64 Vvalue\n");
                                 break;
        case RT_URL:             wprintf(L"URL\n");
                                 break;
        case RT_NDN:             wprintf(L"newrdn: | newrdn::\n");
                                 break;
        case RT_ATTRNAMENC:      wprintf(L"attrname\n");
                                 break;
        case RT_ADM:             wprintf(L"add | delete | modify\n");
                                 break;
        case RT_ACDCRC:          wprintf(L"add: | delete: | replace:\n");
                                 break;
    }
}

/*
*   Threads to load records thread  
*/
DWORD LDIF_LoadRecordThread (LPVOID Parameter){

    tParameter *t = (tParameter *) Parameter;
    LDIF_Record   *recReturned;
    LDAP *pLdap = t->pLdap;
    ds_arg *pArg = t->pArg;
    LDIF_Error    ll_err;
    LdifRecordQueue *pRecord=NULL;
    DWORD hr = ERROR_SUCCESS;
    DWORD cLineReturn, cLine;

    BOOL fGotRecord = FALSE;
    BOOL fEOF = FALSE;

    while(!g_SentAllFileItems){

        // Get Element from queue
        // Important: Reading the entry must be done AFTER reading the
        // EOF flag.  In the parser thread, we set them in the reverse
        // order, thereby guaranteeing that if we read the EOF flag as true,
        // the parse thread will have completed adding any entries to the
        // parse queue.  Otherwise, we may read the flag as true when not
        // all entries have yet been added to the parsed queue, see that the
        // queue is empty, and terminate prematurely.

        fEOF = g_EofReached;
        fGotRecord = ParsedQueueGetEntry(&pRecord);

        if (!fGotRecord) {
            // this happens once at startup
            if(fEOF) {
                //
                // no more entries in parsed queue and we reached
                // EOF --> nothing more to do, all entries have been
                // sent
                //
                InterlockedIncrement((long *)&g_SentAllFileItems);
                return (hr);
            }
            else {
                //
                // Can happen if we ever run out of entries in the queue
                // while there are more to go in the file.  The parser thread
                // will notice this and start stuffing more entries into
                // the queue, eventually.
                //
                Sleep(1);

                //try again
                continue; 
            }
        }

    	recReturned = &pRecord->i_record;
        cLineReturn = pRecord->dwLineNumber;
        cLine = pRecord->dwRecordIndex;

        //
        // Loading
        //
        ll_err = LDIF_LoadRecord(pLdap, 
                                 recReturned, 
                                 pArg->fActive,
                                 pArg->fLazyCommit,
                                 FALSE);

        //
        // Fill in the results of the import
        //
        pRecord->dwError = ll_err.error_code;
        pRecord->dwLdapError = ll_err.ldap_err;
        pRecord->dwLdapExtError = ERROR_SUCCESS;
        pRecord->fSkipExist = pArg->fSkipExist;

        //
        // Determine whether an error occurred and if we
        // need to abort (actual logging/reporting of the
        // error will be handled separately, once the record
        // is on the sent queue).
        //
        if((ll_err.error_code!=LL_SUCCESS)) {
                        
            if (ll_err.error_code == LL_LDAP) {
                if (pArg->fSkipExist && ll_err.ldap_err == LDAP_OTHER) {
                    DWORD dwWinError = ERROR_SUCCESS;
                    BOOL fError = GetLdapExtendedError(pLdap, &dwWinError);
                                                      
                    pRecord->dwLdapExtError = dwWinError;
                    
                    if ((fError) || (dwWinError != ERROR_MEMBER_IN_ALIAS)) {

                        //
                        // Unignorable errors -> program termination
                        //

                        hr = LdapToWinError(ll_err.ldap_err);
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                } 
                //
                // If skip is on, and if we get objectclass violation, it means
                // the objectclass does not exist. We then check the item 
                // actually has no attributes, we'll ignore that if it's the 
                // case
                //
                else if (pArg->fSkipExist && 
                         (ll_err.ldap_err == LDAP_OBJECT_CLASS_VIOLATION) &&
                         recReturned->fIsChangeRecord && 
                         (recReturned->changes->mods_mem && (*(recReturned->changes->mods_mem) == NULL))) {
                    //
                    // Error that can be ignored
                    //
                }
                else if (pArg->fSkipExist && 
                        (ll_err.ldap_err == LDAP_ALREADY_EXISTS || 
                         ll_err.ldap_err == LDAP_CONSTRAINT_VIOLATION ||
                         ll_err.ldap_err == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                         ll_err.ldap_err == LDAP_NO_SUCH_OBJECT)) {
                    //
                    // Error that can be ignored
                    //
                }
                else {
                    //
                    // Unignorable errors -> program termination
                    //
                    hr = LdapToWinError(ll_err.ldap_err);
                    GetLdapExtendedError(pLdap, &(pRecord->dwLdapExtError));
                    DIREXG_BAIL_ON_FAILURE(hr);
                }                
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                hr = ll_err.error_code;
                DIREXG_BAIL_ON_FAILURE(hr);
            }

        }
        else {
            //
            // SUCCESS
            //
            InterlockedIncrement(&g_cAdded);
        }
        
        //
        //load proccesed record into Sent Queue
        //
        SentQueueAddEntry(pRecord);
        pRecord = NULL;

        TrackStatus();

    }
    
error: 

    //
    // If record has not been added to the sent queue yet,
    // do so now.  This way, the logging code will be
    // able to pull the record from the sent queue and
    // log the error that occurred.
    //
    if (pRecord != NULL) {
        SentQueueAddEntry(pRecord);
        pRecord = NULL;
    }

    //
    // if we hit an error, we set this flag which will
    // make it look like we completed loading all entries
    // and terminate the process
    //
    InterlockedIncrement((long *)&g_SentAllFileItems);

    return (hr);
}


//
// Compute a spin count to be used for the queue critical sections
//
DWORD
ComputeCritSectSpinCount(LPSYSTEM_INFO psysInfo, DWORD dwSpin)
{
    if(psysInfo->dwNumberOfProcessors > 1)
    {
        return(dwSpin +
               (((psysInfo->dwNumberOfProcessors - 2) * dwSpin) / 10));
    }
    return(0);
}


//
// Cleanup structures used for multi-threaded operation
//
void
CleanupLDIFDEMT()
{
    if (g_fCritSectInitialized) {
        DeleteCriticalSection(&g_csSentList);
        DeleteCriticalSection(&g_csParseList);
    }
}


//
// Initialize structures for multi-threaded operation
//
DWORD 
InitLDIFDEMT()
{

    int i;
    SYSTEM_INFO psysInfo;
    DWORD dwSpinCount;

    //
    // Initialize the critical sections that protect the queues
    //
    GetSystemInfo(&psysInfo);

    dwSpinCount = ComputeCritSectSpinCount(&psysInfo, (DWORD)500);

    if(dwSpinCount)
    {
        InitializeCriticalSectionAndSpinCount( &g_csSentList, dwSpinCount );

        InitializeCriticalSectionAndSpinCount( &g_csParseList, dwSpinCount );
    }
    else
    {
        InitializeCriticalSection(&g_csSentList);

        InitializeCriticalSection(&g_csParseList);
    }

    g_fCritSectInitialized = TRUE;

    //
    // Initialize the queue records
    //
    memset (g_LdifEntries,0,sizeof(LdifRecordQueue) * QUEUE_ENTRIES);

    //
    // Initialize the queues themselves
    //
    InitializeListHead(&g_LFreeEntry);
    InitializeListHead(&g_LParseList);
    InitializeListHead(&g_LSentList);


    //
    // Load the FreeQueue with the queue records
    //
    for ( i = 0; i< (int)(QUEUE_ENTRIES) ; i++) {
        InitializeListHead(&g_LdifEntries[i].pqueue);
        InsertTailList( &g_LFreeEntry, &g_LdifEntries[i].pqueue );
    }

    // Global Status Vars

    g_EofReached = 0 ;
    g_SentAllFileItems =0;


    return 0;
}


//+---------------------------------------------------------------------------
// Function:   FreeQueueGetEntry 
//
// Synopsis:   Retrieves an empty record from the FreeQueue, if
//             one is available   
//
// Arguments:  pEnt - on return, set to ptr to retrieved record
//
// Returns:    TRUE if it retrieved a empty record, FALSE otherwise 
//
// Modifies:   g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL 
FreeQueueGetEntry(PLdifRecordQueue *pEnt)
{
    int i;

    //
    // try 3 times
    //
    for ( i = 0; i<3; i++) {

        if( !IsListEmpty( &g_LFreeEntry ) ) {
            //
            // Take element from free list
            //
            *pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LFreeEntry );
          
            return TRUE;
          
        }
        else {
            //
            // wait
            //
            
            //
            // get one from the proccesed list
            //
            if(!SentQueueFreeAllEntries()){  
                   Sleep(4-i);
            }
        }
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
// Function:   FreeQueueFreeEntry 
//
// Synopsis:   returns an empty record to the FreeQueue
//
// Arguments:  pEnt - the record to return to the FreeQueue
//
// Returns:    - 
//
// Modifies:   g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
VOID
FreeQueueFreeEntry(LdifRecordQueue *pEnt)
{
    //
    //free and insert processed entrie 
    //
    InsertTailList( &g_LFreeEntry, &pEnt->pqueue );
}


//+---------------------------------------------------------------------------
// Function:   SentQueueAddEntry 
//
// Synopsis:   adds a record to the SentQueue
//
// Arguments:  pEnt - the record to add to the SentQueue
//
// Returns:    - 
//
// Modifies:   g_LSentList (the SentQueue)
//
//----------------------------------------------------------------------------
VOID 
SentQueueAddEntry(LdifRecordQueue *pEnt)
{
    EnterCriticalSection(&g_csSentList);

    InsertTailList( &g_LSentList, &pEnt->pqueue );

    LeaveCriticalSection(&g_csSentList);
}


//+---------------------------------------------------------------------------
// Function:   SentQueueFreeAllEntries 
//
// Synopsis:   clears all records on the SentQueue and returns
//             them to the FreeQueue
//
// Arguments:  -
//
// Returns:    TRUE if it freed one or more records, FALSE otherwise
//
// Modifies:   g_LSentList (the SentQueue), g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL
SentQueueFreeAllEntries (void)
{

    LdifRecordQueue *pEnt;
    BOOL ListEmpty = FALSE;
    BOOL FreedSome = FALSE;

    EnterCriticalSection(&g_csSentList);  
    
    while (!ListEmpty) {

        if( !IsListEmpty( &g_LSentList ) ) {
            //
            // Take element from sent List
            //
            pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LSentList );

            //
            // Log the results of this import
            //
            OutputResult(pEnt);

            //
            // now free the element and place it back on the free queue
            //
    	    LDIF_ParseFree(&pEnt->i_record);   
            FreeQueueFreeEntry(pEnt);

            FreedSome = TRUE;
        }
        else {
            ListEmpty=TRUE;
        }
    }

    LeaveCriticalSection(&g_csSentList);
    return FreedSome;
}


//+---------------------------------------------------------------------------
// Function:   ParsedQueueAddEntry 
//
// Synopsis:   adds a record to the ParsedQueue
//
// Arguments:  pEnt - the record to add to the ParsedQueue
//
// Returns:    -
//
// Modifies:   g_LParseList (the ParsedQueue)
//
//----------------------------------------------------------------------------
VOID 
ParsedQueueAddEntry(
                    LdifRecordQueue *pEnt
                    )
{

    EnterCriticalSection(&g_csParseList);

    InsertTailList( &g_LParseList, &pEnt->pqueue );

    LeaveCriticalSection(&g_csParseList);
}


//+---------------------------------------------------------------------------
// Function:   ParsedQueueGetEntry 
//
// Synopsis:   gets a record off the ParsedQueue, ready to be sent
//             to the server
//
// Arguments:  pEnt - on return, set to ptr to retrieved record
//
// Returns:    TRUE if it retrieved a record, FALSE otherwise
//
// Modifies:   g_LParseList (the ParsedQueue)
//
//----------------------------------------------------------------------------
BOOL
ParsedQueueGetEntry(
                    PLdifRecordQueue *pEnt
                    )
{

    EnterCriticalSection(&g_csParseList);
    
    if( !IsListEmpty( &g_LParseList ) ) {
        //
        // Take element from free list
        //
        *pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LParseList );

        LeaveCriticalSection(&g_csParseList);
        
        return TRUE;

    }
    else {
        //
        // wait
        //
        LeaveCriticalSection(&g_csParseList);
        
        Sleep(1);
    }
    
    return FALSE;

}



//+---------------------------------------------------------------------------
// Function:   ParsedQueueFreeAllEntries 
//
// Synopsis:   clears all records on the ParsedQueue and returns
//             them to the FreeQueue
//
// Arguments:  -
//
// Returns:    TRUE if it freed one or more records, FALSE otherwise
//
// Modifies:   g_LParseList (the ParsedQueue), g_LFreeEntry (the FreeQueue)
//
//----------------------------------------------------------------------------
BOOL
ParsedQueueFreeAllEntries (void)
{

    LdifRecordQueue *pEnt;
    BOOL ListEmpty = FALSE;
    BOOL FreedSome = FALSE;

    EnterCriticalSection(&g_csParseList);  
    
    while (!ListEmpty) {

        if( !IsListEmpty( &g_LParseList ) ) {
            //
            // Take element from sent List
            //
            pEnt = (LdifRecordQueue *) RemoveHeadList( &g_LParseList );

            // now free the element
            LDIF_ParseFree(&pEnt->i_record); 
            FreeQueueFreeEntry(pEnt);
            
            FreedSome = TRUE;
        }
        else {
            ListEmpty=TRUE;
        }
    }

    LeaveCriticalSection(&g_csParseList);
    return FreedSome;
}


//+---------------------------------------------------------------------------
// Function:   OutputResult 
//
// Synopsis:   given a queue entry filled in with the results
//             of an import operation, outputs those results to
//             log files/console
//
// Arguments:  pRecord - a queue record
//
// Returns:    -
//
// Modifies:   -
//
//----------------------------------------------------------------------------
void OutputResult (LdifRecordQueue *pRecord)
{
   
	LDIF_Record *recReturned = &pRecord->i_record;
    DWORD cLineReturn = pRecord->dwLineNumber;
    DWORD cLine = pRecord->dwRecordIndex;
    DWORD dwError = pRecord->dwError;
    DWORD dwLdapError = pRecord->dwLdapError;
    DWORD dwLdapExtError = pRecord->dwLdapExtError;
    BOOL  fSkipExist = pRecord->fSkipExist;

  
    if(dwError != LL_SUCCESS) {
        SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                 L"%d: %s\n",
                 cLine,
                 recReturned->dn);
        PrintRecord(recReturned, 
                    PRT_LOG|PRT_ERROR);
                    
        if (dwError == LL_LDAP) {
            if (fSkipExist && (dwLdapError == LDAP_OTHER)) {
                if (dwLdapExtError == ERROR_MEMBER_IN_ALIAS) {
                    SelectivePrint2W( PRT_ERROR,
                                     L"%d: ",
                                     cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                     MSG_LDIFDE_MEMBEREXIST);
                }
                else {
                    //
                    // Unignorable errors -> program termination
                    //
                    SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ADDERROR,
                                    cLineReturn, 
                                    ldap_err2string(dwLdapError));
                    OutputExtendedErrorByCode(dwLdapExtError);
                    
                    return;
                }
            } 
            //
            // If skip is on, and if we get objectclass violation, it means
            // the objectclass does not exist. We then check the item 
            // actually has no attributes, we'll ignore that if it's the 
            // case
            //
            else if (fSkipExist && 
                     (dwLdapError == LDAP_OBJECT_CLASS_VIOLATION) &&
                     recReturned->fIsChangeRecord && 
                     (recReturned->changes->mods_mem && (*(recReturned->changes->mods_mem) == NULL))) {
                SelectivePrint2W( PRT_ERROR,
                                  L"%d: ",
                                  cLineReturn );
                SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_NOATTRIBUTES);
            }
            else if (fSkipExist && 
                    (dwLdapError == LDAP_ALREADY_EXISTS || 
                     dwLdapError == LDAP_CONSTRAINT_VIOLATION ||
                     dwLdapError == LDAP_ATTRIBUTE_OR_VALUE_EXISTS ||
                     dwLdapError == LDAP_NO_SUCH_OBJECT)) {
                //
                // Error that can be ignored
                //
                if (dwLdapError == LDAP_ALREADY_EXISTS) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ENTRYEXIST);
                }
                else if (dwLdapError == LDAP_ATTRIBUTE_OR_VALUE_EXISTS) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ATTRVALEXIST);
                }
                else if (dwLdapError == LDAP_NO_SUCH_OBJECT) {
                    SelectivePrint2W( PRT_ERROR,
                                    L"%d: ",
                                    cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_OBJECTNOEXIST);
                }
                else {
                    SelectivePrint2W( PRT_ERROR,
                                     L"%d: ",
                                     cLineReturn );
                    SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_CONSTRAINTVIOLATE);
                } 
            }
            else {
                //
                // Unignorable errors -> program termination
                //
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_ADDERROR,
                                cLineReturn, 
                                ldap_err2string(dwLdapError)); 
                OutputExtendedErrorByCode(dwLdapExtError);
                
                return;
            }                
        }
        else {
            SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_ERRLOAD);

            return;
        }

    }
    else {
        //
        // SUCCESS
        //
        SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
             L"%d: %s\n",
             cLine,
             recReturned->dn);
        PrintRecord(recReturned, PRT_LOG);
        SelectivePrintW( PRT_STD_VERBOSEONLY|PRT_LOG,
                        MSG_LDIFDE_ENTRYMODIFIED);
    }


    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\inc\utils.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    utils.h

Abstract:

    This is the header file that will be precompiled. Include this in all
    the source files

Environment:

    User mode

Revision History:

    03/20/98 -srinivac-
        Created it

--*/

#ifndef _UTILS_H_
#define _UTILS_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>

#include "symhelp.h"
#include "debug.h"
#include "memory.h"
#include "async.h"

#endif // ifndef _UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\base64.c ===
/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.c

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    This code is essentially the same as util\base64, except that it uses 
    h* memory allocation funciton which use ldifldap's provate heap.
    
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#include <precomp.h>

//-------------------------------------------------------------------------------------------
// Function:     base64decode()
//
// Description:  base-64 decode a string of data. The data must be '\0' terminated.
//
// Arguments:    bufcoded       -pointer to encoded data
//               pcbDecoded     -number of decode bytes
//
// Return Value: Returns pointer to byte blob  is successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PBYTE 
base64decode(
    PWSTR pszBufCoded, 
    long * plDecodedSize
    )
{
    long lBytesDecoded;
    int pr2six[256];
    int i;
    int j=0;
    PWSTR pszCur = pszBufCoded;
    int fDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    PWSTR pszBufIn = NULL;
    PBYTE pbBufOut = NULL;
    PBYTE pbTemp = NULL;    
    PBYTE pbBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=wcslen(pszCur)-1+4;
    *plDecodedSize = lBufSize;

    pbBufDecoded = (PBYTE)MemAlloc_E(lBufSize*sizeof(BYTE));
    if(!pbBufDecoded) {
        hr = E_OUTOFMEMORY;
        BAIL();
    }

        
    lCount=wcslen(pszCur);

    // Do the decoding to new buffer
    pszBufIn = pszCur;
    pbBufOut = pbBufDecoded;

    while(lCount > 0) {
        *(pbBufOut++) = (BYTE) (pr2six[*pszBufIn] << 2 | pr2six[pszBufIn[1]] >> 4);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[1]] << 4 | pr2six[pszBufIn[2]] >> 2);
        *(pbBufOut++) = (BYTE) (pr2six[pszBufIn[2]] << 6 | pr2six[pszBufIn[3]]);
        pszBufIn += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(pbBufOut++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(pbBufOut-pbBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (pszBufIn[-1]=='=') lop_off++;
    if (pszBufIn[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    pbTemp = (PBYTE) MemAlloc_E((*plDecodedSize)*sizeof(BYTE));
    if (!pbTemp) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    memcpy(pbTemp, pbBufDecoded, (*plDecodedSize)*sizeof(BYTE));
error:
    if (pbBufDecoded) {
        MemFree(pbBufDecoded);
    }
    return pbTemp; 
}

//
// the map for the encoder, according to RFC 1521
//
WCHAR _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


//-------------------------------------------------------------------------------------------
// Function:     base64encode()
//
// Description:  base-64 encode a string of data
//
// Arguments:    bufin          -pointer to data to encode
//               nbytes         -number of bytes to encode (do not include the trailing '\0'
//                                                               in this measurement if it is a string.)
//
// Return Value: Returns '\0' terminated string if successful; otherwise NULL is returned.
//-------------------------------------------------------------------------------------------
PWSTR 
base64encode(
    PBYTE pbBufInput, 
    long nBytes
    )
{
    PWSTR pszOut = NULL;
    PWSTR pszReturn = NULL;
    long i;
    long OutBufSize;
    PWSTR six2pr = _six2pr64;
    PBYTE pbBufIn = NULL;
    PBYTE pbBuffer = NULL;
    DWORD nPadding;

    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nBytes + ((nBytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nBytes
    //
    pszOut = (PWSTR)MemAlloc_E((OutBufSize + 1)*sizeof(WCHAR));
    pszReturn = pszOut;

    nPadding = 3 - (nBytes % 3);
    if (nPadding == 3) {
        pbBufIn = pbBufInput;
    }
    else {
        pbBuffer = (PBYTE)MemAlloc_E(nBytes + nPadding);
        pbBufIn = pbBuffer;
        memcpy(pbBufIn,pbBufInput,nBytes);
        while (nPadding) {
            pbBufIn[nBytes+nPadding-1] = 0;
            nPadding--;
        }
    }
    

    //
    // Encode everything
    //  
    for (i=0; i<nBytes; i += 3) {
        *(pszOut++) = six2pr[*pbBufIn >> 2];                                     // c1 
        *(pszOut++) = six2pr[((*pbBufIn << 4) & 060) | ((pbBufIn[1] >> 4) & 017)]; // c2
        *(pszOut++) = six2pr[((pbBufIn[1] << 2) & 074) | ((pbBufIn[2] >> 6) & 03)];// c3
        *(pszOut++) = six2pr[pbBufIn[2] & 077];                                  // c4 
        pbBufIn += 3;
    }

    //
    // If nBytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if (i == nBytes+1) {
        // There were only 2 bytes in that last group 
        pszOut[-1] = '=';
    } 
    else if (i == nBytes+2) {
        // There was only 1 byte in that last group 
        pszOut[-1] = '=';
        pszOut[-2] = '=';
    }

    *pszOut = '\0';

    if (pbBuffer) {
        MemFree(pbBuffer);
    }

    return pszReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifde\export.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    export.cxx

ABSTRACT:

DETAILS:
    
CREATED:

    09/02/97    Felix Wong (felixw)

REVISION HISTORY:

--*/


#include "ldifde.hxx"
#pragma hdrstop

WCHAR szTempExtraFile[MAX_PATH] = L"";
BOOLEAN bExtraExist = FALSE;
HANDLE hFileExtra = NULL;
DWORD dwWritten;
PWSTR g_szFrom = NULL;
PWSTR g_szTo = NULL;

#define UNICODE_MARK 0xFEFF
//+---------------------------------------------------------------------------
// Function:   DSExport 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD DSExport(LDAP *pLdap, ds_arg *pArg)
{
    DWORD           hr = ERROR_SUCCESS;
    int             search_err;
    LDIF_Error        ll_err;
    LDAPMessage     *res = NULL;
    LDAPMessage     *entry = NULL;
    HANDLE          hFileOut = NULL;
    PLDAPSearch     pSearch = NULL;
    DWORD           cEntriesExported = 0;
    PWSTR           pszRootDN = NULL;
    DWORD           dwFlag = 0;
    BOOL            fPagingAvail = FALSE;
    BOOL            *pfPagingAvail = &fPagingAvail;
    BOOL            fSAMAvail = FALSE;
    PWSTR           *ppszAttrsWithRange = NULL;
    BOOL            fSearchStart = TRUE, fAttrsWithRange = FALSE;
    BOOL            fEntryExported = FALSE;
    
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_EXPORTING,
                   pArg->szFilename);
    
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_SEARCHING);

    if (pArg->fSAM) {
        dwFlag |= LL_INIT_BACKLINK;
    }
    if (pArg->szRootDN == NULL) {
        dwFlag |= LL_INIT_NAMINGCONTEXT;
    }
    
    //
    // If paging is off already, we don't need to ask whether paging is 
    // available or not.
    // pfPagingAvail is used to pass into InitExport to get paging status.
    //
    if (!pArg->fPaged) {
        pfPagingAvail = NULL;
    }


    ll_err = LDIF_InitializeExport(pLdap,
                            pArg->omitList,
                            dwFlag,
                            &pszRootDN,
                            pArg->szFromDN,
                            pArg->szToDN,
                            pfPagingAvail,
                            &fSAMAvail);    
    if (ll_err.error_code!=LL_SUCCESS) {
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);      
        
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // If RootDN is NULL, we check if InitExport returns the naming context
    // correctly
    //
    if (pArg->szRootDN == NULL) {
        //
        // Output error message if we failed to get default naming context
        //
        if (pszRootDN == NULL) {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_ROOTDN_NOTAVAIL); 
            /*
            hr = ERROR_INVALID_PARAMETER;
            BAIL();
            */
        }
        else {
        //
        // else use it
        //
            pArg->szRootDN = pszRootDN;
        }
    }

    //
    // If we asked for SAM and it is not available, output error message and
    // turn off SAM logic, but still go on
    // 
    if (pArg->fSAM && (fSAMAvail == FALSE)) {
        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_SAM_NOTAVAIL); 
        pArg->fSAM = FALSE;
    }

    //
    // If the user requests paging, but it is not available, we'll inform the
    // user and turn off paging
    //
    if (pArg->fPaged) {

        //
        // If user requested paging, we must have passed in a valid entry
        // to initExport to get back status
        //
        ASSERT(pfPagingAvail);

        if (fPagingAvail == FALSE) {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_PAGINGNOTAVAIL); 
            pArg->fPaged = FALSE;
        }
    }

    if (pArg->szFromDN) {
        g_szFrom = MemAllocStrW_E(pArg->szFromDN);
    }
    if (pArg->szToDN) {
        g_szTo = MemAllocStrW_E(pArg->szToDN);
    }

    do { // keep retrieving results till all values of all multivalued
        // attributes are returned. 

      if (!pArg->fPaged) {

        // ****************
        // NON-PAGED SEARCH
        // ****************
        ULONG msgnum;

        msgnum = ldap_searchW(pLdap, 
                              pArg->szRootDN, 
                              pArg->dwScope, 
                              pArg->szFilter, 
                              ppszAttrsWithRange ? ppszAttrsWithRange:
                                                   pArg->attrList,  
                              0);
                                       
        search_err = LdapResult(pLdap, msgnum, &res);
        
        if ( search_err!= LDAP_SUCCESS ) {
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                            MSG_LDIFDE_SEARCHERROR, 
                            ldap_err2string(search_err));
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if(ppszAttrsWithRange)
        {
            // free any previous attribute names with range values in them

            int i = 0; 

            while(ppszAttrsWithRange[i])
            {
                MemFree(ppszAttrsWithRange[i]);
                i++;
            }

            MemFree(ppszAttrsWithRange);
            ppszAttrsWithRange = NULL;
            fAttrsWithRange = TRUE;
        }
        else
            fAttrsWithRange = FALSE;
   
        if(fSearchStart) // first time through do-while loop
        { 
            if ((hFileOut = CreateFileW(pArg->szGenFile, 
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL | 
                                   FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ERROR_OPENOUTPUT,
                                    hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (g_fUnicode) {
                WCHAR wchar = UNICODE_MARK;
                if (WriteFile(hFileOut,
                          &wchar,
                          sizeof(WCHAR),
                          &dwWritten,
                          NULL) == FALSE) {
                    hr = GetLastError();
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }

            //
            // Step through each entry
            //
            SelectivePrintW(PRT_STD|PRT_LOG,
                        MSG_LDIFDE_WRITINGOUT);
            SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                         L"\n");
            TrackStatus();

            fSearchStart = FALSE;
         } // if(fSearchStart)
         
         for ( entry = ldap_first_entry( pLdap, 
                                         res ); 
               entry != NULL; 
               entry = ldap_next_entry( pLdap, 
                                        entry ) ) { 
             fEntryExported = FALSE;
             hr = ParseEntry(pArg,
                             pLdap,
                             entry,
                             hFileOut,
                             &ppszAttrsWithRange,
                             fAttrsWithRange,
                             &fEntryExported);
             DIREXG_BAIL_ON_FAILURE(hr);
             if(fEntryExported)
                 cEntriesExported++;
         }
                
      }
      else {
        
        // ****************
        // PAGED SEARCH
        // ****************

        pSearch = ldap_search_init_pageW( pLdap,
                                          pArg->szRootDN,
                                          pArg->dwScope, 
                                          pArg->szFilter, 
                                          ppszAttrsWithRange ? ppszAttrsWithRange :
                                                             pArg->attrList,  
                                          FALSE,
                                          NULL,        // server controls
                                          NULL,
                                          0,
                                          20000,
                                          NULL         // sort keys
                                        );
    
        search_err = LDAP_SUCCESS;

        if(ppszAttrsWithRange)
        {
            // free any previous attribute names with range values in them

            int i = 0;

            while(ppszAttrsWithRange[i])
            {
                MemFree(ppszAttrsWithRange[i]);
                i++;
            }

            MemFree(ppszAttrsWithRange);
            ppszAttrsWithRange = NULL;
            fAttrsWithRange = TRUE;
        }
        else
            fAttrsWithRange = FALSE;
    
        if (pSearch == NULL) {
            search_err = LdapGetLastError();
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_SEARCHFAILED);
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        if(fSearchStart)
        {
            if ((hFileOut = CreateFileW(pArg->szGenFile, 
                                   GENERIC_WRITE,
                                   0,
                                   NULL,
                                   CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL |
                                   FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_ERROR_OPENOUTPUT,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (g_fUnicode) {
                WCHAR wchar = UNICODE_MARK;
                if (WriteFile(hFileOut,
                          &wchar,
                          sizeof(WCHAR),
                          &dwWritten,
                          NULL) == FALSE) {
                    hr = GetLastError();
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            }
        }
         
        while ((search_err == LDAP_SUCCESS) && (pSearch != NULL)) {
    
            ULONG totalCount;
    
            search_err = ldap_get_next_page_s(  pLdap,
                                                pSearch,
                                                g_pLdapTimeout,
                                                10,
                                                &totalCount,
                                                &res );
    
            if (fSearchStart) {
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_WRITINGOUT);
                SelectivePrint2W(PRT_STD_VERBOSEONLY|PRT_LOG,
                                L"\n");
                fSearchStart = FALSE;
                g_fDot = TRUE;  // Turn on dots so that a 'new line' char will
                                // be added before printing next statement.
            }

            if (res != NULL) {
    
                ULONG rc;
                PWSTR matchedDNs = NULL;
                PWSTR errors     = NULL;
                PWSTR *referrals  = NULL;
    
                search_err = ldap_parse_result( pLdap,
                                                 res,
                                                 &rc,
                                                 &matchedDNs,
                                                 &errors,
                                                 &referrals,
                                                 NULL,
                                                 FALSE      // don't free it.
                                                );
    
                if (referrals != NULL) {
                    PWSTR *val = referrals;
                    while (*val != NULL) {
                        wprintf(L"%s\n", *val );
                        val++;
                    }
                    ldap_value_free( referrals );
                }
    
                if (errors != NULL) {
                    ldap_memfree( errors );
                }
    
                if (matchedDNs != NULL) {
                    ldap_memfree( matchedDNs );
                }
            
                //
                // Step through each entry
                //
                for ( entry = ldap_first_entry( pLdap, 
                                                 res ); 
                      entry != NULL; 
                      entry = ldap_next_entry( pLdap, 
                                                entry ) ) { 
                    fEntryExported = FALSE;
                    hr = ParseEntry(pArg,
                                    pLdap,
                                    entry,
                                    hFileOut,
                                    &ppszAttrsWithRange,
                                    fAttrsWithRange,
                                    &fEntryExported);
                    DIREXG_BAIL_ON_FAILURE(hr);
                    if(fEntryExported)
                        cEntriesExported++;
                }
            }
            ldap_msgfree(res);
            res = NULL;
        }

        if ((search_err != LDAP_SUCCESS) && (search_err != LDAP_NO_RESULTS_RETURNED)) {
            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                           MSG_LDIFDE_SEARCHFAILED);
            OutputExtendedErrorByConnection(pLdap);
            hr = LdapToWinError(search_err);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    
      }

    } while(ppszAttrsWithRange);

    if (hFileExtra) {
        CloseHandle(hFileExtra);
        if ((hFileExtra = CreateFile(szTempExtraFile, 
                                   GENERIC_READ,
                                   0,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                   NULL)) == INVALID_HANDLE_VALUE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_ERROR_OPENTEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        hr = AppendFile(hFileExtra,
                        hFileOut);
        if (hr != 0) {
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_ERRORWRITE,hr);
        }
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    
    if (cEntriesExported == 0) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_NOENTRIES);
    }
    else {
        SelectivePrintW(PRT_STD|PRT_LOG,
                       MSG_LDIFDE_NUMEXPORTED,
                       cEntriesExported);
    }
error:
    if (hFileExtra) {
        CloseHandle(hFileExtra);
    }

    if (pSearch != NULL) {
        ldap_search_abandon_page( pLdap, pSearch );
    }

    if (hFileOut) {
        CloseHandle(hFileOut);
    }

    if (res) {
        ldap_msgfree(res);
    }

    if (pszRootDN) {
        MemFree(pszRootDN);
    }

    if (g_szFrom) {
        MemFree(g_szFrom);
    }

    if (g_szTo) {
        MemFree(g_szTo);
    }

    if(ppszAttrsWithRange)
    {
        // free any previous attribute names with range values in them

        int i = 0;

        while(ppszAttrsWithRange[i])
        {
            MemFree(ppszAttrsWithRange[i]);
            i++;
        }

        MemFree(ppszAttrsWithRange);
        ppszAttrsWithRange = NULL;
    }

#ifndef LEAVE_TEMP_FILES
    if (szTempExtraFile[0]) {
        DeleteFile(szTempExtraFile);
        szTempExtraFile[0] = NULL;
    }
#endif

    LDIF_CleanUp();
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:  ParseEntry  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD ParseEntry(ds_arg *pArg,
                   LDAP *pLdap,
                   LDAPMessage *entry,
                   HANDLE hFileOut,
                   PWSTR **pppszAttrsWithRange,
                   BOOL fAttrsWithRange,
                   BOOL *pfEntryExported)
{
    LDIF_Error        ll_err;
    DWORD           i;
    DWORD           hr = ERROR_SUCCESS;
    PWSTR           *rgszParsed = NULL;
    PWSTR           szParsedOutput = NULL;
    DWORD           j;
    PWSTR           szReplace = NULL;
    PWSTR           szTemp;

    TrackStatus();
    
    rgszParsed = NULL;
    ll_err = LDIF_GenerateEntry(pLdap, 
                           entry, 
                           (PWSTR**)&rgszParsed, 
                           pArg->fSAM,
                           !pArg->fBinary,
                           pppszAttrsWithRange,
                           fAttrsWithRange);
    if((ll_err.error_code!=LL_SUCCESS)) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_PARSE_FAILED);
        hr = PrintError(PRT_STD|PRT_LOG|PRT_ERROR,
                        ll_err.error_code);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    if (ll_err.the_modify != -1) {
        
        //
        // Write out to temporary file
        //
        WCHAR szTempExtraPath[MAX_PATH];

        if (!bExtraExist) {
            bExtraExist = TRUE;
            if (!(GetTempPath(MAX_PATH, szTempExtraPath))) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_LDIFDE_ERROR_CREATETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            
            if (!(GetTempFileName(szTempExtraPath, 
                                  L"ldif", 
                                  0, 
                                  szTempExtraFile))) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                               MSG_LDIFDE_ERROR_CREATETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            if ((hFileExtra = CreateFile(szTempExtraFile, 
                                       GENERIC_WRITE,
                                       0,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                                       NULL)) == INVALID_HANDLE_VALUE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_ERROR_OPENOUTPUT,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }
        }

        j = ll_err.the_modify;            
        while(rgszParsed[j]) {
            szReplace = rgszParsed[j];
            DWORD dwSize;
            if (g_fUnicode) {
                dwSize = wcslen(szReplace) * sizeof(WCHAR);             
            }
            else {
                UnicodeToAnsiString(szReplace,
                                    (PSTR)szReplace);
                dwSize = strlen((PSTR)szReplace) * sizeof(CHAR);
            }
            if (WriteFile(hFileExtra,
                           (PBYTE)szReplace,
                           dwSize,
                           &dwWritten,
                           NULL) == FALSE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_FAILEDWRITETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }

            if (szParsedOutput) {
                MemFree(szParsedOutput);
                szParsedOutput = NULL;
            }
            j++;
        }

        // we will always print a newline here as we are guaranteed that there
        // is at least one linked atribute printed out for this object 
        // if the_modify is != -1.
        DWORD dwSize;
        PBYTE pByte;
        if (g_fUnicode) {
            pByte = (PBYTE)L"\r\n";
            dwSize = 2 * sizeof(WCHAR);             
        }
        else {
            pByte = (PBYTE)"\r\n";
            dwSize = 2 * sizeof(CHAR);              
        }
        if (WriteFile(hFileExtra,
                   (LPCVOID)pByte,
                   dwSize,
                   &dwWritten,
                   NULL) == FALSE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                    MSG_LDIFDE_FAILEDWRITETEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
   
    if (ll_err.the_modify != -1) {
        j = ll_err.the_modify;
    }
    else {
        j = -1;
    }
    if (rgszParsed) {
        i = 0;            
        // added check for j == 1 below since rgszParsed[0] would contain 
        // "\r\n" if we were dealing only with linked attributes and we don't 
        // want to count this as an entry in the output file. The output for
        // the linked attributes goes into a separate file which gets appended
        // to the output file below. j == 1 would not occur in the normal case
        // as any entry will have at lease two lines - for dn and changetype.
        while(rgszParsed[i] && (i < j) && (j != 1)) {

            szReplace = rgszParsed[i];

            DWORD dwSize;
            if (g_fUnicode) {
                dwSize = wcslen(szReplace) * sizeof(WCHAR);             
            }
            else {
                UnicodeToAnsiString(szReplace,
                                    (PSTR)szReplace);
                dwSize = strlen((PSTR)szReplace) * sizeof(CHAR);
            }
            if (WriteFile(hFileOut,
                           (PBYTE)szReplace,
                           dwSize,
                           &dwWritten,
                           NULL) == FALSE) {
                hr = GetLastError();
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                         MSG_LDIFDE_FAILEDWRITETEMP,hr);
                DIREXG_BAIL_ON_FAILURE(hr);
            }         
        
            if (szParsedOutput) {
                MemFree(szParsedOutput);
                szParsedOutput = NULL;
            }
            i++;
        }

        // don't double count for objects which are being retrieved for
        // the second time due to an attribute having a range specifier
        if((i != 0) && (FALSE == fAttrsWithRange))
            *pfEntryExported = TRUE;
        else
            *pfEntryExported = FALSE;

        if(rgszParsed[0])
        {
            if (g_fUnicode) {
                rgszParsed[0][wcslen(rgszParsed[0]) - 1] = NULL;
                rgszParsed[0][wcslen(rgszParsed[0]) - 1] = NULL;
                SelectivePrintW(PRT_STD_VERBOSEONLY|PRT_LOG,
                            MSG_LDIFDE_EXPORT_ENTRY,
                            rgszParsed[0]+4);
            }
            else {
                ((PSTR)rgszParsed[0])[strlen((PSTR)rgszParsed[0]) - 1] = NULL;
                ((PSTR)rgszParsed[0])[strlen((PSTR)rgszParsed[0]) - 1] = NULL;
                szTemp = AllocateUnicodeString(((PSTR)rgszParsed[0])+4);
                if (szTemp) {
                    SelectivePrintW(PRT_STD_VERBOSEONLY|PRT_LOG,
                               MSG_LDIFDE_EXPORT_ENTRY,
                               szTemp);
                    MemFree(szTemp);
                }

            }
        }
        LDIF_FreeStrs(rgszParsed);
        rgszParsed = NULL;
    }
     
    // if something was printed out to hFileOut, print out a newline too.
    // Nothing may be printed if LDAP only returns teh DN of an object and 
    // does not return any of its attributes (which may happen if the object
    // does not have the specified attribute).  
    if(*pfEntryExported)
    { 
        DWORD dwSize;
        PBYTE pByte;

        if (g_fUnicode) {
            pByte = (PBYTE)L"\r\n";
            dwSize = 2 * sizeof(WCHAR);             
        }
        else {
            pByte = (PBYTE)"\r\n";
            dwSize = 2 * sizeof(CHAR);              
        }
        if (WriteFile(hFileOut,
                  (LPCVOID)pByte,
                  dwSize,
                  &dwWritten,
                  NULL) == FALSE) {
            hr = GetLastError();
            SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_FAILEDWRITETEMP,hr);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

error:
    if (rgszParsed) {
        LDIF_FreeStrs(rgszParsed);
    }
    if (szParsedOutput) {
        MemFree(szParsedOutput);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\inc\ldifext.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifext.h

Abstract:

    Header for users of the library

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

--*/
#ifndef _LDIFEXT_H
#define _LDIFEXT_H

#ifdef __cplusplus
extern "C" {
#endif

#include <..\ldifldap\base64.h>

extern BOOLEAN g_fUnicode;         // whether we are using UNICODE or not

//
// When the parser returns with an ldif-change-record, the result will be in a 
// null terminated linked list of the following struct. a pointer to the head of 
// this list will be found in the LDIF_Record defined below. The DN of the entry 
// will also be in the changerecord. 
//

//
// The node for the linked list built up while parsing a changerecord list.
// Note: because of an ambigiouty in the LDIF spec, nothing can follow a 
// change: add entry in the same ldif-change-record
//
struct change_list {
    union {
        LDAPModW **mods;    // if this is a changetype: add, modify
        PWSTR     dn;       // if this is a changetype: mod(r)dn
    } stuff;

    int operation;         
    int deleteold;         // This the the deleteold option in moddn. Note 
                           // that only deleteold==1 works with our DS.
                           // I mean I could've made a struct within the 
                           // union, but thats way too complicated. Having 
                           // it here is much easier.
    struct change_list *next;
};

#define mods_mem        stuff.mods
#define dn_mem          stuff.dn


//
// The codes inside in the operation field inside a change_list node.
//

enum _CHANGE_OP
{
    CHANGE_ADD             =  1,  // a change: add with an attrval spec list
    CHANGE_DEL             =  2,  // a delete without anything
    CHANGE_DN              =  3,  // a chdn with a new dn and deleteoldrdn
    CHANGE_MOD             =  4,  // a modify
    CHANGE_NTDSADD         =  5,  // a change: add with an attrval spec list
    CHANGE_NTDSDEL         =  6,  // a delete without anything
    CHANGE_NTDSDN          =  7,  // a chdn with a new dn and deleteoldrdn
    CHANGE_NTDSMOD         =  8   // a modify
};


//
// The ldif functions will work with the following structure 
//
typedef struct {
    PWSTR dn;

    //
    // TRUE implies this is a change record and the "changes" linked list is 
    // valid
    // FALSE implies this is a content record and the "contents" array of 
    // pointers is valid.
    //
    BOOL fIsChangeRecord;

    union {
        struct change_list *changes;
        LDAPModW **        content;
    };

} LDIF_Record;

//
// Errors to the calling program are returned in this struct.
//
typedef struct ldiferror {
    DWORD error_code;  // error codes as defined below
    WCHAR token_start; // if its a syntax error, indicate start of the token
    PWSTR szTokenLast; // if its a syntax error, indicate start of the token
    long  line_number; // line number of error
    long  line_begin;  // beginning line of this record
    int   ldap_err;    // LDIF_LoadRecord may detect an error in an ldap call 
    int   RuleLastBig; // The last rule the grammar parsed successfully.
                       // codes defined in ldifext.h 
    int   RuleLast;    // the last lower level rule parsed successfully 
    int   RuleExpect;  // The rule the grammar expects to see next 
    int   TokenExpect; // The token the grammar expects to see next 
    long  the_modify;  // LDIF_GenerateEntry can tell the world          
                       // where the modify portion starts. -1 if none */
} LDIF_Error;


//
// Various exceptions that could be raised by the program. These also double as 
// error codes in the returned error struct
//

#define LL_SUCCESS         0          // The function executed successfully
#define LL_INIT_REENTER    0x00000200
#define LL_FILE_ERROR      0x00000300
#define LL_INIT_NOT_CALLED 0x00000400
#define LL_EOF             0x00000500
#define LL_SYNTAX          0x00000600   
                                      //
                                      // Syntax error, token_start contains the 
                                      // start of the token at or after which 
                                      // the error occurs and line_number 
                                      // contains the line_number of the error.
                                      //

#define LL_URL             0x00000700
#define LL_EXTRA           0x00000800 // Extraneous attributes in a mod-spec
#define LL_LDAP            0x00000900 // LDAP call failed. Errcode in 
                                      // error->ldap_err
#define LL_MULTI_TYPE      0x00000A00 
#define LL_INTERNAL        0x00000B00 
                                      //
                                      // you have uncovered a bug in 
                                      // ldifldap.lib. Please report it. 
                                      //
#define LL_DUPLICATE       0x00000C00
#define LL_FTYPE           0x00000D00 //
                                      // Illegal mix of ldif-records and 
                                      // ldif-changerecords
                                      //
#define LL_INITFAIL        0x00000E00  
#define LL_INTERNAL_PARSER 0x00000F00 // internal error in parser

//
// NOTE: THIS ERROR NO LONGER EXITS!!!
// The implementation has been changed to allow the mixing of values.
// I leave it here (and some dormant codepaths) in case the old
// string functionality needs to be resurrected and this error 
// will live again!
//
// The above error (LL_MULTI_TYPE) is such:
//  Each attribute may have one or more values. For example:
//      description: tall
//      description: beautiful
// Notice how both of these values are strings. Another example 
// is:
//      description:: [some base64 value]
//      description:< file://c:\myfile
// The first example winds up as multiple strings in a single LDAPMod
// struct.The second winds up as multiple bervals. Although the LDIF spec
// does not specifically mention this, it is illegal to combine the two 
// in one entry. What this means is that as multilple values for the same 
// attribute, one cannot specify both a string and a URL. 
// i.e.
//      description:< file://c:\myfile
//      description:  HI!
//  BAD!!!
// The reason for this is that that these multiple values (according to the 
// spirit of the LDAP API and the LDIF specification) are meant to wind up 
// in the same LDAPMod struct, which is impossible if they are strings and 
// bervals. 
// This is not a problem however, considering that if a value is meant to 
// take one, the user should not want to specify the other. Specifying 
// different types for different attributes is of course fine. If the user 
// wants to accomplish what he intends in the incorrect exmaple, he should 
// split the operation into two entries. (One that creates the attribute 
// with some values of one type and one that adds some of the other) 
//

//
// The following values will be found in lastrule, lastsmall, expectrule,
// expecttoken members of the error struct if the error was a syntax error.
// They help explain what the parser was doing and expecting. 
//

// 
// lastrule field - this field tells the last major rule the parser accepted. 
// Refer to the LDIF draft of June 9, 1997. 
// For an example of how to use these 4 fields, see the ClarifyErr() helper 
// function in rload.c 
// Note: R stands for Rule.
//
enum _RULE
{
    R_VERSION      = 1,  // the version-spec rule. version: #
    R_REC          = 2,  // the ldif-attrval-record rule. dn SEP (list of) 
                         // [attrval-spec SEP] 
    R_CHANGE       = 3,  // the ldif-change-record rule. dn SEP (list of)  
                         // [changerecord SEP]   
    R_DN           = 4,  // the dn-spec rule. dn:(:) the DN
    R_AVS          = 5,  // an attrval-spec.
    R_C_ADD        = 6,  // a change: add changerecord
    R_C_DEL        = 7,  // a change: delete changerecord
    R_C_DN         = 8,  // a change: dn changerecord
    R_C_NEWSUP     = 9,  // a change: dn changerecord with a newsup addendum
    R_C_MOD        = 10, // a changetype: modify
    R_C_MODSPEC    = 11  // a mod-spec
};

// 
// lastsmall field - this field tells the last minor rule or token the 
// parser accepted. The line between this and the above is vague.
// Basically, if I felt it was a major rule, it was major,
// and if I didn't, it was minor. Generally, you'll find the major rules 
// higher up in the BNF tree than the minor ones. The minor rule 
// will usually show the last part of the major rule, unless it doesn't.
// Together with the "expecting" information, these two will
// will clarify where the parser was able to get up to and where it
// was forced to stop. (RS stands for rule small)
//
enum _RULESMALL
{
    RS_VERNUM      = 1,        // the version-number rule
    RS_ATTRNAME    = 2,        // a valid attribute name followed by colon
    RS_ATTRNAMENC  = 3,        // an attribute name without colon. (mod-spec)
    RS_DND         = 4,        // a dn::
    RS_DN          = 5,        // a dn:
    RS_DIGITS      = 6,        // some digits
    RS_VERSION     = 7,        // version: 
    RS_BASE64      = 8,        // a base64 string
    RS_SAFE        = 9,        // a regular safe string
    RS_DC         = 10,        // good old double colon 
    RS_URLC       = 11,        // a URL colon :<
    RS_C          = 12,        // a single colon
    RS_MDN        = 13,        // a modrdn or a moddn
    RS_NRDNC      = 14,        // a newrdn:
    RS_NRDNDC     = 15,        // a newrdn::
    RS_DORDN      = 16,        // a deleteoldrdn:
    RS_NEWSUP     = 17,        // a newsuperior: 
    RS_NEWSUPD    = 18,        // a newsuperior:: 
    RS_DELETEC    = 19,        // a delete:
    RS_ADDC       = 20,        // a add:
    RS_REPLACEC   = 21,        // a replace:
    RS_CHANGET    = 22,        // a changetype: 
    RS_C_ADD      = 23,        // an add
    RS_C_DELETE   = 24,        // a delete
    RS_MINUS      = 25,        // a minus
    RS_C_MODIFY   = 26         // a modify
};

//
// expectrule - this field shows which rule (there maybe more than one option)
// that the parser wanted to see after the last rule that it parsed. RE stands
// for Rule Expect.
//
enum _EXPECTRULE
{
    RE_REC_OR_CHANGE   = 1,   // ldif-attrval-record or an ldif-change-record
    RE_REC             = 2,   // ldif-attrval-record
    RE_CHANGE          = 3,   // ldif-change-record
    RE_ENTRY           = 4,   // the post-DN body of an ldif-c-r or ldif-a-r
    RE_AVS_OR_END      = 5,   // another attribute value spec or list 
                              // termination.
    RE_CH_OR_NEXT      = 6,   // another changetype: * or end of entry
    RE_MODSPEC_END     = 7    // another mod-sepc or entry's end
};


//
// expecttoken - this field will show the token or small rule (there may
// again be more than one option that the parse wanted to see next.
// RT stands for rule token.
//

enum _EXPECTTOKEN
{
    RT_DN              = 1,    // a dn: or a dn::
    RT_ATTR_OR_CHANGE  = 2,    // an [attribute name]: or a changetype: 
                               // (add|delete|etc.)
    RT_ATTR_MIN_SEP    = 3,    // an attribte name, a minus or (at least) 
                               // two separators
    RT_CH_OR_SEP       = 4,    // a changetype: or another SEP signifying 
                               // entry's end
    RT_MODBEG_SEP      = 5,    // a (add|delete|replace), or a another SEP 
                               // signifying end
    RT_C_VALUE         = 6,    // one of the colons followed by the appropriate 
                               // value
    RT_ATTRNAME        = 7,    // an attribute name followed by the colons.            
    RT_VALUE           = 8,    // a regular safevalue
    RT_MANY            = 9,    // any number of different things
    RT_DIGITS          = 10,   // some digits 
    RT_BASE64          = 11,   // a base64 as defined in RFC 1521. 
                               // (length mod 4 MUST ==0)
    RT_URL             = 12,   // a URL
    RT_NDN             = 13,   // a newrdn: or a newrdn::
    RT_ATTRNAMENC      = 14,   // an attribute name without a colon
    RT_ADM             = 15,   // an add, delete, or a modify
    RT_ACDCRC          = 16    // and add: delete: or replace:
};


// 
// functions accessible to the user
//

STDAPI_(LDIF_Error)
LDIF_InitializeImport(
    LDAP *pLdap,
    PWSTR filename,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfLazyCommitAvail);
    
STDAPI_(LDIF_Error)
LDIF_InitializeExport(
    LDAP *pLdap,
    PWSTR *omit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail);

enum _LL_INIT_FLAGS
{
    LL_INIT_NAMINGCONTEXT = 1,   
    LL_INIT_BACKLINK = 2
};

STDAPI_(void)
LDIF_CleanUp();

//
// Description - LDIF_Parse:
//  This is the main function in the ldifldap library. After calling LL_init,
//  this function is called to retrieve entries from the specified file. 
//  The entries are returned one-by-one. If there is a syntax or other error,
//  the error structure returned  will contain 
//  details. A successfully parsed record will result in several things:
//  
//  1) The dn member of the LDIF_Record struct pointed to by the argument
//     will contain the DN of the entry we're working on.
//              -AND one of the following-
//  2) If the record was a regular record,
//     The content member of that same struct will contain the LDAPMods**
//     array containing the attributes and values. The fIsChangeRecord member
//     will be FALSE.
//  3) If the record was a change record,
//     The changes member of the LDIF_Record will point to the first element
//     of the linked list of changes (in the same order they were sepcified in 
//     the source file). Each of these is a struct change_list. The 
//     fIsChangeRecord member will be TRUE. 
//
//  If any sort of error occured, it 
//  will be reported in the error struct. i.e. If the error is LL_syntax,
//  the other fields of the error struct will be filled with the appropriate 
//  details. 
//   
//  The user is responsible for using and freeing the memory in the returned 
//  structures.
//  This memory may be freed by calling LDIF_ParseFree();
//
//  Also, please note that the allocated memory is only valid before you call 
//  another LL library fucntion (ie. calling LDIF_Parse again), This is 
//  because if some sort of fatal error occurs (i.e. syntax),
//  all resources related to the current ldifldap session will be freed,
//  thus destroying these structures. The user must either use these constructs 
//  and free them, or copy them elsewhere. (There are originally allocated from 
//  the library's private heap.)
//
//  If the entry read was the last one in the file, the return code will
//  be LL_EOF instead of LL_SUCCESS. LDIF_Parse will also return LL_EOF
//  on any subsequent calls until LDIF_CleanUp and LL_init are called to start a
//  new session.  
//
//  Arguments:
//      LL_Record//pRecord; (OUT)
//          This argument takes a pointer to an LDIF_Record the user has created. 
//          This object will be filled with data if the function exits without 
//          error.
//      
//  Return Value:
//      LDIF_Error
//         An LDIF_Error struct. 
//  
//  Example:
//  
//  LDIF_Error            error;
//  LDIF_Record           returned;
//
//  error=LDIF_Parse(&returned);
//  if((error.error_code==LL_SUCCESS)||((error.error_code==LL_EOF)) {
//      LDIF_ParseFree(&returned);
//  }
// 
STDAPI_(LDIF_Error)
LDIF_Parse(LDIF_Record *pRecord);


//
// Description - LDIF_LoadRecord:
//  LDIF_LoadRecord takes the return values of LDIF_Parse, namely the LL_rec, 
//  and loads them into the DS over the specified 
//  LDAP connection. The user is also free to construct his own structures 
//  and pass them to LDIF_LoadRecord. However, they must follow the conventions 
//  that LDIF_Parse follows when returning these to the user. LDIF_LoadRecord does
//  not free anything by itself, however an LDAP error will raise an exception 
//  and cause it to shut down all state in the current ldifldap session. 
//  The function returns the usual error struct. If an error occurs, the 
//  error_code will contain LL_LDAP, and the ldap_err field will contain the 
//  error code the ldap call returned. 
//  
// Arguments:
//  LDAP//ld (IN)   - connection over which to send entries. This must be 
//                    initialized properly.
//  LDIF_Record//pRecord (IN) - the LL_rec argument filled in by LDIF_Parse
//  int active  -   0  for "don't actually do the LDAP calls" Just go through 
//                     the data printing it out if compiled with the DEVELOP 
//                     flag
//              -   1  Go LDAP calls hot. (read: do the actual calls)
// 
// Return Values:
//          The usual error struct.
//
STDAPI_(LDIF_Error)
LDIF_LoadRecord(LDAP   *ld, LDIF_Record *pRecord, int active, 
                BOOL fLazyCommit, BOOLEAN fDoEndIfFail);


//
// Description: LDIF_ParseFree
//      Free the resources allocated by LDIF_Parse associated with the 
//      argument. This function should be called after the data returned by 
//      LL_ldif parse has been used. It should not be called after an LDIF_CleanUp 
//      or after an LDAP library call returned with an error. (That means all 
//      resources have already been freed.) 
// Arguments:
//      LDIF_Record//pRecord;
// Return values:
//      The regular error struct deal. 
// 
//
STDAPI_(LDIF_Error)
LDIF_ParseFree(LDIF_Record *pRecord);


//
//  Description: LDIF_GenerateEntry 
//      This function takes an entry such as those returned by 
//      ldap_first_entry( ld, res );, the LDAP connection it was generated
//      over and a pointer to a char**. It creates an array of
//      strings in the LDIF format, corresponding to the entry.
//      this list is NULL terminated.
//      If any one of the values in any of the attributes are 
//      outside the normal printable text range 0x20-0x7E, it base64
//      encodes all the values of that attribute and outputs them 
//      accordingly. All values that would exceed 80 characters are
//      wrapped. If the samLogic parameter is non-zero, much special
//      processing (like omitting various attributes and separating
//      off membership information will be done for samObjects.) 
//      The the_modify member of error struct will contain the array index 
//      where the group additions start or -1 if there is no modify section. 
//      See rload.doc for details. Also, if you want to import, don't forget 
//      to omit objectGUID for all objects.
//      One last caveat is that if objectClass is one
//      of the attribures, it only outputs the last value (being 
//      the actual class) LDAP returns the entire inheritance tree
//      leading to the specific class but barfs if its sees them all on the
//      way back, when we try to add the entry. Since the file 
//      needs to be digestible on the way back, we need to make this 
//      adjustment. Also the user may specify a null terminated list
//      of attribute names that the function will omit on output.
//      Each line is terminated by carriage returns and \0s, so
//      sample usage of the function that would print out all the entries
//      in a given search result would look like:
//    
//    fputs("# Generated by LDIF_GenerateEntry. Have a nice day.\n", Generated);
//         
//    for ( entry = ldap_first_entry( ld, res ); 
//         entry != NULL; 
//         entry = ldap_next_entry( ld, entry ) ) { 
//         //Call the library function
//         llerr=LDIF_GenerateEntry(ld, entry, &parsed, NULL);
//         i=0;
//         while(parsed[i]) {
//             printf("%s", parsed[i]); 
//             if (fputs(parsed[i], Generated)==EOF) {
//               perror("Stream error");
//             }
//             free(parsed);
//             i++;
//         }
//         free(parsed);
//         if (fputs("\n", Generated)==EOF) {
//            perror("Stream error");
//         }
//         printf("\n\r");
//   }
//  
//  Args:
//      ld (IN) - the connection over which the LDAPMessage e was retrieved
//      e  (IN) - The entry to process as returned by ldap_(first/next)_entry
//      to_return (OUT) - A pointer to a char//*. Will be filled with the
//                        address of the array of strings.
//      omit    - A null terminated array of strings to omit on output. 
//      samLogic - non-zero to treat SamObjects specially, 0 for not to.
// Return Values:   
//      LDIF_Error   -   Regular LDIF_Error struct.
//
STDAPI_(LDIF_Error)
LDIF_GenerateEntry(
    LDAP        *pLdap, 
    LDAPMessage *pMessage, 
    PWSTR       **ppReturn, 
    BOOLEAN     fSamLogic,
    BOOLEAN     fIgnoreBinary,
    PWSTR       **pppszAttrsWithRange,
    BOOL        fAttrsWithRange);

STDAPI_(LDIF_Error) LDIF_FreeStrs(PWSTR *rgpszStr);

typedef struct ldapmodW_Ext {
    ULONG     mod_op;
    PWCHAR    mod_type;
    union {
        PWCHAR  *modv_strvals;
        struct berval   **modv_bvals;
    } mod_vals;
    BOOLEAN    fString;
} LDAPModW_Ext, *PLDAPModW_Ext;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifde\main.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    main.cxx

ABSTRACT:

    The LDIF Bulk Import/Export Utility

DETAILS:
    
CREATED:

    08/10/97       Felix Wong (felixw)

REVISION HISTORY:

--*/

#include "ldifde.hxx"
#pragma hdrstop

#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#define UNICODE_MARK 0xFEFF

//
// Global variables (necessary for printouts)
//
FILE *g_pFileLog = NULL;            // Status log
FILE *g_pFileErrorLog = NULL;       // Error log              
BOOLEAN g_fDot = FALSE;             // Info for Status Tracker
BOOLEAN g_fError = FALSE;

BOOLEAN g_fVerbose = FALSE;         // SelectivePrint needs this info

PWSTR g_szErrorFilename = NULL;
PWSTR g_szDefaultFilter = L"(objectClass=*)";


PWSTR GetDCName(BOOLEAN fWritable);
BOOL GetPassword(PWSTR szBuffer, DWORD dwLength, DWORD *pdwLengthReturn);
#define     CR              0xD
#define     BACKSPACE       0x8
#define     NULLC           '\0'
#define     NEWLINE         '\n'


int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   );

int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   );


//+---------------------------------------------------------------------------
// Function: InitArgument    
//
// Synopsis: Initialization of Argument variables to default settings
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void InitArgument(ds_arg *pArg)
{
    pArg->dwPort = 389;
    pArg->szGenFile = NULL;    
    pArg->szFilename = NULL;
    pArg->szDSAName = NULL;
    pArg->szRootDN = NULL;
    pArg->szFilter = NULL;
    pArg->szFromDN = NULL;
    pArg->szToDN = NULL;
    pArg->attrList = NULL;
    pArg->omitList = NULL;
    pArg->dwScope = -1;
    pArg->creds.User = NULL;
    pArg->creds.Domain = NULL;
    pArg->creds.Password = NULL;
    pArg->fActive = TRUE;
    pArg->fSimple = FALSE;
    pArg->fExport = TRUE;
    pArg->fVerbose = FALSE; 
    pArg->fSAM = FALSE;
    pArg->fErrorExplain = TRUE;
    pArg->fPaged = TRUE;
    pArg->fSkipExist = FALSE;
    pArg->fBinary = TRUE;
    pArg->fSpanLine = FALSE;
    pArg->szLocation = NULL;
    pArg->fUnicode = FALSE;
    pArg->fLazyCommit = FALSE;
    pArg->dwLDAPConcurrent = 1;

}         


//+---------------------------------------------------------------------------
// Function: FreeArgument   
//
// Synopsis: Free argument variables   
//
// Arguments:  
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void FreeArgument(ds_arg *pArg)
{
    if (pArg->szFromDN) {
        MemFree(pArg->szFromDN);
    }
    if (pArg->szToDN) {
        MemFree(pArg->szToDN);
    }
    if (pArg->attrList) {
        MemFree(pArg->attrList);
    }
    if (pArg->omitList) {
        MemFree(pArg->omitList);
    }
}




//+---------------------------------------------------------------------------
// Function:  Main  
//
// Synopsis: Main Program Entry
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
extern "C" int __cdecl wmain(
    IN  int     argc,
    IN  PWSTR  argv[]
)
{
    
    DWORD hr = ERROR_SUCCESS;
    LDAP    *pLdap[MAX_LDAP_CONCURRENT];
    unsigned long err;
    ds_arg Argument;
    VOID *data;
    PWSTR szLogfileName = NULL;
    PWSTR szDSAName = NULL;
    PWSTR pszPassword = NULL;

    ULONG msgnum;
    
    InitArgument(&Argument);
    
    InitMem();

    // Initialize each connection
    for (int i=0; i<MAX_LDAP_CONCURRENT; i++) {
	    pLdap[i] = NULL;
    }

    hr = ProcessArgs(argc,
                     argv,
                     &Argument);
    DIREXG_BAIL_ON_FAILURE(hr);

    //
    // Setting up Logfile location
    //
    if (Argument.szLocation) {
        CStringW str;
        str.Init();
        str.Append(Argument.szLocation);
        str.Append(L"\\");
        str.Append(L"ldif.log");
        hr = str.GetCopy(&szLogfileName); 
        DIREXG_BAIL_ON_FAILURE(hr);

        str.Init();
        str.Append(Argument.szLocation);
        str.Append(L"\\");
        str.Append(L"ldif.err");
        hr = str.GetCopy(&g_szErrorFilename); 
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    else {
        szLogfileName = MemAllocStrW(L"ldif.log");
        if (!szLogfileName) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        g_szErrorFilename = MemAllocStrW(L"ldif.err");
        if (!g_szErrorFilename) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    if (g_fUnicode) {
        if ((g_pFileLog = _wfopen(szLogfileName , 
                                  L"wb")) == NULL) {
            hr = ERROR_OPEN_FAILED;
            SelectivePrintW(PRT_STD,
                           MSG_LDIFDE_UNABLEOPEN);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    
        if(fputwc(UNICODE_MARK,
                  g_pFileLog)==WEOF) {
            hr = ERROR_OPEN_FAILED;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    else {
        if ((g_pFileLog = _wfopen(szLogfileName, 
                                  L"wt")) == NULL) {
            hr = ERROR_OPEN_FAILED;
            SelectivePrintW(PRT_STD,
                           MSG_LDIFDE_UNABLEOPEN);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    //  Check whether the import file can be read
    //
    if (!Argument.fExport) {
    FILE* pFileIn = _wfopen(Argument.szFilename, L"rb");
        WCHAR wChar;
        BOOLEAN failed = FALSE;
        if (pFileIn == NULL || (wChar = fgetwc(pFileIn)) == WEOF)
            failed = TRUE;
        if (pFileIn)
            fclose(pFileIn);
        if (failed) {
            hr = ERROR_OPEN_FAILED;
            SelectivePrintW(PRT_STD, MSG_LDIFDE_IMPORTFILE_FAILED_READ,
                Argument.szFilename);
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // Required by SelectivePrint
    //
    g_fVerbose = Argument.fVerbose;

    if (Argument.szDSAName == NULL) {
        szDSAName = GetDCName(!Argument.fExport);
        if (szDSAName != NULL) {
            Argument.szDSAName = szDSAName;
        }
        else {
            SelectivePrintW(PRT_STD,
                           MSG_LDIFDE_NODCAVAILABLE);
            hr = ERROR_DS_SERVER_DOWN;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    //
    // If the user inputs '*', we'll get the password without 
    // echoing the output
    //
    
    if (Argument.creds.Password && 
        (wcscmp(Argument.creds.Password,L"*") == 0)) {
        WCHAR szBuffer[PWLEN+1];
        DWORD dwLength;

        SelectivePrintW(PRT_STD,
                        MSG_LDIFDE_GETPASSWORD,
                        Argument.szDSAName);

        if (GetPassword(szBuffer,PWLEN+1,&dwLength)) {
            pszPassword = MemAllocStrW_E(szBuffer);   
            Argument.creds.Password = pszPassword;
            Argument.creds.PasswordLength = dwLength;
        }
        else {
            SelectivePrintW(PRT_STD,
                            MSG_LDIFDE_PASSWORDTOLONG,
                            Argument.szDSAName);
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }

    //
    // CONNECTION section
    //
        
    SelectivePrintW(PRT_STD|PRT_LOG,
                   MSG_LDIFDE_CONNECT,
                   Argument.szDSAName);
  
    if (Argument.fExport){
	    Argument.dwLDAPConcurrent = 1;
    }

    for( i=0; i<(int)Argument.dwLDAPConcurrent; i++){
        //
        // start as many connections as needed
        //
        
        if ( (pLdap[i] = ldap_initW( Argument.szDSAName, 
                                     Argument.dwPort )) == NULL )  {
            hr = LdapToWinError(LdapGetLastError());
            if (i == 0) {
                //
                // Couldn't create any connections, so bail.
                //
                SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                        MSG_LDIFDE_CONNECT_FAIL,hr);
                
                Argument.dwLDAPConcurrent = 0;
    	        DIREXG_BAIL_ON_FAILURE(hr);
    	    }
            else {
                //
    	        // have at least one connection, so use them,
    	        // but first warn the user
    	        //
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_THREAD_FAILED_CONNECT,
                               i);    	        
    	        Argument.dwLDAPConcurrent = i;
    	        hr = ERROR_SUCCESS;
    	        break;
           }
        }
        else {
            if (err = ldap_connect(pLdap[i], g_pLdapTimeout) != LDAP_SUCCESS) {
                hr = LdapToWinError(err);
    	        if (i == 0) {
    	            //
    	            // Couldn't create any connections, so bail.
    	            //
                    SelectivePrintWithError(PRT_STD|PRT_LOG|PRT_ERROR,
                                            MSG_LDIFDE_CONNECT_FAIL,hr);
        	            
                    Argument.dwLDAPConcurrent = 0;
    	            DIREXG_BAIL_ON_FAILURE(hr);
    	        }
                else {
                    //
    	            // have at least one connection, so use what
    	            // we have, but first warn the user
    	            //
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_THREAD_FAILED_CONNECT,
                                   i);    	        
        	            
    	            ldap_unbind(pLdap[i]);  // free the connection we ldap_init'ed
    	            Argument.dwLDAPConcurrent = i;
    	            hr = ERROR_SUCCESS;
    	            break;
    	        }
            }
        }

        data = (VOID*)LDAP_OPT_OFF;
        ldap_set_option( pLdap[i], LDAP_OPT_REFERRALS, &data );
        data = (VOID*)LDAP_VERSION3 ;
        ldap_set_option( pLdap[i], LDAP_OPT_VERSION, &data );

        if (Argument.creds.User) {
            if (Argument.fSimple) {

                if (i == 0) {
                    // only show this status message once
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_SIMPLEBIND,
                                   Argument.creds.User);
                }
                
                msgnum = ldap_simple_bindW( pLdap[i], 
                                            Argument.creds.User, 
                                            Argument.creds.Password);

                err = LdapResult(pLdap[i], msgnum, NULL);
                                      
                if ( err != LDAP_SUCCESS ) {
                    if (err != LDAP_INVALID_CREDENTIALS) {
                        //
                        // If it is not invalid crednetials, we'll fall to version
                        // 2 and try again
                        //
                        data = (VOID*)LDAP_VERSION2 ;
                        ldap_set_option( pLdap[i], LDAP_OPT_VERSION, &data );
                        
                        msgnum =ldap_simple_bindW( pLdap[i], 
                                                   Argument.creds.User, 
                                                   Argument.creds.Password);

                        err = LdapResult(pLdap[i], msgnum, NULL);
                        
                        if ( err != LDAP_SUCCESS ) {
                            SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                           MSG_LDIFDE_SIMPLEBINDRETURN, 
                                           ldap_err2string(err) );
                            hr = LdapToWinError(err);
                            DIREXG_BAIL_ON_FAILURE(hr);
                        }
                    }
                    else {
                        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                       MSG_LDIFDE_SIMPLEBINDRETURN, 
                                       ldap_err2string(err) );
                        hr = LdapToWinError(err);
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
            } 
            else {
                if (i == 0) {
                    // only show this status message once
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                    MSG_LDIFDE_SSPI,
                                    Argument.creds.User,
                                    Argument.creds.Domain);
                }
                
                Argument.creds.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
                if ( (err=ldap_bind_sW( pLdap[i], 
                                       NULL, 
                                       (PWSTR)&(Argument.creds), 
                                       LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                    SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                                   MSG_LDIFDE_SSPIRETURN, 
                                   ldap_err2string(err) );
                    hr = LdapToWinError(err);
                    DIREXG_BAIL_ON_FAILURE(hr);
                }   
            } 
        }
        else {
            if (i == 0) {
                // only show this status message once
                SelectivePrintW(PRT_STD|PRT_LOG,
                               MSG_LDIFDE_SSPILOCAL);
            }
            
            if ( (err = ldap_bind_s( pLdap[i], 
                                     NULL, 
                                     NULL, 
                                     LDAP_AUTH_SSPI)) != LDAP_SUCCESS ) {
                SelectivePrintW( PRT_STD|PRT_LOG|PRT_ERROR,
                                MSG_LDIFDE_SSPILOCALRETURN, 
                                ldap_err2string(err) );
                hr = LdapToWinError(err);
                DIREXG_BAIL_ON_FAILURE(hr);
            }   
        }
    }   // end of connection creation loop
    
    //
    //  ACTION section
    //
    if (Argument.fExport) {
        hr = DSExport(pLdap[0], 
                      &Argument);
    } else {    
        hr = DSImport(pLdap, 
                      &Argument);
    }    
    
    //
    // Printing results
    //
    if (hr == ERROR_SUCCESS) {
        SelectivePrint2W(PRT_STD|PRT_LOG,
                         L"\n");
        SelectivePrintW(PRT_STD|PRT_LOG,
                       MSG_LDIFDE_COMPLETE);
    }
    else if (hr == ERROR_NOT_ENOUGH_MEMORY) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_MEMERROR);
    }
    else if (hr == ERROR_TIMEOUT) {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_TIMEOUT);
    }
    else {
        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                       MSG_LDIFDE_ERROROCCUR);
    }


error:  
    if (szDSAName) {
        MemFree(szDSAName);          
    }
    if (g_szErrorFilename) {
        MemFree(g_szErrorFilename);
    }
    if (szLogfileName) {
        MemFree(szLogfileName);
    }
    if (g_pFileLog) {
        fclose(g_pFileLog);
    }
    if (g_pFileErrorLog) {
        fclose(g_pFileErrorLog);
    }
    if (pszPassword) {
        MemFree(pszPassword);
        pszPassword = NULL;
    }

    if ((Argument.dwLDAPConcurrent == 1) && pLdap[0]) {
        ldap_unbind(pLdap[0]);
        pLdap[0] = NULL;
    }
    else {
        // do the rest of the unbinds
    	for (i=0; i<(int)Argument.dwLDAPConcurrent; i++) {
    	    ldap_unbind(pLdap[i]);
    	    pLdap[i] = NULL;
    	}
    }
    
    FreeArgument(&Argument);
    DumpMemoryTracker();
    return(hr);
}


//+---------------------------------------------------------------------------
// Function:  ProcessArgs  
//
// Synopsis:  Process the Argument list passed into Main()  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD 
ProcessArgs(
    int argc,
    PWSTR argv[],
    ds_arg* pArg   
    )
{
    int i;
    DWORD hr = ERROR_SUCCESS;
    BOOLEAN bCredentials = FALSE;
    BOOLEAN bLazyCommit = FALSE;
    BOOLEAN rgbUsed[26];
    WCHAR cKey;
    PWSTR s;
    DWORD dwMaxThread = 0;


    memset(rgbUsed,0,sizeof(BOOLEAN) * 26);

    if (argc == 1) {
        hr = ERROR_INVALID_PARAMETER;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    for (i=1; i < argc; i++) {

        if (((argv[i][0] != '-') && (argv[i][0] != '/')) || 
            (argv[i][1] && (argv[i][2] != NULL))) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARGUMENT, argv[i]);
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }

        cKey = argv[i][1];
        if ((cKey >= 'a') && (cKey <= 'z')) {
            cKey = towupper(argv[i][1]);
        }
        if ((cKey >= 'A') && (cKey <= 'Z')) {
            if (rgbUsed[cKey-'A']) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_ARGUMENTTWICE, argv[i]);
                hr = ERROR_INVALID_PARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            else {
                rgbUsed[cKey-'A'] = TRUE;
            }
        }
        else {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_UNKNOWN); 
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        
        switch (argv[i][1]) {

            case 'g':
            case 'G':
                pArg->fPaged = FALSE;
                break;

            case 'i':
            case 'I':
                pArg->fExport = FALSE;
                if (!bLazyCommit)
                    pArg->fLazyCommit = TRUE;
                break;
        
            case 't':
            case 'T':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_PORT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->dwPort = _wtoi(argv[i]);
                if (pArg->dwPort == 0) {
                    // If dwPort returns 0, we check whether it is really 0 or if it was
                    // a failure in atoi
                    if (wcscmp(argv[i],L"0") != 0) {
                        SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_PORT);
                        hr = ERROR_INVALID_PARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                }
                break;

            case 'w':
            case 'W':
                if ((++i >= argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                // Validate that specified value is entirely numeric.
                s=argv[i];
                while (*s) {
                    if (!iswdigit(*s)) {
                        SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                        hr = ERROR_INVALID_PARAMETER;
                        DIREXG_BAIL_ON_FAILURE(hr);
                    }
                    s++;
                }
                
                g_LdapTimeout.tv_sec = _wtoi(argv[i]);

                if (g_LdapTimeout.tv_sec <= 0) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_TIMEOUT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                g_pLdapTimeout = &g_LdapTimeout;
                break;


            case 'f':
            case 'F':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FILENAME);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szGenFile = argv[i];
                pArg->szFilename = argv[i];
                break;
            
            case 'j':
            case 'J':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_LOGFILE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szLocation = argv[i];
                break;

            case 's':
            case 'S':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SERVERNAME);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szDSAName = argv[i];
                break;

            case 'v':
            case 'V':
                pArg->fVerbose = TRUE;
                break;

            case '?':
                PrintUsage();       
                break;

            //
            // Export Parameters
            //

            case 'd':
            case 'D':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ROOTDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szRootDN = argv[i];
                break;

            case 'r':
            case 'R':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FILTER);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->szFilter = argv[i];
                break;

            case 'p':
            case 'P':
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
               
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_SCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!_wcsicmp(argv[i], L"Base" ))
                    pArg->dwScope = LDAP_SCOPE_BASE;
                else if (!_wcsicmp(argv[i], L"OneLevel" ))
                    pArg->dwScope = LDAP_SCOPE_ONELEVEL;
                else if (!_wcsicmp(argv[i], L"Subtree" ))
                    pArg->dwScope = LDAP_SCOPE_SUBTREE;
                else {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_BADSCOPE);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                break;
       
            case 'c':
            case 'C':
            {
                PWSTR pszTrimmedString, pszBuffer;
            
                if ((i+2) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                i++;
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpacesW(pszBuffer);
                pArg->szFromDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szFromDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);

                
                i++;
                if (!argv[i]) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_FROMDN);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszBuffer = MemAllocStrW(argv[i]);
                if (pszBuffer == NULL) {
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pszTrimmedString = RemoveWhiteSpacesW(pszBuffer);
                pArg->szToDN = MemAllocStrW(pszTrimmedString);
                if (pArg->szToDN == NULL) {
                    MemFree(pszBuffer);            
                    hr = ERROR_NOT_ENOUGH_MEMORY;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                MemFree(pszBuffer);
                
                break;
            }
            

            case 'l':
            case 'L':
            {
                PWSTR *rgszArgument = NULL;
                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);
                pArg->attrList = rgszArgument;
                break;
            }

            case 'o':
            case 'O':
            {
                PWSTR *rgszArgument = NULL;

                if (++i >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR2);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                if (!argv[i] || (*(argv[i]) == NULL)) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_ATTR2);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                hr = GetAllEntries(argv[i],
                                   &rgszArgument);
                DIREXG_BAIL_ON_FAILURE(hr);
                pArg->omitList = rgszArgument;
                break;
            }

            case 'm':
            case 'M':
                pArg->fSAM = TRUE;
                break;

            case 'n':
            case 'N':
                pArg->fBinary = FALSE;
                break;

            //
            // Import Parameters
            //
            
            case 'k':
            case 'K':
                pArg->fSkipExist = TRUE;
                break;

            //
            // Credentials Establishment
            //
                
            case 'a':
            case 'A':
                if (bCredentials) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPCRED);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+2) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQUSRPWD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;
                pArg->fSimple = TRUE; 
                
                i++;
                pArg->creds.User = argv[i];
                if (!pArg->creds.User) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = argv[i];
                if (!pArg->creds.Password) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;
            
            case 'u':
            case 'U':
                pArg->fUnicode = TRUE;
                g_fUnicode = TRUE;
                break;

            case 'b':
            case 'B':
                if (bCredentials) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPCRED);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if ((i+3) >= argc) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQUSRDOMPWD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                bCredentials = TRUE;

                i++;
                pArg->creds.User = argv[i];
                if (!pArg->creds.User) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.UserLength = wcslen(argv[i]);

                i++;
                pArg->creds.Domain = argv[i];
                if (!pArg->creds.Domain) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.DomainLength = wcslen(argv[i]);

                i++;
                pArg->creds.Password = argv[i];
                if (!pArg->creds.Password) {
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                pArg->creds.PasswordLength = wcslen(argv[i]);
                break;

            case 'y':
            case 'Y':
                if (bLazyCommit) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPLAZYCOMMIT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                pArg->fLazyCommit = TRUE;
                bLazyCommit = TRUE;
                break; 

            case 'e':
            case 'E':
                if (bLazyCommit) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_DUPLAZYCOMMIT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
            
                pArg->fLazyCommit = FALSE;
                bLazyCommit = TRUE;
                break;

            case 'q':
            case 'Q':
                if ((++i > argc) || (!argv[i])) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_PARAM_THREAD);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }
                
                dwMaxThread = _wtoi(argv[i]);
                if (((LONG)dwMaxThread) <= 0) {
                    SelectivePrintW( PRT_STD,MSG_LDIFDE_INVALID_THREAD_COUNT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);
                }

                if (dwMaxThread > MAX_LDAP_CONCURRENT) {
                    SelectivePrintW(PRT_STD, MSG_LDIFDE_TOO_MANY_THREADS, MAX_LDAP_CONCURRENT);
                    hr = ERROR_INVALID_PARAMETER;
                    DIREXG_BAIL_ON_FAILURE(hr);                    
                }
                pArg->dwLDAPConcurrent = dwMaxThread;
                break;
                
            default:
                SelectivePrintW( PRT_STD,MSG_LDIFDE_UNKNOWN);
                hr = ERROR_INVALID_PARAMETER;
                DIREXG_BAIL_ON_FAILURE(hr);
        } 
    } 
        
    // 
    // Checking Mandatory Options
    //
    if (hr == ERROR_SUCCESS) {
        if (!pArg->szFilename) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQFILE);
            hr = ERROR_INVALID_PARAMETER;
        }
        /*
        if (!pArg->szDSAName) {
            SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_REQSERVER);
            hr = ERROR_INVALID_PARAMETER;
        }
        */
        
        if (!pArg->fExport) {
            // Require for Import

            // Not Require
            if (pArg->szRootDN) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQROOTDN);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->szFilter) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQFILTER);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->dwScope != -1) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSCOPE);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fSAM) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSAM);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->omitList) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQOMIT);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->attrList) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQATTR);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (!pArg->fBinary) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQBINARY);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fSpanLine) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQSPAN);
                hr = ERROR_INVALID_PARAMETER;
            }
            if (pArg->fPaged == FALSE) { 
                SelectivePrintW(PRT_STD,
                               MSG_LDIFDE_BADARG_NREQPAGE);
                hr = ERROR_INVALID_PARAMETER;
            }
        }
        else {
            // Require for Export
            if (!pArg->szFilter) {
                pArg->szFilter = g_szDefaultFilter;
            }
            if (pArg->dwScope == -1) {
                pArg->dwScope = LDAP_SCOPE_SUBTREE;
            }

            // Not Require
            if (pArg->fSkipExist) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_SKIP);
                hr = ERROR_INVALID_PARAMETER;
            }

            if (pArg->fLazyCommit || bLazyCommit) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_LAZY_COMMIT);
                hr = ERROR_INVALID_PARAMETER;
            }

            if (pArg->dwLDAPConcurrent != 1) {
                SelectivePrintW( PRT_STD,MSG_LDIFDE_BADARG_NREQ_NUM_THREADS);
                hr = ERROR_INVALID_PARAMETER;
            }
        }
    }
error:  
    if (hr != ERROR_SUCCESS) {
        PrintUsage();
    }
    return (hr);
}


//***************************
//  UTILITIES SECTION
//***************************

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpaces  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
LPSTR
RemoveWhiteSpaces(
    LPSTR pszText)
{
    LPSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && isspace(*pszText))
        pszText++;

    for(pChar = pszText + strlen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!isspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}

//+---------------------------------------------------------------------------
// Function:  RemoveWhiteSpacesW  
//
// Synopsis:  Removes trailing and starting white spaces  
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
PWSTR
RemoveWhiteSpacesW(
    PWSTR pszText)
{
    PWSTR pChar;

    if(!pszText)
        return (pszText);

    while(*pszText && iswspace(*pszText))
        pszText++;

    for(pChar = pszText + wcslen(pszText) - 1; pChar >= pszText; pChar--) {
        if(!iswspace(*pChar))
            break;
        else
            *pChar = '\0';
    }
    return pszText;
}



//+---------------------------------------------------------------------------
// Function:  PrintUsage  
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void PrintUsage() {
    SelectivePrintW(PRT_STD,
                   MSG_LDIFDE_HELP);
}

#if 0
//+---------------------------------------------------------------------------
// Function:   SelectivePrint 
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    PSTR pszMessageBuffer = NULL;
    va_list ap;
    DWORD dwSize;

    va_start(ap, messageID);

    FormatMessageA(FORMAT_MESSAGE_FROM_HMODULE |FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                  NULL, 
                  messageID, 
                  0, 
                  (PSTR)&pszMessageBuffer, 
                  4095, 
                  &ap);

    if (!pszMessageBuffer) {
        goto error;
    }
    
    dwSize = strlen(pszMessageBuffer);
    if (g_fUnicode == FALSE) {
        if (pszMessageBuffer [dwSize-2] == '\r') {
            pszMessageBuffer [dwSize-2] = '\n';
            pszMessageBuffer [dwSize-1] = '\0';
        }
    }

    fflush(stdout);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        fprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        fprintf(stdout,pszMessageBuffer );
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        fprintf(stdout,pszMessageBuffer);
    }

    if (dwTarget & PRT_LOG) {
        fflush(g_pFileLog);    
        fprintf(g_pFileLog,pszMessageBuffer);
        fflush(g_pFileLog);
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if (g_fUnicode == FALSE) {
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wt")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                }
                else {
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wb")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                    if(fputwc(UNICODE_MARK,
                              g_pFileErrorLog)==WEOF) {
                        goto error;
                    }
                }
            }
        }
        fflush(g_pFileErrorLog);
        fprintf(g_pFileErrorLog,pszMessageBuffer);
        fflush(g_pFileErrorLog);
        
    }
error:
    fflush(stdout);

    va_end(ap);
    if (pszMessageBuffer) {
        LocalFree(pszMessageBuffer);
    }

    return;
}
#endif

//+---------------------------------------------------------------------------
// Function:   SelectivePrintW
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrintW(
    DWORD dwTarget, DWORD messageID, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    PWSTR pszMessageBuffer = NULL;
    DWORD dwSize;
    va_list ap;

    va_start(ap, messageID);

    FormatMessageW(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER, 
                   NULL, 
                   messageID, 
                   0, 
                   (PWSTR)&pszMessageBuffer, 
                   4095, 
                   &ap);

    if (!pszMessageBuffer) {
        goto error;
    }
    
    dwSize = wcslen(pszMessageBuffer);
    if (g_fUnicode == FALSE) {
        if (pszMessageBuffer[dwSize-2] == '\r') {
            pszMessageBuffer[dwSize-2] = '\n';
            pszMessageBuffer[dwSize-1] = '\0';
        }
    }

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_fwprintf(stdout,pszMessageBuffer);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_fwprintf(stdout,pszMessageBuffer);
    }

    if (dwTarget & PRT_LOG) {
        fwprintf(g_pFileLog,pszMessageBuffer);
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if (g_fUnicode == FALSE) {
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wt")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                }
                else {
                    if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                                   L"wb")) == NULL) {
                        SelectivePrintW(PRT_STD|PRT_LOG,
                                       MSG_LDIFDE_UNABLEOPENERR);
                        bTriedOpen = TRUE;
                        goto error;
                    }
                    if(fputwc(UNICODE_MARK,
                              g_pFileErrorLog)==WEOF) {
                        goto error;
                    }
                }
            }
            else {          // we have tried so proceed as an error
                goto error;
            }
        }
        fwprintf(g_pFileErrorLog,pszMessageBuffer);

    }
error:

    va_end(ap);
    if (pszMessageBuffer) {
        LocalFree(pszMessageBuffer);
    }
    
    return;
}

//+---------------------------------------------------------------------------
// Function:   SelectivePrint2W
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2W(
    DWORD dwTarget, PWSTR pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    
    va_start(args, pszfmt);

    if (g_fUnicode) {
        if (pszfmt && wcscmp(pszfmt,L"\n") == 0) {
            pszfmt = L"\r\n";
        }
    }


    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        My_vfwprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            wprintf(L"\n");
            g_fDot = FALSE;
        }
        My_vfwprintf(stdout,pszfmt,args);
    }

    if (dwTarget & PRT_LOG) {
        vfwprintf(g_pFileLog,pszfmt,args);
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                               L"wt")) == NULL) {
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_UNABLEOPENERR);
                    bTriedOpen = TRUE;
                    goto error;
                }
            }
            else {
                goto error;
            }
        }
        vfwprintf(g_pFileErrorLog,pszfmt,args);

    }
error:

    va_end(args);
    
    return;
}

#if 0

//+---------------------------------------------------------------------------
// Function:   SelectivePrint2
//
// Synopsis:   Depending on parameter, print string to different media
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void SelectivePrint2(
    DWORD dwTarget, char *pszfmt, ...)
{
    static BOOLEAN bTriedOpen = FALSE;
    va_list args;
    
    va_start(args, pszfmt);
        
    if (g_fUnicode) {
        if (pszfmt && strcmp(pszfmt,"\n") == 0) {
            pszfmt = "\r\n";
        }
    }

    fflush(stdout);

    if (dwTarget & PRT_STD) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        vfprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_VERBOSEONLY) && g_fVerbose) {
        vfprintf(stdout,pszfmt,args);
    }
    else if ((dwTarget & PRT_STD_NONVERBOSE) && !g_fVerbose) {
        if (g_fDot) {
            printf("\n");
            g_fDot = FALSE;
        }
        vfprintf(stdout,pszfmt,args);
    }

    if (dwTarget & PRT_LOG) {
        fflush(g_pFileLog);
        vfprintf(g_pFileLog,pszfmt,args);
        fflush(g_pFileLog);
        
    }
    if (dwTarget & PRT_ERROR) {
        if (!g_fError) {
            g_fError = TRUE;
        }
        if (!g_pFileErrorLog) {   // If log file is not opened
            if (!bTriedOpen) {          // If we haven't tried
                if ((g_pFileErrorLog = _wfopen(g_szErrorFilename, 
                                               L"wt")) == NULL) {
                    SelectivePrintW(PRT_STD|PRT_LOG,
                                   MSG_LDIFDE_UNABLEOPENERR);
                    bTriedOpen = TRUE;
                    goto error;
                }
            }
            else {
                goto error;
            }
        }
        fflush(g_pFileErrorLog);
        vfprintf(g_pFileErrorLog,pszfmt,args);
        fflush(g_pFileErrorLog);

    }
error:
    fflush(stdout);

    va_end(args);
    
    return;
}

#endif

#define UNIT    2           // This is the number of entries each dot represents
#define DOTS    20          // This is the number of dots before we roll back

//+---------------------------------------------------------------------------
// Function:   TrackStatus
//
// Synopsis:   Print a dot to indicate status, turn on g_fDot to indicate
//             that a dot has been printed. Any subsequent outputs require
//             a carriage return. (handled by SelectivePrint)
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
void TrackStatus()
{
/*
    //  
    // This static count keeps track of where we are
    //
    static DWORD dwCount = 0;

    if (!g_fVerbose) {
        if (dwCount == (DOTS*UNIT)) {
            DWORD i;
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",' ');
            }
            for (i=0;i<DOTS;i++) {
                printf("%c",BACKSPACE);
            }
            dwCount = 0;
        }
        //
        // Only if we reached UNIT we'll print out a dot now
        //
        if (dwCount % UNIT == 0)
            printf(".");
        dwCount++;
        g_fDot = TRUE;
    }
*/
    if (!g_fVerbose) {
        wprintf(L".");
    }
    g_fDot = TRUE;
}
//+---------------------------------------------------------------------------
// Function:   GetNextEntry 
//
// Synopsis:    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
BOOLEAN GetNextEntry(PWSTR szInput, 
                     PWSTR *pszEntry,
                     PWSTR *pszNext)
{
    PWSTR szFinal = szInput;
    
    while ((*szFinal != ',') && (*szFinal != '\0')) {
        if (*szFinal == '\\') {
            szFinal++;
            if (*szFinal == '\0') {
                return FALSE;
            }
        }
        szFinal++;
    }

    if (*szFinal == ',') {
        *szFinal = '\0';
        *pszEntry = RemoveWhiteSpacesW(szInput);
        *pszNext = szFinal+1;
        return (TRUE);
    }
    else {
        *pszEntry = RemoveWhiteSpacesW(szInput);
        *pszNext = NULL;
        return (TRUE);
    }
}



//+---------------------------------------------------------------------------
// Function:  GetAllEntries  
//
// Synopsis:  Get all the entries from a list of comma separated values
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD GetAllEntries(PWSTR szInput, 
                         PWSTR **ppszOutput)
{
    DWORD cNumberAttributes = 0;
    PWSTR *pszReturn = NULL;
    PWSTR szCurrent = NULL;
    PWSTR szEntry = NULL;
    PWSTR szNext = NULL;     
    DWORD hr = ERROR_SUCCESS;

    DWORD cNumberNeeded = 1;

    // Allocating array to store entries    
    szCurrent = szInput;
    while (*szCurrent != '\0') {
        if (*szCurrent == '\\') {
            if (*(szCurrent+1) == '\0') {
                hr = ERROR_GEN_FAILURE;
                DIREXG_BAIL_ON_FAILURE(hr);
            }
            szCurrent+=2;
            continue;
        }
        if (*szCurrent == ',') {
            cNumberNeeded++;
        }
        szCurrent++;
    }
    pszReturn = (PWSTR*)MemAlloc_E((cNumberNeeded+1)*sizeof(PWSTR));
    if (!pszReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    szCurrent = szInput;
    if (GetNextEntry(szCurrent,
                     &szEntry,
                     &szNext) == FALSE) {
        hr = ERROR_INVALID_PARAMETER;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    pszReturn[cNumberAttributes] = szEntry;
    cNumberAttributes++;

    while (szNext) {
        szCurrent = szNext;
        if (GetNextEntry(szCurrent,
                          &szEntry,
                          &szNext) == FALSE) {
            hr = ERROR_INVALID_PARAMETER;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        pszReturn[cNumberAttributes] = szEntry;
        cNumberAttributes++;
    }
    pszReturn[cNumberAttributes] = NULL;

    cNumberAttributes--;

    *ppszOutput = pszReturn;

error:
    return hr;
}


PWSTR GetDCName(BOOLEAN fWritable)
{
    DWORD dwError = 0;
    PDOMAIN_CONTROLLER_INFOW pDomainControllerInfo = NULL;
    PWSTR szDCName = NULL;

    if (fWritable) {
        //
        // Looking for a writable server
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_WRITABLE_REQUIRED,
                               &pDomainControllerInfo);
    }
    else {
        //
        // Looking for a GC first, if it fails, goto any DC
        //
        dwError = DsGetDcNameW(NULL, //ComputerName 
                               NULL, //DomainName 
                               NULL, //DomainGuid 
                               NULL, //SiteName 
                               DS_DIRECTORY_SERVICE_REQUIRED|DS_GC_SERVER_REQUIRED,
                               &pDomainControllerInfo);
        if (dwError != 0) {
            dwError = DsGetDcNameW(NULL, //ComputerName 
                                   NULL, //DomainName 
                                   NULL, //DomainGuid 
                                   NULL, //SiteName 
                                   DS_DIRECTORY_SERVICE_REQUIRED,
                                   &pDomainControllerInfo);
        }
    }

    if ((dwError == 0) && 
        pDomainControllerInfo && 
        (pDomainControllerInfo->DomainControllerName)) {
        szDCName = MemAllocStrW(pDomainControllerInfo->DomainControllerName+2);
    }
    if (pDomainControllerInfo) {
        NetApiBufferFree(pDomainControllerInfo);
    }
    return szDCName;
}

BOOL
GetPassword(
    PWSTR  szBuffer,
    DWORD  dwLength,
    DWORD  *pdwLengthReturn
    )
{
    WCHAR   ch;
    PWSTR   pszBufCur = szBuffer;
    DWORD   c;
    int     err;
    DWORD   mode;

    //
    // make space for NULL terminator
    //
    dwLength -= 1;                  
    *pdwLengthReturn = 0;               

    if (!GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), 
                        &mode)) {
        return FALSE;
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) {
        err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), 
                          &ch, 
                          1, 
                          &c, 
                          0);
        if (!err || c != 1)
            ch = 0xffff;
    
        if ((ch == CR) || (ch == 0xffff))    // end of line
            break;

        if (ch == BACKSPACE) {  // back up one or two 
            //
            // IF pszBufCur == buf then the next two lines are a no op.
            // Because the user has basically backspaced back to the start
            //
            if (pszBufCur != szBuffer) {
                pszBufCur--;
                (*pdwLengthReturn)--;
            }
        }
        else {

            *pszBufCur = ch;

            if (*pdwLengthReturn < dwLength) 
                pszBufCur++ ;                   // don't overflow buf 
            (*pdwLengthReturn)++;            // always increment pdwLengthReturn 
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);

    //
    // NULL terminate the string
    //
    *pszBufCur = NULLC;         
    putwchar(L'\n');

    return((*pdwLengthReturn <= dwLength) ? TRUE : FALSE);
}






 /***
 * My_fwprintf(stream, format) - print formatted data
 *
 * Prints Unicode formatted string to console window using WriteConsoleW.
 * Note: This My_fwprintf() is used to workaround the problem in c-runtime
 * which looks up LC_CTYPE even for Unicode string.
 *
 */

int __cdecl
My_fwprintf(
    FILE *str,
    const wchar_t *format,
    ...
   )

{
    DWORD  cchWChar;

    va_list args;
    va_start( args, format );

    cchWChar = My_vfwprintf(str, format, args);

    va_end(args);

    return cchWChar;
}


int __cdecl
My_vfwprintf(
    FILE *str,
    const wchar_t *format,
    va_list argptr
   )

{
    
    HANDLE hOut;
    DWORD currentMode;

    if (str == stderr) {
        hOut = GetStdHandle(STD_ERROR_HANDLE);
    }
    else {
        hOut = GetStdHandle(STD_OUTPUT_HANDLE);
    }

    DWORD  cchWChar;
    WCHAR  szBufferMessage[4096];
    vswprintf( szBufferMessage, format, argptr );
    cchWChar = wcslen(szBufferMessage);

    //  if it is console, we can use WriteConsoleW
    if (GetFileType(hOut) == FILE_TYPE_CHAR && GetConsoleMode(hOut, &currentMode)) {
        WriteConsoleW(hOut, szBufferMessage, cchWChar, &cchWChar, NULL);
    }
    //  otherwise, we need to convert Unicode to potential character sets
    //  and use WriteFile
    else {
        int charCount = WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, 0, 0, 0, 0);
        char* szaStr = new char[charCount];
        if (szaStr != NULL) {
            DWORD dwBytesWritten;
            WideCharToMultiByte(GetConsoleOutputCP(), 0, szBufferMessage, -1, szaStr, charCount, 0, 0);
            WriteFile(hOut, szaStr, charCount - 1, &dwBytesWritten, 0);
            delete[] szaStr;
        }
        else
            cchWChar = 0;
    }
    return cchWChar;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\base64.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    base64.h

ABSTRACT:

    The base64 funcionality for ldifldap.lib.

DETAILS:
    
    It follows the base64 encoding standard of RFC 1521.
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#ifndef _BASE_H
#define _BASE_H

PBYTE base64decode(PWSTR bufcoded, long * plDecodedSize);
PWSTR base64encode(PBYTE bufin, long nbytes);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifde\utils.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    util.cxx

Abstract:
    
    Utilities

Author:

    Felix Wong [FelixW]    06-Sep-1997
    
++*/

#include "ldifde.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
// Class:  CStringPlex
//
// Synopsis: A Class that encapsulates an array of zero terminated strings    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringPlex::CStringPlex()
{
    m_cszMax = 0;
    m_iszNext = 0;
    m_rgsz = NULL;
}

CStringPlex::~CStringPlex()
{
    Free();
}

DWORD CStringPlex::GetCopy(LPSTR **prgszReturn)
{
    LPSTR *rgszReturn = NULL;
    DWORD hr = ERROR_SUCCESS;
    DWORD i;

    if (m_iszNext == 0) {
        hr = ERROR_INVALID_FUNCTION;
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    rgszReturn = (LPSTR*)MemAlloc_E( m_iszNext * sizeof(LPSTR) );
    if (!rgszReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    memset(rgszReturn, 0, m_iszNext * sizeof(LPSTR) );

    for (i=0;i<m_iszNext;i++) {
        rgszReturn[i] = MemAllocStr_E(m_rgsz[i]); 
        if (!rgszReturn[i]) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
    }
    
    *prgszReturn = rgszReturn;
    return hr;

error:
    if (rgszReturn) {
        i = 0;
        while ((i<m_iszNext) && rgszReturn[i]) {
            MemFree(rgszReturn[i]);
            i++;
        }
        MemFree (rgszReturn);
    }
    return hr;
}

DWORD CStringPlex::NumElements()
{
    return m_iszNext;
}

LPSTR *CStringPlex::Plex()
{
    return m_rgsz;
}


DWORD CStringPlex::Init()
{
    DWORD hr = ERROR_SUCCESS;

    Free();

    m_rgsz = (LPSTR*)MemAlloc_E( STRINGPLEX_INC * sizeof(LPSTR) );
    if (!m_rgsz ) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_cszMax = STRINGPLEX_INC;
    m_iszNext = 0;
    memset(m_rgsz, 0, STRINGPLEX_INC * sizeof(LPSTR) );

error:
    return hr;
}

DWORD CStringPlex::AddElement(LPSTR szValue)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR *rgszT = NULL;

    if (!szValue) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If next index is larger than largest index
    //
    if (m_iszNext > (m_cszMax-1)) {
        rgszT = (LPSTR*)MemRealloc_E(m_rgsz , 
                                (m_cszMax + STRINGPLEX_INC)*sizeof(LPSTR));
        if (!rgszT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_rgsz = rgszT;
        m_cszMax+=STRINGPLEX_INC;
    }

    m_rgsz [m_iszNext] = MemAllocStr_E(szValue);
    if (!m_rgsz [m_iszNext]) {
         hr = ERROR_NOT_ENOUGH_MEMORY;
         DIREXG_BAIL_ON_FAILURE(hr);
    }
    m_iszNext++;
error:
    return hr;
}

void CStringPlex::Free()
{
    DWORD isz = 0;

    if (m_rgsz) {
        for (isz=0;isz<m_iszNext;isz++) {
            if (m_rgsz[isz]) {
                MemFree(m_rgsz[isz]);
            }
        }
        MemFree (m_rgsz);
        m_rgsz = NULL;
    }
    m_cszMax = 0;
    m_iszNext = 0;
}

//+---------------------------------------------------------------------------
// Class:  CString
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CString::CString()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CString::~CString()
{
    Free();
}

DWORD CString::Init()
{
    Free();
    m_sz = (LPSTR)MemAlloc_E(STRING_INC * sizeof(char));
    if (!m_sz) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return ERROR_SUCCESS;
}

DWORD CString::GetCopy(LPSTR *pszReturn)
{
    LPSTR szReturn = NULL;
    szReturn = MemAllocStr_E(m_sz);
    if (!szReturn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    *pszReturn = szReturn;
    return ERROR_SUCCESS;
}

LPSTR CString::String()
{
    return m_sz;
}


DWORD CString::Append(LPSTR szAppend)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = strlen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (LPSTR)MemRealloc_E(m_sz, sizeof(char) * cchResult);
        if (!szT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    strcat(m_sz, szAppend);

error:
    return hr;
}

DWORD CString::Backup()
{
    DWORD hr = ERROR_GEN_FAILURE;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = ERROR_SUCCESS;
    }
    return hr;
}

void CString::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}

//+---------------------------------------------------------------------------
// Class:  CStringW
//
// Synopsis: A class that encapsulates a variable size string    
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
CStringW::CStringW()
{
    m_sz = NULL;
    m_ichNext = 0;
    m_cchMax = 0;
}

CStringW::~CStringW()
{
    Free();
}

DWORD CStringW::Init()
{
    Free();
    m_sz = (PWSTR)MemAlloc_E(STRING_INC * sizeof(WCHAR));
    if (!m_sz) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    m_cchMax = STRING_INC;
    m_ichNext = 0;
    m_sz[0] = '\0';
    return ERROR_SUCCESS;
}

DWORD CStringW::GetCopy(PWSTR *pszReturn)
{
    PWSTR szReturn = NULL;
    szReturn = (PWSTR)MemAlloc_E((wcslen(m_sz) + 1) * sizeof(WCHAR));
    if (!szReturn) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    memcpy(szReturn,m_sz,(wcslen(m_sz) + 1) * sizeof(WCHAR));
    *pszReturn = szReturn;
    return ERROR_SUCCESS;
}

PWSTR CStringW::String()
{
    return m_sz;
}


DWORD CStringW::Append(PWSTR szAppend)
{
    DWORD hr = ERROR_SUCCESS;
    PWSTR szT;
    DWORD cchResult;
    DWORD cchAppend;
    
    cchAppend = wcslen(szAppend);
    if ((cchAppend + m_ichNext) > (m_cchMax - 1)) {
        //
        // If normal addition of memory is not enough
        //
        if ((cchAppend + m_ichNext) > (m_cchMax + STRING_INC - 1)) {
            cchResult = m_cchMax + STRING_INC + cchAppend;
        }
        else {
            cchResult = m_cchMax + STRING_INC;
        }
        szT = (PWSTR)MemRealloc_E(m_sz, sizeof(WCHAR) * cchResult);
        if (!szT) {
            hr = ERROR_NOT_ENOUGH_MEMORY;
            DIREXG_BAIL_ON_FAILURE(hr);
        }
        m_sz = szT;
        m_cchMax = cchResult;
    }
    m_ichNext += cchAppend;
    wcscat(m_sz, szAppend);

error:
    return hr;
}

DWORD CStringW::Backup()
{
    DWORD hr = ERROR_GEN_FAILURE;

    if (m_sz && (m_ichNext > 0)) {
        m_sz[m_ichNext-1] = '\0';
        m_ichNext--;
        hr = ERROR_SUCCESS;
    }
    return hr;
}

void CStringW::Free()
{
    if (m_sz) {
        MemFree(m_sz);
        m_sz = NULL;
    }
    m_ichNext = 0;
    m_cchMax = 0;
}



//+---------------------------------------------------------------------------
// Function:  SubString
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            ERROR_SUCCESS with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubString(LPSTR szInput,
                  LPSTR szFrom,
                  LPSTR szTo,
                  LPSTR *pszOutput)
{
    DWORD hr = ERROR_SUCCESS;
    LPSTR szOutput = NULL;
    LPSTR szLast = NULL;
    LPSTR szReturn = NULL;
    DWORD cchToCopy = 0;            // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    cchFrom    = strlen(szFrom);
    cchTo      = strlen(szTo);
    cchInput   = strlen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = strstr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return ERROR_SUCCESS;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = strstr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (LPSTR)MemAlloc_E(sizeof(char) * cchReturn);
    if (!szReturn) {
        hr = ERROR_NOT_ENOUGH_MEMORY;
        DIREXG_BAIL_ON_FAILURE(hr);
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = strstr(szInput,
                      szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    strncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    strcat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = strstr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        strncat(szReturn,
                szInput,
                cchToCopy);
        strcat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = strstr(szInput,
                          szFrom);
    }

    strcat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:  GetLine
//
// Synopsis:  will return the new line in the allocated buffer, must be MemFreed
//            by user
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD GetLine(FILE* pFileIn,
                LPSTR *pszLine)
{
    CString String;
    DWORD hr = ERROR_SUCCESS;
    char szValue[256];

    hr = String.Init();
    DIREXG_BAIL_ON_FAILURE(hr);
    
    //
    // First Buffer
    //
    if(fgets(szValue,
             256,
             pFileIn) == NULL) {
        //
        // The new line does not exist, will still return ERROR_SUCCESS 
        // with szLine == NULL
        //
        *pszLine = NULL;
        goto error;
    };

    hr = String.Append(szValue);
    DIREXG_BAIL_ON_FAILURE(hr);

    // 
    // Subsequent buffers
    //
    while ((strlen(szValue) == 255) && szValue[254] != '\n') {
        if(fgets(szValue,
                 256,
                 pFileIn) == NULL) {
            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
        };
        hr = String.Append(szValue);
        DIREXG_BAIL_ON_FAILURE(hr);
    }

    //
    // Removing \n
    // fgets always return '\n' as last character
    //
    hr = String.Backup();
    DIREXG_BAIL_ON_FAILURE(hr);

    hr = String.GetCopy(pszLine);
    DIREXG_BAIL_ON_FAILURE(hr);

error:
    return (hr);
}

//+---------------------------------------------------------------------------
// Function:   AppendFile 
//
// Synopsis:   Append fileAppend to fileTarget
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    25-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD AppendFile(HANDLE hFileAppend,
                   HANDLE hFileTarget)
{
    DWORD hr = ERROR_SUCCESS;
    char szBuffer[100];
    DWORD cchRead = 0;
    DWORD cchWrite = 0;
    BOOL bResult;

    bResult = ReadFile(hFileAppend,
                       (LPVOID)szBuffer,
                       100,
                       &cchRead,
                       NULL);
    while (bResult && cchRead != 0) {
         if (WriteFile(hFileTarget,
                       (LPCVOID)szBuffer,
                       cchRead,
                       &cchWrite,
                       NULL) == FALSE) {
            hr = ERROR_GEN_FAILURE;
            DIREXG_BAIL_ON_FAILURE(hr);
         }
         bResult = ReadFile(hFileAppend,
                            (LPVOID)szBuffer,
                            100,
                            &cchRead,
                            NULL);
    }
    
    if (!bResult) {
        hr = GetLastError();
    }

error:
    return hr;
}

//+---------------------------------------------------------------------------
// Function:  PrintError  
//
// Synopsis:  Print the error returned from the LDIF engine plus convert it
//            to a win32 error code.
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    10-8-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD PrintError(DWORD dwType, DWORD error) 
{
    DWORD WinError = ERROR_GEN_FAILURE;

    switch(error) {
        case STATUS_ACCESS_VIOLATION:
            SelectivePrintW(dwType,MSG_LDIFDE_EXCEPTION);
            break;
        case LL_MEMORY_ERROR: 
            WinError = ERROR_OUTOFMEMORY;
            SelectivePrintW(dwType,MSG_LDIFDE_MEMERROR);
            break;
        case LL_INIT_REENTER: 
            SelectivePrintW(dwType,MSG_LDIFDE_INITAGAIN);
            break;
        case LL_FILE_ERROR:   
            WinError = ERROR_OPEN_FAILED;
            SelectivePrintW(dwType,MSG_LDIFDE_FILEOPERFAIL);
            break;
        case LL_INIT_NOT_CALLED:   
            SelectivePrintW(dwType,MSG_LDIFDE_INITNOTCALLED);
            break;
        case LL_EOF:          
            SelectivePrintW(dwType,MSG_LDIFDE_ENDOFINPUT);
            break;
        case LL_SYNTAX:       
            SelectivePrintW(dwType,MSG_LDIFDE_SYNTAXERR);
            break;
        case LL_URL:          
            SelectivePrintW(dwType,MSG_LDIFDE_URLERROR);
            break;
        case LL_EXTRA:        
            SelectivePrintW(dwType,MSG_LDIFDE_EXTSPECLIST);
            break;
        case LL_LDAP:         
            SelectivePrintW(dwType,MSG_LDIFDE_LDAPFAILED);
            break;
        case LL_MULTI_TYPE:   
            SelectivePrintW(dwType,MSG_LDIFDE_BOTHSTRBERVAL);  
            break;
        case LL_INTERNAL:
        case LL_INTERNAL_PARSER:
            SelectivePrintW(dwType,MSG_LDIFDE_INTERNALERROR);  
            break;
        case LL_INITFAIL:     
            SelectivePrintW(dwType,MSG_LDIFDE_FAILEDINIT);  
            break;
        case LL_DUPLICATE:    
            SelectivePrintW(dwType,MSG_LDIFDE_MULTIINST);  
            break;
        default:
            SelectivePrintW(dwType,MSG_LDIFDE_UNDEFINED);  
            break;
    }
    return WinError;
}

//+---------------------------------------------------------------------------
// Function:  OutputExtendedErrorByConnection
//
// Synopsis:  This function is called right after an error occurs. Using the
//            pLdap pointer, it will call ldap to retrieve the win32 error
//            code, get the error msg string and output it.
//
//----------------------------------------------------------------------------
void OutputExtendedErrorByConnection(LDAP *pLdap) 
{
    DWORD dwWinError = 0;

    if (GetLdapExtendedError(pLdap, &dwWinError)) {
        OutputExtendedErrorByCode(dwWinError);
    }
}


//+---------------------------------------------------------------------------
// Function:  GetLdapExtendedError
//
// Synopsis:  This function is called right after an error occurs. Using the
//            pLdap pointer, it will call ldap to retrieve the win32 error
//            code.
//
//----------------------------------------------------------------------------
BOOL GetLdapExtendedError(LDAP *pLdap, DWORD *pdwWinError) 
{
    DWORD dwWinError = 0;
    
    if (ldap_get_optionW( pLdap, LDAP_OPT_SERVER_EXT_ERROR, &dwWinError) == LDAP_SUCCESS) {
        *pdwWinError = dwWinError;
        return TRUE;
    }
    else {
        return FALSE;
    }
    
}


//+---------------------------------------------------------------------------
// Function:  OutputExtendedErrorByCode
//
// Synopsis:  Given a  win32 error code, get the error msg string
//            and output it.
//
//----------------------------------------------------------------------------
void OutputExtendedErrorByCode(DWORD dwWinError) 
{
    DWORD dwError;
    DWORD dwLen;
    WCHAR szMsg[MAX_PATH];

    if (dwWinError) {
        dwLen = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              dwWinError,
                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                              szMsg,
                              MAX_PATH,
                              NULL);
        if (dwLen == 0) {
            _itow(dwWinError, szMsg, 10);
        }
        else {
            //
            // If we get a message, we'll remove all the linefeeds in it
            // and replace it with a space, except the last one.
            // FormatMessage always end with a single \r\n, in that case
            // we'll just copy the rest of the string over, which is a
            // null terminator.
            //
            PWSTR pszNew = szMsg;
            while (pszNew && (pszNew = wcsstr(pszNew,L"\r\n"))) {
                if ((*(pszNew+2))) {
                    wcscpy(pszNew, L" ");                                           
                    wcscpy(pszNew+1, (pszNew + 2));
                }
                else {
                    *pszNew = NULL;
                }
            }
        }

        SelectivePrintW(PRT_STD|PRT_LOG|PRT_ERROR,
                        MSG_LDIFDE_EXTENDERROR, 
                        szMsg);
    }
}


DWORD
LdapToWinError(
    int     ldaperr
    )
{
    DWORD dwStatus = NO_ERROR;
    DWORD dwErr = NO_ERROR;

    // first set the dwErr, then we can see if we can get
    // more information from ldap_parse_resultW
    switch (ldaperr) {

    case LDAP_SUCCESS :
        dwErr = NO_ERROR;
        break;

    case LDAP_OPERATIONS_ERROR :
        dwErr =  ERROR_DS_OPERATIONS_ERROR;
        break;

    case LDAP_PROTOCOL_ERROR :
        dwErr =  ERROR_DS_PROTOCOL_ERROR;
        break;

    case LDAP_TIMELIMIT_EXCEEDED :
        dwErr = ERROR_DS_TIMELIMIT_EXCEEDED;
        break;

    case LDAP_SIZELIMIT_EXCEEDED :
        dwErr = ERROR_DS_SIZELIMIT_EXCEEDED;
        break;

    case LDAP_COMPARE_FALSE :
        dwErr = ERROR_DS_COMPARE_FALSE;
        break;

    case LDAP_COMPARE_TRUE :
        dwErr = ERROR_DS_COMPARE_TRUE;
        break;

    case LDAP_AUTH_METHOD_NOT_SUPPORTED :
        dwErr = ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
        break;

    case LDAP_STRONG_AUTH_REQUIRED :
        dwErr =  ERROR_DS_STRONG_AUTH_REQUIRED;
        break;

    // LDAP_REFERRAL_V2 has same value as LDAP_PARTIAL_RESULTS
    case LDAP_PARTIAL_RESULTS :
        dwErr = ERROR_MORE_DATA;
        break ;

    case LDAP_REFERRAL :
        dwErr =  ERROR_DS_REFERRAL;
        break;

    case LDAP_ADMIN_LIMIT_EXCEEDED :
        dwErr   = ERROR_DS_ADMIN_LIMIT_EXCEEDED;
        break;

    case LDAP_UNAVAILABLE_CRIT_EXTENSION :
        dwErr = ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
        break;

    case LDAP_CONFIDENTIALITY_REQUIRED :
        dwErr = ERROR_DS_CONFIDENTIALITY_REQUIRED;
        break;

    case LDAP_NO_SUCH_ATTRIBUTE :
        dwErr = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        break;

    case LDAP_UNDEFINED_TYPE :
        dwErr = ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
        break;

    case LDAP_INAPPROPRIATE_MATCHING :
        dwErr = ERROR_DS_INAPPROPRIATE_MATCHING;
        break;

    case LDAP_CONSTRAINT_VIOLATION :
        dwErr = ERROR_DS_CONSTRAINT_VIOLATION;
        break;

    case LDAP_ATTRIBUTE_OR_VALUE_EXISTS :
        dwErr = ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
        break;

    case LDAP_INVALID_SYNTAX :
        dwErr = ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
        break;

    case LDAP_NO_SUCH_OBJECT :
        dwErr = ERROR_DS_NO_SUCH_OBJECT;
        break;

    case LDAP_ALIAS_PROBLEM :
        dwErr = ERROR_DS_ALIAS_PROBLEM;
        break;

    case LDAP_INVALID_DN_SYNTAX :
        dwErr = ERROR_DS_INVALID_DN_SYNTAX;
        break;

    case LDAP_IS_LEAF :
        dwErr = ERROR_DS_IS_LEAF;
        break;

    case LDAP_ALIAS_DEREF_PROBLEM :
        dwErr = ERROR_DS_ALIAS_DEREF_PROBLEM;
        break;

    case LDAP_INAPPROPRIATE_AUTH :
        dwErr = ERROR_DS_INAPPROPRIATE_AUTH;
        break;

    case LDAP_INVALID_CREDENTIALS :
        dwErr = ERROR_LOGON_FAILURE;
        break;

    case LDAP_INSUFFICIENT_RIGHTS :
        dwErr = ERROR_ACCESS_DENIED;
        break;

    case LDAP_BUSY :
        dwErr = ERROR_DS_BUSY;
        break;

    case LDAP_UNAVAILABLE :
        dwErr = ERROR_DS_UNAVAILABLE;
        break;

    case LDAP_UNWILLING_TO_PERFORM :
        dwErr = ERROR_DS_UNWILLING_TO_PERFORM;
        break;

    case LDAP_LOOP_DETECT :
        dwErr = ERROR_DS_LOOP_DETECT;
        break;

    case LDAP_NAMING_VIOLATION :
        dwErr = ERROR_DS_NAMING_VIOLATION;
        break;

    case LDAP_OBJECT_CLASS_VIOLATION :
        dwErr = ERROR_DS_OBJ_CLASS_VIOLATION;
        break;

    case LDAP_NOT_ALLOWED_ON_NONLEAF :
        dwErr = ERROR_DS_CANT_ON_NON_LEAF;
        break;

    case LDAP_NOT_ALLOWED_ON_RDN :
        dwErr = ERROR_DS_CANT_ON_RDN;
        break;

    case LDAP_ALREADY_EXISTS :
        dwErr = ERROR_OBJECT_ALREADY_EXISTS;
        break;

    case LDAP_NO_OBJECT_CLASS_MODS :
        dwErr = ERROR_DS_CANT_MOD_OBJ_CLASS;
        break;

    case LDAP_RESULTS_TOO_LARGE :
        dwErr = ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
        break;

    case LDAP_AFFECTS_MULTIPLE_DSAS :
        dwErr = ERROR_DS_AFFECTS_MULTIPLE_DSAS;
        break;

    case LDAP_OTHER :
        dwErr = ERROR_GEN_FAILURE;
        break;

    case LDAP_SERVER_DOWN :
        dwErr = ERROR_DS_SERVER_DOWN;
        break;

    case LDAP_LOCAL_ERROR :
        dwErr = ERROR_DS_LOCAL_ERROR;
        break;

    case LDAP_ENCODING_ERROR :
        dwErr = ERROR_DS_ENCODING_ERROR;
        break;

    case LDAP_DECODING_ERROR :
        dwErr = ERROR_DS_DECODING_ERROR;
        break;

    case LDAP_TIMEOUT :
        dwErr = ERROR_TIMEOUT;
        break;

    case LDAP_AUTH_UNKNOWN :
        dwErr = ERROR_DS_AUTH_UNKNOWN;
        break;

    case LDAP_FILTER_ERROR :
        dwErr = ERROR_DS_FILTER_UNKNOWN;
        break;

    case LDAP_USER_CANCELLED :
       dwErr = ERROR_CANCELLED;
       break;

    case LDAP_PARAM_ERROR :
        dwErr = ERROR_DS_PARAM_ERROR;
        break;

    case LDAP_NO_MEMORY :
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case LDAP_CONNECT_ERROR :
        dwErr = ERROR_CONNECTION_REFUSED;
        break;

    case LDAP_NOT_SUPPORTED :
        dwErr = ERROR_DS_NOT_SUPPORTED;
        break;

    case LDAP_NO_RESULTS_RETURNED :
        dwErr = ERROR_DS_NO_RESULTS_RETURNED;
        break;

    case LDAP_CONTROL_NOT_FOUND :
        dwErr = ERROR_DS_CONTROL_NOT_FOUND;
        break;

    case LDAP_MORE_RESULTS_TO_RETURN :
        dwErr = ERROR_MORE_DATA;
        break;

    case LDAP_CLIENT_LOOP :
        dwErr = ERROR_DS_CLIENT_LOOP;
        break;

    case LDAP_REFERRAL_LIMIT_EXCEEDED :
        dwErr = ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
        break;

    default:
        //
        // It may not be a bad idea to add range checking here
        //
        dwErr = (DWORD) LdapMapErrorToWin32(ldaperr);

    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\incpch.c ===
#include <ldifds.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\globals.c ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.c

Abstract:

    This file contains global variables

Environment:

    User mode

Revision History:

    04/30/98 -felixw-
        Created it

--*/
#include <precomp.h>
#include "ntldap.h"

//
// Variables for status information
//
int Mode        = C_NORMAL; // The current lexing mode
WCHAR cLast;                 // Last Character before error occurred
BOOL fEOF       = FALSE;    // Whether the end of file has been reached
BOOL fNewLine   = TRUE;     // Used to tell whether we are just after a NewLine.
                            // It is used only in the CLEAR mode.
PWSTR g_pszLastToken = NULL;


//
// Variables for the line-counting
//
long LineClear       = 0;          // for initial line counting
long Line            = 0;          // for while-processing countint
long LineGhosts      = 0;
long *rgLineMap      = NULL;
long cLineMax;

int FileType;       // making sure that the input file is just either LDIF-recs 
                    // or LDIF-c-recs

int RuleLast;       // The last lower level rule parsed successfully
int TokenExpect;    // The token the grammar expects to see next               
int RuleLastBig;    // The last rule the grammar parsed successfully codes 
int RuleExpect;     // The rule the grammar expects to see next

//
// An a ldif-record (or only the DN for a changes list will be recorded here)
//
LDIF_Object g_pObject;
WCHAR       g_szTempUrlfilename[MAX_PATH] = L"";
FILE        *g_pFileUrlTemp          =  NULL;
BOOLEAN     g_fUnicode               = FALSE;   // whether we are using UNICODE or not

DWORD g_dwBeginLine = 0;

// Search control for lazy commit
LDAPControlW g_wLazyCommitControl = { LDAP_SERVER_LAZY_COMMIT_OID_W,
                                      {0, NULL},
                                      FALSE 
                                    };

PLDAPControlW g_ppwLazyCommitControl[] = { &g_wLazyCommitControl, NULL };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\globals.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This file contains global variables extern declarations

Environment:

    User mode

Revision History:

    04/30/99 -felixw-
        Created it

--*/
#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//
// Global variables
//

//
// Variables for status information
//
extern int Mode;                    // The current lexing mode
extern WCHAR cLast;                  // Last Character before error occurred
extern BOOL fEOF;                   // Whether the end of file has been reached
extern BOOL fNewLine;               // Used to tell whether we are just after a NewLine.
                                    // It is used only in the CLEAR mode.

//
// Variables for the line-counting
//
extern long LineClear;              // for initial rgLineMap
extern long Line;                   // for while-processing countint
extern long LineGhosts;
extern long *rgLineMap;
extern long cLineMax;

extern int FileType; // making sure that the input file is just either 
                     // LDIF-recs or LDIF-c-recs

//
// Information for the user on error
//
extern int RuleLast;       // The last lower level rule parsed successfully
extern int TokenExpect;    // The token the grammar expects to see next               
extern int RuleLastBig;    // The last rule the grammar parsed successfully codes 
extern int RuleExpect;     // The rule the grammar expects to see next

//
// An a ldif-record (or only the DN for a changes list will be recorded here)
//
extern LDIF_Object  g_pObject;
extern WCHAR        g_szTempUrlfilename[MAX_PATH];
extern FILE         *g_pFileUrlTemp;
extern PWSTR g_pszLastToken;

extern DWORD g_dwBeginLine;

extern LDAPControlW g_wLazyCommitControl;
extern PLDAPControlW g_ppwLazyCommitControl[];

#endif  // ifndef _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\ldifutil.h ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldifutil.h

ABSTRACT:

     Utilities for LDIF library

REVISION HISTORY:

--*/
#ifndef _LDIFUTIL_H
#define _LDIFUTIL_H

#define HIGER_6_BIT(u)    ((u) >> 12)
#define MIDDLE_6_BIT(u)   (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)    ((u) & 0x003f)

#define BIT7(a)           ((a) & 0x80)
#define BIT6(a)           ((a) & 0x40)

RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct );
RTL_GENERIC_COMPARE_RESULTS
NtiCompW( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct );
PVOID NtiAlloc( RTL_GENERIC_TABLE *Table, CLONG ByteSize );
VOID NtiFree ( RTL_GENERIC_TABLE *Table, PVOID Buffer );

/*
DWORD SubStr(LPSTR szInput,
             LPSTR szFrom,
             LPSTR szTo,
             LPSTR *pszOutput);
*/

DWORD SubStrW(PWSTR szInput,
              PWSTR szFrom,
              PWSTR szTo,
              PWSTR *pszOutput);

wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        );

void
ConvertUnicodeToUTF8(
    PWSTR pszUnicode,
    DWORD dwLen,
    PBYTE *ppbValue,
    DWORD *pdwLen
    );

void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    );

BOOLEAN IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc);

ULONG LDAPAPI ldif_ldap_add_sW(
    LDAP *ld,
    PWCHAR dn,
    LDAPModW *attrs[],
    BOOL fLazyCommit
    );

ULONG LDAPAPI ldif_ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn,
    BOOL fLazyCommit
    );

ULONG LDAPAPI ldif_ldap_modify_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    BOOL fLazyCommit
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\ldifldap.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifldap.c

Abstract:

    This file implements the support code for the ldif parser

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

    05/12/99 -felixw-
        Rewrite + unicode support

--*/
#include <precomp.h>
#include "samrestrict.h"
#include "ntldap.h"

//
// Global to/from strings
//
PWSTR g_szImportTo = NULL;
PWSTR g_szImportFrom = NULL;
PWSTR g_szExportTo = NULL;
PWSTR g_szExportFrom = NULL;

PWSTR g_szFileFlagR = NULL;         // Flag for reading files

PWSTR g_szPrimaryGroup = L"primaryGroupID";
PSTR  g_szDefaultGroup = "513";

PWSTR g_rgszOmit[] = { L"replPropertyMetaData",
                       NULL };

PWSTR g_rgszAttrList[] = { L"ldapDisplayName",
                           L"linkid",
                           NULL };

PWSTR g_rgszSchemaList[] = { L"schemaNamingContext",
                             L"defaultNamingContext",
                             L"supportedControl",
                             NULL };

PWSTR g_rgszControlsList[] = { L"supportedControl",
                               NULL };


struct change_list *g_pChangeCur = NULL;
struct change_list *g_pChangeStart = NULL;

//
// Used to build up the list of attribute value specs
//
struct l_list   *g_pListStart     = NULL;
struct l_list   *g_pListCur       = NULL;
DWORD           g_dwListElem      = 0;

//
// Various variables for file manipulations
//
FILE        *g_pFileIn                    = NULL;

ULONG               g_nBacklinkCount     = 0;
int                 g_nClassLast         = LOC_NOTSET;
PRTL_GENERIC_TABLE  g_pOmitTable         = NULL;
HASHCACHESTRING     *g_pBacklinkHashTable = NULL;


LDIF_Error 
LDIF_InitializeImport(
    LDAP *pLdap,
    PWSTR szFilename, 
    PWSTR szFrom, 
    PWSTR szTo,
    BOOL *pfLazyCommitAvail) 
{
    WCHAR       szTempPathname[MAX_PATH]    = L"";
    LDIF_Error    error;

    BOOL fLazyCommitAvail = FALSE;
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;
    PWSTR *rgszVal = NULL;
    PWSTR szAttribute = NULL;
    ULONG LdapError;
    ULONG msgnum;


    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    //
    // Setting up global replacement strings
    //
    g_szImportFrom = szFrom;
    g_szImportTo = szTo;

    __try {


        //
        // Test lazy commit availability.
        //

        if (pfLazyCommitAvail) {
            
            msgnum = ldap_searchW(pLdap,
                                  NULL,
                                  LDAP_SCOPE_BASE,
                                  L"(objectClass=*)",
                                  g_rgszControlsList,
                                  0);

            LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
        
            if ( LdapError != LDAP_SUCCESS ) {
                //
                // RootDSE search fails
                // pfLazyCommitAvail will be FALSE as well
                //
                fLazyCommitAvail = FALSE;
            }
            else {

                for ( pMessage = ldap_first_entry( pLdap,
                                                   pSearchMessage );
                      pMessage != NULL;
                      pMessage = ldap_next_entry( pLdap,
                                                     pMessage ) ) {
                    for (   szAttribute = ldap_first_attributeW( pLdap, pMessage, &pBerElement );
                            szAttribute != NULL;
                            szAttribute = ldap_next_attributeW( pLdap, pMessage, pBerElement ) ) {

                            if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                                DWORD i = 0;
                                rgszVal = ldap_get_valuesW( pLdap, pMessage, szAttribute );

                                while (rgszVal[i]) {
                                    if (wcscmp(rgszVal[i],LDAP_SERVER_LAZY_COMMIT_OID_W) == 0) {
                                        fLazyCommitAvail = TRUE;
                                        break;
                                    }
                                    i++;
                                }

                                ldap_value_freeW(rgszVal);
                                rgszVal = NULL;
                            }
                           
                            szAttribute = NULL;
                    }

                    pBerElement = NULL;
                }

                if (pSearchMessage) {
                    ldap_msgfree(pSearchMessage);
                    pSearchMessage = NULL;
                }
            }

            *pfLazyCommitAvail = fLazyCommitAvail;
        }



        //
        // Initialize filetype to non known
        //
        FileType = F_NONE;  

        //
        // If user has not turned on the unicode flag, open file to check 
        // whether it is a unicode file
        //
        if (g_fUnicode == FALSE) {
            FILE *pFileIn;
            WCHAR wChar;
            if ((pFileIn = _wfopen(szFilename, L"rb")) == NULL) {
                ERR(("Failed opening file %S\n",szFilename));
                RaiseException(LL_FILE_ERROR, 0, 0, NULL);
            }
            wChar = fgetwc(pFileIn);
            if (wChar == WEOF) {
                fclose(pFileIn);
                ERR(("Failed getting first character of file %S\n",szFilename));
                RaiseException(LL_FILE_ERROR, 0, 0, NULL);
            }
            if (wChar == UNICODE_MARK) {
                g_fUnicode = TRUE;
            };
            fclose(pFileIn);
        }

        //
        // Setting up global file read\write flags
        //
        g_szFileFlagR = L"rb";
    
        if ((g_pFileIn = _wfopen(szFilename, g_szFileFlagR)) == NULL) {
            ERR(("Failed opening file %S\n",szFilename));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        if (!(GetTempPath(MAX_PATH, szTempPathname))) {
            DWORD WinError = GetLastError();
            ERR(("Failed getting tempory path: %d\n",WinError));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        if (!(GetTempFileName(szTempPathname, L"ldif", 0, g_szTempUrlfilename))) {
            DWORD WinError = GetLastError();
            ERR(("Failed getting tempory filename: %d\n",WinError));
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }


        yyout = stdout;
        yyin = g_pFileIn;

        LexerInit(szFilename);


    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
        LDIF_CleanUp();
    }

    return error;
}

LDIF_Error 
LDIF_InitializeExport(
    LDAP* pLdap,
    PWSTR *rgszOmit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    PWSTR szFrom,
    PWSTR szTo,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail) 
{
    LDIF_Error        error;
    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    //
    // Setting up global replacement strings
    //
    g_szExportFrom = szFrom;
    g_szExportTo = szTo;

    __try {
        samTablesCreate();
        CreateOmitBacklinkTable(pLdap,
                                rgszOmit,
                                dwFlag,
                                ppszNamingContext,
                                pfPagingAvail,
                                pfSAMAvail);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }

    return error;
}


//+---------------------------------------------------------------------------
// Function:    GenereateModFromAttr
//
// Synopsis:
//   The function below takes the attribute name and the attribute value, and 
//   an indication of whether its a text value or a binary to be BERval'd 
//   (ValueSize == length of buffer)
//   and returns an LDAPMod pointer representing the attribute modification.
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
LDAPModW *
GenereateModFromAttr(
    PWSTR szType, 
    PBYTE pbValue, 
    long ValueSize) 
{
    LDAPModW_Ext *pModTmp;
    PWSTR szOutput = NULL;
    PWSTR szValueW = NULL;
    DWORD dwSize = 0;
    PBYTE pbUTF8 = NULL;

    pModTmp = (LDAPModW_Ext*)MemAlloc_E(sizeof(LDAPModW_Ext));
    pModTmp->mod_type = MemAllocStrW_E(szType);

    if (ValueSize==-1) {
        pModTmp->mod_bvalues=
            (struct berval **)MemAlloc_E(2*sizeof(struct berval *));

        (pModTmp->mod_bvalues)[0]=
            (struct berval *)MemAlloc_E(sizeof(struct berval));

        pModTmp->mod_op = BINARY;
        pModTmp->fString = TRUE;
        szValueW = MemAllocStrW_E((PWSTR)pbValue);

        //
        // The parser will pass in a static "" string to represent a null
        // string. In that case, we don't need to free it.
        //
        if (*((PWSTR)pbValue))
            MemFree(pbValue);

        if (g_szImportFrom) {
            SubStrW(szValueW,
                    g_szImportFrom,
                    g_szImportTo,
                    &szOutput);
            if (szOutput == NULL) {
                szOutput = szValueW;
                szValueW = NULL;
            }
        }
        else {
            szOutput = szValueW;
            szValueW = NULL;
        }

        ConvertUnicodeToUTF8(szOutput,
                             wcslen(szOutput),
                             &pbUTF8,
                             &dwSize);

        ((pModTmp->mod_bvalues)[0])->bv_val = pbUTF8;
        ((pModTmp->mod_bvalues)[0])->bv_len = dwSize;
        (pModTmp->mod_bvalues)[1] = NULL;
    }
    else {
        pModTmp->fString = FALSE;
        pModTmp->mod_bvalues=
            (struct berval **)MemAlloc_E(2*sizeof(struct berval *));

        (pModTmp->mod_bvalues)[0]=
            (struct berval *)MemAlloc_E(sizeof(struct berval));

        pModTmp->mod_op = BINARY;
        ((pModTmp->mod_bvalues)[0])->bv_val = pbValue;
        ((pModTmp->mod_bvalues)[0])->bv_len = ValueSize;
        (pModTmp->mod_bvalues)[1] = NULL;
    }

    //
    // Clearing out
    //
    if (szValueW) {
        MemFree(szValueW);
    }
    if (szOutput) {
        MemFree(szOutput);
    }
    return (PLDAPModW)pModTmp;
}


void 
AddModToSpecList(
    LDAPModW *pMod
    )
{
    if (g_pListCur==NULL) {
        g_pListCur = (struct l_list *)MemAlloc_E(sizeof(struct l_list));
        g_pListCur->mod = pMod;
        g_pListCur->next = NULL;
        g_pListStart = g_pListCur;
        g_dwListElem++;
    }
    else {
        g_pListCur->next = (struct l_list *)MemAlloc_E(sizeof(struct l_list));
        g_pListCur = g_pListCur->next;
        g_pListCur->mod = pMod;
        g_pListCur->next = NULL;
        g_dwListElem++;
    }
}


//+---------------------------------------------------------------------------
// Function:    GenerateModFromList
//
// Synopsis:
//   This function takes the current linked list of elements and converts
//   it to to an LDAPMod** array which can passed to an LDAP API call.
//   All the elements of the linked list, other than those that will
//   be necessary for the new structure will be freed, making memory available
//   for the next attrval list. Note: the mod_op field will not be assigned here.
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
LDAPModW** 
GenerateModFromList(
    int nMode
    ) 
{
    LDAPModW **ppModTmp = NULL;
    LDAPModW **ppModReturn = NULL;
    struct l_list *pListNext = NULL;
    struct name_entry *pNameEntry = NULL;
    DWORD dwElements, i;
    PRTL_GENERIC_TABLE pTable = NULL;
    PNAME_MAP pNameMap = NULL;


    if (nMode==PACK) {
        //
        // an exception will be generated if the below fails
        //
        pTable = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
        RtlInitializeGenericTable(pTable,
                                  NtiCompW, NtiAlloc, NtiFree, NULL);

        //
        // If we've been told to pack, we must do many, many things
        //
        pNameEntry = (struct name_entry *)
                        MemAlloc_E(g_dwListElem*sizeof(struct name_entry));

        //
        // setup the name table
        //
        if (NameTableProcess(pNameEntry,
                        g_dwListElem,
                        SETUP,
                        g_pListStart->mod->mod_op,
                        g_pListStart->mod,
                        pTable)) {
            //
            // Note that NameTableProcess only returns 1 if it runs into memory
            // problems. Since, in the release version (without the DEVELOP
            // flag), those would generate exceptions, control would never
            // even get here, so this perror and its friends in this
            // function would never actually be reached.
            //
            ERR_RIP(("Failed setting up nametable!\n"));
        }

        //
        // count how many of each name we have
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             COUNT,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed counting nametable!\n"));
            }
            pListNext =g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // Lets allocate memory for each value now
        // Note: this can obviously be done without iterating over the start
        // list because all the necessary information is already in the name
        // table, but doing it this way is more consistent with the overall
        // scheme of things. (albeit a bit more expensive, however LDAP
        // accesses are orders of magnitude slower than any memory
        // machinations, so it doesn't even matter)
        //

        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             ALLOC,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed allocating nametable!\n"));
            }
            pListNext = g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // And finally, we place each value in its rightful place
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            if (NameTableProcess(pNameEntry,
                             g_dwListElem,
                             PLACE,
                             g_pListCur->mod->mod_op,
                             g_pListCur->mod,
                             pTable)) {
                ERR_RIP(("Failed placing nametable!\n"));
            }
            pListNext = g_pListCur->next;
            g_pListCur = pListNext;
        }

        //
        // Let's get rid of the name to index RTL table. Note that the pointers
        // in the Nti actually pointed to strings in our original list,
        // which we free down below.
        //

        for (pNameMap = RtlEnumerateGenericTable(pTable, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pTable, TRUE)) {
            RtlDeleteElementGenericTable(pTable, pNameMap);
        }

        if (RtlIsGenericTableEmpty(pTable)==FALSE) {
            ERR_RIP(("Table is empty!\n"));
            RaiseException(LL_INTERNAL_PARSER, 0, 0, NULL);
        }

        MemFree(pTable);

        //
        // At this point, all the values have been moved over to the name
        // table, and the name table has everything we need to build a new
        // LDAPMod array. The only remaining problem are the allocated names
        // and arrays in the linked list.
        // Lets first free the linked list (and the names in the contained
        // LDAPMod structs).
        //
        g_pListCur = g_pListStart;
        while(g_pListCur!=NULL) {
            MemFree(g_pListCur->mod->mod_type);

            //
            // the actual values are being pointed to from the table now
            //
            if (g_pListCur->mod->mod_op==REGULAR) {
                MemFree(g_pListCur->mod->mod_values);
            }
            else {
                MemFree(g_pListCur->mod->mod_bvalues);
            }
            MemFree(g_pListCur->mod);
            pListNext = g_pListCur->next;
            MemFree(g_pListCur);
            g_pListCur = pListNext;
        }

        //
        // Now that all the old data is gone, lets go through the nametable
        // generating the LDAPMod** array we're going to return
        //

        //
        // but first we must count how many actual elements we have
        //
        dwElements = 0;
        while((dwElements<g_dwListElem) && (pNameEntry[dwElements].count!=0) )
            dwElements++;

        //
        // allocate this much plus one for the NULL
        //
        ppModReturn = (LDAPModW **)MemAlloc_E((dwElements+1)*sizeof(LDAPModW *));
        ppModTmp = ppModReturn;

        for(i=0; i<dwElements; i++) {
            (*ppModTmp) = (LDAPModW*)pNameEntry[i].mod;
            ppModTmp++;
        }
        (*ppModTmp) = NULL;

        MemFree(pNameEntry);

    }
    else if (nMode==EMPTY) {
        //
        // allocate just one item for the NULL
        //
        ppModReturn = (LDAPModW **)MemAlloc_E(sizeof(LDAPModW *));
        ppModTmp = ppModReturn;
        (*ppModTmp) = NULL;
    }
    else {

        ppModReturn = (LDAPModW **)MemAlloc_E((g_dwListElem+1)*sizeof(LDAPModW *));
        ppModTmp = ppModReturn;

        //
        // Walk the list and assign the values
        //
        g_pListCur = g_pListStart;

        while(g_pListCur!=NULL) {
            (*ppModTmp) = g_pListCur->mod;
            ppModTmp++;
            pListNext = g_pListCur->next;
            MemFree(g_pListCur);
            g_pListCur = pListNext;
        }

        (*ppModTmp) = NULL;
    }

    //
    // reset the stuff for the next list
    //
    g_dwListElem = 0;
    g_pListCur = NULL;
    g_pListStart = NULL;

    return ppModReturn;
}


//+---------------------------------------------------------------------------
// Function:  FreeAllMods
//
// Synopsis:
//      This function takes an LDAPMod ** and frees all memory associated
//      with it
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
FreeAllMods(
    LDAPModW** ppModIn
    ) 
{
    PWSTR           *rgszValues = NULL;
    struct berval   **rgpBerval = NULL;
    LDAPModW        **ppMod     = NULL;

    ppMod = ppModIn;

    if (ppModIn!=NULL) {
        while((*ppModIn)!=NULL) {

            if ( (*ppModIn)->mod_op != (((*ppModIn)->mod_op)|LDAP_MOD_BVALUES )) {

                //
                // Its a regular value, so we must free an array of strings
                //
                // Note: the comparison checked whether ORing the value with
                // LDAP_MOD_BVALUES changes it. If it does, then it wasn't ORed
                // before and thus its a regular value. If it doesn't change it,
                // then it was OR'ed before and is thus a Bvalue
                //

                rgszValues = (*ppModIn)->mod_values;

                if (rgszValues!=NULL) {

                    while ((*rgszValues)!=NULL) {
                        MemFree (*rgszValues);
                        rgszValues++;
                    }

                    MemFree((*ppModIn)->mod_values);
                }
            }
            else {

                //
                // its a bvalue
                //
                rgpBerval = (*ppModIn)->mod_bvalues;

                if (rgpBerval!=NULL) {
                    while ((*rgpBerval)!=NULL) {
                        MemFree ((*rgpBerval)->bv_val);   //free the byte blob
                        MemFree (*rgpBerval);             //free the struct
                        rgpBerval++;
                    }
                    MemFree((*ppModIn)->mod_bvalues);
                }
            }

            MemFree((*ppModIn)->mod_type);
            MemFree(*ppModIn);

            ppModIn++;
        }
        MemFree(ppMod);
    }
}

void free_mod(
    LDAPModW* pMod
    ) 
{
    struct berval **rgpBerval = NULL;

    if (pMod!=NULL) {
        rgpBerval = pMod->mod_bvalues;
        if (rgpBerval!=NULL) {
            while ((*rgpBerval)!=NULL) {
                MemFree ((*rgpBerval)->bv_val);   //free the byte blob
                MemFree (*rgpBerval);             //free the struct
                rgpBerval++;
            }
            MemFree(pMod->mod_bvalues);
        }

        MemFree(pMod->mod_type);
        MemFree(pMod);
    }
}

//+---------------------------------------------------------------------------
// Function: SetModOps
//
// Synopsis:
//      The function below walks through a modifications list and sets the
//      mod_op fields to the indicated value
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
SetModOps(
    LDAPModW** ppMod, 
    int op
    ) 
{
    while((*ppMod)!=NULL) {
        (*ppMod)->mod_op = (*ppMod)->mod_op|op;
        ppMod++;
    }
}


//+---------------------------------------------------------------------------
// Function:    NameTableProcess
//
// Synopsis:
//
//      This function takes an LDAPMod and a pointer to a name table and
//      performs the specified table operation on it. It returns 0 on success
//      and non-zero on error. See inside the function for further information.
//
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int NameTableProcess(
            struct name_entry rgNameEntry[],
            long nTableSize,
            int op,
            int ber,
            LDAPModW *pModIn,
            PRTL_GENERIC_TABLE pTable
            )
{
    long        i,j;
    NAME_MAPW   Elem;
    PNAME_MAPW  pElemTemp;
    BOOLEAN     fNewElement;
    PWSTR       szName;

    szName = pModIn->mod_type;

    //
    // First, lets create the actual Element to use with our indexing table
    //
    Elem.szName = szName;
    Elem.index = 0;

    //
    // try to find it in our indexing table
    //
    pElemTemp = RtlLookupElementGenericTable(pTable, &Elem);

    //
    // if it was found, get the index into our primary name table
    // if it wasn't get the next available index and create the new entry
    //
    if (pElemTemp) {
        i = pElemTemp->index;
    }
    else {
        i = RtlNumberGenericTableElements(pTable);
        Elem.index = i;
        RtlInsertElementGenericTable(pTable,
                                     &Elem,
                                     sizeof(NAME_MAP),
                                     &fNewElement);
        if (fNewElement==FALSE) {
            // "Re-insertion of indexing entry
            RaiseException(LL_INTERNAL_PARSER, 0, 0, NULL);
        }
    }

    switch(op) {

        case SETUP:
            //
            // The name in the LDAPMod struct given will be ignored.
            // This is a call to set up the table of names
            //
            for (i = 0; i<nTableSize; i++) {
                rgNameEntry[i].count = 0;
            }
            break;

        case COUNT:
            //
            // Here is what we do here:
            // If the count is 0, that means we're at a new name. So lets set it
            // up and leave. If the count is not, lets increment.
            //
            if (rgNameEntry[i].count==0) {
                //
                // Since we're using an LDAPMod struct to keep track of names
                // and stuff, we have to allocate one
                ///
                rgNameEntry[i].mod = (LDAPModW_Ext *)MemAlloc_E(sizeof(LDAPModW_Ext));
                rgNameEntry[i].mod->mod_type = MemAllocStrW_E(szName);

                //
                // Use the mod_op field of the struct to flag whether memory for
                // the values has yet been alloc'd
                //
                rgNameEntry[i].mod->mod_op = NOT_ALLOCATED;
                rgNameEntry[i].count = 1;
                return 0;
            }
            else {
                //
                // Another instance of a name we have
                //
                rgNameEntry[i].count++;
                return 0;
            }
            break;

        case ALLOC:
            //
            // For the name given, we allocate the memory needed
            // for all the values.
            // If the same name is given twice, the computer will
            // explode.
            // (note: the above was a joke.
            // Once the memory has been allocated once,
            // all remaiing mentions of the name will be ignored).
            //
            if (rgNameEntry[i].mod->mod_op==NOT_ALLOCATED) {
                if (ber==REGULAR) {

                    rgNameEntry[i].mod->mod_values =
                        (PWSTR*)MemAlloc_E((rgNameEntry[i].count+1)*sizeof(PWSTR));

                    for (j=0; j<(rgNameEntry[i].count+1); j++) {
                        (rgNameEntry[i].mod->mod_values)[j]=NULL;
                    }

                    rgNameEntry[i].next_val = rgNameEntry[i].mod->mod_values;
                    rgNameEntry[i].mod->mod_op = ALLOCATED;
                }
                else {

                    rgNameEntry[i].mod->mod_bvalues=
                        (struct berval **)MemAlloc_E((rgNameEntry[i].count+
                               1)*sizeof(struct berval *));

                    for (j=0; j<(rgNameEntry[i].count+1); j++) {
                        (rgNameEntry[i].mod->mod_bvalues)[j]=NULL;
                    }

                    rgNameEntry[i].next_bval=rgNameEntry[i].mod->mod_bvalues;
                    rgNameEntry[i].mod->mod_op=ALLOCATED_B;
                }
            }
            else {
                //
                // Check for more than one type in the multiple values of
                // a single attribute. Explained in ldifext.h
                //
                if ( ((rgNameEntry[i].mod->mod_op==ALLOCATED_B)
                        &&(ber==REGULAR)) ||
                    ((rgNameEntry[i].mod->mod_op==ALLOCATED)
                        &&(ber==BINARY)) ) {
                    RaiseException(LL_MULTI_TYPE, 0, 0, NULL);
                }
            }
            return 0;
            break;

        case PLACE:
        {
            LDAPModW_Ext *pExt = (LDAPModW_Ext*)pModIn;
            rgNameEntry[i].mod->fString = pExt->fString;

            //
            // Now that we've counted and allocated memory for values, We can
            // place them. Note that we're actually Just passing around pointers
            // without reallocing the memory.
            //
            if (ber==REGULAR) {
                //
                // Now that we're done using the mod_op for the sinister
                // purposes of allocating, we can set it to the proper value for
                // the type. We set it to 0 if its a regular value and we OR it
                // with LDAP_MOD_BVALUES if its a bval. The SetModOps function
                // will then add its own thing by also OR'ing. Note that this
                // implies that one cannot specifiy multiple values of both
                // types in one LDIF record. I am aware that doing it here is
                // somewhat redundant, as every multi-value will set mod_op,
                // however it costs next to nothing and is convinient.
                ///
                rgNameEntry[i].mod->mod_op = 0;

                //
                // And now place the value
                //
                *(rgNameEntry[i].next_val) = (pModIn->mod_values)[0];
                (rgNameEntry[i].next_val)++;
            }
            else {
                rgNameEntry[i].mod->mod_op = LDAP_MOD_BVALUES;
                *(rgNameEntry[i].next_bval) = (pModIn->mod_bvalues)[0];
                (rgNameEntry[i].next_bval)++;
            }
            break;
        }
    }

    return 0;
}

void 
ChangeListAdd(
    struct change_list *pList
    ) 
{
    if (g_pChangeCur==NULL) {
        g_pChangeCur = pList;
        g_pChangeStart = pList;
        g_pChangeCur->next = NULL;
    }
    else {
        g_pChangeCur->next = pList;
        g_pChangeCur = pList;
        g_pChangeCur->next = NULL;
    }
}


void 
ProcessException (
    DWORD exception, 
    LDIF_Error *pError
    )
{
    if (exception==STATUS_NO_MEMORY) {
        pError->error_code=LL_MEMORY_ERROR;
    }
    else if ((exception==LL_SYNTAX) || (exception==LL_MULTI_TYPE) ||
             (exception==LL_EXTRA) || (exception==LL_INTERNAL_PARSER) ||
             (exception==LL_FTYPE) || (exception==LL_URL)) {
        pError->token_start = cLast;

        //
        // Pass ownership of the buffer to the error blob
        //
        pError->szTokenLast = g_pszLastToken;
        g_pszLastToken = NULL;

        pError->error_code = exception;
        if (Line > 0) {
            //
            // An extern from yylex()
            // rgLineMap is only initialized when we reach the second
            // line following a newline.  So if it isn't initialized,
            // we must still be on the first line of the file.
            //
            pError->line_number = rgLineMap ? rgLineMap[Line-1] : 1;
        }
        //
        // the array was built without the version: 1
        // we have to readjust...
        //
        pError->RuleLastBig = RuleLastBig;
        pError->RuleLast = RuleLast;
        pError->RuleExpect = RuleExpect;
        pError->TokenExpect = TokenExpect;
    }
    else {
        pError->error_code = exception;
    }
}

void 
LDIF_CleanUp() 
{
    fEOF = FALSE;
    FileType = F_NONE;

    samTablesDestroy();

    LexerFree();

    //
    // Normally, g_pObject & g_pListStart get cleaned up
    // as we finish parsing a record.  If they're non-NULL,
    // we must have hit an error while parsing, and we clean
    // them up now.
    //
    if (g_pObject.pszDN) {
        MemFree(g_pObject.pszDN);
        g_pObject.pszDN = NULL;
    }

    if (g_pListStart) {
        struct l_list *pListNext;
        struct l_list *pListCurElem = NULL;
        pListCurElem = g_pListStart;

        while(pListCurElem!=NULL) {
            free_mod(pListCurElem->mod);
            pListNext = pListCurElem->next;
            MemFree(pListCurElem);
            pListCurElem = pListNext;
        }

        g_pListStart = NULL;
        g_pListCur = NULL;
        g_dwListElem = 0;
    }

    if (g_pFileIn) {
        fclose(g_pFileIn);
        g_pFileIn = NULL;
    }

    if (g_pFileUrlTemp) {
        fclose(g_pFileUrlTemp);
        g_pFileUrlTemp = NULL;
    }

#ifndef LEAVE_TEMP_FILES
    if (g_szTempUrlfilename[0]) {
        DeleteFile(g_szTempUrlfilename);
        swprintf(g_szTempUrlfilename, L"");
    }
#endif

    if (rgLineMap) {
        MemFree(rgLineMap);
        rgLineMap = NULL;
    }

    LineClear = 0;
    Line = 0;
    LineGhosts = 0;

    if (g_pszLastToken) {
        MemFree(g_pszLastToken);
        g_pszLastToken = NULL;
    }
}

LDIF_Error 
LDIF_Parse(
    LDIF_Record *pRecord
    ) 
{

    LDIF_Error        error = {0};
    int             nReturnCode;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    __try {
        //
        // Unfortunately, we can't do this through an exception from yywrap.
        // yywrap needs to exit peacefully for yyparse to complete succesfully.
        //
        if (fEOF) {
            //
            // I thought of raising an exception here, but then that
            // would call LDIF_CleanUp and kill the heap, which would trash the last
            // returned entry. So I just set the error and leave.
            //
            error.error_code = LL_EOF;
            return error;
        }

        //
        // Set up for changes
        //
        g_pChangeStart = NULL;
        g_pChangeCur = NULL;

        //
        // Return the next entry
        //
        nReturnCode = yyparse();

        //
        // Note that an exception may have been raised here from yyparse or
        // yylex. Now lets set EOF if we hit it, so user knows not to call
        // ldif_parse again
        //
        if (fEOF) {
            error.error_code = LL_EOF;
        }

        if (nReturnCode==LDIF_REC) {
            pRecord->fIsChangeRecord = FALSE;
            pRecord->content = g_pObject.ppMod;
        }
        else {
            pRecord->fIsChangeRecord = TRUE;
            pRecord->changes = g_pChangeStart;
        }

        if (g_szImportFrom) {
            pRecord->dn = NULL;
            SubStrW(g_pObject.pszDN,
                   g_szImportFrom,
                   g_szImportTo,
                   &pRecord->dn);
            if (pRecord->dn) {
                if (g_pObject.pszDN) {
                    MemFree(g_pObject.pszDN);
                    g_pObject.pszDN = NULL;
                }
            }
            else {
                if (g_pObject.pszDN) {
                    pRecord->dn = MemAllocStrW_E(g_pObject.pszDN);
                    MemFree(g_pObject.pszDN);
                    g_pObject.pszDN = NULL;
                }
                else {
                    pRecord->dn = NULL;
                }
            }
        }
        else {
            if (g_pObject.pszDN) {
                pRecord->dn = MemAllocStrW_E(g_pObject.pszDN);
                MemFree(g_pObject.pszDN);
                g_pObject.pszDN = NULL;
            }
            else {
                pRecord->dn = NULL;
            }
        }

        //error.line_number=rgLineMap[Line-1];
        error.line_begin=rgLineMap[g_dwBeginLine-1];

    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }

    return error;
}


LDIF_Error 
LDIF_LoadRecord(
    LDAP *pLdap, 
    LDIF_Record *pRecoard, 
    int nActive, 
    BOOL fLazyCommit,
    BOOLEAN fCallTerminateIfFail
    ) 
{
    struct change_list  *pListCurrent;
    int                 LdapError;
    LDIF_Error            LdifError;
    PWSTR               pszDN = NULL;

    LdifError.error_code    = LL_SUCCESS;
    LdifError.szTokenLast = NULL;

    //
    // mattrim Oct-30-2000
    // Previously, fCallTerminateIfFail was used to determine whether to
    // call LDIF_Cleanup if loading a record failed.  The following code
    // was in the exception handler to do this:
    //
    //    //
    //    // the err was set by the call before the exception occurred
    //    //
    //    if (fCallTerminateIfFail) {
    //        LDIF_Cleanup();
    //    }
    //
    // I've changed the LDIF library to put the responsibility for calling
    // LDIF_Cleanup on the user of the libbrary.
    //
    UNREFERENCED_PARAMETER(fCallTerminateIfFail);

    __try {

        if (pRecoard->fIsChangeRecord==FALSE) {
            if (nActive==1) {
                if ((LdapError=ldif_ldap_add_sW(pLdap, pRecoard->dn, 
                            pRecoard->content, fLazyCommit)) !=LDAP_SUCCESS) {
                    ERR(("ldif_ldapadd returns %d\n",LdapError));
                    RaiseException(LL_LDAP, 0, 0, NULL);
                }
            }
        }
        else {
            pListCurrent = pRecoard->changes;
            while(pListCurrent!=NULL) {
                if (pListCurrent->dn_mem) {
                    pszDN = MemAllocStrW_E(pListCurrent->dn_mem);
                }

                switch(pListCurrent->operation) {

                case CHANGE_ADD:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_add_sW(pLdap, pRecoard->dn,
                                   pListCurrent->mods_mem, fLazyCommit)) != 
                             LDAP_SUCCESS) {
                            ERR(("ldif_ldapadd returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_DEL:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_delete_sW(pLdap, pRecoard->dn,
                                fLazyCommit)) !=LDAP_SUCCESS) {
                            ERR(("ldif_ldapdelete returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_DN:
                    if (nActive==1) {
                        ULONG msgnum = ldap_modrdn2W(pLdap,
                                                       pRecoard->dn,
                                                       pszDN,
                                                       pListCurrent->deleteold);

                        LdapError = LdapResult(pLdap, msgnum, NULL);
                        
                        if (LdapError!=LDAP_SUCCESS) {
                           ERR(("ldapmodrdn returns %d\n",LdapError));
                           RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_MOD:
                    if (nActive==1) {
                        if ((LdapError=ldif_ldap_modify_sW(pLdap,
                                                pRecoard->dn,
                                                pListCurrent->mods_mem,
                                                fLazyCommit))
                                                !=LDAP_SUCCESS) {
                            ERR(("ldif_ldapmodify returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSADD:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_add_sW(pLdap,
                                                  pRecoard->dn,
                                                  pListCurrent->mods_mem))!=LDAP_SUCCESS) {
                            ERR(("ldapadd returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSDEL:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_delete_sW(pLdap,
                                                     pRecoard->dn))
                                                        !=LDAP_SUCCESS) {
                            ERR(("ldapdelete returns %d\n",LdapError));
                            RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSDN:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_modrdn2_sW(pLdap,
                                                      pRecoard->dn,
                                                      pszDN,
                                                      pListCurrent->deleteold))
                                                        !=LDAP_SUCCESS) {
                           ERR(("ldapmod returns %d\n",LdapError));
                           RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;

                case CHANGE_NTDSMOD:
                    if (nActive==1) {
                        if ((LdapError=NTDS_ldap_modify_sW(pLdap,
                                                     pRecoard->dn,
                                                     pListCurrent->mods_mem))
                                                        !=LDAP_SUCCESS) {
                        ERR(("ldapmod returns %d\n",LdapError));
                        RaiseException(LL_LDAP, 0, 0, NULL);
                        }
                    }
                    break;
                }

                pListCurrent = pListCurrent->next;

                if (pszDN) {
                    MemFree(pszDN);
                    pszDN = NULL;
                }
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {

        ProcessException(GetExceptionCode(), &LdifError);

        if (pszDN) {
            MemFree(pszDN);
            pszDN = NULL;
        }
        LdifError.ldap_err = LdapError;
        
    }

    return LdifError;
}


LDIF_Error LDIF_ParseFree(
    LDIF_Record *pRecord
    ) 
{

    struct change_list  *pListCurrent;
    struct change_list  *pListStart;
    LDIF_Error LdifError;

    LdifError.error_code = LL_SUCCESS;
    LdifError.szTokenLast = NULL;

    __try {

        if (pRecord->fIsChangeRecord==FALSE) {
            if (pRecord->content) {
                FreeAllMods(pRecord->content);
                pRecord->content = NULL;
            }
            if (pRecord->dn) {
                MemFree(pRecord->dn);
                pRecord->dn = NULL;
            }
        }
        else if (pRecord->fIsChangeRecord==TRUE) {
            //
            // Walk the changes list
            //
            pListStart=pRecord->changes;
            pListCurrent=pListStart;
            while(pListCurrent!=NULL) {
                //
                // first order of business is to process the change specified
                // and free change specific memory (the stuff in the union)
                //
                switch(pListCurrent->operation) {
                    case CHANGE_ADD:
                    case CHANGE_NTDSADD:
                        if (pListCurrent->mods_mem) {
                            FreeAllMods(pListCurrent->mods_mem);
                            pListCurrent->mods_mem = NULL;
                        }
                        break;

                    case CHANGE_DN:
                    case CHANGE_NTDSDN:
                        if (pListCurrent->dn_mem) {
                            MemFree(pListCurrent->dn_mem);
                            pListCurrent->dn_mem = NULL;
                        }
                        break;
                    case CHANGE_MOD:
                    case CHANGE_NTDSMOD:
                        if (pListCurrent->mods_mem) {
                            FreeAllMods(pListCurrent->mods_mem);
                            pListCurrent->mods_mem = NULL;
                        }
                        break;
                }
                //
                // now that the union memory has been freed, lets move and kill
                // this node
                //
                pListStart=pListCurrent;

                //
                // I am aware this is not necessary on the first el.
                //
                pListCurrent=pListCurrent->next;
                MemFree(pListStart);
            }

            //
            // reset the start, the current was reset by the last loop pass
            //
            pListStart = NULL;
            pRecord->changes = NULL;
            if (pRecord->dn) {
                MemFree(pRecord->dn);
                pRecord->dn = NULL;
            }
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &LdifError);
    }

    return LdifError;

}

LDIF_Error 
LDIF_GenerateEntry(
    LDAP        *pLdap,
    LDAPMessage *pMessage,
    PWSTR       **prgReturn,
    BOOLEAN     fSamLogic,
    BOOLEAN     fIgnoreBinary,
    PWSTR       **pppszAttrsWithRange,
    BOOL        fAttrsWithRange)
{
    PWSTR szDN = NULL;
    PWSTR szDNW = NULL;
    PWSTR szDNFinal = NULL;
    PWSTR szTemp = NULL;
    PWSTR szAttribute = NULL;
    PWSTR *rgszAttributes = NULL;
    PWSTR *rgszResult = NULL;
    WCHAR szTrailer[] = L"\r\n";
    WCHAR szRegular[] = L": ";
    WCHAR szB64[] = L":: ";
    WCHAR szWrapper[] = L"\r\n ";
    WCHAR szDNCommonStart[] = L"dn: ";
    WCHAR szDNB64Start[] = L"dn:: ";
    PWSTR szDNStart = NULL, szTmpDN = NULL;

    struct berelement *pBerElement;
    struct berval     **rgpVals;

    DWORD dwB64 = wcslen(szB64);
    DWORD dwTrailer = wcslen(szTrailer);
    DWORD dwRegular = wcslen(szRegular);
    DWORD dwWrapper = wcslen(szWrapper);
    DWORD dwAttrname, dwAttrNoRange;
    DWORD dwTemp;
    DWORD dwLeft;

    DWORD dwCount;
    DWORD j;
    DWORD dwEveryAttr;
    DWORD dwManyAttr;
    DWORD dwValCount;
    DWORD dwTotalStrings;
    DWORD iNextString;
    DWORD dwStrPos;
    long lSets78;

    LDIF_Error            error;
    PNAME_MAP           pNtiPtr;
    NAME_MAP            NtiElem;
    PNAME_MAP           pNtiElemTemp;

    BOOLEAN             bWrapMarker;
    DWORD               iCheckAttr;
    BOOLEAN             bNotInObjectClass;
    BOOLEAN             bSamSkip;
    BOOLEAN             bNewElem;
    BOOLEAN             bBase64;

    BOOLEAN             bBackLink = FALSE;
    BOOLEAN             bBase64DN = FALSE;
    PWSTR               szCur;

    PWSTR szReplacedAttrW = NULL;
    PWSTR szTempW         = NULL;
    PWSTR szAttributeW    = NULL;
    PWSTR szAttrNoRange   = NULL;
    PWSTR *rgszValW       = NULL;
    PWSTR *rgszVal        = NULL;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;
    error.the_modify = -1;

    __try {

        //
        // Getting the DN
        //
        szDNW = ldap_get_dnW( pLdap,
                              pMessage );

        //
        // This is a special case, we sub the DN before trying to convert to
        // B64
        //
        if (g_szExportFrom) {
            PWSTR szOutput;

            SubStrW(szDNW,
                    g_szExportFrom,
                    g_szExportTo,
                    &szDNFinal);
        }
        if (szDNFinal == NULL) {
            szDNFinal = MemAllocStrW_E(szDNW);
        }

        //
        // In ANSI mode, unicode DNs have to be displayed as B64 format
        // Check DN to see if it is unicode, if it is unicode, we'll export as
        // B64.
        //
        if (g_fUnicode == FALSE) {
            szCur = szDNFinal;
            while (*szCur) {
                if (((*szCur)<0x20) ||
                    ((*szCur)>0xFF)) {
                    //
                    // This string contains non-ANSI value, use B64 format
                    //
                    bBase64DN = TRUE;
                    break;
                }
                szCur++;
            }
        }

        if (bBase64DN) {
            DWORD dwSize;
            PBYTE pbUTF8;

            ConvertUnicodeToUTF8(szDNFinal,
                                 wcslen(szDNFinal),
                                 &pbUTF8,
                                 &dwSize);

            szDN = base64encode(pbUTF8,
                                dwSize);
            dwSize = wcslen(szDN);

            MemFree(pbUTF8);
            szDNStart = szDNB64Start;
        }
        else {
            szDN = MemAllocStrW_E(szDNFinal);
            szDNStart = szDNCommonStart;
        }

        //
        // Allocating RETURN STRING. Calculate the number of strings needed to
        // be returned in total by looking at all the attributes
        //
        iCheckAttr = 0;
        dwTotalStrings = 0;
        pBerElement = NULL;
        dwManyAttr = 0;

        for (   szAttribute = ldap_first_attribute( pLdap,
                                                    pMessage,
                                                    &pBerElement );
                szAttribute != NULL;
                szAttribute = ldap_next_attribute( pLdap,
                                                   pMessage,
                                                   pBerElement ) ) {
            PWSTR szTmpAttr =  NULL;

            dwManyAttr++;
            rgszVal = ldap_get_values( pLdap, pMessage, szAttribute);

            // make sure that the comparison is only with the attribute name
            // and not with any range specifiers follwing the attribute name.
            szTmpAttr = StripRangeFromAttr(szAttribute);
         
            if (!_wcsicmp(L"objectClass",szTmpAttr)) {
                if (!iCheckAttr) {
                    iCheckAttr = samCheckObject(rgszVal);
                }
            }

            dwValCount = ldap_count_values(rgszVal);

            //
            // Allocate Extra Space if attribute is backlinks
            //
            if (fSamLogic) {
                if (SCGetAttByName(wcslen(szTmpAttr),
                                   szTmpAttr) == TRUE) {
                    dwTotalStrings += (dwValCount * 5);
                }
            }
            else if(fAttrsWithRange)
            // if there are attributes with range specifiers, then we need
            // 2 strings per attribute - one for "add <attr>: ..." and one
            // for the '-' at the end
                dwTotalStrings += (dwValCount * 2);

            if(szTmpAttr)
                MemFree(szTmpAttr);

            dwTotalStrings+=dwValCount;
            ldap_value_free(rgszVal);
            rgszVal = NULL;
        }

        dwTotalStrings+=10;  // for miscellaneous stuff
        rgszResult=(PWSTR*)MemAlloc_E(dwTotalStrings*sizeof(PWSTR));


        iNextString=0;
        pBerElement=NULL;

        // create a temporary string containing the DN for this entry
        szTmpDN = (PWSTR)MemAlloc_E((wcslen(szDN) +
                                wcslen(szDNStart)+dwTrailer+1)*sizeof(WCHAR));
        memcpy(szTmpDN, szDNStart, wcslen(szDNStart) * sizeof(WCHAR));
        dwStrPos=wcslen(szDNStart);
        memcpy(szTmpDN+dwStrPos, szDN, wcslen(szDN) * sizeof(WCHAR));
        dwStrPos+=wcslen(szDN);
        memcpy(szTmpDN+dwStrPos, szTrailer, (dwTrailer+1) * sizeof(WCHAR));
        MemFree(szDN);
        szDN = NULL;
        

        //
        // Setting up Entry. If we are here because of attributes with range, 
        // then we want to set up a modify entry in the export file (done 
        // later). We should setup an add entry only if we are not here due
        // to an attribute with a range specifier.
        //
        if(FALSE == fAttrsWithRange)
        {
            rgszResult[iNextString]=(PWSTR)MemAllocStrW_E(szTmpDN);
            iNextString++;

            rgszResult[iNextString]=MemAllocStrW_E(L"changetype: add\r\n");
            iNextString++; 
        }

        //
        // Put the attributes into a sortable array
        //
        rgszAttributes=(PWSTR*)MemAlloc_E(dwManyAttr*sizeof(PWSTR));
        dwEveryAttr = 0;
        for ( szAttribute = ldap_first_attribute(pLdap, pMessage, &pBerElement);
              szAttribute != NULL;
              szAttribute = ldap_next_attribute(pLdap, pMessage, pBerElement)) {
              rgszAttributes[dwEveryAttr++]=MemAllocStrW_E(szAttribute);
        }

        if (fSamLogic) {
            qsort((void *)rgszAttributes,
                  (size_t)dwManyAttr,
                  sizeof(PWSTR),
                  LoadedCompare);
        }

        for (dwEveryAttr=0; dwEveryAttr < dwManyAttr; dwEveryAttr++) {

            int i;
            bBackLink = FALSE;
            szAttribute = rgszAttributes[dwEveryAttr];
            dwAttrname = wcslen(szAttribute);
            // free string if previous iteration of for loop did 'continue'
            if(szAttrNoRange)
            {
                MemFree(szAttrNoRange);
                szAttrNoRange = NULL;
            }
            szAttrNoRange = StripRangeFromAttr(szAttribute);
            dwAttrNoRange = wcslen(szAttrNoRange);
            rgpVals = ldap_get_values_len( pLdap, pMessage, szAttribute );
            dwValCount = ldap_count_values_len(rgpVals);

            //
            // if values contain bytes outside our permissible range of
            // printables, all values of this attribute will be base64 encoded.
            //
            bBase64 = FALSE;
            for (i=0; rgpVals[i]!=NULL; i++) {
                if (g_fUnicode) {
                    if (!IsUTF8String(rgpVals[i]->bv_val,
                                      rgpVals[i]->bv_len)) {
                        bBase64 = TRUE;
                        break;
                    }
                    else {
                        //
                        // If it is a UTF8 unicode string, we'll convert it to
                        // unicode and test whether all values are > 0x20, if
                        // they are not, we display them as base64
                        //
                        DWORD dwLen = 0;
                        PWSTR pszUnicode = NULL;
                        DWORD l = 0;

                        ConvertUTF8ToUnicode(
                            rgpVals[i]->bv_val,
                            rgpVals[i]->bv_len,
                            &pszUnicode,
                            &dwLen
                            );
    
                        if (pszUnicode) {
                            while (l<(dwLen-1)) {
                                if (pszUnicode[l] < 0x20) {
                                    bBase64 = TRUE;
                                    break;
                                }
                                l++;
                            }

                            if (!bBase64 && dwLen > 1) {
                                //
                                // If the value starts with a prohibited
                                // initial character (SPACE, :, <), or ends
                                // with a space, must base-64 encode
                                // (clauses 4, 8 of LDIF standard)
                                //
                                if ( (pszUnicode[0] == 0x20) ||     // init. space
                                     (pszUnicode[0] == 0x3A) ||     // init. :
                                     (pszUnicode[0] == 0x3C) ||     // init. <
                                     (pszUnicode[dwLen-2] == 0x20) )// final space
                                {
                                    bBase64 = TRUE;
                                }
                            }
                            
                            MemFree(pszUnicode);
                            pszUnicode = NULL;
                        }
                    }
                }
                else {
                    for (j=0; j<rgpVals[i]->bv_len; j++) {
                        if (!g_fUnicode) {
                            if (((rgpVals[i]->bv_val)[j]<0x20)
                                    ||((rgpVals[i]->bv_val)[j]>0x7E)) {
                                bBase64 = TRUE;
                                break;
                            }
                        }
                    }

                    if (!bBase64 && rgpVals[i]->bv_len > 0) {
                        //
                        // If the value starts with a prohibited
                        // initial character (SPACE, :, <), or ends
                        // with a space, must base-64 encode
                        // (clauses 4, 8 of LDIF standard)
                        //
                        if ( ((rgpVals[i]->bv_val)[0] == 0x20) ||   // init. space
                             ((rgpVals[i]->bv_val)[0] == 0x3A) ||   // init. :
                             ((rgpVals[i]->bv_val)[0] == 0x3C) ||   // init. <
                             ((rgpVals[i]->bv_val)[rgpVals[i]->bv_len - 1] == 0x20) ) // final space
                        {
                            bBase64 = TRUE;
                        }
                    }
                }
                if (bBase64)
                    break;
            }

            //
            // omit if its on our sam lists
            //
            bSamSkip = FALSE;
            if (iCheckAttr) {
                bSamSkip = samCheckAttr(szAttrNoRange, iCheckAttr);
            }

            //
            // omit if its on our user list.
            //
            NtiElem.szName = szAttrNoRange;
            NtiElem.index = 0;
            pNtiElemTemp = RtlLookupElementGenericTable(g_pOmitTable,
                                                        &NtiElem);

            bNotInObjectClass = (_wcsicmp(L"objectClass",szAttrNoRange) != 0);

            //
            // Do the S_MEM special action, if it is a backlink, will be last
            //
            if (fSamLogic) {
                if (SCGetAttByName(wcslen(szAttrNoRange),
                                   szAttrNoRange
                                   ) == TRUE) {
                    if (_wcsicmp(szAttrNoRange,g_szPrimaryGroup) == 0) {
                        if ((rgpVals[0]->bv_len == strlen(g_szDefaultGroup)) && 
                            (memcmp(rgpVals[0]->bv_val,
                                   g_szDefaultGroup,
                                   strlen(g_szDefaultGroup)*sizeof(CHAR)) == 0)
                            ) {
                            //
                            // If the primarygroup value is the same as default,
                            // we just ignore it when the object is actually
                            // being created, the default value will be put in
                            //
                            bBackLink = FALSE;
                            bSamSkip = TRUE;
                        }
                        else {
                            //
                            // If the value is not default, we will append it
                            // (treat it as backlink). It cannot accompany the
                            // rest of the object because this operation will
                            // fail if the group does not exist yet
                            //
                            bBackLink = TRUE;
                        }
                    }
                    else {
                        bBackLink = TRUE;
                    }
                }
            }

            //
            // don't write if its on the sam prohibited list
            //
            if (fSamLogic && bSamSkip) {
                ldap_value_free_len(rgpVals);            
                continue;
            }

            //
            // don't write if its on the omit list
            //
            if (pNtiElemTemp) {
                ldap_value_free_len(rgpVals);            
                continue;
            }

            if (fSamLogic && 
                ((_wcsicmp(L"objectGUID", szAttrNoRange) == 0) ||
                 (_wcsicmp(L"isCriticalSystemObject", szAttrNoRange) == 0))
               ) {
                ldap_value_free_len(rgpVals);               
                continue;
            }

            if (bBackLink && (error.the_modify == -1)) {
                error.the_modify = iNextString+1;
            }

            if (fIgnoreBinary && bBase64) {
                ldap_value_free_len(rgpVals);
                continue;
            }

            if((FALSE == bBackLink) && fAttrsWithRange && (0 == dwEveryAttr))
            {
                rgszResult[iNextString]=(PWSTR)MemAllocStrW_E(szTmpDN);
                iNextString++;

                rgszResult[iNextString] = MemAllocStrW_E(
                                               L"changetype: modify\r\n");
                iNextString++;
            }

            //
            // In unicode mode, if the string is UTF8 encode, we still have to
            // test whether it has any invalid values. If it does, we'll have
            // to use b64 format
            //
            if (g_fUnicode && !bBase64) {
                DWORD l;
                ASSERT(szAttributeW == NULL && rgszValW == NULL);
                szAttributeW = MemAllocStrW_E(szAttribute);
                rgszValW = ldap_get_valuesW( pLdap, pMessage, szAttributeW);
                for (l=0; rgszValW[l]!=NULL; l++) {
                    PWSTR szCurrent = rgszValW[l];
                    while (*szCurrent) {
                        if (*szCurrent < 32) {
                            bBase64 = TRUE;
                            goto processvalue;
                        }
                        szCurrent++;
                    }
                }
            }

processvalue:
            if (bBase64) {

                //
                // Binary Value
                //

                for (i=0; rgpVals[i]!=NULL; i++) {
                    if (bBackLink) {
                        WCHAR szBuffer[256];
                        // start a new entry
                        rgszResult[iNextString++]=MemAllocStrW_E(L"\r\n");
                        //copy the DN
                        rgszResult[iNextString++]=MemAllocStrW_E(szTmpDN);
                        rgszResult[iNextString++]=MemAllocStrW_E(L"changetype: modify\r\n");
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }
                    else if(fAttrsWithRange) {
                        WCHAR szBuffer[256];
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }

                    //
                    // Only print last value if ObjectClass
                    //
                    if(!bNotInObjectClass) {
                        if (g_nClassLast == LOC_NOTSET) {
                            if ( _stricmp( rgpVals[0]->bv_val, "top") == 0 ) {
                                g_nClassLast = LOC_LAST;
                            }
                            else {
                                g_nClassLast = LOC_FIRST;
                            }
                        }
                        if (g_nClassLast == LOC_LAST) {
                            if (rgpVals[i+1]!=NULL) {
                                continue;
                            }
                        }
                        else {
                            if (i!=0) {
                                break;
                            }
                        }
                    }

                    szTemp = base64encode((PBYTE)rgpVals[i]->bv_val,
                                          rgpVals[i]->bv_len);
                    dwTemp = wcslen(szTemp);

                    //
                    // break into sets, 78 to make room for wrapping newline and
                    // space
                    //
                    lSets78=dwTemp/78;
                    dwLeft=dwTemp%78;

                    //
                    // if we the length of our name plus the length of
                    // the value exceeds 80, we need to put in a wrap.
                    //
                    bWrapMarker=0;
                    if ((lSets78==0) &&
                        ((dwAttrNoRange+dwB64+dwTemp+dwTrailer)>80)) {
                        bWrapMarker=1;
                        dwTemp+=dwWrapper;
                    } else if (lSets78>0) {
                        bWrapMarker=1;
                        dwTemp= dwWrapper         // Initial wrapper
                                + (lSets78*(78+dwWrapper)) // Each line with wrapper
                                + dwLeft;         // last line
                    }

                    rgszResult[iNextString]=(PWSTR)MemAlloc_E(
                                    (dwAttrNoRange+dwB64+dwTemp+dwTrailer+1)*sizeof(WCHAR));
                    memcpy(rgszResult[iNextString],
                           szAttrNoRange,
                           dwAttrNoRange * sizeof(WCHAR));
                    dwStrPos=dwAttrNoRange;

                    // if this attribute has a range associated with it, then 
                    // we may have to make another search request to fetch the
                    // remaining values. Store off the range values for the
                    // next search request, if required.
                    if(dwAttrNoRange != dwAttrname) // range present
                        GetNewRange(szAttribute, dwAttrNoRange, szAttrNoRange,
                            dwManyAttr, pppszAttrsWithRange);

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szB64,
                           dwB64*sizeof(WCHAR));
                    dwStrPos+=dwB64;

                    if (bWrapMarker) {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                                szWrapper,
                                dwWrapper * sizeof(WCHAR));
                        dwStrPos+=dwWrapper;
                    }

                    if (lSets78>0) {
                        dwCount=0;
                        while (lSets78>0) {
                            memcpy(rgszResult[iNextString]+dwStrPos,
                                                szTemp+(dwCount*78), 78 * sizeof(WCHAR));
                            dwStrPos+=78;
                            dwCount++;
                            lSets78--;
                            //
                            // Don't put in wrapper if last line and no spaces left
                            //
                            if (lSets78 !=0 || dwLeft != 0) {
                                    memcpy(rgszResult[iNextString]+dwStrPos,
                                           szWrapper, 
                                           dwWrapper * sizeof(WCHAR));
                                    dwStrPos+=dwWrapper;
                            }
                        }
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp+(dwCount*78), 
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    } else {
                        memcpy(rgszResult[iNextString]+dwStrPos, szTemp, dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    }

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szTrailer, 
                           (dwTrailer+1) * sizeof(WCHAR));

                    iNextString++;
                    MemFree(szTemp);
                    szTemp = NULL;

                    if (bBackLink || fAttrsWithRange) {
                        rgszResult[iNextString++]=MemAllocStrW_E(L"-\r\n");
                    }
                }
            }
            else {

                //
                // Get the values if we haven't got them yet
                //
                if (rgszValW == NULL) {
                    ASSERT(szAttributeW == NULL);
                    szAttributeW = MemAllocStrW_E(szAttribute);
                    rgszValW = ldap_get_valuesW( pLdap, pMessage, szAttributeW);
                }

                //
                // String Value
                //
                for (i=0; rgpVals[i]!=NULL; i++) {
                    if (bBackLink) {
                        WCHAR szBuffer[256];
                        rgszResult[iNextString++]=MemAllocStrW_E(L"\r\n");
                        rgszResult[iNextString++]=MemAllocStrW_E(szTmpDN); //copy the DN
                        rgszResult[iNextString++]=MemAllocStrW_E(L"changetype: modify\r\n");
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }
                    else if(fAttrsWithRange) {
                        WCHAR szBuffer[256];
                        swprintf(szBuffer, L"add: %s\r\n", szAttrNoRange);
                        rgszResult[iNextString++]=MemAllocStrW_E(szBuffer);
                    }

                    //
                    // Only print last value if ObjectClass
                    //
                    if(!bNotInObjectClass) {
                        if (g_nClassLast == LOC_NOTSET) {
                            if ( _stricmp( rgpVals[0]->bv_val, "top") == 0 ) {
                                g_nClassLast = LOC_LAST;
                            }
                            else {
                                g_nClassLast = LOC_FIRST;
                            }
                        }
                        if (g_nClassLast == LOC_LAST) {
                            if (rgpVals[i+1]!=NULL) {
                                continue;
                            }
                        }
                        else {
                            if (i!=0) {
                                break;
                            }
                        }
                    }

                    ASSERT(szReplacedAttrW == NULL);
                    ASSERT(szTemp == NULL);

                    szTempW = rgszValW[i];
                    if (g_szExportFrom) {
                        SubStrW(rgszValW[i],
                                g_szExportFrom,
                                g_szExportTo,
                                &szReplacedAttrW);
                    }
                    if (szReplacedAttrW != NULL) {
                        szTempW = szReplacedAttrW;
                    }
                    szTemp = MemAllocStrW_E(szTempW);

                    dwTemp = wcslen(szTemp);

                    //
                    // break into sets, 78 to make room for wrapping newline and space
                    //
                    lSets78=dwTemp/78;
                    dwLeft=dwTemp%78;

                    //
                    // if the length of our name plus the length
                    // of the value exceeds 80, need to put in a wrap.
                    //
                    bWrapMarker = FALSE;
                    if ((lSets78==0) &&
                        ((dwAttrNoRange+dwRegular+dwTemp+dwTrailer)>80)) {
                        bWrapMarker = TRUE;
                        dwTemp+=dwWrapper;              // The initial wrapper
                    }
                    else if (lSets78>0) {
                        bWrapMarker = TRUE;
                        dwTemp= dwWrapper       // Initial wrapper
                                + (lSets78*(78+dwWrapper))  // Each line with wrapper
                                + dwLeft;       // last line
                    }

                    rgszResult[iNextString]=(PWSTR)
                                MemAlloc_E((dwAttrNoRange+dwRegular+dwTemp+dwTrailer+1)
                                                                    *sizeof(WCHAR));
                    memcpy(rgszResult[iNextString], szAttrNoRange, dwAttrNoRange * sizeof(WCHAR));
                    dwStrPos=dwAttrNoRange;

                    // if this attribute has a range associated with it, then
                    // we may have to make another search request to fetch the
                    // remaining values. Store off the range values for the
                    // next search request, if required.
                    if(dwAttrNoRange != dwAttrname) // range present
                        GetNewRange(szAttribute, dwAttrNoRange, szAttrNoRange,
                            dwManyAttr, pppszAttrsWithRange);

                    memcpy(rgszResult[iNextString]+dwStrPos, szRegular, dwRegular * sizeof(WCHAR));
                    dwStrPos+=dwRegular;

                    if (bWrapMarker) {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szWrapper,
                               dwWrapper * sizeof(WCHAR));
                        dwStrPos+=dwWrapper;
                    }

                    if (lSets78>0) {
                        dwCount=0;
                        while (lSets78>0) {
                            memcpy(rgszResult[iNextString]+dwStrPos,
                                   szTemp+(dwCount*78),
                                   78 * sizeof(WCHAR));
                            dwStrPos+=78;
                            dwCount++;
                            lSets78--;
                            //
                            // Don't put in wrapper if last line and no spaces left
                            //
                            if (lSets78 !=0 || dwLeft != 0) {
                                memcpy(rgszResult[iNextString]+dwStrPos,
                                       szWrapper,
                                       dwWrapper * sizeof(WCHAR));
                                dwStrPos+=dwWrapper;
                            }

                        }
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp+(dwCount*78),
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;

                    } else {
                        memcpy(rgszResult[iNextString]+dwStrPos,
                               szTemp,
                               dwLeft * sizeof(WCHAR));
                        dwStrPos+=dwLeft;
                    }

                    memcpy(rgszResult[iNextString]+dwStrPos,
                           szTrailer,
                           (dwTrailer+1) * sizeof(WCHAR));
                    iNextString++;
                    // don't need to free temp because its part of vals
                    if (bBackLink || fAttrsWithRange) {
                        rgszResult[iNextString++]=MemAllocStrW_E(L"-\r\n");
                    }
                    if (szReplacedAttrW) {
                        MemFree(szReplacedAttrW);
                        szReplacedAttrW = NULL;
                    }
                    if (szTemp) {
                        MemFree(szTemp);
                        szTemp = NULL;
                    }
                }
            }
            if (szAttributeW) {
                MemFree(szAttributeW);
                szAttributeW = NULL;
            }
            if(szAttrNoRange) {
                MemFree(szAttrNoRange);
                szAttrNoRange = NULL;
            }
            if (rgszValW) {
                ldap_value_freeW(rgszValW);
                rgszValW = NULL;
            }
            ldap_value_free_len(rgpVals);
        }

        // ldap_memfree((PWSTR)pBerElement);
        pBerElement=NULL;

        *prgReturn = rgszResult;
        rgszResult[iNextString] = NULL;

        for (dwEveryAttr=0; dwEveryAttr < dwManyAttr; dwEveryAttr++) {
            MemFree(rgszAttributes[dwEveryAttr]);
        }
        MemFree(rgszAttributes);

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ProcessException(GetExceptionCode(), &error);
    }
    
    if (szDNW) {
        ldap_memfreeW(szDNW);
    }
    if (szDN) {
        MemFree(szDN);
    }
    if (szDNFinal) {
        MemFree(szDNFinal);
    }
    if (szReplacedAttrW) {
        MemFree(szReplacedAttrW);
        szReplacedAttrW = NULL;
    }
    if (szTemp) {
        MemFree(szTemp);
        szTemp = NULL;
    }
    if (szAttributeW) {
        MemFree(szAttributeW);
        szAttributeW = NULL;
    }
    if(szAttrNoRange) {
        MemFree(szAttrNoRange);
        szAttrNoRange = NULL;
    }
    if(szTmpDN) {
        MemFree(szTmpDN);
        szTmpDN = NULL;
    }
    if (rgszValW) {
        ldap_value_freeW(rgszValW);
        rgszValW = NULL;
    }
    if (rgszVal) {
        ldap_value_freeW(rgszVal);
        rgszVal = NULL;
    }
    return error;
}


LDIF_Error 
LDIF_FreeStrs(
    PWSTR* pszFree
    ) 
{
    long i = 0;
    LDIF_Error error;

    error.error_code = LL_SUCCESS;
    error.szTokenLast = NULL;

    if (pszFree) {
        while(pszFree[i]) {
            MemFree(pszFree[i]);
            i++;
        }
        MemFree(pszFree);
    }

    return error;
}


//+---------------------------------------------------------------------------
// Function:    samTablesCreate
//
// Synopsis:
//    The goal of this routine is to set up the tables necessary for the SAM
//    exclusions. These tables are generated form the arrays found in
//    samrestrict.h, which are PAINFULLY hand generated from src\dsamain\src\mappings.c
//    The pointers to the tables are also declared in samrestrict.h.
//    There are 6 tables that the lookup functions will need. One if for samCheckObject()
//    to check whether the objectClass in LDIF_GenerateEntry() is one under our watch.
//    The remaining 5 are for each of the objects so that samCheckAttr() can find out
//    whether the attribute we want to add is on the prohibited list. Called from LL_init()
//
// Arguments:
//    None. We access the tables and variables in samrestrict.h
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
samTablesCreate() 
{
    long i;
    PNAME_MAP   NtiPtr;
    NAME_MAP    NtiElem;
    PNAME_MAP   PElemTemp;
    BOOLEAN     NewElem;

    // note that an exception will be generated if the below fails
    pSamObjects = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pSamObjects, NtiComp, NtiAlloc, NtiFree, NULL);


    i = 0;
    while(SamObjects[i]) {
        NtiElem.szName=SamObjects[i];
        //
        // The index information is important here, because it wil be returned
        // by samCheckObject() if the object is found and passed to
        // samCheckAttr() so it knows which table to look at
        //
        NtiElem.index = i+1;
        RtlInsertElementGenericTable(pSamObjects,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    //
    // Then create the tables for each object. This will be used by
    // samCheckAttr()
    //
    pServerAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pServerAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(samServer[i]) {
        NtiElem.szName=samServer[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pServerAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pDomainAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pDomainAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(domain[i]) {
        NtiElem.szName=domain[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pDomainAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pGroupAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(group[i]) {
        NtiElem.szName=group[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pGroupAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pLocalGroupAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pLocalGroupAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(localgroup[i]) {
        NtiElem.szName=localgroup[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pLocalGroupAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pUserAttrs = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pUserAttrs, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(user[i]) {
        NtiElem.szName=user[i];
        NtiElem.index=0;
        RtlInsertElementGenericTable(pUserAttrs,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }

    pSpecial = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(pSpecial, NtiComp, NtiAlloc, NtiFree, NULL);

    i = 0;
    while(special[i]) {
        NtiElem.szName=special[i];
        NtiElem.index=actions[i];  //The what-to-do
        if (NtiElem.index==0) {
            // Special table and action table mismatch
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        RtlInsertElementGenericTable(pSpecial,
                                    &NtiElem,
                                    sizeof(NAME_MAP),
                                    &NewElem);
        if (NewElem==FALSE) {
            // Re-insertion of indexing entry!
            RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        i++;
    }
}


//+---------------------------------------------------------------------------
// Function:    samTablesDestroy
//
// Synopsis:
//    Destroy the tables created by samTablesCreate()
//    called from LDIF_CleanUp().
//
// Arguments:
//
// Returns:
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
void 
samTablesDestroy() 
{
     PNAME_MAP   pNameMap;

     if (pSamObjects) {
        for (pNameMap = RtlEnumerateGenericTable(pSamObjects, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pSamObjects, TRUE))
            {
                RtlDeleteElementGenericTable(pSamObjects, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pSamObjects)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pSamObjects);
        pSamObjects=NULL;
     }

     if (pServerAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pServerAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pServerAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pServerAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pServerAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pServerAttrs);
        pServerAttrs=NULL;
     }

     if (pDomainAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pDomainAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pDomainAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pDomainAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pDomainAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pDomainAttrs);
        pDomainAttrs=NULL;
     }

     if (pGroupAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pGroupAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pGroupAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pGroupAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pGroupAttrs);
        pGroupAttrs=NULL;
     }

     if (pLocalGroupAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pLocalGroupAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pLocalGroupAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pLocalGroupAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pLocalGroupAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pLocalGroupAttrs);
        pLocalGroupAttrs=NULL;
     }

     if (pUserAttrs) {
        for (pNameMap = RtlEnumerateGenericTable(pUserAttrs, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pUserAttrs, TRUE))
            {
                RtlDeleteElementGenericTable(pUserAttrs, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pUserAttrs)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pUserAttrs);
        pUserAttrs=NULL;
     }

     if (pSpecial) {
        for (pNameMap = RtlEnumerateGenericTable(pSpecial, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(pSpecial, TRUE))
            {
            //printf("Deleting %s.\n",pNameMap->name);
                RtlDeleteElementGenericTable(pSpecial, pNameMap);
            }

        if (RtlIsGenericTableEmpty(pSpecial)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }

        MemFree(pSpecial);
        pSpecial=NULL;
     }

    //
    // Removing RTL Table and attributes .
    // Pointers in NTI points to strings in orginal list and need not be freed.
    //
    if (g_pOmitTable) {
        for (pNameMap = RtlEnumerateGenericTable(g_pOmitTable, TRUE);
             pNameMap != NULL;
             pNameMap = RtlEnumerateGenericTable(g_pOmitTable, TRUE)) {
            PWSTR szLinkDN;
            szLinkDN = pNameMap->szName;
            RtlDeleteElementGenericTable(g_pOmitTable, pNameMap);
            MemFree(szLinkDN);
        }
        if (RtlIsGenericTableEmpty(g_pOmitTable)==FALSE) {
            //RaiseException(LL_INTERNAL, 0, 0, NULL);
        }
        MemFree(g_pOmitTable);
        g_pOmitTable = NULL;
    }

    if (g_pBacklinkHashTable) {
        UINT i;
        for (i=0;i<g_nBacklinkCount;i++) {
            if (g_pBacklinkHashTable[i].bUsed) {
                MemFree(g_pBacklinkHashTable[i].value);
            }
        }
        MemFree(g_pBacklinkHashTable);
        g_pBacklinkHashTable = NULL;
    }
}

//+---------------------------------------------------------------------------
// Function:    samCheckObject
//
// Synopsis:
//  samCheckObject() - this function will be called
//  from LDIF_GenerateEntry() to determine whether the
//  object we are looking at is on our sam watch list.
//
// Arguments:
//  class - a value of the objectClass attribute.
//          This function will be called
//          on every value of objectClass received to
//          determine whether this object or any of its
//          ancestors are on our watch list.
//
// Returns:
//          0 if the object was not found
//          or 1-5 indicating which table samCheckAttr()
//          should look at it. This number was set by samTablesCreate()
//          in the index member of the table entry.
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
int 
samCheckObject(
    PWSTR *rgszVal
    )
{
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap;
    WCHAR szObjClass[MAX_PATH];
    int i = 0;

    NameMap.szName = szObjClass;
    NameMap.index = 0;

    //
    // Find the last item
    //
    while (rgszVal[i]!=NULL) {
        i++;
    }
    i--;

    //
    // Search from end to beginning to speed up common objects such as group
    // and users
    //
    while (i>=0) {
        wcscpy(szObjClass,rgszVal[i]);

        pNameMap = RtlLookupElementGenericTable(pSamObjects, &NameMap);
    
        if (pNameMap) 
            return pNameMap->index;

        i--;
    }
    return 0;
}


//+---------------------------------------------------------------------------
// Function:    samCheckAttr
//
// Synopsis:
//      Given the number of the table to look at and
//      an attribute name, this function will figure out
//      if the attribute is on the "no-no" list. This function
//      gets the number returned by samCheckObject();
//
// Arguments:
//      attribute: the name of the attrbiute to look up
//      table:     the number of the table to look at
//
// Returns:
//      TRUE  - this attrbiute is prohibited
//      FALSE - this attribute is allowed
//
// Modifies:      -
//
// History:    22-7-97   t-romany                   Created.
//
//----------------------------------------------------------------------------
BOOLEAN 
samCheckAttr(
    PWSTR szAttribute, 
    int TableType
    ) 
{
    NAME_MAP    NameMap;
    PNAME_MAP   pNameMap = NULL;

    NameMap.szName = szAttribute;
    NameMap.index = 0;

    switch(TableType) {
        case 1:
            pNameMap = RtlLookupElementGenericTable(pServerAttrs, &NameMap);
            break;
        case 2:
            pNameMap = RtlLookupElementGenericTable(pDomainAttrs, &NameMap);
            break;
        case 3:
            pNameMap = RtlLookupElementGenericTable(pGroupAttrs, &NameMap);
            break;
        case 4:
            pNameMap = RtlLookupElementGenericTable(pLocalGroupAttrs, &NameMap);
            break;
        case 5:
            pNameMap = RtlLookupElementGenericTable(pUserAttrs, &NameMap);
            break;
        default:
            RaiseException(LL_INTERNAL, 0, 0, NULL);
    }

    if (pNameMap) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
// Function:    LoadedCompare
//
// Synopsis:    This function will be used with qsort to sink member attributes
//              down to the end of the attributes list so that we may easily
//              separate them into a changetype: modify.
//
// Arguments:
//              const void *arg1  - A pointer to an element in our array
//              const void *arg2  - Same
//
// Returns:     Result of comparison. (0, <0, >0)
//
// Modifies:      -
//
// History:    22-7-97   t-RomanY Created.
//
//----------------------------------------------------------------------------
int __cdecl 
LoadedCompare(
    const void *pArg1, 
    const void *pArg2
    ) 
{
    int nIsMember1;
    int nIsMember2;
    int return_val;

    PWSTR pszElem1 = StripRangeFromAttr(*(PWSTR *)pArg1);
    PWSTR pszElem2 = StripRangeFromAttr(*(PWSTR *)pArg2);

    nIsMember1 = SCGetAttByName(wcslen(pszElem1),
                                 pszElem1);
    nIsMember2 = SCGetAttByName(wcslen(pszElem2),
                                 pszElem2);

    //
    // beginning case is that they are both members
    //
    if (nIsMember1&&nIsMember2) {
        
        return_val = 0;   // equal
    }

    else if (nIsMember1) {
        return_val =  1;   // greater
    }

    else if (nIsMember2) {
        return_val = -1;  // lesser
    }

    //
    // If neither are members, we just compare
    //
    else
        return_val = _wcsicmp(pszElem1, pszElem2);

    if(pszElem1)
        MemFree(pszElem1);
    if(pszElem2)
        MemFree(pszElem2);

    return return_val;
}

__inline ULONG 
SCNameHash(
    ULONG size, 
    PWSTR pVal, 
    ULONG count
    )
{
    ULONG val=0;
    while(size--) {
        //
        // Map A->a, B->b, etc.  Also maps @->', but who cares.
        //
        val += (*pVal | 0x20);
        pVal++;
    }
    return (val % count);
}

int
SCGetAttByName(
    ULONG ulSize,
    PWSTR pVal
    )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns non-zero if exist, 0 otherwise.

--*/
{
    ULONG i;

    if (!g_pBacklinkHashTable) {
        return FALSE;
    }

    i=SCNameHash(ulSize,pVal,g_nBacklinkCount);
    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }


    while (g_pBacklinkHashTable[i].bUsed &&            // this hash spot refers to an object,
          (g_pBacklinkHashTable[i].length != ulSize || // but the size is wrong
           _wcsicmp(g_pBacklinkHashTable[i].value,pVal))) // or the value is wrong
    {
        i++;
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }

    return (g_pBacklinkHashTable[i].bUsed);
}

int
SCInsert(
    ULONG ulSize,
    PWSTR pVal
    )
/*++

Routine Description:

    Find an attcache given its name.

Arguments:
    ulSize - the num of chars in the name.
    pVal - the chars in the name
    ppAttcache - the attribute cache returned

Return Value:
    Returns TRUE if successfull, return 0 if duplicate

--*/
{
    ULONG i = SCNameHash(ulSize,pVal,g_nBacklinkCount);

    if (i >= g_nBacklinkCount) {
        // should never happen (SCNameHash should always return a value
        // of i that's in range)
        i=0;
    }

    while (g_pBacklinkHashTable[i].bUsed)
    {
        if ((g_pBacklinkHashTable[i].length == ulSize) &&
            (_wcsicmp(g_pBacklinkHashTable[i].value,pVal) == 0)) {
            return FALSE;
        }

        i++;
        if (i >= g_nBacklinkCount) {
            i=0;
        }
    }
    
    g_pBacklinkHashTable[i].length = ulSize;
    g_pBacklinkHashTable[i].value = MemAllocStrW_E(pVal);
    if (!g_pBacklinkHashTable[i].value) {
        return FALSE;
    }    
    g_pBacklinkHashTable[i].bUsed = TRUE;
    return TRUE;
}

void 
CreateOmitBacklinkTable(
    LDAP *pLdap,
    PWSTR *rgszOmit,
    DWORD dwFlag,
    PWSTR *ppszNamingContext,
    BOOL *pfPagingAvail,
    BOOL *pfSAMAvail)
{
    HRESULT hr = S_OK;
    LDAPMessage     *pSearchMessage = NULL;
    LDAPMessage     *pMessage = NULL;
    struct berelement *pBerElement = NULL;

    PWSTR *rgszVal = NULL;
    PWSTR *rgszValW = NULL;
    PWSTR szAttribute = NULL;
    PWSTR szAttributeW = NULL;

    PWSTR szTemp = NULL;
    PWSTR szDN = NULL;
    PWSTR szLinkCN = NULL;

    PWSTR szSchemaPath = NULL;

    ULONG i;
    ULONG nCount = 0;
    ULONG iLinkID = 0;

    NAME_MAP NtiElem;
    BOOLEAN bNewElem;
    BOOLEAN bNamingContext = (BOOLEAN)(dwFlag & LL_INIT_NAMINGCONTEXT);
    BOOLEAN bBacklink = (BOOLEAN)(dwFlag & LL_INIT_BACKLINK);
    BOOL fSAMAvail = FALSE;
    BOOL fPagingAvail = FALSE;

    ULONG LdapError;
    ULONG msgnum;

    //
    // Generating OMIT table
    //
    g_pOmitTable = (PRTL_GENERIC_TABLE) MemAlloc_E(sizeof(RTL_GENERIC_TABLE));
    RtlInitializeGenericTable(g_pOmitTable,
                              NtiComp,
                              NtiAlloc,
                              NtiFree,
                              NULL);

    if (rgszOmit) {
        i = 0;
        while(rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW_E(rgszOmit[i]);
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP),
                                         &bNewElem);
            if (!bNewElem) {
                RaiseException(LL_DUPLICATE, 0, 0, NULL);
            }
            i++;
        }
    }

    //
    // We search rootdse either we search for backlinks, need to get the 
    // base context, or if we need to check whether paging is available or not
    //
    if (bBacklink || bNamingContext || pfPagingAvail) {
        
        msgnum = ldap_searchW(pLdap,
                              NULL,
                              LDAP_SCOPE_BASE,
                              L"(objectClass=*)",
                              g_rgszSchemaList,
                              0);

        LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
    
        if ( LdapError != LDAP_SUCCESS ) {
            //
            // RootDSE search fails
            // pfPagingAvail will be FALSE as well
            //
            if (ppszNamingContext)
                *ppszNamingContext = NULL;
            BAIL();         
        }

        for ( pMessage = ldap_first_entry( pLdap,
                                           pSearchMessage );
              pMessage != NULL;
              pMessage = ldap_next_entry( pLdap,
                                             pMessage ) ) {
            for (   szAttribute = ldap_first_attributeW( pLdap, pMessage, &pBerElement );
                    szAttribute != NULL;
                    szAttribute = ldap_next_attributeW( pLdap, pMessage, pBerElement ) ) {

                    rgszVal = ldap_get_valuesW( pLdap, pMessage, szAttribute );
                    if (_wcsicmp(L"schemaNamingContext",szAttribute) == 0) {
                        szSchemaPath = MemAllocStrW_E(rgszVal[0]);

                    }
                    else if (_wcsicmp(L"defaultNamingContext",szAttribute) == 0) {
                        *ppszNamingContext = MemAllocStrW_E(rgszVal[0]);
                    }
                    else if (_wcsicmp(L"supportedControl",szAttribute) == 0) {
                        DWORD i = 0;
                        while (rgszVal[i]) {
                            if (wcscmp(rgszVal[i],LDAP_PAGED_RESULT_OID_STRING_W) == 0) {
                                fPagingAvail = TRUE;
                                break;
                            }
                            i++;
                        }
                    }
                    else {
                        RaiseException(LL_INITFAIL, 0, 0, NULL);
                    }
                    ldap_value_freeW(rgszVal);
                    rgszVal = NULL;
            }
        }

        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
            pSearchMessage = NULL;
        }
    }

    if (bBacklink) {
        //
        // We are taking all attributes that are linked attributes, and any
        // attribute of DN types as backlinked attributes
        //
        msgnum = ldap_searchW(pLdap,
                                szSchemaPath,
                                LDAP_SCOPE_ONELEVEL,
                                L"(&(objectClass= attributeSchema)(|(linkid=*)(attributeSyntax=2.5.5.1)))",
                                g_rgszAttrList,
                                0);

        LdapError = LdapResult(pLdap, msgnum, &pSearchMessage);
        
        if ( LdapError != LDAP_SUCCESS ) {
            //
            // we'll bail, saying sam support is not available
            //
            BAIL();         
        }
        MemFree(szSchemaPath);
        szSchemaPath = NULL;

        nCount = ldap_count_entries(pLdap,
                                    pSearchMessage);

        g_nBacklinkCount = nCount * 2;
        if (nCount == 0) {
            g_pBacklinkHashTable = NULL;
        }
        else {
            g_pBacklinkHashTable = MemAlloc_E(g_nBacklinkCount * sizeof(HASHCACHESTRING));
            memset(g_pBacklinkHashTable,0,g_nBacklinkCount * sizeof(HASHCACHESTRING));
        }

        //
        // Always insert Primary Group. It is always a backlink. It always refer to some
        // other group
        //
        if (SCInsert(wcslen(g_szPrimaryGroup),
                     g_szPrimaryGroup) == FALSE) {
            RaiseException(LL_INITFAIL, 0, 0, NULL);
        }

        for ( pMessage = ldap_first_entry( pLdap,
                                           pSearchMessage );
              pMessage != NULL;
              pMessage = ldap_next_entry( pLdap,
                                          pMessage ) ) {
            BOOLEAN bLinkIDPresent = FALSE;
            for (   szAttributeW = ldap_first_attribute( pLdap, pMessage, &pBerElement );
                    szAttributeW != NULL;
                    szAttributeW = ldap_next_attribute( pLdap, pMessage, pBerElement ) ) {
                rgszValW = ldap_get_values( pLdap, pMessage, szAttributeW );
                if (!_wcsicmp(L"ldapdisplayname",szAttributeW)) {
                    szLinkCN = MemAllocStrW_E(rgszValW[0]);
                }
                else {
                    szTemp = MemAllocStrW_E(rgszValW[0]);

                    iLinkID = _wtoi(szTemp);
                    MemFree(szTemp);
                    bLinkIDPresent = TRUE;
                }
                ldap_value_free(rgszValW);
            }
            //
            // If it is not a linked ID (and thus a DN type attribute) or if it
            // is the source linked ID (source linked ID are even while
            // targets are odd)
            //
            if (((!bLinkIDPresent) || ((iLinkID % 2) == 0))) {
                //
                // Ignore 'distinguishname and objectcategory' because they are
                // DN attributes that exist in every object
                //
                if ((_wcsicmp(szLinkCN, L"objectCategory") == 0) ||
                    (_wcsicmp(szLinkCN, L"distinguishedName") == 0)) {
                    MemFree(szLinkCN);
                    continue;
                }

                //
                // Insert into Backlink Hash
                //
                if (SCInsert(wcslen(szLinkCN),
                             szLinkCN) == FALSE) {
                    RaiseException(LL_INITFAIL, 0, 0, NULL);
                }
                MemFree(szLinkCN);
            }
            else {
                //
                // Insert into our Omit Table
                //
                NtiElem.szName = szLinkCN;
                NtiElem.index = 0;
                RtlInsertElementGenericTable(g_pOmitTable,
                                             &NtiElem,
                                             sizeof(NAME_MAP),
                                             &bNewElem);
                if (!bNewElem) {
                    RaiseException(LL_INITFAIL, 0, 0, NULL);
                }
            }
        }

        if (pSearchMessage) {
            ldap_msgfree(pSearchMessage);
        }
        i = 0;
        while(g_rgszOmit[i]) {
            NtiElem.szName = MemAllocStrW_E(g_rgszOmit[i]);
            NtiElem.index = 0;
            RtlInsertElementGenericTable(g_pOmitTable,
                                         &NtiElem,
                                         sizeof(NAME_MAP),
                                         &bNewElem);
            i++;
        }
        fSAMAvail = TRUE;
    }

error:
    if (szSchemaPath) {
        MemFree(szSchemaPath);
        szSchemaPath = NULL;
    }
    if (pfPagingAvail) {
        *pfPagingAvail = fPagingAvail;
    }
    if (pfSAMAvail) {
        *pfSAMAvail = fSAMAvail;
    }
    
    return;
}

//--------------------------------------------------------------------------
// GetNewRange
//
// This function checks if the server returned a multivalued attribute with
// a range specifier. In this case, it may be required to fetch the
// remaining values of the attribute in a separate search request. To specify
// the end of the range, the server uses * as the upper limit in the range
// it returns. If the server returns range0-999 as the range, the next client
// request will contain 1000-*, where * specifies the end of the range.
//
//---------------------------------------------------------------------------
void GetNewRange(PWSTR szAttribute, DWORD dwAttrNoRange,
                 PWSTR szAttrNoRange, DWORD dwNumAttr, 
                 PWSTR **pppszAttrsWithRange)
{
    PWSTR szNewRangeAttr = NULL;
    int iUpperLimit, iLowerLimit, iRangeIndex, i = 0;
    WCHAR hyphen, cTmp;

    int SpaceToAlloc = 0;

    // make sure the attribute returned by the server has a range specifier
    if( (szAttribute[dwAttrNoRange] != L';') || 
        (_wcsnicmp(&szAttribute[dwAttrNoRange+1],L"range=", wcslen(L"range="))) ) 
        return;

    // get the upper and lower limits of the range returned by the server
    iRangeIndex = dwAttrNoRange+1+wcslen(L"range="); 
    swscanf(&szAttribute[iRangeIndex], L"%d %c %c", &iLowerLimit, &hyphen, 
                                                                  &cTmp);
    if(hyphen != L'-')
        return;

    if(cTmp == L'*')
    // end of values for this attribute
        return;
    else if((cTmp < L'0') || (cTmp > L'9'))
    // bad upper limit
        return;
    else // read the upper limit
        swscanf(&szAttribute[iRangeIndex], L"%d %c %d", &iLowerLimit, &hyphen,
                                                        &iUpperLimit);

    // 100 chars to hold the "range=..." string
    SpaceToAlloc = (dwAttrNoRange + 100) * sizeof(WCHAR);

    szNewRangeAttr = MemAlloc_E(SpaceToAlloc);
    wsprintf(szNewRangeAttr, L"%s;Range=%d-*", szAttrNoRange, iUpperLimit+1);

    // make sure that this attribute is not already marked for another
    // search request. This can happen, if object X returned a range for this
    // attribute and then object Y also returned a range for the same attr.
    if(*pppszAttrsWithRange)
    {
        while((*pppszAttrsWithRange)[i])
        {
            if(!_wcsicmp(szNewRangeAttr, (*pppszAttrsWithRange)[i]))
            // this attr has already been marked for another search request
            {
                MemFree(szNewRangeAttr);
                return;
            }
            
            i++;
        }
    }

    // the attribute is not already marked for another search

    if(NULL == (*pppszAttrsWithRange))
        // allocate space for attribute + NULL terminator 
        *pppszAttrsWithRange = (PWSTR *) MemAlloc_E(2 * sizeof(PWSTR));
    else
        *pppszAttrsWithRange = MemRealloc_E(*pppszAttrsWithRange, 
                                          (i + 2) * sizeof(PWSTR));

    (*pppszAttrsWithRange)[i] = szNewRangeAttr;
    (*pppszAttrsWithRange)[i+1] = NULL;

    return;
}

//----------------------------------------------------------------------------
// StripRangeFromAttr
//
// This function strip off the range specifier from an attribute name and
// returns just teh attribute name in a newly allocated string. For example, if
// "member;0-999" is passed to this function, it returns "member".
//
//----------------------------------------------------------------------------
PWSTR StripRangeFromAttr(PWSTR szAttribute)
{
    PWSTR szNoRangeAttr = NULL;
    DWORD dwAttrLen = wcslen(szAttribute), i;

    szNoRangeAttr = MemAlloc_E((wcslen(szAttribute)+1) * sizeof(WCHAR));

    for(i = 0; i <= dwAttrLen; i++)
        if( (szAttribute[i] == L';') && 
            (!_wcsnicmp(&szAttribute[i+1], L"range=", wcslen(L"range="))) 
          )
        // found the range specifier. 
            szNoRangeAttr[i] = L'\0';
        else
            szNoRangeAttr[i] = szAttribute[i];

    return szNoRangeAttr;
}

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\ldifldap.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    ldifldap.c

Abstract:

    Header for main support routine for ldif parser and generaetor

Environment:

    User mode

Revision History:

    07/17/99 -t-romany-
        Created it

    05/12/99 -felixw-
        Rewrite + unicode support

--*/
#ifndef _LDIFLDAP_H
#define _LDIFLDAP_H

#include <winldap.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <debug.h>

#define UNICODE_MARK 0xFEFF

//
// Structure Definitions
//
typedef struct object {
    LDAPModW    **ppMod;
    PWSTR       pszDN;
} LDIF_Object;

typedef struct _hashcachestring {
    PWSTR    value;
    ULONG    length;
    BOOLEAN  bUsed;
} HASHCACHESTRING;

//
// The node for the linked list built up while parsing an attrval spec list 
//
struct l_list {
    LDAPModW        *mod;
    struct l_list   *next;
};

//
// The name table entry used for doing things based on the attrname.
// Used in NameTableProcess.
//
struct name_entry {
    LDAPModW_Ext    *mod;   
    PWSTR           *next_val;
    struct berval   **next_bval;
    long            count;
}; 

//
// typedefs for structures to be stored in name to index mapping tables 
//
typedef struct _NAME_MAP {
    PWSTR szName;
    long  index;
} NAME_MAP, *PNAME_MAP;

typedef struct _NAME_MAPW {
    PWSTR szName;
    long  index;
} NAME_MAPW, *PNAME_MAPW;


//
// Switches for nametable operations
//
#define BINARY          0 /* The value is a binary to be berval'd */
#define REGULAR         1 /* Regular text value */
#define ALLOCATED_B     0 /* Memory has been allocated for binary */
#define ALLOCATED       1 /* Memory has been allocated for regular */  
#define NOT_ALLOCATED   2 /* memory has not yet been allocated */

//
// The commands the parser issues to the lexer for switching lexical modes
//
enum LEXICAL_MODE {
    NO_COMMAND             =  0,
    C_ATTRNAME             =  1,
    C_SAFEVAL              =  2,
    C_NORMAL               =  3,
    C_M_STRING             =  4,
    C_M_STRING64           =  5,
    C_DIGITREAD            =  7,
    C_URLSCHEME            =  9,
    C_TYPE                 =  10,
    C_CLEAR                =  12,
    C_URLMACHINE           =  13,
    C_CHANGETYPE           =  14,
    C_SPECIAL1             =  15,
    C_ATTRNAMENC           =  16,
    C_SEPBC                =  17
};

//
//  Parser return codes.
//  I am breaking with convention here and using the return code of yyparse to 
//  indicate to the calling funciton the type of entry that was read. (Usually 
//  yyparse returns 0 on success and non-0 otherwise. 
//
//
enum RETURN_CODE {
    LDIF_REC               = 1,  // entry is a regular add
    LDIF_CHANGE            = 2  // entry is a change
};

//
// Below are the parameters to GenerateModFromList()
//
enum CONVERTLIST_PARAM {
    NORMALACT              = 0, // Take the default action
    PACK                   = 1, // If there are several attrval-spec's with 
                                // the same attrname place them into one 
                                // LDAPMod struct (As multiple values)
                                //  
    EMPTY                  = 2  // An empty list
};

// 
// Different commands for name table operations
//
enum NAMETABLE_OP {
    SETUP   = 1,
    COUNT   = 2,  
    ALLOC   = 3,
    PLACE   = 4
};

enum CLASS_LOC {
    LOC_NOTSET,
    LOC_FIRST,
    LOC_LAST
};

enum FileType {
    F_NONE      = 0,
    F_REC       = 1,
    F_CHANGE    = 2
};

extern int yyparse();

LDAPModW*  GenereateModFromAttr(PWSTR type, PBYTE value, long bin);
LDAPModW** GenerateModFromList(int);
void       AddModToSpecList(LDAPModW *elem);
void       FreeAllMods(LDAPModW** mods);
void       SetModOps(LDAPModW** mods, int op);
void       ChangeListAdd(struct change_list *elem);
int        NameTableProcess(
                  struct name_entry table[], 
                  long table_size, 
                  int op, 
                  int ber, 
                  LDAPModW  *mod,
                  PRTL_GENERIC_TABLE NtiTable);
void       CreateOmitBacklinkTable(
                  LDAP *pLdap,
                  PWSTR *rgszOmit,
                  DWORD dwFlag,
                  PWSTR *ppszNamingContext,
                  BOOL *pfPagingAvail,
                  BOOL *pfSAMAvail);
void       samTablesCreate();
void       samTablesDestroy();
int        samCheckObject(PWSTR *rgpVals);
BOOLEAN    samCheckAttr(PWSTR attribute, int table);

int __cdecl LoadedCompare(const void *arg1, const void *arg2);

void        ProcessException (DWORD exception, LDIF_Error *pError);

int         SCGetAttByName(ULONG ulSize, PWSTR pVal);

void GetNewRange(PWSTR szAttribute, DWORD dwAttrNoRange,
                 PWSTR szAttrNoRange, DWORD dwNumAttr,
                 PWSTR **pppszAttrsWithRange);

PWSTR StripRangeFromAttr(PWSTR szAttribute);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\lexerinc.c ===
#include <precomp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\ldifutil.c ===
/*++

Copyright (c) 1998 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldifutil.c

ABSTRACT:

     Utilities for LDIF library

REVISION HISTORY:

--*/
#include <precomp.h>

PVOID NtiAlloc( 
    RTL_GENERIC_TABLE *Table, 
    CLONG ByteSize 
    )
{
    return(MemAlloc_E(ByteSize));
}

VOID NtiFree ( RTL_GENERIC_TABLE *Table, PVOID Buffer )
{
    MemFree(Buffer);
}


RTL_GENERIC_COMPARE_RESULTS
NtiComp( PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct ) 
{
    PNAME_MAP NameMap1 = (PNAME_MAP) FirstStruct;
    PNAME_MAP NameMap2 = (PNAME_MAP) SecondStruct;
  
    PWSTR Name1 = NameMap1->szName;
    PWSTR Name2 = NameMap2->szName;
    
    int diff;

    diff = _wcsicmp(Name1, Name2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff==0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
}

RTL_GENERIC_COMPARE_RESULTS
NtiCompW(PRTL_GENERIC_TABLE  Table,
         PVOID               FirstStruct,
         PVOID               SecondStruct ) 
{
    PNAME_MAPW NameMap1 = (PNAME_MAPW) FirstStruct;
    PNAME_MAPW NameMap2 = (PNAME_MAPW) SecondStruct;
  
    PWSTR Name1 = NameMap1->szName;
    PWSTR Name2 = NameMap2->szName;
    
    int diff;

    diff = _wcsicmp(Name1, Name2);

    if (diff<0) {
        return GenericLessThan;
    } 
    else if (diff==0) {
        return GenericEqual;
    } 
    else {
        return GenericGreaterThan;
    }
}

/*
//+---------------------------------------------------------------------------
// Function:  SubStr
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            S_OK with szOutput = NULL;
//            This function raises an exception when there are memory errors
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubStr(LPSTR szInput,
             LPSTR szFrom,
             LPSTR szTo,
             LPSTR *pszOutput)
{
    DWORD dwErr = 0;
    LPSTR szOutput = NULL;
    LPSTR szLast = NULL;
    LPSTR szReturn = NULL;
    DWORD cchToCopy = 0;        // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    if (!szFrom || !szTo) {
        *pszOutput = NULL;
        return E_FAIL;
    }

    if (!szInput) {
        *pszOutput = NULL;
        return S_OK;
    }

    cchFrom    = strlen(szFrom);
    cchTo      = strlen(szTo);
    cchInput   = strlen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = strstr(szInput,
                      szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return S_OK;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = strstr(szOutput,
                          szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (LPSTR)MemAlloc_E(sizeof(char) * cchReturn);
    if (!szReturn) {
        dwErr = 1;
        goto error;
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = strstr(szInput,
                      szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    strncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    strcat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = strstr(szInput,
                      szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        strncat(szReturn,
                szInput,
                cchToCopy);
        strcat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = strstr(szInput,
                          szFrom);
    }

    strcat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (dwErr);
} 
*/            

//+---------------------------------------------------------------------------
// Function:  SubStrW
//
// Synopsis:  substitute every occurences of 'szFrom' to 'szTo'. Will allocate
//            a return string. It must be MemFreed by MemFree()  
//            If the intput does not contain the 'szFrom', it will just return 
//            S_OK with szOutput = NULL;
//
// Arguments:   
//
// Returns:     
//
// Modifies:      -
//
// History:    6-9-97   FelixW         Created.
//
//----------------------------------------------------------------------------
DWORD SubStrW(PWSTR szInput,
              PWSTR szFrom,
              PWSTR szTo,
              PWSTR *pszOutput)
{
    DWORD dwErr = 0;
    PWSTR szOutput = NULL;
    PWSTR szLast = NULL;
    PWSTR szReturn = NULL;
    DWORD cchToCopy = 0;        // count of number of char to copy
    DWORD cchReturn = 0;
    DWORD cchFrom;
    DWORD cchTo;
    DWORD cchInput;
    DWORD cSubString = 0;       // count of number of substrings in input

    if (!szFrom || !szTo) {
        *pszOutput = NULL;
        return E_FAIL;
    }

    if (!szInput) {
        *pszOutput = NULL;
        return S_OK;
    }

    cchFrom    = wcslen(szFrom);
    cchTo      = wcslen(szTo);
    cchInput   = wcslen(szInput);
    *pszOutput = NULL;

    //
    // Does the substring exist?
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    if (!szOutput) {
        *pszOutput = NULL;
        return S_OK;
    }

    // 
    // Counting substrings
    //
    while (szOutput) {
        szOutput += cchFrom;
        cSubString++;
        szOutput = wcsistr(szOutput,
                           szFrom);
    }

    //
    // Allocating return string
    //
    cchReturn = cchInput + ((cchTo - cchFrom) * cSubString) + 1;
    szReturn = (PWSTR)MemAlloc(sizeof(WCHAR) * cchReturn);
    if (!szReturn) {
        dwErr = 1;
        goto error;
    };
    szReturn[0] = '\0';
    
    //
    // Copying first string before sub
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    cchToCopy = (ULONG)(szOutput - szInput);
    wcsncat(szReturn,
            szInput,
            cchToCopy);
    
    //
    // Copying 'To' String over
    //
    wcscat(szReturn,
           szTo);
    szInput = szOutput + cchFrom;

    //
    // Test for more 'from' string
    //
    szOutput = wcsistr(szInput,
                       szFrom);
    while (szOutput) {
        cchToCopy = (ULONG)(szOutput - szInput);
        wcsncat(szReturn,
                szInput,
                cchToCopy);
        wcscat(szReturn,
                szTo);
        szInput= szOutput + cchFrom;
        szOutput = wcsistr(szInput,
                           szFrom);
    }

    wcscat(szReturn,
           szInput);
    *pszOutput = szReturn;

error:
    return (dwErr);
};



//
// Case-insensitive version of wcsstr.
// Based off the Visual C++ 6.0 CRT
// sources.
//
wchar_t * __cdecl wcsistr (
        const wchar_t * wcs1,
        const wchar_t * wcs2
        )
{
        wchar_t *cp = (wchar_t *) wcs1;
        wchar_t *s1, *s2;
        wchar_t cs1, cs2;

        while (*cp)
        {
                s1 = cp;
                s2 = (wchar_t *) wcs2;

                cs1 = *s1;
                cs2 = *s2;

                if (iswupper(cs1))
                    cs1 = towlower(cs1);

                if (iswupper(cs2))
                    cs2 = towlower(cs2);


                while ( *s1 && *s2 && !(cs1-cs2) ) {

                    s1++, s2++;

                    cs1 = *s1;
                    cs2 = *s2;

                    if (iswupper(cs1))
                        cs1 = towlower(cs1);

                    if (iswupper(cs2))
                        cs2 = towlower(cs2);
                }

                if (!*s2)
                        return(cp);

                cp++;
        }

        return(NULL);
}



void
ConvertUnicodeToUTF8(
    PWSTR pszUnicode,
    DWORD dwLen,
    BYTE  **ppbValue,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode.
    This function raises an exception when memory error occurs.

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PBYTE pbValue = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the UTF8 String
    //
    pbValue = (PBYTE)MemAlloc_E((dwLen + 1) * 3 * sizeof(BYTE));

    nReturn = LdapUnicodeToUTF8(pszUnicode,
                                dwLen,
                                pbValue,
                                (dwLen + 1) * 3 * sizeof(BYTE));
    //
    // NULL terminate it
    //

    pbValue[nReturn] = '\0';

    *ppbValue = pbValue;
    *pdwLen = nReturn;
}

void
ConvertUTF8ToUnicode(
    PBYTE pVal,
    DWORD dwLen,
    PWSTR *ppszUnicode,
    DWORD *pdwLen
    )

/*++

Routine Description:

    Convert a Value from the Ansi syntax to Unicode

Arguments:

    *ppVal - pointer to value to convert
    *pdwLen - pointer to length of string in bytes

Return Value:

    S_OK on success, error code otherwise

--*/

{
    PWSTR pszUnicode = NULL;
    int nReturn = 0;

    //
    // Allocate memory for the Unicode String
    //
    pszUnicode = (PWSTR)MemAlloc_E((dwLen + 1) * sizeof(WCHAR));

    nReturn = LdapUTF8ToUnicode((PSTR)pVal,
                                dwLen,
                                pszUnicode,
                                dwLen + 1);

    //
    // NULL terminate it
    //

    pszUnicode[nReturn] = '\0';

    *ppszUnicode = pszUnicode;
    *pdwLen = (nReturn + 1);//* sizeof(WCHAR);
}

BOOLEAN IsUTF8String(
    PCSTR pSrcStr,
    int cchSrc)

/*++

Routine Description:

    Given a string, this function checks whether it is a valid UTF8 String. 
    For details about the UTF8 format, please refer to rfc2279.

Arguments:
    pSrcStr - input string
    cchSrc - number of bytes    

Return Value:

    Whether this is a UTF8 string or not

--*/

{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    PCSTR pUTF8 = pSrcStr;
    char UTF8;


    while (cchSrc--)
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //

            //
            // If we are expecting trailing bytes, this is probably an invalid
            // utf8 string
            //
            if (nTB > 0) {
                return FALSE;
            }
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;
            }
            else {
                //
                // Found a trail byte with no leading byte
                //
                return FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                return FALSE;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                if (nTB>3) {
                    return FALSE;
                }
                //
                //  decrement the number of bytes to follow.
                //
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    // We are still expecting trailing bytes, but we can't find any
    //
    if (nTB > 0) {
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// The following functions are used for importing an entry. Depending on
// whether the command specified lazy commit or not, the appropriate ldap API
// function is called. 
//
//---------------------------------------------------------------------------
ULONG LDAPAPI ldif_ldap_add_sW( 
    LDAP *ld, 
    PWCHAR dn, 
    LDAPModW *attrs[], 
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_add_extW(ld, dn, attrs, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_addW(ld, dn, attrs);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;
}

ULONG LDAPAPI ldif_ldap_delete_sW(
    LDAP *ld,
    const PWCHAR dn,
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_delete_extW(ld, dn, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_deleteW(ld, dn);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;

}

ULONG LDAPAPI ldif_ldap_modify_sW(
    LDAP *ld,
    const PWCHAR dn,
    LDAPModW *mods[],
    BOOL fLazyCommit
    )
{
    ULONG msgnum;
    ULONG Ldap_err;
    
    if (fLazyCommit) {
        Ldap_err = ldap_modify_extW(ld, dn, mods, g_ppwLazyCommitControl, NULL, &msgnum);

        if (Ldap_err == LDAP_SUCCESS) {
            Ldap_err = LdapResult(ld, msgnum, NULL);
        }
    }
    else {
        msgnum = ldap_modifyW(ld, dn, mods);

        Ldap_err = LdapResult(ld, msgnum, NULL);
    }

    return Ldap_err;


}


//-----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\precomp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Precompiled header for library

Environment:

    User mode

Revision History:

    04/29/99 -felixw-
        Created it

--*/
#ifndef _PRECOMP_H
#define _PRECOMP_H

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>
#include <rpc.h>

//
// CRunTime Includes
//
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <string.h>

//
// LDAP Includes
//
#include <winldap.h>
#include "tchar.h"

//
// LDIFDE specific includes
//
#include "ldifext.h"
#include "ldifldap.h"
#include "memory.h"
#include "ldifutil.h"
#include "async.h"

#include "lexeru.h"
#include "base64.h"
#include "dsldap.h"
#include "globals.h"

#endif // _PRECOMP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\lexeru.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lexeru.c

Abstract:

    Unicode Lexer. Designed to be compatible with lex.

Environment:

    User mode

Revision History:

    04/26/99 -felixw-
        Created it

--*/

#include <precomp.h>
#include "y_tab.h"


DEFINE_FEATURE_FLAGS(Lexer, 0);

#define ECHO(c) fwprintf(yyout, L"%c", c)
FILE *yyin      = NULL;         // Input file stream
FILE *yyout     = NULL;         // Output file stream for first phase (CLEAR)
BOOLEAN fNewFile = FALSE;
PWSTR g_szInputFileName = NULL; // name of input file

//
// Variables for Stack
//
STACK *g_pStack = NULL;
STACK *g_pFilteredCharStack = NULL;
STACK *g_pRawCharStack = NULL;


/*++

Routines Description:
    
    Character Stack Implementation. This stack is designed for handling 
    characters we get back from the file stream. It allows us to store 
    characters in the stack and roll back to the original state if the 
    charactesr that we get does not meet our requirement.

--*/

void LexerInit(PWSTR szInputFileName)
{
    g_pStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pStack->dwSize = INC;
    g_pStack->dwIndex = 0;

    g_pFilteredCharStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pFilteredCharStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pFilteredCharStack->dwSize = INC;
    g_pFilteredCharStack->dwIndex = 0;

    g_pRawCharStack = (STACK*)MemAlloc_E(sizeof(STACK));
    g_pRawCharStack->rgcStack = (PWSTR)MemAlloc_E(sizeof(WCHAR) * INC);
    g_pRawCharStack->dwSize = INC;
    g_pRawCharStack->dwIndex = 0;

    g_szInputFileName = MemAllocStrW_E(szInputFileName);
}

void LexerFree()
{
    if (g_pStack) {
        if (g_pStack->rgcStack) {
            MemFree(g_pStack->rgcStack);
            g_pStack->rgcStack = NULL;
        }
        MemFree(g_pStack);
        g_pStack = NULL;
    }

    if (g_pFilteredCharStack) {
        if (g_pFilteredCharStack->rgcStack) {
            MemFree(g_pFilteredCharStack->rgcStack);
            g_pFilteredCharStack->rgcStack = NULL;
        }
        MemFree(g_pFilteredCharStack);
        g_pFilteredCharStack = NULL;
    }

    if (g_pRawCharStack) {
        if (g_pRawCharStack->rgcStack) {
            MemFree(g_pRawCharStack->rgcStack);
            g_pRawCharStack->rgcStack = NULL;
        }
        MemFree(g_pRawCharStack);
        g_pRawCharStack = NULL;
    }

    if (g_szInputFileName) {
        MemFree(g_szInputFileName);
        g_szInputFileName = NULL;
    }
}

void Push(STACK *pStack,WCHAR c)
{
    if (pStack->dwIndex >= pStack->dwSize) {
        pStack->rgcStack = (PWSTR)MemRealloc_E(pStack->rgcStack,sizeof(WCHAR) * (pStack->dwSize + INC));
        pStack->dwSize += INC;
    }
    pStack->rgcStack[pStack->dwIndex++] = c;
}

BOOL Pop(STACK *pStack,WCHAR *pChar)
{
    if (pStack->dwIndex > 0) {
        *pChar =  pStack->rgcStack[--pStack->dwIndex];
        return TRUE;
    }
    else {
        return FALSE;
    }
}

void Clear(STACK *pStack)
{
    pStack->dwIndex = 0;
}



BOOL GetNextCharExFiltered(
    WCHAR *pChar, 
    BOOL fStart
    )

/*++

Routine Description:

    Special version of GetNextCharFiltered that stores the values in the stack. The
    RollBack function can be used to restore all the values from the stack.

Arguments:

    pChar - Character to return
    fStart - Start recording in the stack from fresh, or continue pushing

Return Value:
    
    TRUE if succeeds, FALSE if fails to get value

--*/

{
    if (GetNextCharFiltered(pChar)) {
        
        //
        // If we start from scratch, we'll clear the stack first
        //
        if (fStart) {
            Clear(g_pStack);
        }
        Push(g_pStack,*pChar);
        return TRUE;
    }
    return FALSE;
}

void RollBack()

/*++

Routine Description:

    RollBack all the characters from the stack into the file stream

Arguments:
    None

Return Value:
    None
    
--*/

{
    WCHAR c;
    while (Pop(g_pStack,&c)) {
        UnGetCharFiltered(c);
    }
}

BOOL GetNextCharFiltered(
    WCHAR *pChar
    )

/*++

Routine Description:

    Get the next character from the file stream, filtering
    out comments and line continuations

Arguments:

    pChar - Character to be returned

Return Value:
    
    TRUE if succeeds, FALSE if fails to retrieval 

--*/

{
    WCHAR c;

    if (Pop(g_pFilteredCharStack,&c)) {
        *pChar = c;
        return TRUE;
    }

    c = GetFilteredWC();
    if (c == WEOF) {
        return FALSE;
    }
    else {
        *pChar = c;
        return TRUE;
    }
}

void UnGetCharFiltered(WCHAR c) 

/*++

Routine Description:
    
    Pushes the input character back into the file stream

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/

{
    WCHAR cReturn;
    WCHAR cGet;

    if (c == WEOF) {
        ERR(("UnGetCharFiltered: Invalid input value, WEOF.\n"));
        RaiseException(LL_SYNTAX, 0, 0, NULL);
    }

    Push(g_pFilteredCharStack,c);
}

void UnGetCharExFiltered(WCHAR c) 

/*++

Routine Description:
    
    Pushes the input character back into the file stream

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/

{
    WCHAR cGet;
    UnGetCharFiltered(c);
    Pop(g_pStack,&cGet);
}


/*++

Routine Description:

    Get the next character from the file stream
    This routine should only be used internally
    by the comment preprocessor.

Arguments:

    pChar - Character to be returned

Return Value:
    
    TRUE if succeeds, FALSE if fails to retrieval 
++*/
BOOL GetNextCharRaw(WCHAR *pChar)
{
    WCHAR c;

    if (Pop(g_pRawCharStack,&c)) {
        *pChar = c;
        return TRUE;
    }

    c = g_fUnicode ? getwc(yyin) : (WCHAR) getc(yyin);
    if (c == WEOF) {
        if (ferror(yyin)) {
            ERR(("GetNextCharRaw: An error occurred while reading char.\n"));
            RaiseException(LL_SYNTAX, 0, 0, NULL);
        }
        return FALSE;
    }
    else {
        *pChar = c;
        return TRUE;
    }
}


/*++

Routine Description:
    
    Pushes the input character back into the file stream
    This routine should only be used internally
    by the comment preprocessor.

Arguments:

    c - the character to push back

Return Value:
    None
    
--*/
void UnGetCharRaw(WCHAR c)
{
    WCHAR cReturn;
    WCHAR cGet;

    if (c == WEOF) {
        ERR(("UnGetCharRaw: Invalid input value, WEOF.\n"));
        RaiseException(LL_SYNTAX, 0, 0, NULL);
    }

    Push(g_pRawCharStack,c);
}


/*++

Routine Description:
    Reads the next character from the input file, skipping over
    line continuations and comments.  This replaces "getwc" by
    providing pre-processed input.

Arguments:
    None

Return Value:
    A character 
    
--*/

WCHAR GetFilteredWC(void)
{
    static BOOL fFirstTime = TRUE;   // first time we're being called?
    static BOOL fReturnedNewLine = FALSE;// was the last char we returned
                                         // a new line?
                                         
    static __int64 cBytesProcessed = 0; // bytes processed so far of the file
    static __int64 cBytesTrimmed = 0;   // "trimmed" file size
    
    WCHAR c;
    WCHAR wszVersionHeader[] = L"ersion: 1\n";  // version spec (minus 'v')
    DWORD i;

    if (fFirstTime) {

        fFirstTime = FALSE;

        //
        // We need to insert a "version: 1\n" header string.  To quote
        // the original author:
        //   There is a pressing problem of the user putting in opening newlines
        //   before his first valid token. This is prohibited by the LDIF spec,
        //   however due to some flex/yacc peculiarity, it is allowed to pass.
        //   Which is good, because it is an unreasonable restriction.
        //   However, what it does is mess up our line counting. The solution
        //   is to put in a version spec line automatically. This would
        //   simultaneously remove opening newlines and set the version spec to 
        //   some default value.
        //   (I am not currently doing anything with it, but if the need
        //   ever arose)...
        //   The grammar is also changed to accomodate 0, one or two
        //   version specs.
        //
        // To do this, we return the character 'v' and stuff the character stack
        // with the remainer of the header string for subsequent calls to
        // GetNextCharFiltered to read
        //

        c = L'v';
        
        for (i = (sizeof(wszVersionHeader)/sizeof(WCHAR))-1; // -1 for the NULL
             i > 0;
             i--) {

            //
            // We have to push the characters in reverse order
            // so they come out in correct order when popped
            //
            Push(g_pFilteredCharStack, wszVersionHeader[i-1]);
        }
        

        //
        // In addition to prepending the version header string, we also
        // need to simulate trimming extra newlines at the end of the file,
        // otherwise the parser will reject the file with a syntax error
        //
        // To do this, we get the total file size, determine how many (if any)
        // newlines are at the end of the file, and subtract the two to determine
        // the "trimmed" file size.  In the future, we avoid returning characters
        // past the end of this "trimmed" file".  We'll also have to insert
        // a newline character into the stream so that the file is terminated
        // by exactly one newline.
        //

        if (!GetTrimmedFileSize(g_szInputFileName, &cBytesTrimmed)) {
            RaiseException(LL_FILE_ERROR, 0, 0, NULL);
        }

        //
        // Return the first character of the version header string
        //
        return c;   // 'v'
    }

    
    //
    // We determine if we've reached the end of the "trimmed" file.
    // Note: Since this is _before_ we start scanning, we need to
    // check if we're _at_ or past the end, i.e., >=, since if
    // we're at the end there's nothing more to scan
    //
    if (cBytesProcessed >= cBytesTrimmed) {
        // Reached the end, inject a newline if needed
        if (!fReturnedNewLine) {
            fReturnedNewLine = TRUE;
            return L'\n';
        }
        else {
            return WEOF;
        }
    }
    else {
    
        // Haven't reached the end, keep processing characters
        
        while (1) {
            c = L'\0';
            if (!ScanClear(&c, &cBytesProcessed)) {
                // ScanClear reached EOF, pass it up, injecting
                // a terminating newline if needed
                if (!fReturnedNewLine) {
                    fReturnedNewLine = TRUE;
                    return L'\n';
                }
                else {
                    return WEOF;
                }
            }

            // ScanClear may have gone past the end of our "trimmed" file.
            // Check for this.
            // Note: It's okay if the scanning put us _at_ the end, it
            // just can't put us _past_ the end, i.e., >
            if (cBytesProcessed > cBytesTrimmed) {
                // Reached the end, inject a newline if needed
                if (!fReturnedNewLine) {
                    fReturnedNewLine = TRUE;
                    return L'\n';
                }
                else {
                    return WEOF;
                }
            }

            // Otherwise, if ScanClear got a character, return it, else
            // keep scanning.
            if (c != L'\0') {
                if (c == L'\n') {
                    fReturnedNewLine = TRUE;
                }
                else {
                    fReturnedNewLine = FALSE;
                }
                return c;
            }
        }
    }
}


BOOL GetTrimmedFileSize(PWSTR szFilename,
                        __int64 *pTrimmedSize
                        )
{
        BOOL fSuccess = TRUE;

        HANDLE hFile = INVALID_HANDLE_VALUE;
        DWORD dwSize;               // size of a char
        DWORD dwErr;
        BOOL bRes;
        BOOL fDone = FALSE;
        BOOL fReachedTop = FALSE;
        DWORD dwBytesRead=0;
        BYTE rgByte[256];
        WCHAR CharCur;              // current char we just read
        WCHAR CharLastNonSep = 0;   // previous char we read that wasn't a newline
        LARGE_INTEGER TotalFileSize;
        DWORD dwTrimCount = 0;      // bytes we know we need to trim so far
        DWORD dwPossibleTrimCount = 0; // bytes we might have to trim

        hFile = CreateFile(szFilename,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

        if (hFile==INVALID_HANDLE_VALUE) {
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }


        //
        // Determine the total file size
        //
        if (!GetFileSizeEx(hFile, &TotalFileSize)) {
            ERR(("Couldn't get file size\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }

        //
        // Compute the amount to be "trimmed"
        //
        dwSize = (g_fUnicode ? sizeof(WCHAR) : sizeof(CHAR));

        //
        // First point to one char left of FILE_END
        //
        dwErr = SetFilePointer(hFile, -1 * dwSize, NULL, FILE_END);
        if (dwErr==INVALID_SET_FILE_POINTER) {
            ERR(("Failed setting file pointer\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }

        //
        // Read in the last character
        //
        bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
        if ((!bRes)||(dwBytesRead!=dwSize)) {
            ERR(("Failed reading file\n"));
            fSuccess=FALSE;
            BAIL_ON_FAILURE(E_FAIL);
        }


        //
        // Now we keep moving back until we find a line that isn't
        // either a newline, a comment, or a continuation of a comment
        // (i.e., the first line that's a actual LDIF record)
        //

        //
        // We first get the char that we got from readfile
        //
        CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);

        while (!fDone) {

            //
            // Count up all the chars until we reach a newline
            // These characters will go into the "possible trim" count:
            // they may get trimmed (if this turns out to be a comment line
            // or a continuation of a comment line), or not trimmed (if it turns
            // out to be part of a LDIF record)
            //
            while((CharCur!='\n')&&(CharCur!='\r')) {

                dwPossibleTrimCount += dwSize;
                CharLastNonSep = CharCur;
                
                //
                // Move back 2 chars, to point to the char before the character we
                // just read
                //
                dwErr = SetFilePointer(hFile, -2 * dwSize, NULL, FILE_CURRENT);
                if (dwErr==INVALID_SET_FILE_POINTER) {
                    if (GetLastError() == ERROR_NEGATIVE_SEEK) {
                        // reached the top of the file
                        fReachedTop = TRUE;
                        break;
                    }
                    else {
                        ERR(("Failed setting file pointer\n"));                   
                        fSuccess=FALSE;
                        BAIL_ON_FAILURE(E_FAIL);
                    }
                }
        
                //
                // Get the next char
                //
                bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
                if ((!bRes)||(dwBytesRead!=dwSize)) {
                    ERR(("Failed reading char\n"));
                    fSuccess=FALSE;
                    BAIL_ON_FAILURE(E_FAIL);
                }
                
                CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);
            }

            //
            // Depending on the last character before the newline, we
            // may need to either increase the trim count, keep going, or
            // terminate
            //
            // in each of the following, adding the extra "dwSize" accounts
            // for the newline we hit to get out of the previous loop and
            // into this block of code (unless we exited the loop because
            // we reached the top of the file)
            //

            if (CharLastNonSep == L'#') {

                // this was a comment line at the end of the file--> trim it
                dwTrimCount += dwPossibleTrimCount;
                dwTrimCount += (!fReachedTop ? dwSize : 0);
                dwPossibleTrimCount = 0;
                CharLastNonSep = 0; 
            }
            else if (CharLastNonSep == L' ') {
                // this was a continuation line, so it may need to be trimmed
                // or it may need to not be trimmed, depending on what it was
                // a continuation of --> do nothing for now and keep going
                dwPossibleTrimCount += (!fReachedTop ? dwSize : 0);
            }
            else if (CharLastNonSep == 0) {
                // just a plain newline --> trim it
                dwTrimCount += (!fReachedTop ? dwSize : 0);
            }
            else {
                // The last non-separator character was neither a # nor a continuation
                // --> we hit a valid LDIF record line --> don't trim the line and
                // stop processing, we're no longer at the end of the file
                fDone = TRUE;
                break;
            }

            // if we reached the top, no point to trying to continue
            if (fReachedTop) {
                fDone = TRUE;
                break;
            }

            //
            // Move back 2 chars, to point to the char before the character we
            // just read
            //
            dwErr = SetFilePointer(hFile, -2 * dwSize, NULL, FILE_CURRENT);
            if (dwErr==INVALID_SET_FILE_POINTER) {
                if (GetLastError() == ERROR_NEGATIVE_SEEK) {
                    // reached the top of the file
                    fReachedTop = TRUE;
                    fDone = TRUE;
                    break;
                }
                else {
                    ERR(("Failed setting file pointer\n"));
                    fSuccess=FALSE;
                    BAIL_ON_FAILURE(E_FAIL);
                }
            }

            //
            // Get the next char
            //
            bRes = ReadFile(hFile, rgByte, dwSize, &dwBytesRead, NULL);
            if ((!bRes)||(dwBytesRead!=dwSize)) {
                ERR(("Failed reading char\n"));
                fSuccess=FALSE;
                BAIL_ON_FAILURE(E_FAIL);
            }
            
            CharCur = (g_fUnicode ? ((PWSTR)rgByte)[0] : rgByte[0]);
        }
        
        //
        // Compute the trimmed size
        //
        *pTrimmedSize = TotalFileSize.QuadPart - dwTrimCount;

error:

        if (hFile != INVALID_HANDLE_VALUE) {
            if(!CloseHandle(hFile)) {
                ERR(("Failed closing file handle\n"));
                fSuccess=FALSE;
            }
        }

        return fSuccess;
}


int yylex ()

/*++

Routine Description:

    Main lexing routine. Take input from yyin.

Arguments:

Return Value:

    The token found.

--*/

{
    DWORD Token;                            // Returning pToken
    int Mode_last; 
    BOOL fMatched;

    FEATURE_DEBUG(Lexer,
                  FLAG_FNTRACE,
                  ("yylex()\n"));

    if (Mode == NO_COMMAND) {
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("yylex: NO_COMMAND, Returning MODESWITCH\n"));
        return MODESWITCH;
    }
    
    //
    // After storing the old mode, we reset Mode to NO_COMMAND 
    // indicitating that if we're not in NORMAL mode, we must switch modes 
    // according to the grammar again.
    //
    Mode_last = Mode;
    if (Mode != C_NORMAL) {
        Mode = NO_COMMAND;
    }
        
    while (1) {

        //
        // Depending on our current mode, we use a different lexing routine
        //
        switch (Mode_last) {
            case C_NORMAL:
                fMatched = ScanNormal(&Token);
                break;
            case C_SAFEVAL:
                fMatched = ScanVal(&Token);
                break;
            case C_ATTRNAME:
                fMatched = ScanName(&Token);
                break;
            case C_ATTRNAMENC:
                fMatched = ScanNameNC(&Token);
                break;
            case C_M_STRING:
                ERR_RIP(("M_STRING is an unsupported mode command.\n"));
                return YY_NULL;
                break;
            case C_M_STRING64:
                fMatched = ScanString64(&Token);
                break;
            case C_DIGITREAD:
                fMatched = ScanDigit(&Token);
                break;
            case C_TYPE:
                fMatched = ScanType(&Token);
                break;
            case C_URLSCHEME:
                ERR_RIP(("URLSCHEME is an unsupported mode command.\n"));
                return YY_NULL;
                break;
            case C_URLMACHINE:
                fMatched = ScanUrlMachine(&Token);
                break;
            case C_CHANGETYPE:
                fMatched = ScanChangeType(&Token);
                break;
            default:
                ERR_RIP(("Unexpected command type %d.\n",Mode_last));
                return YY_NULL;
                break;
        }

        //
        // If no match can be found, goto the default handling case
        //
        if (!fMatched) {
            WCHAR c;
            if (g_pszLastToken) {
                MemFree(g_pszLastToken);
                g_pszLastToken = NULL;
            }

            if (GetNextCharFiltered(&c)) {
                cLast = c;
                UnGetCharFiltered(c);
                /*
                if (GetToken(&g_pszLastToken)) {
                    RollBack();
                };
                */

                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("yylex: Uncongnized char, Returning MODESWITCH\n"));
                return MODESWITCH; 
            }
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("yylex: YY_NULL\n"));
            fEOF = TRUE;
            return YY_NULL; 
        }

        //
        //  If there is a match, and there is a returning token, return it
        //
        else if (Token != YY_NULL) {
            return Token;
        }
    }
}


void yyerror (char *error) 
{
    RaiseException(LL_SYNTAX, 0, 0, NULL);
}

BOOL ScanClear(PWCHAR pChar, __int64 *pBytesProcessed)
{
    WCHAR c;
    BOOL fNextChar = TRUE;
    DWORD dwCharSize = (g_fUnicode ? sizeof(WCHAR) : sizeof(CHAR));

    if (!GetNextCharRaw(&c)) {
        return FALSE;
    }
    (*pBytesProcessed) += dwCharSize;
    
    if (fNewFile == FALSE) {
        if (g_fUnicode) {
            fNewFile = TRUE;
            if (c == UNICODE_MARK) {
                if (!GetNextCharRaw(&c)) {
                    return FALSE;
                }
                (*pBytesProcessed) += dwCharSize;
            }
        }
    }

    //
    // Comment
    // <CLEAR>^#[^\n\r]+[\n\r]?
    //
    if (fNewLine && (c == '#')) {

        //
        // We have got another character, it's not a newline anymore
        //
        fNewLine = FALSE;
        while (GetNextCharRaw(&c)) {
            (*pBytesProcessed) += dwCharSize;
            if (c == '\r') {
                if (!GetNextCharRaw(&c)) {
                    ERR_RIP(("\r is not followed by anything!\n"));
                    return FALSE;
                }
                (*pBytesProcessed) += dwCharSize;
            }
            if (c == '\n') {
                //
                // after a '\n', it's a newline
                //
                fNewLine = TRUE;
                //
                // Exit if we have reached the end
                //
                if (!GetNextCharRaw(&c)) {
                    LineGhosts++;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanClear: Comment\n"));
                    return TRUE;
                };
                UnGetCharRaw(c);
                
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanClear: Comment\n"));
                LineGhosts++;
                return TRUE;
            }
        }
        
        //
        // Indicating a successful parse with no token returning
        //
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanClear: Comment\n"));
        LineGhosts++;
        return TRUE;
    }
    
    //
    // Linefeed
    //
    else if ((c == '\n') || (c == '\r')) {

        if (c == '\r') {
            if (!GetNextCharRaw(&c)) {
                ERR_RIP(("\r is not followed by anything!\n"));
                return FALSE;
            }
            (*pBytesProcessed) += dwCharSize;
        }

        //
        // It's a newline after linefeed
        //
        fNewLine = TRUE;

        //
        // Done if we have reached the end
        //
        if (!GetNextCharRaw(&c)) {
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanClear: LineFeed\n"));
            *pChar = L'\n';
            return TRUE;
        }
        (*pBytesProcessed) += dwCharSize;
        
        //
        // If it comes with a space
        // <CLEAR>[\n\r][ ]           
        //
        if (c == ' ') {
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("\nLinewrap removed\n"));
            LineGhosts++;
            fNewLine = FALSE;
            return TRUE;
        }
        else {
            //
            // <CLEAR>[\n\r]
            //
            UnGetCharRaw(c);
            (*pBytesProcessed) -= dwCharSize;
            if (!rgLineMap) {
                rgLineMap = (long *)MemAlloc_E(LINEMAP_INC*sizeof(long));
                cLineMax = MemSize(rgLineMap);
            } 
            else if ((LineClear%LINEMAP_INC)==0) {
                //
                // Chunk used up. LineClear is 'LineClear'
                //
                rgLineMap = (long *)MemRealloc_E(
                                        rgLineMap, 
                                        cLineMax+LINEMAP_INC*(DWORD)sizeof(long)
                                        );
                cLineMax = MemSize(rgLineMap);
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("\nChunk used up\n"));
            }
            
            //
            // the +1 is because our array starts at 0
            //
            rgLineMap[LineClear] = LineClear + LineGhosts + 1;
            
            //
            // 'LineClear' maps to 'LineClear+LineGhosts+1'
            // 
            LineClear++;
 
            *pChar = L'\n';
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanClear: Multi-LineFeed\n"));
            return TRUE;
        }
    }

    //
    // Other characters
    //
    else {
        //
        // After any other characters, it's not a newline anymore
        //
        fNewLine = FALSE;
        *pChar = c;
        return TRUE;
    }
}

BOOL ScanNormal(DWORD *pToken)
{
    WCHAR c;
    *pToken = YY_NULL;

    if (!GetNextCharFiltered(&c)) {
        return FALSE;
    }

    if ((c == ' ') || (c == '\t')) {
        while (GetNextCharFiltered(&c)) {
            if ((c == ' ') || (c == '\t')) {
                continue;
            }
            else if (c == '\n') {
                UnGetCharFiltered(c);
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: Ignoring whitespace\n"));
                return TRUE;
            }
            else {
                UnGetCharFiltered(c);
                *pToken = MULTI_SPACE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: MULTI_SPACE\n"));
                return TRUE;
            }
        }
        //
        // If we reaches end of file, we'll handle the '<NORMAL>[ \t]+$' case
        //
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanNormal: Ignoring whitespace\n"));
        return TRUE;
    }
    else if (c == '\n') {
        if (!GetNextCharExFiltered(&c,TRUE)) {
            //
            // We do not understand single '\n'
            //
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: don't understand single '\\n'.\n"));
            /*
            UnGetChar(c);
            return FALSE;                       
            */
            return TRUE;
        }
        if (c == '-') {
            //
            // <NORMAL>[\n\r]/"-"[ \t]*[\n\r]
            //
            while (GetNextCharExFiltered(&c,FALSE)) {
                if ((c == ' ') || (c == '\t')) {
                    continue;
                }
                else if (c == '\n') {
                    RollBack();
                    Line++; 
                    *pToken = SEPBYMINUS;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanNormal: SEPBYMINUS\n"));
                    return TRUE;
                }
                else {
                    RollBack();
                    Line++; 
                    *pToken = SEP;
                    FEATURE_DEBUG(Lexer,
                                  FLAG_VERBOSE,
                                  ("ScanNormal: SEP\n"));
                    return TRUE;
                }
            }
            Line++; 
            RollBack();
            *pToken = SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: SEP\n"));
            return TRUE;
        }
        else if ((c == 'c') || (c == 'C')) {
            //
            // <NORMAL>[\n\r]/"changetype:"[ \t]*("add"|"delete"|"modrdn"|"moddn"|"modify"|"ntdsSchemaadd"|"ntdsSchemadelete"|"ntdsSchemamodrdn"|"ntdsSchemamoddn"|"ntdsSchemamodify")[ \t]*[\n\r] {
            //
            if (!GetNextCharExFiltered(&c,FALSE)) {
                RollBack();
                Line++; 
                *pToken = SEP;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEP\n"));
                return TRUE;                        
            }
            if ((c == 'h') || (c == 'H')) {
                RollBack();
                Line++; 
                *pToken = SEPBYCHANGE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEPBYCHANGE\n"));
                return TRUE;
            }
            else {
                RollBack();
                Line++; 
                *pToken = SEP;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanNormal: SEP\n"));
                return TRUE;
            }
        }
        else if (c == '\n') {
            DWORD dwLineCount = 2;
            //
            // <NORMAL>[\n\r]{2,}
            //
            while (GetNextCharFiltered(&c)) {
                if (c != '\n') {
                    UnGetCharFiltered(c);
                    break;
                }
                dwLineCount++;
            }
            Line += dwLineCount;
            *pToken = MULTI_SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: MULTI_SEP\n"));
            return TRUE;
        }
        else {
            RollBack();
            Line++; 
            *pToken = SEP;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNormal: SEP\n"));
            return TRUE;            
        }
    }
    UnGetCharFiltered(c);
    return FALSE;
}

BOOL ScanDigit(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharFiltered(&c)) {
        BAIL();
    }

    if (!IsDigit(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);

    while (GetNextCharFiltered(&c)) {
        if (!IsDigit(c)) {
            UnGetCharFiltered(c);
            *pToken = DIGITS;

            yylval.num = _wtoi(STR_VALUE()); 
            
            //
            // ERROR REPORTING BLOCK
            //
            RuleLast = RS_DIGITS;
            TokenExpect = RT_MANY;
        
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanDigit: DIGITS '%S'\n",STR_VALUE()));

            fReturn = TRUE;
            BAIL();
        }
        STR_ADDCHAR(c);
    }
error:
    STR_FREE();
    return fReturn;
}


BOOL ScanString64(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!Is64Char(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }
    
    while (1) {
        int i;

        //
        // Adding in first character
        //
        STR_ADDCHAR(c);

        //
        // Looking at the rest 4 characters
        //
        for (i=0;i<3;i++)
        {
            //
            // If the character is not what we want, we roll back and exit
            //
            if ((!GetNextCharExFiltered(&c,FALSE)) || (!Is64Char(c))) {
                RollBack();
                BAIL();
            }
            STR_ADDCHAR(c);
        }

        //
        // Must be followed by not \x21-\x7E    
        //
        if (!GetNextCharExFiltered(&c,FALSE)) {
            RollBack();
            BAIL();
        }
        //
        // Terminate if we find a terminator
        //
        else if (Is64CharEnd(c)) {
            UnGetCharFiltered(c);
            *pToken = BASE64STRING;
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
            
            RuleLast = RS_BASE64;
            TokenExpect = RT_MANY;
            
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanString64: BASE64STRING '%S'\n",STR_VALUE()));

            fReturn = TRUE;
            BAIL();
        }
    }
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanName(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!IsNameChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharExFiltered(&c,FALSE)) {
        if (!IsNameChar(c)) {
            if (c != ':') {
                RollBack();
                BAIL();
            }
            else {
                UnGetCharFiltered(c);
                yylval.wstr = MemAllocStrW_E(STR_VALUE());
             
                RuleLast = RS_ATTRNAME;
                TokenExpect = RT_C_VALUE;
                *pToken = NAME;
                fReturn = TRUE;
                FEATURE_DEBUG(Lexer,
                              FLAG_VERBOSE,
                              ("ScanName: NAME '%S'\n",STR_VALUE()));
                BAIL();
            }
        }
        STR_ADDCHAR(c);
    }

    //
    // RollBack and fail out if we can't find the terminating ':'
    //
    RollBack();
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanNameNC(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (!IsNameChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);

    while (GetNextCharFiltered(&c)) {
        if (!IsNameChar(c)) {
            UnGetCharFiltered(c);
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
         
            RuleLast = RS_ATTRNAMENC;
            TokenExpect = RT_C_VALUE;
            *pToken = NAMENC;
            fReturn = TRUE;

            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanNameNC: NAMENC '%S'\n",STR_VALUE()));

            BAIL();
        }
            STR_ADDCHAR(c);
    }
    fReturn = TRUE;
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanVal(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();
    *pToken = YY_NULL;

    if (!GetNextCharFiltered(&c)) {
        fReturn = FALSE;
        BAIL();
    }

    //
    // Even if there is no value, it is valid
    //
    if (!IsValInit(c)) {
        fReturn = FALSE;
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharFiltered(&c)) {
        if (!IsVal(c)) {
            UnGetCharFiltered(c);
            fReturn = TRUE;
            BAIL();
        }
        STR_ADDCHAR(c);
    }
error:
    if (fReturn) {
        yylval.wstr = MemAllocStrW_E(STR_VALUE());
        
        RuleLast = RS_SAFE;
        TokenExpect = RT_MANY;
        
        *pToken = VALUE;                                           
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanVal: VALUE '%S'\n",STR_VALUE()));
    }
    STR_FREE();
    return fReturn;
}

BOOL ScanUrlMachine(DWORD *pToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    STR_INIT();

    if (!GetNextCharFiltered(&c)) {
        BAIL();
    }

    if (!IsURLChar(c)) {
        UnGetCharFiltered(c);
        BAIL();
    }

    STR_ADDCHAR(c);
    while (GetNextCharFiltered(&c)) {
        if (!IsURLChar(c)) {
            UnGetCharFiltered(c);
            yylval.wstr = MemAllocStrW_E(STR_VALUE());
         
            *pToken = MACHINENAME;
            fReturn = TRUE;
            FEATURE_DEBUG(Lexer,
                          FLAG_VERBOSE,
                          ("ScanUrlMachine: MACHINENAME '%S'\n",STR_VALUE()));
            BAIL();
        }
        STR_ADDCHAR(c);
    }
    fReturn = TRUE;
    FEATURE_DEBUG(Lexer,
                  FLAG_VERBOSE,
                  ("ScanUrlMachine: MACHINENAME\n"));
error:
    STR_FREE();
    return fReturn;
}

BOOL ScanChangeType(DWORD *pToken)
{
    PWSTR pszToken;
    BOOL fReturn = FALSE;

    if (!GetToken(&pszToken)) {
        return FALSE;
    }
    if (_wcsicmp(pszToken,L"changetype:") == 0) {
        RuleLast = RS_CHANGET;
        TokenExpect = RT_ADM;
        *pToken = T_CHANGETYPE;
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanChangeType: T_CHANGETYPE\n"));
        fReturn = TRUE;
    }
    else {
        RollBack();
    }
    if (pszToken) {
        MemFree(pszToken);
    }
    return fReturn;
}

BOOL ScanType(DWORD *pToken)
{
    PWSTR pszToken = NULL;
    BOOL fReturn = FALSE;

    if (!GetToken(&pszToken)) {
        return FALSE;
    }
    if (wcscmp(pszToken,L":") == 0) {
        RuleLast = RS_C;
        TokenExpect = RT_VALUE;
        *pToken = SINGLECOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"version:") == 0) {
        RuleLast=RS_VERSION;
        TokenExpect=RT_DIGITS;
        *pToken = VERSION;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"dn:") == 0) {
        RuleLast=RS_DN;
        TokenExpect=RT_VALUE;
        *pToken = DNCOLON;
        fReturn = TRUE;
        g_dwBeginLine = Line;
    }
    else if (_wcsicmp(pszToken,L"dn::") == 0) {
        RuleLast = RS_DND;
        TokenExpect = RT_BASE64;
        *pToken = DNDCOLON;
        fReturn = TRUE;
        g_dwBeginLine = Line;
    }
    else if (wcscmp(pszToken,L"::") == 0) {
        RuleLast = RS_DC;
        TokenExpect = RT_BASE64;
        *pToken = DOUBLECOLON;
        fReturn = TRUE;
    }
    else if (wcscmp(pszToken,L":<") == 0) {
        RuleLast = RS_URLC;
        TokenExpect = RT_URL;
        *pToken = URLCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"modrdn") == 0) {
        yylval.num = 0;
        
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = MODRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemamodrdn") == 0) {
        yylval.num = 1;
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = NTDSMODRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"moddn") == 0) {
        RuleLast = RS_MDN;
        TokenExpect = RT_NDN;
        *pToken = MODDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newrdn:") == 0) {
        RuleLast = RS_NRDNC;
        TokenExpect = RT_VALUE;
        *pToken = NEWRDNCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newrdn::") == 0) {
        RuleLast = RS_NRDNDC;
        TokenExpect = RT_BASE64;
        *pToken = NEWRDNDCOLON;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"deleteoldrdn:") == 0) {
        RuleLast = RS_DORDN;
        TokenExpect = RT_DIGITS;
        *pToken = DELETEOLDRDN;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newsuperior:") == 0) {
        RuleLast = RS_NEWSUP;
        TokenExpect = RT_VALUE;
        *pToken = NEWSUPERIORC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"newsuperior::") == 0) {
        RuleLast = RS_NEWSUPD;
        TokenExpect = RT_BASE64;
        *pToken = NEWSUPERIORDC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"delete:") == 0) {
        RuleLast = RS_DELETEC;
        TokenExpect = RT_ATTRNAMENC;
        *pToken = DELETEC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"replace:") == 0) {
        RuleLast = RS_REPLACEC;
        TokenExpect = RT_ATTRNAMENC;
        *pToken = REPLACEC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"add") == 0) {
        yylval.num = 0;
        RuleLast = RS_C_ADD;
        TokenExpect = RT_ATTRNAME;
        *pToken = ADD;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemaadd") == 0) {
        yylval.num = 1;
            
        RuleLast = RS_C_ADD;
        TokenExpect = RT_ATTRNAME;
        
        *pToken = NTDSADD;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"delete") == 0) {
        yylval.num = 0;
            
        RuleLast = RS_C_DELETE;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = MYDELETE;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemadelete") == 0) {
        yylval.num = 1;
            
        RuleLast = RS_C_DELETE;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = NTDSMYDELETE;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"add:") == 0) {
        RuleLast = RS_ADDC;
        TokenExpect = RT_ATTRNAMENC;
        
        *pToken = ADDC;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"-") == 0) {
        RuleLast = RS_MINUS;
        TokenExpect = RT_CH_OR_SEP;
        
        *pToken = MINUS;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"modify") == 0) {
        yylval.num = 0;
        
        RuleLast = RS_C_MODIFY;
        TokenExpect = RT_ACDCRC;
        
        *pToken = MODIFY;
        fReturn = TRUE;
    }
    else if (_wcsicmp(pszToken,L"ntdsSchemamodify") == 0) {
        yylval.num = 1;
        
        RuleLast = RS_C_MODIFY;
        TokenExpect = RT_ACDCRC;

        *pToken = NTDSMODIFY;
        fReturn = TRUE;
    }
    if (fReturn) {
        FEATURE_DEBUG(Lexer,
                      FLAG_VERBOSE,
                      ("ScanType: %S\n",pszToken));
    }
    else {
        RollBack();
    }
    if (pszToken) {
        MemFree(pszToken);
    }
    return fReturn;
}

BOOL GetToken(PWSTR *pszToken)
{
    WCHAR c;
    BOOL fReturn = FALSE;
    BOOL fFirstColon = FALSE;
    STR_INIT();
    
    if (!GetNextCharExFiltered(&c,TRUE)) {
        BAIL();
    }

    if (c == ' ' || c == '\n' || c == '\t') {
        UnGetCharFiltered(c);
        BAIL();
    }

    do {
        if (c == ' ' || c == '\n' || c == '\t') {
            UnGetCharExFiltered(c);
            *pszToken = MemAllocStrW_E(STR_VALUE());
            fReturn = TRUE;
            BAIL();
        }
        if (fFirstColon) {
            //
            // If we have hit the first colon already, and we hit another colon
            // or '<', we'll add them to the string and exit
            //
            if ((c == ':') || (c == '<')) {
                STR_ADDCHAR(c);
                break;
            }
            //
            // If we have hit another random char, it is the start of another
            // token already and thus we'll put it back 
            //
            else {
                UnGetCharExFiltered(c);
                break;          
            }
        }
        if (c == ':') {
            fFirstColon = TRUE;
        }
        STR_ADDCHAR(c);
    } while (GetNextCharExFiltered(&c,FALSE));
    *pszToken = MemAllocStrW_E(STR_VALUE());
    fReturn = TRUE;
    
error:
    STR_FREE();
    return fReturn;
}

BOOL IsDigit(WCHAR c)
{
    if ((c >= '0') && (c <= '9')) {
        return TRUE;
    }
    return FALSE;
}

BOOL Is64Char(WCHAR c) 
{
    if (c >= 'A' && c <= 'Z') {
        return TRUE;
    }
    if (c >= 'a' && c <= 'z') {
        return TRUE;
    }
    if (c >= '0' && c <= '9') {
        return TRUE;
    }
    if (c == '+' || c == '=' || c == '/') {
        return TRUE;
    }
    return FALSE;
}
    
BOOL Is64CharEnd(WCHAR c)
{
    if (!(c >= 0x21 && c <= 0x7e)) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsNameChar(WCHAR c) 
{
    if (!((c >= 0 && c <= 0x1f) || 
          (c >= 0x7f && c <= 0xff) ||
          (c == ':'))) {
        return TRUE;        
    }
    return FALSE;
}

BOOL IsURLChar(WCHAR c) 
{
    if (!((c == '\n') ||
          (c == '/')  ||
          (c == ' ')  ||
          (c == 0x00))) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsVal(WCHAR c) 
{
    if (c >= 0x20 && c <= 0xffff) {
        return TRUE;
    }
    return FALSE;
}

BOOL IsValInit(WCHAR c) 
{
    if (!((c >= 0x00 && c <=0x1f) ||
          (c == ':' || c == '<' || c == ' '))) {
        return TRUE;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\parser.c ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 2 "ldif.y"

/*++

Copyright (c) 1997 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.y

ABSTRACT:

    The yacc grammar for LDIF.

DETAILS:
    
    To generate the sources for lexer.c and parser.c,
    run nmake -f makefile.parse.
    
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/


#include <precomp.h>
#include <urlmon.h>
#include <io.h>

/**/
/* I really don't want to do another linked list contraption for mod_specs, */
/* expecially considering that we don't need to do any preprocessing other than */
/* combine them into an LDAPmod**. So I am going to use realloc. */
/**/
#define CHUNK 100        
LDAPModW        **g_ppModSpec     = NULL; 
LDAPModW        **g_ppModSpecNext = NULL;
long            g_cModSpecUsedup  = 0;        /* how many we have used up*/
size_t          g_nModSpecSize    = 0;        /* how big the buffer is*/
long            g_cModSpec        = 0;        /* no. of mod spec allocated*/


DEFINE_FEATURE_FLAGS(Parser, 0);

#define DBGPRNT(x)  FEATURE_DEBUG(Parser,FLAG_FNTRACE,(x))

#line 55 "ldif.y"
typedef union {
    int                 num;
    PWSTR               wstr;
    LDAPModW            *mod;
    struct change_list  *change;
} YYSTYPE;
#line 70 "y_tab.c"
#define SEP 257
#define MULTI_SEP 258
#define MULTI_SPACE 259
#define CHANGE 260
#define VERSION 261
#define DNCOLON 262
#define DNDCOLON 263
#define LINEWRAP 264
#define NEWRDNDCOLON 265
#define MODESWITCH 266
#define SINGLECOLON 267
#define DOUBLECOLON 268
#define URLCOLON 269
#define FILESCHEME 270
#define T_CHANGETYPE 271
#define NEWRDNCOLON 272
#define DELETEOLDRDN 273
#define NEWSUPERIORC 274
#define NEWSUPERIORDC 275
#define ADDC 276
#define MINUS 277
#define SEPBYMINUS 278
#define DELETEC 279
#define REPLACEC 280
#define STRING 281
#define SEPBYCHANGE 282
#define NAME 283
#define VALUE 284
#define BASE64STRING 285
#define MACHINENAME 286
#define NAMENC 287
#define DIGITS 288
#define ADD 289
#define MODIFY 290
#define MODDN 291
#define MODRDN 292
#define MYDELETE 293
#define NTDSADD 294
#define NTDSMODIFY 295
#define NTDSMODRDN 296
#define NTDSMYDELETE 297
#define NTDSMODDN 298
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,   27,   27,   27,   28,   28,   28,   29,   36,
   31,   31,   32,   32,   38,   39,   26,   26,   26,   40,
   40,   41,   41,    1,    1,    1,    1,   43,   46,   44,
   34,   45,   37,   33,   47,   17,   17,   19,   19,   18,
   18,   20,   20,   21,   21,   11,   11,   11,   11,    9,
    9,   14,   13,   13,   12,   12,   12,   12,   23,   22,
    6,    7,   15,    8,    8,   10,   48,   48,    4,    4,
    4,    2,    3,    5,   16,   16,   42,   42,   30,   30,
   35,   35,   24,   25,
};
short yylen[] = {                                         2,
    1,    1,    3,    5,    1,    3,    5,    1,    5,    3,
    1,    3,    1,    3,    3,    3,    5,    5,    3,    1,
    3,    1,    3,    9,    9,    9,    5,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    9,
    7,    7,    1,    3,    5,    5,    5,    5,    7,    7,
    5,    5,    7,    5,    5,    9,    1,    3,    1,    1,
    1,   13,   12,   12,    0,    2,    1,    1,    1,    1,
    0,    1,    3,    3,
};
short yydefred[] = {                                      0,
   34,    0,    0,    1,    2,    0,    0,    0,    0,   11,
   13,    0,    0,   79,   80,    0,    0,    0,    0,    0,
    0,   28,   20,    0,    0,   35,   46,   48,   22,    0,
   49,   47,    0,    0,    0,    0,    0,    0,    0,    0,
    0,   12,    0,   14,   31,    0,    0,    0,   77,   78,
    0,    0,    0,    0,    0,    0,    0,    0,   82,    0,
    0,    0,   21,    0,   54,    0,    0,    0,    0,    0,
    0,   23,    0,    0,    0,   33,    9,    0,   30,   17,
    0,   32,   18,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   56,    0,   58,    0,    0,   55,
   57,    0,   10,   83,   84,    0,    0,    0,    0,    0,
    0,    0,    0,   36,   40,   44,   42,   38,   37,   41,
   43,   39,   45,    0,    0,    0,    0,    0,    0,    0,
    0,   64,   65,    0,   62,   61,    0,    0,   52,   59,
   60,    0,    0,    0,    0,    0,    0,   24,   25,   26,
    0,    0,   69,   70,   67,   71,    0,    0,    0,    0,
    0,    0,    0,   63,    0,    0,    0,   68,    0,    0,
    0,   29,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   73,   74,   72,
};
short yydgoto[] = {                                       2,
   23,  163,  164,  165,  166,   67,   68,   65,   27,   28,
   29,   30,   31,   32,  105,  193,  134,  135,  136,  137,
  138,   33,   34,   80,   83,    3,    4,    5,    6,   16,
    7,    8,  106,   46,   60,   77,   78,   10,   11,   24,
   35,   51,   25,   81,   84,  183,   36,  168,
};
short yysindex[] = {                                   -238,
    0,    0, -241,    0,    0, -240, -193, -185, -229,    0,
    0, -183, -182,    0,    0, -238, -238, -238, -181, -181,
 -181,    0,    0, -235, -194,    0,    0,    0,    0, -167,
    0,    0, -161, -160, -184, -170, -240, -193, -185, -155,
 -195,    0, -179,    0,    0, -154, -154, -154,    0,    0,
 -183, -238, -238, -238, -238, -182, -181, -238,    0, -159,
 -158, -157,    0, -210,    0, -205, -151, -136, -251, -135,
 -129,    0, -154, -193, -185,    0,    0, -156,    0,    0,
 -153,    0,    0, -152, -181, -181, -181, -181, -181, -238,
 -238, -181, -181, -238, -238, -238, -181, -181, -181, -154,
 -154, -154, -154, -154,    0, -144,    0, -154, -154,    0,
    0, -178,    0,    0,    0, -158, -157, -158, -158, -157,
 -181, -157, -158,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -181, -181, -181, -181, -181, -150, -149,
 -146,    0,    0, -154,    0,    0, -235, -127,    0,    0,
    0, -181, -181, -181, -159, -183, -238,    0,    0,    0,
 -148, -235,    0,    0,    0,    0, -249, -120, -181, -181,
 -181, -181, -238,    0, -154, -154, -154,    0, -122, -122,
 -122,    0, -142, -141, -140, -181, -181, -181, -235, -235,
 -235, -183, -139, -183, -130, -242, -238, -235, -238, -238,
 -128, -126, -125, -181, -181, -181,    0,    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,    0,    0,    0,    0,  150,  153,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    4,    0,    0,    0,    0,    0,    2,
    0,    0,    0,    0,    5,    0,    0,  154,  155,    0,
    0,    0,    0,    0,    0, -110, -237, -110,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0, -110,  157,  162,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    1,
 -110, -110, -110, -110,    0,    0,    0, -110, -110,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -110,    0,    0,    6,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    7,    0,    0,    0,    0,    0,    3,    0,    0,
    0,    0,    0,    0, -110, -110, -110,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0, -115,
 -115,    0,    0,    0,    0,    0,    0, -114,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
  118,    0,    0,   -3,    0,  116,  117,    0,    0,    0,
  122,    0,    0,    0,  -39,  -18,    0,    0,    0,    0,
    0,    0,    0, -100,  -85,   54,    0,    0,  158,  142,
   -5,   -4,    8,  -11,   -9,    0,   25,  165,  166, -143,
    0, -147,    0,  -68,   66, -101,    0,    0,
};
#define YYTABLESIZE 285
short yytable[] = {                                     156,
   27,   53,   66,   15,   16,   51,   50,    9,   47,   48,
   38,   39,  162,   92,   49,   12,   14,   15,  142,   19,
   93,   49,  146,    9,   41,   41,  170,    1,   81,  171,
  172,   19,   20,   21,  143,  200,  145,   61,   62,   50,
   13,  192,  194,  194,   19,   73,   50,  139,  196,  141,
  198,  107,   74,   75,  110,  111,   85,   86,   87,   64,
   66,   69,   69,   96,   17,   41,   20,   21,   88,   89,
   40,   43,   18,  100,  101,  102,  103,  104,  184,  185,
  108,  109,   22,   26,   45,  113,  114,  115,   52,   53,
  116,  117,  118,  119,  120,   54,   55,   56,  122,  123,
   57,   12,   13,  112,   59,   90,   76,   79,   82,  144,
  124,  125,  126,  127,  128,  129,  130,  131,  132,  133,
   91,   94,  147,  148,  149,  150,  151,   95,  121,  157,
   98,   97,   99,  152,  155,  153,  173,  154,  197,  169,
  158,  159,  160,  182,  186,  187,  188,  199,  204,    5,
  205,  206,    8,    3,    6,   81,    4,  174,  175,  176,
  177,    7,   75,   76,  167,  179,  180,  181,   63,  178,
   70,   71,  195,   37,  189,  190,  191,   72,   58,  161,
  167,   42,  140,   44,    0,    0,    0,    0,    0,    0,
    0,    0,  207,  208,  209,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  201,    0,  202,  203,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   27,   27,   53,
   66,   15,   16,   51,   50,    0,   81,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   27,    0,
    0,    0,   27,   53,   66,
};
short yycheck[] = {                                     147,
    0,    0,    0,    0,    0,    0,    0,    0,   20,   21,
   16,   16,  156,  265,  257,  257,  257,  258,  119,  257,
  272,  257,  123,   16,   17,   18,  276,  266,  266,  279,
  280,  261,  262,  263,  120,  278,  122,   47,   48,  282,
  282,  189,  190,  191,  282,   57,  282,  116,  192,  118,
  194,   91,   58,   58,   94,   95,  267,  268,  269,   52,
   53,   54,   55,   73,  258,   58,  262,  263,  274,  275,
   17,   18,  258,   85,   86,   87,   88,   89,  180,  181,
   92,   93,  266,  266,  266,   97,   98,   99,  283,  257,
  100,  101,  102,  103,  104,  257,  257,  282,  108,  109,
  271,  257,  282,   96,  259,  257,  266,  266,  266,  121,
  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,
  257,  257,  134,  135,  136,  137,  138,  257,  273,  257,
  284,  288,  285,  284,  144,  285,  257,  284,  278,  288,
  152,  153,  154,  266,  287,  287,  287,  278,  277,    0,
  277,  277,    0,    0,    0,  266,    0,  169,  170,  171,
  172,    0,  278,  278,  157,  175,  176,  177,   51,  173,
   55,   55,  191,   16,  186,  187,  188,   56,   37,  155,
  173,   17,  117,   18,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,  204,  205,  206,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,  197,   -1,  199,  200,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,  258,
  258,  258,  258,  258,  258,   -1,  266,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  278,   -1,
   -1,   -1,  282,  282,  282,
};
#define YYFINAL 2
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 298
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"SEP","MULTI_SEP","MULTI_SPACE",
"CHANGE","VERSION","DNCOLON","DNDCOLON","LINEWRAP","NEWRDNDCOLON","MODESWITCH",
"SINGLECOLON","DOUBLECOLON","URLCOLON","FILESCHEME","T_CHANGETYPE",
"NEWRDNCOLON","DELETEOLDRDN","NEWSUPERIORC","NEWSUPERIORDC","ADDC","MINUS",
"SEPBYMINUS","DELETEC","REPLACEC","STRING","SEPBYCHANGE","NAME","VALUE",
"BASE64STRING","MACHINENAME","NAMENC","DIGITS","ADD","MODIFY","MODDN","MODRDN",
"MYDELETE","NTDSADD","NTDSMODIFY","NTDSMODRDN","NTDSMYDELETE","NTDSMODDN",
};
char *yyrule[] = {
"$accept : ldif_file",
"ldif_file : ldif_content",
"ldif_file : ldif_changes",
"ldif_content : version_spec any_sep ldif_record_list",
"ldif_content : version_spec any_sep version_spec any_sep ldif_record_list",
"ldif_content : ldif_record_list",
"ldif_changes : version_spec any_sep ldif_change_record_list",
"ldif_changes : version_spec any_sep version_spec any_sep ldif_change_record_list",
"ldif_changes : ldif_change_record_list",
"version_spec : M_type VERSION M_normal any_space version_number",
"version_number : M_digitread DIGITS M_normal",
"ldif_record_list : ldif_record",
"ldif_record_list : ldif_record_list MULTI_SEP ldif_record",
"ldif_change_record_list : ldif_change_record",
"ldif_change_record_list : ldif_change_record_list MULTI_SEP ldif_change_record",
"ldif_record : dn_spec SEP attrval_spec_list",
"ldif_change_record : dn_spec SEPBYCHANGE changerecord_list",
"dn_spec : M_type DNCOLON M_normal any_space dn",
"dn_spec : M_type DNDCOLON M_normal any_space base64_dn",
"dn_spec : M_type DNCOLON M_normal",
"attrval_spec_list : attrval_spec",
"attrval_spec_list : attrval_spec_list sep attrval_spec",
"changerecord_list : changerecord",
"changerecord_list : changerecord_list SEPBYCHANGE changerecord",
"attrval_spec : M_name_read NAME M_type SINGLECOLON M_normal any_space M_safeval VALUE M_normal",
"attrval_spec : M_name_read NAME M_type DOUBLECOLON M_normal any_space M_string64 BASE64STRING M_normal",
"attrval_spec : M_name_read NAME M_type URLCOLON M_normal any_space M_safeval VALUE M_normal",
"attrval_spec : M_name_read NAME M_type SINGLECOLON M_normal",
"M_name_read : MODESWITCH",
"M_name_readnc : MODESWITCH",
"M_safeval : MODESWITCH",
"M_normal : MODESWITCH",
"M_string64 : MODESWITCH",
"M_digitread : MODESWITCH",
"M_type : MODESWITCH",
"M_changetype : MODESWITCH",
"add_token : ADD",
"add_token : NTDSADD",
"delete_token : MYDELETE",
"delete_token : NTDSMYDELETE",
"modify_token : MODIFY",
"modify_token : NTDSMODIFY",
"modrdn_token : MODRDN",
"modrdn_token : NTDSMODRDN",
"moddn_token : MODDN",
"moddn_token : NTDSMODDN",
"changerecord : change_add",
"changerecord : change_delete",
"changerecord : change_modify",
"changerecord : change_moddn",
"change_add : M_changetype T_CHANGETYPE M_normal any_space M_type add_token M_normal sep attrval_spec_list",
"change_add : M_changetype T_CHANGETYPE M_normal any_space M_type add_token M_normal",
"change_delete : M_changetype T_CHANGETYPE M_normal any_space M_type delete_token M_normal",
"change_moddn : chdn_normal",
"change_moddn : chdn_normal SEP new_superior",
"chdn_normal : modrdn SEP newrdncolon SEP deleteoldrdn",
"chdn_normal : moddn SEP newrdncolon SEP deleteoldrdn",
"chdn_normal : modrdn SEP newrdndcolon SEP deleteoldrdn",
"chdn_normal : moddn SEP newrdndcolon SEP deleteoldrdn",
"modrdn : M_changetype T_CHANGETYPE M_normal any_space M_type modrdn_token M_normal",
"moddn : M_changetype T_CHANGETYPE M_normal any_space M_type moddn_token M_normal",
"newrdncolon : M_type NEWRDNCOLON M_normal any_space dn",
"newrdndcolon : M_type NEWRDNDCOLON M_normal any_space base64_dn",
"deleteoldrdn : M_type DELETEOLDRDN M_normal any_space M_digitread DIGITS M_normal",
"new_superior : M_type NEWSUPERIORC M_normal any_space dn",
"new_superior : M_type NEWSUPERIORDC M_normal any_space base64_dn",
"change_modify : M_changetype T_CHANGETYPE M_normal any_space M_type modify_token M_normal SEP mod_spec_list",
"mod_spec_list : mod_spec",
"mod_spec_list : mod_spec_list SEP mod_spec",
"mod_spec : mod_add_spec",
"mod_spec : mod_delete_spec",
"mod_spec : mod_replace_spec",
"mod_add_spec : M_type ADDC M_normal any_space M_name_readnc NAMENC M_normal sep attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"mod_delete_spec : M_type DELETEC M_normal any_space M_name_readnc NAMENC M_normal maybe_attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"mod_replace_spec : M_type REPLACEC M_normal any_space M_name_readnc NAMENC M_normal maybe_attrval_spec_list SEPBYMINUS M_type MINUS M_normal",
"maybe_attrval_spec_list :",
"maybe_attrval_spec_list : sep attrval_spec_list",
"sep : SEP",
"sep : SEPBYCHANGE",
"any_sep : SEP",
"any_sep : MULTI_SEP",
"any_space :",
"any_space : MULTI_SPACE",
"dn : M_safeval VALUE M_normal",
"base64_dn : M_string64 BASE64STRING M_normal",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#line 1237 "ldif.y"



#line 417 "y_tab.c"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif

    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif

    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
#line 84 "ldif.y"
{ DBGPRNT("ldif_Content\n"); }
break;
case 2:
#line 85 "ldif.y"
{ DBGPRNT("ldif_Changes\n"); }
break;
case 3:
#line 89 "ldif.y"
{ 
                    DBGPRNT("ldif_record_list\n"); 
                }
break;
case 4:
#line 93 "ldif.y"
{
                    DBGPRNT("v/ldif_record_list\n"); 
                }
break;
case 5:
#line 97 "ldif.y"
{ 
                    DBGPRNT("ldif_record_list\n"); 
                }
break;
case 6:
#line 103 "ldif.y"
{ 
                    DBGPRNT("ldif_change_record_list\n"); 
                }
break;
case 7:
#line 107 "ldif.y"
{ 
                    DBGPRNT("v/ldif_change_record_list\n");
                }
break;
case 8:
#line 111 "ldif.y"
{ 
                    DBGPRNT("ldif_change_record_list\n");
                }
break;
case 9:
#line 117 "ldif.y"
{ 
                    RuleLastBig=R_VERSION;
                    RuleExpect=RE_REC_OR_CHANGE;
                    TokenExpect=RT_DN;
                    DBGPRNT("Version spec\n");
                }
break;
case 10:
#line 125 "ldif.y"
{ 
                    RuleLast=RS_VERNUM;
                    RuleExpect=RE_REC_OR_CHANGE;
                    TokenExpect=RT_DN;
                    DBGPRNT("Version number\n"); 
                }
break;
case 15:
#line 151 "ldif.y"
{ 
                                
                            /**/
                            /* first action here is to take the linked list of */
                            /* attributes that was built up in attrval_spec_list */
                            /* and turn it into an LDAPModW **mods array. */
                            /* Everything having to do with the */
                            /* attrval_spec_list that is not necessary for the */
                            /* new array will be either destroyed or cleared*/
                            /**/
                            g_pObject.ppMod = GenerateModFromList(PACK);

                            SetModOps(g_pObject.ppMod, 
                                        LDAP_MOD_ADD);
                            
                            /**/
                            /* now assign the dn*/
                            /**/
                            g_pObject.pszDN = yyvsp[-2].wstr;
                            
                            DBGPRNT("\nldif_record\n"); 
                            
                            RuleLastBig=R_REC;
                            RuleExpect=RE_REC;
                            TokenExpect=RT_DN;
                            
                            if (FileType==F_NONE) {
                                FileType = F_REC;
                            } 
                            else if (FileType==F_CHANGE) {
                                RaiseException(LL_FTYPE, 0, 0, NULL);
                            }
                            return LDIF_REC;
                        }
break;
case 16:
#line 188 "ldif.y"
{ 
                            /**/
                            /* By the time we've parsed to here we've got a dn */
                            /* and a changes_list pointed to by changes_start. */
                            /* We're going to return to the caller the fact that */
                            /* what we're gving back is a changes list and not */
                            /* the regular g_pObject.ppMod. The client is */
                            /* responsible for walking down the list */
                            /* start_changes, using it, and, freeing the memory*/
                            /**/
                            g_pObject.pszDN = yyvsp[-2].wstr;
                            
                            DBGPRNT("\nldif_change_record\n"); 
                            
                            RuleLastBig = R_CHANGE;
                            RuleExpect = RE_CHANGE;
                            TokenExpect = RT_DN;
                            
                            if (FileType == F_NONE) {
                                FileType = F_CHANGE;
                            } 
                            else if (FileType == F_REC) {
                                RaiseException(LL_FTYPE, 0, 0, NULL);
                            }   
                            return LDIF_CHANGE;
                        }
break;
case 17:
#line 217 "ldif.y"
{ 
                            yyval.wstr = yyvsp[0].wstr; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 18:
#line 224 "ldif.y"
{ 
                            yyval.wstr = yyvsp[0].wstr; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 19:
#line 231 "ldif.y"
{ 
                            yyval.wstr = NULL; 
                            RuleLastBig=R_DN;
                            RuleExpect=RE_ENTRY;
                            TokenExpect=RT_ATTR_OR_CHANGE;
                        }
break;
case 20:
#line 246 "ldif.y"
{ 
                            RuleLastBig=R_AVS;
                            RuleExpect=RE_AVS_OR_END;
                            TokenExpect=RT_ATTR_MIN_SEP;
                            AddModToSpecList(yyvsp[0].mod); 
                        }
break;
case 21:
#line 253 "ldif.y"
{ 
                            RuleLastBig=R_AVS;
                            RuleExpect=RE_AVS_OR_END;
                            TokenExpect=RT_ATTR_MIN_SEP;
                            AddModToSpecList(yyvsp[0].mod); 
                        }
break;
case 22:
#line 262 "ldif.y"
{ 
                            ChangeListAdd(yyvsp[0].change); 
                        }
break;
case 23:
#line 266 "ldif.y"
{ 
                            ChangeListAdd(yyvsp[0].change); 
                        }
break;
case 24:
#line 275 "ldif.y"
{
                
                            /**/
                            /* What we're doing below is creating the attribute */
                            /* with the specified value and then freeing the */
                            /* strings we used.*/
                            /**/
                           
                            yyval.mod = GenereateModFromAttr(yyvsp[-7].wstr, (PBYTE)yyvsp[-1].wstr, -1);
                            MemFree(yyvsp[-7].wstr);
                        }
break;
case 25:
#line 289 "ldif.y"
{
                           long decoded_size;
                           PBYTE decoded_buffer;
                           
                        
                           /**/
                           /* Take the steps required to decode the data*/
                           /**/
                                           
                           if(!(decoded_buffer=base64decode(yyvsp[-1].wstr, 
                                                            &decoded_size))) {
                                                            
                                /**/
                                /* Actually, the only way base64decode will return*/
                                /* with NULL is if it runs into a memory issue. */
                                /* (which would generate an exception... Well, you */
                                /* know the story by now if you've read the other */
                                /* source files. (i.e. ldifldap.c)*/
                                /**/
                                DBGPRNT("Error decoding Base64 value");
                            }
                           
                            /* */
                            /* make the attrbiute*/
                            /**/
                            yyval.mod = GenereateModFromAttr(yyvsp[-7].wstr, decoded_buffer, decoded_size);
                            MemFree(yyvsp[-1].wstr);
                            MemFree(yyvsp[-7].wstr);
                        }
break;
case 26:
#line 320 "ldif.y"
{
                        
                            long            fileSize;
                            PBYTE           readData;
                            size_t          chars_read;
                            DBGPRNT("\nNote: The access mechanism for URLS is very simple.\n");
                            DBGPRNT("If rload is not responding, the URL\nmay be invalid.");
                            DBGPRNT(" Ctrl-C, check your URL and try again.\n\n");
                        
                            /**/
                            /* Reading the URL should prove to be a mean trick*/
                            /**/
                        
                            if (!(S_OK==URLDownloadToFileW(NULL, 
                                                          yyvsp[-1].wstr, 
                                                          g_szTempUrlfilename, 
                                                          0, 
                                                          NULL))) {
                                DBGPRNT("URL read failed\n");
                                RaiseException(LL_URL, 0, 0, NULL);
                            } 
                            
                            /**/
                            /* We now have a filename. There is data in it.*/
                            /* let us use this data*/
                            /**/
                            if( (g_pFileUrlTemp = 
                                    _wfopen( g_szTempUrlfilename, L"rb" ))== NULL ) {
                                RaiseException(LL_URL, 0, 0, NULL);
                            }
    
                            /**/
                            /* get file size*/
                            /**/
                            if( (fileSize = _filelength(_fileno(g_pFileUrlTemp))) == -1)
                            {
                                DBGPRNT("filelength OR fileno failed");
                                RaiseException(LL_URL, 0, 0, NULL);
                            }
    
                            readData = MemAlloc_E(fileSize*sizeof(BYTE));
                            
                            /**/
                            /* read it all in*/
                            /**/
                            chars_read=fread(readData, 
                                             1, 
                                             fileSize, 
                                             g_pFileUrlTemp);
                        
                            /**/
                            /* For some reason, _filelength returns one */
                            /* character more than fread wants to read. Perhaps */
                            /* its the EOF character. However, it seems that if */
                            /* there is no EOF character, all the bytes are */
                            /* read.*/

                            if ( (long)chars_read+1 < fileSize) {
                                DBGPRNT("Didn't read in all data in file.");
                                RaiseException(LL_URL, 0, 0, NULL);
                            }
                            
                            if (!feof(g_pFileUrlTemp)&&ferror(g_pFileUrlTemp)) {
                                DBGPRNT("EOF NOT reached. Error on stream.");
                                RaiseException(LL_URL, 0, 0, NULL);
                            }
                            
                            /**/
                            /* Well, if an fclose fails, all is lost anyway, */
                            /* so forget it.*/
                            /**/
                            fclose(g_pFileUrlTemp);                  
                            g_pFileUrlTemp = NULL;
                            
                            yyval.mod = GenereateModFromAttr(yyvsp[-7].wstr, readData, fileSize);
                            
                            /**/
                            /* Note: It appears that newlines in the source file*/
                            /*       appear as '|'s when viewed by ldp*/
                            /**/
                            
                            /**/
                            /* Again, note that we're not freeing readData */
                            /* because it was used when making the attribute*/
                            /**/
                            
                            /**/
                            /* free the memory we used in allocating for the */
                            /* tokens*/
                            /**/
                            MemFree(yyvsp[-7].wstr);
                            MemFree(yyvsp[-1].wstr);

                        }
break;
case 27:
#line 416 "ldif.y"
{
                            /* */
                            /* If the value is empty, just pass a null string  */
                            /* Unforutnately, LDAP doesn't beleive in these, so*/
                            /* its kindof pointless*/
                            /**/
                            yyval.mod = GenereateModFromAttr(yyvsp[-3].wstr, (PBYTE)L"", -1);
                            MemFree(yyvsp[-3].wstr);
                        }
break;
case 28:
#line 434 "ldif.y"
{ 
                    DBGPRNT(("PARSER: Switching lexer to ATTRNAME read.\n"));
                    Mode = C_ATTRNAME;
                }
break;
case 29:
#line 440 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to ATTRNAMENC read.\n");
                    Mode = C_ATTRNAMENC;
                }
break;
case 30:
#line 446 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to SAFEVALUE read.\n");
                    Mode = C_SAFEVAL;
                }
break;
case 31:
#line 453 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to NORMAL mode.\n");
                    Mode = C_NORMAL;
                }
break;
case 32:
#line 460 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to STRING64 mode.\n");
                    Mode = C_M_STRING64;
                }
break;
case 33:
#line 467 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to DIGITREAD mode.\n");
                    Mode = C_DIGITREAD;
                }
break;
case 34:
#line 475 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to TYPE mode.\n");
                    Mode = C_TYPE;
                }
break;
case 35:
#line 481 "ldif.y"
{ 
                    DBGPRNT("PARSER: Switching lexer to CHANGETYPE mode.\n");
                    Mode = C_CHANGETYPE;
                }
break;
case 36:
#line 487 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 37:
#line 488 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 38:
#line 491 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 39:
#line 492 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 40:
#line 495 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 41:
#line 496 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 42:
#line 499 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 43:
#line 500 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 44:
#line 503 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 45:
#line 504 "ldif.y"
{ yyval.num=yyvsp[0].num; }
break;
case 46:
#line 507 "ldif.y"
{ yyval.change=yyvsp[0].change; }
break;
case 47:
#line 508 "ldif.y"
{ yyval.change=yyvsp[0].change; }
break;
case 48:
#line 509 "ldif.y"
{ yyval.change=yyvsp[0].change; }
break;
case 49:
#line 510 "ldif.y"
{ yyval.change=yyvsp[0].change; }
break;
case 50:
#line 516 "ldif.y"
{
                    /**/
                    /* make the change_list node we'll use*/
                    /**/
                    yyval.change=(struct change_list *)
                            MemAlloc_E(sizeof(struct change_list));
                    
                    /**/
                    /* set the mods member of the stuff union inside the node to */
                    /* the attrval list we've built*/
                    /**/
                    /* DBGPRNT(("change_add is now equal to %x\n", $$));*/
                    
                    yyval.change->mods_mem=GenerateModFromList(PACK);
                    
                    /**/
                    /* now set the mod_op fields in the mods. This isn't really */
                    /* necessary in this case, but I am doing it to be */
                    /* consistent*/
                    /**/
                    SetModOps(yyval.change->mods_mem, LDAP_MOD_ADD);
                    
                    /**/
                    /* set the operation inside the node to indicate to the */
                    /* client what we are doing*/
                    /**/
                    if (yyvsp[-3].num == 0) { 
                        yyval.change->operation=CHANGE_ADD;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSADD;
                    }
                    
                    /**/
                    /* note that we are not setting the next field, as it will */
                    /* be set by the function that builds up the changes list.*/
                    /**/
                    DBGPRNT("parsed a change add\n");
                    
                    RuleLastBig=R_C_ADD;
                    RuleExpect=RE_CHANGE;
                    TokenExpect=RT_DN;
                }
break;
case 51:
#line 561 "ldif.y"
{
                    /**/
                    /* make the change_list node we'll use*/
                    /**/
                    yyval.change=(struct change_list *)
                            MemAlloc_E(sizeof(struct change_list));
                    
                    yyval.change->mods_mem=GenerateModFromList(EMPTY);
                    
                    /**/
                    /* now set the mod_op fields in the mods. This isn't really */
                    /* necessary in this case, but I am doing it to be */
                    /* consistent*/
                    /**/
                    SetModOps(yyval.change->mods_mem, LDAP_MOD_ADD);
                    
                    /**/
                    /* set the operation inside the node to indicate to the */
                    /* client what we are doing*/
                    /**/
                    if (yyvsp[-1].num == 0) { 
                        yyval.change->operation=CHANGE_ADD;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSADD;
                    }
                    
                    /**/
                    /* note that we are not setting the next field, as it will */
                    /* be set by the function that builds up the changes list.*/
                    /**/
                    DBGPRNT("parsed a change add\n");
                    
                    RuleLastBig=R_C_ADD;
                    RuleExpect=RE_CHANGE;
                    TokenExpect=RT_DN;
                }
break;
case 52:
#line 602 "ldif.y"
{
                    /**/
                    /* make the change_list node we'll use*/
                    /**/
                    yyval.change = (struct change_list *)
                            MemAlloc_E(sizeof(struct change_list));
                            
                    if (yyvsp[-1].num == 0) {
                        yyval.change->operation=CHANGE_DEL;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSDEL;
                    }
                    
                    RuleLastBig=R_C_DEL;
                    RuleExpect=RE_CH_OR_NEXT;
                    TokenExpect=RT_CH_OR_SEP;
                }
break;
case 53:
#line 623 "ldif.y"
{ 
                    yyval.change = yyvsp[0].change;
                    
                    RuleLastBig=R_C_DN;
                    RuleExpect=RE_CH_OR_NEXT;
                    TokenExpect=RT_CH_OR_SEP;
                }
break;
case 54:
#line 631 "ldif.y"
{
                    PWSTR           pszTemp = NULL;
                    /**/
                    /* now the way I interpreted the spec and the LDAP API is */
                    /* that when the new superior is specified, it should be */
                    /* appended to the rdn to create an entire DN.*/
                    /**/
                    
                    pszTemp=(PWSTR)MemAlloc_E((wcslen(yyvsp[-2].change->dn_mem)
                                +wcslen(yyvsp[0].wstr)+10)*sizeof(WCHAR));
                    swprintf(pszTemp, L"%s, %s", yyvsp[-2].change->dn_mem, yyvsp[0].wstr);
    
                    MemFree(yyvsp[-2].change->dn_mem);
                    MemFree(yyvsp[0].wstr);
            
                    yyvsp[-2].change->dn_mem=pszTemp;

                    yyval.change=yyvsp[-2].change;
                    
                    RuleLastBig=R_C_NEWSUP;
                    RuleExpect=RE_CH_OR_NEXT;
                    TokenExpect=RT_CH_OR_SEP;
                }
break;
case 55:
#line 666 "ldif.y"
{
                    yyval.change=(struct change_list *)
                                MemAlloc_E(sizeof(struct change_list));
                    
                    if (yyvsp[-4].num == 0) {
                        yyval.change->operation=CHANGE_DN;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSDN;
                    }
                    yyval.change->deleteold=yyvsp[0].num;
                    yyval.change->dn_mem=yyvsp[-2].wstr;
                }
break;
case 56:
#line 680 "ldif.y"
{
                    yyval.change=(struct change_list *)
                                MemAlloc_E(sizeof(struct change_list));
                    if (yyvsp[-4].num == 0) {
                        yyval.change->operation=CHANGE_DN;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSDN;
                    }
                    yyval.change->deleteold=yyvsp[0].num;
                    yyval.change->dn_mem=yyvsp[-2].wstr;
                }
break;
case 57:
#line 693 "ldif.y"
{
                    yyval.change=(struct change_list *)
                                MemAlloc_E(sizeof(struct change_list));
                    if (yyvsp[-4].num == 0) {
                        yyval.change->operation=CHANGE_DN;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSDN;
                    }
                    yyval.change->deleteold=yyvsp[0].num;
                    yyval.change->dn_mem=yyvsp[-2].wstr;
                
                }
break;
case 58:
#line 707 "ldif.y"
{
                    yyval.change=(struct change_list *)
                                MemAlloc_E(sizeof(struct change_list));
                    if (yyvsp[-4].num == 0) {
                        yyval.change->operation=CHANGE_DN;
                    }
                    else {
                        yyval.change->operation=CHANGE_NTDSDN;
                    }
                    yyval.change->deleteold=yyvsp[0].num;
                    yyval.change->dn_mem=yyvsp[-2].wstr;
                }
break;
case 59:
#line 723 "ldif.y"
{ 
                    yyval.num = yyvsp[-1].num; 
                }
break;
case 60:
#line 730 "ldif.y"
{ 
                    yyval.num = yyvsp[-1].num; 
                }
break;
case 61:
#line 736 "ldif.y"
{ 
                    yyval.wstr=MemAllocStrW_E(yyvsp[0].wstr); 
                    MemFree(yyvsp[0].wstr);
                }
break;
case 62:
#line 743 "ldif.y"
{ 
                    yyval.wstr=MemAllocStrW_E(yyvsp[0].wstr); 
                }
break;
case 63:
#line 750 "ldif.y"
{ 
                    yyval.num=yyvsp[-1].num; 
                }
break;
case 64:
#line 755 "ldif.y"
{ 
                    yyval.wstr=MemAllocStrW_E(yyvsp[0].wstr); 
                    MemFree(yyvsp[0].wstr);
                }
break;
case 65:
#line 759 "ldif.y"
{ 
                    yyval.wstr=MemAllocStrW_E(yyvsp[0].wstr); 
                }
break;
case 66:
#line 766 "ldif.y"
{
                        
                    /**/
                    /* If there is not enough room for the NULL terminator, */
                    /* add it*/
                    /**/
                    if (g_cModSpecUsedup==CHUNK) {
                        
                        DBGPRNT("WE don't have enough room for the null terminator. Alloc\n");
                        /**/
                        /* We've already used up the last slot in the current */
                        /* memory block*/
                        /**/
                        if ((g_ppModSpec=(LDAPModW**)MemRealloc_E(g_ppModSpec, 
                                      g_nModSpecSize+sizeof(LDAPModW *)))==NULL) {
                            perror("Not enough memory for  specs!");
                        }
                        g_nModSpecSize=MemSize(g_ppModSpec);
                    
                        /**/
                        /* The thing is that our heap may have moved, so we must */
                        /* repostion g_ppModSpecNext*/
                        /**/
                        g_ppModSpecNext=g_ppModSpec;
                        g_ppModSpecNext=g_ppModSpecNext+(g_cModSpec*CHUNK);
                    
                        g_cModSpec++;
                        
                        /**/
                        /* lets go again*/
                        /**/
                        g_cModSpecUsedup=0;
                    }
                 
                    *g_ppModSpecNext=NULL;
                 
                    /**/
                    /* now we have a full LDAPModWs* array with our changes, lets */
                    /* make the change node*/
                    /**/
                    
                    /**/
                    /* make the change_list node we'll use*/
                    /**/
                    yyval.change=(struct change_list *)MemAlloc_E(sizeof(struct change_list));
                    
                    if (yyvsp[-3].num==0) {
                      yyval.change->operation=CHANGE_MOD;
                    }
                    else {
                      yyval.change->operation=CHANGE_NTDSMOD;
                    }
                    yyval.change->mods_mem=g_ppModSpec;
                    
                    /**/
                    /* reset our variables for the next set*/
                    /**/
                    g_cModSpecUsedup=0;
                    g_cModSpec=0;
                    g_ppModSpec=NULL; 
                    g_ppModSpecNext=NULL;
                    g_nModSpecSize=0;    
                    
                    RuleLastBig=R_C_MOD;
                    RuleExpect=RE_CH_OR_NEXT;
                    TokenExpect=RT_CH_OR_SEP;
                }
break;
case 67:
#line 837 "ldif.y"
{
                    /**/
                    /* if its the first mod_spec we have, lets allocate the */
                    /* first chunk*/
                    /**/
                    if (g_nModSpecSize==0) {
                        g_ppModSpec=(LDAPModW **)MemAlloc_E(CHUNK*sizeof(LDAPModW *));
                        g_nModSpecSize=MemSize(g_ppModSpec);
                        g_cModSpec++;
                        g_ppModSpecNext=g_ppModSpec;
                    } 
                    else if (g_cModSpecUsedup==CHUNK) {
                    
                        /* Specs: %d\n", g_cModSpecUsedup                      */
                        DBGPRNT("Chunk used up, reallocating."); 
                   
                        /**/
                        /* We've already used up the last slot in the current */
                        /* memory block*/
                        /**/
                        g_ppModSpec=(LDAPModW **)MemRealloc_E(g_ppModSpec, 
                                          g_nModSpecSize+CHUNK*sizeof(LDAPModW *));
                        g_nModSpecSize=MemSize(g_ppModSpec);
                        
                        /**/
                        /* The thing is that our heap may have moved, so we must */
                        /* repostion g_ppModSpecNext*/
                        /**/
                        g_ppModSpecNext=g_ppModSpec;
                        g_ppModSpecNext=g_ppModSpecNext+(g_cModSpec*CHUNK);
                    
                        g_cModSpec++;
                    
                        /**/
                        /* lets go again*/
                        /**/
                        g_cModSpecUsedup=0;
                    }
                    
                    /**/
                    /* now that this memory b.s. is over, lets actually assign */
                    /* the mod*/
                    /**/
                    *g_ppModSpecNext=yyvsp[0].mod;
                    g_ppModSpecNext++;
                    g_cModSpecUsedup++;
                    
                    RuleLastBig=R_C_MODSPEC;
                    RuleExpect=RE_MODSPEC_END;
                    TokenExpect=RT_MODBEG_SEP;
                }
break;
case 68:
#line 889 "ldif.y"
{
                    /**/
                    /* if its the first mod_spec we have, lets allocate the */
                    /* first chunk*/
                    /**/
                    if (g_nModSpecSize==0) {
                        g_ppModSpec=(LDAPModW **)MemAlloc_E(CHUNK*sizeof(LDAPModW *));
                        g_nModSpecSize=MemSize(g_ppModSpec);
                        g_cModSpec++;
                        g_ppModSpecNext=g_ppModSpec;
                    } 
                    else if (g_cModSpecUsedup==CHUNK) {
                    
                        /**/
                        /* Specs: %d\n", g_cModSpecUsedup*/
                        /**/
                        DBGPRNT("Chunk used up, reallocating."); 
    
                        /**/
                        /* We've already used up the last slot in the current */
                        /* memory block*/
                        /**/
                        g_ppModSpec=(LDAPModW **)MemRealloc_E(g_ppModSpec, 
                                      g_nModSpecSize+CHUNK*sizeof(LDAPModW *));
                        g_nModSpecSize=MemSize(g_ppModSpec);
                    
                        /* */
                        /* The thing is that our heap may have moved, so we must */
                        /* repostion g_ppModSpecNext*/
                        /**/
                        g_ppModSpecNext=g_ppModSpec;
                        g_ppModSpecNext=g_ppModSpecNext+(g_cModSpec*CHUNK);
                        
                        g_cModSpec++;
                                            
                        /**/
                        /* lets go again*/
                        /**/
                        g_cModSpecUsedup=0;
                    }
                    
                    /**/
                    /* now that this memory b.s. is over, lets actually assign */
                    /* the mod*/
                    /**/
                    *g_ppModSpecNext=yyvsp[0].mod;
                    g_ppModSpecNext++;
                    g_cModSpecUsedup++;
                    
                    RuleLastBig=R_C_MODSPEC;
                    RuleExpect=RE_MODSPEC_END;
                    TokenExpect=RT_MODBEG_SEP;
                }
break;
case 69:
#line 944 "ldif.y"
{ yyval.mod=yyvsp[0].mod; }
break;
case 70:
#line 945 "ldif.y"
{ yyval.mod=yyvsp[0].mod; }
break;
case 71:
#line 946 "ldif.y"
{ yyval.mod=yyvsp[0].mod; }
break;
case 72:
#line 951 "ldif.y"
{
                    LDAPModW **ppModTmp = NULL;
                    /**/
                    /* The attribute value spec list element above is actually */
                    /* an LDAPModW** array, whose first element is the the one */
                    /* we are looking for. (The second element is null)*/
                    /**/
                    ppModTmp=GenerateModFromList(PACK);     
                    
                    /**/
                    /* assign the one we want*/
                    /**/
                    yyval.mod=ppModTmp[0];
                    
                    if (ppModTmp[1]!=NULL) {
                        DBGPRNT("WARNING: Extra names in modify add.\n");
                    
                        /**/
                        /* note that the character and line number will not be */
                        /* correct*/
                        /**/
                        RaiseException(LL_EXTRA, 0, 0, NULL);
                    }
                    
                    /**/
                    /* remember that it may haven't berval'd*/
                    /**/
                    yyval.mod->mod_op=(yyval.mod->mod_op)|LDAP_MOD_ADD; 
                    
                    /**/
                    /* This is really kindof pointless, since the name has */
                    /* already been set by a properly written modify, but we */
                    /* should follow the spec */
                    /**/
                    MemFree(yyval.mod->mod_type);
                    yyval.mod->mod_type= MemAllocStrW_E(yyvsp[-7].wstr);
                    MemFree(yyvsp[-7].wstr);
                    
                    /**/
                    /* the thing now is that  we've grabbed away the first */
                    /* element. However, the user may have made a mistake and */
                    /* specified more attributes with other names in this field. */
                    /* He'll get lucky if the first attribute he specified was */
                    /* the one we're changing. */
                    /* well, to make a long story short, we should reform the */
                    /* first element and properly free this array*/
                    /**/
                    ppModTmp[0]=(LDAPModW *)MemAlloc_E(sizeof(LDAPModW));
                    ppModTmp[0]->mod_type=MemAllocStrW_E(L"blah");
                    ppModTmp[0]->mod_op=LDAP_MOD_ADD;
                    ppModTmp[0]->mod_values=(PWSTR*)MemAlloc_E(sizeof(PWSTR));
                    ppModTmp[0]->mod_values[0]=NULL;
                    
                    /**/
                    /* free the array, we don't need it*/
                    /**/
                    FreeAllMods(ppModTmp);
                    DBGPRNT("Add modify.\n");
                }
break;
case 73:
#line 1015 "ldif.y"
{
                    
                        if (yyvsp[-4].num) {
                        
                            LDAPModW **ppModTmp = NULL;
                            /* The attribute value spec list element above is */
                            /* actually an LDAPModW** array, whose first element */
                            /* is the the one we are looking for. (The second */
                            /* element is null)*/
                            /**/
                            ppModTmp = GenerateModFromList(PACK);            
                            
                            /**/
                            /* assign the one we want*/
                            /**/
                            yyval.mod = ppModTmp[0];
                            
                            if (ppModTmp[1]!=NULL) {
                                DBGPRNT("WARNING: Extra attr names in mod del.\n");
                                RaiseException(LL_EXTRA, 0, 0, NULL);
                            }
                            
                            /**/
                            /* This is really kindof pointless, since the name */
                            /* has already been set by a properly written */
                            /* modify, but we should follow the spec*/
                            /**/
                            MemFree(yyval.mod->mod_type);
                            yyval.mod->mod_type = MemAllocStrW_E(yyvsp[-6].wstr);
                            MemFree(yyvsp[-6].wstr);
                            
                            /* */
                            /* the thing now is that  we've grabbed away the */
                            /* first element. However, the user may have made a */
                            /* mistake and specified more attributes with other */
                            /* names in this field. He'll get lucky if the first */
                            /* attribute he specified was the one we're */
                            /* changing. well, to make a long story short, we */
                            /* should reform the first element and properly free */
                            /* this array*/
                            /**/
                            ppModTmp[0] = (LDAPModW *)MemAlloc_E(sizeof(LDAPModW));
                            ppModTmp[0]->mod_type = MemAllocStrW_E(L"blah");
                            ppModTmp[0]->mod_op = LDAP_MOD_ADD;
                            ppModTmp[0]->mod_values = (PWSTR*)MemAlloc_E(sizeof(PWSTR));
                            ppModTmp[0]->mod_values[0] = NULL;
                            
                            /**/
                            /* free the array, we don't need it*/
                            /**/
                            FreeAllMods(ppModTmp);
                        } 
                        else {
                        
                            yyval.mod = (LDAPModW *)MemAlloc_E(sizeof(LDAPModW));
                            yyval.mod->mod_values = NULL;
                            yyval.mod->mod_type = MemAllocStrW_E(yyvsp[-6].wstr);
                            MemFree(yyvsp[-6].wstr);
                            yyval.mod->mod_op = 0;
                        
                        }
                       
                        /**/
                        /* set its op field*/
                        /**/
                        yyval.mod->mod_op = (yyval.mod->mod_op)|LDAP_MOD_DELETE; 
                        
                        /**/
                        /* remember that it may haven't berval'd*/
                        /**/
                        DBGPRNT("Modify delete.\n");
                    }
break;
case 74:
#line 1093 "ldif.y"
{
                        if (yyvsp[-4].num) {
                            
                            LDAPModW **ppModTmp = NULL;
                            /* */
                            /* The attribute value spec list element above is */
                            /* actually an LDAPModW** array, whose first element is */
                            /* the the one we are looking for. (The second element */
                            /* is null)* /*/
                            
                            ppModTmp = GenerateModFromList(PACK);            
                            
                            /**/
                            /* assign the one we want*/
                            /**/
                            yyval.mod = ppModTmp[0];
                            
                            if (ppModTmp[1]!= NULL) {
                                DBGPRNT("WARNING: Extraneous attribute names specified in modify replace.\n");
                                RaiseException(LL_EXTRA, 0, 0, NULL);
                            }
                            
                            /**/
                            /* This is really kindof pointless, since the name has */
                            /* already been set by a properly written modify, but we */
                            /* should follow the spec*/
                            /**/
                            MemFree(yyval.mod->mod_type);
                            yyval.mod->mod_type = MemAllocStrW_E(yyvsp[-6].wstr);
                            MemFree(yyvsp[-6].wstr);
                            
                            /**/
                            /* the thing now is that  we've grabbed away the first */
                            /* element. However, the user may have made a mistake */
                            /* and specified more attributes with other names in */
                            /* this field. He'll get lucky if the first attribute he */
                            /* specified was the one we're changing. well, to make a*/
                            /* long story short, we should reform the first element */
                            /* and properly free this array*/
                            /**/
                            ppModTmp[0] = (LDAPModW *)MemAlloc_E(sizeof(LDAPModW));
                            ppModTmp[0]->mod_type = MemAllocStrW_E(L"blah");
                            ppModTmp[0]->mod_op = LDAP_MOD_ADD;
                            ppModTmp[0]->mod_values = (PWSTR*)MemAlloc_E(sizeof(PWSTR));
                            ppModTmp[0]->mod_values[0] = NULL;
                            
                            /**/
                            /* free the array, we don't need it*/
                            /**/
                            FreeAllMods(ppModTmp);
                        } 
                        else {
                        
                            yyval.mod = (LDAPModW *)MemAlloc_E(sizeof(LDAPModW));
                            yyval.mod->mod_values = NULL;
                            yyval.mod->mod_type = MemAllocStrW_E(yyvsp[-6].wstr);
                            MemFree(yyvsp[-6].wstr);
                            yyval.mod->mod_op = 0;
                        
                        }
                       
                        /**/
                        /* set its op field*/
                        /* */
                        yyval.mod->mod_op=(yyval.mod->mod_op)|LDAP_MOD_REPLACE; 
                        
                        /* */
                        /* remember that it may haven't berval'd*/
                        /**/
                        DBGPRNT("Modify replace.\n");
                    }
break;
case 75:
#line 1171 "ldif.y"
{ 
                                yyval.num=0; 
                            }
break;
case 76:
#line 1175 "ldif.y"
{ 
                                yyval.num=1; 
                            }
break;
case 83:
#line 1194 "ldif.y"
{ 
                            yyval.wstr = MemAllocStrW_E(yyvsp[-1].wstr); 
                            MemFree(yyvsp[-1].wstr);
                        }
break;
case 84:
#line 1201 "ldif.y"
{  
                            /**/
                            /* The string better decode to somehting with a \0*/
                            /* at the end*/
                            /**/
                            PBYTE pByte;
                            PWSTR pszUnicode;
                            DWORD dwLen;
                            long decoded_size;
                            
                            if(!(pByte=base64decode(yyvsp[-1].wstr, &decoded_size))) {
                                perror("Error decoding Base64 dn");
                            }
                           
                            /*
                            //
                            // I'll add the '\0' myself
                            //
                            if (($$=(char *)MemRealloc_E($$, 
                                    decoded_size+sizeof(char)))==NULL) {
                                perror("Not enough memory for base64dn!");
                            }
                            */
                            
                            ConvertUTF8ToUnicode(
                                pByte,
                                decoded_size,
                                &pszUnicode,
                                &dwLen
                                );
                           
                            yyval.wstr = pszUnicode;
                            MemFree(yyvsp[-1].wstr);
                        }
break;
#line 1718 "y_tab.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = (short)yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\lexer.c ===
#include <precomp.h>
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#ifndef _MSC_VER
  #include <unistd.h>
#endif

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)

typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 45
#define YY_END_OF_BUFFER 46
static yyconst short int yy_accept[241] =
    {   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,   46,   44,
       45,   12,   45,   44,   16,   44,   44,   19,   13,   39,
       22,   44,   44,   44,   44,   44,   44,    4,    3,    3,
        4,   44,   43,   44,   18,   12,    5,    8,   11,    8,
        8,   16,    0,    0,   17,   19,   19,   13,   20,   21,
        0,    0,    0,    0,    0,    0,    0,    0,    2,    1,
        0,   43,    0,   18,   11,    0,    9,    0,    0,   34,
        0,    7,    0,    0,    0,    0,    0,    1,    0,    0,

        0,    0,   38,    0,    6,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,   15,    0,    0,   25,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       36,   40,   23,    0,    0,    0,    0,    0,    0,    0,
        0,   31,    0,   26,    0,    0,    0,    0,   42,    0,
        0,    0,   27,    0,    0,   32,   14,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,   33,    0,    0,   29,    0,    0,
        0,    0,    0,    0,    0,    0,   28,   30,   35,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,

        0,    0,    0,    0,    0,    0,   10,    0,    0,    0,
        0,    0,   37,   41,   24,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0
    } ;

static yyconst int yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    5,    6,    6,    7,    6,    6,    6,    6,    6,
        6,    6,    8,    6,    9,    6,   10,   11,   11,   11,
       11,   11,   11,   11,   11,   11,   11,   12,    6,   13,
        8,    6,    6,    6,   14,    8,   15,   16,   17,   18,
       19,   20,   21,    8,    8,   22,   23,   24,   25,   26,
        8,   27,   28,   29,   30,   31,   32,    8,   33,    8,
        6,    6,    6,    6,    6,    6,   14,    8,   15,   16,

       17,   18,   19,   20,   21,    8,    8,   22,   23,   24,
       25,   26,    8,   27,   28,   29,   30,   31,   32,    8,
       33,    8,    6,    6,    6,    6,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,

       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
       34,   34,   34,   34,   34
    } ;

static yyconst int yy_meta[36] =
    {   0,
        1,    1,    2,    2,    3,    4,    4,    5,    4,    6,
        5,    7,    4,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    5,    5,    5,    5,    5,    5,    5,
        5,    5,    5,    8,    9
    } ;

static yyconst short int yy_base[261] =
    {   0,
      333,  332,    0,    4,    7,    9,   13,   48,   83,  118,
      153,  188,   18,   20,  221,    0,   24,   29,   21,   27,
       59,   62,   31,   41,  252,  287,  331,  330,  332,  524,
      524,   35,   87,   89,    0,    0,  319,   30,  319,  524,
       46,  313,   51,  303,   59,  303,  302,  524,  313,  312,
        0,  295,    0,  295,    0,   68,  524,  524,   74,  103,
      294,    0,    0,  301,  524,    0,   98,  301,  524,  524,
      295,  288,  297,  292,  275,  290,  279,  277,  524,   76,
      281,    0,  288,    0,   96,  110,  524,  287,    0,  288,
      281,  285,  107,   97,  268,  273,  266,  524,  276,  268,

      261,  322,  524,  255,  524,  259,  264,  265,  264,  249,
      250,  263,  255,  263,  255,  254,  524,    0,  255,  524,
      238,  246,  245,  242,  252,  251,  240,  253,  245,  244,
      104,  524,  524,  248,  242,  238,  240,  227,  240,  220,
      218,  524,  224,  231,  215,  224,  228,  227,  524,  205,
      203,  218,  524,  211,  208,  524,  524,  203,  202,  200,
      201,  211,  205,  204,  204,  192,  117,  206,  205,  192,
      203,  198,  196,  187,  524,  356,  199,  198,  193,  186,
      191,    0,  190,  188,  179,  174,  524,  524,  524,  185,
      105,  183,  176,  181,  180,  166,  176,  171,  133,  169,

      123,  157,  167,  150,  158,  143,  524,  152,  156,  161,
      162,  149,  524,  524,  524,  159,  142,  150,  157,  151,
      153,  146,  150,  145,  147,  143,  126,  133,  121,  126,
      124,  146,   98,   85,   83,   73,   64,   41,   17,  524,
      380,  389,  398,  407,  416,  425,  434,  443,  452,  461,
      466,  470,  475,  483,  492,  498,  500,  504,  508,  514
    } ;

static yyconst short int yy_def[261] =
    {   0,
      241,  241,  241,  241,  242,  242,  243,  243,  244,  244,
      245,  245,  241,  241,  241,   15,  246,  246,  241,  241,
      247,  247,  241,  241,  248,  248,  241,  241,  240,  240,
      240,  240,  249,  249,  250,  251,  252,  253,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      254,  240,  255,  240,  256,  240,  240,  240,  240,  240,
      240,  250,  257,  252,  240,  258,  253,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  254,
      240,  255,  240,  256,  240,  240,  240,  240,  259,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,

      240,  260,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  251,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  176,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,

      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,    0,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240
    } ;

static yyconst short int yy_nxt[560] =
    {   0,
      240,   32,   33,   34,   32,   32,   33,   34,   32,   31,
       30,   31,   30,   30,   30,   31,   30,   30,   30,   30,
       31,   30,   31,   31,   30,   30,   49,   50,   39,   31,
       39,   49,   50,   31,   66,   51,   56,   57,   52,   56,
      199,   66,   66,   31,   52,   54,   30,   30,   30,   30,
       31,   30,   30,   30,   30,   54,   30,   69,   70,   30,
       30,   31,   30,   30,   31,   30,   30,   72,   30,   56,
       57,   30,   56,  199,   73,   75,   85,   85,   98,   98,
      199,   30,   30,   30,   30,   31,   30,   76,  239,   59,
       59,   59,   59,   30,   30,   60,   30,   60,   85,   85,

      238,   61,   66,   61,   86,   87,   87,   86,  199,   66,
       66,   86,   87,   87,   86,  142,   30,   30,   30,   30,
       31,   30,  106,  109,  110,  197,  237,  107,  143,   30,
      172,  198,  173,  108,  206,  207,  207,  206,  209,  174,
      233,  232,  231,  210,  206,  207,  207,  206,  199,  211,
      230,   30,   30,   30,   30,   31,   30,   30,  225,  229,
      226,  234,  228,  224,   30,   30,  235,  227,  223,  222,
      221,  220,  236,  199,  199,  199,  219,  218,  217,  199,
      216,  215,  214,  213,  212,  208,  205,   30,   30,   30,
       31,   30,   30,  204,  203,  202,  201,  200,  199,   30,

       30,  196,  195,  194,  193,  192,  191,  190,  189,  188,
      187,  181,  180,  179,  178,  177,  176,  175,  171,  170,
      169,  168,   30,   31,  167,  166,  165,  164,  163,   40,
      162,  161,   41,  160,   42,  159,   43,  158,  157,  156,
      155,  154,  153,   44,   45,  152,  151,   46,  150,  149,
      148,   47,   30,   30,   31,   30,  147,  146,  145,  144,
      141,  140,  139,   30,  138,  137,  136,  135,  134,  133,
      132,  131,  130,  129,  128,  127,  126,  125,  124,  123,
      122,  121,  120,  119,  116,   30,   30,   30,   30,   31,
       30,  115,  114,  113,  112,  111,  105,  104,   30,  103,

      101,  100,   99,   97,   96,   95,   94,   93,   92,   91,
       90,   68,   65,   88,   83,   81,   79,   79,   78,   77,
       30,   30,  117,  117,  117,  117,  117,   74,   71,   68,
       65,  240,   31,   31,   31,   31,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  117,  117,  182,  240,  240,
      182,  240,  240,  240,  240,  240,  240,  240,  240,  183,
      240,  184,  240,  240,  240,  240,  240,  240,  185,  186,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   35,
       35,   35,   35,   35,   35,   35,   35,   35,   36,   36,

       36,   36,   36,   36,   36,   36,   36,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   38,   38,   38,   38,
       38,   38,   38,   38,   38,   48,   48,   48,   48,   48,
       48,   48,   48,   48,   53,   53,   53,   53,   53,   53,
       53,   53,   53,   55,   55,   55,   55,   55,   55,   55,
       55,   55,   58,   58,   58,   58,   58,   58,   58,   58,
       58,   62,  240,   62,   62,   62,   62,   62,   62,   62,
       63,   63,   64,   64,   64,   64,   64,   67,   67,   67,
       67,   67,   67,   80,  240,   80,   80,   80,   80,   80,
       80,   80,   82,  240,  240,   82,   82,  240,   82,   82,

       84,   84,   84,   84,   89,   89,   66,   66,   66,   66,
       66,   66,  102,  102,  118,  118,  118,  240,  118,  118,
      240,  118,  118,   29,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240
    } ;

static yyconst short int yy_chk[560] =
    {   0,
        0,    3,    3,    3,    3,    4,    4,    4,    4,    5,
        5,    6,    6,    7,    7,    7,    7,    7,    7,    7,
       13,    7,   14,   19,    7,    7,   17,   17,   13,   20,
       14,   18,   18,   23,   38,   18,   32,   32,   19,   32,
      239,   38,   38,   24,   20,   23,    7,    7,    8,    8,
        8,    8,    8,    8,    8,   24,    8,   41,   41,    8,
        8,   21,   21,   21,   22,   22,   22,   43,   21,   56,
       56,   22,   56,  238,   43,   45,   59,   59,   80,   80,
      237,    8,    8,    9,    9,    9,    9,   45,  236,   33,
       33,   34,   34,   21,    9,   33,   22,   34,   85,   85,

      235,   33,   67,   34,   60,   60,   60,   60,  234,   67,
       67,   86,   86,   86,   86,  131,    9,    9,   10,   10,
       10,   10,   93,   94,   94,  191,  233,   93,  131,   10,
      167,  191,  167,   93,  199,  199,  199,  199,  201,  167,
      231,  230,  229,  201,  206,  206,  206,  206,  228,  201,
      227,   10,   10,   11,   11,   11,   11,   11,  224,  226,
      224,  232,  225,  223,   11,   11,  232,  224,  222,  221,
      220,  219,  232,  218,  217,  216,  212,  211,  210,  209,
      208,  205,  204,  203,  202,  200,  198,   11,   12,   12,
       12,   12,   12,  197,  196,  195,  194,  193,  192,   12,

       12,  190,  186,  185,  184,  183,  181,  180,  179,  178,
      177,  174,  173,  172,  171,  170,  169,  168,  166,  165,
      164,  163,   12,   15,  162,  161,  160,  159,  158,   15,
      155,  154,   15,  152,   15,  151,   15,  150,  148,  147,
      146,  145,  144,   15,   15,  143,  141,   15,  140,  139,
      138,   15,   25,   25,   25,   25,  137,  136,  135,  134,
      130,  129,  128,   25,  127,  126,  125,  124,  123,  122,
      121,  119,  116,  115,  114,  113,  112,  111,  110,  109,
      108,  107,  106,  104,  101,   25,   25,   26,   26,   26,
       26,  100,   99,   97,   96,   95,   92,   91,   26,   90,

       88,   83,   81,   78,   77,   76,   75,   74,   73,   72,
       71,   68,   64,   61,   54,   52,   50,   49,   47,   46,
       26,   26,  102,  102,  102,  102,  102,   44,   42,   39,
       37,   29,   28,   27,    2,    1,    0,    0,    0,    0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,  102,  102,  176,    0,    0,
      176,    0,    0,    0,    0,    0,    0,    0,    0,  176,
        0,  176,    0,    0,    0,    0,    0,    0,  176,  176,
      241,  241,  241,  241,  241,  241,  241,  241,  241,  242,
      242,  242,  242,  242,  242,  242,  242,  242,  243,  243,

      243,  243,  243,  243,  243,  243,  243,  244,  244,  244,
      244,  244,  244,  244,  244,  244,  245,  245,  245,  245,
      245,  245,  245,  245,  245,  246,  246,  246,  246,  246,
      246,  246,  246,  246,  247,  247,  247,  247,  247,  247,
      247,  247,  247,  248,  248,  248,  248,  248,  248,  248,
      248,  248,  249,  249,  249,  249,  249,  249,  249,  249,
      249,  250,    0,  250,  250,  250,  250,  250,  250,  250,
      251,  251,  252,  252,  252,  252,  252,  253,  253,  253,
      253,  253,  253,  254,    0,  254,  254,  254,  254,  254,
      254,  254,  255,    0,    0,  255,  255,    0,  255,  255,

      256,  256,  256,  256,  257,  257,  258,  258,  258,  258,
      258,  258,  259,  259,  260,  260,  260,    0,  260,  260,
        0,  260,  260,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240,  240,
      240,  240,  240,  240,  240,  240,  240,  240,  240
    } ;

static yy_state_type yy_last_accepting_state;
static char *yy_last_accepting_cpos;

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "ldif.l"
#define INITIAL 0
#line 2 "ldif.l"

/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    ldif.l

ABSTRACT:

    The lex scanner for LDIF.

DETAILS:
    
    To generate the sources for lexer.c and parser.c,
    run nmake -f makefile.parse.
    
    
CREATED:

    07/17/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/    
#include <precomp.h>
#include "y_tab.h"

DEFINE_FEATURE_FLAGS(Lexer, 0);

#define DBGPRNT(x)  FEATURE_DEBUG(Lexer,FLAG_FNTRACE,(x))
#define YY_NEVER_INTERACTIVE 1
#define NORMAL 1

#define M_STRING 2
 
#define M_STRING64 3

#define ATTRNAME 4

#define SAFEVAL 5

#define DIGITREAD 6

#define TYPE 7

#define CLEAR 8

#define URLSCHEME 9

#define URLMACHINE 10

#define CHANGETYPE 11

#define ATTRNAMENC 12

#define SEPBC 13

#line 628 "lex.yy.c"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	if ( yyleng > 0 ) \
		yy_current_buffer->yy_at_bol = \
				(yytext[yyleng - 1] == '\n'); \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;

#line 54 "ldif.l"


 

    DBGPRNT("Lexer called\n");
    
    if (Mode==NO_COMMAND) {
        DBGPRNT("LEXER: called with NO_COMMAND! MODESWITCH");
        return MODESWITCH;
    }
    
    switch( Mode ) 
    {
        case C_NORMAL:
            BEGIN NORMAL;
            break;
        case C_SAFEVAL:
            BEGIN SAFEVAL;
            break;
        case C_ATTRNAME:
            BEGIN ATTRNAME;
            break;
        case C_ATTRNAMENC:
            BEGIN ATTRNAMENC;
            break;
        case C_M_STRING:
            BEGIN M_STRING;
            break;
        case C_M_STRING64:
            BEGIN M_STRING64;
            break;
        case C_DIGITREAD:
            BEGIN DIGITREAD;
            break;
        case C_TYPE:
            BEGIN TYPE;
            break;
        case C_URLSCHEME:
            BEGIN URLSCHEME;
            break;
        case C_URLMACHINE:
            BEGIN URLMACHINE;
            break;
        case C_CLEAR:
            BEGIN CLEAR;
            break;
        case C_CHANGETYPE:
            BEGIN CHANGETYPE;
            break;
         case C_SEPBC:
            BEGIN SEPBC;
            break;
    }
    
    //
    // After the above switch statement changed modes, we reset Mode to 
    // NO_COMMAND indicitating that if we're not in NORMAL mode, we must switch 
    // modes according to the grammar again.
    //
    
    if (Mode != C_NORMAL) {
        Mode = NO_COMMAND;
    }


#line 848 "lex.yy.c"

	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
		yy_current_state += YY_AT_BOL();
yy_match:
		do
			{
			register YY_CHAR yy_c = (YY_CHAR)yy_ec[YY_SC_TO_UI(*yy_cp)];
			if ( yy_accept[yy_current_state] )
				{
				yy_last_accepting_state = yy_current_state;
				yy_last_accepting_cpos = yy_cp;
				}
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 241 )
					yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 524 );

yy_find_action:
		yy_act = yy_accept[yy_current_state];
		if ( yy_act == 0 )
			{ /* have to back up */
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			yy_act = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
			case 0: /* must back up */
			/* undo the effects of YY_DO_BEFORE_ACTION */
			*yy_cp = yy_hold_char;
			yy_cp = yy_last_accepting_cpos;
			yy_current_state = yy_last_accepting_state;
			goto yy_find_action;

case 1:
YY_RULE_SETUP
#line 119 "ldif.l"
{ 
                                //
                                // Remove COMMENT
                                //
                                DBGPRNT("\nComment removed\n");
                                LineGhosts++;
                            }
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 127 "ldif.l"
{ 
                                //
                                // Remove LINEWRAP
                                //
                                DBGPRNT("\nLinewrap removed\n");
                                LineGhosts++;
                            }
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 135 "ldif.l"
{
                                if (!rgLineMap) {
                                    rgLineMap = (long *)
                                            MemAlloc_E(LINEMAP_INC*sizeof(long));
                                    cLineMax = MemSize(rgLineMap);
                                } 
                                else if ((LineClear%LINEMAP_INC)==0) {
                                    //
                                    // Chunk used up. LineClear is 'LineClear'
                                    //
                                    rgLineMap = 
                                        (long *)MemRealloc_E(rgLineMap, 
                                                         cLineMax+LINEMAP_INC*(
                                                            DWORD)sizeof(long));
                                    cLineMax = MemSize(rgLineMap);
                                    DBGPRNT("\nChunk used up\n");
                                }
                                
                                //
                                // the +1 is because our array starts at 0
                                //
                                rgLineMap[LineClear] = LineClear + LineGhosts + 1;
                                
                                //
                                // 'LineClear' maps to 'LineClear+LineGhosts+1'
                                // 
                                LineClear++;
                            
                                ECHO;
                            }
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 166 "ldif.l"
{
                                //
                                // ("%c",yytext[0]);
                                //
                                ECHO;
                            }
	YY_BREAK
case 5:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 173 "ldif.l"
{ 
                                //
                                // LEXER: Ignoring whitespace at the end  
                                // NOT LDIF SPEC
                                //
                                DBGPRNT("\nIgnoring white space at end\n");
                            }
	YY_BREAK
case 6:
YY_RULE_SETUP
#line 181 "ldif.l"
{ 
                                //
                                // Error Reporting
                                //
                                RuleLast = RS_DND;
                                TokenExpect = RT_BASE64;
                                DBGPRNT("\nReturning DNDCOLON\n");
                                return DNDCOLON;
                            }
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 191 "ldif.l"
{ 
                                //
                                // Error Reporting
                                //
                                RuleLast=RS_DN;
                                TokenExpect=RT_VALUE;
                                DBGPRNT("\nReturning DNCOLON\n");
                                return DNCOLON;
                            }               
	YY_BREAK
case 8:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 202 "ldif.l"
{ 
                                    Line++; 
                                    DBGPRNT("\nReturning SEP\n");
                                    return SEP;    
                                }
	YY_BREAK
case 9:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 208 "ldif.l"
{  
                                    Line++; 
                                    DBGPRNT("\nReturning SEPBYMINUS\n");
                                    return SEPBYMINUS;  
                                }
	YY_BREAK
case 10:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 214 "ldif.l"
{
                                    Line++; 
                                    DBGPRNT("\nReturning SEPBYCHANGE\n");
                                    return SEPBYCHANGE; 
                                }
	YY_BREAK
case 11:
YY_RULE_SETUP
#line 220 "ldif.l"
{   
                                    Line+=yyleng; 
                                    DBGPRNT("\nReturning MULTI_SEP\n");
                                    return MULTI_SEP;    
                                }
	YY_BREAK
case 12:
YY_RULE_SETUP
#line 226 "ldif.l"
{   
                                    DBGPRNT("\nReturning MULTI_SPACE\n");
                                    return MULTI_SPACE;   
                                }
	YY_BREAK
case 13:
YY_RULE_SETUP
#line 231 "ldif.l"
{   
                                    yylval.num = atoi(yytext); 
                                    
                                    //
                                    // ERROR REPORTING BLOCK
                                    //
                                    RuleLast = RS_DIGITS;
                                    TokenExpect = RT_MANY;
                                        
                                    DBGPRNT("\nReturning DIGITS\n");
                                    return DIGITS; 
                                }
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 244 "ldif.l"
{   
                                    RuleLast=RS_VERSION;
                                    TokenExpect=RT_DIGITS;
                                    
                                    return VERSION;  
                                }
	YY_BREAK
case 15:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 252 "ldif.l"
{   
                                                    yylval.str = MemAllocStr_E(yytext);
                                                    
                                                    RuleLast = RS_BASE64;
                                                    TokenExpect = RT_MANY;
                                                    
                                                    DBGPRNT("\nReturning B64\n");
                                                    return BASE64STRING;
                                                }
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 262 "ldif.l"
{   
                                    DBGPRNT("\nReturning STRING\n");
                                    return STRING;
                                }
	YY_BREAK
case 17:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp -= 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 267 "ldif.l"
{   
                                        yylval.str = MemAllocStr_E(yytext);
                                     
                                        RuleLast = RS_ATTRNAME;
                                        TokenExpect = RT_C_VALUE;
                                            
                                        DBGPRNT("\nReturning NAME\n");
                                        return NAME; 
                                    }
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 277 "ldif.l"
{   
                                        yylval.str = MemAllocStr_E(yytext);
                                        
                                        RuleLast = RS_ATTRNAMENC;
                                        TokenExpect = RT_ATTRNAME;
                                        
                                        DBGPRNT("\nReturning NAMENC\n");
                                        return NAMENC; 
                                    }
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 288 "ldif.l"
{   
                                                    yylval.str = MemAllocStr_E(yytext);
                                                    
                                                    RuleLast = RS_SAFE;
                                                    TokenExpect = RT_MANY;
                                                    
                                                    DBGPRNT("\nReturning VALUE\n");
                                                    return VALUE;                                           
                                                }
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 298 "ldif.l"
{   
                            RuleLast = RS_DC;
                            TokenExpect = RT_BASE64;
                            DBGPRNT("\nReturning DOUBLECOLON\n");
                            return DOUBLECOLON;
                        }
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 305 "ldif.l"
{   
                            RuleLast = RS_URLC;
                            TokenExpect = RT_URL;
                            DBGPRNT("\nReturning URLCOLON\n");
                            return URLCOLON;
                        }
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 312 "ldif.l"
{   
                            RuleLast = RS_C;
                            TokenExpect = RT_VALUE;
                            DBGPRNT("\nReturning SINGLECOLON\n");
                            return SINGLECOLON;
                        }
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 319 "ldif.l"
{   
                            yylval.num = 0;
                            
                            RuleLast = RS_MDN;
                            TokenExpect = RT_NDN;
                            DBGPRNT("\nReturning MODRDN\n");
                            return MODRDN;
                        }
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 327 "ldif.l"
{   
                            yylval.num = 1;
                            RuleLast = RS_MDN;
                            TokenExpect = RT_NDN;
                            DBGPRNT("\nReturning NTDSMODRDN\n");
                            return NTDSMODRDN;
                        }
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 335 "ldif.l"
{   
                            RuleLast = RS_MDN;
                            TokenExpect = RT_NDN;
                            DBGPRNT("\nReturning MODDN\n");
                            return MODDN;
                        }
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 342 "ldif.l"
{   
                            RuleLast = RS_NRDNC;
                            TokenExpect = RT_VALUE;
                            DBGPRNT("\nReturning NEWRDNCOLON\n");
                            return NEWRDNCOLON;
                        }
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 349 "ldif.l"
{   
                            RuleLast = RS_NRDNDC;
                            TokenExpect = RT_BASE64;
                            DBGPRNT("\nReturning NEWRDNDCOLON\n");
                            return NEWRDNDCOLON;
                        }
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 356 "ldif.l"
{   
                            RuleLast = RS_DORDN;
                            TokenExpect = RT_DIGITS;
                            DBGPRNT("\nReturning DELETEOLDRDN\n");
                            return DELETEOLDRDN;
                        }
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 363 "ldif.l"
{   
                            RuleLast = RS_NEWSUP;
                            TokenExpect = RT_VALUE;
                            DBGPRNT("\nReturning NEWSUPERIORC\n");
                            return NEWSUPERIORC;
                        }
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 370 "ldif.l"
{   
                            RuleLast = RS_NEWSUPD;
                            TokenExpect = RT_BASE64;
                            DBGPRNT("\nReturning NEWSUPERIORDC\n");
                            return NEWSUPERIORDC;
                        }
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 377 "ldif.l"
{   
                            RuleLast = RS_DELETEC;
                            TokenExpect = RT_ATTRNAMENC;
                            DBGPRNT("\nReturning DELETEC\n");
                            return DELETEC;
                        }
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 384 "ldif.l"
{   
                            RuleLast = RS_REPLACEC;
                            TokenExpect = RT_ATTRNAMENC;
                            DBGPRNT("\nReturning REPLACEC\n");
                            return REPLACEC;
                        }
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 391 "ldif.l"
{   
                            RuleLast = RS_CHANGET;
                            TokenExpect = RT_ADM;
                            DBGPRNT("\nReturning T_CHANGETYPE\n");
                            return T_CHANGETYPE;
                        }
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 398 "ldif.l"
{   
                            yylval.num = 0;
                            RuleLast = RS_C_ADD;
                            TokenExpect = RT_ATTRNAME;
                            DBGPRNT("\nReturning ADD\n");
                            return ADD;
                        }
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 406 "ldif.l"
{   
                            yylval.num = 1;
                                
                            RuleLast = RS_C_ADD;
                            TokenExpect = RT_ATTRNAME;
                            
                            DBGPRNT("\nReturning NTDSADD\n");
                            return NTDSADD;
                        }
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 416 "ldif.l"
{   
                            yylval.num = 0;
                                
                            RuleLast = RS_C_DELETE;
                            TokenExpect = RT_CH_OR_SEP;
                            
                            DBGPRNT("\nReturning MYDELETE\n");
                            return MYDELETE;
                        }
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 426 "ldif.l"
{   
                            yylval.num = 1;
                                
                            RuleLast = RS_C_DELETE;
                            TokenExpect = RT_CH_OR_SEP;
                            
                            DBGPRNT("\nReturning NTDSMYDELETE\n");
                            return NTDSMYDELETE;
                        }
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 436 "ldif.l"
{   
                            RuleLast = RS_ADDC;
                            TokenExpect = RT_ATTRNAMENC;
                            
                            DBGPRNT("\nReturning ADDC\n");
                            return ADDC;
                        }
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 444 "ldif.l"
{   
                            RuleLast = RS_MINUS;
                            TokenExpect = RT_CH_OR_SEP;
                            
                            DBGPRNT("\nReturning MINUS\n");
                            return MINUS;
                        }
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 452 "ldif.l"
{   
                            yylval.num = 0;
                            
                            RuleLast = RS_C_MODIFY;
                            TokenExpect = RT_ACDCRC;
                            
                            DBGPRNT("\nReturning MODIFY\n");
                            return MODIFY;
                        }
	YY_BREAK
case 41:
YY_RULE_SETUP
#line 462 "ldif.l"
{   
                            yylval.num = 1;
                            
                            RuleLast = RS_C_MODIFY;
                            TokenExpect = RT_ACDCRC;
                            
                            DBGPRNT("\nReturning NTDSMODIFY\n");
                            return NTDSMODIFY;
                        }
	YY_BREAK
case 42:
YY_RULE_SETUP
#line 473 "ldif.l"
{   
                            DBGPRNT("\nReturning FILESCHEME\n");
                            return FILESCHEME;
                        }
	YY_BREAK
case 43:
YY_RULE_SETUP
#line 478 "ldif.l"
{   
                            //
                            // LEXER: returning HOST: 'yytext'
                            //
                            yylval.str = MemAllocStr_E(yytext);
                            DBGPRNT("\nReturning MACHINENAME\n");
                            return MACHINENAME;
                        }
	YY_BREAK
case 44:
YY_RULE_SETUP
#line 488 "ldif.l"
{ 
                            //
                            // LEXER:Unrecongnized char 'yytext[0]'. Returning 
                            // MODESWITCH
                            //
                            cLast = yytext[0];      
                            yyless(0);
                            DBGPRNT("\nUncongnized char, Returning MODESWITCH\n");
                            return MODESWITCH; 
                        }
	YY_BREAK
case 45:
YY_RULE_SETUP
#line 499 "ldif.l"
ECHO;
	YY_BREAK
#line 1463 "lex.yy.c"
case YY_STATE_EOF(INITIAL):
case YY_STATE_EOF(NORMAL):
case YY_STATE_EOF(M_STRING):
case YY_STATE_EOF(M_STRING64):
case YY_STATE_EOF(ATTRNAME):
case YY_STATE_EOF(SAFEVAL):
case YY_STATE_EOF(DIGITREAD):
case YY_STATE_EOF(TYPE):
case YY_STATE_EOF(CLEAR):
case YY_STATE_EOF(URLSCHEME):
case YY_STATE_EOF(URLMACHINE):
case YY_STATE_EOF(CHANGETYPE):
case YY_STATE_EOF(ATTRNAMENC):
case YY_STATE_EOF(SEPBC):
	yyterminate();

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_current_buffer->yy_n_chars = yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );

		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;
	yy_current_state += YY_AT_BOL();

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 35);
		if ( yy_accept[yy_current_state] )
			{
			yy_last_accepting_state = yy_current_state;
			yy_last_accepting_cpos = yy_cp;
			}
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 241 )
				yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;
	register char *yy_cp = yy_c_buf_p;

	register YY_CHAR yy_c = 35;
	if ( yy_accept[yy_current_state] )
		{
		yy_last_accepting_state = yy_current_state;
		yy_last_accepting_cpos = yy_cp;
		}
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 241 )
			yy_c = (YY_CHAR)yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 240);

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_current_buffer->yy_n_chars =
			yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			int offset = yy_c_buf_p - yytext_ptr;
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/* fall through */

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						return EOF;

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;

	yy_current_buffer->yy_at_bol = (c == '\n');

	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
	{
	int len;
	for ( len = 0; yy_str[len]; ++len )
		;

	return yy_scan_bytes( yy_str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
	{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif
#line 499 "ldif.l"


void yyerror (char *error) {
    //
    // version: 1 addition reports the wrong token if syntax error is on the 
    // first line
    //
    /*
    if (rgLineMap[Line]==1) {
        cLast = ' ';
    }
    */

    //
    // ERROR: 'error' AT OR AFTER: 'cLast' LINE: 'rgLineMap[Line]'
    // Note:
    // 1) Any line which begins with a space is a wrap of the previous.
    // 2) No other changetype: * can follow changetype: add in a single entry.
    // 3) The LDIF spec forbids trailing whitespace. This implementation allows 
    //    it in most places, however there may be spots in the grammar where it 
    //    is still forbiden. Check your trailing whitespace.
    //
    RaiseException(LL_SYNTAX, 0, 0, NULL);
}

int yywrap() {
    fEOF = 1; // for LL_ldif_parse
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\utils\async.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    async.c

Abstract:
    
    Asynchronous LDAP support routines

Author:

    Matthew Rimer [MattRim]    15-May-2000
    
++*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <objidl.h>
#include <stdio.h>
#include <winldap.h>

LDAP_TIMEVAL g_LdapTimeout = {0, 0};

LDAP_TIMEVAL * g_pLdapTimeout = NULL;


ULONG LDAPAPI LdapResult(
    LDAP *ld, 
    ULONG msgnum,
    LDAPMessage **ppres
    )
{
    ULONG Ldap_err = LDAP_SUCCESS;
    LDAPMessage *pres = NULL;

    //
    // If the async request was successful, try to get the result
    //
    if (((LONG)msgnum) != -1) {

        Ldap_err = ldap_result(ld, msgnum, LDAP_MSG_ALL, g_pLdapTimeout, &pres);

        //
        // If the attempt to get the result failed, retrieve the error
        // If the attempt to get the result timed-out, return appropriate error
        // Else, we got the result, return the code returned by the operation
        //
        if (((LONG)Ldap_err) == -1) {
            Ldap_err = LdapGetLastError();
        }
        else if (Ldap_err == 0) {
            Ldap_err = LDAP_TIMEOUT;
        }
        else {
            Ldap_err = ldap_result2error(ld, pres, FALSE);

            //
            // If user wants the actual result, return it (user must free).
            // Else, we free it.
            //
            if (ppres) {
                *ppres = pres;
            }
            else {
                ldap_msgfree(pres);
            }
        }
    }
    else {
        Ldap_err = LdapGetLastError();
    }

    return Ldap_err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\utils\symhelp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Defines the interfaces to the SYMHELP dynamic link library.  Useful for programs
    that want to maintain a debug informaiton data base.

Author:

    Steve Wood (stevewo) 11-Mar-1994

Revision History:

    Mike Seaman (mikese) 20-Jan-1995    Added TranslateAddress

--*/

#ifndef _DEBUGFILE_
#define _DEBUGFILE_

#include <debnot.h>

#ifndef _WIN64
typedef enum _LOAD_SYMBOLS_FILTER_REASON {
    LoadSymbolsPathNotFound,
    LoadSymbolsDeferredLoad,
    LoadSymbolsLoad,
    LoadSymbolsUnload,
    LoadSymbolsUnableToLoad
} LOAD_SYMBOLS_FILTER_REASON;

typedef BOOL (*PLOAD_SYMBOLS_FILTER_ROUTINE)(
    HANDLE UniqueProcess,
    LPSTR ImageFilePath,
    DWORD ImageBase,
    DWORD ImageSize,
    LOAD_SYMBOLS_FILTER_REASON Reason
    );

BOOL
InitializeImageDebugInformation(
    IN PLOAD_SYMBOLS_FILTER_ROUTINE LoadSymbolsFilter,
    IN HANDLE TargetProcess,
    IN BOOL NewProcess,
    IN BOOL GetKernelSymbols
    );

BOOL
AddImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase,
    IN DWORD ImageSize
    );

BOOL
RemoveImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN LPSTR ImageFilePath,
    IN DWORD ImageBase
    );

PIMAGE_DEBUG_INFORMATION
FindImageDebugInformation(
    IN HANDLE UniqueProcess,
    IN DWORD Address
    );

ULONG
GetSymbolicNameForAddress(
    IN HANDLE UniqueProcess,
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

//
// The following function is essentially identical in operation to
//  GetSymbolicNameForAddress, except that it:
//
//  1. Operates only on the calling process.
//  2. Does not require any previous calls to AddImageDebugInformation et al.
//     That is, debug information for all currently loaded modules will
//     be added automatically.

ULONG
TranslateAddress (
    IN ULONG Address,
    OUT LPSTR Name,
    IN ULONG MaxNameLength
    );

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\samrestrict.h ===
/*++

Copyright (c) 1996 Microsoft Corporation.
All rights reserved.

MODULE NAME:

    samrestrict.h

ABSTRACT:
    
    Ldap display names of SAM read-only attrbiutes.

DETAILS:

    We have the problem that if we export out SAM objects,
    we can't put them back in with all the attributes we 
    get because some of them are SAM read only.
    This header contains the read onlys listed by
    their ldapDisplayNames, for each Sam object type.  
    
    
CREATED:

    07/14/97    Roman Yelensky (t-romany)

REVISION HISTORY:

--*/
#ifndef _SAM_H
#define _SAM_H


//
// The server and domain are here only for completeness, its not actually
// relevant and is not expected and won't work for import/export operations.
//


//
// CLASS_SAM_SERVER, SampServerObjectType (ldapdisplayname: samServer) 
//
PWSTR samServer[] = {
     L"revision",  //SAMP_FIXED_SERVER_REVISION_LEVEL, ATT_REVISION
     L"objectSid", //not in mappings.c, but still required!, ATT_OBJECT_SID
     NULL
};


//
// CLASS_SAM_DOMAIN, SampDomainObjectType (ldapdisplayname: domain) 
//
PWSTR domain[] = {
    L"objectSid",                // SAMP_DOMAIN_SID, ATT_OBJECT_SID
    L"domainReplica",            // SAMP_DOMAIN_REPLICA, ATT_DOMAIN_REPLICA
    L"creationTime",             // SAMP_FIXED_DOMAIN_CREATION_TIME, 
                                // ATT_CREATION_TIME
    L"modifiedCount",            // SAMP_FIXED_DOMAIN_MODIFIED_COUNT,
                                // ATT_MODIFIED_COUNT
    L"modifiedCountAtLastProm",  // SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION, 
                                // ATT_MODIFIED_COUNT_AT_LAST_PROM
    L"nextRid",                  // SAMP_FIXED_DOMAIN_NEXT_RID, ATT_NEXT_RID
    L"serverState",              // SAMP_FIXED_DOMAIN_SERVER_STATE, 
                                // ATT_SERVER_STATE
    L"sAMAccountType",           // SAMP_DOMAIN_ACCOUNT_TYPE, 
                                // ATT_SAM_ACCOUNT_TYPE
    L"uASCompat",               // SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,
                                //  ATT_UAS_COMPAT
    NULL
};


//
// CLASS_GROUP, SampGroupObjectType (ldapdisplayname: group) 
//
PWSTR group[] = {
    L"rid",                 // SAMP_FIXED_GROUP_RID, ATT_RID
    L"sAMAccountType",      // SAMP_GROUP_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",           // not in mappings.c, but still required!, 
                           // ATT_OBJECT_SID
    L"memberOf",            // SAMP_USER_GROUPS, ATT_MEMBER
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    NULL
};


//
// CLASS_LOCALGROUP, SampAliasObjectType (ldapdisplayname: localGroup) 
//
PWSTR localgroup[] = {
    L"rid",                // SAMP_FIXED_ALIAS_RID, ATT_RID
    L"sAMAccountType",     // SAMP_ALIAS_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"objectSid",          // not in mappings.c, but still required!, ATT_OBJECT_SID
    L"isCriticalSystemObject", // SAMP_FIXED_GROUP_IS_CRITICAL,
                               //  ATT_IS_CRITICAL_SYSTEM_OBJECT    
    NULL
};


//
// CLASS_USER, SampUserObjectType (ldapdisplayname: user)
//
PWSTR user[] = {
    L"memberOf",                // SAMP_USER_GROUPS, ATT_MEMBER
    L"dBCSPwd",                 // SAMP_USER_DBCS_PWD, ATT_DBCS_PWD
    L"ntPwdHistory",            // SAMP_USER_NT_PWD_HISTORY, ATT_NT_PWD_HISTORY
    L"lmPwdHistory",            // SAMP_USER_LM_PWD_HISTORY, ATT_LM_PWD_HISTORY
    L"lastLogon",               // SAMP_FIXED_USER_LAST_LOGON, ATT_LAST_LOGON
    L"lastLogoff",              // SAMP_FIXED_USER_LAST_LOGOFF, ATT_LAST_LOGOFF
    L"badPasswordTime",         // SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME, 
                                // ATT_BAD_PASSWORD_TIME
    L"rid",                     // SAMP_FIXED_USER_USERID, ATT_RID
    L"badPwdCount",             // SAMP_FIXED_USER_BAD_PWD_COUNT, 
                                // ATT_BAD_PWD_COUNT
    L"logonCount",              // SAMP_FIXED_USER_LOGON_COUNT, ATT_LOGON_COUNT
    L"sAMAccountType",          // SAMP_USER_ACCOUNT_TYPE, ATT_SAM_ACCOUNT_TYPE
    L"supplementalCredentials", // SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS,
                                // ATT_SUPPLEMENTAL_CREDENTIALS
    L"objectSid",               // not in mappings.c, but still required!, 
                                // ATT_OBJECT_SID
    L"pwdLastSet",
    L"isCriticalSystemObject",  // SAMP_FIXED_USER_IS_CRITICAL,
                                //  ATT_IS_CRITICAL_SYSTEM_OBJECT
    L"lastLogonTimestamp",      // SAMP_FIXED_USER_LAST_LOGON_TIMESTAMP,
                                //  ATT_LAST_LOGON_TIMESTAMP
    NULL
};


PWSTR SamObjects[] = {
    L"samServer",
    L"domain",
    L"group",
    L"localGroup",
    L"user",
    NULL
};
    

//
// These tables will be generated by samTablesCreate() and used by 
// samCheckObject() and samCheckAttr()
//

PRTL_GENERIC_TABLE pSamObjects      =   NULL;
PRTL_GENERIC_TABLE pServerAttrs     =   NULL;
PRTL_GENERIC_TABLE pDomainAttrs     =   NULL;
PRTL_GENERIC_TABLE pGroupAttrs      =   NULL;
PRTL_GENERIC_TABLE pLocalGroupAttrs =   NULL;
PRTL_GENERIC_TABLE pUserAttrs       =   NULL;
PRTL_GENERIC_TABLE pSpecial         =   NULL;

//
// output membership info in a changetype: modify following the changetype: add 
//
#define S_MEM               1 

PWSTR special[] = {
    L"domain",
    L"group",
    L"localGroup",
    NULL
};


int actions[] = {
    S_MEM,
    S_MEM,
    S_MEM,
    0
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\lexeru.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    lexeru.h

Abstract:

    Unicode Lexer Header file

Environment:

    User mode

Revision History:

    04/29/99 -felixw-
        Created it

--*/
#ifndef __LEXERU_H__
#define __LEXERU_H__

extern FILE *yyin;                     // Input file stream
extern FILE *yyout;                    // Output file stream for first phase (CLEAR)

extern void    yyerror(char *);
extern int     yylex();

//
// used to determine whether we've passed limit. 
// must be one less than COUNT_CHUNK
//
#define LINEMAP_INC 1000
#define YY_NULL 0

typedef struct _STACK {
    DWORD dwSize;
    PWSTR rgcStack;
    DWORD dwIndex;              // Current index to stack
} STACK;

//
// Define the stack functions
//
#define MAXVAL 65535
#define INC     256


//
// Define the dynamic string macros. This should be implemented as a String
// Class if lexer is implemented in C.
//
#define STR_INIT()                                          \
            PWSTR pszString = NULL;                         \
            DWORD cSize = INC;                              \
            DWORD cCurrent = 0;                             \
            pszString = MemAlloc_E(INC*sizeof(WCHAR));      \
            memset(pszString, 0, INC*sizeof(WCHAR));

#define STR_ADDCHAR(c)                                                         \
            if ((cCurrent+2) >= cSize) {                                       \
                pszString = MemRealloc_E(pszString,(INC+cSize)*sizeof(WCHAR));   \
                memset(pszString + cSize,                    \
                       0,                                                      \
                       INC*sizeof(WCHAR));                             \
                cSize+=INC;                                                    \
            }                                                                  \
            pszString[cCurrent++] = c;

#define STR_VALUE()  pszString

#define STR_FREE()                      \
            MemFree(pszString);         \
            pszString = NULL;

//
// Stack Functions
//
void Push(STACK *pStack,WCHAR c);
BOOL Pop(STACK *pStack,WCHAR *pChar);
void Clear(STACK *pStack);

void LexerInit(PWSTR szInputFileName);
void LexerFree();

//
// Special file stream functions using the stack
//
BOOL GetNextCharExFiltered(WCHAR *pChar, BOOL fStart);
void UnGetCharExFiltered(WCHAR c) ;

void RollBack();

//
// File stream functions
//   Filtered = goes through the comment preprocessor
//   Raw = direct access
//
BOOL GetNextCharFiltered(WCHAR *pChar);
void UnGetCharFiltered(WCHAR c);
BOOL GetNextCharRaw(WCHAR *pChar);
void UnGetCharRaw(WCHAR c);

BOOL GetToken(PWSTR *pszToken);

//
// Comment preprocessing functions
//
BOOL ScanClear(PWCHAR pChar, __int64 *pBytesProcessed);
WCHAR GetFilteredWC(void);
BOOL GetTrimmedFileSize(PWSTR szFilename, __int64 *pTrimmedSize);

//
// Character validation functions
//
BOOL IsDigit(WCHAR c);
BOOL Is64Char(WCHAR c); 
BOOL Is64CharEnd(WCHAR c);
BOOL IsNameChar(WCHAR c);
BOOL IsURLChar(WCHAR c);
BOOL IsVal(WCHAR c);
BOOL IsValInit(WCHAR c);

//
// Scanning function for individual mode
//
BOOL ScanNormal(DWORD *pToken);
BOOL ScanDigit(DWORD *pToken);
BOOL ScanString64(DWORD *pToken);
BOOL ScanName(DWORD *pToken);
BOOL ScanNameNC(DWORD *pToken);
BOOL ScanVal(DWORD *pToken);
BOOL ScanUrlMachine(DWORD *pToken);
BOOL ScanChangeType(DWORD *pToken);
BOOL ScanType(DWORD *pToken);

/*
    Comment Preprocessing Architecture Notes

    Originally, LDIFDE used a two-pass parser.  The first pass would
    remove comments and paste together line continuations, and write the
    results to a temporary file.  The second pass would read this 
    preprocessed file and parse it to import entries into the directory.
    GetNextChar and UnGetChar were used in both passes to directly
    read from the file.

    In the new architecture, the first pass of the parser, ScanClear,
    has been transformed into a filter that sits between the actual
    parser (what used to be the second pass) and the raw input file.
    The parser uses GetNextCharFiltered/UnGetCharFiltered to read
    characters through the filter.  The filter in turn uses GetNextCharRaw/
    UnGetCharRaw to directly read the file.  GetNextCharFiltered uses
    GetFilteredWC to interface with the filter (ScanClear).

    GetFilteredWC, along with its helper function GetTrimmedFileSize,
    is responsible for emulating two behaviors of the original
    two-pass parser.  First, while the LDIF grammar requires that the file
    begin with "version: 1" without any leading white spaces, LDIFDE has
    traditionally permitted the omission of the version spec and the inclusion
    of leading white spaces.  It did this by prepending a version spec to
    the start of the start of the temp file.  We simulate this for the parser
    by injecting a version spec line into the stream at the start of the file.

    Second, LDIFDE has been lax about allowing extra white space at the end of the
    file.  It did this by trimming off any trailing white space in the temp file.
    We simulate this by calculating what the size of the "trimmed" file would be
    and injecting EOF at that point in the stream.

*/


#endif // ifndef __LEXERU_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\ldifldap\y_tab.h ===
#define SEP 257
#define MULTI_SEP 258
#define MULTI_SPACE 259
#define CHANGE 260
#define VERSION 261
#define DNCOLON 262
#define DNDCOLON 263
#define LINEWRAP 264
#define NEWRDNDCOLON 265
#define MODESWITCH 266
#define SINGLECOLON 267
#define DOUBLECOLON 268
#define URLCOLON 269
#define FILESCHEME 270
#define T_CHANGETYPE 271
#define NEWRDNCOLON 272
#define DELETEOLDRDN 273
#define NEWSUPERIORC 274
#define NEWSUPERIORDC 275
#define ADDC 276
#define MINUS 277
#define SEPBYMINUS 278
#define DELETEC 279
#define REPLACEC 280
#define STRING 281
#define SEPBYCHANGE 282
#define NAME 283
#define VALUE 284
#define BASE64STRING 285
#define MACHINENAME 286
#define NAMENC 287
#define DIGITS 288
#define ADD 289
#define MODIFY 290
#define MODDN 291
#define MODRDN 292
#define MYDELETE 293
#define NTDSADD 294
#define NTDSMODIFY 295
#define NTDSMODRDN 296
#define NTDSMYDELETE 297
#define NTDSMODDN 298
typedef union {
    int                 num;
    PWSTR               wstr;
    LDAPModW            *mod;
    struct change_list  *change;
} YYSTYPE;
extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\util\ldifds\utils\symhelp.c ===
#ifndef _WIN64
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    symhelp.c

Abstract:

    Symb