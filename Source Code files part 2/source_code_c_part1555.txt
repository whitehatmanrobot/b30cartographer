.0, 0.0, 0.0}
    },
    {
	{GL_COLOR_MATERIAL, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_COLOR_MATERIAL_FACE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FRONT_AND_BACK}
    },
    {
	{GL_COLOR_MATERIAL_PARAMETER, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_AMBIENT_AND_DIFFUSE}
    },
    {
	{GL_COLOR_WRITEMASK, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE}
    },
    {
	{GL_CULL_FACE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_CULL_FACE_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_BACK}
    },
    {
	{GL_CURRENT_COLOR, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_CURRENT_INDEX, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_CURRENT_NORMAL, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 1.0}
    },
    {
	{GL_CURRENT_RASTER_COLOR, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_CURRENT_RASTER_INDEX, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_CURRENT_RASTER_POSITION, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_CURRENT_RASTER_POSITION_VALID, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_TRUE}
    },
    {
	{GL_CURRENT_RASTER_TEXTURE_COORDS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_CURRENT_TEXTURE_COORDS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_DEPTH_CLEAR_VALUE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_DEPTH_BIAS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_DEPTH_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_DEPTH_FUNC, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_LESS}
    },
    {
	{GL_DEPTH_RANGE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_DEPTH_SCALE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_DEPTH_TEST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_DEPTH_WRITEMASK, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_TRUE}
    },
    {
	{GL_DITHER, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_TRUE}
    },
    {
	{GL_DOUBLEBUFFER, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_DRAW_BUFFER, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_EDGE_FLAG, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_TRUE}
    },
    {
	{GL_FOG, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_FOG_COLOR, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_FOG_DENSITY, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_FOG_END, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_FOG_HINT, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_FOG_INDEX, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_FOG_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_EXP}
    },
    {
	{GL_FOG_START, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_FRONT_FACE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_CCW}
    },
    {
	{GL_GREEN_BIAS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_GREEN_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_GREEN_SCALE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_INDEX_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_INDEX_CLEAR_VALUE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_INDEX_MODE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_INDEX_OFFSET, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_INDEX_SHIFT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_INDEX_WRITEMASK, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_LIGHTING, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LIGHT_MODEL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.2, 0.2, 0.2, 1.0}
    },
    {
	{GL_LIGHT_MODEL_LOCAL_VIEWER, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LIGHT_MODEL_TWO_SIDE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LINE_SMOOTH, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LINE_SMOOTH_HINT, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_LINE_STIPPLE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LINE_STIPPLE_PATTERN, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {65535.0}
    },
    {
	{GL_LINE_STIPPLE_REPEAT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LINE_WIDTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LINE_WIDTH_GRANULARITY, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_LINE_WIDTH_RANGE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 2
    },
    {
	{GL_LIST_BASE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIST_INDEX, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LOGIC_OP, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_LOGIC_OP_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_COPY}
    },
    {
	{GL_MAP_COLOR, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP_STENCIL, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_COLOR_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_GRID_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_GRID_SEGMENTS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_INDEX, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_NORMAL, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_TEXTURE_COORD_1, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_TEXTURE_COORD_2, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_TEXTURE_COORD_3, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_TEXTURE_COORD_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_VERTEX_3, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP1_VERTEX_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_COLOR_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_GRID_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_GRID_SEGMENTS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_INDEX, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_NORMAL, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_TEXTURE_COORD_1, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_TEXTURE_COORD_2, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_TEXTURE_COORD_3, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_TEXTURE_COORD_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_VERTEX_3, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MAP2_VERTEX_4, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_MATRIX_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_MODELVIEW}
    },
    {
	{GL_MAX_ATTRIB_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_CLIP_PLANES, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_EVAL_ORDER, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_LIGHTS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_LIST_NESTING, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_MODELVIEW_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_NAME_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_PIXEL_MAP_TABLE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_PROJECTION_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_TEXTURE_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_TEXTURE_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_MAX_VIEWPORT_DIMS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 2
    },
    {
	{GL_MODELVIEW_MATRIX, GL_NULL}, STATEDATA_MATRIX,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 16, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_MODELVIEW_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_NAME_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_NORMALIZE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_PACK_ALIGNMENT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {4.0}
    },
    {
	{GL_PACK_LSB_FIRST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_PACK_ROW_LENGTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PACK_SKIP_PIXELS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PACK_SKIP_ROWS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PACK_SWAP_BYTES, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_PERSPECTIVE_CORRECTION_HINT, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_PIXEL_MAP_A_TO_A_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_B_TO_B_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_G_TO_G_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_A_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_B_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_G_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_I_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_R_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_R_TO_R_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_PIXEL_MAP_S_TO_S_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_POINT_SIZE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_POINT_SIZE_GRANULARITY, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_POINT_SIZE_RANGE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 2
    },
    {
	{GL_POINT_SMOOTH, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_POINT_SMOOTH_HINT, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_POLYGON_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 2, {GL_FILL, GL_FILL}
    },
    {
	{GL_POLYGON_SMOOTH, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_POLYGON_SMOOTH_HINT, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_POLYGON_STIPPLE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_PROJECTION_MATRIX, GL_NULL}, STATEDATA_MATRIX,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 16, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_PROJECTION_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_READ_BUFFER, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_RED_BIAS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_RED_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_RED_SCALE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_RENDER_MODE, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_RENDER}
    },
    {
	{GL_RGBA_MODE, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_SCISSOR_BOX, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 4
    },
    {
	{GL_SCISSOR_TEST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_SHADE_MODEL, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_SMOOTH}
    },
    {
	{GL_STENCIL_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_STENCIL_CLEAR_VALUE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_STENCIL_FAIL, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_KEEP}
    },
    {
	{GL_STENCIL_FUNC, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_ALWAYS}
    },
    {
	{GL_STENCIL_PASS_DEPTH_FAIL, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_KEEP}
    },
    {
	{GL_STENCIL_PASS_DEPTH_PASS, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_KEEP}
    },
    {
	{GL_STENCIL_REF, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_STENCIL_TEST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_STENCIL_VALUE_MASK, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_STENCIL_WRITEMASK, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_STEREO, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_SUBPIXEL_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_TEXTURE_1D, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_2D, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_GEN_R, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_GEN_Q, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_GEN_S, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_GEN_T, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_TEXTURE_MATRIX, GL_NULL}, STATEDATA_MATRIX,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 16, {1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_TEXTURE_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_UNPACK_ALIGNMENT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {4.0}
    },
    {
	{GL_UNPACK_LSB_FIRST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_UNPACK_ROW_LENGTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_UNPACK_SKIP_PIXELS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_UNPACK_SKIP_ROWS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_UNPACK_SWAP_BYTES, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_VIEWPORT, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 4
    },
    {
	{GL_ZOOM_X, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_ZOOM_Y, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_CLIP_PLANE0, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_CLIP_PLANE1, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_CLIP_PLANE2, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_CLIP_PLANE3, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_CLIP_PLANE4, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_CLIP_PLANE5, GL_NULL}, STATEDATA_DATA,
	"Clipping Plane Information",
	StateGetClipPlane,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_LIGHT0, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT0, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT0, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_LIGHT0, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT0, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT0, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT0, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_LIGHT0, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT0, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT0, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT1, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT1, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT1, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT1, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT1, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT1, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT1, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT1, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT1, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT1, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT2, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT2, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT2, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT2, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT2, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT2, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT2, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT2, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT2, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT2, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT3, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT3, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT3, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT3, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT3, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT3, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT3, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT3, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT3, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT3, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT4, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT4, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT4, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT4, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT4, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT4, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT4, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT4, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT4, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT4, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT5, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT5, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT5, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT5, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT5, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT5, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT5, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT5, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT5, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT5, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT6, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT6, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT6, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT6, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT6, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT6, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT6, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT6, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT6, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT6, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT7, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT7, GL_CONSTANT_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_LIGHT7, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT7, GL_LINEAR_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT7, GL_POSITION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 1.0, 0.0}
    },
    {
	{GL_LIGHT7, GL_QUADRATIC_ATTENUATION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_LIGHT7, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_LIGHT7, GL_SPOT_CUTOFF, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {180.0}
    },
    {
	{GL_LIGHT7, GL_SPOT_DIRECTION, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 3, {0.0, 0.0, -1.0}
    },
    {
	{GL_LIGHT7, GL_SPOT_EXPONENT, GL_NULL}, STATEDATA_DATA,
	"Lighting Information",
	StateGetLight,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_MAP1_COLOR_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_MAP1_COLOR_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_COLOR_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_INDEX, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_INDEX, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_INDEX, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_NORMAL, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 1.0}
    },
    {
	{GL_MAP1_NORMAL, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_NORMAL, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_1, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_1, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_1, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_2, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 0.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_2, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_2, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_3, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 0.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_3, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_3, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_TEXTURE_COORD_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_VERTEX_3, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 0.0}
    },
    {
	{GL_MAP1_VERTEX_3, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_VERTEX_3, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP1_VERTEX_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_MAP1_VERTEX_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 1.0}
    },
    {
	{GL_MAP1_VERTEX_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP2_COLOR_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {1.0, 1.0, 1.0, 1.0}
    },
    {
	{GL_MAP2_COLOR_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_COLOR_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_INDEX, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_MAP2_INDEX, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_INDEX, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_NORMAL, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_NORMAL, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_NORMAL, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_1, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_1, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_1, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_2, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {0.0, 0.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_2, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_2, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_3, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 0.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_3, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_3, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_TEXTURE_COORD_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_VERTEX_3, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 3, {0.0, 0.0, 0.0}
    },
    {
	{GL_MAP2_VERTEX_3, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_VERTEX_3, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_MAP2_VERTEX_4, GL_COEFF, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_VERTEX_4, GL_DOMAIN, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 1.0}
    },
    {
	{GL_MAP2_VERTEX_4, GL_ORDER, GL_NULL}, STATEDATA_DATA,
	"Evaluator Information",
	StateGetMap,
	STATEDATA_LOCKED, 2, {1.0, 1.0}
    },
    {
	{GL_BACK, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.2, 0.2, 0.2, 1.0}
    },
    {
	{GL_BACK, GL_COLOR_INDEXES, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 3, {0.0, 1.0, 1.0}
    },
    {
	{GL_BACK, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.8, 0.8, 0.8, 1.0}
    },
    {
	{GL_BACK, GL_EMISSION, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_BACK, GL_SHININESS, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_BACK, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_FRONT, GL_AMBIENT, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.2, 0.2, 0.2, 1.0}
    },
    {
	{GL_FRONT, GL_COLOR_INDEXES, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 3, {0.0, 1.0, 1.0}
    },
    {
	{GL_FRONT, GL_DIFFUSE, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.8, 0.8, 0.8, 1.0}
    },
    {
	{GL_FRONT, GL_EMISSION, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_FRONT, GL_SHININESS, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_FRONT, GL_SPECULAR, GL_NULL}, STATEDATA_DATA,
	"Material Information",
	StateGetMaterial,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 1.0}
    },
    {
	{GL_PIXEL_MAP_A_TO_A, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_B_TO_B, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_G_TO_G, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_A, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_B, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_G, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_I, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_I_TO_R, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_R_TO_R, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_PIXEL_MAP_S_TO_S, GL_NULL}, STATEDATA_DATA,
	"Pixel map Information",
	StateGetPixelMap,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexEnv,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexEnv,
	STATEDATA_LOCKED, 1, {GL_MODULATE}
    },
    {
	{GL_Q, GL_EYE_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_Q, GL_OBJECT_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_Q, GL_TEXTURE_GEN_MODE, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 1, {GL_EYE_LINEAR}
    },
    {
	{GL_R, GL_EYE_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_R, GL_OBJECT_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_R, GL_TEXTURE_GEN_MODE, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 1, {GL_EYE_LINEAR}
    },
    {
	{GL_S, GL_EYE_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {1.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_S, GL_OBJECT_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {1.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_S, GL_TEXTURE_GEN_MODE, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 1, {GL_EYE_LINEAR}
    },
    {
	{GL_T, GL_EYE_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 0.0}
    },
    {
	{GL_T, GL_OBJECT_PLANE, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 4, {0.0, 1.0, 0.0, 0.0}
    },
    {
	{GL_T, GL_TEXTURE_GEN_MODE, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexGen,
	STATEDATA_LOCKED, 1, {GL_EYE_LINEAR}
    },
    {
	{GL_TEXTURE_1D, GL_TEXTURE_BORDER_COLOR, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_LINEAR}
    },
    {
	{GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_NEAREST_MIPMAP_LINEAR}
    },
    {
	{GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_REPEAT}
    },
    {
	{GL_TEXTURE_1D, GL_TEXTURE_WRAP_T, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_REPEAT}
    },
    {
	{GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, GL_NULL}, STATEDATA_DATA,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_LINEAR}
    },
    {
	{GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_NEAREST_MIPMAP_LINEAR}
    },
    {
	{GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_REPEAT}
    },
    {
	{GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_NULL}, STATEDATA_ENUM,
	"Texture Information",
	StateGetTexParm,
	STATEDATA_LOCKED, 1, {GL_REPEAT}
    },
    {
	{GL_POLYGON_STIPPLE, GL_NULL}, STATEDATA_STIPPLE,
	"State Information",
	StateGetPolygonStipple,
	STATEDATA_LOCKED, 128, {255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0, 255.0}
    },
    {
	{GL_NULL}
    }
};


/*****************************************************************************/

static void StateGetTarget(stateRec *ptr)
{

    glGetFloatv(ptr->value[0], ptr->dataCur);
}

static void StateGetClipPlane(stateRec *ptr)
{
    GLdouble tmpBuf[256];
    long i;

    for (i = 0; i < 256; i++) {
	tmpBuf[i] = -1.0;
    }
    glGetClipPlane(ptr->value[0], tmpBuf);
    for (i = 0; i < 4; i++) {
	ptr->dataCur[i] = (float)tmpBuf[i];
    }
}

static void StateGetLight(stateRec *ptr)
{

    glGetLightfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

static void StateGetMap(stateRec *ptr)
{

    glGetMapfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

static void StateGetMaterial(stateRec *ptr)
{

    glGetMaterialfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

static void StateGetPixelMap(stateRec *ptr)
{

    glGetPixelMapfv(ptr->value[0], ptr->dataCur);
}

static void StateGetPolygonStipple(stateRec *ptr)
{
    GLubyte tmpBuf[256];
    long i;

    for (i = 0; i < 256; i++) {
	tmpBuf[i] = 0xFF;
    }
    glGetPolygonStipple((GLubyte *)tmpBuf);
    for (i = 0; i < 128; i++) {
	ptr->dataCur[i] = (float)tmpBuf[i];
    }
}

static void StateGetTexEnv(stateRec *ptr)
{

    glGetTexEnvfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

static void StateGetTexGen(stateRec *ptr)
{

    glGetTexGenfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

static void StateGetTexParm(stateRec *ptr)
{

    glGetTexParameterfv(ptr->value[0], ptr->value[1], ptr->dataCur);
}

/*****************************************************************************/

long StateCheck(void)
{
    stateRec *ptr;
    long i;

    for (ptr = state; ptr->value[0] != GL_NULL; ptr++) {
	for (i = 0; i < 256; i++) {
	    ptr->dataCur[i] = -1.0;
	}
	(*ptr->GetFunc)(ptr);
	if (ptr->dataFlag == GL_TRUE) {
	    for (i = 0; i < ptr->dataCount; i++) {
		if (ABS(ptr->dataCur[i]-ptr->dataTrue[i]) > epsilon.zero) {
		    return ERROR;
		}
	    }
	    if (ptr->dataCur[i] != -1.0) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

long StateInit(void)
{
    stateRec *ptr;
    long i;

    for (ptr = state; ptr->value[0] != GL_NULL; ptr++) {
	if (ptr->dataType == STATEDATA_DEPENDENT) {
	    for (i = 0; i < 256; i++) {
		ptr->dataCur[i] = -1.0;
	    }
	    (*ptr->GetFunc)(ptr);
	    for (i = 0; i < ptr->dataCount; i++) {
		ptr->dataTrue[i] = ptr->dataCur[i];
	    }
	    ptr->dataFlag = GL_TRUE;
	    if (ptr->dataCur[i] != -1.0) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

void StateReport(void)
{
    stateRec *ptr;
    char name[40];
    float data[40];
    long i, j;

    Output(2, "    State Report. (Current) <-> (Default)\n");
    for (ptr = state; ptr->value[0] != GL_NULL; ptr++) {
	if (ptr->dataCount > 0) {
	    (*ptr->GetFunc)(ptr);
	    for (i = 0; i < ptr->dataCount; i++) {
		if (ABS(ptr->dataCur[i]-ptr->dataTrue[i]) > epsilon.zero) {
		    Output(2, "        ");
		    for (i = 0; ptr->value[i] != GL_NULL; i++) {
			GetEnumName(ptr->value[i], name);
			Output(2, "%s", name);
			if (ptr->value[i+1] != GL_NULL) {
			    Output(2, ", ");
			} else {
			    Output(2, " (%s)\n", ptr->title);
			}
		    }
		    switch (ptr->valueType) {
		      case STATEDATA_BOOLEAN:
			Output(2, "           ");
			for (i = 0; i < ptr->dataCount; i++) {
			    if (ptr->dataCur[i] == 0.0) {
				Output(2, " GL_FALSE");
			    } else if (ptr->dataCur[i] == 1.0) {
				Output(2, " GL_TRUE");
			    } else {
				Output(2, " %.2f", ptr->dataCur[i]);
			    }
			}
			Output(2, " <->");
			for (i = 0; i < ptr->dataCount; i++) {
			    if (ptr->dataTrue[i] == 0.0) {
				Output(2, " GL_FALSE");
			    } else if (ptr->dataTrue[i] == 1.0) {
				Output(2, " GL_TRUE");
			    } else {
				Output(2, " %.2f", ptr->dataTrue[i]);
			    }
			}
			Output(2, "\n");
			break;
		      case STATEDATA_DATA:
			Output(2, "           ");
			for (i = 0; i < ptr->dataCount; i++) {
			    Output(2, " %.2f", ptr->dataCur[i]);
			}
			Output(2, " <->");
			for (i = 0; i < ptr->dataCount; i++) {
			    Output(2, " %.2f", ptr->dataTrue[i]);
			}
			Output(2, "\n");
			break;
		      case STATEDATA_ENUM:
			Output(2, "           ");
			for (i = 0; i < ptr->dataCount; i++) {
			    GetEnumName(ptr->dataCur[i], name);
			    Output(2, " %s", name);
			}
			Output(2, " <->");
			for (i = 0; i < ptr->dataCount; i++) {
			    GetEnumName(ptr->dataTrue[i], name);
			    Output(2, " %s", name);
			}
			Output(2, "\n");
			break;
		      case STATEDATA_MATRIX:
			for (i = 0; i < 4; i++) {
			    Output(2, "           ");
			    for (j = 0; j < 4; j++) {
				Output(2, " %+.3f", ptr->dataCur[i*4+j]);
			    }
			    Output(2, " <->");
			    for (j = 0; j < 4; j++) {
				Output(2, " %+.3f", ptr->dataTrue[i*4+j]);
			    }
			    Output(2, "\n");
			}
			break;
		      case STATEDATA_STIPPLE:
			for (i = 0; i < 16; i++) {
			    Output(2, "           ");
			    for (j = 0; j < 8; j++) {
				Output(2, " %2X",
				       (unsigned char)ptr->dataCur[i*8+j]);
			    }
			    Output(2, " <->");
			    for (j = 0; j < 8; j++) {
				Output(2, " %2X",
				       (unsigned char)ptr->dataTrue[i*8+j]);
			    }
			    Output(2, "\n");
			}
			break;
		    }
		    break;
		}
	    }
	}
    }
}

long StateReset(void)
{

    ResetMatrix();
    glPopAttrib();
    if (machine.stateCheckFlag == GL_TRUE) {
	if (StateCheck() == ERROR) {
	    return ERROR_STATE;
	} else {
	    return NO_ERROR;
	}
    } else {
	return NO_ERROR;
    }
}

void StateSave(void)
{

    glPushAttrib(GL_ALL_ATTRIB_BITS);
}

void StateSetup(void)
{
    stateRec *ptr;

    for (ptr = state; ptr->value[0] != GL_NULL; ptr++) {
	if (ptr->dataType == STATEDATA_LOCKED) {
	    ptr->dataFlag = GL_TRUE;
	} else {
	    ptr->dataFlag = GL_FALSE;
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\c.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallCallList(void)
{

    Output("glCallList\n");
    glCallList(1);
    Output("\n");
}

void CallCallLists(void)
{
    static unsigned char buf[8] = {
	0, 0, 0, 0, 0, 0, 0, 0
    };
    long i;

    Output("glCallLists\n");
    for (i = 0; enum_ListNameType[i].value != -1; i++) {
	Output("\t%s\n", enum_ListNameType[i].name);
	glCallLists(1, enum_ListNameType[i].value, buf);
	ProbeEnum();
    }
    Output("\n");
}

void CallClear(void)
{
    long i;

    Output("glClear\n");
    for (i = 0; enum_ClearBufferMask[i].value != -1; i++) {
	Output("\t%s\n", enum_ClearBufferMask[i].name);
	glClear(enum_ClearBufferMask[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallClearAccum(void)
{

    Output("glClearAccum\n");
    glClearAccum(0.0, 0.0, 0.0, 0.0);
    Output("\n");
}

void CallClearColor(void)
{

    Output("glClearColor\n");
    glClearColor(0.0, 0.0, 0.0, 1.0);
    Output("\n");
}

void CallClearDepth(void)
{

    Output("glClearDepth\n");
    glClearDepth(0);
    Output("\n");
}

void CallClearIndex(void)
{

    Output("glClearIndex\n");
    glClearIndex(0.0);
    Output("\n");
}

void CallClearStencil(void)
{

    Output("glClearStencil\n");
    glClearStencil(0);
    Output("\n");
}

void CallClipPlane(void)
{
    static GLdouble buf[] = {
	1.0, 1.0, 1.0, 1.0
    };
    long i;

    Output("glClipPlane\n");
    for (i = 0; enum_ClipPlaneName[i].value != -1; i++) {
	Output("\t%s\n", enum_ClipPlaneName[i].name);
	glClipPlane(enum_ClipPlaneName[i].value, buf);
	ProbeEnum();
    }
    Output("\n");
}

void CallColor(void)
{
    GLfloat r, g, b, a;

    r = 1.0;
    g = 1.0;
    b = 1.0;
    a = 1.0;

    Output("glColor3b, ");
    Output("glColor3bv, ");
    Output("glColor3ub, ");
    Output("glColor3ubv, ");
    Output("glColor3s, ");
    Output("glColor3sv, ");
    Output("glColor3us, ");
    Output("glColor3usv, ");
    Output("glColor3i, ");
    Output("glColor3iv, ");
    Output("glColor3ui, ");
    Output("glColor3uiv, ");
    Output("glColor3f, ");
    Output("glColor3fv, ");
    Output("glColor3d, ");
    Output("glColor3dv, ");
    Output("glColor4b, ");
    Output("glColor4bv, ");
    Output("glColor4ub, ");
    Output("glColor4ubv, ");
    Output("glColor4s, ");
    Output("glColor4sv, ");
    Output("glColor4us, ");
    Output("glColor4usv, ");
    Output("glColor4i, ");
    Output("glColor4iv, ");
    Output("glColor4ui, ");
    Output("glColor4uiv, ");
    Output("glColor4f, ");
    Output("glColor4fv, ");
    Output("glColor4d, ");
    Output("glColor4dv\n");

    glColor3b((GLbyte)(r*255.0), (GLbyte)(g*255.0), (GLbyte)(b*255.0));

    {
	GLbyte buf[3];
	buf[0] = (GLbyte)(r * 255.0);
	buf[1] = (GLbyte)(g * 255.0);
	buf[2] = (GLbyte)(b * 255.0);
	glColor3bv(buf);
    }

    glColor3ub((GLubyte)(r*255.0), (GLubyte)(g*255.0), (GLubyte)(b*255.0));

    {
	GLubyte buf[3];
	buf[0] = (GLubyte)(r * 255.0);
	buf[1] = (GLubyte)(g * 255.0);
	buf[2] = (GLubyte)(b * 255.0);
	glColor3ubv(buf);
    }

    glColor3s((GLshort)(r*65535.0), (GLshort)(g*65535.0), (GLshort)(b*65535.0));

    {
	GLshort buf[3];
	buf[0] = (GLshort)(r * 65535.0);
	buf[1] = (GLshort)(g * 65535.0);
	buf[2] = (GLshort)(b * 65535.0);
	glColor3sv(buf);
    }

    glColor3us((GLushort)(r*65535.0), (GLushort)(g*65535.0), (GLushort)(b*65535.0));

    {
	GLushort buf[3];
	buf[0] = (GLushort)(r * 65535.0);
	buf[1] = (GLushort)(g * 65535.0);
	buf[2] = (GLushort)(b * 65535.0);
	glColor3usv(buf);
    }

    glColor3i((GLint)(r*65535.0), (GLint)(g*65535.0), (GLint)(b*65535.0));

    {
	GLint buf[3];
	buf[0] = (GLint)(r * 65535.0);
	buf[1] = (GLint)(g * 65535.0);
	buf[2] = (GLint)(b * 65535.0);
	glColor3iv(buf);
    }

    glColor3ui((GLuint)(r*65535.0), (GLuint)(g*65535.0), (GLuint)(b*65535.0));

    {
	GLuint buf[3];
	buf[0] = (GLuint)(r * 65535.0);
	buf[1] = (GLuint)(g * 65535.0);
	buf[2] = (GLuint)(b * 65535.0);
	glColor3uiv((GLuint *)buf);
    }

    glColor3f((GLfloat)(r*1.0), (GLfloat)(g*1.0), (GLfloat)(b*1.0));

    {
	GLfloat buf[3];
	buf[0] = (GLfloat)(r * 1.0);
	buf[1] = (GLfloat)(g * 1.0);
	buf[2] = (GLfloat)(b * 1.0);
	glColor3fv(buf);
    }

    glColor3d((GLdouble)(r*1.0), (GLdouble)(g*1.0), (GLdouble)(b*1.0));

    {
	GLdouble buf[3];
	buf[0] = (GLdouble)(r * 1.0);
	buf[1] = (GLdouble)(g * 1.0);
	buf[2] = (GLdouble)(b * 1.0);
	glColor3dv(buf);
    }

    glColor4b((GLbyte)(r*255.0), (GLbyte)(g*255.0), (GLbyte)(b*255.0), (GLbyte)(a*255.0));

    {
	GLbyte buf[4];
	buf[0] = (GLbyte)(r * 255.0);
	buf[1] = (GLbyte)(g * 255.0);
	buf[2] = (GLbyte)(b * 255.0);
	buf[3] = (GLbyte)(a * 255.0);
	glColor4bv(buf);
    }

    glColor4ub((GLubyte)(r*255.0), (GLubyte)(g*255.0), (GLubyte)(b*255.0), (GLubyte)(a*255.0));

    {
	GLubyte buf[4];
	buf[0] = (GLubyte)(r * 255.0);
	buf[1] = (GLubyte)(g * 255.0);
	buf[2] = (GLubyte)(b * 255.0);
	buf[3] = (GLubyte)(a * 255.0);
	glColor4ubv(buf);
    }

    glColor4s((GLshort)(r*65535.0), (GLshort)(g*65535.0), (GLshort)(b*65535.0), (GLshort)(a*65535.0));

    {
	GLshort buf[4];
	buf[0] = (GLshort)(r * 65535.0);
	buf[1] = (GLshort)(g * 65535.0);
	buf[2] = (GLshort)(b * 65535.0);
	buf[3] = (GLshort)(a * 65535.0);
	glColor4sv(buf);
    }

    glColor4us((GLushort)(r*65535.0), (GLushort)(g*65535.0), (GLushort)(b*65535.0), (GLushort)(a*65535.0));

    {
	GLushort buf[4];
	buf[0] = (GLushort)(r * 65535.0);
	buf[1] = (GLushort)(g * 65535.0);
	buf[2] = (GLushort)(b * 65535.0);
	buf[3] = (GLushort)(a * 65535.0);
	glColor4usv(buf);
    }

    glColor4i((GLint)(r*65535.0), (GLint)(g*65535.0), (GLint)(b*65535.0), (GLint)(a*65535.0));

    {
	GLint buf[4];
	buf[0] = (GLint)(r * 65535.0);
	buf[1] = (GLint)(g * 65535.0);
	buf[2] = (GLint)(b * 65535.0);
	buf[3] = (GLint)(a * 65535.0);
	glColor4iv(buf);
    }

    glColor4ui((GLuint)(r*65535.0), (GLuint)(g*65535.0), (GLuint)(b*65535.0), (GLuint)(a*65535.0));

    {
	GLuint buf[4];
	buf[0] = (GLuint)(r * 65535.0);
	buf[1] = (GLuint)(g * 65535.0);
	buf[2] = (GLuint)(b * 65535.0);
	buf[3] = (GLuint)(a * 65535.0);
	glColor4uiv((GLuint *)buf);
    }

    glColor4f((GLfloat)(r*1.0), (GLfloat)(g*1.0), (GLfloat)(b*1.0), (GLfloat)(a*1.0));

    {
	GLfloat buf[4];
	buf[0] = (GLfloat)(r * 1.0);
	buf[1] = (GLfloat)(g * 1.0);
	buf[2] = (GLfloat)(b * 1.0);
	buf[3] = (GLfloat)(a * 1.0);
	glColor4fv(buf);
    }

    glColor4d((GLdouble)(r*1.0), (GLdouble)(g*1.0), (GLdouble)(b*1.0), (GLdouble)(a*1.0));

    {
	GLdouble buf[4];
	buf[0] = (GLdouble)(r * 1.0);
	buf[1] = (GLdouble)(g * 1.0);
	buf[2] = (GLdouble)(b * 1.0);
	buf[3] = (GLdouble)(a * 1.0);
	glColor4dv(buf);
    }

    Output("\n");
}

void CallColorMask(void)
{

    Output("glColorMask\n");
    glColorMask(0, 0, 0, 1);
    Output("\n");
}

void CallColorMaterial(void)
{
    long i, j;

    Output("glColorMaterial\n");
    for (i = 0; enum_MaterialFace[i].value != -1; i++) {
	for (j = 0; enum_MaterialParameter[j].value != -1; j++) {

	    if (enum_MaterialParameter[j].value == GL_COLOR_INDEXES) {
		continue;
	    } else if (enum_MaterialParameter[j].value == GL_SHININESS) {
		continue;
	    }

	    Output("\t%s, %s\n", enum_MaterialFace[i].name, enum_MaterialParameter[j].name);
	    glColorMaterial(enum_MaterialFace[i].value, enum_MaterialParameter[j].value);
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallCopyPixels(void)
{
    long i;

    Output("glCopyPixels\n");
    for (i = 0; enum_PixelCopyType[i].value != -1; i++) {
	Output("\t%s\n", enum_PixelCopyType[i].name);
	glCopyPixels(0, 0, 10, 10, enum_PixelCopyType[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallCullFace(void)
{
    long i;

    Output("glCullFace\n");
    for (i = 0; enum_CullFaceMode[i].value != -1; i++) {
	Output("\t%s\n", enum_CullFaceMode[i].name);
	glCullFace(enum_CullFaceMode[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\d.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallDeleteLists(void)
{

    Output("glDeleteLists\n");
    glDeleteLists(1, 1);
    Output("\n");
}

void CallDepthFunc(void)
{
    long i;

    Output("glDepthFunc\n");
    for (i = 0; enum_DepthFunction[i].value != -1; i++) {
	Output("\t%s\n", enum_DepthFunction[i].name);
	glDepthFunc(enum_DepthFunction[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallDepthMask(void)
{

    Output("glDepthMask\n");
    glDepthMask(0);
    Output("\n");
}

void CallDepthRange(void)
{

    Output("glDepthRange\n");
    glDepthRange(0.0, 1.0);
    Output("\n");
}

void CallDrawBuffer(void)
{
    long i;

    Output("glDrawBuffer\n");
    for (i = 0; enum_DrawBufferMode[i].value != -1; i++) {
	Output("\t%s\n", enum_DrawBufferMode[i].name);
	glDrawBuffer(enum_DrawBufferMode[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\e.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallEdgeFlag(void)
{
    long i;

    Output("glEdgeFlag, ");
    Output("glEdgeFlagv\n");
    for (i = 0; enum_Boolean[i].value != -1; i++) {
	Output("\t%s\n", enum_Boolean[i].name);
	glEdgeFlag((unsigned char)enum_Boolean[i].value);
	{
	    GLboolean buf[1];
	    buf[0] = (unsigned char)enum_Boolean[i].value;
	    glEdgeFlagv(buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallEnableIsEnableDisable(void)
{
    long i, x;

    Output("glEnable, ");
    Output("glIsEnabled, ");
    Output("glDisable\n");
    for (i = 0; enum_Enable[i].value != -1; i++) {

	if (enum_Enable[i].value == GL_TEXTURE_GEN_R) {
	    continue;
	} else if (enum_Enable[i].value == GL_TEXTURE_GEN_Q) {
	    continue;
	}

	Output("\t%s\n", enum_Enable[i].name);
	glEnable(enum_Enable[i].value);
	x = glIsEnabled(enum_Enable[i].value);
	glDisable(enum_Enable[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallEvalCoord(void)
{
    float x, y;

    x = 0.0;
    y = 0.0;

    Output("glEvalCoord1f, ");
    Output("glEvalCoord1fv, ");
    Output("glEvalCoord1d, ");
    Output("glEvalCoord1dv, ");
    Output("glEvalCoord2f, ");
    Output("glEvalCoord2fv, ");
    Output("glEvalCoord2d, ");
    Output("glEvalCoord2dv\n");

    glEvalCoord1f((GLfloat)x);

    {
	GLfloat buf[1];
	buf[0] = (float)x;
	glEvalCoord1fv(buf);
    }

    glEvalCoord1d((GLdouble)x);

    {
	GLdouble buf[1];
	buf[0] = (GLdouble)x;
	glEvalCoord1dv(buf);
    }

    glEvalCoord2f((GLfloat)x, (GLfloat)y);

    {
	GLfloat buf[2];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	glEvalCoord2fv(buf);
    }

    glEvalCoord2d((GLdouble)x, (GLdouble)y);

    {
	GLdouble buf[2];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	glEvalCoord2dv(buf);
    }

    Output("\n");
}

void CallEvalMesh1(void)
{
    long i;

    Output("glEvalMesh1\n");
    for (i = 0; enum_MeshMode1[i].value != -1; i++) {
	Output("\t%s\n", enum_MeshMode1[i].name);
	glEvalMesh1(enum_MeshMode1[i].value, 0, 1);
	ProbeEnum();
    }
    Output("\n");
}

void CallEvalMesh2(void)
{
    long i;

    Output("glEvalMesh2\n");
    for (i = 0; enum_MeshMode2[i].value != -1; i++) {
	Output("\t%s\n", enum_MeshMode2[i].name);
	glEvalMesh2(enum_MeshMode2[i].value, 0, 1, 0, 1);
	ProbeEnum();
    }
    Output("\n");
}

void CallEvalPoint1(void)
{

    Output("glEvalPoint1\n");
    glEvalPoint1(0);
    Output("\n");
}

void CallEvalPoint2(void)
{

    Output("glEvalPoint2\n");
    glEvalPoint2(0, 0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\f.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallFeedbackBuffer(void)
{
    GLfloat buf[1];
    long i;

    Output("glFeedbackBuffer\n");
    for (i = 0; enum_FeedBackMode[i].value != -1; i++) {
	Output("\t%s\n", enum_FeedBackMode[i].name);
	glFeedbackBuffer(1, enum_FeedBackMode[i].value, buf);
	ProbeEnum();
    }
    Output("\n");
}

void CallFinish(void)
{

    Output("glFinish\n");
    glFinish();
    Output("\n");
}

void CallFlush(void)
{

    Output("glFlush\n");
    glFlush();
    Output("\n");
}

void CallFog(void)
{
    long i, j;

    Output("glFogi, ");
    Output("glFogf\n");
    for (i = 0; enum_FogParameter[i].value != -1; i++) {

	if (enum_FogParameter[i].value == GL_FOG_COLOR) {
	    continue;
	}

	Output("\t%s\n", enum_FogParameter[i].name);
	switch (enum_FogParameter[i].value) {
	    case GL_FOG_MODE:
		for (j = 0; enum_FogMode[j].value != -1; j++) {
		    Output("\t%s, %s\n", enum_FogParameter[i].name, enum_FogMode[j].name);
		    glFogi(enum_FogParameter[i].value, (GLint)enum_FogMode[j].value);
		    glFogf(enum_FogParameter[i].value, (GLfloat)enum_FogMode[j].value);
		    ProbeEnum();
		}
		break;
	    case GL_FOG_START:
	    case GL_FOG_END:
	    case GL_FOG_INDEX:
	    case GL_FOG_DENSITY:
		Output("\t%s\n", enum_FogParameter[i].name);
		glFogi(enum_FogParameter[i].value, 0);
		glFogf(enum_FogParameter[i].value, 0.0);
		ProbeEnum();
		break;
	}
	ProbeEnum();
    }
    Output("\n");

    Output("glFogiv, ");
    Output("glFogfv\n");
    for (i = 0; enum_FogParameter[i].value != -1; i++) {
	switch (enum_FogParameter[i].value) {
	    case GL_FOG_MODE:
		for (j = 0; enum_FogMode[j].value != -1; j++) {
		    Output("\t%s, %s\n", enum_FogParameter[i].name, enum_FogMode[j].name);
		    {
			GLint buf[1];
			buf[0] = (GLint)enum_FogMode[j].value;
			glFogiv(enum_FogParameter[i].value, buf);
		    }
		    {
			GLfloat buf[1];
			buf[0] = (GLfloat)enum_FogMode[j].value;
			glFogfv(enum_FogParameter[i].value, buf);
		    }
		    ProbeEnum();
		}
		break;
	    case GL_FOG_START:
	    case GL_FOG_END:
	    case GL_FOG_COLOR:
	    case GL_FOG_INDEX:
	    case GL_FOG_DENSITY:
		Output("\t%s\n", enum_FogParameter[i].name);
		{
		    static GLint buf[] = {
			0, 0, 0, 0
		    };
		    glFogiv(enum_FogParameter[i].value, buf);
		}
		{
		    static GLfloat buf[] = {
			0.0, 0.0, 0.0, 0.0
		    };
		    glFogfv(enum_FogParameter[i].value, buf);
		}
		ProbeEnum();
		break;
	}
    }
    Output("\n");
}

void CallFrontFace(void)
{
    long i;

    Output("glFrontFace\n");
    for (i = 0; enum_FrontFaceDirection[i].value != -1; i++) {
	Output("\t%s\n", enum_FrontFaceDirection[i].name);
	glFrontFace(enum_FrontFaceDirection[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallFrustum(void)
{

    Output("glFrustum\n");
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 2.0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\g.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallGenLists(void)
{
    GLuint x;

    Output("glGenLists\n");
    x = glGenLists(1);
    Output("\n");
}

void CallGet(void)
{
    long i;

    Output("glGetBooleanv, ");
    Output("glGetIntegerv, ");
    Output("glGetFloatv, ");
    Output("glGetDoublev\n");
    for (i = 0; enum_GetTarget[i].value != -1; i++) {
	Output("\t%s\n", enum_GetTarget[i].name);
	{
	    GLubyte buf[100];
	    glGetBooleanv(enum_GetTarget[i].value, buf);
	}
	{
	    GLint buf[100];
	    glGetIntegerv(enum_GetTarget[i].value, buf);
	}
	{
	    GLfloat buf[100];
	    glGetFloatv(enum_GetTarget[i].value, buf);
	}
	{
	    GLdouble buf[100];
	    glGetDoublev(enum_GetTarget[i].value, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallGetClipPlane(void)
{
    GLdouble buf[100];
    long i;

    Output("glGetClipPlane\n");
    for (i = 0; enum_ClipPlaneName[i].value != -1; i++) {
	Output("\t%s\n", enum_ClipPlaneName[i].name);
	glGetClipPlane(enum_ClipPlaneName[i].value, buf);
	ProbeEnum();
    }
    Output("\n");
}

void CallGetError(void)
{

    Output("glGetError\n");
    glGetError();
    Output("\n");
}

void CallGetLight(void)
{
    long i, j;

    Output("glGetLightiv, ");
    Output("glGetLightfv\n");
    for (i = 0; enum_LightName[i].value != -1; i++) {
	for (j = 0; enum_LightParameter[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_LightName[i].name, enum_LightParameter[j].name);
	    {
		GLint buf[100];
		glGetLightiv(enum_LightName[i].value, enum_LightParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetLightfv(enum_LightName[i].value, enum_LightParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetMap(void)
{
    long i, j;

    Output("glGetMapiv, ");
    Output("glGetMapfv, ");
    Output("glGetMapdv\n");
    for (i = 0; enum_MapTarget[i].value != -1; i++) {
	for (j = 0; enum_MapGetTarget[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_MapTarget[i].name, enum_MapGetTarget[j].name);
	    {
		GLint buf[100];
		glGetMapiv(enum_MapTarget[i].value, enum_MapGetTarget[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetMapfv(enum_MapTarget[i].value, enum_MapGetTarget[j].value, buf);
	    }
	    {
		GLdouble buf[100];
		glGetMapdv(enum_MapTarget[i].value, enum_MapGetTarget[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetMaterial(void)
{
    long i, j;

    Output("glGetMaterialiv, ");
    Output("glGetMaterialfv\n");
    for (i = 0; enum_MaterialFace[i].value != -1; i++) {
	for (j = 0; enum_MaterialParameter[j].value != -1; j++) {

	    if (enum_MaterialFace[i].value == GL_FRONT_AND_BACK) {
		continue;
	    }
	    if (enum_MaterialParameter[j].value == GL_AMBIENT_AND_DIFFUSE) {
		continue;
	    }

	    Output("\t%s, %s\n", enum_MaterialFace[i].name, enum_MaterialParameter[j].name);
	    {
		GLint buf[100];
		glGetMaterialiv(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetMaterialfv(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetPixelMap(void)
{
    long i;

    Output("glGetPixelMapusv, ");
    Output("glGetPixelMapuiv, ");
    Output("glGetPixelMapfv\n");
    for (i = 0; enum_PixelMap[i].value != -1; i++) {
	Output("\t%s\n", enum_PixelMap[i].name);
	{
	    GLushort buf[100];
	    glGetPixelMapusv(enum_PixelMap[i].value, buf);
	}
	{
	    GLuint buf[100];
	    glGetPixelMapuiv(enum_PixelMap[i].value, buf);
	}
	{
	    GLfloat buf[100];
	    glGetPixelMapfv(enum_PixelMap[i].value, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallGetPolygonStipple(void)
{
    GLubyte buf[128];

    glGetPolygonStipple(buf);
}

void CallGetString(void)
{
    const GLubyte *buf;
    long i;

    Output("glGetString\n");
    for (i = 0; enum_StringName[i].value != -1; i++) {
	Output("\t%s\n", enum_StringName[i].name);
	buf = glGetString(enum_StringName[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallGetTexEnv(void)
{
    long i, j;

    Output("glGetTexEnviv, ");
    Output("glGetTexEnvfv\n");
    for (i = 0; enum_TextureEnvTarget[i].value != -1; i++) {
	for (j = 0; enum_TextureEnvParameter[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_TextureEnvTarget[i].name, enum_TextureEnvParameter[j].name);
	    {
		GLint buf[100];
		glGetTexEnviv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetTexEnvfv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetTexGen(void)
{
    long i, j;

    Output("glGetTexGeniv, ");
    Output("glGetTexGenfv\n");
    for (i = 0; enum_TextureCoordName[i].value != -1; i++) {
	for (j = 0; enum_TextureGenParameter[j].value != -1; j++) {

	    Output("\t%s, %s\n", enum_TextureCoordName[i].name, enum_TextureGenParameter[j].name);
	    {
		GLint buf[100];
		glGetTexGeniv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetTexGenfv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
	    }
	    {
		GLdouble buf[100];
		glGetTexGendv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetTexImage(void)
{
    GLubyte buf[1000];
    long i, j, k;

    Output("glGetTexImage\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_PixelFormat[j].value != -1; j++) {
	    for (k = 0; enum_PixelType[k].value != -1; k++) {
		if (enum_PixelFormat[j].value == GL_COLOR_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_STENCIL_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_DEPTH_COMPONENT) {
		    continue;
		}
		if (enum_PixelType[k].value == GL_BITMAP) {
		    continue;
		}

		Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_PixelFormat[j].name, enum_PixelType[k].name);
		glGetTexImage(enum_TextureTarget[i].value, 0, enum_PixelFormat[j].value, enum_PixelType[k].value, buf); 
		ProbeEnum();
	    }
	}
    }
    Output("\n");
}

void CallGetTexLevelParameter(void)
{
    long i, j;

    Output("glGetTexLevelParameteriv, ");
    Output("glGetTexLevelParameterfv\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_GetTextureParameter[j].value != -1; j++) {

	    if (enum_GetTextureParameter[j].value == GL_TEXTURE_MAG_FILTER) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_MIN_FILTER) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_WRAP_S) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_WRAP_T) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_BORDER_COLOR) {
     		continue;
	    }

	    Output("\t%s, %s\n", enum_TextureTarget[i].name, enum_GetTextureParameter[j].name);
	    {
		GLint buf[100];
		glGetTexLevelParameteriv(enum_TextureTarget[i].value, 0, enum_GetTextureParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetTexLevelParameterfv(enum_TextureTarget[i].value, 0, enum_GetTextureParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallGetTexParameter(void)
{
    long i, j;

    Output("glGetTexParameteriv, ");
    Output("glGetTexParameterfv\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_GetTextureParameter[j].value != -1; j++) {

	    if (enum_GetTextureParameter[j].value == GL_TEXTURE_WIDTH) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_HEIGHT) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_COMPONENTS) {
     		continue;
	    } else if (enum_GetTextureParameter[j].value == GL_TEXTURE_BORDER) {
     		continue;
	    }

	    Output("\t%s, %s\n", enum_TextureTarget[i].name, enum_GetTextureParameter[j].name);
	    {
		GLint buf[100];
		glGetTexParameteriv(enum_TextureTarget[i].value, enum_GetTextureParameter[j].value, buf);
	    }
	    {
		GLfloat buf[100];
		glGetTexParameterfv(enum_TextureTarget[i].value, enum_GetTextureParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\i.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallIndex(void)
{
    float ci;

    ci = 255.0;

    Output("glIndexs, ");
    Output("glIndexsv, ");
    Output("glIndexi, ");
    Output("glIndexiv, ");
    Output("glIndexf, ");
    Output("glIndexfv, ");
    Output("glIndexd, ");
    Output("glIndexdv\n");

    glIndexs((GLshort)ci);

    {
	short buf[1];
	buf[0] = (short)ci;
	glIndexsv(buf);
    }

    glIndexi((GLint)ci);

    {
	GLint buf[1];
	buf[0] = (GLint)ci;
	glIndexiv(buf);
    }

    glIndexf((GLfloat)ci);

    {
	GLfloat buf[1];
	buf[0] = (GLfloat)ci;
	glIndexfv(buf);
    }

    glIndexd((GLdouble)ci);

    {
	GLdouble buf[1];
	buf[0] = (GLdouble)ci;
	glIndexdv(buf);
    }

    Output("\n");
}

void CallIndexMask(void)
{

    Output("glIndexMask\n");
    glIndexMask(0xFFFFFFFF);
    Output("\n");
}

void CallInitNames(void)
{

    Output("glInitNames\n");
    glInitNames();
    Output("\n");
}

void CallIsList(void)
{
    GLubyte x;

    Output("glIsList\n");
    x = glIsList(1);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\data.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


enumCheckRec enum_Check[] = {
    {
	"GL_2_BYTES", GL_2_BYTES, 5127
    },
    {
	"GL_3_BYTES", GL_3_BYTES, 5128
    },
    {
	"GL_4_BYTES", GL_4_BYTES, 5129
    },
    {
	"GL_2D", GL_2D, 1536
    },
    {
	"GL_3D", GL_3D, 1537
    },
    {
	"GL_3D_COLOR", GL_3D_COLOR, 1538
    },
    {
	"GL_3D_COLOR_TEXTURE", GL_3D_COLOR_TEXTURE, 1539
    },
    {
	"GL_4D_COLOR_TEXTURE", GL_4D_COLOR_TEXTURE, 1540
    },
    {
	"GL_ACCUM", GL_ACCUM, 256
    },
    {
	"GL_ACCUM_ALPHA_BITS", GL_ACCUM_ALPHA_BITS, 3419
    },
    {
	"GL_ACCUM_BLUE_BITS", GL_ACCUM_BLUE_BITS, 3418
    },
    {
	"GL_ACCUM_BUFFER_BIT", GL_ACCUM_BUFFER_BIT, 512
    },
    {
	"GL_ACCUM_CLEAR_VALUE", GL_ACCUM_CLEAR_VALUE, 2944
    },
    {
	"GL_ACCUM_GREEN_BITS", GL_ACCUM_GREEN_BITS, 3417
    },
    {
	"GL_ACCUM_RED_BITS", GL_ACCUM_RED_BITS, 3416
    },
    {
	"GL_ADD", GL_ADD, 260
    },
    {
	"GL_ALL_ATTRIB_BITS", GL_ALL_ATTRIB_BITS, 1048575
    },
    {
	"GL_ALPHA", GL_ALPHA, 6406
    },
    {
	"GL_ALPHA_BIAS", GL_ALPHA_BIAS, 3357
    },
    {
	"GL_ALPHA_BITS", GL_ALPHA_BITS, 3413
    },
    {
	"GL_ALPHA_SCALE", GL_ALPHA_SCALE, 3356
    },
    {
	"GL_ALPHA_TEST", GL_ALPHA_TEST, 3008
    },
    {
	"GL_ALPHA_TEST_FUNC", GL_ALPHA_TEST_FUNC, 3009
    },
    {
	"GL_ALPHA_TEST_REF", GL_ALPHA_TEST_REF, 3010
    },
    {
	"GL_ALWAYS", GL_ALWAYS, 519
    },
    {
	"GL_AMBIENT", GL_AMBIENT, 4608
    },
    {
	"GL_AMBIENT_AND_DIFFUSE", GL_AMBIENT_AND_DIFFUSE, 5634
    },
    {
	"GL_AND", GL_AND, 5377
    },
    {
	"GL_AND_INVERTED", GL_AND_INVERTED, 5380
    },
    {
	"GL_AND_REVERSE", GL_AND_REVERSE, 5378
    },
    {
	"GL_ATTRIB_STACK_DEPTH", GL_ATTRIB_STACK_DEPTH, 2992
    },
    {
	"GL_AUTO_NORMAL", GL_AUTO_NORMAL, 3456
    },
    {
	"GL_AUX_BUFFERS", GL_AUX_BUFFERS, 3072
    },
    {
	"GL_AUX0", GL_AUX0, 1033
    },
    {
	"GL_AUX1", GL_AUX1, 1034
    },
    {
	"GL_AUX2", GL_AUX2, 1035
    },
    {
	"GL_AUX3", GL_AUX3, 1036
    },
    {
	"GL_BACK", GL_BACK, 1029
    },
    {
	"GL_BACK_LEFT", GL_BACK_LEFT, 1026
    },
    {
	"GL_BACK_RIGHT", GL_BACK_RIGHT, 1027
    },
    {
	"GL_BITMAP", GL_BITMAP, 6656
    },
    {
	"GL_BITMAP_TOKEN", GL_BITMAP_TOKEN, 1796
    },
    {
	"GL_BLEND", GL_BLEND, 3042
    },
    {
	"GL_BLEND_DST", GL_BLEND_DST, 3040
    },
    {
	"GL_BLEND_SRC", GL_BLEND_SRC, 3041
    },
    {
	"GL_BLUE", GL_BLUE, 6405
    },
    {
	"GL_BLUE_BIAS", GL_BLUE_BIAS, 3355
    },
    {
	"GL_BLUE_BITS", GL_BLUE_BITS, 3412
    },
    {
	"GL_BLUE_SCALE", GL_BLUE_SCALE, 3354
    },
    {
	"GL_BYTE", GL_BYTE, 5120
    },
    {
	"GL_CCW", GL_CCW, 2305
    },
    {
	"GL_CLAMP", GL_CLAMP, 10496
    },
    {
	"GL_CLEAR", GL_CLEAR, 5376
    },
    {
	"GL_CLIP_PLANE0", GL_CLIP_PLANE0, 12288
    },
    {
	"GL_CLIP_PLANE1", GL_CLIP_PLANE1, 12289
    },
    {
	"GL_CLIP_PLANE2", GL_CLIP_PLANE2, 12290
    },
    {
	"GL_CLIP_PLANE3", GL_CLIP_PLANE3, 12291
    },
    {
	"GL_CLIP_PLANE4", GL_CLIP_PLANE4, 12292
    },
    {
	"GL_CLIP_PLANE5", GL_CLIP_PLANE5, 12293
    },
    {
	"GL_COEFF", GL_COEFF, 2560
    },
    {
	"GL_COLOR", GL_COLOR, 6144
    },
    {
	"GL_COLOR_BUFFER_BIT", GL_COLOR_BUFFER_BIT, 16384
    },
    {
	"GL_COLOR_CLEAR_VALUE", GL_COLOR_CLEAR_VALUE, 3106
    },
    {
	"GL_COLOR_INDEX", GL_COLOR_INDEX, 6400
    },
    {
	"GL_COLOR_INDEXES", GL_COLOR_INDEXES, 5635
    },
    {
	"GL_COLOR_MATERIAL", GL_COLOR_MATERIAL, 2903
    },
    {
	"GL_COLOR_MATERIAL_FACE", GL_COLOR_MATERIAL_FACE, 2901
    },
    {
	"GL_COLOR_MATERIAL_PARAMETER", GL_COLOR_MATERIAL_PARAMETER, 2902
    },
    {
	"GL_COLOR_WRITEMASK", GL_COLOR_WRITEMASK, 3107
    },
    {
	"GL_COMPILE", GL_COMPILE, 4864
    },
    {
	"GL_COMPILE_AND_EXECUTE", GL_COMPILE_AND_EXECUTE, 4865
    },
    {
	"GL_CONSTANT_ATTENUATION", GL_CONSTANT_ATTENUATION, 4615
    },
    {
	"GL_COPY", GL_COPY, 5379
    },
    {
	"GL_COPY_INVERTED", GL_COPY_INVERTED, 5388
    },
    {
	"GL_COPY_PIXEL_TOKEN", GL_COPY_PIXEL_TOKEN, 1798
    },
    {
	"GL_CULL_FACE", GL_CULL_FACE, 2884
    },
    {
	"GL_CULL_FACE_MODE", GL_CULL_FACE_MODE, 2885
    },
    {
	"GL_CURRENT_BIT", GL_CURRENT_BIT, 1
    },
    {
	"GL_CURRENT_COLOR", GL_CURRENT_COLOR, 2816
    },
    {
	"GL_CURRENT_INDEX", GL_CURRENT_INDEX, 2817
    },
    {
	"GL_CURRENT_NORMAL", GL_CURRENT_NORMAL, 2818
    },
    {
	"GL_CURRENT_RASTER_COLOR", GL_CURRENT_RASTER_COLOR, 2820
    },
    {
	"GL_CURRENT_RASTER_INDEX", GL_CURRENT_RASTER_INDEX, 2821
    },
    {
	"GL_CURRENT_RASTER_POSITION", GL_CURRENT_RASTER_POSITION, 2823
    },
    {
	"GL_CURRENT_RASTER_POSITION_VALID", GL_CURRENT_RASTER_POSITION_VALID, 2824
    },
    {
	"GL_CURRENT_RASTER_TEXTURE_COORDS", GL_CURRENT_RASTER_TEXTURE_COORDS, 2822
    },
    {
	"GL_CURRENT_TEXTURE_COORDS", GL_CURRENT_TEXTURE_COORDS, 2819
    },
    {
	"GL_CW", GL_CW, 2304
    },
    {
	"GL_DECAL", GL_DECAL, 8449
    },
    {
	"GL_DECR", GL_DECR, 7683
    },
    {
	"GL_DEPTH", GL_DEPTH, 6145
    },
    {
	"GL_DEPTH_BIAS", GL_DEPTH_BIAS, 3359
    },
    {
	"GL_DEPTH_BITS", GL_DEPTH_BITS, 3414
    },
    {
	"GL_DEPTH_BUFFER_BIT", GL_DEPTH_BUFFER_BIT, 256
    },
    {
	"GL_DEPTH_CLEAR_VALUE", GL_DEPTH_CLEAR_VALUE, 2931
    },
    {
	"GL_DEPTH_COMPONENT", GL_DEPTH_COMPONENT, 6402
    },
    {
	"GL_DEPTH_FUNC", GL_DEPTH_FUNC, 2932
    },
    {
	"GL_DEPTH_RANGE", GL_DEPTH_RANGE, 2928
    },
    {
	"GL_DEPTH_SCALE", GL_DEPTH_SCALE, 3358
    },
    {
	"GL_DEPTH_TEST", GL_DEPTH_TEST, 2929
    },
    {
	"GL_DEPTH_WRITEMASK", GL_DEPTH_WRITEMASK, 2930
    },
    {
	"GL_DIFFUSE", GL_DIFFUSE, 4609
    },
    {
	"GL_DITHER", GL_DITHER, 3024
    },
    {
	"GL_DOMAIN", GL_DOMAIN, 2562
    },
    {
	"GL_DONT_CARE", GL_DONT_CARE, 4352
    },
    {
	"GL_DOUBLEBUFFER", GL_DOUBLEBUFFER, 3122
    },
    {
	"GL_DRAW_BUFFER", GL_DRAW_BUFFER, 3073
    },
    {
	"GL_DRAW_PIXEL_TOKEN", GL_DRAW_PIXEL_TOKEN, 1797
    },
    {
	"GL_DST_ALPHA", GL_DST_ALPHA, 772
    },
    {
	"GL_DST_COLOR", GL_DST_COLOR, 774
    },
    {
	"GL_EDGE_FLAG", GL_EDGE_FLAG, 2883
    },
    {
	"GL_EMISSION", GL_EMISSION, 5632
    },
    {
	"GL_ENABLE_BIT", GL_ENABLE_BIT, 8192
    },
    {
	"GL_EQUAL", GL_EQUAL, 514
    },
    {
	"GL_EQUIV", GL_EQUIV, 5385
    },
    {
	"GL_EXP", GL_EXP, 2048
    },
    {
	"GL_EXP2", GL_EXP2, 2049
    },
    {
	"GL_EXTENSIONS", GL_EXTENSIONS, 7939
    },
    {
	"GL_EVAL_BIT", GL_EVAL_BIT, 65536
    },
    {
	"GL_EYE_LINEAR", GL_EYE_LINEAR, 9216
    },
    {
	"GL_EYE_PLANE", GL_EYE_PLANE, 9474
    },
    {
	"GL_FALSE", GL_FALSE, 0
    },
    {
	"GL_FASTEST", GL_FASTEST, 4353
    },
    {
	"GL_FEEDBACK", GL_FEEDBACK, 7169
    },
    {
	"GL_FILL", GL_FILL, 6914
    },
    {
	"GL_FLAT", GL_FLAT, 7424
    },
    {
	"GL_FLOAT", GL_FLOAT, 5126
    },
    {
	"GL_FOG", GL_FOG, 2912
    },
    {
	"GL_FOG_BIT", GL_FOG_BIT, 128
    },
    {
	"GL_FOG_COLOR", GL_FOG_COLOR, 2918
    },
    {
	"GL_FOG_DENSITY", GL_FOG_DENSITY, 2914
    },
    {
	"GL_FOG_END", GL_FOG_END, 2916
    },
    {
	"GL_FOG_HINT", GL_FOG_HINT, 3156
    },
    {
	"GL_FOG_INDEX", GL_FOG_INDEX, 2913
    },
    {
	"GL_FOG_MODE", GL_FOG_MODE, 2917
    },
    {
	"GL_FOG_START", GL_FOG_START, 2915
    },
    {
	"GL_FRONT", GL_FRONT, 1028
    },
    {
	"GL_FRONT_AND_BACK", GL_FRONT_AND_BACK, 1032
    },
    {
	"GL_FRONT_FACE", GL_FRONT_FACE, 2886
    },
    {
	"GL_FRONT_LEFT", GL_FRONT_LEFT, 1024
    },
    {
	"GL_FRONT_RIGHT", GL_FRONT_RIGHT, 1025
    },
    {
	"GL_GEQUAL", GL_GEQUAL, 518
    },
    {
	"GL_GREATER", GL_GREATER, 516
    },
    {
	"GL_GREEN", GL_GREEN, 6404
    },
    {
	"GL_GREEN_BIAS", GL_GREEN_BIAS, 3353
    },
    {
	"GL_GREEN_BITS", GL_GREEN_BITS, 3411
    },
    {
	"GL_GREEN_SCALE", GL_GREEN_SCALE, 3352
    },
    {
	"GL_HINT_BIT", GL_HINT_BIT, 32768
    },
    {
	"GL_INCR", GL_INCR, 7682
    },
    {
	"GL_INDEX_BITS", GL_INDEX_BITS, 3409
    },
    {
	"GL_INDEX_CLEAR_VALUE", GL_INDEX_CLEAR_VALUE, 3104
    },
    {
	"GL_INDEX_MODE", GL_INDEX_MODE, 3120
    },
    {
	"GL_INDEX_OFFSET", GL_INDEX_OFFSET, 3347
    },
    {
	"GL_INDEX_SHIFT", GL_INDEX_SHIFT, 3346
    },
    {
	"GL_INDEX_WRITEMASK", GL_INDEX_WRITEMASK, 3105
    },
    {
	"GL_INT", GL_INT, 5124
    },
    {
	"GL_INVALID_ENUM", GL_INVALID_ENUM, 1280
    },
    {
	"GL_INVALID_OPERATION", GL_INVALID_OPERATION, 1282
    },
    {
	"GL_INVALID_VALUE", GL_INVALID_VALUE, 1281
    },
    {
	"GL_INVERT", GL_INVERT, 5386
    },
    {
	"GL_KEEP", GL_KEEP, 7680
    },
    {
	"GL_LEFT", GL_LEFT, 1030
    },
    {
	"GL_LEQUAL", GL_LEQUAL, 515
    },
    {
	"GL_LESS", GL_LESS, 513
    },
    {
	"GL_LIGHT_MODEL_AMBIENT", GL_LIGHT_MODEL_AMBIENT, 2899
    },
    {
	"GL_LIGHT_MODEL_LOCAL_VIEWER", GL_LIGHT_MODEL_LOCAL_VIEWER, 2897
    },
    {
	"GL_LIGHT_MODEL_TWO_SIDE", GL_LIGHT_MODEL_TWO_SIDE, 2898
    },
    {
	"GL_LIGHT0", GL_LIGHT0, 16384
    },
    {
	"GL_LIGHT1", GL_LIGHT1, 16385
    },
    {
	"GL_LIGHT2", GL_LIGHT2, 16386
    },
    {
	"GL_LIGHT3", GL_LIGHT3, 16387
    },
    {
	"GL_LIGHT4", GL_LIGHT4, 16388
    },
    {
	"GL_LIGHT5", GL_LIGHT5, 16389
    },
    {
	"GL_LIGHT6", GL_LIGHT6, 16390
    },
    {
	"GL_LIGHT7", GL_LIGHT7, 16391
    },
    {
	"GL_LIGHTING", GL_LIGHTING, 2896
    },
    {
	"GL_LIGHTING_BIT", GL_LIGHTING_BIT, 64
    },
    {
	"GL_LINE", GL_LINE, 6913
    },
    {
	"GL_LINE_BIT", GL_LINE_BIT, 4
    },
    {
	"GL_LINE_LOOP", GL_LINE_LOOP, 2
    },
    {
	"GL_LINE_RESET_TOKEN", GL_LINE_RESET_TOKEN, 1799
    },
    {
	"GL_LINE_SMOOTH", GL_LINE_SMOOTH, 2848
    },
    {
	"GL_LINE_SMOOTH_HINT", GL_LINE_SMOOTH_HINT, 3154
    },
    {
	"GL_LINE_STIPPLE", GL_LINE_STIPPLE, 2852
    },
    {
	"GL_LINE_STIPPLE_PATTERN", GL_LINE_STIPPLE_PATTERN, 2853
    },
    {
	"GL_LINE_STIPPLE_REPEAT", GL_LINE_STIPPLE_REPEAT, 2854
    },
    {
	"GL_LINE_STRIP", GL_LINE_STRIP, 3
    },
    {
	"GL_LINE_TOKEN", GL_LINE_TOKEN, 1794
    },
    {
	"GL_LINE_WIDTH", GL_LINE_WIDTH, 2849
    },
    {
	"GL_LINE_WIDTH_GRANULARITY", GL_LINE_WIDTH_GRANULARITY, 2851
    },
    {
	"GL_LINE_WIDTH_RANGE", GL_LINE_WIDTH_RANGE, 2850
    },
    {
	"GL_LINEAR", GL_LINEAR, 9729
    },
    {
	"GL_LINEAR_ATTENUATION", GL_LINEAR_ATTENUATION, 4616
    },
    {
	"GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST, 9985
    },
    {
	"GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR, 9987
    },
    {
	"GL_LINES", GL_LINES, 1
    },
    {
	"GL_LIST_BASE", GL_LIST_BASE, 2866
    },
    {
	"GL_LIST_BIT", GL_LIST_BIT, 131072
    },
    {
	"GL_LIST_INDEX", GL_LIST_INDEX, 2867
    },
    {
	"GL_LIST_MODE", GL_LIST_MODE, 2864
    },
    {
	"GL_LOAD", GL_LOAD, 257
    },
    {
	"GL_LOGIC_OP", GL_LOGIC_OP, 3057
    },
    {
	"GL_LOGIC_OP_MODE", GL_LOGIC_OP_MODE, 3056
    },
    {
	"GL_LUMINANCE", GL_LUMINANCE, 6409
    },
    {
	"GL_LUMINANCE_ALPHA", GL_LUMINANCE_ALPHA, 6410
    },
    {
	"GL_MAP_COLOR", GL_MAP_COLOR, 3344
    },
    {
	"GL_MAP_STENCIL", GL_MAP_STENCIL, 3345
    },
    {
	"GL_MAP1_COLOR_4", GL_MAP1_COLOR_4, 3472
    },
    {
	"GL_MAP1_GRID_DOMAIN", GL_MAP1_GRID_DOMAIN, 3536
    },
    {
	"GL_MAP1_GRID_SEGMENTS", GL_MAP1_GRID_SEGMENTS, 3537
    },
    {
	"GL_MAP1_INDEX", GL_MAP1_INDEX, 3473
    },
    {
	"GL_MAP1_NORMAL", GL_MAP1_NORMAL, 3474
    },
    {
	"GL_MAP1_TEXTURE_COORD_1", GL_MAP1_TEXTURE_COORD_1, 3475
    },
    {
	"GL_MAP1_TEXTURE_COORD_2", GL_MAP1_TEXTURE_COORD_2, 3476
    },
    {
	"GL_MAP1_TEXTURE_COORD_3", GL_MAP1_TEXTURE_COORD_3, 3477
    },
    {
	"GL_MAP1_TEXTURE_COORD_4", GL_MAP1_TEXTURE_COORD_4, 3478
    },
    {
	"GL_MAP1_VERTEX_3", GL_MAP1_VERTEX_3, 3479
    },
    {
	"GL_MAP1_VERTEX_4", GL_MAP1_VERTEX_4, 3480
    },
    {
	"GL_MAP2_COLOR_4", GL_MAP2_COLOR_4, 3504
    },
    {
	"GL_MAP2_GRID_DOMAIN", GL_MAP2_GRID_DOMAIN, 3538
    },
    {
	"GL_MAP2_GRID_SEGMENTS", GL_MAP2_GRID_SEGMENTS, 3539
    },
    {
	"GL_MAP2_INDEX", GL_MAP2_INDEX, 3505
    },
    {
	"GL_MAP2_NORMAL", GL_MAP2_NORMAL, 3506
    },
    {
	"GL_MAP2_TEXTURE_COORD_1", GL_MAP2_TEXTURE_COORD_1, 3507
    },
    {
	"GL_MAP2_TEXTURE_COORD_2", GL_MAP2_TEXTURE_COORD_2, 3508
    },
    {
	"GL_MAP2_TEXTURE_COORD_3", GL_MAP2_TEXTURE_COORD_3, 3509
    },
    {
	"GL_MAP2_TEXTURE_COORD_4", GL_MAP2_TEXTURE_COORD_4, 3510
    },
    {
	"GL_MAP2_VERTEX_3", GL_MAP2_VERTEX_3, 3511
    },
    {
	"GL_MAP2_VERTEX_4", GL_MAP2_VERTEX_4, 3512
    },
    {
	"GL_MATRIX_MODE", GL_MATRIX_MODE, 2976
    },
    {
	"GL_MAX_ATTRIB_STACK_DEPTH", GL_MAX_ATTRIB_STACK_DEPTH, 3381
    },
    {
	"GL_MAX_CLIP_PLANES", GL_MAX_CLIP_PLANES, 3378
    },
    {
	"GL_MAX_EVAL_ORDER", GL_MAX_EVAL_ORDER, 3376
    },
    {
	"GL_MAX_LIGHTS", GL_MAX_LIGHTS, 3377
    },
    {
	"GL_MAX_LIST_NESTING", GL_MAX_LIST_NESTING, 2865
    },
    {
	"GL_MAX_MODELVIEW_STACK_DEPTH", GL_MAX_MODELVIEW_STACK_DEPTH, 3382
    },
    {
	"GL_MAX_NAME_STACK_DEPTH", GL_MAX_NAME_STACK_DEPTH, 3383
    },
    {
	"GL_MAX_PIXEL_MAP_TABLE", GL_MAX_PIXEL_MAP_TABLE, 3380
    },
    {
	"GL_MAX_PROJECTION_STACK_DEPTH", GL_MAX_PROJECTION_STACK_DEPTH, 3384
    },
    {
	"GL_MAX_TEXTURE_SIZE", GL_MAX_TEXTURE_SIZE, 3379
    },
    {
	"GL_MAX_TEXTURE_STACK_DEPTH", GL_MAX_TEXTURE_STACK_DEPTH, 3385
    },
    {
	"GL_MAX_VIEWPORT_DIMS", GL_MAX_VIEWPORT_DIMS, 3386
    },
    {
	"GL_MODELVIEW", GL_MODELVIEW, 5888
    },
    {
	"GL_MODELVIEW_MATRIX", GL_MODELVIEW_MATRIX, 2982
    },
    {
	"GL_MODELVIEW_STACK_DEPTH", GL_MODELVIEW_STACK_DEPTH, 2979
    },
    {
	"GL_MODULATE", GL_MODULATE, 8448
    },
    {
	"GL_MULT", GL_MULT, 259
    },
    {
	"GL_NAME_STACK_DEPTH", GL_NAME_STACK_DEPTH, 3440
    },
    {
	"GL_NAND", GL_NAND, 5390
    },
    {
	"GL_NEAREST", GL_NEAREST, 9728
    },
    {
	"GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR, 9986
    },
    {
	"GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST, 9984
    },
    {
	"GL_NEVER", GL_NEVER, 512
    },
    {
	"GL_NICEST", GL_NICEST, 4354
    },
    {
	"GL_NO_ERROR", GL_NO_ERROR, 0
    },
    {
	"GL_NONE", GL_NONE, 0
    },
    {
	"GL_NOOP", GL_NOOP, 5381
    },
    {
	"GL_NOR", GL_NOR, 5384
    },
    {
	"GL_NORMALIZE", GL_NORMALIZE, 2977
    },
    {
	"GL_NOTEQUAL", GL_NOTEQUAL, 517
    },
    {
	"GL_OBJECT_LINEAR", GL_OBJECT_LINEAR, 9217
    },
    {
	"GL_OBJECT_PLANE", GL_OBJECT_PLANE, 9473
    },
    {
	"GL_ONE", GL_ONE, 1
    },
    {
	"GL_ONE_MINUS_DST_ALPHA", GL_ONE_MINUS_DST_ALPHA, 773
    },
    {
	"GL_ONE_MINUS_DST_COLOR", GL_ONE_MINUS_DST_COLOR, 775
    },
    {
	"GL_ONE_MINUS_SRC_ALPHA", GL_ONE_MINUS_SRC_ALPHA, 771
    },
    {
	"GL_ONE_MINUS_SRC_COLOR", GL_ONE_MINUS_SRC_COLOR, 769
    },
    {
	"GL_OR", GL_OR, 5383
    },
    {
	"GL_OR_INVERTED", GL_OR_INVERTED, 5389
    },
    {
	"GL_OR_REVERSE", GL_OR_REVERSE, 5387
    },
    {
	"GL_ORDER", GL_ORDER, 2561
    },
    {
	"GL_OUT_OF_MEMORY", GL_OUT_OF_MEMORY, 1285
    },
    {
	"GL_PACK_ALIGNMENT", GL_PACK_ALIGNMENT, 3333
    },
    {
	"GL_PACK_LSB_FIRST", GL_PACK_LSB_FIRST, 3329
    },
    {
	"GL_PACK_ROW_LENGTH", GL_PACK_ROW_LENGTH, 3330
    },
    {
	"GL_PACK_SKIP_PIXELS", GL_PACK_SKIP_PIXELS, 3332
    },
    {
	"GL_PACK_SKIP_ROWS", GL_PACK_SKIP_ROWS, 3331
    },
    {
	"GL_PACK_SWAP_BYTES", GL_PACK_SWAP_BYTES, 3328
    },
    {
	"GL_PASS_THROUGH_TOKEN", GL_PASS_THROUGH_TOKEN, 1792
    },
    {
	"GL_PERSPECTIVE_CORRECTION_HINT", GL_PERSPECTIVE_CORRECTION_HINT, 3152
    },
    {
	"GL_PIXEL_MAP_A_TO_A", GL_PIXEL_MAP_A_TO_A, 3193
    },
    {
	"GL_PIXEL_MAP_A_TO_A_SIZE", GL_PIXEL_MAP_A_TO_A_SIZE, 3257
    },
    {
	"GL_PIXEL_MAP_B_TO_B", GL_PIXEL_MAP_B_TO_B, 3192
    },
    {
	"GL_PIXEL_MAP_B_TO_B_SIZE", GL_PIXEL_MAP_B_TO_B_SIZE, 3256
    },
    {
	"GL_PIXEL_MAP_G_TO_G", GL_PIXEL_MAP_G_TO_G, 3191
    },
    {
	"GL_PIXEL_MAP_G_TO_G_SIZE", GL_PIXEL_MAP_G_TO_G_SIZE, 3255
    },
    {
	"GL_PIXEL_MAP_I_TO_A", GL_PIXEL_MAP_I_TO_A, 3189
    },
    {
	"GL_PIXEL_MAP_I_TO_A_SIZE", GL_PIXEL_MAP_I_TO_A_SIZE, 3253
    },
    {
	"GL_PIXEL_MAP_I_TO_B", GL_PIXEL_MAP_I_TO_B, 3188
    },
    {
	"GL_PIXEL_MAP_I_TO_B_SIZE", GL_PIXEL_MAP_I_TO_B_SIZE, 3252
    },
    {
	"GL_PIXEL_MAP_I_TO_G", GL_PIXEL_MAP_I_TO_G, 3187
    },
    {
	"GL_PIXEL_MAP_I_TO_G_SIZE", GL_PIXEL_MAP_I_TO_G_SIZE, 3251
    },
    {
	"GL_PIXEL_MAP_I_TO_I", GL_PIXEL_MAP_I_TO_I, 3184
    },
    {
	"GL_PIXEL_MAP_I_TO_I_SIZE", GL_PIXEL_MAP_I_TO_I_SIZE, 3248
    },
    {
	"GL_PIXEL_MAP_I_TO_R", GL_PIXEL_MAP_I_TO_R, 3186
    },
    {
	"GL_PIXEL_MAP_I_TO_R_SIZE", GL_PIXEL_MAP_I_TO_R_SIZE, 3250
    },
    {
	"GL_PIXEL_MAP_R_TO_R", GL_PIXEL_MAP_R_TO_R, 3190
    },
    {
	"GL_PIXEL_MAP_R_TO_R_SIZE", GL_PIXEL_MAP_R_TO_R_SIZE, 3254
    },
    {
	"GL_PIXEL_MAP_S_TO_S", GL_PIXEL_MAP_S_TO_S, 3185
    },
    {
	"GL_PIXEL_MAP_S_TO_S_SIZE", GL_PIXEL_MAP_S_TO_S_SIZE, 3249
    },
    {
	"GL_PIXEL_MODE_BIT", GL_PIXEL_MODE_BIT, 32
    },
    {
	"GL_POINT", GL_POINT, 6912
    },
    {
	"GL_POINT_BIT", GL_POINT_BIT, 2
    },
    {
	"GL_POINT_SIZE", GL_POINT_SIZE, 2833
    },
    {
	"GL_POINT_SIZE_GRANULARITY", GL_POINT_SIZE_GRANULARITY, 2835
    },
    {
	"GL_POINT_SIZE_RANGE", GL_POINT_SIZE_RANGE, 2834
    },
    {
	"GL_POINT_SMOOTH", GL_POINT_SMOOTH, 2832
    },
    {
	"GL_POINT_SMOOTH_HINT", GL_POINT_SMOOTH_HINT, 3153
    },
    {
	"GL_POINT_TOKEN", GL_POINT_TOKEN, 1793
    },
    {
	"GL_POINTS", GL_POINTS, 0
    },
    {
	"GL_POLYGON", GL_POLYGON, 9
    },
    {
	"GL_POLYGON_BIT", GL_POLYGON_BIT, 8
    },
    {
	"GL_POLYGON_MODE", GL_POLYGON_MODE, 2880
    },
    {
	"GL_POLYGON_SMOOTH", GL_POLYGON_SMOOTH, 2881
    },
    {
	"GL_POLYGON_SMOOTH_HINT", GL_POLYGON_SMOOTH_HINT, 3155
    },
    {
	"GL_POLYGON_STIPPLE", GL_POLYGON_STIPPLE, 2882
    },
    {
	"GL_POLYGON_STIPPLE_BIT", GL_POLYGON_STIPPLE_BIT, 16
    },
    {
	"GL_POLYGON_TOKEN", GL_POLYGON_TOKEN, 1795
    },
    {
	"GL_POSITION", GL_POSITION, 4611
    },
    {
	"GL_PROJECTION", GL_PROJECTION, 5889
    },
    {
	"GL_PROJECTION_MATRIX", GL_PROJECTION_MATRIX, 2983
    },
    {
	"GL_PROJECTION_STACK_DEPTH", GL_PROJECTION_STACK_DEPTH, 2980
    },
    {
	"GL_Q", GL_Q, 8195
    },
    {
	"GL_QUAD_STRIP", GL_QUAD_STRIP, 8
    },
    {
	"GL_QUADRATIC_ATTENUATION", GL_QUADRATIC_ATTENUATION, 4617
    },
    {
	"GL_QUADS", GL_QUADS, 7
    },
    {
	"GL_R", GL_R, 8194
    },
    {
	"GL_READ_BUFFER", GL_READ_BUFFER, 3074
    },
    {
	"GL_RED", GL_RED, 6403
    },
    {
	"GL_RED_BIAS", GL_RED_BIAS, 3349
    },
    {
	"GL_RED_BITS", GL_RED_BITS, 3410
    },
    {
	"GL_RED_SCALE", GL_RED_SCALE, 3348
    },
    {
	"GL_RENDER", GL_RENDER, 7168
    },
    {
	"GL_RENDER_MODE", GL_RENDER_MODE, 3136
    },
    {
	"GL_RENDERER", GL_RENDERER, 7937
    },
    {
	"GL_REPEAT", GL_REPEAT, 10497
    },
    {
	"GL_REPLACE", GL_REPLACE, 7681
    },
    {
	"GL_RETURN", GL_RETURN, 258
    },
    {
	"GL_RGB", GL_RGB, 6407
    },
    {
	"GL_RGBA", GL_RGBA, 6408
    },
    {
	"GL_RGBA_MODE", GL_RGBA_MODE, 3121
    },
    {
	"GL_RIGHT", GL_RIGHT, 1031
    },
    {
	"GL_S", GL_S, 8192
    },
    {
	"GL_SHININESS", GL_SHININESS, 5633
    },
    {
	"GL_SPECULAR", GL_SPECULAR, 4610
    },
    {
	"GL_SRC_ALPHA", GL_SRC_ALPHA, 770
    },
    {
	"GL_SRC_ALPHA_SATURATE", GL_SRC_ALPHA_SATURATE, 776
    },
    {
	"GL_SRC_COLOR", GL_SRC_COLOR, 768
    },
    {
	"GL_SCISSOR_BIT", GL_SCISSOR_BIT, 524288
    },
    {
	"GL_SCISSOR_BOX", GL_SCISSOR_BOX, 3088
    },
    {
	"GL_SCISSOR_TEST", GL_SCISSOR_TEST, 3089
    },
    {
	"GL_SELECT", GL_SELECT, 7170
    },
    {
	"GL_SET", GL_SET, 5391
    },
    {
	"GL_SHADE_MODEL", GL_SHADE_MODEL, 2900
    },
    {
	"GL_SHORT", GL_SHORT, 5122
    },
    {
	"GL_SMOOTH", GL_SMOOTH, 7425
    },
    {
	"GL_SPHERE_MAP", GL_SPHERE_MAP, 9218
    },
    {
	"GL_SPOT_CUTOFF", GL_SPOT_CUTOFF, 4614
    },
    {
	"GL_SPOT_DIRECTION", GL_SPOT_DIRECTION, 4612
    },
    {
	"GL_SPOT_EXPONENT", GL_SPOT_EXPONENT, 4613
    },
    {
	"GL_STACK_OVERFLOW", GL_STACK_OVERFLOW, 1283
    },
    {
	"GL_STACK_UNDERFLOW", GL_STACK_UNDERFLOW, 1284
    },
    {
	"GL_STENCIL", GL_STENCIL, 6146
    },
    {
	"GL_STENCIL_BITS", GL_STENCIL_BITS, 3415
    },
    {
	"GL_STENCIL_BUFFER_BIT", GL_STENCIL_BUFFER_BIT, 1024
    },
    {
	"GL_STENCIL_CLEAR_VALUE", GL_STENCIL_CLEAR_VALUE, 2961
    },
    {
	"GL_STENCIL_FAIL", GL_STENCIL_FAIL, 2964
    },
    {
	"GL_STENCIL_FUNC", GL_STENCIL_FUNC, 2962
    },
    {
	"GL_STENCIL_INDEX", GL_STENCIL_INDEX, 6401
    },
    {
	"GL_STENCIL_PASS_DEPTH_FAIL", GL_STENCIL_PASS_DEPTH_FAIL, 2965
    },
    {
	"GL_STENCIL_PASS_DEPTH_PASS", GL_STENCIL_PASS_DEPTH_PASS, 2966
    },
    {
	"GL_STENCIL_REF", GL_STENCIL_REF, 2967
    },
    {
	"GL_STENCIL_TEST", GL_STENCIL_TEST, 2960
    },
    {
	"GL_STENCIL_VALUE_MASK", GL_STENCIL_VALUE_MASK, 2963
    },
    {
	"GL_STENCIL_WRITEMASK", GL_STENCIL_WRITEMASK, 2968
    },
    {
	"GL_STEREO", GL_STEREO, 3123
    },
    {
	"GL_SUBPIXEL_BITS", GL_SUBPIXEL_BITS, 3408
    },
    {
	"GL_T", GL_T, 8193
    },
    {
	"GL_TEXTURE", GL_TEXTURE, 5890
    },
    {
	"GL_TEXTURE_1D", GL_TEXTURE_1D, 3552
    },
    {
	"GL_TEXTURE_2D", GL_TEXTURE_2D, 3553
    },
    {
	"GL_TEXTURE_BIT", GL_TEXTURE_BIT, 262144
    },
    {
	"GL_TEXTURE_BORDER", GL_TEXTURE_BORDER, 4101
    },
    {
	"GL_TEXTURE_BORDER_COLOR", GL_TEXTURE_BORDER_COLOR, 4100
    },
    {
	"GL_TEXTURE_COMPONENTS", GL_TEXTURE_COMPONENTS, 4099
    },
    {
	"GL_TEXTURE_ENV", GL_TEXTURE_ENV, 8960
    },
    {
	"GL_TEXTURE_ENV_COLOR", GL_TEXTURE_ENV_COLOR, 8705
    },
    {
	"GL_TEXTURE_ENV_MODE", GL_TEXTURE_ENV_MODE, 8704
    },
    {
	"GL_TEXTURE_GEN_MODE", GL_TEXTURE_GEN_MODE, 9472
    },
    {
	"GL_TEXTURE_GEN_Q", GL_TEXTURE_GEN_Q, 3171
    },
    {
	"GL_TEXTURE_GEN_R", GL_TEXTURE_GEN_R, 3170
    },
    {
	"GL_TEXTURE_GEN_S", GL_TEXTURE_GEN_S, 3168
    },
    {
	"GL_TEXTURE_GEN_T", GL_TEXTURE_GEN_T, 3169
    },
    {
	"GL_TEXTURE_HEIGHT", GL_TEXTURE_HEIGHT, 4097
    },
    {
	"GL_TEXTURE_MAG_FILTER", GL_TEXTURE_MAG_FILTER, 10240
    },
    {
	"GL_TEXTURE_MATRIX", GL_TEXTURE_MATRIX, 2984
    },
    {
	"GL_TEXTURE_MIN_FILTER", GL_TEXTURE_MIN_FILTER, 10241
    },
    {
	"GL_TEXTURE_STACK_DEPTH", GL_TEXTURE_STACK_DEPTH, 2981
    },
    {
	"GL_TEXTURE_WIDTH", GL_TEXTURE_WIDTH, 4096
    },
    {
	"GL_TEXTURE_WRAP_S", GL_TEXTURE_WRAP_S, 10242
    },
    {
	"GL_TEXTURE_WRAP_T", GL_TEXTURE_WRAP_T, 10243
    },
    {
	"GL_TRANSFORM_BIT", GL_TRANSFORM_BIT, 4096
    },
    {
	"GL_TRIANGLES", GL_TRIANGLES, 4
    },
    {
	"GL_TRIANGLE_FAN", GL_TRIANGLE_FAN, 6
    },
    {
	"GL_TRIANGLE_STRIP", GL_TRIANGLE_STRIP, 5
    },
    {
	"GL_TRUE", GL_TRUE, 1
    },
    {
	"GL_UNPACK_ALIGNMENT", GL_UNPACK_ALIGNMENT, 3317
    },
    {
	"GL_UNPACK_LSB_FIRST", GL_UNPACK_LSB_FIRST, 3313
    },
    {
	"GL_UNPACK_ROW_LENGTH", GL_UNPACK_ROW_LENGTH, 3314
    },
    {
	"GL_UNPACK_SKIP_PIXELS", GL_UNPACK_SKIP_PIXELS, 3316
    },
    {
	"GL_UNPACK_SKIP_ROWS", GL_UNPACK_SKIP_ROWS, 3315
    },
    {
	"GL_UNPACK_SWAP_BYTES", GL_UNPACK_SWAP_BYTES, 3312
    },
    {
	"GL_UNSIGNED_BYTE", GL_UNSIGNED_BYTE, 5121
    },
    {
	"GL_UNSIGNED_INT", GL_UNSIGNED_INT, 5125
    },
    {
	"GL_UNSIGNED_SHORT", GL_UNSIGNED_SHORT, 5123
    },
    {
	"GL_VENDOR", GL_VENDOR, 7936
    },
    {
	"GL_VIEWPORT", GL_VIEWPORT, 2978
    },
    {
	"GL_VIEWPORT_BIT", GL_VIEWPORT_BIT, 2048
    },
    {
	"GL_XOR", GL_XOR, 5382
    },
    {
	"GL_ZERO", GL_ZERO, 0
    },
    {
	"GL_ZOOM_X", GL_ZOOM_X, 3350
    },
    {
	"GL_ZOOM_Y", GL_ZOOM_Y, 3351
    },
    {
	"GL_VERSION", GL_VERSION, 7938
    },
    {
	"End of List", -1, -1
    }
};

enumTestRec enum_AccumOp[] = {
    "GL_ACCUM", GL_ACCUM,
    "GL_LOAD", GL_LOAD,
    "GL_RETURN", GL_RETURN,
    "GL_MULT", GL_MULT,
    "GL_ADD", GL_ADD,
    "End of List", -1
};

enumTestRec enum_AlphaFunction[] = {
    "GL_NEVER", GL_NEVER,
    "GL_LESS", GL_LESS,
    "GL_EQUAL", GL_EQUAL,
    "GL_LEQUAL", GL_LEQUAL,
    "GL_GREATER", GL_GREATER,
    "GL_NOTEQUAL", GL_NOTEQUAL,
    "GL_GEQUAL", GL_GEQUAL,
    "GL_ALWAYS", GL_ALWAYS,
    "End of List", -1
};

enumTestRec enum_AttribMask[] = {
    "GL_CURRENT_BIT", GL_CURRENT_BIT,
    "GL_POINT_BIT", GL_POINT_BIT,
    "GL_LINE_BIT", GL_LINE_BIT,
    "GL_POLYGON_BIT", GL_POLYGON_BIT,
    "GL_POLYGON_STIPPLE_BIT", GL_POLYGON_STIPPLE_BIT,
    "GL_PIXEL_MODE_BIT", GL_PIXEL_MODE_BIT,
    "GL_LIGHTING_BIT", GL_LIGHTING_BIT,
    "GL_FOG_BIT", GL_FOG_BIT,
    "GL_DEPTH_BUFFER_BIT", GL_DEPTH_BUFFER_BIT,
    "GL_ACCUM_BUFFER_BIT", GL_ACCUM_BUFFER_BIT,
    "GL_STENCIL_BUFFER_BIT", GL_STENCIL_BUFFER_BIT,
    "GL_VIEWPORT_BIT", GL_VIEWPORT_BIT,
    "GL_TRANSFORM_BIT", GL_TRANSFORM_BIT,
    "GL_ENABLE_BIT", GL_ENABLE_BIT,
    "GL_COLOR_BUFFER_BIT", GL_COLOR_BUFFER_BIT,
    "GL_HINT_BIT", GL_HINT_BIT,
    "GL_EVAL_BIT", GL_EVAL_BIT,
    "GL_LIST_BIT", GL_LIST_BIT,
    "GL_TEXTURE_BIT", GL_TEXTURE_BIT,
    "GL_SCISSOR_BIT", GL_SCISSOR_BIT,
    "GL_ALL_ATTRIB_BITS", GL_ALL_ATTRIB_BITS,
    "End of List", -1
};

enumTestRec enum_BlendingFactorDest[] = {
    "GL_ZERO", GL_ZERO,
    "GL_ONE", GL_ONE,
    "GL_SRC_COLOR", GL_SRC_COLOR,
    "GL_ONE_MINUS_SRC_COLOR", GL_ONE_MINUS_SRC_COLOR,
    "GL_SRC_ALPHA", GL_SRC_ALPHA,
    "GL_ONE_MINUS_SRC_ALPHA", GL_ONE_MINUS_SRC_ALPHA,
    "GL_DST_ALPHA", GL_DST_ALPHA,
    "GL_ONE_MINUS_DST_ALPHA", GL_ONE_MINUS_DST_ALPHA,
    "End of List", -1
};

enumTestRec enum_BlendingFactorSrc[] = {
    "GL_ZERO", GL_ZERO,
    "GL_ONE", GL_ONE,
    "GL_DST_COLOR", GL_DST_COLOR,
    "GL_ONE_MINUS_DST_COLOR", GL_ONE_MINUS_DST_COLOR,
    "GL_SRC_ALPHA_SATURATE", GL_SRC_ALPHA_SATURATE,
    "GL_SRC_ALPHA", GL_SRC_ALPHA,
    "GL_ONE_MINUS_SRC_ALPHA", GL_ONE_MINUS_SRC_ALPHA,
    "GL_DST_ALPHA", GL_DST_ALPHA,
    "GL_ONE_MINUS_DST_ALPHA", GL_ONE_MINUS_DST_ALPHA,
    "End of List", -1
};

enumTestRec enum_Boolean[] = {
    "GL_TRUE", GL_TRUE,
    "GL_FALSE", GL_FALSE,
    "End of List", -1
};

enumTestRec enum_Enable[] = {
    "GL_FOG", GL_FOG,
    "GL_LIGHTING", GL_LIGHTING,
    "GL_TEXTURE_1D", GL_TEXTURE_1D,
    "GL_TEXTURE_2D", GL_TEXTURE_2D,
    "GL_LINE_STIPPLE", GL_LINE_STIPPLE,
    "GL_POLYGON_STIPPLE", GL_POLYGON_STIPPLE,
    "GL_CULL_FACE", GL_CULL_FACE,
    "GL_ALPHA_TEST", GL_ALPHA_TEST,
    "GL_BLEND", GL_BLEND,
    "GL_LOGIC_OP", GL_LOGIC_OP,
    "GL_DITHER", GL_DITHER,
    "GL_STENCIL_TEST", GL_STENCIL_TEST,
    "GL_DEPTH_TEST", GL_DEPTH_TEST,
    "GL_CLIP_PLANE0", GL_CLIP_PLANE0,
    "GL_CLIP_PLANE1", GL_CLIP_PLANE1,
    "GL_CLIP_PLANE2", GL_CLIP_PLANE2,
    "GL_CLIP_PLANE3", GL_CLIP_PLANE3,
    "GL_CLIP_PLANE4", GL_CLIP_PLANE4,
    "GL_CLIP_PLANE5", GL_CLIP_PLANE5,
    "GL_LIGHT0", GL_LIGHT0,
    "GL_LIGHT1", GL_LIGHT1,
    "GL_LIGHT2", GL_LIGHT2,
    "GL_LIGHT3", GL_LIGHT3,
    "GL_LIGHT4", GL_LIGHT4,
    "GL_LIGHT5", GL_LIGHT5,
    "GL_LIGHT6", GL_LIGHT6,
    "GL_LIGHT7", GL_LIGHT7,
    "GL_TEXTURE_GEN_S", GL_TEXTURE_GEN_S,
    "GL_TEXTURE_GEN_T", GL_TEXTURE_GEN_T,
    "GL_TEXTURE_GEN_R", GL_TEXTURE_GEN_R,
    "GL_TEXTURE_GEN_Q", GL_TEXTURE_GEN_Q,
    "GL_MAP1_VERTEX_3", GL_MAP1_VERTEX_3,
    "GL_MAP1_VERTEX_4", GL_MAP1_VERTEX_4,
    "GL_MAP1_COLOR_4", GL_MAP1_COLOR_4,
    "GL_MAP1_INDEX", GL_MAP1_INDEX,
    "GL_MAP1_NORMAL", GL_MAP1_NORMAL,
    "GL_MAP1_TEXTURE_COORD_1", GL_MAP1_TEXTURE_COORD_1,
    "GL_MAP1_TEXTURE_COORD_2", GL_MAP1_TEXTURE_COORD_2,
    "GL_MAP1_TEXTURE_COORD_3", GL_MAP1_TEXTURE_COORD_3,
    "GL_MAP1_TEXTURE_COORD_4", GL_MAP1_TEXTURE_COORD_4,
    "GL_MAP2_VERTEX_3", GL_MAP2_VERTEX_3,
    "GL_MAP2_VERTEX_4", GL_MAP2_VERTEX_4,
    "GL_MAP2_COLOR_4", GL_MAP2_COLOR_4,
    "GL_MAP2_INDEX", GL_MAP2_INDEX,
    "GL_MAP2_NORMAL", GL_MAP2_NORMAL,
    "GL_MAP2_TEXTURE_COORD_1", GL_MAP2_TEXTURE_COORD_1,
    "GL_MAP2_TEXTURE_COORD_2", GL_MAP2_TEXTURE_COORD_2,
    "GL_MAP2_TEXTURE_COORD_3", GL_MAP2_TEXTURE_COORD_3,
    "GL_MAP2_TEXTURE_COORD_4", GL_MAP2_TEXTURE_COORD_4,
    "GL_POINT_SMOOTH", GL_POINT_SMOOTH,
    "GL_LINE_SMOOTH", GL_LINE_SMOOTH,
    "GL_POLYGON_SMOOTH", GL_POLYGON_SMOOTH,
    "GL_SCISSOR_TEST", GL_SCISSOR_TEST,
    "GL_COLOR_MATERIAL", GL_COLOR_MATERIAL,
    "GL_NORMALIZE", GL_NORMALIZE,
    "GL_AUTO_NORMAL", GL_AUTO_NORMAL,
    "End of List", -1
};

enumTestRec enum_ClearBufferMask[] = {
    "GL_COLOR_BUFFER_BIT", GL_COLOR_BUFFER_BIT,
    "GL_ACCUM_BUFFER_BIT", GL_ACCUM_BUFFER_BIT,
    "GL_STENCIL_BUFFER_BIT", GL_STENCIL_BUFFER_BIT,
    "GL_DEPTH_BUFFER_BIT", GL_DEPTH_BUFFER_BIT,
    "End of List", -1
};

enumTestRec enum_ClipPlaneName[] = {
    "GL_CLIP_PLANE0", GL_CLIP_PLANE0,
    "GL_CLIP_PLANE1", GL_CLIP_PLANE1,
    "GL_CLIP_PLANE2", GL_CLIP_PLANE2,
    "GL_CLIP_PLANE3", GL_CLIP_PLANE3,
    "GL_CLIP_PLANE4", GL_CLIP_PLANE4,
    "GL_CLIP_PLANE5", GL_CLIP_PLANE5,
    "End of List", -1
};

enumTestRec enum_ColorMaterialFace[] = {
    "GL_FRONT", GL_FRONT,
    "GL_BACK", GL_BACK,
    "GL_FRONT_AND_BACK", GL_FRONT_AND_BACK,
    "End of List", -1
};

enumTestRec enum_ColorMaterialParameter[] = {
    "GL_AMBIENT", GL_AMBIENT,
    "GL_DIFFUSE", GL_DIFFUSE,
    "GL_SPECULAR", GL_SPECULAR,
    "GL_EMISSION", GL_EMISSION,
    "GL_AMBIENT_AND_DIFFUSE", GL_AMBIENT_AND_DIFFUSE,
    "End of List", -1
};

enumTestRec enum_CullFaceMode[] = {
    "GL_FRONT", GL_FRONT,
    "GL_BACK", GL_BACK,
    "End of List", -1
};

enumTestRec enum_DepthFunction[] = {
    "GL_NEVER", GL_NEVER,
    "GL_LESS", GL_LESS,
    "GL_EQUAL", GL_EQUAL,
    "GL_LEQUAL", GL_LEQUAL,
    "GL_GREATER", GL_GREATER,
    "GL_NOTEQUAL", GL_NOTEQUAL,
    "GL_GEQUAL", GL_GEQUAL,
    "GL_ALWAYS", GL_ALWAYS,
    "End of List", -1
};

enumTestRec enum_DrawBufferMode[] = {
    "GL_NONE", GL_NONE,
    "GL_FRONT_LEFT", GL_FRONT_LEFT,
    "GL_FRONT_RIGHT", GL_FRONT_RIGHT,
    "GL_BACK_LEFT", GL_BACK_LEFT,
    "GL_BACK_RIGHT", GL_BACK_RIGHT,
    "GL_BACK", GL_BACK,
    "GL_LEFT", GL_LEFT,
    "GL_RIGHT", GL_RIGHT,
    "GL_FRONT_AND_BACK", GL_FRONT_AND_BACK,
    "GL_AUX0", GL_AUX0,
    "GL_AUX1", GL_AUX1,
    "GL_AUX2", GL_AUX2,
    "GL_AUX3", GL_AUX3,
    "GL_FRONT", GL_FRONT,
    "End of List", -1
};

enumTestRec enum_ErrorCode[] = {
    "GL_NO_ERROR", GL_NO_ERROR,
    "GL_INVALID_ENUM", GL_INVALID_ENUM,
    "GL_INVALID_VALUE", GL_INVALID_VALUE,
    "GL_INVALID_OPERATION", GL_INVALID_OPERATION,
    "GL_STACK_OVERFLOW", GL_STACK_OVERFLOW,
    "GL_STACK_UNDERFLOW", GL_STACK_UNDERFLOW,
    "GL_OUT_OF_MEMORY", GL_OUT_OF_MEMORY,
    "End of List", -1
};

enumTestRec enum_FeedBackMode[] = {
    "GL_2D", GL_2D,
    "GL_3D", GL_3D,
    "GL_3D_COLOR", GL_3D_COLOR,
    "GL_3D_COLOR_TEXTURE", GL_3D_COLOR_TEXTURE,
    "GL_4D_COLOR_TEXTURE", GL_4D_COLOR_TEXTURE,
    "End of List", -1
};

enumTestRec enum_FogMode[] = {
    "GL_LINEAR", GL_LINEAR,
    "GL_EXP", GL_EXP,
    "GL_EXP2", GL_EXP2,
    "End of List", -1
};

enumTestRec enum_FogParameter[] = {
    "GL_FOG_COLOR", GL_FOG_COLOR,
    "GL_FOG_DENSITY", GL_FOG_DENSITY,
    "GL_FOG_END", GL_FOG_END,
    "GL_FOG_INDEX", GL_FOG_INDEX,
    "GL_FOG_MODE", GL_FOG_MODE,
    "GL_FOG_START", GL_FOG_START,
    "End of List", -1
};

enumTestRec enum_FrontFaceDirection[] = {
    "GL_CW", GL_CW,
    "GL_CCW", GL_CCW,
    "End of List", -1
};

enumTestRec enum_GetPixelMap[] = {
    "GL_PIXEL_MAP_I_TO_I", GL_PIXEL_MAP_I_TO_I,
    "GL_PIXEL_MAP_S_TO_S", GL_PIXEL_MAP_S_TO_S,
    "GL_PIXEL_MAP_I_TO_R", GL_PIXEL_MAP_I_TO_R,
    "GL_PIXEL_MAP_I_TO_G", GL_PIXEL_MAP_I_TO_G,
    "GL_PIXEL_MAP_I_TO_B", GL_PIXEL_MAP_I_TO_B,
    "GL_PIXEL_MAP_I_TO_A", GL_PIXEL_MAP_I_TO_A,
    "GL_PIXEL_MAP_R_TO_R", GL_PIXEL_MAP_R_TO_R,
    "GL_PIXEL_MAP_G_TO_G", GL_PIXEL_MAP_G_TO_G,
    "GL_PIXEL_MAP_B_TO_B", GL_PIXEL_MAP_B_TO_B,
    "GL_PIXEL_MAP_A_TO_A", GL_PIXEL_MAP_A_TO_A,
    "End of List", -1
};

enumTestRec enum_GetTarget[] = {
    "GL_NAME_STACK_DEPTH", GL_NAME_STACK_DEPTH,
    "GL_MAX_TEXTURE_SIZE", GL_MAX_TEXTURE_SIZE,
    "GL_MAP1_COLOR_4", GL_MAP1_COLOR_4,
    "GL_MAP1_INDEX", GL_MAP1_INDEX,
    "GL_MAP1_NORMAL", GL_MAP1_NORMAL,
    "GL_MAP1_TEXTURE_COORD_1", GL_MAP1_TEXTURE_COORD_1,
    "GL_MAP1_TEXTURE_COORD_2", GL_MAP1_TEXTURE_COORD_2,
    "GL_MAP1_TEXTURE_COORD_3", GL_MAP1_TEXTURE_COORD_3,
    "GL_MAP1_TEXTURE_COORD_4", GL_MAP1_TEXTURE_COORD_4,
    "GL_MAP1_VERTEX_3", GL_MAP1_VERTEX_3,
    "GL_MAP1_VERTEX_4", GL_MAP1_VERTEX_4,
    "GL_MAP2_COLOR_4", GL_MAP2_COLOR_4,
    "GL_MAP2_INDEX", GL_MAP2_INDEX,
    "GL_MAP2_NORMAL", GL_MAP2_NORMAL,
    "GL_MAP2_TEXTURE_COORD_1", GL_MAP2_TEXTURE_COORD_1,
    "GL_MAP2_TEXTURE_COORD_2", GL_MAP2_TEXTURE_COORD_2,
    "GL_MAP2_TEXTURE_COORD_3", GL_MAP2_TEXTURE_COORD_3,
    "GL_MAP2_TEXTURE_COORD_4", GL_MAP2_TEXTURE_COORD_4,
    "GL_MAP2_VERTEX_3", GL_MAP2_VERTEX_3,
    "GL_MAP2_VERTEX_4", GL_MAP2_VERTEX_4,
    "GL_AUTO_NORMAL", GL_AUTO_NORMAL,
    "GL_EDGE_FLAG", GL_EDGE_FLAG,
    "GL_SUBPIXEL_BITS", GL_SUBPIXEL_BITS,
    "GL_CURRENT_COLOR", GL_CURRENT_COLOR,
    "GL_CURRENT_INDEX", GL_CURRENT_INDEX,
    "GL_CURRENT_NORMAL", GL_CURRENT_NORMAL,
    "GL_CURRENT_TEXTURE_COORDS", GL_CURRENT_TEXTURE_COORDS,
    "GL_CURRENT_RASTER_INDEX", GL_CURRENT_RASTER_INDEX,
    "GL_CURRENT_RASTER_COLOR", GL_CURRENT_RASTER_COLOR,
    "GL_CURRENT_RASTER_TEXTURE_COORDS", GL_CURRENT_RASTER_TEXTURE_COORDS,
    "GL_CURRENT_RASTER_POSITION", GL_CURRENT_RASTER_POSITION,
    "GL_CURRENT_RASTER_POSITION_VALID", GL_CURRENT_RASTER_POSITION_VALID,
    "GL_POINT_SIZE", GL_POINT_SIZE,
    "GL_POINT_SIZE_RANGE", GL_POINT_SIZE_RANGE,
    "GL_POINT_SIZE_GRANULARITY", GL_POINT_SIZE_GRANULARITY,
    "GL_POINT_SMOOTH", GL_POINT_SMOOTH,
    "GL_LINE_SMOOTH", GL_LINE_SMOOTH,
    "GL_LINE_WIDTH", GL_LINE_WIDTH,
    "GL_LINE_WIDTH_RANGE", GL_LINE_WIDTH_RANGE,
    "GL_LINE_WIDTH_GRANULARITY", GL_LINE_WIDTH_GRANULARITY,
    "GL_LINE_STIPPLE_PATTERN", GL_LINE_STIPPLE_PATTERN,
    "GL_LINE_STIPPLE_REPEAT", GL_LINE_STIPPLE_REPEAT,
    "GL_LINE_STIPPLE", GL_LINE_STIPPLE,
    "GL_POLYGON_MODE", GL_POLYGON_MODE,
    "GL_POLYGON_SMOOTH", GL_POLYGON_SMOOTH,
    "GL_POLYGON_STIPPLE", GL_POLYGON_STIPPLE,
    "GL_CULL_FACE", GL_CULL_FACE,
    "GL_CULL_FACE_MODE", GL_CULL_FACE_MODE,
    "GL_FRONT_FACE", GL_FRONT_FACE,
    "GL_LIGHTING", GL_LIGHTING,
    "GL_LIGHT_MODEL_LOCAL_VIEWER", GL_LIGHT_MODEL_LOCAL_VIEWER,
    "GL_LIGHT_MODEL_TWO_SIDE", GL_LIGHT_MODEL_TWO_SIDE,
    "GL_LIGHT_MODEL_AMBIENT", GL_LIGHT_MODEL_AMBIENT,
    "GL_COLOR_MATERIAL", GL_COLOR_MATERIAL,
    "GL_COLOR_MATERIAL_FACE", GL_COLOR_MATERIAL_FACE,
    "GL_COLOR_MATERIAL_PARAMETER", GL_COLOR_MATERIAL_PARAMETER,
    "GL_SHADE_MODEL", GL_SHADE_MODEL,
    "GL_FOG", GL_FOG,
    "GL_FOG_INDEX", GL_FOG_INDEX,
    "GL_FOG_DENSITY", GL_FOG_DENSITY,
    "GL_FOG_START", GL_FOG_START,
    "GL_FOG_END", GL_FOG_END,
    "GL_FOG_MODE", GL_FOG_MODE,
    "GL_FOG_COLOR", GL_FOG_COLOR,
    "GL_DEPTH_RANGE", GL_DEPTH_RANGE,
    "GL_DEPTH_TEST", GL_DEPTH_TEST,
    "GL_DEPTH_WRITEMASK", GL_DEPTH_WRITEMASK,
    "GL_DEPTH_CLEAR_VALUE", GL_DEPTH_CLEAR_VALUE,
    "GL_DEPTH_FUNC", GL_DEPTH_FUNC,
    "GL_ACCUM_CLEAR_VALUE", GL_ACCUM_CLEAR_VALUE,
    "GL_STENCIL_TEST", GL_STENCIL_TEST,
    "GL_STENCIL_CLEAR_VALUE", GL_STENCIL_CLEAR_VALUE,
    "GL_STENCIL_FUNC", GL_STENCIL_FUNC,
    "GL_STENCIL_VALUE_MASK", GL_STENCIL_VALUE_MASK,
    "GL_STENCIL_FAIL", GL_STENCIL_FAIL,
    "GL_STENCIL_PASS_DEPTH_FAIL", GL_STENCIL_PASS_DEPTH_FAIL,
    "GL_STENCIL_PASS_DEPTH_PASS", GL_STENCIL_PASS_DEPTH_PASS,
    "GL_STENCIL_REF", GL_STENCIL_REF,
    "GL_STENCIL_WRITEMASK", GL_STENCIL_WRITEMASK,
    "GL_MATRIX_MODE", GL_MATRIX_MODE,
    "GL_NORMALIZE", GL_NORMALIZE,
    "GL_VIEWPORT", GL_VIEWPORT,
    "GL_ATTRIB_STACK_DEPTH", GL_ATTRIB_STACK_DEPTH,
    "GL_MODELVIEW_STACK_DEPTH", GL_MODELVIEW_STACK_DEPTH,
    "GL_PROJECTION_STACK_DEPTH", GL_PROJECTION_STACK_DEPTH,
    "GL_TEXTURE_STACK_DEPTH", GL_TEXTURE_STACK_DEPTH,
    "GL_MODELVIEW_MATRIX", GL_MODELVIEW_MATRIX,
    "GL_PROJECTION_MATRIX", GL_PROJECTION_MATRIX,
    "GL_TEXTURE_MATRIX", GL_TEXTURE_MATRIX,
    "GL_ALPHA_TEST", GL_ALPHA_TEST,
    "GL_ALPHA_TEST_FUNC", GL_ALPHA_TEST_FUNC,
    "GL_ALPHA_TEST_REF", GL_ALPHA_TEST_REF,
    "GL_DITHER", GL_DITHER,
    "GL_BLEND_DST", GL_BLEND_DST,
    "GL_BLEND_SRC", GL_BLEND_SRC,
    "GL_BLEND", GL_BLEND,
    "GL_LOGIC_OP_MODE", GL_LOGIC_OP_MODE,
    "GL_LOGIC_OP", GL_LOGIC_OP,
    "GL_DRAW_BUFFER", GL_DRAW_BUFFER,
    "GL_READ_BUFFER", GL_READ_BUFFER,
    "GL_SCISSOR_TEST", GL_SCISSOR_TEST,
    "GL_SCISSOR_BOX", GL_SCISSOR_BOX,
    "GL_INDEX_CLEAR_VALUE", GL_INDEX_CLEAR_VALUE,
    "GL_INDEX_MODE", GL_INDEX_MODE,
    "GL_INDEX_WRITEMASK", GL_INDEX_WRITEMASK,
    "GL_COLOR_CLEAR_VALUE", GL_COLOR_CLEAR_VALUE,
    "GL_RGBA_MODE", GL_RGBA_MODE,
    "GL_COLOR_WRITEMASK", GL_COLOR_WRITEMASK,
    "GL_RENDER_MODE", GL_RENDER_MODE,
    "GL_PERSPECTIVE_CORRECTION_HINT", GL_PERSPECTIVE_CORRECTION_HINT,
    "GL_POINT_SMOOTH_HINT", GL_POINT_SMOOTH_HINT,
    "GL_LINE_SMOOTH_HINT", GL_LINE_SMOOTH_HINT,
    "GL_POLYGON_SMOOTH_HINT", GL_POLYGON_SMOOTH_HINT,
    "GL_FOG_HINT", GL_FOG_HINT,
    "GL_LIST_BASE", GL_LIST_BASE,
    "GL_LIST_INDEX", GL_LIST_INDEX,
    "GL_LIST_MODE", GL_LIST_MODE,
    "GL_MAX_LIST_NESTING", GL_MAX_LIST_NESTING,
    "GL_TEXTURE_GEN_S", GL_TEXTURE_GEN_S,
    "GL_TEXTURE_GEN_T", GL_TEXTURE_GEN_T,
    "GL_TEXTURE_GEN_R", GL_TEXTURE_GEN_R,
    "GL_TEXTURE_GEN_Q", GL_TEXTURE_GEN_Q,
    "GL_PACK_SWAP_BYTES", GL_PACK_SWAP_BYTES,
    "GL_PACK_LSB_FIRST", GL_PACK_LSB_FIRST,
    "GL_PACK_ROW_LENGTH", GL_PACK_ROW_LENGTH,
    "GL_PACK_SKIP_ROWS", GL_PACK_SKIP_ROWS,
    "GL_PACK_SKIP_PIXELS", GL_PACK_SKIP_PIXELS,
    "GL_PACK_ALIGNMENT", GL_PACK_ALIGNMENT,
    "GL_UNPACK_SWAP_BYTES", GL_UNPACK_SWAP_BYTES,
    "GL_UNPACK_LSB_FIRST", GL_UNPACK_LSB_FIRST,
    "GL_UNPACK_ROW_LENGTH", GL_UNPACK_ROW_LENGTH,
    "GL_UNPACK_SKIP_ROWS", GL_UNPACK_SKIP_ROWS,
    "GL_UNPACK_SKIP_PIXELS", GL_UNPACK_SKIP_PIXELS,
    "GL_UNPACK_ALIGNMENT", GL_UNPACK_ALIGNMENT,
    "GL_MAP_COLOR", GL_MAP_COLOR,
    "GL_MAP_STENCIL", GL_MAP_STENCIL,
    "GL_INDEX_SHIFT", GL_INDEX_SHIFT,
    "GL_INDEX_OFFSET", GL_INDEX_OFFSET,
    "GL_RED_SCALE", GL_RED_SCALE,
    "GL_GREEN_SCALE", GL_GREEN_SCALE,
    "GL_BLUE_SCALE", GL_BLUE_SCALE,
    "GL_ALPHA_SCALE", GL_ALPHA_SCALE,
    "GL_DEPTH_SCALE", GL_DEPTH_SCALE,
    "GL_RED_BIAS", GL_RED_BIAS,
    "GL_GREEN_BIAS", GL_GREEN_BIAS,
    "GL_BLUE_BIAS", GL_BLUE_BIAS,
    "GL_ALPHA_BIAS", GL_ALPHA_BIAS,
    "GL_DEPTH_BIAS", GL_DEPTH_BIAS,
    "GL_ZOOM_X", GL_ZOOM_X,
    "GL_ZOOM_Y", GL_ZOOM_Y,
    "GL_PIXEL_MAP_I_TO_I_SIZE", GL_PIXEL_MAP_I_TO_I_SIZE,
    "GL_PIXEL_MAP_S_TO_S_SIZE", GL_PIXEL_MAP_S_TO_S_SIZE,
    "GL_PIXEL_MAP_I_TO_R_SIZE", GL_PIXEL_MAP_I_TO_R_SIZE,
    "GL_PIXEL_MAP_I_TO_G_SIZE", GL_PIXEL_MAP_I_TO_G_SIZE,
    "GL_PIXEL_MAP_I_TO_B_SIZE", GL_PIXEL_MAP_I_TO_B_SIZE,
    "GL_PIXEL_MAP_I_TO_A_SIZE", GL_PIXEL_MAP_I_TO_A_SIZE,
    "GL_PIXEL_MAP_R_TO_R_SIZE", GL_PIXEL_MAP_R_TO_R_SIZE,
    "GL_PIXEL_MAP_G_TO_G_SIZE", GL_PIXEL_MAP_G_TO_G_SIZE,
    "GL_PIXEL_MAP_B_TO_B_SIZE", GL_PIXEL_MAP_B_TO_B_SIZE,
    "GL_PIXEL_MAP_A_TO_A_SIZE", GL_PIXEL_MAP_A_TO_A_SIZE,
    "GL_MAX_EVAL_ORDER", GL_MAX_EVAL_ORDER,
    "GL_MAX_LIGHTS", GL_MAX_LIGHTS,
    "GL_MAX_CLIP_PLANES", GL_MAX_CLIP_PLANES,
    "GL_MAX_PIXEL_MAP_TABLE", GL_MAX_PIXEL_MAP_TABLE,
    "GL_MAX_ATTRIB_STACK_DEPTH", GL_MAX_ATTRIB_STACK_DEPTH,
    "GL_MAX_MODELVIEW_STACK_DEPTH", GL_MAX_MODELVIEW_STACK_DEPTH,
    "GL_MAX_NAME_STACK_DEPTH", GL_MAX_NAME_STACK_DEPTH,
    "GL_MAX_PROJECTION_STACK_DEPTH", GL_MAX_PROJECTION_STACK_DEPTH,
    "GL_MAX_TEXTURE_STACK_DEPTH", GL_MAX_TEXTURE_STACK_DEPTH,
    "GL_INDEX_BITS", GL_INDEX_BITS,
    "GL_RED_BITS", GL_RED_BITS,
    "GL_GREEN_BITS", GL_GREEN_BITS,
    "GL_BLUE_BITS", GL_BLUE_BITS,
    "GL_ALPHA_BITS", GL_ALPHA_BITS,
    "GL_DEPTH_BITS", GL_DEPTH_BITS,
    "GL_STENCIL_BITS", GL_STENCIL_BITS,
    "GL_ACCUM_RED_BITS", GL_ACCUM_RED_BITS,
    "GL_ACCUM_GREEN_BITS", GL_ACCUM_GREEN_BITS,
    "GL_ACCUM_BLUE_BITS", GL_ACCUM_BLUE_BITS,
    "GL_ACCUM_ALPHA_BITS", GL_ACCUM_ALPHA_BITS,
    "GL_MAP1_GRID_DOMAIN", GL_MAP1_GRID_DOMAIN,
    "GL_MAP1_GRID_SEGMENTS", GL_MAP1_GRID_SEGMENTS,
    "GL_MAP2_GRID_DOMAIN", GL_MAP2_GRID_DOMAIN,
    "GL_MAP2_GRID_SEGMENTS", GL_MAP2_GRID_SEGMENTS,
    "GL_TEXTURE_1D", GL_TEXTURE_1D,
    "GL_TEXTURE_2D", GL_TEXTURE_2D,
    "GL_MAX_VIEWPORT_DIMS", GL_MAX_VIEWPORT_DIMS,
    "GL_DOUBLEBUFFER", GL_DOUBLEBUFFER,
    "GL_AUX_BUFFERS", GL_AUX_BUFFERS,
    "GL_STEREO", GL_STEREO,
    "End of List", -1
};

enumTestRec enum_HintMode[] = {
    "GL_DONT_CARE", GL_DONT_CARE,
    "GL_FASTEST", GL_FASTEST,
    "GL_NICEST", GL_NICEST,
    "End of List", -1
};

enumTestRec enum_HintTarget[] = {
    "GL_PERSPECTIVE_CORRECTION_HINT", GL_PERSPECTIVE_CORRECTION_HINT,
    "GL_POINT_SMOOTH_HINT", GL_POINT_SMOOTH_HINT,
    "GL_LINE_SMOOTH_HINT", GL_LINE_SMOOTH_HINT,
    "GL_POLYGON_SMOOTH_HINT", GL_POLYGON_SMOOTH_HINT,
    "GL_FOG_HINT", GL_FOG_HINT,
    "End of List", -1
};

enumTestRec enum_LightModelParameter[] = {
    "GL_LIGHT_MODEL_AMBIENT", GL_LIGHT_MODEL_AMBIENT,
    "GL_LIGHT_MODEL_LOCAL_VIEWER", GL_LIGHT_MODEL_LOCAL_VIEWER,
    "GL_LIGHT_MODEL_TWO_SIDE", GL_LIGHT_MODEL_TWO_SIDE,
    "End of List", -1
};

enumTestRec enum_LightName[] = {
    "GL_LIGHT0", GL_LIGHT0,
    "GL_LIGHT1", GL_LIGHT1,
    "GL_LIGHT2", GL_LIGHT2,
    "GL_LIGHT3", GL_LIGHT3,
    "GL_LIGHT4", GL_LIGHT4,
    "GL_LIGHT5", GL_LIGHT5,
    "GL_LIGHT6", GL_LIGHT6,
    "GL_LIGHT7", GL_LIGHT7,
    "End of List", -1
};

enumTestRec enum_LightParameter[] = {
    "GL_AMBIENT", GL_AMBIENT,
    "GL_DIFFUSE", GL_DIFFUSE,
    "GL_SPECULAR", GL_SPECULAR,
    "GL_POSITION", GL_POSITION,
    "GL_SPOT_DIRECTION", GL_SPOT_DIRECTION,
    "GL_SPOT_EXPONENT", GL_SPOT_EXPONENT,
    "GL_SPOT_CUTOFF", GL_SPOT_CUTOFF,
    "GL_CONSTANT_ATTENUATION", GL_CONSTANT_ATTENUATION,
    "GL_LINEAR_ATTENUATION", GL_LINEAR_ATTENUATION,
    "GL_QUADRATIC_ATTENUATION", GL_QUADRATIC_ATTENUATION,
    "End of List", -1
};

enumTestRec enum_ListMode[] = {
    "GL_COMPILE", GL_COMPILE,
    "GL_COMPILE_AND_EXECUTE", GL_COMPILE_AND_EXECUTE,
    "End of List", -1
};

enumTestRec enum_ListNameType[] = {
    "GL_BYTE", GL_BYTE,
    "GL_UNSIGNED_BYTE", GL_UNSIGNED_BYTE,
    "GL_SHORT", GL_SHORT,
    "GL_UNSIGNED_SHORT", GL_UNSIGNED_SHORT,
    "GL_INT", GL_INT,
    "GL_UNSIGNED_INT", GL_UNSIGNED_INT,
    "GL_FLOAT", GL_FLOAT,
    "GL_2_BYTES", GL_2_BYTES,
    "GL_3_BYTES", GL_3_BYTES,
    "GL_4_BYTES", GL_4_BYTES,
    "End of List", -1
};

enumTestRec enum_LogicOp[] = {
    "GL_CLEAR", GL_CLEAR,
    "GL_AND", GL_AND,
    "GL_AND_REVERSE", GL_AND_REVERSE,
    "GL_COPY", GL_COPY,
    "GL_AND_INVERTED", GL_AND_INVERTED,
    "GL_NOOP", GL_NOOP,
    "GL_XOR", GL_XOR,
    "GL_OR", GL_OR,
    "GL_NOR", GL_NOR,
    "GL_EQUIV", GL_EQUIV,
    "GL_INVERT", GL_INVERT,
    "GL_OR_REVERSE", GL_OR_REVERSE,
    "GL_COPY_INVERTED", GL_COPY_INVERTED,
    "GL_OR_INVERTED", GL_OR_INVERTED,
    "GL_NAND", GL_NAND,
    "GL_SET", GL_SET,
    "End of List", -1
};

enumTestRec enum_MapTarget[] = {
    "GL_MAP1_COLOR_4", GL_MAP1_COLOR_4,
    "GL_MAP1_INDEX", GL_MAP1_INDEX,
    "GL_MAP1_NORMAL", GL_MAP1_NORMAL,
    "GL_MAP1_TEXTURE_COORD_1", GL_MAP1_TEXTURE_COORD_1,
    "GL_MAP1_TEXTURE_COORD_2", GL_MAP1_TEXTURE_COORD_2,
    "GL_MAP1_TEXTURE_COORD_3", GL_MAP1_TEXTURE_COORD_3,
    "GL_MAP1_TEXTURE_COORD_4", GL_MAP1_TEXTURE_COORD_4,
    "GL_MAP1_VERTEX_3", GL_MAP1_VERTEX_3,
    "GL_MAP1_VERTEX_4", GL_MAP1_VERTEX_4,
    "GL_MAP2_COLOR_4", GL_MAP2_COLOR_4,
    "GL_MAP2_INDEX", GL_MAP2_INDEX,
    "GL_MAP2_NORMAL", GL_MAP2_NORMAL,
    "GL_MAP2_TEXTURE_COORD_1", GL_MAP2_TEXTURE_COORD_1,
    "GL_MAP2_TEXTURE_COORD_2", GL_MAP2_TEXTURE_COORD_2,
    "GL_MAP2_TEXTURE_COORD_3", GL_MAP2_TEXTURE_COORD_3,
    "GL_MAP2_TEXTURE_COORD_4", GL_MAP2_TEXTURE_COORD_4,
    "GL_MAP2_VERTEX_3", GL_MAP2_VERTEX_3,
    "GL_MAP2_VERTEX_4", GL_MAP2_VERTEX_4,
    "End of List", -1
};

enumTestRec enum_MapGetTarget[] = {
    "GL_COEFF", GL_COEFF,
    "GL_ORDER", GL_ORDER,
    "GL_DOMAIN", GL_DOMAIN,
    "End of List", -1
};

enumTestRec enum_MaterialFace[] = {
    "GL_FRONT", GL_FRONT,
    "GL_BACK", GL_BACK,
    "GL_FRONT_AND_BACK", GL_FRONT_AND_BACK,
    "End of List", -1
};

enumTestRec enum_MaterialParameter[] = {
    "GL_EMISSION", GL_EMISSION,
    "GL_SHININESS", GL_SHININESS,
    "GL_AMBIENT_AND_DIFFUSE", GL_AMBIENT_AND_DIFFUSE,
    "GL_COLOR_INDEXES", GL_COLOR_INDEXES,
    "GL_AMBIENT", GL_AMBIENT,
    "GL_DIFFUSE", GL_DIFFUSE,
    "GL_SPECULAR", GL_SPECULAR,
    "End of List", -1
};

enumTestRec enum_MatrixMode[] = {
    "GL_TEXTURE", GL_TEXTURE,
    "GL_PROJECTION", GL_PROJECTION,
    "GL_MODELVIEW", GL_MODELVIEW,
    "End of List", -1
};

enumTestRec enum_MeshMode1[] = {
    "GL_POINT", GL_POINT,
    "GL_LINE", GL_LINE,
    "End of List", -1
};

enumTestRec enum_MeshMode2[] = {
    "GL_POINT", GL_POINT,
    "GL_LINE", GL_LINE,
    "GL_FILL", GL_FILL,
    "End of List", -1
};

enumTestRec enum_PixelCopyType[] = {
    "GL_COLOR", GL_COLOR,
    "GL_DEPTH", GL_DEPTH,
    "GL_STENCIL", GL_STENCIL,
    "End of List", -1
};

enumTestRec enum_PixelFormat[] = {
    "GL_COLOR_INDEX", GL_COLOR_INDEX,
    "GL_STENCIL_INDEX", GL_STENCIL_INDEX,
    "GL_DEPTH_COMPONENT", GL_DEPTH_COMPONENT,
    "GL_RED", GL_RED,
    "GL_GREEN", GL_GREEN,
    "GL_BLUE", GL_BLUE,
    "GL_ALPHA", GL_ALPHA,
    "GL_RGB", GL_RGB,
    "GL_RGBA", GL_RGBA,
    "GL_LUMINANCE", GL_LUMINANCE,
    "GL_LUMINANCE_ALPHA", GL_LUMINANCE_ALPHA,
    "End of List", -1
};

enumTestRec enum_PixelMap[] = {
    "GL_PIXEL_MAP_I_TO_I", GL_PIXEL_MAP_I_TO_I,
    "GL_PIXEL_MAP_S_TO_S", GL_PIXEL_MAP_S_TO_S,
    "GL_PIXEL_MAP_I_TO_R", GL_PIXEL_MAP_I_TO_R,
    "GL_PIXEL_MAP_I_TO_G", GL_PIXEL_MAP_I_TO_G,
    "GL_PIXEL_MAP_I_TO_B", GL_PIXEL_MAP_I_TO_B,
    "GL_PIXEL_MAP_I_TO_A", GL_PIXEL_MAP_I_TO_A,
    "GL_PIXEL_MAP_R_TO_R", GL_PIXEL_MAP_R_TO_R,
    "GL_PIXEL_MAP_G_TO_G", GL_PIXEL_MAP_G_TO_G,
    "GL_PIXEL_MAP_B_TO_B", GL_PIXEL_MAP_B_TO_B,
    "GL_PIXEL_MAP_A_TO_A", GL_PIXEL_MAP_A_TO_A,
    "End of List", -1
};

enumTestRec enum_PixelStore[] = {
    "GL_UNPACK_SWAP_BYTES", GL_UNPACK_SWAP_BYTES,
    "GL_UNPACK_LSB_FIRST", GL_UNPACK_LSB_FIRST,
    "GL_UNPACK_ROW_LENGTH", GL_UNPACK_ROW_LENGTH,
    "GL_UNPACK_SKIP_ROWS", GL_UNPACK_SKIP_ROWS,
    "GL_UNPACK_SKIP_PIXELS", GL_UNPACK_SKIP_PIXELS,
    "GL_UNPACK_ALIGNMENT", GL_UNPACK_ALIGNMENT,
    "GL_PACK_SWAP_BYTES", GL_PACK_SWAP_BYTES,
    "GL_PACK_LSB_FIRST", GL_PACK_LSB_FIRST,
    "GL_PACK_ROW_LENGTH", GL_PACK_ROW_LENGTH,
    "GL_PACK_SKIP_ROWS", GL_PACK_SKIP_ROWS,
    "GL_PACK_SKIP_PIXELS", GL_PACK_SKIP_PIXELS,
    "GL_PACK_ALIGNMENT", GL_PACK_ALIGNMENT,
    "End of List", -1
};

enumTestRec enum_PixelTransfer[] = {
    "GL_MAP_COLOR", GL_MAP_COLOR,
    "GL_MAP_STENCIL", GL_MAP_STENCIL,
    "GL_INDEX_SHIFT", GL_INDEX_SHIFT,
    "GL_INDEX_OFFSET", GL_INDEX_OFFSET,
    "GL_RED_SCALE", GL_RED_SCALE,
    "GL_RED_BIAS", GL_RED_BIAS,
    "GL_GREEN_SCALE", GL_GREEN_SCALE,
    "GL_GREEN_BIAS", GL_GREEN_BIAS,
    "GL_BLUE_SCALE", GL_BLUE_SCALE,
    "GL_BLUE_BIAS", GL_BLUE_BIAS,
    "GL_ALPHA_SCALE", GL_ALPHA_SCALE,
    "GL_ALPHA_BIAS", GL_ALPHA_BIAS,
    "GL_DEPTH_SCALE", GL_DEPTH_SCALE,
    "GL_DEPTH_BIAS", GL_DEPTH_BIAS,
    "End of List", -1
};

enumTestRec enum_PixelType[] = {
    "GL_BITMAP", GL_BITMAP,
    "GL_BYTE", GL_BYTE,
    "GL_UNSIGNED_BYTE", GL_UNSIGNED_BYTE,
    "GL_SHORT", GL_SHORT,
    "GL_UNSIGNED_SHORT", GL_UNSIGNED_SHORT,
    "GL_INT", GL_INT,
    "GL_UNSIGNED_INT", GL_UNSIGNED_INT,
    "GL_FLOAT", GL_FLOAT,
    "End of List", -1
};

enumTestRec enum_PolygonMode[] = {
    "GL_POINT", GL_POINT,
    "GL_LINE", GL_LINE,
    "GL_FILL", GL_FILL,
    "End of List", -1
};

enumTestRec enum_BeginMode[] = {
    "GL_LINE_LOOP", GL_LINE_LOOP,
    "GL_LINE_STRIP", GL_LINE_STRIP,
    "GL_LINES", GL_LINES,
    "GL_POINTS", GL_POINTS,
    "GL_POLYGON", GL_POLYGON,
    "GL_TRIANGLE_STRIP", GL_TRIANGLE_STRIP,
    "GL_TRIANGLE_FAN", GL_TRIANGLE_FAN,
    "GL_TRIANGLES", GL_TRIANGLES,
    "GL_QUAD_STRIP", GL_QUAD_STRIP,
    "GL_QUADS", GL_QUADS,
    "End of List", -1
};

enumTestRec enum_ReadBufferMode[] = {
    "GL_FRONT_LEFT", GL_FRONT_LEFT,
    "GL_FRONT_RIGHT", GL_FRONT_RIGHT,
    "GL_BACK_LEFT", GL_BACK_LEFT,
    "GL_BACK_RIGHT", GL_BACK_RIGHT,
    "GL_BACK", GL_BACK,
    "GL_LEFT", GL_LEFT,
    "GL_RIGHT", GL_RIGHT,
    "GL_AUX0", GL_AUX0,
    "GL_AUX1", GL_AUX1,
    "GL_AUX2", GL_AUX2,
    "GL_AUX3", GL_AUX3,
    "GL_FRONT", GL_FRONT,
    "End of List", -1
};

enumTestRec enum_RenderingMode[] = {
    "GL_FEEDBACK", GL_FEEDBACK,
    "GL_SELECT", GL_SELECT,
    "GL_RENDER", GL_RENDER,
    "End of List", -1
};

enumTestRec enum_ShadingModel[] = {
    "GL_FLAT", GL_FLAT,
    "GL_SMOOTH", GL_SMOOTH,
    "End of List", -1
};

enumTestRec enum_StencilFunction[] = {
    "GL_NEVER", GL_NEVER,
    "GL_LESS", GL_LESS,
    "GL_EQUAL", GL_EQUAL,
    "GL_LEQUAL", GL_LEQUAL,
    "GL_GREATER", GL_GREATER,
    "GL_NOTEQUAL", GL_NOTEQUAL,
    "GL_GEQUAL", GL_GEQUAL,
    "GL_ALWAYS", GL_ALWAYS,
    "End of List", -1
};

enumTestRec enum_StencilOp[] = {
    "GL_ZERO", GL_ZERO,
    "GL_KEEP", GL_KEEP,
    "GL_REPLACE", GL_REPLACE,
    "GL_INCR", GL_INCR,
    "GL_DECR", GL_DECR,
    "GL_INVERT", GL_INVERT,
    "End of List", -1
};

enumTestRec enum_StringName[] = {
    "GL_VENDOR", GL_VENDOR,
    "GL_RENDERER", GL_RENDERER,
    "GL_VERSION", GL_VERSION,
    "GL_EXTENSIONS", GL_EXTENSIONS,
    "End of List", -1
};

enumTestRec enum_TextureBorder[] = {
    "No border", 0,
    "One Border", 1,
    "End of List", -1
};

enumTestRec enum_TextureCoordName[] = {
    "GL_S", GL_S,
    "GL_T", GL_T,
    "GL_R", GL_R,
    "GL_Q", GL_Q,
    "End of List", -1
};

enumTestRec enum_TextureEnvMode[] = {
    "GL_MODULATE", GL_MODULATE,
    "GL_DECAL", GL_DECAL,
    "GL_BLEND", GL_BLEND,
    "End of List", -1
};

enumTestRec enum_TextureEnvParameter[] = {
    "GL_TEXTURE_ENV_MODE", GL_TEXTURE_ENV_MODE,
    "GL_TEXTURE_ENV_COLOR", GL_TEXTURE_ENV_COLOR,
    "End of List", -1
};

enumTestRec enum_TextureEnvTarget[] = {
    "GL_TEXTURE_ENV", GL_TEXTURE_ENV,
    "End of List", -1
};

enumTestRec enum_TextureGenMode[] = {
    "GL_EYE_LINEAR", GL_EYE_LINEAR,
    "GL_OBJECT_LINEAR", GL_OBJECT_LINEAR,
    "GL_SPHERE_MAP", GL_SPHERE_MAP,
    "End of List", -1
};

enumTestRec enum_TextureGenParameter[] = {
    "GL_TEXTURE_GEN_MODE", GL_TEXTURE_GEN_MODE,
    "GL_OBJECT_PLANE", GL_OBJECT_PLANE,
    "GL_EYE_PLANE", GL_EYE_PLANE,
    "End of List", -1
};

enumTestRec enum_TextureWrapMode[] = {
    "GL_CLAMP", GL_CLAMP,
    "GL_REPEAT", GL_REPEAT,
    "End of List", -1
};

enumTestRec enum_TextureMagFilter[] = {
    "GL_NEAREST", GL_NEAREST,
    "GL_LINEAR", GL_LINEAR,
    "End of List", -1
};

enumTestRec enum_TextureMinFilter[] = {
    "GL_NEAREST", GL_NEAREST,
    "GL_LINEAR", GL_LINEAR,
    "GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST,
    "GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST,
    "GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR,
    "GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR,
    "End of List", -1
};

enumTestRec enum_TextureParameterName[] = {
    "GL_TEXTURE_MAG_FILTER", GL_TEXTURE_MAG_FILTER,
    "GL_TEXTURE_MIN_FILTER", GL_TEXTURE_MIN_FILTER,
    "GL_TEXTURE_WRAP_S", GL_TEXTURE_WRAP_S,
    "GL_TEXTURE_WRAP_T", GL_TEXTURE_WRAP_T,
    "End of List", -1
};

enumTestRec enum_GetTextureParameter[] = {
    "GL_TEXTURE_MAG_FILTER", GL_TEXTURE_MAG_FILTER,
    "GL_TEXTURE_MIN_FILTER", GL_TEXTURE_MIN_FILTER,
    "GL_TEXTURE_WRAP_S", GL_TEXTURE_WRAP_S,
    "GL_TEXTURE_WRAP_T", GL_TEXTURE_WRAP_T,
    "GL_TEXTURE_WIDTH", GL_TEXTURE_WIDTH,
    "GL_TEXTURE_HEIGHT", GL_TEXTURE_HEIGHT,
    "GL_TEXTURE_COMPONENTS", GL_TEXTURE_COMPONENTS,
    "GL_TEXTURE_BORDER_COLOR", GL_TEXTURE_BORDER_COLOR,
    "GL_TEXTURE_BORDER", GL_TEXTURE_BORDER,
    "End of List", -1
};

enumTestRec enum_TextureTarget[] = {
    "GL_TEXTURE_1D", GL_TEXTURE_1D,
    "GL_TEXTURE_2D", GL_TEXTURE_2D,
    "End of List", -1
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\enum.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void VerifyEnums(void)
{
    long i;

    Output("Enumeration check.\n");
    for (i = 0; enum_Check[i].value != -1; i++) {
	Output("\t%s (%d) = %d.\n", enum_Check[i].name, enum_Check[i].true, enum_Check[i].value);
	if (enum_Check[i].value != enum_Check[i].true) {
	    FailAndDie();
	}    
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\l.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallLight(void)
{
    long i, j;

    Output("glLighti, ");
    Output("glLightf\n");
    for (i = 0; enum_LightName[i].value != -1; i++) {
	for (j = 0; enum_LightParameter[j].value != -1; j++) {

	    if (enum_LightParameter[j].value == GL_AMBIENT) {
		continue;
	    } else if (enum_LightParameter[j].value == GL_DIFFUSE) {
		continue;
	    } else if (enum_LightParameter[j].value == GL_SPECULAR) {
		continue;
	    } else if (enum_LightParameter[j].value == GL_POSITION) {
		continue;
	    } else if (enum_LightParameter[j].value == GL_SPOT_DIRECTION) {
		continue;
	    }

	    Output("\t%s, %s\n", enum_LightName[i].name, enum_LightParameter[j].name);
	    glLighti(enum_LightName[i].value, enum_LightParameter[j].value, 0);
	    glLightf(enum_LightName[i].value, enum_LightParameter[j].value, 0.0);
	    ProbeEnum();
	}
    }
    Output("\n");

    Output("glLightiv, ");
    Output("glLightfv\n");
    for (i = 0; enum_LightName[i].value != -1; i++) {
	for (j = 0; enum_LightParameter[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_LightName[i].name, enum_LightParameter[j].name);
	    {
		static GLint buf[] = {
		    0, 0, 0, 0
		};
		glLightiv(enum_LightName[i].value, enum_LightParameter[j].value, buf);
	    }
	    {
		static GLfloat buf[] = {
		    0.0, 0.0, 0.0, 0.0
		};
		glLightfv(enum_LightName[i].value, enum_LightParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallLightModel(void)
{
    long i;

    Output("glLightModeli, ");
    Output("glLightModelf\n");
    for (i = 0; enum_LightModelParameter[i].value != -1; i++) {

	if (enum_LightModelParameter[i].value == GL_LIGHT_MODEL_AMBIENT) {
	    continue;
	}

	Output("\t%s\n", enum_LightModelParameter[i].name);
	glLightModeli(enum_LightModelParameter[i].value, 0);
	glLightModelf(enum_LightModelParameter[i].value, 0.0);
	ProbeEnum();
    }
    Output("\n");

    Output("glLightModeliv, ");
    Output("glLightModelfv\n");
    for (i = 0; enum_LightModelParameter[i].value != -1; i++) {
	Output("\t%s\n", enum_LightModelParameter[i].name);
	{
	    static GLint buf[] = {
		0, 0, 0, 0
	    };
	    glLightModeliv(enum_LightModelParameter[i].value, buf);
	}
	{
	    static GLfloat buf[] = {
		0.0, 0.0, 0.0, 0.0
	    };
	    glLightModelfv(enum_LightModelParameter[i].value, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallLineStipple(void)
{

    Output("glLineStipple\n");
    glLineStipple(1, ~0);
    Output("\n");
}

void CallLineWidth(void)
{

    Output("glLineWidth\n");
    glLineWidth(1.0);
    Output("\n");
}

void CallListBase(void)
{

    Output("glListBase\n");
    glListBase(1);
    Output("\n");
}

void CallLoadIdentity(void)
{

    Output("glLoadIdentity\n");
    glLoadIdentity();
    Output("\n");
}

void CallLoadMatrix(void)
{

    Output("glLoadMatrixf, ");
    Output("glLoadMatrixd\n");
    {
	static GLfloat buf[] = {
	    1.0, 0.0, 0.0, 0.0,
	    0.0, 1.0, 0.0, 0.0,
	    0.0, 0.0, 1.0, 0.0,
	    0.0, 0.0, 0.0, 1.0
	};
	glLoadMatrixf(buf);
    }
    {
	static GLdouble buf[] = {
	    1.0, 0.0, 0.0, 0.0,
	    0.0, 1.0, 0.0, 0.0,
	    0.0, 0.0, 1.0, 0.0,
	    0.0, 0.0, 0.0, 1.0
	};
	glLoadMatrixd(buf);
    }
    Output("\n");
}

void CallLoadName(void)
{

    Output("glLoadName\n");
    glLoadName(1);
    Output("\n");
}

void CallLogicOp(void)
{
    long i;

    Output("glLogicOp\n");
    for (i = 0; enum_LogicOp[i].value != -1; i++) {
	Output("\t%s\n", enum_LogicOp[i].name);
	glLogicOp(enum_LogicOp[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\h.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallHint(void)
{
    long i, j;

    Output("glHint\n");
    for (i = 0; enum_HintTarget[i].value != -1; i++) {
	for (j = 0; enum_HintMode[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_HintTarget[i].name, enum_HintMode[j].name);
	    glHint(enum_HintTarget[i].value, enum_HintMode[j].value);
	    ProbeEnum();
	}
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\n.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallNewEndList(void)
{
    long i;

    Output("glNewList\n");
    for (i = 0; enum_ListMode[i].value != -1; i++) {
	Output("\t%s\n", enum_ListMode[i].name);
	glNewList(1, enum_ListMode[i].value);
	glEndList();
	ProbeEnum();
    }
    Output("\n");

    Output("glEndList\n");
    Output("\n");
}

void CallNormal(void)
{
    float x, y, z;

    x = 1.0;
    y = 1.0;
    z = 1.0;

    Output("glNormal3b, ");
    Output("glNormal3bv, ");
    Output("glNormal3s, ");
    Output("glNormal3sv, ");
    Output("glNormal3i, ");
    Output("glNormal3iv, ");
    Output("glNormal3f, ");
    Output("glNormal3fv, ");
    Output("glNormal3d, ");
    Output("glNormal3dv\n");

    glNormal3b((GLbyte)x, (GLbyte)y, (GLbyte)z);

    {
	GLbyte buf[3];
	buf[0] = (GLbyte)x;
	buf[1] = (GLbyte)y;
	buf[2] = (GLbyte)z;
	glNormal3bv(buf);
    }

    glNormal3s((GLshort)x, (GLshort)y, (GLshort)z);

    {
	GLshort buf[3];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	glNormal3sv(buf);
    }

    glNormal3i((GLint)x, (GLint)y, (GLint)z);

    {
	GLint buf[3];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	glNormal3iv(buf);
    }

    glNormal3f((GLfloat)x, (GLfloat)y, (GLfloat)z);

    {
	GLfloat buf[3];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	glNormal3fv(buf);
    }

    glNormal3d((GLdouble)x, (GLdouble)y, (GLdouble)z);

    {
	GLdouble buf[3];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	glNormal3dv(buf);
    }

    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\o.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallOrtho(void)
{

    Output("glOrtho\n");
    glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\m.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallMap1(void)
{
    long i;

    Output("glMap1f, ");
    Output("glMap1d\n");
    for (i = 0; enum_MapTarget[i].value != -1; i++) {

	if (enum_MapTarget[i].value == GL_MAP2_COLOR_4) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_INDEX) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_NORMAL) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_TEXTURE_COORD_1) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_TEXTURE_COORD_2) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_TEXTURE_COORD_3) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_TEXTURE_COORD_4) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_VERTEX_3) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP2_VERTEX_4) {
	    continue;
	}

	Output("\t%s\n", enum_MapTarget[i].name);
	{
	    static GLfloat buf[] = {
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0,
	    };
	    glMap1f(enum_MapTarget[i].value, 0.0, 1.0, 4, 2, buf);
	}
	{
	    static GLdouble buf[] = {
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0,
	    };
	    glMap1d(enum_MapTarget[i].value, 0.0, 1.0, 4, 2, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallMap2(void)
{
    long i;

    Output("glMap2f, ");
    Output("glMap2d\n");
    for (i = 0; enum_MapTarget[i].value != -1; i++) {

	if (enum_MapTarget[i].value == GL_MAP1_COLOR_4) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_INDEX) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_NORMAL) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_TEXTURE_COORD_1) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_TEXTURE_COORD_2) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_TEXTURE_COORD_3) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_TEXTURE_COORD_4) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_VERTEX_3) {
	    continue;
	} else if (enum_MapTarget[i].value == GL_MAP1_VERTEX_4) {
	    continue;
	}

	Output("\t%s\n", enum_MapTarget[i].name);
	{
	    static GLfloat buf[] = {
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0,
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0
	    };
	    glMap2f(enum_MapTarget[i].value, 0.0, 1.0, 4, 2, 0.0, 1.0, 4, 2, buf);
	}
	{
	    static GLdouble buf[] = {
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0,
		1.0, 0.0, 0.0, 1.0,
		0.0, 1.0, 0.0, 1.0
	    };
	    glMap2d(enum_MapTarget[i].value, 0.0, 1.0, 4, 2, 0.0, 1.0, 4, 2, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallMapGrid1(void)
{

    Output("glMapGrid1f, ");
    Output("glMapGrid1d\n");
    glMapGrid1f(1, 0.0, 1.0);
    glMapGrid1d(1, 0.0, 1.0);
    Output("\n");
}

void CallMapGrid2(void)
{

    Output("glMapGrid2f, ");
    Output("glMapGrid2d\n");
    glMapGrid2f(1, 0.0, 1.0, 1, 0.0, 1.0);
    glMapGrid2d(1, 0.0, 1.0, 1, 0.0, 1.0);
    Output("\n");
}

void CallMaterial(void)
{
    long i, j;

    Output("glMateriali, ");
    Output("glMaterialf\n");
    for (i = 0; enum_MaterialFace[i].value != -1; i++) {
	for (j = 0; enum_MaterialParameter[j].value != -1; j++) {

            if (enum_MaterialParameter[j].value == GL_COLOR_INDEXES) {
		continue;
            } else if (enum_MaterialParameter[j].value == GL_EMISSION) {
		continue;
            } else if (enum_MaterialParameter[j].value == GL_AMBIENT) {
		continue;
            } else if (enum_MaterialParameter[j].value == GL_DIFFUSE) {
		continue;
            } else if (enum_MaterialParameter[j].value == GL_SPECULAR) {
		continue;
            } else if (enum_MaterialParameter[j].value == GL_AMBIENT_AND_DIFFUSE) {
		continue;
	    }

	    Output("\t%s, %s\n", enum_MaterialFace[i].name, enum_MaterialParameter[j].name);
	    glMateriali(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, 0);
	    glMaterialf(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, 0.0);
	    ProbeEnum();
	}
    }
    Output("\n");

    Output("glMaterialiv, ");
    Output("glMaterialfv\n");
    for (i = 0; enum_MaterialFace[i].value != -1; i++) {
	for (j = 0; enum_MaterialParameter[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_MaterialFace[i].name, enum_MaterialParameter[j].name);
	    {
		static GLint buf[] = {
		    0, 0, 0, 0
		};
		glMaterialiv(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, buf);
	    }
	    {
		static GLfloat buf[] = {
		    0.0, 0.0, 0.0, 0.0
		};
		glMaterialfv(enum_MaterialFace[i].value, enum_MaterialParameter[j].value, buf);
	    }
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallMatrixMode(void)
{
    long i;

    Output("glMatrixMode\n");
    for (i = 0; enum_MatrixMode[i].value != -1; i++) {
	Output("\t%s\n", enum_MatrixMode[i].name);
	glMatrixMode(enum_MatrixMode[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallMultMatrix(void)
{

    Output("glMultMatrixf, ");
    Output("glMultMatrixd\n");
    {
	static GLfloat buf[] = {
	    1.0, 0.0, 0.0, 0.0,
	    0.0, 1.0, 0.0, 0.0,
	    0.0, 0.0, 1.0, 0.0,
	    0.0, 0.0, 0.0, 1.0
	};
	glMultMatrixf(buf);
    }
    {
	static GLdouble buf[] = {
	    1.0, 0.0, 0.0, 0.0,
	    0.0, 1.0, 0.0, 0.0,
	    0.0, 0.0, 1.0, 0.0,
	    0.0, 0.0, 0.0, 1.0
	};
	glMultMatrixd(buf);
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\s.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallScale(void)
{

    Output("glScalef, ");
    Output("glScaled\n");
    glScalef(1.0, 1.0, 1.0);
    glScaled(1.0, 1.0, 1.0);
    Output("\n");
}

void CallScissor(void)
{

    Output("glScissor\n");
    glScissor(0, 0, 1, 1);
    Output("\n");
}

void CallSelectBuffer(void)
{
    GLuint buf[1];

    Output("glSelectBuffer\n");
    glSelectBuffer(1, buf);
    Output("\n");
}

void CallShadeModel(void)
{
    long i;

    Output("glShadeModel\n");
    for (i = 0; enum_ShadingModel[i].value != -1; i++) {
	Output("\t%s\n", enum_ShadingModel[i].name);
	glShadeModel(enum_ShadingModel[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallStencilFunc(void)
{
    long i;

    Output("glStencilFunc\n");
    for (i = 0; enum_StencilFunction[i].value != -1; i++) {
	Output("\t%s\n", enum_StencilFunction[i].name);
	glStencilFunc(enum_StencilFunction[i].value, 0, 0);
	ProbeEnum();
    }
    Output("\n");
}

void CallStencilMask(void)
{

    Output("glStencilMask\n");
    glStencilMask(0);
    Output("\n");
}

void CallStencilOp(void)
{
    long i, j, k;

    Output("glStencilOp\n");
    for (i = 0; enum_StencilOp[i].value != -1; i++) {
	for (j = 0; enum_StencilOp[j].value != -1; j++) {
	    for (k = 0; enum_StencilOp[k].value != -1; k++) {
		Output("\t%s, %s, %s\n", enum_StencilOp[i].name, enum_StencilOp[j].name, enum_StencilOp[k].name);
		glStencilOp(enum_StencilOp[i].value, enum_StencilOp[j].value, enum_StencilOp[k].value);
		ProbeEnum();
	    }
	}
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\r.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallRasterPos(void)
{
    float x, y, z, w;

    x = 1.0;
    y = 1.0;
    z = 1.0;
    w = 1.0;

    Output("glRasterPos2s, ");
    Output("glRasterPos2sv, ");
    Output("glRasterPos2i, ");
    Output("glRasterPos2iv, ");
    Output("glRasterPos2f, ");
    Output("glRasterPos2fv, ");
    Output("glRasterPos2d, ");
    Output("glRasterPos2dv, ");
    Output("glRasterPos3s, ");
    Output("glRasterPos3sv, ");
    Output("glRasterPos3i, ");
    Output("glRasterPos3iv, ");
    Output("glRasterPos3f, ");
    Output("glRasterPos3fv, ");
    Output("glRasterPos3d, ");
    Output("glRasterPos3dv, ");
    Output("glRasterPos4s, ");
    Output("glRasterPos4sv, ");
    Output("glRasterPos4i, ");
    Output("glRasterPos4iv, ");
    Output("glRasterPos4f, ");
    Output("glRasterPos4fv, ");
    Output("glRasterPos4d, ");
    Output("glRasterPos4dv\n");

    glRasterPos2s((GLshort)x, (GLshort)y);

    {
	GLshort buf[2];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	glRasterPos2sv(buf);
    }

    glRasterPos2i((GLint)x, (GLint)y);

    {
	GLint buf[2];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	glRasterPos2iv(buf);
    }

    glRasterPos2f((GLfloat)x, (GLfloat)y);

    {
	GLfloat buf[2];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	glRasterPos2fv(buf);
    }

    glRasterPos2d((GLdouble)x, (GLdouble)y);

    {
	GLdouble buf[2];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	glRasterPos2dv(buf);
    }

    glRasterPos3s((GLshort)x, (GLshort)y, (GLshort)z);

    {
	GLshort buf[3];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	glRasterPos3sv(buf);
    }

    glRasterPos3i((GLint)x, (GLint)y, (GLint)z);

    {
	GLint buf[3];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	glRasterPos3iv(buf);
    }

    glRasterPos3f((GLfloat)x, (GLfloat)y, (GLfloat)z);

    {
	GLfloat buf[3];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	glRasterPos3fv(buf);
    }

    glRasterPos3d((GLdouble)x, (GLdouble)y, (GLdouble)z);

    {
	GLdouble buf[3];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	glRasterPos3dv(buf);
    }

    glRasterPos4s((GLshort)x, (GLshort)y, (GLshort)z, (GLshort)w);

    {
	GLshort buf[4];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	buf[3] = (GLshort)w;
	glRasterPos4sv(buf);
    }

    glRasterPos4i((GLint)x, (GLint)y, (GLint)z, (GLint)w);

    {
	GLint buf[4];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	buf[3] = (GLint)w;
	glRasterPos4iv(buf);
    }

    glRasterPos4f((GLfloat)x, (GLfloat)y, (GLfloat)z, (GLfloat)w);

    {
	GLfloat buf[4];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	buf[3] = (GLfloat)w;
	glRasterPos4fv(buf);
    }

    glRasterPos4d((GLdouble)x, (GLdouble)y, (GLdouble)z, (GLdouble)w);

    {
	GLdouble buf[4];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	buf[3] = (GLdouble)w;
	glRasterPos4dv(buf);
    }

    Output("\n");
}

void CallReadBuffer(void)
{
    long i;

    Output("glReadBuffer\n");
    for (i = 0; enum_ReadBufferMode[i].value != -1; i++) {
	Output("\t%s\n", enum_ReadBufferMode[i].name);
	glReadBuffer(enum_ReadBufferMode[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallReadDrawPixels(void)
{
    float buf[100];
    long i, j;

    Output("glReadPixels, ");
    Output("glDrawPixels\n");
    for (i = 0; enum_PixelFormat[i].value != -1; i++) {
	for (j = 0; enum_PixelType[j].value != -1; j++) {

	    if (enum_PixelType[j].value == GL_BITMAP) {
		continue;
	    }

	    Output("\t%s, %s\n", enum_PixelFormat[i].name, enum_PixelType[j].name);
	    glReadPixels(0, 0, 1, 1, enum_PixelFormat[i].value, enum_PixelType[j].value, (GLubyte *)buf);
	    glDrawPixels(1, 1, enum_PixelFormat[i].value, enum_PixelType[j].value, (GLubyte *)buf);
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallRect(void)
{
    float x1, y1, x2, y2;

    x1 = 1.0;
    y1 = 1.0;
    x2 = 1.0;
    y2 = 1.0;

    Output("glRects, ");
    Output("glRectsv, ");
    Output("glRecti, ");
    Output("glRectiv, ");
    Output("glRectf, ");
    Output("glRectfv, ");
    Output("glRectd, ");
    Output("glRectdv\n");

    glRects((GLshort)x1, (GLshort)y1, (GLshort)x2, (GLshort)y2);

    {
	GLshort buf1[2], buf2[2];
	buf1[0] = (GLshort)x1;
	buf1[1] = (GLshort)y1;
	buf2[0] = (GLshort)x2;
	buf2[1] = (GLshort)y2;
	glRectsv(buf1, buf2);
    }

    glRecti((GLint)x1, (GLint)y1, (GLint)x2, (GLint)y2);

    {
	GLint buf1[2], buf2[2];
	buf1[0] = (GLint)x1;
	buf1[1] = (GLint)y1;
	buf2[0] = (GLint)x2;
	buf2[1] = (GLint)y2;
	glRectiv(buf1, buf2);
    }

    glRectf((GLfloat)x1, (GLfloat)y1, (GLfloat)x2, (GLfloat)y2);

    {
	GLfloat buf1[2], buf2[2];
	buf1[0] = (GLfloat)x1;
	buf1[1] = (GLfloat)y1;
	buf2[0] = (GLfloat)x2;
	buf2[1] = (GLfloat)y2;
	glRectfv(buf1, buf2);
    }

    glRectd((GLdouble)x1, (GLdouble)y1, (GLdouble)x2, (GLdouble)y2);

    {
	GLdouble buf1[2], buf2[2];
	buf1[0] = (GLdouble)x1;
	buf1[1] = (GLdouble)y1;
	buf2[0] = (GLdouble)x2;
	buf2[1] = (GLdouble)y2;
	glRectdv(buf1, buf2);
    }

    Output("\n");
}

void CallRenderMode(void)
{
    GLint i, j;

    Output("glRenderMode\n");
    for (i = 0; enum_RenderingMode[i].value != -1; i++) {
	Output("\t%s\n", enum_RenderingMode[i].name);
	j = glRenderMode(enum_RenderingMode[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallRotate(void)
{

    Output("glRotatef, ");
    Output("glRotated\n");
    glRotatef(0.0, 1, 1, 1);
    glRotated(0.0, 1, 1, 1);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\p.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallPassThrough(void)
{

    Output("glPassThrough\n");
    glPassThrough(0.0);
    Output("\n");
}

void CallPixelMap(void)
{
    long i;

    Output("glPixelMapus, ");
    Output("glPixelMapui, ");
    Output("glPixelMapf\n");
    for (i = 0; enum_PixelMap[i].value != -1; i++) {

	Output("\t%s\n", enum_PixelMap[i].name);
	{
	    GLushort buf[1];
	    buf[0] = 0;
	    glPixelMapusv(enum_PixelMap[i].value, 1, buf);
	}
	{
	    GLuint buf[1];
	    buf[0] = 0;
	    glPixelMapuiv(enum_PixelMap[i].value, 1, buf);
	}
	{
	    GLfloat buf[1];
	    buf[0] = 0.0;
	    glPixelMapfv(enum_PixelMap[i].value, 1, buf);
	}
	ProbeEnum();
    }
    Output("\n");
}

void CallPixelStore(void)
{
    long i;

    Output("glPixelStorei, ");
    Output("glPixelStoref\n");
    for (i = 0; enum_PixelStore[i].value != -1; i++) {
	Output("\t%s\n", enum_PixelStore[i].name);
	glPixelStorei(enum_PixelStore[i].value, 1);
	glPixelStoref(enum_PixelStore[i].value, 1.0);
	ProbeEnum();
    }
    Output("\n");
}

void CallPixelTransfer(void)
{
    long i;

    Output("glPixelTransferi, ");
    Output("glPixelTransferf\n");
    for (i = 0; enum_PixelTransfer[i].value != -1; i++) {
	Output("\t%s\n", enum_PixelTransfer[i].name);
	glPixelTransferi(enum_PixelTransfer[i].value, 1);
	glPixelTransferf(enum_PixelTransfer[i].value, 1.0);
	ProbeEnum();
    }
    Output("\n");
}

void CallPixelZoom(void)
{

    Output("glPixelZoom\n");
    glPixelZoom(1.0, 1.0);
    Output("\n");
}

void CallPointSize(void)
{

    Output("glPointSize\n");
    glPointSize(1.0);
    Output("\n");
}

void CallPolygonMode(void)
{
    long i, j;

    Output("glPolygonMode\n");
    for (i = 0; enum_MaterialFace[i].value != -1; i++) {
	for (j = 0; enum_PolygonMode[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_MaterialFace[i].name, enum_PolygonMode[j].name);
	    glPolygonMode(enum_MaterialFace[i].value, enum_PolygonMode[j].value);
	    ProbeEnum();
	}
    }
    Output("\n");
}

void CallPolygonStipple(void)
{
    GLubyte buf[128];

    ZeroBuf(GL_UNSIGNED_BYTE, 128, (void *)buf);

    Output("glPolygonStipple\n");
    glPolygonStipple(buf);
    Output("\n");
}

void CallPopMatrix(void)
{

    Output("glPopMatrix\n");
    glPopMatrix();
    Output("\n");
}

void CallPopName(void)
{

    Output("glPopName\n");
    glPopName();
    Output("\n");
}

void CallPushPopAttrib(void)
{
    long i;

    Output("glPushAttrib, ");
    Output("glPopAttrib\n");
    for (i = 0; enum_AttribMask[i].value != -1; i++) {
	Output("\t%s\n", enum_AttribMask[i].name);
	glPushAttrib(enum_AttribMask[i].value);
	glPopAttrib();
	ProbeEnum();
    }
    Output("\n");
}

void CallPushMatrix(void)
{

    Output("glPushMatrix\n");
    glPushMatrix();
    Output("\n");
}

void CallPushName(void)
{

    Output("glPushName\n");
    glPushName(1);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\shell.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include "ctk.h"
#include "shell.h"


long  verbose;
GLint visualID = -99;

void Output(char *format, ...)
{
    va_list args;

    va_start(args, format);
    if (verbose) {
	vprintf(format, args);
	fflush(stdout);
    }
    va_end(args);
}

void FailAndDie(void)
{

    Output("\n");
    printf("covgl failed.\n\n");
    tkQuit();
}

void ProbeEnum(void)
{

    if (glGetError() == GL_INVALID_ENUM) {
	FailAndDie();
    }
}

void ProbeError(void (*Func)(void))
{
    glPushAttrib(GL_ALL_ATTRIB_BITS);

    (*Func)();

    if (glGetError() != GL_NO_ERROR) {
	FailAndDie();
    }
    glFlush();
    glPopAttrib();
}

void ZeroBuf(long type, long size, void *buf)
{
    long i;

    switch (type) {
	case GL_UNSIGNED_BYTE:
	    {
		unsigned char *ptr = (unsigned char *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_BYTE:
	    {
		char *ptr = (char *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_UNSIGNED_SHORT:
	    {
		unsigned short *ptr = (unsigned short *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_SHORT:
	    {
		short *ptr = (short *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_UNSIGNED_INT:
	    {
		unsigned long *ptr = (unsigned long *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_INT:
	    {
		long *ptr = (long *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_FLOAT:
	    {
		float *ptr = (float *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = (GLfloat)0;
		}
	    }
	    break;
    }
}

static void DoTests(void)
{

    VerifyEnums();

    ProbeError(CallGet);
    ProbeError(CallGetClipPlane);
    ProbeError(CallGetError);
    ProbeError(CallGetLight);
    ProbeError(CallGetMap);
    ProbeError(CallGetMaterial);
    ProbeError(CallGetPixelMap);
    ProbeError(CallGetPolygonStipple);
    ProbeError(CallGetString);
    ProbeError(CallGetTexEnv);
    ProbeError(CallGetTexGen);
    ProbeError(CallGetTexImage);
    ProbeError(CallGetTexLevelParameter);
    ProbeError(CallGetTexParameter);

    ProbeError(CallPushPopAttrib);

    ProbeError(CallEnableIsEnableDisable);

    ProbeError(CallHint);

    ProbeError(CallViewport);
    ProbeError(CallOrtho);
    ProbeError(CallFrustum);
    ProbeError(CallScissor);
    ProbeError(CallClipPlane);

    ProbeError(CallAccum);
    ProbeError(CallSelectBuffer);
    ProbeError(CallFeedbackBuffer);
/*
** XXX
**
    ProbeError(CallPassThrough);
*/
    ProbeError(CallInitNames);
    ProbeError(CallPushName);
    ProbeError(CallLoadName);
    ProbeError(CallPopName);

    ProbeError(CallLoadIdentity);
    ProbeError(CallMatrixMode);
    ProbeError(CallPushMatrix);
    ProbeError(CallLoadMatrix);
    ProbeError(CallMultMatrix);
    ProbeError(CallRotate);
    ProbeError(CallScale);
    ProbeError(CallTranslate);
    ProbeError(CallPopMatrix);

    ProbeError(CallClear);
    ProbeError(CallClearAccum);
    ProbeError(CallClearColor);
    ProbeError(CallClearDepth);
    ProbeError(CallClearIndex);
    ProbeError(CallClearStencil);

    ProbeError(CallColorMask);
    ProbeError(CallColor);
    ProbeError(CallIndexMask);
    ProbeError(CallIndex);

    ProbeError(CallVertex);
    ProbeError(CallNormal);

    ProbeError(CallAlphaFunc);
    ProbeError(CallBlendFunc);
    ProbeError(CallDepthFunc);
    ProbeError(CallDepthMask);
    ProbeError(CallDepthRange);
    ProbeError(CallLogicOp);
    ProbeError(CallStencilFunc);
    ProbeError(CallStencilMask);
    ProbeError(CallStencilOp);

    ProbeError(CallRenderMode);
    ProbeError(CallReadBuffer);
    ProbeError(CallDrawBuffer);
    ProbeError(CallRasterPos);
/*
 * Put CallPixelStore at end of this function - otherwise modes it sets
 * can cause access violations for subsequent tests such as CallTexImage1D.
 */
#if 0
    ProbeError(CallPixelStore);
#endif
    ProbeError(CallPixelTransfer);
    ProbeError(CallPixelZoom);
    ProbeError(CallReadDrawPixels);
    ProbeError(CallCopyPixels);
    ProbeError(CallPixelMap);

    ProbeError(CallFog);
    ProbeError(CallLightModel);
    ProbeError(CallLight);
    ProbeError(CallMaterial);
    ProbeError(CallColorMaterial);

    ProbeError(CallTexCoord);
    ProbeError(CallTexEnv);
    ProbeError(CallTexGen);
    ProbeError(CallTexParameter);

    ProbeError(CallTexImage1D);
    ProbeError(CallTexImage2D);

    ProbeError(CallShadeModel);
    ProbeError(CallPointSize);
    ProbeError(CallLineStipple);
    ProbeError(CallLineWidth);
    ProbeError(CallRect);
    ProbeError(CallPolygonMode);
    ProbeError(CallPolygonStipple);
    ProbeError(CallCullFace);
    ProbeError(CallEdgeFlag);
    ProbeError(CallFrontFace);
    ProbeError(CallBitmap);
    ProbeError(CallBeginEnd);

    ProbeError(CallMap1);
    ProbeError(CallMap2);
    ProbeError(CallEvalCoord);
    ProbeError(CallEvalPoint1);
    ProbeError(CallEvalPoint2);
    ProbeError(CallMapGrid1);
    ProbeError(CallMapGrid2);
    ProbeError(CallEvalMesh1);
    ProbeError(CallEvalMesh2);

    ProbeError(CallGenLists);
    ProbeError(CallNewEndList);
    ProbeError(CallIsList);
    ProbeError(CallCallList);
    ProbeError(CallListBase);
    ProbeError(CallCallLists);
    ProbeError(CallDeleteLists);

    ProbeError(CallFlush);
    ProbeError(CallFinish);
#if 1
    ProbeError(CallPixelStore);
#endif

    printf("covgl passed.\n\n");
}

static long Exec(TK_EventRec *ptr)
{

    if (ptr->event == TK_EVENT_EXPOSE) {
	DoTests();
	return 0;
    }
    return 1;
}

static long Init(int argc, char **argv)
{
long i;

    verbose = 0;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-h") == 0) {
	    printf("Options:\n");
	    printf("\t-h     Print this help screen.\n");
            printf("\t-a     [Default] Run tests on all pixel formats. \n");
            printf("\t-s     Run tests on all display pixel formats. \n");
            printf("\t-b     Run tests on all bitmap pixel formats. \n");
	    printf("\t-v     Verbose mode ON.\n");
	    printf("\n");
	    return 1;
	} else if (strcmp(argv[i], "-v") == 0) {
	    verbose = 1;
        } else if (strcmp(argv[i], "-a") == 0) {    // all display & bitmap fmt
            visualID = -99;
        } else if (strcmp(argv[i], "-s") == 0) {    // all display formats
            visualID = -98;
        } else if (strcmp(argv[i], "-b") == 0) {    // all bitmap formats
            visualID = -97;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return 1;
	}
    }
    return 0;
}

int main(int argc, char **argv)
{
    TK_WindowRec        wind;
    TK_VisualIDsRec     list;
    int                 i;
    BOOL                bTestAll = FALSE;

    printf("Open GL Coverage Test.\n");
    printf("Version 1.0.14\n");
    printf("\n");

    if (Init(argc, argv)) {
	tkQuit();
	return 1;
    }

    strcpy(wind.name, "Open GL Coverage Test");
    wind.x = CW_USEDEFAULT;
    wind.y = CW_USEDEFAULT;
    wind.width = WINSIZE;
    wind.height = WINSIZE;
    wind.eventMask = TK_EVENT_EXPOSE;

    switch (visualID) {
        case -99:   // test all display and bitmap pixel formats
            bTestAll = TRUE;
            // fall through

        case -98:   // test all display pixel formats
            tkGet(TK_VISUALIDS, (void *)&list);
            for (i = 0; i < list.count; i++) {
                wind.type = TK_WIND_VISUAL;
                wind.info = (GLint)list.IDs[i];
                wind.render = TK_WIND_DIRECT;
                if (tkNewWindow(&wind)) {
                    printf("Display ID %d \n", list.IDs[i]);
                    tkExec(Exec);
                    tkCloseWindow();
                } else {
                    printf("Display ID %d not found.\n\n", list.IDs[i]);
                }
            }
            if (!bTestAll)
                break;
            // fall through

        case -97:   // test all bitmap pixel formats
            tkGet(TK_VISUALIDS, (void *)&list);
            for (i = 0; i < list.count; i++) {
                wind.type = TK_WIND_VISUAL;
                wind.info = -(GLint)list.IDs[i];
                wind.render = TK_WIND_DIRECT;
                if (tkNewWindow(&wind)) {
                    printf("Bitmap ID %d \n", -list.IDs[i]);
                    tkExec(Exec);
                    tkCloseWindow();
                } else {
                    printf("Bitmap ID %d not found.\n\n", -list.IDs[i]);
                }
            }
            break;
        default:
            break;
    }
    tkQuit();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\t.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallTexCoord(void)
{
    GLfloat x, y, z, w;

    x = 1.0;
    y = 1.0;
    z = 1.0;
    w = 1.0;

    Output("glTexCoord1s, ");
    Output("glTexCoord1sv, ");
    Output("glTexCoord1i, ");
    Output("glTexCoord1iv, ");
    Output("glTexCoord1f, ");
    Output("glTexCoord1fv, ");
    Output("glTexCoord1d, ");
    Output("glTexCoord1dv, ");
    Output("glTexCoord2s, ");
    Output("glTexCoord2sv, ");
    Output("glTexCoord2i, ");
    Output("glTexCoord2iv, ");
    Output("glTexCoord2f, ");
    Output("glTexCoord2fv, ");
    Output("glTexCoord2d, ");
    Output("glTexCoord2dv, ");
    Output("glTexCoord3s, ");
    Output("glTexCoord3sv, ");
    Output("glTexCoord3i, ");
    Output("glTexCoord13iv, ");
    Output("glTexCoord3f, ");
    Output("glTexCoord3fv, ");
    Output("glTexCoord3d, ");
    Output("glTexCoord3dv, ");
    Output("glTexCoord4s, ");
    Output("glTexCoord4sv, ");
    Output("glTexCoord4i, ");
    Output("glTexCoord4iv, ");
    Output("glTexCoord4f, ");
    Output("glTexCoord4fv, ");
    Output("glTexCoord4d, ");
    Output("glTexCoord4dv\n");

    glTexCoord1s((GLshort)x);

    {
	GLshort buf[1];
	buf[0] = (GLshort)x;
	glTexCoord1sv(buf);
    }

    glTexCoord1i((GLint)x);

    {
	GLint buf[1];
	buf[0] = (GLint)x;
	glTexCoord1iv(buf);
    }

    glTexCoord1f((GLfloat)x);

    {
	GLfloat buf[1];
	buf[0] = (GLfloat)x;
	glTexCoord1fv(buf);
    }

    glTexCoord1d((GLdouble)x);

    {
	GLdouble buf[1];
	buf[0] = (GLdouble)x;
	glTexCoord1dv(buf);
    }

    glTexCoord2s((GLshort)x, (GLshort)y);

    {
	GLshort buf[2];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	glTexCoord2sv(buf);
    }

    glTexCoord2i((GLint)x, (GLint)y);

    {
	GLint buf[2];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	glTexCoord2iv(buf);
    }

    glTexCoord2f((GLfloat)x, (GLfloat)y);

    {
	GLfloat buf[2];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	glTexCoord2fv(buf);
    }

    glTexCoord2d((GLdouble)x, (GLdouble)y);

    {
	GLdouble buf[2];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	glTexCoord2dv(buf);
    }

    glTexCoord3s((GLshort)x, (GLshort)y, (GLshort)z);

    {
	GLshort buf[3];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	glTexCoord3sv(buf);
    }

    glTexCoord3i((GLint)x, (GLint)y, (GLint)z);

    {
	GLint buf[3];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	glTexCoord3iv(buf);
    }

    glTexCoord3f((GLfloat)x, (GLfloat)y, (GLfloat)z);

    {
	GLfloat buf[3];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	glTexCoord3fv(buf);
    }

    glTexCoord3d((GLdouble)x, (GLdouble)y, (GLdouble)z);

    {
	GLdouble buf[3];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	glTexCoord3dv(buf);
    }

    glTexCoord4s((GLshort)x, (GLshort)y, (GLshort)z, (GLshort)w);

    {
	GLshort buf[4];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	buf[3] = (GLshort)w;
	glTexCoord4sv(buf);
    }

    glTexCoord4i((GLint)x, (GLint)y, (GLint)z, (GLint)w);

    {
	GLint buf[4];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	buf[3] = (GLint)w;
	glTexCoord4iv(buf);
    }

    glTexCoord4f((GLfloat)x, (GLfloat)y, (GLfloat)z, (GLfloat)w);

    {
	GLfloat buf[4];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	buf[3] = (GLfloat)w;
	glTexCoord4fv(buf);
    }

    glTexCoord4d((GLdouble)x, (GLdouble)y, (GLdouble)z, (GLdouble)w);

    {
	GLdouble buf[4];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	buf[3] = (GLdouble)w;
	glTexCoord4dv(buf);
    }

    Output("\n");
}

void CallTexEnv(void)
{
    GLint i, j, k;

    Output("glTexEnvi, ");
    Output("glTexEnvf\n");
    for (i = 0; enum_TextureEnvTarget[i].value != -1; i++) {
	for (j = 0; enum_TextureEnvParameter[j].value != -1; j++) {
	   
	    if (enum_TextureEnvParameter[j].value == GL_TEXTURE_ENV_COLOR) {
		continue;
	    }

	    for (k = 0; enum_TextureEnvMode[k].value != -1; k++) {
		Output("\t%s, %s, %s\n", enum_TextureEnvTarget[i].name, enum_TextureEnvParameter[j].name, enum_TextureEnvMode[k].name);
		glTexEnvi(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, (GLint)enum_TextureEnvMode[k].value);
		glTexEnvf(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, (GLfloat)enum_TextureEnvMode[k].value);
		ProbeEnum();
	    }
	}
    }
    Output("\n");

    Output("glTexEnviv, ");
    Output("glTexEnvfv\n");
    for (i = 0; enum_TextureEnvTarget[i].value != -1; i++) {
	for (j = 0; enum_TextureEnvParameter[j].value != -1; j++) {
	    switch (enum_TextureEnvParameter[j].value) {
		case GL_TEXTURE_ENV_MODE:
		    for (k = 0; enum_TextureEnvMode[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureEnvTarget[i].name, enum_TextureEnvParameter[j].name, enum_TextureEnvMode[k].name);
			{
			    GLint buf[1];
			    buf[0] = (GLint)enum_TextureEnvMode[k].value;
			    glTexEnviv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
			}
			{
			    GLfloat buf[1];
			    buf[0] = (GLfloat)enum_TextureEnvMode[k].value;
			    glTexEnvfv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
			}
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_ENV_COLOR:
		    Output("\t%s, %s\n", enum_TextureEnvTarget[i].name, enum_TextureEnvParameter[j].name);
		    {
			static GLint buf[] = {
			    0, 0, 0, 0
			};
			glTexEnviv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
		    }
		    {
			static GLfloat buf[] = {
			    0.0, 0.0, 0.0, 0.0
			};
			glTexEnvfv(enum_TextureEnvTarget[i].value, enum_TextureEnvParameter[j].value, buf);
		    }
		    ProbeEnum();
		    break;
	    }
	}
    }
    Output("\n");
}

void CallTexGen(void)
{
    GLint i, j, k;

    Output("glTexGeni, ");
    Output("glTexGenf, ");
    Output("glTexGend\n");
    for (i = 0; enum_TextureCoordName[i].value != -1; i++) {
	for (j = 0; enum_TextureGenParameter[j].value != -1; j++) {

	    if (enum_TextureGenParameter[j].value == GL_OBJECT_PLANE) {
		continue;
	    } else if (enum_TextureGenParameter[j].value == GL_EYE_PLANE) {
		continue;
	    }

	    for (k = 0; enum_TextureGenMode[k].value != -1; k++) {
		if (enum_TextureGenMode[k].value == GL_SPHERE_MAP) {
		    if (enum_TextureCoordName[i].value == GL_R) {
			continue;
		    } else if (enum_TextureCoordName[i].value == GL_Q) {
			continue;
		    }
		}
		Output("\t%s, %s, %s\n", enum_TextureCoordName[i].name, enum_TextureGenParameter[j].name, enum_TextureGenMode[k].name);
		glTexGeni(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, (GLint)enum_TextureGenMode[k].value);
		glTexGenf(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, (GLfloat)enum_TextureGenMode[k].value);
		glTexGend(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, (GLdouble)enum_TextureGenMode[k].value);
		ProbeEnum();
	    }
	}
    }
    Output("\n");

    Output("glTexGeniv, ");
    Output("glTexGenfv, ");
    Output("glTexGendv\n");
    for (i = 0; enum_TextureCoordName[i].value != -1; i++) {
	for (j = 0; enum_TextureGenParameter[j].value != -1; j++) {
	    if (enum_TextureGenParameter[j].value == GL_TEXTURE_GEN_MODE) {
		for (k = 0; enum_TextureGenMode[k].value != -1; k++) {
		    if (enum_TextureGenMode[k].value == GL_SPHERE_MAP) {
			if (enum_TextureCoordName[i].value == GL_R) {
			    continue;
			} else if (enum_TextureCoordName[i].value == GL_Q) {
			    continue;
			}
		    }
		    Output("\t%s, %s, %s\n", enum_TextureCoordName[i].name, enum_TextureGenParameter[j].name, enum_TextureGenMode[k].name);
		    {
			GLint buf[1];
			buf[0] = (GLint)enum_TextureGenMode[k].value;
			glTexGeniv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		    }
		    {
			GLfloat buf[1];
			buf[0] = (GLfloat)enum_TextureGenMode[k].value;
			glTexGenfv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		    }
		    {
			GLdouble buf[1];
			buf[0] = (GLdouble)enum_TextureGenMode[k].value;
			glTexGendv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		    }
		    ProbeEnum();
		}
	    } else {
		{
		    static GLint buf[] = {
			0, 0, 0, 0
		    };
		    glTexGeniv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		}
		{
		    static GLfloat buf[] = {
			0.0, 0.0, 0.0, 0.0
		    };
		    glTexGenfv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		}
		{
		    static GLdouble buf[] = {
			0.0, 0.0, 0.0, 0.0
		    };
		    glTexGendv(enum_TextureCoordName[i].value, enum_TextureGenParameter[j].value, buf);
		}
		ProbeEnum();
	    }
	}
    }
    Output("\n");
}

void CallTexImage1D(void)
{
    GLubyte buf[1000];
    GLint component, i, j, k, l;

    Output("glTexImage1D\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_PixelFormat[j].value != -1; j++) {
	    for (k = 0; enum_PixelType[k].value != -1; k++) {
		for (l = 0; enum_TextureBorder[l].value != -1; l++) {

                    if (enum_TextureTarget[i].value == GL_TEXTURE_2D) {
			continue;
		    }
		    if (enum_PixelFormat[j].value == GL_COLOR_INDEX) {
			continue;
		    } else if (enum_PixelFormat[j].value == GL_STENCIL_INDEX) {
			continue;
		    } else if (enum_PixelFormat[j].value == GL_DEPTH_COMPONENT) {
			continue;
		    }
		    if (enum_PixelType[k].value == GL_BITMAP) {
			continue;
		    }

		    Output("\t%s, %s, %s, %s\n", enum_TextureTarget[i].name, enum_PixelFormat[j].name, enum_PixelType[k].name, enum_TextureBorder[l].name);
		    switch (enum_PixelFormat[j].value) {
			case GL_RED:
			    component = 1;
			    break;
			case GL_GREEN:
			    component = 1;
			    break;
			case GL_BLUE:
			    component = 1;
			    break;
			case GL_ALPHA:
			    component = 1;
			    break;
			case GL_RGB:
			    component = 3;
			    break;
			case GL_RGBA:
			    component = 4;
			    break;
			case GL_LUMINANCE:
			    component = 1;
			    break;
			case GL_LUMINANCE_ALPHA:
			    component = 2;
			    break;
		    }
		    ZeroBuf(enum_PixelType[k].value, 100, buf);
		    glTexImage1D(enum_TextureTarget[i].value, 0, component, (enum_TextureBorder[l].value) ? 3 : 1, enum_TextureBorder[l].value, enum_PixelFormat[j].value, enum_PixelType[k].value, buf);
		    ProbeEnum();
		}
	    }
	}
    }
    Output("\n");
}

void CallTexImage2D(void)
{
    GLubyte buf[1000];
    GLint component, i, j, k, l;

    Output("glTexImage2D\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_PixelFormat[j].value != -1; j++) {
	    for (k = 0; enum_PixelType[k].value != -1; k++) {
		for (l = 0; enum_TextureBorder[l].value != -1; l++) {

                    if (enum_TextureTarget[i].value == GL_TEXTURE_1D) {
			continue;
		    }
		    if (enum_PixelFormat[j].value == GL_COLOR_INDEX) {
			continue;
		    } else if (enum_PixelFormat[j].value == GL_STENCIL_INDEX) {
			continue;
		    } else if (enum_PixelFormat[j].value == GL_DEPTH_COMPONENT) {
			continue;
		    }
		    if (enum_PixelType[k].value == GL_BITMAP) {
			continue;
		    }

		    Output("\t%s, %s, %s, %s\n", enum_TextureTarget[i].name, enum_PixelFormat[j].name, enum_PixelType[k].name, enum_TextureBorder[l].name);
		    switch (enum_PixelFormat[j].value) {
			case GL_RED:
			    component = 1;
			    break;
			case GL_GREEN:
			    component = 1;
			    break;
			case GL_BLUE:
			    component = 1;
			    break;
			case GL_ALPHA:
			    component = 1;
			    break;
			case GL_RGB:
			    component = 3;
			    break;
			case GL_RGBA:
			    component = 4;
			    break;
			case GL_LUMINANCE:
			    component = 1;
			    break;
			case GL_LUMINANCE_ALPHA:
			    component = 2;
			    break;
		    }
		    ZeroBuf(enum_PixelType[k].value, 100, buf);
		    glTexImage2D(enum_TextureTarget[i].value, 0, component, (enum_TextureBorder[l].value) ? 3 : 1, (enum_TextureBorder[l].value) ? 3 : 1, enum_TextureBorder[l].value, enum_PixelFormat[j].value, enum_PixelType[k].value, buf);
		    ProbeEnum();
		}
	    }
	}
    }
    Output("\n");
}

void CallTexParameter(void)
{
    GLint i, j, k;

    Output("glTexParameteri, ");
    Output("glTexParameterf\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_TextureParameterName[j].value != -1; j++) {
	    switch (enum_TextureParameterName[j].value) {
		case GL_TEXTURE_WRAP_S:
		case GL_TEXTURE_WRAP_T:
		    for (k = 0; enum_TextureWrapMode[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureWrapMode[k].name);
			glTexParameteri(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLint)enum_TextureWrapMode[k].value);
			glTexParameterf(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLfloat)enum_TextureWrapMode[k].value);
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_MIN_FILTER:
		    for (k = 0; enum_TextureMinFilter[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureMinFilter[k].name);
			glTexParameteri(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLint)enum_TextureMinFilter[k].value);
			glTexParameterf(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLfloat)enum_TextureMinFilter[k].value);
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_MAG_FILTER:
		    for (k = 0; enum_TextureMagFilter[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureMagFilter[k].name);
			glTexParameteri(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLint)enum_TextureMagFilter[k].value);
			glTexParameterf(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, (GLfloat)enum_TextureMagFilter[k].value);
			ProbeEnum();
		    }
		    break;
	    }
	}
    }
    Output("\n");

    Output("glTexParameteriv, ");
    Output("glTexParameterfv\n");
    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
	for (j = 0; enum_TextureParameterName[j].value != -1; j++) {
	    switch (enum_TextureParameterName[j].value) {
		case GL_TEXTURE_WRAP_S:
		case GL_TEXTURE_WRAP_T:
		    for (k = 0; enum_TextureWrapMode[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureWrapMode[k].name);
			{
			    GLint buf[1];
			    buf[0] = (GLint)enum_TextureWrapMode[k].value;
			    glTexParameteriv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			{
			    GLfloat buf[1];
			    buf[0] = (GLfloat)enum_TextureWrapMode[k].value;
			    glTexParameterfv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_MIN_FILTER:
		    for (k = 0; enum_TextureMinFilter[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureMinFilter[k].name);
			{
			    GLint buf[1];
			    buf[0] = (GLint)enum_TextureMinFilter[k].value;
			    glTexParameteriv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			{
			    GLfloat buf[1];
			    buf[0] = (GLfloat)enum_TextureMinFilter[k].value;
			    glTexParameterfv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_MAG_FILTER:
		    for (k = 0; enum_TextureMagFilter[k].value != -1; k++) {
			Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name, enum_TextureMagFilter[k].name);
			{
			    GLint buf[1];
			    buf[0] = (GLint)enum_TextureMagFilter[k].value;
			    glTexParameteriv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			{
			    GLfloat buf[1];
			    buf[0] = (GLfloat)enum_TextureMagFilter[k].value;
			    glTexParameterfv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
			}
			ProbeEnum();
		    }
		    break;
		case GL_TEXTURE_BORDER_COLOR:
		    Output("\t%s, %s\n", enum_TextureTarget[i].name, enum_TextureParameterName[j].name);
		    {
			static GLint buf[] = {
			    0, 0, 0, 0
			};
			glTexParameteriv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
		    }
		    {
			static GLfloat buf[] = {
			    0.0, 0.0, 0.0, 0.0
			};
			glTexParameterfv(enum_TextureTarget[i].value, enum_TextureParameterName[j].value, buf);
		    }
		    ProbeEnum();
		    break;
	    }
	}
    }
    Output("\n");
}

void CallTranslate(void)
{

    Output("glTranslatef, ");
    Output("glTranslated\n");
    glTranslatef(1.0, 1.0, 1.0);
    glTranslated(1.0, 1.0, 1.0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\b.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallBeginCurve(void)
{

    Output("gluBeginCurve\n");
    gluBeginCurve(nurbObj);
    Output("\n");
}

void CallBeginPolygon(void)
{

    Output("gluBeginPolygon\n");
    gluBeginPolygon(tessObj);
    Output("\n");
}

void CallBeginSurface(void)
{

    Output("gluBeginSurface\n");
    gluBeginSurface(nurbObj);
    Output("\n");
}

void CallBeginTrim(void)
{

    Output("gluBeginTrim\n");
    gluBeginTrim(nurbObj);
    Output("\n");
}

void CallBuild1DMipmaps(void)
{
    unsigned char buf[1000];
    GLint component; 
    long x, i, j, k;

    Output("gluBuild1DMipmaps\n");

    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
        for (j = 0; enum_PixelFormat[j].value != -1; j++) {
            for (k = 0; enum_PixelType[k].value != -1; k++) {

		if (enum_TextureTarget[i].value == GL_TEXTURE_2D) {
		    continue;
		}
		if (enum_PixelFormat[j].value == GL_COLOR_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_STENCIL_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_DEPTH_COMPONENT) {
		    continue;
		}
		if (enum_PixelType[k].value == GL_BITMAP) {
		    continue;
		}

		Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_PixelFormat[j].name, enum_PixelType[k].name);
		switch (enum_PixelFormat[j].value) {
		    case GL_RED:
			component = 1;
			break;
		    case GL_GREEN:
			component = 1;
			break;
		    case GL_BLUE:
			component = 1;
			break;
		    case GL_ALPHA:
			component = 1;
			break;
		    case GL_RGB:
			component = 3;
			break;
		    case GL_RGBA:
			component = 4;
			break;
		    case GL_LUMINANCE:
			component = 1;
			break;
		    case GL_LUMINANCE_ALPHA:
			component = 2;
			break;
		}
		ZeroBuf(enum_PixelType[k].value, 100, buf);
		x = gluBuild1DMipmaps(enum_TextureTarget[i].value, component, 3, enum_PixelFormat[j].value, enum_PixelType[k].value, (void *)buf);
		ProbeEnum();
	    }
	}
    }

    Output("\n");
}

void CallBuild2DMipmaps(void)
{
    unsigned char buf[1000];
    GLint component; 
    long x, i, j, k;

    Output("gluBuild2DMipmaps\n");

    for (i = 0; enum_TextureTarget[i].value != -1; i++) {
        for (j = 0; enum_PixelFormat[j].value != -1; j++) {
            for (k = 0; enum_PixelType[k].value != -1; k++) {

		if (enum_TextureTarget[i].value == GL_TEXTURE_1D) {
		    continue;
		}
		if (enum_PixelFormat[j].value == GL_COLOR_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_STENCIL_INDEX) {
		    continue;
		} else if (enum_PixelFormat[j].value == GL_DEPTH_COMPONENT) {
		    continue;
		}
		if (enum_PixelType[k].value == GL_BITMAP) {
		    continue;
		}

		Output("\t%s, %s, %s\n", enum_TextureTarget[i].name, enum_PixelFormat[j].name, enum_PixelType[k].name);
		switch (enum_PixelFormat[j].value) {
		    case GL_RED:
			component = 1;
			break;
		    case GL_GREEN:
			component = 1;
			break;
		    case GL_BLUE:
			component = 1;
			break;
		    case GL_ALPHA:
			component = 1;
			break;
		    case GL_RGB:
			component = 3;
			break;
		    case GL_RGBA:
			component = 4;
			break;
		    case GL_LUMINANCE:
			component = 1;
			break;
		    case GL_LUMINANCE_ALPHA:
			component = 2;
			break;
		}
		ZeroBuf(enum_PixelType[k].value, 100, buf);
		x = gluBuild2DMipmaps(enum_TextureTarget[i].value, component, 3, 3, enum_PixelFormat[j].value, enum_PixelType[k].value, (void *)buf);
		ProbeEnum();
	    }
	}
    }

    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\v.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallVertex(void)
{
    GLfloat x, y, z, w;

    x = 1.0;
    y = 1.0;
    z = 1.0;
    w = 1.0;

    Output("glVertex2s, ");
    Output("glVertex2sv, ");
    Output("glVertex2i, ");
    Output("glVertex2iv, ");
    Output("glVertex2f, ");
    Output("glVertex2fv, ");
    Output("glVertex2d, ");
    Output("glVertex2dv, ");
    Output("glVertex3s, ");
    Output("glVertex3sv, ");
    Output("glVertex3i, ");
    Output("glVertex3iv, ");
    Output("glVertex3f, ");
    Output("glVertex3fv, ");
    Output("glVertex3d, ");
    Output("glVertex3dv, ");
    Output("glVertex4s, ");
    Output("glVertex4sv, ");
    Output("glVertex4i, ");
    Output("glVertex4iv, ");
    Output("glVertex4f, ");
    Output("glVertex4fv, ");
    Output("glVertex4d, ");
    Output("glVertex4dv\n");

    glVertex2s((GLshort)x, (GLshort)y);

    {
	GLshort buf[2];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	glVertex2sv(buf);
    }

    glVertex2i((GLint)x, (GLint)y);

    {
	GLint buf[2];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	glVertex2iv(buf);
    }

    glVertex2f((GLfloat)x, (GLfloat)y);

    {
	GLfloat buf[2];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	glVertex2fv(buf);
    }

    glVertex2d((GLdouble)x, (GLdouble)y);

    {
	GLdouble buf[2];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	glVertex2dv(buf);
    }

    glVertex3s((GLshort)x, (GLshort)y, (GLshort)z);

    {
	GLshort buf[3];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	glVertex3sv(buf);
    }

    glVertex3i((GLint)x, (GLint)y, (GLint)z);

    {
	GLint buf[3];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	glVertex3iv(buf);
    }

    glVertex3f((GLfloat)x, (GLfloat)y, (GLfloat)z);

    {
	GLfloat buf[3];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	glVertex3fv(buf);
    }

    glVertex3d((GLdouble)x, (GLdouble)y, (GLdouble)z);

    {
	GLdouble buf[3];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	glVertex3dv(buf);
    }

    glVertex4s((GLshort)x, (GLshort)y, (GLshort)z, (GLshort)w);

    {
	GLshort buf[4];
	buf[0] = (GLshort)x;
	buf[1] = (GLshort)y;
	buf[2] = (GLshort)z;
	buf[3] = (GLshort)w;
	glVertex4sv(buf);
    }

    glVertex4i((GLint)x, (GLint)y, (GLint)z, (GLint)w);

    {
	GLint buf[4];
	buf[0] = (GLint)x;
	buf[1] = (GLint)y;
	buf[2] = (GLint)z;
	buf[3] = (GLint)w;
	glVertex4iv(buf);
    }

    glVertex4f((GLfloat)x, (GLfloat)y, (GLfloat)z, (GLfloat)w);

    {
	GLfloat buf[4];
	buf[0] = (GLfloat)x;
	buf[1] = (GLfloat)y;
	buf[2] = (GLfloat)z;
	buf[3] = (GLfloat)w;
	glVertex4fv(buf);
    }

    glVertex4d((GLdouble)x, (GLdouble)y, (GLdouble)z, (GLdouble)w);

    {
	GLdouble buf[4];
	buf[0] = (GLdouble)x;
	buf[1] = (GLdouble)y;
	buf[2] = (GLdouble)z;
	buf[3] = (GLdouble)w;
	glVertex4dv(buf);
    }

    Output("\n");
}

void CallViewport(void)
{

    Output("glViewport\n");
    glViewport(0, 0, WINSIZE, WINSIZE);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\shell.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#ifdef NT

// Added these pragmas to suppress OGLCFM warnings.
//
#pragma warning(disable : 4244)  //Mips (conversion of double/float)
#pragma warning(disable : 4245)  //Mips (conversion of signed/unsigned)
#pragma warning(disable : 4007)  //x86  (main must be _cdecl)
#pragma warning(disable : 4236)  //x86
#pragma warning(disable : 4051)  //Alpha

#endif


#define WINSIZE 100


typedef struct _enumCheckRec {
    char name[40];
    GLenum value;
    GLenum true;
} enumCheckRec;

typedef struct _enumTestRec {
    char name[40];
    GLenum value;
} enumTestRec;


extern enumCheckRec enum_Check[];
extern enumTestRec enum_AccumOp[];
extern enumTestRec enum_AlphaFunction[];
extern enumTestRec enum_AttribMask[];
extern enumTestRec enum_BlendingFactorDest[];
extern enumTestRec enum_BlendingFactorSrc[];
extern enumTestRec enum_Boolean[];
extern enumTestRec enum_Enable[];
extern enumTestRec enum_ClearBufferMask[];
extern enumTestRec enum_ClipPlaneName[];
extern enumTestRec enum_ColorMaterialFace[];
extern enumTestRec enum_ColorMaterialParameter[];
extern enumTestRec enum_CullFaceMode[];
extern enumTestRec enum_DepthFunction[];
extern enumTestRec enum_DrawBufferMode[];
extern enumTestRec enum_ErrorCode[];
extern enumTestRec enum_FeedBackMode[];
extern enumTestRec enum_FeedBackToken[];
extern enumTestRec enum_FogMode[];
extern enumTestRec enum_FogParameter[];
extern enumTestRec enum_FrontFaceDirection[];
extern enumTestRec enum_GetPixelMap[];
extern enumTestRec enum_GetTarget[];
extern enumTestRec enum_HintMode[];
extern enumTestRec enum_HintTarget[];
extern enumTestRec enum_LightModelParameter[];
extern enumTestRec enum_LightName[];
extern enumTestRec enum_LightParameter[];
extern enumTestRec enum_ListMode[];
extern enumTestRec enum_ListNameType[];
extern enumTestRec enum_LogicOp[];
extern enumTestRec enum_MapGetTarget[];
extern enumTestRec enum_MapTarget[];
extern enumTestRec enum_MapGetTarget[];
extern enumTestRec enum_MaterialFace[];
extern enumTestRec enum_MaterialParameter[];
extern enumTestRec enum_MatrixMode[];
extern enumTestRec enum_MeshMode1[];
extern enumTestRec enum_MeshMode2[];
extern enumTestRec enum_PixelCopyType[];
extern enumTestRec enum_PixelFormat[];
extern enumTestRec enum_PixelMap[];
extern enumTestRec enum_PixelStore[];
extern enumTestRec enum_PixelTransfer[];
extern enumTestRec enum_PixelType[];
extern enumTestRec enum_PolygonMode[];
extern enumTestRec enum_BeginMode[];
extern enumTestRec enum_ReadBufferMode[];
extern enumTestRec enum_RenderingMode[];
extern enumTestRec enum_ShadingModel[];
extern enumTestRec enum_StencilFunction[];
extern enumTestRec enum_StencilOp[];
extern enumTestRec enum_StringName[];
extern enumTestRec enum_TextureBorder[];
extern enumTestRec enum_TextureCoordName[];
extern enumTestRec enum_TextureEnvMode[];
extern enumTestRec enum_TextureEnvParameter[];
extern enumTestRec enum_TextureEnvTarget[];
extern enumTestRec enum_TextureGenMode[];
extern enumTestRec enum_TextureGenParameter[];
extern enumTestRec enum_TextureWrapMode[];
extern enumTestRec enum_TextureMagFilter[];
extern enumTestRec enum_TextureMinFilter[];
extern enumTestRec enum_TextureParameterName[];
extern enumTestRec enum_GetTextureParameter[];
extern enumTestRec enum_TextureTarget[];


extern void FailAndDie(void);
extern void Output(char *, ...);
extern void ProbeError(void (*)(void));
extern void ProbeEnum(void);
extern void ZeroBuf(long, long, void *);

extern void VerifyEnums(void);

extern void CallAccum(void);
extern void CallAlphaFunc(void);
extern void CallBeginEnd(void);
extern void CallBitmap(void);
extern void CallBlendFunc(void);
extern void CallCallList(void);
extern void CallCallLists(void);
extern void CallClear(void);
extern void CallClearAccum(void);
extern void CallClearColor(void);
extern void CallClearDepth(void);
extern void CallClearIndex(void);
extern void CallClearStencil(void);
extern void CallClipPlane(void);
extern void CallColor(void);
extern void CallColorMask(void);
extern void CallColorMaterial(void);
extern void CallCopyPixels(void);
extern void CallCullFace(void);
extern void CallDeleteLists(void);
extern void CallDepthFunc(void);
extern void CallDepthMask(void);
extern void CallDepthRange(void);
extern void CallDrawBuffer(void);
extern void CallEdgeFlag(void);
extern void CallEnableIsEnableDisable(void);
extern void CallEvalCoord(void);
extern void CallEvalMesh1(void);
extern void CallEvalMesh2(void);
extern void CallEvalPoint1(void);
extern void CallEvalPoint2(void);
extern void CallFeedbackBuffer(void);
extern void CallFinish(void);
extern void CallFlush(void);
extern void CallFog(void);
extern void CallFrontFace(void);
extern void CallFrustum(void);
extern void CallGenLists(void);
extern void CallGet(void);
extern void CallGetClipPlane(void);
extern void CallGetLight(void);
extern void CallGetError(void);
extern void CallGetMap(void);
extern void CallGetMaterial(void);
extern void CallGetPixelMap(void);
extern void CallGetPolygonStipple(void);
extern void CallGetString(void);
extern void CallGetTexEnv(void);
extern void CallGetTexGen(void);
extern void CallGetTexImage(void);
extern void CallGetTexLevelParameter(void);
extern void CallGetTexParameter(void);
extern void CallHint(void);
extern void CallIndex(void);
extern void CallIndexMask(void);
extern void CallInitNames(void);
extern void CallIsList(void);
extern void CallLight(void);
extern void CallLightModel(void);
extern void CallLineStipple(void);
extern void CallLineWidth(void);
extern void CallListBase(void);
extern void CallLoadIdentity(void);
extern void CallLoadMatrix(void);
extern void CallLoadName(void);
extern void CallLogicOp(void);
extern void CallMap1(void);
extern void CallMap2(void);
extern void CallMapGrid1(void);
extern void CallMapGrid2(void);
extern void CallMaterial(void);
extern void CallMatrixMode(void);
extern void CallMultMatrix(void);
extern void CallNewEndList(void);
extern void CallNormal(void);
extern void CallOrtho(void);
extern void CallPassThrough(void);
extern void CallPixelMap(void);
extern void CallPixelStore(void);
extern void CallPixelTransfer(void);
extern void CallPixelZoom(void);
extern void CallPointSize(void);
extern void CallPolygonMode(void);
extern void CallPolygonStipple(void);
extern void CallPopMatrix(void);
extern void CallPopName(void);
extern void CallPushPopAttrib(void);
extern void CallPushMatrix(void);
extern void CallPushName(void);
extern void CallRasterPos(void);
extern void CallReadBuffer(void);
extern void CallReadDrawPixels(void);
extern void CallRect(void);
extern void CallRenderMode(void);
extern void CallRotate(void);
extern void CallScale(void);
extern void CallScissor(void);
extern void CallSelectBuffer(void);
extern void CallShadeModel(void);
extern void CallStencilFunc(void);
extern void CallStencilMask(void);
extern void CallStencilOp(void);
extern void CallTexCoord(void);
extern void CallTexEnv(void);
extern void CallTexGen(void);
extern void CallTexImage1D(void);
extern void CallTexImage2D(void);
extern void CallTexParameter(void);
extern void CallTranslate(void);
extern void CallVertex(void);
extern void CallViewport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\c.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallCylinder(void)
{

    Output("gluCylinder\n");
    gluCylinder(quadObj, 10.0, 10.0, 10.0, 4, 5);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\e.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallEndCurve(void)
{

    Output("gluEndCurve\n");
    gluEndCurve(nurbObj);
    Output("\n");
}

void CallEndPolygon(void)
{

    Output("gluEndPolygon\n");
    gluEndPolygon(tessObj);
    Output("\n");
}

void CallEndSurface(void)
{

    Output("gluEndSurface\n");
    gluEndSurface(nurbObj);
    Output("\n");
}

void CallEndTrim(void)
{

    Output("gluEndTrim\n");
    gluEndTrim(nurbObj);
    Output("\n");
}

void CallErrorString(void)
{
    const GLubyte *buf;
    long i;

    Output("gluErrorString\n");
    for (i = 0; enum_Error[i].value != -1; i++) {
	Output("\t%s\n", enum_Error[i].name);
	buf = gluErrorString(enum_Error[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\l.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallLoadSamplingMatrices(void)
{
    static GLfloat buf1[] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    static GLint buf2[] = {
	0, 0, 100, 100
    };

    Output("gluLoadSamplingMatrices\n");
    gluLoadSamplingMatrices(nurbObj, buf1, buf1, buf2);
    Output("\n");
}

void CallLookAt(void)
{

    Output("gluLookAt\n");
    gluLookAt(1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\g.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallGetNurbsProperty(void)
{
    GLfloat buf[100];
    long i;

    Output("gluGetNurbsProperty\n");
    for (i = 0; enum_NurbProperty[i].value != -1; i++) {

	if (enum_NurbProperty[i].value == GLU_MAP1_TRIM_2) {
	    continue;
	} else if (enum_NurbProperty[i].value == GLU_MAP1_TRIM_3) {
	    continue;
	}

	Output("\t%s\n", enum_NurbProperty[i].name);
	gluGetNurbsProperty(nurbObj, enum_NurbProperty[i].value, buf);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\enum.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <stdio.h>
#include "shell.h"
#include "ctk.h"


static struct EnumCheckRec {
    char *name;
    GLenum value;
    GLenum true;
} enumCheck[] = {
    {
	"GLU_INVALID_ENUM", GLU_INVALID_ENUM, 100900
    },
    {
	"GLU_INVALID_VALUE", GLU_INVALID_VALUE, 100901
    },
    {
	"GLU_OUT_OF_MEMORY", GLU_OUT_OF_MEMORY, 100902
    },
    {
	"GLU_TRUE", GLU_TRUE, 1
    },
    {
	"GLU_FALSE", GLU_FALSE, 0
    },
    {
	"GLU_SMOOTH", GLU_SMOOTH, 100000
    },
    {
	"GLU_FLAT", GLU_FLAT, 100001
    },
    {
	"GLU_NONE", GLU_NONE, 100002
    },
    {
	"GLU_POINT", GLU_POINT, 100010
    },
    {
	"GLU_LINE", GLU_LINE, 100011
    },
    {
	"GLU_FILL", GLU_FILL, 100012
    },
    {
	"GLU_SILHOUETTE", GLU_SILHOUETTE, 100013
    },
    {
	"GLU_OUTSIDE", GLU_OUTSIDE, 100020
    },
    {
	"GLU_INSIDE", GLU_INSIDE, 100021
    },
    {
	"GLU_BEGIN", GLU_BEGIN, 100100
    },
    {
	"GLU_VERTEX", GLU_VERTEX, 100101
    },
    {
	"GLU_END", GLU_END, 100102
    },
    {
	"GLU_ERROR", GLU_ERROR, 100103
    },
    {
	"GLU_EDGE_FLAG", GLU_EDGE_FLAG, 100104
    },
    {
	"GLU_CW", GLU_CW, 100120
    },
    {
	"GLU_CCW", GLU_CCW, 100121
    },
    {
	"GLU_INTERIOR", GLU_INTERIOR, 100122
    },
    {
	"GLU_EXTERIOR", GLU_EXTERIOR, 100123
    },
    {
	"GLU_UNKNOWN", GLU_UNKNOWN, 100124
    },
    {
	"GLU_TESS_ERROR1", GLU_TESS_ERROR1, 100151
    },
    {
	"GLU_TESS_ERROR2", GLU_TESS_ERROR2, 100152
    },
    {
	"GLU_TESS_ERROR3", GLU_TESS_ERROR3, 100153
    },
    {
	"GLU_TESS_ERROR4", GLU_TESS_ERROR4, 100154
    },
    {
	"GLU_TESS_ERROR5", GLU_TESS_ERROR5, 100155
    },
    {
	"GLU_TESS_ERROR6", GLU_TESS_ERROR6, 100156
    },
    {
	"GLU_TESS_ERROR7", GLU_TESS_ERROR7, 100157
    },
    {
	"GLU_TESS_ERROR8", GLU_TESS_ERROR8, 100158
    },
    {
	"GLU_AUTO_LOAD_MATRIX", GLU_AUTO_LOAD_MATRIX, 100200
    },
    {
	"GLU_CULLING", GLU_CULLING, 100201
    },
    {
	"GLU_SAMPLING_TOLERANCE", GLU_SAMPLING_TOLERANCE, 100203
    },
    {
	"GLU_DISPLAY_MODE", GLU_DISPLAY_MODE, 100204
    },
    {
	"GLU_MAP1_TRIM_2", GLU_MAP1_TRIM_2, 100210
    },
    {
	"GLU_MAP1_TRIM_3", GLU_MAP1_TRIM_3, 100211
    },
    {
	"GLU_OUTLINE_POLYGON", GLU_OUTLINE_POLYGON, 100240
    },
    {
	"GLU_OUTLINE_PATCH", GLU_OUTLINE_PATCH, 100241
    },
    {
	"GLU_NURBS_ERROR1", GLU_NURBS_ERROR1, 100251
    },
    {
	"GLU_NURBS_ERROR2", GLU_NURBS_ERROR2, 100252
    },
    {
	"GLU_NURBS_ERROR3", GLU_NURBS_ERROR3, 100253
    },
    {
	"GLU_NURBS_ERROR4", GLU_NURBS_ERROR4, 100254
    },
    {
	"GLU_NURBS_ERROR5", GLU_NURBS_ERROR5, 100255
    },
    {
	"GLU_NURBS_ERROR6", GLU_NURBS_ERROR6, 100256
    },
    {
	"GLU_NURBS_ERROR7", GLU_NURBS_ERROR7, 100257
    },
    {
	"GLU_NURBS_ERROR8", GLU_NURBS_ERROR8, 100258
    },
    {
	"GLU_NURBS_ERROR9", GLU_NURBS_ERROR9, 100259
    },
    {
	"GLU_NURBS_ERROR10", GLU_NURBS_ERROR10, 100260
    },
    {
	"GLU_NURBS_ERROR11", GLU_NURBS_ERROR11, 100261
    },
    {
	"GLU_NURBS_ERROR12", GLU_NURBS_ERROR12, 100262
    },
    {
	"GLU_NURBS_ERROR13", GLU_NURBS_ERROR13, 100263
    },
    {
	"GLU_NURBS_ERROR14", GLU_NURBS_ERROR14, 100264
    },
    {
	"GLU_NURBS_ERROR15", GLU_NURBS_ERROR15, 100265
    },
    {
	"GLU_NURBS_ERROR16", GLU_NURBS_ERROR16, 100266
    },
    {
	"GLU_NURBS_ERROR17", GLU_NURBS_ERROR17, 100267
    },
    {
	"GLU_NURBS_ERROR18", GLU_NURBS_ERROR18, 100268
    },
    {
	"GLU_NURBS_ERROR19", GLU_NURBS_ERROR19, 100269
    },
    {
	"GLU_NURBS_ERROR20", GLU_NURBS_ERROR20, 100270
    },
    {
	"GLU_NURBS_ERROR21", GLU_NURBS_ERROR21, 100271
    },
    {
	"GLU_NURBS_ERROR22", GLU_NURBS_ERROR22, 100272
    },
    {
	"GLU_NURBS_ERROR23", GLU_NURBS_ERROR23, 100273
    },
    {
	"GLU_NURBS_ERROR24", GLU_NURBS_ERROR24, 100274
    },
    {
	"GLU_NURBS_ERROR25", GLU_NURBS_ERROR25, 100275
    },
    {
	"GLU_NURBS_ERROR26", GLU_NURBS_ERROR26, 100276
    },
    {
	"GLU_NURBS_ERROR27", GLU_NURBS_ERROR27, 100277
    },
    {
	"GLU_NURBS_ERROR28", GLU_NURBS_ERROR28, 100278
    },
    {
	"GLU_NURBS_ERROR29", GLU_NURBS_ERROR29, 100279
    },
    {
	"GLU_NURBS_ERROR30", GLU_NURBS_ERROR30, 100280
    },
    {
	"GLU_NURBS_ERROR31", GLU_NURBS_ERROR31, 100281
    },
    {
	"GLU_NURBS_ERROR32", GLU_NURBS_ERROR32, 100282
    },
    {
	"GLU_NURBS_ERROR33", GLU_NURBS_ERROR33, 100283
    },
    {
	"GLU_NURBS_ERROR34", GLU_NURBS_ERROR34, 100284
    },
    {
	"GLU_NURBS_ERROR35", GLU_NURBS_ERROR35, 100285
    },
    {
	"GLU_NURBS_ERROR36", GLU_NURBS_ERROR36, 100286
    },
    {
	"GLU_NURBS_ERROR37", GLU_NURBS_ERROR37, 100287
    }
};


void VerifyEnums(void)
{
    struct EnumCheckRec *p, *end;

    p = enumCheck;
    end = p + (sizeof(enumCheck) / sizeof(struct EnumCheckRec));

    Output("Enumeration check.\n");
    while (p < end) {
	Output("\t%s (%d) = %d.\n", p->name, p->true, p->value);
	if (p->value != p->true) {
	    printf("covglu failed.\n\n");
	    tkQuit();
	}    
	p++;
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\d.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallDeleteNurbsRenderer(void)
{

    Output("gluDeleteNurbsRenderer\n");
    gluDeleteNurbsRenderer(nurbObj);
    Output("\n");
}

void CallDeleteQuadric(void)
{

    Output("gluDeleteQuadric\n");
    gluDeleteQuadric(quadObj);
    Output("\n");
}

void CallDeleteTess(void)
{

    Output("gluDeleteTess\n");
    gluDeleteTess(tessObj);
    Output("\n");
}

void CallDisk(void)
{

    Output("gluDisk\n");
    gluDisk(quadObj, 5.0, 10.0, 4, 5);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\data.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


enumTestRec enum_Error[] = {
    GLU_INVALID_ENUM, "GLU_INVALID_ENUM",
    GLU_INVALID_VALUE, "GLU_INVALID_VALUE",
    GLU_OUT_OF_MEMORY, "GLU_OUT_OF_MEMORY",
    -1, "End of List"
};

enumTestRec enum_NurbCallBack[] = {
    GLU_ERROR, "GLU_ERROR",
    -1, "End of List"
};

enumTestRec enum_NurbContour[] = {
    GLU_CW, "GLU_CW",
    GLU_CCW, "GLU_CCW",
    GLU_INTERIOR, "GLU_INTERIOR",
    GLU_EXTERIOR, "GLU_EXTERIOR",
    GLU_UNKNOWN, "GLU_UNKNOWN",
    -1, "End of List"
};

enumTestRec enum_NurbDisplay[] = {
    GLU_OUTLINE_POLYGON, "GLU_OUTLINE_POLYGON",
    GLU_OUTLINE_PATCH, "GLU_OUTLINE_PATCH",
    -1, "End of List"
};

enumTestRec enum_NurbProperty[] = {
    GLU_AUTO_LOAD_MATRIX, "GLU_AUTO_LOAD_MATRIX",
    GLU_CULLING, "GLU_CULLING",
    GLU_SAMPLING_TOLERANCE, "GLU_SAMPLING_TOLERANCE",
    GLU_DISPLAY_MODE, "GLU_DISPLAY_MODE",
    GLU_MAP1_TRIM_2, "GLU_MAP1_TRIM_2",
    GLU_MAP1_TRIM_3, "GLU_MAP1_TRIM_3",
    -1, "End of List"
};

enumTestRec enum_NurbType[] = {
    GL_MAP1_VERTEX_3, "GL_MAP1_VERTEX_3",
    GL_MAP1_VERTEX_4, "GL_MAP1_VERTEX_4",
    GL_MAP2_VERTEX_3, "GL_MAP2_VERTEX_3",
    GL_MAP2_VERTEX_4, "GL_MAP2_VERTEX_4",
    -1, "End of List"
};

enumTestRec enum_PixelFormat[] = {
    GL_COLOR_INDEX, "GL_COLOR_INDEX",
    GL_STENCIL_INDEX, "GL_STENCIL_INDEX",
    GL_DEPTH_COMPONENT, "GL_DEPTH_COMPONENT",
    GL_RED, "GL_RED",
    GL_GREEN, "GL_GREEN",
    GL_BLUE, "GL_BLUE",
    GL_ALPHA, "GL_ALPHA",
    GL_RGB, "GL_RGB",
    GL_RGBA, "GL_RGBA",
    GL_LUMINANCE, "GL_LUMINANCE",
    GL_LUMINANCE_ALPHA, "GL_LUMINANCE_ALPHA",
    -1, "End of List"
};

enumTestRec enum_PixelType[] = {
    GL_BITMAP, "GL_BITMAP",
    GL_BYTE, "GL_BYTE",
    GL_UNSIGNED_BYTE, "GL_UNSIGNED_BYTE",
    GL_SHORT, "GL_SHORT",
    GL_UNSIGNED_SHORT, "GL_UNSIGNED_SHORT",
    GL_INT, "GL_INT",
    GL_UNSIGNED_INT, "GL_UNSIGNED_INT",
    GL_FLOAT, "GL_FLOAT",
    -1, "End of List"
};

enumTestRec enum_QuadricCallBack[] = {
    GLU_ERROR, "GLU_ERROR",
    -1, "End of List"
};

enumTestRec enum_QuadricDraw[] = {
    GLU_POINT, "GLU_POINT",
    GLU_LINE, "GLU_LINE",
    GLU_FILL, "GLU_FILL",
    GLU_SILHOUETTE, "GLU_SILHOUETTE",
    -1, "End of List"
};

enumTestRec enum_QuadricNormal[] = {
    GLU_SMOOTH, "GLU_SMOOTH",
    GLU_FLAT, "GLU_FLAT",
    GLU_NONE, "GLU_NONE",
    -1, "End of List"
};

enumTestRec enum_QuadricOrientation[] = {
    GLU_OUTSIDE, "GLU_OUTSIDE",
    GLU_INSIDE, "GLU_INSIDE",
    -1, "End of List"
};

enumTestRec enum_TessCallBack[] = {
    GLU_BEGIN, "GLU_BEGIN",
    GLU_VERTEX, "GLU_VERTEX",
    GLU_END, "GLU_END",
    GLU_ERROR, "GLU_ERROR",
    GLU_EDGE_FLAG, "GLU_EDGE_FLAG",
    -1, "End of List"
};

enumTestRec enum_TextureTarget[] = {
    GL_TEXTURE_1D, "GL_TEXTURE_1D",
    GL_TEXTURE_2D, "GL_TEXTURE_2D",
    -1, "End of List"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\n.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallNewNurbsRenderer(void)
{

    Output("gluNewNurbsRenderer\n");
    nurbObj = gluNewNurbsRenderer();
    Output("\n");
}

void CallNewQuadric(void)
{

    Output("gluNewQuadric\n");
    quadObj = gluNewQuadric();
    Output("\n");
}

void CallNewTess(void)
{

    Output("gluNewTess\n");
    tessObj = gluNewTess();
    Output("\n");
}

void CallNextContour(void)
{
    long i;

    Output("gluNextContour\n");
    for (i = 0; enum_NurbContour[i].value != -1; i++) {
	Output("\t%s\n", enum_NurbContour[i].name);
	gluNextContour(tessObj, enum_NurbContour[i].value);
	ProbeEnum();
    }
    Output("\n");
}

static void CallBack(GLenum errno)
{

    return;
}

void CallNurbsCallback(void)
{
    long i;

    Output("gluNurbsCallback\n");
    for (i = 0; enum_NurbCallBack[i].value != -1; i++) {
	Output("\t%s\n", enum_NurbCallBack[i].name);
	gluNurbsCallback(nurbObj, enum_NurbCallBack[i].value, CallBack);
	ProbeEnum();
    }
    Output("\n");
}

void CallNurbsCurve(void)
{
    static GLfloat buf[] = {
	0.0, 0.0, 1.0
    };
    long i;

    Output("gluNurbsCurve\n");
    for (i = 0; enum_NurbType[i].value != -1; i++) {

	if (enum_NurbType[i].value == GL_MAP2_VERTEX_3) {
	    continue;
	} else if (enum_NurbType[i].value == GL_MAP2_VERTEX_4) {
	    continue;
	}

	Output("\t%s\n", enum_NurbType[i].name);
	gluNurbsCurve(nurbObj, 1, buf, 1, buf, 1, enum_NurbType[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallNurbsProperty(void)
{
    long i;

    Output("gluNurbsProperty\n");
    for (i = 0; enum_NurbProperty[i].value != -1; i++) {
	Output("\t%s\n", enum_NurbProperty[i].name);
	gluNurbsProperty(nurbObj, enum_NurbProperty[i].value, GL_FALSE);
	ProbeEnum();
    }
    Output("\n");
}

void CallNurbsSurface(void)
{
    static GLfloat buf[] = {
	0.0, 0.0, 1.0
    };
    long i;

    Output("gluNurbsSurface\n");
    for (i = 0; enum_NurbType[i].value != -1; i++) {

	if (enum_NurbType[i].value == GL_MAP1_VERTEX_3) {
	    continue;
	} else if (enum_NurbType[i].value == GL_MAP1_VERTEX_4) {
	    continue;
	}

	Output("\t%s\n", enum_NurbType[i].name);
	gluNurbsSurface(nurbObj, 1, buf, 1, buf, 1, 1, buf, 1, 1, enum_NurbType[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\o.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallOrtho2D(void)
{

    Output("gluOrtho2D\n");
    gluOrtho2D(0.0, 100.0, 0.0, 100.0);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\p.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallPartialDisk(void)
{

    Output("gluPartialDisk\n");
    gluPartialDisk(quadObj, 5.0, 10.0, 4, 5, 0.0, 0.5);
    Output("\n");
}

void CallPerspective(void)
{

    Output("gluPerspective\n");
    gluPerspective(0.0, 1.0, 0.0, -1.0);
    Output("\n");
}

void CallPickMatrix(void)
{
    static GLint buf[] = {
	0, 0, 100, 100
    };

    Output("gluPickMatrix\n");
    gluPickMatrix(0.0, 0.0, 100.0, 100.0, buf);
    Output("\n");
}

void CallProject(void)
{
    static GLdouble buf1[] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    static GLint buf2[] = {
	0, 0, 100, 100
    };
    GLdouble buf3;
    long x;

    Output("gluProject\n");
    x = gluProject(0.0, 0.0, 0.0, buf1, buf1, buf2, &buf3, &buf3, &buf3);
    Output("\n");
}

void CallPwlCurve(void)
{
    static GLfloat buf[] = {
	0.0, 0.0, 1.0,
    };
    long i;

    Output("gluPwlCurve\n");
    for (i = 0; enum_NurbProperty[i].value != -1; i++) {

	if (enum_NurbProperty[i].value == GLU_AUTO_LOAD_MATRIX) {
	    continue;
	} else if (enum_NurbProperty[i].value == GLU_CULLING) {
	    continue;
	} else if (enum_NurbProperty[i].value == GLU_SAMPLING_TOLERANCE) {
	    continue;
	} else if (enum_NurbProperty[i].value == GLU_DISPLAY_MODE) {
	    continue;
	} else if (enum_NurbProperty[i].value == GLU_MAP1_TRIM_2) {
	    continue;
	}

	Output("\t%s\n", enum_NurbProperty[i].name);
	gluPwlCurve(nurbObj, 1, buf, 1, enum_NurbProperty[i].value);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\t.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


static void CallBackError(GLenum errno)
{

    return;
}

void CallTessCallback(void)
{
    Output("gluTessCallback\n");

    Output("\t%s\n", "GLU_BEGIN");
    gluTessCallback(tessObj, GLU_BEGIN, glBegin);
    ProbeEnum();

    Output("\t%s\n", "GLU_VERTEX");
    gluTessCallback(tessObj, GLU_VERTEX, glVertex4fv);
    ProbeEnum();

    Output("\t%s\n", "GLU_END");
    gluTessCallback(tessObj, GLU_END, glEnd);
    ProbeEnum();

    Output("\t%s\n", "GLU_EDGE_FLAG");
    gluTessCallback(tessObj, GLU_EDGE_FLAG, glEdgeFlag);
    ProbeEnum();

    Output("\t%s\n", "GLU_ERROR");
    gluTessCallback(tessObj, GLU_ERROR, CallBackError);
    ProbeEnum();

    Output("\n");
}

void CallTessVertex(void)
{
    static GLdouble buf[] = {
	0.0, 0.0, 0.0
    };

    Output("gluTessVertex\n");
    gluTessVertex(tessObj, buf, buf);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\u.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallUnProject(void)
{
    static GLdouble buf1[] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    static GLint buf2[] = {
	0, 0, 100, 100
    };
    GLdouble buf3;
    long x;

    Output("gluUnProject\n");
    x = gluUnProject(0.0, 0.0, 0.0, buf1, buf1, buf2, &buf3, &buf3, &buf3);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\s.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


void CallScaleImage(void)
{
    char buf1[1000], buf2[1000];
    long x, i, j, k;

    Output("gluScaleImage\n");
    for (i = 0; enum_PixelFormat[i].value != -1; i++) {
        for (j = 0; enum_PixelType[j].value != -1; j++) {
	    for (k = 0; enum_PixelType[k].value != -1; k++) {
		Output("\t%s, %s, %s\n", enum_PixelFormat[i].name, enum_PixelType[j].name, enum_PixelType[k].name);
		ZeroBuf(enum_PixelType[j].value, 8, buf1);
		x = gluScaleImage(enum_PixelFormat[i].value, 1, 1, enum_PixelType[j].value, (void *)buf1, 1, 1, enum_PixelType[k].value, (void *)buf2);
		ProbeEnum();
	    }
	}
    }
    Output("\n");
}

void CallSphere(void)
{

    Output("gluSphere\n");
    gluSphere(quadObj, 5.0, 4, 5);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\q.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "shell.h"


static void CallBack(GLenum errno)
{

    return;
}

void CallQuadricCallback(void)
{
    long i;

    Output("gluQuadricCallback\n");
    for (i = 0; enum_QuadricCallBack[i].value != -1; i++) {
	Output("\t%s\n", enum_QuadricCallBack[i].name);
	gluQuadricCallback(quadObj, enum_QuadricCallBack[i].value, CallBack);
	ProbeEnum();
    }
    Output("\n");
}

void CallQuadricDrawStyle(void)
{
    long i;

    Output("gluQuadricDrawStyle\n");
    for (i = 0; enum_QuadricDraw[i].value != -1; i++) {
	Output("\t%s\n", enum_QuadricDraw[i].name);
	gluQuadricDrawStyle(quadObj, enum_QuadricDraw[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallQuadricNormals(void)
{
    long i;

    Output("gluQuadricNormals\n");
    for (i = 0; enum_QuadricNormal[i].value != -1; i++) {
	Output("\t%s\n", enum_QuadricNormal[i].name);
	gluQuadricNormals(quadObj, enum_QuadricNormal[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallQuadricOrientation(void)
{
    long i;

    Output("gluQuadricOrientation\n");
    for (i = 0; enum_QuadricOrientation[i].value != -1; i++) {
	Output("\t%s\n", enum_QuadricOrientation[i].name);
	gluQuadricOrientation(quadObj, enum_QuadricOrientation[i].value);
	ProbeEnum();
    }
    Output("\n");
}

void CallQuadricTexture(void)
{

    Output("gluQuadricTexture\n");
    Output("\tGL_TRUE\n");
    gluQuadricTexture(quadObj, GL_TRUE);
    Output("\tGL_FALSE\n");
    gluQuadricTexture(quadObj, GL_FALSE);
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\shell.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include "ctk.h"
#include "shell.h"


long verbose;
GLUnurbsObj *nurbObj;
GLUtriangulatorObj *tessObj;
GLUquadricObj *quadObj;


void Output(char *format, ...)
{
    va_list args;

    va_start(args, format);
    if (verbose) {
	vprintf(format, args);
	fflush(stdout);
    }
    va_end(args);
}

void ProbeEnum(void)
{

    if (glGetError() == GL_INVALID_ENUM) {
	printf("covglu failed.\n\n");
	tkQuit();
    }
}

void ProbeError(void (*Func)(void))
{

    (*Func)();
    if (glGetError() != GL_NO_ERROR) {
	printf("covglu failed.\n\n");
	tkQuit();
    }
}

void ZeroBuf(GLenum type, long size, void *buf)
{
    long i;

    switch (type) {
	case GL_UNSIGNED_BYTE:
	    {
		GLubyte *ptr = (GLubyte *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_BYTE:
	    {
		GLbyte *ptr = (GLbyte *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_UNSIGNED_SHORT:
	    {
		GLushort *ptr = (GLushort *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_SHORT:
	    {
		GLshort *ptr = (GLshort *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_UNSIGNED_INT:
	    {
		GLuint *ptr = (GLuint *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_INT:
	    {
		GLint *ptr = (GLint *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = 0;
		}
	    }
	    break;
	case GL_FLOAT:
	    {
		GLfloat *ptr = (GLfloat *)buf;
		for (i = 0; i < size; i++) {
		    *ptr++ = (GLfloat)0;
		}
	    }
	    break;
    }
}

void DoTests(void)
{

    VerifyEnums();

    ProbeError(CallScaleImage);

    ProbeError(CallBuild1DMipmaps);
    ProbeError(CallBuild2DMipmaps);

    ProbeError(CallNewTess);
    ProbeError(CallTessCallback);
    ProbeError(CallBeginPolygon);
    ProbeError(CallTessVertex);
    ProbeError(CallNextContour);
    ProbeError(CallEndPolygon);
    ProbeError(CallDeleteTess);

    ProbeError(CallNewQuadric);
    ProbeError(CallQuadricCallback);
    ProbeError(CallQuadricDrawStyle);
    ProbeError(CallQuadricOrientation);
    ProbeError(CallQuadricNormals);
    ProbeError(CallQuadricTexture);
    ProbeError(CallSphere);
    ProbeError(CallCylinder);
    ProbeError(CallDisk);
    ProbeError(CallPartialDisk);
    ProbeError(CallDeleteQuadric);

    ProbeError(CallNewNurbsRenderer);
    ProbeError(CallNurbsCallback);
    ProbeError(CallGetNurbsProperty);
    ProbeError(CallBeginSurface);
    ProbeError(CallBeginCurve);
    ProbeError(CallNurbsCurve);
    ProbeError(CallEndCurve);
    ProbeError(CallBeginTrim);
    ProbeError(CallPwlCurve);
    ProbeError(CallEndTrim);
    ProbeError(CallNurbsSurface);
    ProbeError(CallEndSurface);
    ProbeError(CallNurbsProperty);
    ProbeError(CallLoadSamplingMatrices);
    ProbeError(CallDeleteNurbsRenderer);

    ProbeError(CallOrtho2D);
    ProbeError(CallPerspective);
    ProbeError(CallLookAt);
    ProbeError(CallProject);
    ProbeError(CallUnProject);

    ProbeError(CallPickMatrix);

    ProbeError(CallErrorString);

    printf("covglu passed.\n\n");
}

long Exec(TK_EventRec *ptr)
{

    if (ptr->event == TK_EVENT_EXPOSE) {
	DoTests();
	return 0;
    }
    return 1;
}

static void phelp()
{
    printf("Options:\n");
    printf("\t-help     Print this help screen.\n");
    printf("\t-v        Verbose mode ON.\n");
    printf("\n");
}

static long Init(int argc, char **argv)
{
    long i;

    verbose = 0;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-help") == 0) {
	    phelp();
	    return 1;
	} else if (strcmp(argv[i], "-h") == 0) {
	    phelp();
	    return 1;
	} else if (strcmp(argv[i], "-?") == 0) {
	    phelp();
	    return 1;
	} else if (strcmp(argv[i], "-v") == 0) {
	    verbose = 1;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    phelp();
	    return 1;
	}
    }
    return 0;
}

int main(int argc, char **argv)
{
    TK_WindowRec wind;

    printf("OpenGL GLU Coverage Test.\n");
    printf("Version 1.0.15\n");
    printf("\n");

    if (Init(argc, argv)) {
	tkQuit();
	return 1;
    }

    strcpy(wind.name, "GLU Coverage Test");
    wind.x = 0;
    wind.y = 0;
    wind.width = WINSIZE;
    wind.height = WINSIZE;
    wind.type = TK_WIND_REQUEST;
    wind.eventMask = TK_EVENT_EXPOSE;
    wind.render = TK_WIND_DIRECT;

    wind.info = TK_WIND_SB |TK_WIND_RGB | TK_WIND_STENCIL | TK_WIND_Z |
                TK_WIND_ACCUM;

    if (tkNewWindow(&wind)) {
	tkExec(Exec);
    } else {
        wind.info = TK_WIND_DB |TK_WIND_RGB | TK_WIND_STENCIL | TK_WIND_Z |
                    TK_WIND_ACCUM;

        if (tkNewWindow(&wind)) {
            tkExec(Exec);
        } else {
	    printf("Visual requested not found.\n");
        }
    }

    tkQuit();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covglu\shell.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <GL/glu.h>

#ifdef NT

// Added these pragmas to suppress OGLCFM warnings.
//
#pragma warning(disable : 4244)  //Mips (conversion of double/float)
#pragma warning(disable : 4245)  //Mips (conversion of signed/unsigned)
#pragma warning(disable : 4007)  //x86  (main must be _cdecl)
#pragma warning(disable : 4236)  //x86
#pragma warning(disable : 4051)  //Alpha

#endif


#define WINSIZE 100


typedef struct _enumTestRec {
    GLenum value;
    char name[40];
} enumTestRec;


extern GLUnurbsObj *nurbObj;
extern GLUtriangulatorObj *tessObj;
extern GLUquadricObj *quadObj;
extern enumTestRec enum_Error[];
extern enumTestRec enum_NurbCallBack[];
extern enumTestRec enum_NurbContour[];
extern enumTestRec enum_NurbDisplay[];
extern enumTestRec enum_NurbProperty[];
extern enumTestRec enum_NurbType[];
extern enumTestRec enum_PixelFormat[];
extern enumTestRec enum_PixelType[];
extern enumTestRec enum_QuadricCallBack[];
extern enumTestRec enum_QuadricDraw[];
extern enumTestRec enum_QuadricNormal[];
extern enumTestRec enum_QuadricOrientation[];
extern enumTestRec enum_foo[];
extern enumTestRec enum_TessCallBack[];
extern enumTestRec enum_TextureTarget[];


extern void ProbeEnum(void);
extern void ProbeError(void (*)(void));
extern void Output(char *, ...);
extern void ZeroBuf(GLenum, long, void *);

extern void VerifyEnums(void);
extern void CallBeginCurve(void);
extern void CallBeginPolygon(void);
extern void CallBeginSurface(void);
extern void CallBeginTrim(void);
extern void CallBuild1DMipmaps(void);
extern void CallBuild2DMipmaps(void);
extern void CallCylinder(void);
extern void CallDeleteNurbsRenderer(void);
extern void CallDeleteQuadric(void);
extern void CallDeleteTess(void);
extern void CallDisk(void);
extern void CallEndCurve(void);
extern void CallEndPolygon(void);
extern void CallEndSurface(void);
extern void CallEndTrim(void);
extern void CallErrorString(void);
extern void CallGetNurbsProperty(void);
extern void CallLoadSamplingMatrices(void);
extern void CallLookAt(void);
extern void CallNewNurbsRenderer(void);
extern void CallNewQuadric(void);
extern void CallNewTess(void);
extern void CallNextContour(void);
extern void CallNurbsCallback(void);
extern void CallNurbsCurve(void);
extern void CallNurbsProperty(void);
extern void CallNurbsSurface(void);
extern void CallOrtho2D(void);
extern void CallPartialDisk(void);
extern void CallPerspective(void);
extern void CallPickMatrix(void);
extern void CallProject(void);
extern void CallPwlCurve(void);
extern void CallQuadricCallback(void);
extern void CallQuadricDrawStyle(void);
extern void CallQuadricNormals(void);
extern void CallQuadricOrientation(void);
extern void CallQuadricTexture(void);
extern void CallScaleImage(void);
extern void CallSphere(void);
extern void CallTessCallback(void);
extern void CallTessVertex(void);
extern void CallUnProject(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\ctk\ctk.h ===
#include <GL/gl.h>
#include <GL/glu.h>


/*
** ToolKit Window Structure
*/

typedef struct _TK_WindowRec {
    char name[100];
    long x, y;
    long width, height;
    long type, info, render;
    long eventMask;
} TK_WindowRec;

/*
** ToolKit Message Structure
*/

typedef struct _TK_EventRec {
    long event;
    long data[4];
} TK_EventRec;

/*
** Get/Set Structures
*/

typedef struct _TK_ScreenImageRec {
    long x, y;
    long width, height;
    long colorMode;
    float *data;
} TK_ScreenImageRec;

typedef struct _TK_VisualIDsRec {
    long count;
    long IDs[100];
} TK_VisualIDsRec;

/*
** ToolKit Window Types
*/

#define TK_WIND_REQUEST         0
#define TK_WIND_VISUAL          1
#define TK_WIND_RGB		0
#define TK_WIND_CI		1
#define TK_WIND_SB		0
#define TK_WIND_DB		2
#define TK_WIND_INDIRECT	0
#define TK_WIND_DIRECT		1

/* 
** ToolKit Window Masks
*/

#define TK_WIND_IS_RGB(x)	(((x) & TK_WIND_CI) == 0)
#define TK_WIND_IS_CI(x)	((x) & TK_WIND_CI)
#define TK_WIND_IS_SB(x)	(((x) & TK_WIND_DB) == 0)
#define TK_WIND_IS_DB(x)	((x) & TK_WIND_DB)
#define TK_WIND_STENCIL         8
#define TK_WIND_Z               16
#define TK_WIND_ACCUM           32
#define TK_WIND_AUX             64
#define TK_WIND_Z16             128

/* 
** ToolKit Event
*/

#define TK_EVENT_EXPOSE		1

/*
** Toolkit Event Data Indices
*/

#define TK_WINDOWX		0
#define TK_WINDOWY		1

/*
** ToolKit Gets and Sets
*/

enum {
    TK_SCREENIMAGE,
    TK_VISUALIDS
};


extern void tkCloseWindow(void);
extern long tkDrawFont(char *, long, long, char *, long);
extern void tkGet(long, void *);
extern void tkExec(long (*)(TK_EventRec *));
extern long tkLoadFont(char *, long *, long *);
extern long tkNewWindow(TK_WindowRec *);
extern void tkQuit(void);
extern void tkSwapBuffers(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\ctk\ctkw.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <windows.h>
#include "ctk.h"

//#define static

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif

#if DBG
#define TKASSERT(x)                                     \
if ( !(x) ) {                                           \
    PrintMessage("%s(%d) Assertion failed %s\n",        \
        __FILE__, __LINE__, #x);                        \
}
#else
#define TKASSERT(x)
#endif  /* DBG */

/********************************************************************/

static long NoOpExecFunc( TK_EventRec *pEvent );

static long (*ExecFunc)(TK_EventRec *pEvent ) = NoOpExecFunc;

static TK_EventRec tkEvent =    {
                                    TK_EVENT_EXPOSE,
                                    { 0, 0, 0, 0 }
                                };

static HWND     tkhwnd          = NULL;
static HDC      tkhdc           = NULL;
static HDC      tkhmemdc        = NULL;
static HGLRC    tkhrc           = NULL;
static HPALETTE tkhPalette      = NULL;
static char    *lpszClassName   = "ctkLibWClass";

static long  tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam);
static VOID  StorePixelFormatsIDs( TK_VisualIDsRec *VisualID );
static void  PrintMessage( const char *Format, ... );
static HGLRC CreateAndMakeContextCurrent( HDC Dc );
static void  CleanUp( void );
static void  DestroyThisWindow( HWND Window );
static short FindPixelFormat( HDC Dc, long FormatType );
static short GetPixelFormatInformation( HDC Dc, TK_WindowRec *tkWr, PIXELFORMATDESCRIPTOR *Pfd );
static TK_WindowRec *PIXELFORMATDESCRIPTOR_To_TK_WindowRec ( TK_WindowRec *WindowRec, PIXELFORMATDESCRIPTOR *Pfd );

HDC           CreatePixelMapDC(HDC,TK_WindowRec *,UINT, int, LPPIXELFORMATDESCRIPTOR);
BOOL          DeletePixelMapDC(HDC);

// Fixed palette support.

#define BLACK   PALETTERGB(0,0,0)
#define WHITE   PALETTERGB(255,255,255)
#define NUM_STATIC_COLORS   (COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1)

// TRUE if app wants to take over palette
static BOOL tkUseStaticColors = FALSE;

// TRUE if static system color settings have been replaced with B&W settings.
static BOOL tkSystemColorsInUse = FALSE;

// TRUE if static colors have been saved
static BOOL tkStaticSaved = FALSE;

// saved system static colors
static COLORREF gacrSave[NUM_STATIC_COLORS];

// new B&W system static colors
static COLORREF gacrBlackAndWhite[NUM_STATIC_COLORS] = {
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK   // COLOR_BTNHIGHLIGHT
    };
static INT gaiStaticIndex[NUM_STATIC_COLORS] = {
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT
    };


static VOID SaveStaticEntries(HDC);
static VOID UseStaticEntries(HDC);
static VOID RestoreStaticEntries(HDC);


/********************************************************************/

void tkCloseWindow(void)
{
    DestroyThisWindow(tkhwnd);
}

/********************************************************************/

long tkWndProc(HWND hWnd, UINT message, DWORD wParam, LONG lParam)
{
    PAINTSTRUCT Paint;

    switch (message)
    {
        case WM_PAINT:
            BeginPaint( hWnd, &Paint );

            if (!(*ExecFunc)(&tkEvent))
            {
                tkCloseWindow();
            }

            EndPaint( hWnd, &Paint );

            break;

        case WM_GETMINMAXINFO:
            {
                LPMINMAXINFO lpmmi = (LPMINMAXINFO) lParam;

                lpmmi->ptMinTrackSize.x = 1;
                lpmmi->ptMinTrackSize.y = 1;

            }
            return 0;

        case WM_DESTROY:

            CleanUp();
            PostQuitMessage(TRUE);
            return(DefWindowProc( hWnd, message, wParam, lParam));
    }
    return(DefWindowProc( hWnd, message, wParam, lParam));
}

void tkExec( long (*Func)(TK_EventRec *pEvent) )
{
    MSG Message;

    // WM_SIZE gets delivered before we get here!

    if ( NULL != Func )
    {
        ExecFunc = Func;        /* save a pointer to the drawing function */
    }
    else
    {
        ExecFunc = NoOpExecFunc;
    }

    while (GL_TRUE)
    {
        if (GetMessage(&Message, NULL, 0, 0) )
        {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
        else
        {
            break;
        }
    }
}

static long
NoOpExecFunc( TK_EventRec *pEvent )
{
    return(1);
}

/********************************************************************/

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Gamma correction factor * 10
#define GAMMA_CORRECTION 10

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Conversion tables for n bits to eight bits

#if GAMMA_CORRECTION == 10
// These tables are corrected for a gamma of 1.0
static unsigned char abThreeToEight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};
static unsigned char abTwoToEight[4] =
{
    0, 0x55, 0xaa, 0xff
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#else
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};
#endif

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
#if GAMMA_CORRECTION == 10
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245,
    247, 164, 156, 7, 56, 63, 192, 199, 248, 255
};
#else
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};
#endif

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    TKASSERT(nbits >= 1 && nbits <= 3);
    
    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* UpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

static void
UpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = GetStockObject(DEFAULT_PALETTE);

    // The system should always have one of these
    TKASSERT(hpalStock != NULL);
    // Make sure there's the correct number of entries
    TKASSERT(GetPaletteEntries(hpalStock, 0, 0, NULL) == STATIC_COLORS);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                TKASSERT(pe332->peFlags != COLOR_USED);
                
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        TKASSERT(iMinEntry != -1);

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }

#if 0
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        PrintMessage("Static color %2d maps to %d\n",
                     iStatic, aiDefaultOverride[iStatic]);
    }
#endif
}

#define SwapPalE(i,j) { \
    PALETTEENTRY palE; \
    palE = pPal->palPalEntry[i]; \
    pPal->palPalEntry[i] = pPal->palPalEntry[j]; \
    pPal->palPalEntry[j] = palE; }

/******************************Public*Routine******************************\
* SaveStaticEntries
*
* Save the current static system color settings.  This should be called
* prior to UseStaticEntries() to initialize gacrSave.  Once gacrSave is
* called, RestoreStaticEntries() can be called to restore the static system
* color settings.
*
* The colors can be saved only if the tk palette is the background palette.
* This check is done so that we do not accidentally replace the saved
* settings with the B&W settings used when static system color usage is set
* and the fixed 332 rgb palette is realized in the foreground.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static VOID SaveStaticEntries(HDC hdc)
{
    int i;

    if ( !tkSystemColorsInUse )
    {
        for (i = COLOR_SCROLLBAR; i <= COLOR_BTNHIGHLIGHT; i++)
            gacrSave[i - COLOR_SCROLLBAR] = GetSysColor(i);

        tkStaticSaved = TRUE;
    }
}


/******************************Public*Routine******************************\
* UseStaticEntries
*
* Replace the static system color settings with black and white color
* settings.  This is used when taking over the system static colors to
* realize a 332 rgb fixed palette.  Realizing such a palette in the
* foreground screws up the system colors (menus, titles, scrollbars, etc.).
* Setting the system colors to B&W, while not perfect (some elements of
* the UI are DIBs and will not be effected by this--for example, the
* system menu (or "coin slot") button), is somewhat better.
*
* Side effect:
*   WM_SYSCOLORCHANGE message is broadcast to all top-level windows to
*   inform them of the system palette change.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static VOID UseStaticEntries(HDC hdc)
{
    SetSysColors(NUM_STATIC_COLORS, gaiStaticIndex, gacrBlackAndWhite);
    tkSystemColorsInUse = TRUE;

    PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
}


/******************************Public*Routine******************************\
* RestoreStaticEntries
*
* Restores the static system colors to the settings that existed at the
* time SaveStaticEntries was called.
*
* Side effect:
*   WM_SYSCOLORCHANGE message is broadcast to all top-level windows to
*   inform them of the system palette change.
*
* History:
*  26-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static VOID RestoreStaticEntries(HDC hdc)
{
// Must check to see that SaveStaticEntries was called at least once.
// Otherwise, a bad tk app might mess up the system colors.

    if ( tkStaticSaved )
    {
        SetSysColors(NUM_STATIC_COLORS, gaiStaticIndex, gacrSave);
        tkSystemColorsInUse = FALSE;

        PostMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);
    }
}


/******************************Public*Routine******************************\
* FlushPalette
*
* Because of Win 3.1 compatibility, GDI palette mapping always starts
* at zero and stops at the first exact match.  So if there are duplicates,
* the higher colors aren't mapped to--which is often a problem if we
* are trying to make to any of the upper 10 static colors.  To work around
* this, we flush the palette to all black.
*
* This only needs to be done for the 8BPP (256 color) case.
*
\**************************************************************************/

static void
FlushPalette(HDC hdc, int nColors)
{
    LOGPALETTE *pPal;
    HPALETTE hpal, hpalOld;
    int i;

    if (nColors == 256)
    {
        pPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED|LMEM_ZEROINIT,
                                         sizeof(LOGPALETTE) + nColors * sizeof(PALETTEENTRY));

        if (pPal)
        {
	    pPal->palVersion = 0x300;
	    pPal->palNumEntries = nColors;

        // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force every thing
        // into the palette.  Colors are already black because we zero initialized
        // during memory allocation.

            for (i = 0; i < nColors; i++)
            {
                pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(pPal);
            LocalFree(pPal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

static void
CreateRGBPalette(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd )
{
    LOGPALETTE *pPal;
    int n, i;

    tkUseStaticColors = ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE;

// PFD_NEED_PALETTE should not be set if PFD_TYPE_COLORINDEX mode.

    TKASSERT( (ppfd->iPixelType == PFD_TYPE_COLORINDEX) ?
              ((ppfd->dwFlags & PFD_NEED_PALETTE) == 0) : TRUE );

    if (ppfd->dwFlags & PFD_NEED_PALETTE) {
        if (!tkhPalette) {
            n = 1 << ppfd->cColorBits;
            pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                    n * sizeof(PALETTEENTRY));
            pPal->palVersion = 0x300;
            pPal->palNumEntries = n;
            for (i=0; i<n; i++) {
                pPal->palPalEntry[i].peRed =
                        ComponentFromIndex(i, ppfd->cRedBits, ppfd->cRedShift);
                pPal->palPalEntry[i].peGreen =
                        ComponentFromIndex(i, ppfd->cGreenBits, ppfd->cGreenShift);
                pPal->palPalEntry[i].peBlue =
                        ComponentFromIndex(i, ppfd->cBlueBits, ppfd->cBlueShift);
                pPal->palPalEntry[i].peFlags = PALETTE_FLAGS;
            }

            if ( 256 == n )
            {
                if ( tkUseStaticColors )
                {
                // Black and white already exist as the only remaining static
                // colors.  Let those remap.  All others should be put into
                // the palette (i.e., peFlags == PC_NOCOLLAPSE).

                    pPal->palPalEntry[0].peFlags = 0;
                    pPal->palPalEntry[255].peFlags = 0;

                    SaveStaticEntries(hdc);
                    SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
                }
                else
                {
                    if ( (3 == ppfd->cRedBits) && (0 == ppfd->cRedShift) &&
                         (3 == ppfd->cGreenBits) && (3 == ppfd->cGreenShift) &&
                         (2 == ppfd->cBlueBits) && (6 == ppfd->cBlueShift) )
                    {
                        UpdateStaticMapping(pPal->palPalEntry);
                        
                        for (i = 0; i < STATIC_COLORS; i++)
                        {
                            pPal->palPalEntry[aiDefaultOverride[i]] =
                                apeDefaultPalEntry[i];
                        }
                    }
                }
            }
            tkhPalette = CreatePalette(pPal);
            LocalFree(pPal);
        }

        FlushPalette(hdc, n);

        SelectPalette(hdc, tkhPalette, FALSE);
        n = RealizePalette(hdc);

        if ( tkUseStaticColors )
            UseStaticEntries(hdc);
    }

    // set up logical indices for CI mode
    else if( ppfd->iPixelType == PFD_TYPE_COLORINDEX ) {
        if (!tkhPalette) {
            if (ppfd->cColorBits == 4) {

                // for 4-bit, create a logical palette with 16 entries

                n = 16;
                pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                        n * sizeof(PALETTEENTRY));
                pPal->palVersion = 0x300;
                pPal->palNumEntries = n;

                for( i = 0; i < 8; i ++) {
                    pPal->palPalEntry[i] = apeDefaultPalEntry[i];
                }
                for (i = 8; i < 16; i++) {
                    pPal->palPalEntry[i] = apeDefaultPalEntry[i+4];
                }

                // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so
                //  we rearrange the table for now.

                SwapPalE(1,9)
                SwapPalE(2,10)
                SwapPalE(3,12)

            } else if (ppfd->cColorBits == 8) {

                // for 8-bit, create a logical palette with 256 entries, making
                // sure that the 20 system colors exist in the palette

                n = 256;
                pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                        n * sizeof(PALETTEENTRY));
                pPal->palVersion = 0x300;
                pPal->palNumEntries = n;

                tkhPalette = GetStockObject (DEFAULT_PALETTE);

                // start by copying default palette into new one

                GetPaletteEntries( tkhPalette, 0, 20, pPal->palPalEntry);

                // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so
                // we rearrange the table for now.

                SwapPalE(1,13)
                SwapPalE(2,14)
                SwapPalE(3,16)

                for( i = 20; i < n; i ++) {
                    pPal->palPalEntry[i].peRed   = (BYTE) (i - 1);
                    pPal->palPalEntry[i].peGreen = (BYTE) (i - 2);
                    pPal->palPalEntry[i].peBlue  = (BYTE) (i - 3);
                    pPal->palPalEntry[i].peFlags = (BYTE) 0;
                }


                // If we are taking possession of the system colors,
                // must guarantee that 0 and 255 are black and white
                // (respectively), so that they can remap to the
                // remaining two static colors.  All other entries must
                // be marked as PC_NOCOLLAPSE.

                if ( tkUseStaticColors )
                {
                    pPal->palPalEntry[0].peRed =
                    pPal->palPalEntry[0].peGreen =
                    pPal->palPalEntry[0].peBlue = 0x00;

                    pPal->palPalEntry[255].peRed =
                    pPal->palPalEntry[255].peGreen =
                    pPal->palPalEntry[255].peBlue = 0xFF;

                    pPal->palPalEntry[0].peFlags =
                    pPal->palPalEntry[255].peFlags = 0;

                    for ( i = 1 ; i < 255 ; i++ )
                    {
                        pPal->palPalEntry[i].peFlags = PC_NOCOLLAPSE;

                    // This is a workaround for a GDI palette "feature".  If
                    // any of the static colors are repeated in the palette,
                    // those colors will map to the first occurance.  So, for
                    // our case where there are only two static colors (black
                    // and white), if a white color appears anywhere in the
                    // palette other than in the last  entry, the static white
                    // will remap to the first white.  This destroys the nice
                    // one-to-one mapping we are trying to achieve.
                    //
                    // There are two ways to workaround this.  The first is to
                    // simply not allow a pure white anywhere but in the last
                    // entry.  Such requests are replaced with an attenuated
                    // white of (0xFE, 0xFE, 0xFE).
                    //
                    // The other way is to mark these extra whites with
                    // PC_RESERVED which will cause GDI to skip these entries
                    // when mapping colors.  This way the app gets the actual
                    // colors requested, but can have side effects on other
                    // apps.

                        if ( pPal->palPalEntry[i].peRed   == 0xFF &&
                             pPal->palPalEntry[i].peGreen == 0xFF &&
                             pPal->palPalEntry[i].peBlue  == 0xFF )
                        {
                            pPal->palPalEntry[i].peFlags |= PC_RESERVED;
                        }
                    }

                    SaveStaticEntries(hdc);
                    SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
                }

            } else {
                // for pixel formats > 8 bits deep, create a logical palette with
                // 4096 entries

                n = 4096;
                pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                        n * sizeof(PALETTEENTRY));
                pPal->palVersion = 0x300;
                pPal->palNumEntries = n;

                for( i = 0; i < n; i ++) {
                    pPal->palPalEntry[i].peRed   = (BYTE) ((i & 0x000f) << 4);
                    pPal->palPalEntry[i].peGreen = (BYTE) (i & 0x00f0);
                    pPal->palPalEntry[i].peBlue  = (BYTE) ((i & 0x0f00) >> 4);
                    pPal->palPalEntry[i].peFlags = (BYTE) 0;
                }

                // conform expects indices 0..3 to be BLACK,RED,GREEN,BLUE, so
                //  we rearrange the table for now.

                SwapPalE(1,0xf)
                SwapPalE(2,0xf0)
                SwapPalE(3,0xf00)
            }

            tkhPalette = CreatePalette(pPal);
            LocalFree(pPal);
        }

        FlushPalette(hdc, n);

        TKASSERT(tkhPalette != NULL);

        SelectPalette(hdc, tkhPalette, FALSE);
        n = RealizePalette(hdc);

        if ( tkUseStaticColors )
            UseStaticEntries(hdc);
    }
}

void
ShowPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int format;

    ppfd = &pfd;
    format = GetPixelFormat(hdc);
    DescribePixelFormat(hdc, format, sizeof(PIXELFORMATDESCRIPTOR), ppfd);

    printf("Pixel format %d\n", format);
    printf("  dwFlags - 0x%x", ppfd->dwFlags);
        if (ppfd->dwFlags & PFD_DOUBLEBUFFER) printf("PFD_DOUBLEBUFFER ");
        if (ppfd->dwFlags & PFD_STEREO) printf("PFD_STEREO ");
        if (ppfd->dwFlags & PFD_DRAW_TO_WINDOW) printf("PFD_DRAW_TO_WINDOW ");
        if (ppfd->dwFlags & PFD_DRAW_TO_BITMAP) printf("PFD_DRAW_TO_BITMAP ");
        if (ppfd->dwFlags & PFD_SUPPORT_GDI) printf("PFD_SUPPORT_GDI ");
        if (ppfd->dwFlags & PFD_SUPPORT_OPENGL) printf("PFD_SUPPORT_OPENGL ");
        if (ppfd->dwFlags & PFD_GENERIC_FORMAT) printf("PFD_GENERIC_FORMAT ");
        if (ppfd->dwFlags & PFD_NEED_PALETTE) printf("PFD_NEED_PALETTE ");
        if (ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE) printf("PFD_NEED_SYSTEM_PALETTE ");
        printf("\n");
    printf("  iPixelType - %d", ppfd->iPixelType);
        if (ppfd->iPixelType == PFD_TYPE_RGBA) printf("PGD_TYPE_RGBA\n");
        if (ppfd->iPixelType == PFD_TYPE_COLORINDEX) printf("PGD_TYPE_COLORINDEX\n");
    printf("  cColorBits - %d\n", ppfd->cColorBits);
    printf("  cRedBits - %d\n", ppfd->cRedBits);
    printf("  cRedShift - %d\n", ppfd->cRedShift);
    printf("  cGreenBits - %d\n", ppfd->cGreenBits);
    printf("  cGreenShift - %d\n", ppfd->cGreenShift);
    printf("  cBlueBits - %d\n", ppfd->cBlueBits);
    printf("  cBlueShift - %d\n", ppfd->cBlueShift);
    printf("  cAlphaBits - %d\n", ppfd->cAlphaBits);
    printf("  cAlphaShift - 0x%x\n", ppfd->cAlphaShift);
    printf("  cAccumBits - %d\n", ppfd->cAccumBits);
    printf("  cAccumRedBits - %d\n", ppfd->cAccumRedBits);
    printf("  cAccumGreenBits - %d\n", ppfd->cAccumGreenBits);
    printf("  cAccumBlueBits - %d\n", ppfd->cAccumBlueBits);
    printf("  cAccumAlphaBits - %d\n", ppfd->cAccumAlphaBits);
    printf("  cDepthBits - %d\n", ppfd->cDepthBits);
    printf("  cStencilBits - %d\n", ppfd->cStencilBits);
    printf("  cAuxBuffers - %d\n", ppfd->cAuxBuffers);
    printf("  iLayerType - %d\n", ppfd->iLayerType);
    printf("  bReserved - %d\n", ppfd->bReserved);
    printf("  dwLayerMask - 0x%x\n", ppfd->dwLayerMask);
    printf("  dwVisibleMask - 0x%x\n", ppfd->dwVisibleMask);
    printf("  dwDamageMask - 0x%x\n", ppfd->dwDamageMask);
}

/*
 *  This function returns the pixel format index chosen
 *  by choose pixel format.
 */

static short
FindPixelFormat( HDC Dc, long FormatType )
{
    PIXELFORMATDESCRIPTOR Pfd;
    short PfdIndex;

    Pfd.nSize       = sizeof(Pfd);
    Pfd.nVersion    = 1;
    Pfd.dwFlags     = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
    Pfd.dwLayerMask = PFD_MAIN_PLANE;

    if (TK_WIND_IS_DB(FormatType)) {
        Pfd.dwFlags |= PFD_DOUBLEBUFFER;
    }

    if (TK_WIND_IS_CI(FormatType)) {
        Pfd.iPixelType = PFD_TYPE_COLORINDEX;
        Pfd.cColorBits = 8;
    }

    if (TK_WIND_IS_RGB(FormatType)) {
        Pfd.iPixelType = PFD_TYPE_RGBA;
        Pfd.cColorBits = 24;
    }

    if (TK_WIND_ACCUM & FormatType) {
        Pfd.cAccumBits = Pfd.cColorBits;
    } else {
        Pfd.cAccumBits = 0;
    }

    if (TK_WIND_Z & FormatType) {
        Pfd.cDepthBits = 32;
    } else if (TK_WIND_Z16 & FormatType) {
        Pfd.cDepthBits = 16;
    } else {
        Pfd.cDepthBits = 0;
    }

    if (TK_WIND_STENCIL & FormatType) {
        Pfd.cStencilBits = 8;
    } else {
        Pfd.cStencilBits = 0;
    }

    PfdIndex = ChoosePixelFormat( Dc, &Pfd );

    return( PfdIndex );
}

// Initialize a window, create a rendering context for that window
// only allow CI on palette devices, RGB on true color devices
// current server turns on Z, but no accum or stencil
// When SetPixelFormat is implemented, remove all of these restrictions

long
tkNewWindow(TK_WindowRec *tkWr)
{
    WNDCLASS wndclass;
    RECT WinRect;
    HANDLE hInstance;
    PIXELFORMATDESCRIPTOR Pfd;
    short PfdIndex;
    int   nPixelFormats;
    BOOL Result = FALSE;
    HDC tmphdc = NULL;

    TKASSERT(NULL==tkhwnd               );
    TKASSERT(NULL==tkhdc                );
    TKASSERT(NULL==tkhrc                );
    TKASSERT(NULL==tkhPalette           );
    TKASSERT(ExecFunc==NoOpExecFunc     );

    hInstance = GetModuleHandle(NULL);

    wndclass.style          = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
    wndclass.lpfnWndProc    = (WNDPROC)tkWndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = lpszClassName;

    RegisterClass(&wndclass);

    // Make window large enough to hold a client area as large as tkWr
    WinRect.left   = (tkWr->x == CW_USEDEFAULT) ? 0 : tkWr->x;
    WinRect.top    = (tkWr->y == CW_USEDEFAULT) ? 0 : tkWr->y;
    WinRect.right  = WinRect.left + tkWr->width;
    WinRect.bottom = WinRect.top + tkWr->height;

    AdjustWindowRect(&WinRect, WS_OVERLAPPEDWINDOW, FALSE);

    tkhwnd = CreateWindowEx(
                WS_EX_TOPMOST,
                lpszClassName,
                tkWr->name,
                WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                (tkWr->x == CW_USEDEFAULT ? CW_USEDEFAULT : WinRect.left),
                (tkWr->y == CW_USEDEFAULT ? CW_USEDEFAULT : WinRect.top),
                WinRect.right  - WinRect.left,
                WinRect.bottom - WinRect.top,
                NULL,
                NULL,
                hInstance,
                NULL);

    /*
     * Fixup window size in case minimum tracking size did something.
     */
    GetClientRect(tkhwnd, &WinRect);
    tkWr->width  = WinRect.right;
    tkWr->height = WinRect.bottom;

    if ( NULL != tkhwnd )
    {
        tkhdc = GetDC(tkhwnd);

       	if (tkWr->type == TK_WIND_VISUAL)
	{
	    nPixelFormats = DescribePixelFormat(tkhdc,abs(tkWr->info),sizeof(PIXELFORMATDESCRIPTOR),&Pfd);

            // If tkWr->info is negative, this is a bitmap request
	    // Otherwise, it is a display request

	    if (tkWr->info < 0)
	    {
		tkWr->info = -(tkWr->info);

                if (!(Pfd.dwFlags & PFD_DRAW_TO_BITMAP))
		    goto tkNewWindow_exit;

                tkhmemdc    = CreatePixelMapDC(tkhdc, tkWr, DIB_RGB_COLORS, Pfd.cColorBits, &Pfd);
                tmphdc      = tkhmemdc;
            }
	    else
	    {
		if (!(Pfd.dwFlags & PFD_DRAW_TO_WINDOW))
		    goto tkNewWindow_exit;

                tmphdc = tkhdc;
            }
        }
        else
            tmphdc = tkhdc;

        /*
         *  XXXX
         *  I would like to delay the show window a little longer
         *  but this causes an exception, during clears. New code
         *  will fix this.
         */

        ShowWindow(tkhwnd, SW_SHOWDEFAULT);

        PfdIndex = GetPixelFormatInformation( tmphdc, tkWr, &Pfd );

        if ( PfdIndex )
        {
            if ( SetPixelFormat( tmphdc, PfdIndex, &Pfd ) )
            {
                /*
                 *  Would be nice to delay until then, alas, we have a bug
                 */

                ShowPixelFormat(tmphdc);

                /*
                 *  If the tmp DC is a memory DC, create and
                 *  realize the palette for the screen DC first.
                 *  Memory DC palettes are realized as background
                 *  palettes, so we must put the palette in the
                 *  foreground via the screen DC before we muck
                 *  around with the memory DC.
                 */
                if (tmphdc != tkhdc)
                    CreateRGBPalette( tkhdc, &Pfd );

                CreateRGBPalette( tmphdc, &Pfd );
                tkhrc = CreateAndMakeContextCurrent( tmphdc );

                if ( NULL != tkhrc )
                {
                    ShowWindow(tkhwnd, SW_SHOWDEFAULT);

                    /*
                     *  Convert information in the pixel format descriptor
                     *  to the TK_WindowRec format
                     */

                    PIXELFORMATDESCRIPTOR_To_TK_WindowRec ( tkWr, &Pfd );

                    Result = TRUE;
                }
            }
        }
    }

tkNewWindow_exit:
    if ( FALSE == Result )
    {
        /*
         *  Something Failed, Destroy this window
         */

        DestroyThisWindow(tkhwnd);

        /*
         *  Process all the messages
         */

        tkExec( (long (*)(TK_EventRec *pEvent))NULL );
    }
    return( Result );
}

/*
 *  If a function fails, this function will clean itself up
 */

static HGLRC
CreateAndMakeContextCurrent( HDC Dc )
{
    HGLRC Rc = NULL;

    /* Create a Rendering Context */

    Rc = wglCreateContext( Dc );

    if ( NULL != Rc )
    {
        /* Make it Current */

        if ( FALSE == wglMakeCurrent( Dc, Rc ) )
        {
            wglDeleteContext( Rc );
            Rc = NULL;
        }
    }
    return( Rc );
}

static void
DestroyThisWindow( HWND Window )
{
    if ( NULL != Window )
    {
        DestroyWindow( Window );
    }
}

/*
 *  This Should be called in response to a WM_DESTROY message
 */

static void
CleanUp( void )
{
    if ( NULL != tkhwnd )
    {
        if ( NULL != tkhdc )
        {
            if ( NULL != tkhPalette )
            {
                DeleteObject(
                    SelectObject( tkhdc, GetStockObject(DEFAULT_PALETTE) ));

                if ( tkUseStaticColors )
                {
                    SetSystemPaletteUse( tkhdc, SYSPAL_STATIC );
                    RealizePalette( tkhdc );
                    RestoreStaticEntries( tkhdc );
                }

                tkhPalette = NULL;
            }

            if ( NULL != tkhrc )
            {
                wglMakeCurrent( tkhdc, NULL );  // No current context

                wglDeleteContext(tkhrc);        // Delete this context

                tkhrc = NULL;
            }
            ReleaseDC( tkhwnd, tkhdc );
            tkhdc = NULL;
        }
        tkhwnd = NULL;
    }
    ExecFunc = NoOpExecFunc;
}
/*******************************************************************/

void tkQuit(void)
{
    TKASSERT(NULL==tkhwnd      );
    TKASSERT(NULL==tkhdc       );
    TKASSERT(NULL==tkhrc       );
    TKASSERT(NULL==tkhPalette  );

    ExitProcess(0);
}


/*******************************************************************/

void tkSwapBuffers(void)
{
    SwapBuffers(tkhdc);
}

/*******************************************************************/

void tkGet(long item, void *data)
{
    if (item == TK_SCREENIMAGE)
    {
        // XXXX We will need this the covglx and conformw

        OutputDebugString("tkGet(TK_SCREENIMAGE) is not implemented\n");
    }
    else if (item == TK_VISUALIDS)
    {
        StorePixelFormatsIDs( data );
    }
}

static VOID
StorePixelFormatsIDs( TK_VisualIDsRec *VisualID )
{
    HDC hDc;
    int AvailableIds;
    int Id;
    PIXELFORMATDESCRIPTOR Pfd;

    /*
     *  Get a DC for the display
     */

    hDc = GetDC(NULL);

    /*
     *  Get the total number of pixel formats
     */

    AvailableIds = DescribePixelFormat( hDc, 0, 0, NULL );

    /*
     *  Store the IDs in the structure.
     *  The first Id starts at one.
     */

    VisualID->count = 0;

    for ( Id = 1 ; Id <= AvailableIds ; Id++ )
    {
        /*
         *  Make sure you don't overrun the structure's buffer
         */

        if (
                Id <= ((sizeof(((TK_VisualIDsRec *)NULL)->IDs) /
                    sizeof(((TK_VisualIDsRec *)NULL)->IDs[0])))
           )
        {
            if ( DescribePixelFormat( hDc, Id, sizeof(Pfd), &Pfd ) )
            {
                /*
                 *  Make sure the pixel format index supports OpenGL
                 */

                if ( PFD_SUPPORT_OPENGL & Pfd.dwFlags )
                {
                    VisualID->IDs[VisualID->count++] = Id;
                }
            }
        }
        else
            break;
    }

    /*
     *  Don't need the DC anymore
     */

    ReleaseDC( NULL, hDc );
}

static void
PrintMessage( const char *Format, ... )
{
    va_list ArgList;
    char Buffer[256];

    va_start(ArgList, Format);
    vsprintf(Buffer, Format, ArgList);
    va_end(ArgList);

    fprintf( stderr, "libctk: %s", Buffer );
    fflush(stdout);
}

/********************************************************************/

/*
 *  This function returns the selected pixel format index and
 *  the pixel format descriptor.
 */

static short
GetPixelFormatInformation( HDC Dc, TK_WindowRec *tkWr, PIXELFORMATDESCRIPTOR *Pfd )
{
    short PfdIndex = 0;     // Assume no pixel format matches

    /*
     *  TK_WIND_REQUEST indicates that tkWr->info is a mask
     *  describing the type of pixel format requested.
     */

    if ( TK_WIND_REQUEST == tkWr->type )
    {
        PfdIndex = FindPixelFormat( Dc, tkWr->info );
    }
    else
    {
        /*
         *  Otherwise, tkWr->info contains the pixel format Id.
         */

        PfdIndex = (short)tkWr->info;
    }

    if ( DescribePixelFormat( Dc, PfdIndex, sizeof(*Pfd), Pfd) )
    {
        if ( !(PFD_SUPPORT_OPENGL & Pfd->dwFlags) )
        {
            PfdIndex = 0;   // Does not support OpenGL, make it fail
        }
    }
    return( PfdIndex );
}




/********************************************************************\
| CREATE PIXEL-MAP DC
|
| hWnd	 : WindowDC created via GetDC()
| nFormat: must be in the range 21 - 40
| uUsage : DIB_RGB_COLORS (do this one)
|	   DIB_PAL_COLORS
|
\********************************************************************/
HDC CreatePixelMapDC(HDC hDC, TK_WindowRec *tkWr, UINT uUsage, int nBpp, LPPIXELFORMATDESCRIPTOR lpPfd)
{
    HDC     hMemDC;
    HBITMAP hBitmap,hSave;
    int     nWidth,nHeight,nColorTable,idx,nEntries;
    DWORD   dwSize,dwBits,dwCompression;
    HANDLE  hDib;
    PVOID   pvBits;
    LPSTR   lpDib,lpCT;
    DWORD   dwRMask,dwBMask,dwGMask;

    static COLORREF cr16Color[]  = {0x00000000,
                                    0x00000080,
                                    0x00008000,
                                    0x00008080,
                                    0x00800000,
                                    0x00800080,
                                    0x00808000,
                                    0x00808080,
                                    0x00C0C0C0,
                                    0x000000FF,
                                    0x0000FF00,
                                    0x0000FFFF,
                                    0x00FF0000,
                                    0x00FF00FF,
                                    0x00FFFF00,
                                    0x00FFFFFF};


        if(hMemDC = CreateCompatibleDC(hDC))
        {
            // Get device information for the surface
            //
            nWidth  = tkWr->width;
            nHeight = tkWr->height;

            #define USE_DFB 1
            #if USE_DFB
            // Use compatible bitmap (DFB if supported) if DC color
            // depth matches requested color depth.  Otherwise, use DIB.
            if ( nBpp == (GetDeviceCaps(hDC, BITSPIXEL) *
                          GetDeviceCaps(hDC, PLANES)) )
            {
                if(hBitmap = CreateCompatibleBitmap(hDC,nWidth,nHeight))
                {
                    if(hSave = SelectObject(hMemDC,hBitmap))
                    {
                        return(hMemDC);
                    }

                    DeleteObject(hBitmap);
                }
            }
            else
            {
            #endif
                if(nBpp)
                {
                    // Get the colortable size.
                    //
                    switch(nBpp)
                    {
                        case 32:
                        case 16:
                            nColorTable   = 3 * sizeof(DWORD);
                            dwCompression = BI_BITFIELDS;
                            break;

                        case 24:
                            nColorTable   = 0;
                            dwCompression = BI_RGB;
                            break;

                        default:
                            nColorTable   = ((UINT)1 << nBpp) * sizeof(RGBQUAD);
                            dwCompression = BI_RGB;

                            if(uUsage == DIB_PAL_COLORS)
                                nColorTable >>= 1;
                            break;
                    }


                    // Calculate necessary size for dib.
                    //
                    dwBits  = (DWORD)(((nWidth * nBpp) + 31) / 32) * nHeight * sizeof(DWORD);
                    dwSize  = (DWORD)dwBits + sizeof(BITMAPINFOHEADER) + nColorTable;


                    // Create the bitmap based upon the DIB specification.
                    //
                    if(hDib = GlobalAlloc(GHND,dwSize))
                    {
                        if(lpDib = GlobalLock(hDib))
                        {
                            // Initialize DIB specification.
                            //
                            ((LPBITMAPINFOHEADER)lpDib)->biSize          = sizeof(BITMAPINFOHEADER);
                            ((LPBITMAPINFOHEADER)lpDib)->biWidth         = nWidth;
                            ((LPBITMAPINFOHEADER)lpDib)->biHeight        = nHeight;
                            ((LPBITMAPINFOHEADER)lpDib)->biPlanes        = 1;
                            ((LPBITMAPINFOHEADER)lpDib)->biBitCount      = (UINT)nBpp;
                            ((LPBITMAPINFOHEADER)lpDib)->biCompression   = dwCompression;
                            ((LPBITMAPINFOHEADER)lpDib)->biSizeImage     = 0;
                            ((LPBITMAPINFOHEADER)lpDib)->biXPelsPerMeter = 0;
                            ((LPBITMAPINFOHEADER)lpDib)->biYPelsPerMeter = 0;
                            ((LPBITMAPINFOHEADER)lpDib)->biClrUsed       = 0;
                            ((LPBITMAPINFOHEADER)lpDib)->biClrImportant  = 0;


                            // Fill in colortable for appropriate bitmap-format.
                            //
                            lpCT = (LPSTR)((LPBITMAPINFO)lpDib)->bmiColors;

                            switch(nBpp)
                            {
                                case 32:
                                case 16:
                                    // This creates the rough mask of bits for the
                                    // number of color-bits.
                                    //
                                    dwRMask = (((DWORD)1 << lpPfd->cRedBits   ) - 1);
                                    dwGMask = (((DWORD)1 << lpPfd->cGreenBits ) - 1);
                                    dwBMask = (((DWORD)1 << lpPfd->cBlueBits  ) - 1);


                                    // Shift the masks for the color-table.
                                    //
                                    *((LPDWORD)lpCT)     = dwRMask << lpPfd->cRedShift;
                                    *(((LPDWORD)lpCT)+1) = dwGMask << lpPfd->cGreenShift;
                                    *(((LPDWORD)lpCT)+2) = dwBMask << lpPfd->cBlueShift;
                                    break;

                                case 24:
                                    break;

                                case 8:
                                    nEntries = ((UINT)1 << nBpp);

                                    if(uUsage == DIB_PAL_COLORS)
                                    {
                                        for(idx=0; idx < nEntries; idx++)
                                            *(((LPWORD)lpCT)+idx) = idx;
                                    }
                                    else
                                    {
                                        for(idx=0; idx < nEntries; idx++)
                                        {
                                            ((LPBITMAPINFO)lpDib)->bmiColors[idx].rgbRed      = ComponentFromIndex(idx,lpPfd->cRedBits  ,lpPfd->cRedShift  );
                                            ((LPBITMAPINFO)lpDib)->bmiColors[idx].rgbGreen    = ComponentFromIndex(idx,lpPfd->cGreenBits,lpPfd->cGreenShift);
                                            ((LPBITMAPINFO)lpDib)->bmiColors[idx].rgbBlue     = ComponentFromIndex(idx,lpPfd->cBlueBits ,lpPfd->cBlueShift );
                                            ((LPBITMAPINFO)lpDib)->bmiColors[idx].rgbReserved = 0;
                                        }
                                    }
                                    break;

                                case 4:
                                    nEntries = sizeof(cr16Color) / sizeof(cr16Color[0]);

                                    if(uUsage == DIB_PAL_COLORS)
                                    {
                                        for(idx=0; idx < nEntries; idx++)
                                            *(((LPWORD)lpCT)+idx) = idx;
                                    }
                                    else
                                    {
                                        for(idx=0; idx < nEntries; idx++)
                                            *(((LPDWORD)lpCT)+idx) = cr16Color[idx];
                                    }
                                    break;

                                case 1:
                                    if(uUsage == DIB_PAL_COLORS)
                                    {
                                        *((LPWORD)lpCT)++ =   0;
                                        *((LPWORD)lpCT)   = 255;
                                    }
                                    else
                                    {
                                        ((LPBITMAPINFO)lpDib)->bmiColors[0].rgbBlue     =   0;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[0].rgbGreen    =   0;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[0].rgbRed      =   0;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[0].rgbReserved =   0;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[1].rgbBlue     = 255;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[1].rgbGreen    = 255;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[1].rgbRed      = 255;
                                        ((LPBITMAPINFO)lpDib)->bmiColors[1].rgbReserved =   0;
                                    }
                                    break;
                            }

                            if (hBitmap = CreateDIBSection(hMemDC, (LPBITMAPINFO)lpDib, uUsage, &pvBits, NULL, 0))
                            {
                                if(hSave = SelectObject(hMemDC,hBitmap))
                                {
                                    GlobalUnlock(hDib);
                                    GlobalFree(hDib);

                                    return(hMemDC);
                                }
                                DeleteObject(hBitmap);
                            }

                            GlobalUnlock(hDib);
                        }

                        GlobalFree(hDib);
                    }
                }
            #if USE_DFB
            }
            #endif
        }

    return(NULL);
}


BOOL DeletePixelMapDC(HDC hDC)
{
    HBITMAP hFormat,hBitmap;
    BOOL    bFree;


    bFree = FALSE;
    if(hFormat = CreateCompatibleBitmap(hDC,1,1))
    {
        if(hBitmap = SelectObject(hDC,hFormat))
        {
            DeleteObject(hBitmap);

            bFree = DeleteDC(hDC);
        }

        DeleteObject(hFormat);
    }

    return(bFree);
}


/*
 *  This function updates a TK_WindowRec given a PIXELFORMATDESCRIPTOR
 */

static TK_WindowRec *
PIXELFORMATDESCRIPTOR_To_TK_WindowRec ( TK_WindowRec *WindowRec, PIXELFORMATDESCRIPTOR *Pfd )
{
    WindowRec->type  = TK_WIND_REQUEST;
    WindowRec->info  = 0;

    if ( PFD_DOUBLEBUFFER & Pfd->dwFlags )
    {
        WindowRec->info |= TK_WIND_DB;
    }
    else
    {
        WindowRec->info |= TK_WIND_SB;
    }

    if ( PFD_TYPE_COLORINDEX == Pfd->iPixelType )
    {
        WindowRec->info |= TK_WIND_CI;
    }
    else
    {
        WindowRec->info |= TK_WIND_RGB;
    }

    if ( Pfd->cAccumBits )
    {
        WindowRec->info |= TK_WIND_ACCUM;
    }

    if ( Pfd->cDepthBits > 16 )
    {
        WindowRec->info |= TK_WIND_Z;
    }
    else if ( Pfd->cDepthBits > 0 )
    {
        WindowRec->info |= TK_WIND_Z16;
    }

    if ( Pfd->cStencilBits )
    {
        WindowRec->info |= TK_WIND_STENCIL;
    }

    if ( Pfd->cAuxBuffers )
    {
        WindowRec->info |= TK_WIND_AUX;
    }
    return( WindowRec );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\alias.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void AliasInit(void *data)
{

    *((void **)data) = (void *)0;
}

long AliasUpdate(void *data)
{

    return 1;
}

void AliasSet(long enabled, void *data)
{

    if (enabled) {
	glEnable(GL_POINT_SMOOTH);
	glEnable(GL_LINE_SMOOTH);
	glEnable(GL_POLYGON_SMOOTH);
    } else {
	glDisable(GL_POINT_SMOOTH);
	glDisable(GL_LINE_SMOOTH);
	glDisable(GL_POLYGON_SMOOTH);
    }
    Probe();
}

void AliasStatus(long enabled, void *data)
{

    if (enabled) {
	Output("Anti-Aliasing on.\n");
    } else {
	Output("Anti-Aliasing off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\alpha.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _alphaRec {
    long index;
    GLenum value;
    char *name;
    enumRec *enumTable;
} alphaRec;


enumRec enum_Alpha[] = {
    GL_EQUAL, "GL_EQUAL",
    GL_NOTEQUAL, "GL_NOTEQUAL",
    GL_LESS, "GL_LESS",
    GL_LEQUAL, "GL_LEQUAL",
    GL_GREATER, "GL_GREATER",
    GL_GEQUAL, "GL_GEQUAL",
    GL_ALWAYS, "GL_ALWAYS",
    GL_NEVER, "GL_NEVER",
    -1, "End of List"
};


void AlphaInit(void *data)
{
    alphaRec *ptr;

    ptr = (alphaRec *)malloc(sizeof(alphaRec));    
    *((void **)data) = (void *)ptr;
    ptr->enumTable = enum_Alpha;
    ptr->index = 0;
    ptr->value = ptr->enumTable->value;
    ptr->name = ptr->enumTable->name;
}

long AlphaUpdate(void *data)
{
    alphaRec *ptr = (alphaRec *)data;

    ptr->index += 1;
    if (ptr->enumTable[ptr->index].value == -1) {
	ptr->index = 0;
	ptr->value = ptr->enumTable->value;
	ptr->name = ptr->enumTable->name;
	return 1;
    } else {
	ptr->value = ptr->enumTable[ptr->index].value;
	ptr->name = ptr->enumTable[ptr->index].name;
	return 0;
    }
}

void AlphaSet(long enabled, void *data)
{
    alphaRec *ptr = (alphaRec *)data;

    if (enabled) {
	glAlphaFunc(ptr->value, 1.0);
	glEnable(GL_ALPHA_TEST);
    } else {
	glDisable(GL_ALPHA_TEST);
    }
    Probe();
}

void AlphaStatus(long enabled, void *data)
{
    alphaRec *ptr = (alphaRec *)data;

    if (enabled) {
	Output("Alpha on.\n");
	Output("\t%s.\n", ptr->name);
    } else {
	Output("Alpha off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\blend.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _blendRec {
    long index[2];
    GLenum value[2];
    char *name[2];
    enumRec *enumTable[2];
} blendRec;


enumRec enum_BlendFuncSrc[] = {
    GL_ZERO, "GL_ZERO",
    GL_ONE, "GL_ONE",
    GL_DST_COLOR, "GL_DST_COLOR",
    GL_ONE_MINUS_DST_COLOR, "GL_ONE_MINUS_DST_COLOR",
    GL_SRC_ALPHA, "GL_SRC_ALPHA",
    GL_ONE_MINUS_SRC_ALPHA, "GL_ONE_MINUS_SRC_ALPHA",
    GL_DST_ALPHA, "GL_DST_ALPHA",
    GL_ONE_MINUS_DST_ALPHA, "GL_ONE_MINUS_DST_ALPHA",
    GL_SRC_ALPHA_SATURATE, "GL_SRC_ALPHA_SATURATE",
    -1, "End of List"
};

enumRec enum_BlendFuncDest[] = {
    GL_ZERO, "GL_ZERO",
    GL_ONE, "GL_ONE",
    GL_SRC_COLOR, "GL_SRC_COLOR",
    GL_ONE_MINUS_SRC_COLOR, "GL_ONE_MINUS_SRC_COLOR",
    GL_SRC_ALPHA, "GL_SRC_ALPHA",
    GL_ONE_MINUS_SRC_ALPHA, "GL_ONE_MINUS_SRC_ALPHA",
    GL_DST_ALPHA, "GL_DST_ALPHA",
    GL_ONE_MINUS_DST_ALPHA, "GL_ONE_MINUS_DST_ALPHA",
    -1, "End of List"
};


void BlendInit(void *data)
{
    blendRec *ptr;
    long i;

    ptr = (blendRec *)malloc(sizeof(blendRec));    
    *((void **)data) = (void *)ptr;

    ptr->enumTable[0] = enum_BlendFuncSrc;
    ptr->enumTable[1] = enum_BlendFuncDest;

    for (i = 0; i < 2; i++) {
	ptr->index[i] = 0;
	ptr->value[i] = ptr->enumTable[i]->value;
	ptr->name[i] = ptr->enumTable[i]->name;
    }
}

long BlendUpdate(void *data)
{
    blendRec *ptr = (blendRec *)data;
    long flag, i;

    flag = 1;
    for (i = 1; i >= 0; i--) {
	if (flag) {
	    ptr->index[i] += 1;
	    if (ptr->enumTable[i][ptr->index[i]].value == -1) {
		ptr->index[i] = 0;
		ptr->value[i] = ptr->enumTable[i]->value;
		ptr->name[i] = ptr->enumTable[i]->name;
		flag = 1;
	    } else {
		ptr->value[i] = ptr->enumTable[i][ptr->index[i]].value;
		ptr->name[i] = ptr->enumTable[i][ptr->index[i]].name;
		flag = 0;
	    }
	}
    }

    return flag;
}

void BlendSet(long enabled, void *data)
{
    blendRec *ptr = (blendRec *)data;

    if (enabled) {
	glBlendFunc(ptr->value[0], ptr->value[1]);
	glEnable(GL_BLEND);
    } else {
	glDisable(GL_BLEND);
    }
    Probe();
}

void BlendStatus(long enabled, void *data)
{
    blendRec *ptr = (blendRec *)data;

    if (enabled) {
	Output("Blend on.\n");
	Output("\t%s, %s.\n", ptr->name[0], ptr->name[1]);
    } else {
	Output("Blend off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\dither.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void DitherInit(void *data)
{

    *((void **)data) = (void *)0;
}

long DitherUpdate(void *data)
{

    return 1;
}

void DitherSet(long enabled, void *data)
{

    if (enabled) {
	glEnable(GL_DITHER);
    } else {
	glDisable(GL_DITHER);
    }
    Probe();
}

void DitherStatus(long enabled, void *data)
{

    if (enabled) {
	Output("Dither on.\n");
    } else {
	Output("Dither off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\ctk\ctkx.c ===
/************************************************************************/
/*									*/
/* 	Nano toolkit for OpenGL for the X Window System			*/
/*									*/
/************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/keysym.h>
#include <GL/glx.h>
#include "ctk.h"

#if defined(__cplusplus) || defined(c_plusplus)
#define class c_class
#endif

/******************************************************************************/

static Display *display = 0;
static int screen = 0;
static XVisualInfo *visual = 0;
static Colormap colorMap;
static Window window = 0;
static GLXContext context = 0;

static int windType;
static TK_EventRec event;

/******************************************************************************/

static long DisplayInit(void)
{
    int erb, evb;

    if (!display) {
	display = XOpenDisplay(0);
	if (!display) {
	    fprintf(stderr, "Can't connect to display!\n");
	    return 0;
	}
	if (!glXQueryExtension(display, &erb, &evb)) {
	    fprintf(stderr, "No glx extension!\n");
	    return 0;
	}
	screen = DefaultScreen(display);
    }
    return 1;
}

static XVisualInfo *FindVisual(long type)
{
    long list[32];
    int i;

    i = 0;

    list[i++] = GLX_LEVEL;
    list[i++] = 0;

    if (TK_WIND_IS_DB(type)) {
	list[i++] = GLX_DOUBLEBUFFER;
    }

    if (TK_WIND_IS_RGB(type)) {
	list[i++] = GLX_RGBA;
	list[i++] = GLX_RED_SIZE;
	list[i++] = 1;
	list[i++] = GLX_GREEN_SIZE;
	list[i++] = 1;
	list[i++] = GLX_BLUE_SIZE;
	list[i++] = 1;
	/*
	list[i++] = GLX_ALPHA_SIZE;
	list[i++] = 1;
	list[i++] = GLX_ACCUM_RED_SIZE;
	list[i++] = 1;
	list[i++] = GLX_ACCUM_GREEN_SIZE;
	list[i++] = 1;
	list[i++] = GLX_ACCUM_BLUE_SIZE;
	list[i++] = 1;
	list[i++] = GLX_ACCUM_ALPHA_SIZE;
	list[i++] = 1;
	*/
    } else {
	list[i++] = GLX_BUFFER_SIZE;
	list[i++] = 1;
    }

    list[i++] = GLX_DEPTH_SIZE;
    list[i++] = 1;

    list[i++] = GLX_STENCIL_SIZE;
    list[i++] = 1;

    list[i] = (int)None;

    return glXChooseVisual(display, screen, (int *)list);
}

static long MakeVisualType(XVisualInfo *vi)
{
    int rgba, doubleBuffer, stencilSize, depthSize;
    int accumRed, accumGreen, accumBlue, auxBuffers;
    long mask;

    mask = 0;

    glXGetConfig(display, vi, GLX_RGBA, &rgba);
    if (rgba) {
	mask |= TK_WIND_RGB;
    } else {
	mask |= TK_WIND_CI;
    }

    glXGetConfig(display, vi, GLX_DOUBLEBUFFER, &doubleBuffer);
    if (doubleBuffer) {
	mask |= TK_WIND_DB;
    } else {
	mask |= TK_WIND_SB;
    }

    glXGetConfig(display, vi, GLX_ACCUM_RED_SIZE, &accumRed);
    glXGetConfig(display, vi, GLX_ACCUM_GREEN_SIZE, &accumGreen);
    glXGetConfig(display, vi, GLX_ACCUM_BLUE_SIZE, &accumBlue);
    if ((accumRed > 0) && (accumGreen > 0) && (accumBlue > 0)) {
	mask |= TK_WIND_ACCUM;
    }

    glXGetConfig(display, vi, GLX_STENCIL_SIZE, &stencilSize);
    if (stencilSize > 0) {
	mask |= TK_WIND_STENCIL;
    }

    glXGetConfig(display, vi, GLX_DEPTH_SIZE, &depthSize);
    if (depthSize > 0) {
	mask |= TK_WIND_Z;
    }

    return mask;
}

static Bool WaitForMapNotify(Display *d, XEvent *e, char *arg)
{
    if (e->type == MapNotify && e->xmap.window == window) {
	return GL_TRUE;
    }
    return GL_FALSE;
}

long tkNewWindow(TK_WindowRec *wind)
{
    XSetWindowAttributes wa;
    XTextProperty tp;
    XSizeHints sh;
    XEvent e;
    char *ptr;

    if (!DisplayInit()) {
	return 0;
    }

    if (wind->type == TK_WIND_REQUEST) {
	int useGL;

	visual = FindVisual(wind->info);
	if (visual == 0) {
	    return 0;
	}
	glXGetConfig(display, visual, GLX_USE_GL, &useGL);
	if (!useGL) {
	    return 0;
	}
    } else {
	XVisualInfo temp;
	int useGL, count;

	temp.visualid = wind->info;
	visual = XGetVisualInfo(display, VisualIDMask, &temp, &count);
	if (visual == 0) {
	    return 0;
	}
	glXGetConfig(display, visual, GLX_USE_GL, &useGL);
	if (!useGL) {
	    return 0;
	}
    }
    wind->type = TK_WIND_REQUEST;
    wind->info = MakeVisualType(visual);
    windType = wind->info;

    context = glXCreateContext(display, visual, None,
			       (wind->render==TK_WIND_DIRECT)?GL_TRUE:GL_FALSE);
    if (!context) {
	fprintf(stderr, "Can't create a context!\n");
    }
    if (glXIsDirect(display, context)) {
	wind->render = TK_WIND_DIRECT;
    } else {
	wind->render = TK_WIND_INDIRECT;
    }

    colorMap = XCreateColormap(display, RootWindow(display, screen),
			       visual->visual, AllocNone);
    wa.colormap = colorMap;
    wa.background_pixmap = None;
    wa.border_pixel = 0;
    wa.event_mask = StructureNotifyMask | ExposureMask;

    window = XCreateWindow(display, RootWindow(display, screen), (int)wind->x,
			   (int)wind->y, (unsigned int)wind->width,
			   (unsigned int)wind->height, 0, visual->depth,
			   InputOutput, visual->visual,
			   CWBackPixmap|CWBorderPixel|CWEventMask|CWColormap,
			   &wa);
    
    /*
    ** Set up window hints.
    */
    ptr = &wind->name[0];
    XStringListToTextProperty(&ptr, 1, &tp);
    sh.flags = USPosition | USSize;
    XSetWMProperties(display, window, &tp, &tp, 0, 0, &sh, 0, 0);

    /*
    ** Map window and then wait for the window system to get around to it.
    */
    XMapWindow(display, window);
    XIfEvent(display, &e, WaitForMapNotify, 0);

    XSetWMColormapWindows(display, window, &window, 1);
    if (!glXMakeCurrent(display, window, context)) {
	return 0;
    }
    XFlush(display);

    return 1;
}

void tkCloseWindow(void)
{
    glFinish();
    XDestroyWindow(display, window);
    glXDestroyContext(display, context);
    XFreeColormap(display, colorMap);
    XFree((char *)visual);
}

void tkSwapBuffers(void)
{
    glXSwapBuffers(display, window);
}

void tkQuit(void)
{
    exit(0);
}

static void GetNextEvent(void)
{
    XEvent current, ahead;

    event.event = 0;
    event.data[0] = 0;
    event.data[1] = 0;
    event.data[2] = 0;
    event.data[3] = 0;

    XNextEvent(display, &current);
    switch (current.type) {
      case MappingNotify:
	XRefreshKeyboardMapping((XMappingEvent *)&current);
	break;

      case Expose:
	while (XEventsQueued(current.xexpose.display, QueuedAfterReading) > 0) {
	    XPeekEvent(current.xexpose.display, &ahead);
	    if (ahead.type != Expose) {
		break;
	    }
	    if (ahead.xexpose.window != current.xexpose.window) {
		break;
	    }
	    XNextEvent(display, &current);
	}
	if (current.xexpose.count == 0) {
	    event.event = TK_EVENT_EXPOSE;
	    event.data[TK_WINDOWX] = current.xexpose.width;
	    event.data[TK_WINDOWY] = current.xexpose.height;
	}
	break;
    }
}

void tkExec(long (*Func)(TK_EventRec *ptr))
{

    while (1) {
	if (XPending(display)) {
	    GetNextEvent();
	    if (event.event == TK_EVENT_EXPOSE) {
		if ((*Func)(&event) == 0) {
		    break;
		}
	    }
	}
    }
}

static void ScreenImage(TK_ScreenImageRec *ptr)
{
    XImage *image;
    float *destPtr, *tmpBuf;
    unsigned long *srcPtr, c, mask;
    long rShift = 0, gShift = 0, bShift = 0;
    GLint rBits, gBits, bBits;
    float rFactor, gFactor, bFactor;
    long indices_per_word, words_per_line, lines;
    int i, j;
    float *tmpPtr;

    glXWaitGL();

    image = XGetImage(display, window, (int)ptr->x, (int)ptr->y, 
	    (unsigned int)ptr->width, (unsigned int)ptr->height, ~0, ZPixmap);
    srcPtr = (unsigned long *)image->data;
    destPtr = ptr->data;

    mask = (1 << image->depth) - 1;
    indices_per_word = 32 / image->bits_per_pixel;
    words_per_line = image->bytes_per_line / 4;
    lines = ptr->width * ptr->height / (words_per_line * indices_per_word);

    if (ptr->colorMode == TK_WIND_RGB) {
	mask = image->red_mask;
	while ((mask & 0x1) == 0) {
	    rShift++;
	    mask = mask >> 1;
	}
	mask = image->green_mask;
	while ((mask & 0x1) == 0) {
	    gShift++;
	    mask = mask >> 1;
	}
	mask = image->blue_mask;
	while ((mask & 0x1) == 0) {
	    bShift++;
	    mask = mask >> 1;
	}
	mask = (1 << image->depth) - 1;
	glGetIntegerv(GL_RED_BITS, &rBits);
	glGetIntegerv(GL_GREEN_BITS, &gBits);
	glGetIntegerv(GL_BLUE_BITS, &bBits);
	rFactor = (1 << rBits) - 1;
	gFactor = (1 << gBits) - 1;
	bFactor = (1 << bBits) - 1;

        tmpBuf = (float *)malloc(ptr->width*ptr->height*3*sizeof(float));
        tmpPtr = tmpBuf;
        for ( j = 0; j < ptr->height; j++) {
            for (i = 0; i < ptr->width; i++) {
                c = XGetPixel(image, i, j);
                    *tmpPtr++ = ((float)((c & image->red_mask) >> rShift)) / rFactor;
                    *tmpPtr++ = ((float)((c & image->green_mask) >> gShift)) / gFactor;
                    *tmpPtr++ = ((float)((c & image->blue_mask) >> bShift)) / bFactor;
            }
        }

	/*
	** X reads top to bottom, so reverse the line ordering to match
	** GL's bottom to top ordering.
	*/
	tmpPtr = tmpBuf;
	for (i = ptr->height - 1; i >= 0; i--) {
	    for (j = 0; j < ptr->width * 3; j++) {
		destPtr[i*ptr->width*3 + j] = *tmpPtr++;
	    }
	}
	free(tmpBuf);
   } else {
        for ( j = 0; j < ptr->height; j++) {
            for (i = 0; i < ptr->width; i++) {
                destPtr[(ptr->height-j-1)*ptr->width + i] = (float) XGetPixel(image, i, j);
            }
        }
    }

    XDestroyImage(image);
}

static void GetVisuals(TK_VisualIDsRec *ptr)
{
    XVisualInfo vInfoTmp, *vInfoList;
    int total, useGL, i;

    ptr->count = 0;

    if (!DisplayInit()) {
	return;
    }
    vInfoTmp.screen = screen;
    vInfoList = XGetVisualInfo(display, VisualScreenMask, &vInfoTmp, &total);

    for (i = 0; i < total; i++) {
	glXGetConfig(display, &vInfoList[i], GLX_USE_GL, &useGL);
	if (useGL) {
	    ptr->IDs[ptr->count++] = vInfoList[i].visualid;
	}
    }

    XFree((char *)vInfoList);
}

void tkGet(long item, void *data)
{

    if (item == TK_SCREENIMAGE) {
	ScreenImage((TK_ScreenImageRec *)data);
    } else if (item == TK_VISUALIDS) {
	GetVisuals((TK_VisualIDsRec *)data);
    }
}

long tkLoadFont(char *fontName, long *width, long *height)
{
    XFontStruct *fontInfo;
    Font id;
    int first, last;
    GLuint base;

    fontInfo = XLoadQueryFont(display, fontName);
    if (fontInfo == NULL) {
	return 0;
    }

    id = fontInfo->fid;
    first = (int)fontInfo->min_char_or_byte2;
    last = (int)fontInfo->max_char_or_byte2;

    base = glGenLists(last+1);
    if (base == 0) {
	return 0;
    }
    glXUseXFont(id, first, last-first+1, base+first);
    *height = fontInfo->ascent + fontInfo->descent;
    *width = fontInfo->max_bounds.width;
    return base;
}

long tkDrawFont(char *fontName, long x, long y, char *string, long len)
{
    static char pattern1[] = "-adobe-courier-bold-o-normal--14-*-*-*-*-*-*-*";
    static char pattern2[] = "-*-*-*-*-*-*-14-*-*-*-*-*-*-*";
    static char size[] = "456781";
    XFontStruct *fontInfo;
    GC gc;
    XGCValues values;
    XColor exact, green;
    char **fontList;
    unsigned long mask;
    long count, i;

    glXWaitGL();

    /*
    ** Look for a common font first, then look for any font in
    ** a range of point sizes from 11 to 18.
    */
    fontList = XListFonts(display, pattern1, 1, (int *)&count);
    if (count == 0) {
	for (i = 0; i < 6; i++) {
	    pattern2[14] = size[i];
	    fontList = XListFonts(display, pattern2, 1, (int *)&count);
	    if (count > 0) {
		break;
	    }
	}
    }
    if (count == 0) {
       return 0;
    }

    strcpy(fontName, fontList[0]);

    fontInfo = XLoadQueryFont(display, fontList[0]);
    if (fontInfo == NULL) {
        return 0;
    }

    mask = GCForeground | GCFont;
    values.font = fontInfo->fid;

    if (TK_WIND_IS_RGB(windType)) {
	XAllocNamedColor(display, colorMap, "Green", &exact, &green);
	values.foreground = green.pixel;
    } else {
	values.foreground = 2; /* 2 = GREEN. */
    }

    gc = XCreateGC(display, window, mask, &values);

    XDrawString(display, window, gc, (int)x, (int)y, string, (int)len);

    XFreeFontNames(fontList);
    glXWaitX();
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\depth.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _depthRec {
    long index;
    GLenum value;
    char *name;
    enumRec *enumTable;
} depthRec;


enumRec enum_Depth[] = {
    GL_EQUAL, "GL_EQUAL",
    GL_NOTEQUAL, "GL_NOTEQUAL",
    GL_LESS, "GL_LESS",
    GL_LEQUAL, "GL_LEQUAL",
    GL_GREATER, "GL_GREATER",
    GL_GEQUAL, "GL_GEQUAL",
    GL_ALWAYS, "GL_ALWAYS",
    GL_NEVER, "GL_NEVER",
    -1, "End of List"
};


void DepthInit(void *data)
{
    depthRec *ptr;

    ptr = (depthRec *)malloc(sizeof(depthRec));    
    *((void **)data) = (void *)ptr;
    ptr->enumTable = enum_Depth;
    ptr->index = 0;
    ptr->value = ptr->enumTable->value;
    ptr->name = ptr->enumTable->name;
}

long DepthUpdate(void *data)
{
    depthRec *ptr = (depthRec *)data;

    ptr->index += 1;
    if (ptr->enumTable[ptr->index].value == -1) {
	ptr->index = 0;
	ptr->value = ptr->enumTable->value;
	ptr->name = ptr->enumTable->name;
	return 1;
    } else {
	ptr->value = ptr->enumTable[ptr->index].value;
	ptr->name = ptr->enumTable[ptr->index].name;
	return 0;
    }
}

void DepthSet(long enabled, void *data)
{
    depthRec *ptr = (depthRec *)data;

    if (enabled) {
	glDepthFunc(ptr->value);
	glDepthRange(-1, 1);
	glEnable(GL_DEPTH_TEST);
    } else {
	glDisable(GL_DEPTH_TEST);
    }
    Probe();
}

void DepthStatus(long enabled, void *data)
{
    depthRec *ptr = (depthRec *)data;

    if (enabled) {
	Output("Depth on.\n");
	Output("\t%s.\n", ptr->name);
    } else {
	Output("Depth off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\driver.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include "ctk.h"
#include "tproto.h"
#include "driver.h"
#include "shell.h"


driverRec driver[] = {
    {
	TEST_HINT,
	HintInit, HintSet, HintStatus, HintUpdate
    },
    {
	TEST_ALIAS,
	AliasInit, AliasSet, AliasStatus, AliasUpdate
    },
    {
	TEST_ALPHA,
	AlphaInit, AlphaSet, AlphaStatus, AlphaUpdate
    },
    {
	TEST_BLEND,
	BlendInit, BlendSet, BlendStatus, BlendUpdate
    },
    {
	TEST_DEPTH,
	DepthInit, DepthSet, DepthStatus, DepthUpdate
    },
    {
	TEST_DITHER,
	DitherInit, DitherSet, DitherStatus, DitherUpdate
    },
    {
	TEST_FOG,
	FogInit, FogSet, FogStatus, FogUpdate
    },
    {
	TEST_LIGHT,
	LightInit, LightSet, LightStatus, LightUpdate
    },
    {
	TEST_LOGICOP,
	LogicOpInit, LogicOpSet, LogicOpStatus, LogicOpUpdate
    },
    {
	TEST_SCISSOR,
	ScissorInit, ScissorSet, ScissorStatus, ScissorUpdate
    },
    {
	TEST_SHADE,
	ShadeInit, ShadeSet, ShadeStatus, ShadeUpdate
    },
    {
	TEST_STENCIL,
	StencilInit, StencilSet, StencilStatus, StencilUpdate
    },
    {
	TEST_STIPPLE,
	StippleInit, StippleSet, StippleStatus, StippleUpdate
    },
    {
	TEST_TEXTURE,
	TextureInit, TextureSet, TextureStatus, TextureUpdate
    },
    {
	TEST_NULL
    }
};


static long TestProc(void)
{
    long i;

    i = 0;
    while (driver[i].test != TEST_NULL) {
	i++;
    }
    if (driver[i-1].enabled == 1) {
	return 0;
    }

    i = 0;
    while (1) {
	if (driver[i].test == TEST_NULL) {
	    driver[0].enabled = 1;
	    return 1;
	} else if (driver[i].enabled == 1) {
	    driver[i].enabled = 0;
	    driver[i+1].enabled = 1;
	    return 1;
	}
	i++;
    }
}

long Driver(long op)
{
    long flag, i;

    switch (op) {
	case DRIVER_INIT:
	    for (i = 0; driver[i].test != TEST_NULL; i++) {
		(*driver[i].funcInit)((void *)&driver[i].data);
		driver[i].enabled = 0;
		driver[i].finish = 0;
		if (glGetError() != GL_NO_ERROR) {
		    printf("primtest failed.\n\n");
		    return 0;
		}
	    }
	    return 1;
	case DRIVER_SET:
	    for (i = 0; driver[i].test != TEST_NULL; i++) {
		(*driver[i].funcSet)(driver[i].enabled, driver[i].data);
		if (glGetError() != GL_NO_ERROR) {
		    printf("primtest failed.\n\n");
		    return 0;
		}
	    }
	    return 1;
	case DRIVER_STATUS:
	    for (i = 0; driver[i].test != TEST_NULL; i++) {
		(*driver[i].funcStatus)(driver[i].enabled, driver[i].data);
		if (glGetError() != GL_NO_ERROR) {
		    printf("primtest failed.\n\n");
		    return 0;
		}
	    }
	    Output("\n");
	    return 1;
	case DRIVER_UPDATE:
	    for (i = 0; driver[i].test != TEST_NULL; i++) {
		if (driver[i].enabled) {
		    driver[i].finish = (*driver[i].funcUpdate)(driver[i].data);
		    if (glGetError() != GL_NO_ERROR) {
			printf("primtest failed.\n\n");
			return 0;
		    }
		} else {
		    driver[i].finish = 1;
		}
	    }
	    flag = 1;
	    for (i = 0; driver[i].test != TEST_NULL; i++) {
		if (driver[i].enabled && driver[i].finish == 0) {
		    flag = 0;
		}
	    }
	    if (flag) {
		return TestProc();
	    } else {
		return 1;
	    }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\driver.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

enum {
    DRIVER_INIT = 0,
    DRIVER_SET,
    DRIVER_STATUS,
    DRIVER_UPDATE
};


typedef struct _driverRec {
    long test;
    void (*funcInit)(void *);
    void (*funcSet)(long, void *);
    void (*funcStatus)(long, void *);
    long (*funcUpdate)(void *);
    void *data;
    long enabled, finish;
} driverRec;


extern driverRec driver[];


extern long Driver(long);
extern void DrawPrims(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\fog.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _fogRec {
    long index;
    long value;
    char *name;
    enumRec *enumTable;
} fogRec;


enumRec enum_FogMode[] = {
    GL_LINEAR, "GL_LINEAR",
    GL_EXP, "GL_EXP",
    GL_EXP2, "GL_EXP2",
    -1, "End of List"
};


void FogInit(void *data)
{
    static GLfloat color[] = {1.0, 1.0, 1.0, 1.0};
    static GLfloat start[] = {0.0};
    static GLfloat end[] = {1.0};
    static GLfloat density[] = {1.0};
    fogRec *ptr;

    ptr = (fogRec *)malloc(sizeof(fogRec));    
    *((void **)data) = (void *)ptr;
    ptr->enumTable = enum_FogMode;
    ptr->index = 0;
    ptr->value = ptr->enumTable->value;
    ptr->name = ptr->enumTable->name;

    glFogfv(GL_FOG_COLOR, color);
    glFogfv(GL_FOG_DENSITY, density);
    glFogfv(GL_FOG_START, start);
    glFogfv(GL_FOG_END, end);
    Probe();
}

long FogUpdate(void *data)
{
    fogRec *ptr = (fogRec *)data;

    ptr->index += 1;
    if (ptr->enumTable[ptr->index].value == -1) {
	ptr->index = 0;
	ptr->value = ptr->enumTable->value;
	ptr->name = ptr->enumTable->name;
	return 1;
    } else {
	ptr->value = ptr->enumTable[ptr->index].value;
	ptr->name = ptr->enumTable[ptr->index].name;
	return 0;
    }
}

void FogSet(long enabled, void *data)
{
    fogRec *ptr = (fogRec *)data;
    GLfloat buf[1];

    if (enabled) {
	buf[0] = (float)ptr->value;
	glFogfv(GL_FOG_MODE, buf);
	glEnable(GL_FOG);
    } else {
	glDisable(GL_FOG);
    }
    Probe();
}

void FogStatus(long enabled, void *data)
{
    fogRec *ptr = (fogRec *)data;

    if (enabled) {
	Output("Fog on.\n");
	Output("\t%s.\n", ptr->name);
    } else {
	Output("Fog off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\logic.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _logicOpRec {
    long index;
    GLenum value;
    char *name;
    enumRec *enumTable;
} logicOpRec;


enumRec enum_LogicOp[] = {
    GL_NOOP, "GL_NOOP",
    GL_SET, "GL_SET",
    GL_EQUIV, "GL_EQUIV",
    GL_INVERT, "GL_INVERT",
    GL_CLEAR, "GL_CLEAR",
    GL_COPY, "GL_COPY",
    GL_COPY_INVERTED, "GL_COPY_INVERTED",
    GL_AND, "GL_AND",
    GL_AND_REVERSE, "GL_AND_REVERSE",
    GL_AND_INVERTED, "GL_AND_INVERTED",
    GL_OR, "GL_OR",
    GL_OR_REVERSE, "GL_OR_REVERSE",
    GL_OR_INVERTED, "GL_OR_INVERTED",
    GL_NAND, "GL_NAND",
    GL_XOR, "GL_XOR",
    GL_NOR, "GL_NOR",
    -1, "End of List"
};


void LogicOpInit(void *data)
{
    logicOpRec *ptr;

    ptr = (logicOpRec *)malloc(sizeof(logicOpRec));    
    *((void **)data) = (void *)ptr;
    ptr->enumTable = enum_LogicOp;
    ptr->index = 0;
    ptr->value = ptr->enumTable->value;
    ptr->name = ptr->enumTable->name;
}

long LogicOpUpdate(void *data)
{
    logicOpRec *ptr = (logicOpRec *)data;

    ptr->index += 1;
    if (ptr->enumTable[ptr->index].value == -1) {
	ptr->index = 0;
	ptr->value = ptr->enumTable->value;
	ptr->name = ptr->enumTable->name;
	return 1;
    } else {
	ptr->value = ptr->enumTable[ptr->index].value;
	ptr->name = ptr->enumTable[ptr->index].name;
	return 0;
    }
}

void LogicOpSet(long enabled, void *data)
{
    logicOpRec *ptr = (logicOpRec *)data;

    if (enabled) {
	glLogicOp(ptr->value);
	glEnable(GL_LOGIC_OP);
    } else {
	glDisable(GL_LOGIC_OP);
    }
    Probe();
}

void LogicOpStatus(long enabled, void *data)
{
    logicOpRec *ptr = (logicOpRec *)data;

    if (enabled) {
	Output("Logic Op on.\n");
	Output("\t%s.\n", ptr->name);
    } else {
	Output("Logic Op off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\light.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _lightRec {
    long index[2];
    long value[2];
    char *name[2];
    enumRec *enumTable[2];
} lightRec;


enumRec enum_Light_LocalViewer[] = {
    GL_TRUE, "GL_TRUE",
    GL_FALSE, "GL_FALSE",
    -1, "End of List"
};

enumRec enum_Light_TwoSided[] = {
    GL_TRUE, "GL_TRUE",
    GL_FALSE, "GL_FALSE",
    -1, "End of List"
};


void LightInit(void *data)
{
    static GLenum buf1[] = {
	GL_LIGHT0, GL_LIGHT1, GL_LIGHT2, GL_LIGHT3,
	GL_LIGHT4, GL_LIGHT5, GL_LIGHT6, GL_LIGHT7
    };
    static GLenum buf2[] = {
	GL_FRONT, GL_BACK
    };
    static GLfloat lm_ambient[] = {0.2, 0.2, 0.2, 1.0};
    static GLfloat l_ambient[] = {0.1, 0.1, 0.1, 1.0};
    static GLfloat l_diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static GLfloat l_specular[] = {0.5, 1.0, 1.0, 1.0};
    static GLfloat l_position[] = {BOXW, BOXH, -100.0, 1.0};
    static GLfloat l_spot_dir[] = {0.0, 0.0, -1.0};
    static GLfloat l_spot_expon[] = {1.0};
    static GLfloat l_spot_cutoff[] = {0.0};
    static GLfloat l_atten_const[] = {1.0};
    static GLfloat l_atten_lin[] = {1.0};
    static GLfloat l_atten_quad[] = {1.0};
    static GLfloat mat_shininess[] = {30.0};
    static GLfloat mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static GLfloat mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static GLfloat mat_ambient[] = {0.2, 0.2, 0.2, 1.0};
    static GLfloat mat_emission[] = {0.0, 0.0, 0.0, 1.0};
    lightRec *ptr;
    long i;

    ptr = (lightRec *)malloc(sizeof(lightRec));    
    *((void **)data) = (void *)ptr;

    ptr->enumTable[0] = enum_Light_LocalViewer;
    ptr->enumTable[1] = enum_Light_TwoSided;

    for (i = 0; i < 2; i++) {
	ptr->index[i] = 0;
	ptr->value[i] = ptr->enumTable[i]->value;
	ptr->name[i] = ptr->enumTable[i]->name;
    }

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lm_ambient);
    for (i = 0; i < 2; i++) {
	glMaterialfv(buf2[i], GL_SHININESS, mat_shininess);
	glMaterialfv(buf2[i], GL_SPECULAR, mat_specular);
	glMaterialfv(buf2[i], GL_DIFFUSE, mat_diffuse);
	glMaterialfv(buf2[i], GL_EMISSION, mat_emission);
	glMaterialfv(buf2[i], GL_AMBIENT, mat_ambient);
    }
    for (i = 0; i < 8; i++) {
	glLightfv(buf1[i], GL_AMBIENT, l_ambient);
	glLightfv(buf1[i], GL_DIFFUSE, l_diffuse);
	glLightfv(buf1[i], GL_SPECULAR, l_specular);
	glLightfv(buf1[i], GL_POSITION, l_position);
	glLightfv(buf1[i], GL_SPOT_DIRECTION, l_position);
	glLightfv(buf1[i], GL_SPOT_EXPONENT, l_spot_expon);
	glLightfv(buf1[i], GL_SPOT_CUTOFF, l_spot_cutoff);
	glLightfv(buf1[i], GL_CONSTANT_ATTENUATION, l_atten_const);
	glLightfv(buf1[i], GL_LINEAR_ATTENUATION, l_atten_lin);
	glLightfv(buf1[i], GL_QUADRATIC_ATTENUATION, l_atten_quad);
	glEnable(buf1[i]);
    }
    Probe();
}

long LightUpdate(void *data)
{
    lightRec *ptr = (lightRec *)data;
    long flag, i;

    flag = 1;
    for (i = 1; i >= 0; i--) {
	if (flag) {
	    ptr->index[i] += 1;
	    if (ptr->enumTable[i][ptr->index[i]].value == -1) {
		ptr->index[i] = 0;
		ptr->value[i] = ptr->enumTable[i]->value;
		ptr->name[i] = ptr->enumTable[i]->name;
		flag = 1;
	    } else {
		ptr->value[i] = ptr->enumTable[i][ptr->index[i]].value;
		ptr->name[i] = ptr->enumTable[i][ptr->index[i]].name;
		flag = 0;
	    }
	}
    }

    return flag;
}

void LightSet(long enabled, void *data)
{
    lightRec *ptr = (lightRec *)data;
    GLfloat buf[1];

    if (enabled) {
	buf[0] = (GLfloat)ptr->value[0];
	glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, buf);
	buf[0] = (GLfloat)ptr->value[1];
	glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, buf);
	glEnable(GL_LIGHTING);
    } else {
	glDisable(GL_LIGHTING);
    }
    Probe();
}

void LightStatus(long enabled, void *data)
{
    lightRec *ptr = (lightRec *)data;

    if (enabled) {
	Output("Lighting on.\n");
	Output("\t%s, %s.\n", ptr->name[0], ptr->name[1]);
    } else {
	Output("Lighting off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\prim.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void Point(void)
{
    GLfloat x, y;

    glPointSize(1.0);
    glBegin(GL_POINTS);
	glColor3fv(rgbColorMap[RED]);
	glVertex2f(-BOXW/2.0+0.5, BOXH/2.0+0.5);
	glNormal3f(0.0, 0.0, 1.0);
	x = (-BOXW / 2.0 + 0.5 + BOXW) / (BOXW * 2.0);
	y = (BOXH / 2.0 + 0.5 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);
    glEnd();
}

void Line(void)
{
    GLfloat x, y;

    glLineWidth(1.0);
    glBegin(GL_LINES);
	glColor3fv(rgbColorMap[GREEN]);
	glVertex2f(BOXW/2.0, BOXH/2.0+0.5);
	glNormal3f(0.0, 0.0, 1.0);
	x = (BOXW / 2.0 + BOXW) / (BOXW * 2.0);
	y = (BOXH / 2.0 + 0.5 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[YELLOW]);
	glVertex2f(BOXW/2.0+1.0, BOXH/2.0+0.5);
	glNormal3f(0.0, 0.0, 1.0);
	glTexCoord2f(x, y);
	x = (BOXW / 2.0 + 1.0 + BOXW) / (BOXW * 2.0);
	y = (BOXH / 2.0 + 0.5 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);
    glEnd();
}

void Triangle(void)
{
    GLfloat x, y;

    glBegin(GL_TRIANGLES);
	glColor3fv(rgbColorMap[BLUE]);
	glVertex2f(-BOXW/2.0+0.5, -BOXH/2.0+0.75);
	glNormal3f(0.0, 0.0, -100.0);
	x = (-BOXW / 2.0 + 0.5 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + 0.75 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[MAGENTA]);
	glVertex2f(-BOXW/2.0+0.25, -BOXH/2.0+0.25);
	glNormal3f(0.0, 0.0, -100.0);
	x = (-BOXW / 2.0 + 0.25 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + 0.25 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[CYAN]);
	glVertex2f(-BOXW/2.0+0.75, -BOXH/2.0+0.25);
	glNormal3f(0.0, 0.0, -100.0);
	x = (-BOXW / 2.0 + 0.75 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + 0.25 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);
    glEnd();
}

void Quad(void)
{
    GLfloat x, y;

    glBegin(GL_QUADS);
	glColor3fv(rgbColorMap[RED]);
	glVertex2f(BOXW/2.0, -BOXH/2.0);
	glNormal3f(0.0, 0.0, -100.0);
	x = (BOXW / 2.0 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[GREEN]);
	glVertex2f(BOXW/2.0+1.0, -BOXH/2.0);
	glNormal3f(0.0, 0.0, -100.0);
	x = (BOXW / 2.0 + 1.0 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[BLUE]);
	glVertex2f(BOXW/2.0+1.0, -BOXH/2.0+1.0);
	glNormal3f(0.0, 0.0, -100.0);
	x = (BOXW / 2.0 + 1.0 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + 1.0 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);

	glColor3fv(rgbColorMap[YELLOW]);
	glVertex2f(BOXW/2.0, -BOXH/2.0+1.0);
	glNormal3f(0.0, 0.0, -100.0);
	x = (BOXW / 2.0 + BOXW) / (BOXW * 2.0);
	y = (-BOXH / 2.0 + 1.0 + BOXH) / (BOXH * 2.0);
	glTexCoord2f(x, y);
    glEnd();
}

void DrawPrims(void)
{

    Point();
    glFlush();

    Line();
    glFlush();

    Triangle();
    glFlush();

    Quad();
    glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\hint.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _hintRec {
    long index[2];
    GLenum value[2];
    char *name[2];
    enumRec *enumTable[2];
} hintRec;


enumRec enum_HintTarget[] = {
    GL_POINT_SMOOTH_HINT, "GL_POINT_SMOOTH_HINT",
    GL_LINE_SMOOTH_HINT, "GL_LINE_SMOOTH_HINT",
    GL_POLYGON_SMOOTH_HINT, "GL_POLYGON_SMOOTH_HINT",
    GL_PERSPECTIVE_CORRECTION_HINT, "GL_PERSPECTIVE_CORRECTION_HINT",
    GL_FOG_HINT, "GL_FOG_HINT",
    -1, "End of List"
};

enumRec enum_HintMode[] = {
    GL_NICEST, "GL_NICEST",
    GL_FASTEST, "GL_FASTEST",
    -1, "End of List"
};


void HintInit(void *data)
{
    hintRec *ptr;
    long i;

    ptr = (hintRec *)malloc(sizeof(hintRec));    
    *((void **)data) = (void *)ptr;

    ptr->enumTable[0] = enum_HintTarget;
    ptr->enumTable[1] = enum_HintMode;

    for (i = 0; i < 2; i++) {
	ptr->index[i] = 0;
	ptr->value[i] = ptr->enumTable[i]->value;
	ptr->name[i] = ptr->enumTable[i]->name;
    }
}

long HintUpdate(void *data)
{
    hintRec *ptr = (hintRec *)data;
    long flag, i;

    flag = 1;
    for (i = 1; i >= 0; i--) {
	if (flag) {
	    ptr->index[i] += 1;
	    if (ptr->enumTable[i][ptr->index[i]].value == -1) {
		ptr->index[i] = 0;
		ptr->value[i] = ptr->enumTable[i]->value;
		ptr->name[i] = ptr->enumTable[i]->name;
		flag = 1;
	    } else {
		ptr->value[i] = ptr->enumTable[i][ptr->index[i]].value;
		ptr->name[i] = ptr->enumTable[i][ptr->index[i]].name;
		flag = 0;
	    }
	}
    }

    return flag;
}

void HintSet(long enabled, void *data)
{
    hintRec *ptr = (hintRec *)data;

    if (enabled) {
	glHint(ptr->value[0], ptr->value[1]);
    } else {
	glHint(GL_POINT_SMOOTH_HINT, GL_DONT_CARE);
	glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
	glHint(GL_POLYGON_SMOOTH_HINT, GL_DONT_CARE);
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_DONT_CARE);
	glHint(GL_FOG_HINT, GL_DONT_CARE);
    }
    Probe();
}

void HintStatus(long enabled, void *data)
{
    hintRec *ptr = (hintRec *)data;

    if (enabled) {
	Output("Hint.\n");
	Output("\t%s, %s.\n", ptr->name[0], ptr->name[1]);
    } else {
	Output("Hint GL_DONT_CARE.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\scissor.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void ScissorInit(void *data)
{

    *((void **)data) = (void *)0;
}

long ScissorUpdate(void *data)
{

    return 1;
}

void ScissorSet(long enabled, void *data)
{

    if (enabled) {
	glScissor(0, 0, BOXW/2, BOXH/2);
	glEnable(GL_SCISSOR_TEST);
    } else {
	glDisable(GL_SCISSOR_TEST);
    }
    Probe();
}

void ScissorStatus(long enabled, void *data)
{

    if (enabled) {
	Output("Scissor on.\n");
    } else {
	Output("Scissor off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\shade.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _shadeRec {
    long index;
    GLenum value;
    char *name;
    enumRec *enumTable;
} shadeRec;


enumRec enum_Shade[] = {
    GL_FLAT, "GL_FLAT",
    -1, "End of List"
};


void ShadeInit(void *data)
{
    shadeRec *ptr;

    ptr = (shadeRec *)malloc(sizeof(shadeRec));    
    *((void **)data) = (void *)ptr;
    ptr->enumTable = enum_Shade;
    ptr->index = 0;
    ptr->value = ptr->enumTable->value;
    ptr->name = ptr->enumTable->name;
}

long ShadeUpdate(void *data)
{
    shadeRec *ptr = (shadeRec *)data;

    ptr->index += 1;
    if (ptr->enumTable[ptr->index].value == -1) {
	ptr->index = 0;
	ptr->value = ptr->enumTable->value;
	ptr->name = ptr->enumTable->name;
	return 1;
    } else {
	ptr->value = ptr->enumTable[ptr->index].value;
	ptr->name = ptr->enumTable[ptr->index].name;
	return 0;
    }
}

void ShadeSet(long enabled, void *data)
{
    shadeRec *ptr = (shadeRec *)data;

    if (enabled) {
	glShadeModel(ptr->value);
    } else {
	glShadeModel(GL_SMOOTH);
    }
    Probe();
}

void ShadeStatus(long enabled, void *data)
{
    shadeRec *ptr = (shadeRec *)data;

    if (enabled) {
	Output("Shading.\n");
	Output("\t%s\n", ptr->name);
    } else {
	Output("Shading SMOOTH.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\shell.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#ifdef NT

// Added these pragmas to suppress OGLCFM warnings.
//
#pragma warning(disable : 4244)  //Mips (conversion of double/float)
#pragma warning(disable : 4245)  //Mips (conversion of signed/unsigned)
#pragma warning(disable : 4007)  //x86  (main must be _cdecl)
#pragma warning(disable : 4236)  //x86
#pragma warning(disable : 4051)  //Alpha

#endif


enum {
    BLACK = 0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE,
    GREY
};


#define BOXW 50
#define BOXH 50


typedef struct _enumRec {
    GLenum value;
    char name[40];
} enumRec;


extern GLfloat rgbColorMap[][3];


extern void Output(char *, ...);
extern void Probe(void);
extern float Random(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\stipple.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void StippleInit(void *data)
{
    static GLubyte buf[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x0F, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    *((void **)data) = (void *)0;
    glLineStipple(1, 0xA5A5);
    glPolygonStipple(buf);
    Probe();
}

long StippleUpdate(void *data)
{

    return 1;
}

void StippleSet(long enabled, void *data)
{

    if (enabled) {
	glEnable(GL_LINE_STIPPLE);
	glEnable(GL_POLYGON_STIPPLE);
    } else {
	glDisable(GL_LINE_STIPPLE);
	glDisable(GL_POLYGON_STIPPLE);
    }
    Probe();
}

void StippleStatus(long enabled, void *data)
{

    if (enabled) {
	Output("Stipple on.\n");
    } else {
	Output("Stipple off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\shell.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ctk.h"
#include "driver.h"
#include "shell.h"


long verbose;
GLint visualID = -99;

GLfloat rgbColorMap[][3] = {
    {0.0, 0.0, 0.0},
    {1.0, 0.0, 0.0},
    {0.0, 1.0, 0.0},
    {1.0, 1.0, 0.0},
    {0.0, 0.0, 1.0},
    {1.0, 0.0, 1.0},
    {0.0, 1.0, 1.0},
    {1.0, 1.0, 1.0},
    {0.5, 0.5, 0.5}
};


static void MakeIdentMatrix(GLfloat *buf)
{
    long i;

    for (i = 0; i < 16; i++) {
	buf[i] = 0.0;
    }
    for (i = 0; i < 4; i++) {
	buf[i*4+i] = 1.0;
    }
}

static void Ortho2D(double left, double right, double bottom, double top)
{
    GLfloat m[4][4], deltaX, deltaY;
    GLint mode;

    MakeIdentMatrix(&m[0][0]);
    deltaX = right - left;
    deltaY = top - bottom;
    m[0][0] = 2.0 / deltaX;
    m[3][0] = -(right + left) / deltaX;
    m[1][1] = 2.0 / deltaY;
    m[3][1] = -(top + bottom) / deltaY;
    m[2][2] = -1;
    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(&m[0][0]);
    glMatrixMode(mode);
}

void Output(char *format, ...)
{
    va_list args;

    va_start(args, format);
    if (verbose) {
	vprintf(format, args);
	fflush(stdout);
    }
    va_end(args);
}

void Probe(void)
{

    if (glGetError() != GL_NO_ERROR) {
	Output("\n");
	printf("primtest failed.\n\n");
	tkQuit();
    }
}

float Random(void)
{

    return (float)((double)rand() / RAND_MAX);
}

long Exec(TK_EventRec *ptr)
{
    unsigned long x;

    if (ptr->event == TK_EVENT_EXPOSE) {
	glViewport(0, 0, BOXW*2, BOXH*2);
	Ortho2D(-BOXW, BOXW, -BOXH, BOXH);

	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);

	x = 0;
	Driver(DRIVER_INIT);
	do {
	    Driver(DRIVER_STATUS);
	    Driver(DRIVER_SET);
	    DrawPrims();
	    x++;
	} while (Driver(DRIVER_UPDATE));

	if (verbose) {
	    printf("\n%d Combinations.\n", x);
	}

	printf("primtest passed.\n\n");
	return 0;
    }
    return 1;
}

static long Init(int argc, char **argv)
{
    long i;

    verbose = 0;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-help") == 0) {
	    printf("Options:\n");
	    printf("\t-help     Print this help screen.\n");
            printf("\t-a        [Default] Run tests on all pixel formats. \n");
            printf("\t-s        Run tests on all display pixel formats. \n");
            printf("\t-b        Run tests on all bitmap pixel formats. \n");
	    printf("\t-v        Verbose mode on.\n");
	    printf("\n");
	    return 1;
	} else if (strcmp(argv[i], "-v") == 0) {
	    verbose = 1;
        } else if (strcmp(argv[i], "-a") == 0) {    // all display & bitmap fmt
            visualID = -99;
        } else if (strcmp(argv[i], "-s") == 0) {    // all display formats
            visualID = -98;
        } else if (strcmp(argv[i], "-b") == 0) {    // all bitmap formats
            visualID = -97;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return 1;
	}
    }
    return 0;
}

int main(int argc, char **argv)
{
    TK_WindowRec        wind;
    TK_VisualIDsRec     list;
    int                 i;
    BOOL                bTestAll = FALSE;

    printf("Open GL Primitives Test.\n");
    printf("Version 1.0.14\n");
    printf("\n");

    if (Init(argc, argv)) {
	tkQuit();
	return 1;
    }

    strcpy(wind.name, "Primitives Test");
    wind.x          = 0;
    wind.y          = 0;
    wind.width      = BOXW*2;
    wind.height     = BOXH*2;
    wind.type       = TK_WIND_REQUEST;
    wind.eventMask  = TK_EVENT_EXPOSE;

    switch (visualID) {
        case -99:   // test all display and bitmap pixel formats
            bTestAll = TRUE;
            // fall through

        case -98:   // test all display pixel formats
            tkGet(TK_VISUALIDS, (void *)&list);
            for (i = 0; i < list.count; i++) {
                wind.type   = TK_WIND_VISUAL;
                wind.info   = (GLint)list.IDs[i];
                wind.render = TK_WIND_DIRECT;
                if (tkNewWindow(&wind)) {
                    printf("Display ID %d \n", list.IDs[i]);
                    tkExec(Exec);
                    tkCloseWindow();
                } else {
                    printf("Display ID %d not found.\n\n", list.IDs[i]);
                }
            }
            if (!bTestAll)
                break;
            // fall through

        case -97:   // test all bitmap pixel formats
            tkGet(TK_VISUALIDS, (void *)&list);
            for (i = 0; i < list.count; i++) {
                wind.type   = TK_WIND_VISUAL;
                wind.info   = -(GLint)list.IDs[i];
                wind.render = TK_WIND_DIRECT;
                if (tkNewWindow(&wind)) {
                    printf("Bitmap ID %d \n", -list.IDs[i]);
                    tkExec(Exec);
                    tkCloseWindow();
                } else {
                    printf("Bitmap ID %d not found.\n\n", -list.IDs[i]);
                }
            }
            break;
        default:
            break;
    }
    tkQuit();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\texture.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _textureRec {
    long index[11];
    long value[11];
    char *name[11];
    enumRec *enumTable[11];
} textureRec;


enumRec enum_TextureTarget[] = {
    GL_TEXTURE_1D, "GL_TEXTURE_1D",
    GL_TEXTURE_2D, "GL_TEXTURE_2D",
    -1, "End of List"
};

enumRec enum_TextureEnv[] = {
    GL_MODULATE, "GL_MODULATE",
    GL_DECAL, "GL_DECAL",
    GL_BLEND, "GL_BLEND",
    -1, "End of List"
};

enumRec enum_S_TextureGenMode[] = {
    GL_EYE_LINEAR, "GL_EYE_LINEAR",
    GL_OBJECT_LINEAR, "GL_OBJECT_LINEAR",
    GL_SPHERE_MAP, "GL_SPHERE_MAP",
    -1, "End of List"
};

enumRec enum_T_TextureGenMode[] = {
    GL_EYE_LINEAR, "GL_EYE_LINEAR",
    GL_OBJECT_LINEAR, "GL_OBJECT_LINEAR",
    GL_SPHERE_MAP, "GL_SPHERE_MAP",
    -1, "End of List"
};

enumRec enum_S_TextureWrapMode[] = {
    GL_REPEAT, "GL_REPEAT",
    GL_CLAMP, "GL_CLAMP",
    -1, "End of List"
};

enumRec enum_T_TextureWrapMode[] = {
    GL_REPEAT, "GL_REPEAT",
    GL_CLAMP, "GL_CLAMP",
    -1, "End of List"
};

enumRec enum_TextureMinFilter[] = {
    GL_NEAREST, "GL_NEAREST",
    GL_LINEAR, "GL_LINEAR",
    GL_NEAREST_MIPMAP_NEAREST, "GL_NEAREST_MIPMAP_NEAREST",
    GL_LINEAR_MIPMAP_NEAREST, "GL_LINEAR_MIPMAP_NEAREST",
    GL_NEAREST_MIPMAP_LINEAR, "GL_NEAREST_MIPMAP_LINEAR",
    GL_LINEAR_MIPMAP_LINEAR, "GL_LINEAR_MIPMAP_LINEAR",
    -1, "End of List"
};

enumRec enum_TextureMagFilter[] = {
    GL_NEAREST, "GL_NEAREST",
    GL_LINEAR, "GL_LINEAR",
    -1, "End of List"
};

enumRec enum_TexImage_PixelFormat[] = {
    GL_RED, "GL_RED",
    GL_GREEN, "GL_GREEN",
    GL_BLUE, "GL_BLUE",
    GL_ALPHA, "GL_ALPHA",
    GL_RGB, "GL_RGB",
    GL_RGBA, "GL_RGBA",
    GL_LUMINANCE, "GL_LUMINANCE",
    GL_LUMINANCE_ALPHA, "GL_LUMINANCE_ALPHA",
    -1, "End of List"
};

enumRec enum_TexImage_PixelType[] = {
    GL_UNSIGNED_BYTE, "GL_UNSIGNED_BYTE",
    GL_BYTE, "GL_BYTE",
    GL_UNSIGNED_SHORT, "GL_UNSIGNED_SHORT",
    GL_SHORT, "GL_SHORT",
    GL_UNSIGNED_INT, "GL_UNSIGNED_INT",
    GL_INT, "GL_INT",
    GL_FLOAT, "GL_FLOAT",
    -1, "End of List"
};

enumRec enum_TextureBorder[] = {
    0, "No Border",
    1, "One Border",
    -1, "End of List"
};


static void TextureMake(long format, long type, long size, GLfloat *src, GLfloat *dest)
{
    long extract, stride, i, j;

    size /= 4;
    switch (format) {
	case GL_RED:
	    src += 0;
	    extract = 1;
	    stride = 3;
	    break;
	case GL_GREEN:
	    src += 1;
	    extract = 1;
	    stride = 3;
	    break;
	case GL_BLUE:
	    src += 2;
	    extract = 1;
	    stride = 3;
	    break;
	case GL_ALPHA:
	    src += 3;
	    extract = 1;
	    stride = 3;
	    break;
	case GL_RGB:
	    src += 0;
	    extract = 3;
	    stride = 1;
	    break;
	case GL_RGBA:
	    src += 0;
	    extract = 4;
	    stride = 0;
	    break;
	case GL_LUMINANCE:
	    src += 0;
	    extract = 1;
	    stride = 3;
	    break;
	case GL_LUMINANCE_ALPHA:
	    src += 0;
	    extract = 2;
	    stride = 2;
	    break;
    }
    switch (type) {
	case GL_UNSIGNED_BYTE:
	    {
		unsigned char *ptr = (unsigned char *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (unsigned char)(*src++ * 255.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_BYTE:
	    {
		char *ptr = (char *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (char)(*src++ * 255.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_UNSIGNED_SHORT:
	    {
		unsigned short *ptr = (unsigned short *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (unsigned short)(*src++ * 65535.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_SHORT:
	    {
		short *ptr = (short *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (short)(*src++ * 65535.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_UNSIGNED_INT:
	    {
		unsigned long *ptr = (unsigned long *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (unsigned long)(*src++ * 65535.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_INT:
	    {
		long *ptr = (long *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (long)(*src++ * 65535.0);
		    }
		    src += stride;
		}
	    }
	    break;
	case GL_FLOAT:
	    {
		float *ptr = (float *)dest;
		for (i = 0; i < size; i++) {
		    for (j = 0; j < extract; j++) {
			*ptr++ = (float)*src++;
		    }
		    src += stride;
		}
	    }
	    break;
    }
}

void TextureInit(void *data)
{
    static GLfloat color[4] = {0.5, 0.5, 0.5, 1.0};
    textureRec *ptr;
    long i;

    ptr = (textureRec *)malloc(sizeof(textureRec));    
    *((void **)data) = (void *)ptr;

    ptr->enumTable[0] = enum_TextureTarget;
    ptr->enumTable[1] = enum_TextureEnv;
    ptr->enumTable[2] = enum_S_TextureGenMode;
    ptr->enumTable[3] = enum_T_TextureGenMode;
    ptr->enumTable[4] = enum_S_TextureWrapMode;
    ptr->enumTable[5] = enum_T_TextureWrapMode;
    ptr->enumTable[6] = enum_TextureMinFilter;
    ptr->enumTable[7] = enum_TextureMagFilter;
    ptr->enumTable[8] = enum_TexImage_PixelFormat;
    ptr->enumTable[9] = enum_TexImage_PixelType;
    ptr->enumTable[10] = enum_TextureBorder;

    for (i = 0; i < 11; i++) {
	ptr->index[i] = 0;
	ptr->value[i] = ptr->enumTable[i]->value;
	ptr->name[i] = ptr->enumTable[i]->name;
    }

    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_COLOR, color);
    glTexParameterfv(ptr->enumTable[0]->value, GL_TEXTURE_BORDER_COLOR, color);
    Probe();
}

long TextureUpdate(void *data)
{
    textureRec *ptr = (textureRec *)data;
    long flag, i;

    flag = 1;
    for (i = 10; i >= 0; i--) {
	if (flag) {
	    ptr->index[i] += 1;
	    if (ptr->enumTable[i][ptr->index[i]].value == -1) {
		ptr->index[i] = 0;
		ptr->value[i] = ptr->enumTable[i]->value;
		ptr->name[i] = ptr->enumTable[i]->name;
		flag = 1;
	    } else {
		ptr->value[i] = ptr->enumTable[i][ptr->index[i]].value;
		ptr->name[i] = ptr->enumTable[i][ptr->index[i]].name;
		flag = 0;
	    }
	}
    }

    return flag;
}

void TextureSet(long enabled, void *data)
{
    static GLfloat textureSrc[4*4*4] = {
	0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5,
	1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5,
	0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5,
	1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5, 1.0,1.0,1.0,0.5, 0.0,0.0,0.0,0.5
    };
    textureRec *ptr = (textureRec *)data;
    GLfloat buf[1], textureDest[1000];
    GLint component; 
    GLsizei size;

    if (enabled) {
	buf[0] = (GLfloat)ptr->enumTable[1]->value;
	glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, buf);

	glTexGeniv(GL_S, GL_TEXTURE_GEN_MODE, (GLint *)&ptr->enumTable[2]->value);
	glTexGeniv(GL_T, GL_TEXTURE_GEN_MODE, (GLint *)&ptr->enumTable[3]->value);

	buf[0] = (float)ptr->enumTable[4]->value;
	glTexParameterfv(ptr->enumTable[0]->value, GL_TEXTURE_WRAP_S, buf);
	buf[0] = (float)ptr->enumTable[5]->value;
	glTexParameterfv(ptr->enumTable[0]->value, GL_TEXTURE_WRAP_T, buf);
	buf[0] = (float)ptr->enumTable[6]->value;
	glTexParameterfv(ptr->enumTable[0]->value, GL_TEXTURE_MIN_FILTER, buf);
	buf[0] = (float)ptr->enumTable[7]->value;
	glTexParameterfv(ptr->enumTable[0]->value, GL_TEXTURE_MAG_FILTER, buf);

	TextureMake(ptr->enumTable[8]->value, ptr->enumTable[9]->value, 64, textureSrc, textureDest);

	switch (ptr->enumTable[8]->value) {
	    case GL_RED:
		component = 1;
		break;
	    case GL_GREEN:
		component = 1;
		break;
	    case GL_BLUE:
		component = 1;
		break;
	    case GL_ALPHA:
		component = 1;
		break;
	    case GL_RGB:
		component = 3;
		break;
	    case GL_RGBA:
		component = 4;
		break;
	    case GL_LUMINANCE:
		component = 1;
		break;
	    case GL_LUMINANCE_ALPHA:
		component = 2;
		break;
	}
	switch (ptr->enumTable[10]->value) {
	    case 0:
		size = 4;
		break;
	    case 1:
		size = 2;
		break;
	}
	switch (ptr->enumTable[0]->value) {
	    case GL_TEXTURE_1D:
		glTexImage1D(ptr->enumTable[0]->value, 0, component, size, ptr->enumTable[10]->value, ptr->enumTable[8]->value, ptr->enumTable[9]->value, (GLubyte *)textureDest);
		glEnable(GL_TEXTURE_1D);
		break;
	    case GL_TEXTURE_2D:
		glTexImage2D(ptr->enumTable[0]->value, 0, component, size, size, ptr->enumTable[10]->value, ptr->enumTable[8]->value, ptr->enumTable[9]->value, (GLubyte *)textureDest);
		glEnable(GL_TEXTURE_2D);
		break;
	}
    } else {
	glDisable(GL_TEXTURE_1D);
	glDisable(GL_TEXTURE_2D);
    }
    Probe();
}

void TextureStatus(long enabled, void *data)
{
    textureRec *ptr = (textureRec *)data;

    if (enabled) {
	Output("Texture on.\n");
	Output("\t%s.\n", ptr->name[1]);
	Output("\tGL_S, %s, %s, GL_T, %s, %s.\n", ptr->name[2], ptr->name[4],
	       ptr->name[3], ptr->name[5]);
	Output("\t%s, %s.\n", ptr->name[6], ptr->name[7]);
	Output("\t%s, %s, %s, %s.\n", ptr->name[0], ptr->name[8], ptr->name[9],
	       ptr->name[10]);
    } else {
	Output("Texture off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\atlantis.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <GL/gl.h>
#include <tk.h>
#include "atlantis.h"


fishRec sharks[NUM_SHARKS];
fishRec momWhale;
fishRec babyWhale;
fishRec dolph;

GLint windW, windH;
GLenum directRender;
GLenum mouseLeftAction = GL_FALSE, mouseRightAction = GL_FALSE,
       mouseMiddleAction = GL_FALSE;
char *fileName = 0;
TK_RGBImageRec *image;


void InitFishs(void)
{
    int i;

    for (i = 0; i < NUM_SHARKS; i++) {
        sharks[i].x = 70000.0 + rand() % 6000;
        sharks[i].y = rand() % 6000;
        sharks[i].z = rand() % 6000;
        sharks[i].psi = rand() % 360 - 180.0;
        sharks[i].v = 1.0;
    }

    dolph.x = 30000.0;
    dolph.y = 0.0;
    dolph.z = 6000.0;
    dolph.psi = 90.0;
    dolph.theta = 0.0;
    dolph.v = 3.0;

    momWhale.x = 70000.0;
    momWhale.y = 0.0;
    momWhale.z = 0.0;
    momWhale.psi = 90.0;
    momWhale.theta = 0.0;
    momWhale.v = 3.0;

    babyWhale.x = 60000.0;
    babyWhale.y = -2000.0;
    babyWhale.z = -2000.0;
    babyWhale.psi = 90.0;
    babyWhale.theta = 0.0;
    babyWhale.v = 3.0;
}

void Init(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static float position[] = {0.0, 1.0, 0.0, 0.0};
    static float mat_shininess[] = {90.0};
    static float mat_specular[] = {0.8, 0.8, 0.8, 1.0};
    static float mat_diffuse[] = {0.46, 0.66, 0.795, 1.0};
    static float mat_ambient[] = {0.0, 0.1, 0.2, 1.0};
    static float lmodel_ambient[] = {0.4, 0.4, 0.4, 1.0};
    static float lmodel_localviewer[] = {0.0};
    GLfloat map1[4] = {0.0, 0.0, 0.0, 0.0};
    GLfloat map2[4] = {0.0, 0.0, 0.0, 0.0};
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_localviewer);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);

    if (fileName != 0) {
	glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	image = tkRGBImageLoad(fileName);

	glTexImage2D(GL_TEXTURE_2D, 0, 3, image->sizeX, image->sizeY, 0, GL_RGB,
		     GL_UNSIGNED_BYTE, (unsigned char *)image->data);

	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	glPushMatrix();
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	map1[0] = 1.0 / 200000.0 * 50.0;
	map2[2] = 1.0 / 200000.0 * 50.0;
	glTexGenfv(GL_S, GL_EYE_PLANE, map1);
	glTexGenfv(GL_T, GL_EYE_PLANE, map2);
	glPopMatrix();

	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

	glEnable(GL_TEXTURE_2D);
	glEnable(GL_TEXTURE_GEN_S);
	glEnable(GL_TEXTURE_GEN_T);
    }

    InitFishs();

    glClearColor(0.0, 0.5, 0.9, 0.0);
}

void Reshape(int width, int height)
{

    windW = (GLint)width;
    windH = (GLint)height;

    glViewport(0, 0, windW, windH);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(400.0, 1.0, 1.0, 2000000.0);
    glMatrixMode(GL_MODELVIEW);
}

GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	tkQuit();
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

void DoMouseLeft(void)
{
    float x, y;
    int mouseX, mouseY;
	
    tkGetMouseLoc(&mouseX, &mouseY);
    x = (float)mouseX - ((float)windW / 2.0);
    y = (float)mouseY - ((float)windH / 2.0);
    glTranslatef(-x*20.0, y*20.0, 0.0);
}

void DoMouseRight(void)
{
    float y;
    int mouseX, mouseY;
	
    tkGetMouseLoc(&mouseX, &mouseY);
    y = (float)mouseY - ((float)windH / 2.0);
    glTranslatef(0.0, 0.0, -y*20.0);
}

void DoMouseMiddle(void)
{
    float x, y;
    int mouseX, mouseY;
	
    tkGetMouseLoc(&mouseX, &mouseY);
    x = (float)mouseX - ((float)windW / 2.0);
    y = (float)mouseY - ((float)windH / 2.0);
    glRotatef(-x/100.0, 0.0, 1.0, 0.0);
    glRotatef(-y/100.0, 1.0, 0.0, 0.0);
}

GLenum MouseDown(int mouseX, int mouseY, GLenum button)
{
    float x, y;

    if (button & TK_LEFTBUTTON) {
	mouseLeftAction = GL_TRUE;
    }
    if (button & TK_RIGHTBUTTON) {
	mouseRightAction = GL_TRUE;
    }
    if (button & TK_MIDDLEBUTTON) {
	mouseMiddleAction = GL_TRUE;
    }
    return GL_TRUE;
}

GLenum MouseUp(int mouseX, int mouseY, GLenum button)
{
    float x, y;

    if (button & TK_LEFTBUTTON) {
	mouseLeftAction = GL_FALSE;
    }
    if (button & TK_RIGHTBUTTON) {
	mouseRightAction = GL_FALSE;
    }
    if (button & TK_MIDDLEBUTTON) {
	mouseMiddleAction = GL_FALSE;
    }
    return GL_TRUE;
}

void Animate(void)
{
    int i;

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    if (mouseLeftAction == GL_TRUE) {
	DoMouseLeft();
    }
    if (mouseRightAction == GL_TRUE) {
	DoMouseRight();
    }
    if (mouseMiddleAction == GL_TRUE) {
	DoMouseMiddle();
    }

    for (i = 0; i < NUM_SHARKS; i++) {
	glPushMatrix();
	SharkPilot(&sharks[i]);
	SharkMiss(i);
	FishTransform(&sharks[i]);
	DrawShark(&sharks[i]);
	glPopMatrix();
    }

    glPushMatrix();
    WhalePilot(&dolph);
    dolph.phi++;
    FishTransform(&dolph);
    DrawDolphin(&dolph);
    glPopMatrix();

    glPushMatrix();
    WhalePilot(&momWhale);
    momWhale.phi++;
    FishTransform(&momWhale);
    DrawWhale(&momWhale);
    glPopMatrix();

    glPushMatrix();
    WhalePilot(&babyWhale);
    babyWhale.phi++;
    FishTransform(&babyWhale);
    glScalef(0.45, 0.45, 0.3);
    DrawWhale(&babyWhale);
    glPopMatrix();

    tkSwapBuffers();
}

GLenum Args(int argc, char **argv)
{
    GLint i;

    directRender = GL_TRUE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-f") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-f (No file name).\n");
		return GL_FALSE;
	    } else {
		fileName = argv[++i];
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
	tkQuit();
    }

    windW = 600;
    windH = 600;
    tkInitPosition(10, 30, windW, windH);

    type = TK_RGB | TK_DOUBLE | TK_DEPTH16;
    type |= (directRender) ? TK_DIRECT : TK_INDIRECT;
    tkInitDisplayMode(type);

    if (tkInitWindow("Atlantis Demo") == GL_FALSE) {
	tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkMouseDownFunc(MouseDown);
    tkMouseUpFunc(MouseUp);
    tkIdleFunc(Animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\atlantis.h ===
#pragma warning(disable:4305)

#define RAD 57.295
#define RRAD 0.01745

#define NUM_SHARKS 4
#define SHARKSIZE 6000
#define SHARKSPEED 100.0

#define WHALESPEED 250.0


typedef struct _fishRec {
    float x, y, z, phi, theta, psi, v;
    float xt, yt, zt;
    float htail, vtail;
    float dtheta;
    int spurt, attack;
} fishRec;


extern fishRec sharks[NUM_SHARKS];
extern fishRec momWhale;
extern fishRec babyWhale;
extern fishRec dolph;


void FishTransform(fishRec *);
void WhalePilot(fishRec *);
void SharkPilot(fishRec *);
void SharkMiss(int);

void DrawShark(fishRec *fish);
void DrawDolphin(fishRec *fish);
void DrawWhale(fishRec *fish);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\stencil.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "shell.h"


typedef struct _stencilRec {
    long index[4];
    GLenum value[4];
    char *name[4];
    enumRec *enumTable[4];
} stencilRec;


enumRec enum_StencilFunc[] = {
    GL_EQUAL, "GL_EQUAL",
    GL_NOTEQUAL, "GL_NOTEQUAL",
    GL_LESS, "GL_LESS",
    GL_LEQUAL, "GL_LEQUAL",
    GL_GREATER, "GL_GREATER",
    GL_GEQUAL, "GL_GEQUAL",
    GL_ALWAYS, "GL_ALWAYS",
    GL_NEVER, "GL_NEVER",
    -1, "End of List"
};

enumRec enum_StencilOp[] = {
    GL_KEEP, "GL_KEEP",
    GL_REPLACE, "GL_REPLACE",
    GL_INCR, "GL_INCR",
    GL_DECR, "GL_DECR",
    GL_INVERT, "GL_INVERT",
    GL_ZERO, "GL_ZERO",
    -1, "End of List"
};


void StencilInit(void *data)
{
    stencilRec *ptr;
    long i;

    ptr = (stencilRec *)malloc(sizeof(stencilRec));    
    *((void **)data) = (void *)ptr;

    ptr->enumTable[0] = enum_StencilFunc;
    ptr->enumTable[1] = enum_StencilOp;
    ptr->enumTable[2] = enum_StencilOp;
    ptr->enumTable[3] = enum_StencilOp;

    for (i = 0; i < 4; i++) {
	ptr->index[i] = 0;
	ptr->value[i] = ptr->enumTable[i]->value;
	ptr->name[i] = ptr->enumTable[i]->name;
    }
}

long StencilUpdate(void *data)
{
    stencilRec *ptr = (stencilRec *)data;
    long flag, i;

    flag = 1;
    for (i = 3; i >= 0; i--) {
	if (flag) {
	    ptr->index[i] += 1;
	    if (ptr->enumTable[i][ptr->index[i]].value == -1) {
		ptr->index[i] = 0;
		ptr->value[i] = ptr->enumTable[i]->value;
		ptr->name[i] = ptr->enumTable[i]->name;
		flag = 1;
	    } else {
		ptr->value[i] = ptr->enumTable[i][ptr->index[i]].value;
		ptr->name[i] = ptr->enumTable[i][ptr->index[i]].name;
		flag = 0;
	    }
	}
    }

    return flag;
}

void StencilSet(long enabled, void *data)
{
    stencilRec *ptr = (stencilRec *)data;

    if (enabled) {
	glStencilFunc(ptr->value[0], 0, ~0);
	glStencilOp(ptr->value[1], ptr->value[2], ptr->value[3]);
	glStencilMask(~0);
	glEnable(GL_STENCIL_TEST);
    } else {
	glDisable(GL_STENCIL_TEST);
    }
    Probe();
}

void StencilStatus(long enabled, void *data)
{
    stencilRec *ptr = (stencilRec *)data;

    if (enabled) {
	Output("Stencil on.\n");
	Output("\t%s, %s, %s, %s.\n", ptr->name[0], ptr->name[1],
	       ptr->name[2], ptr->name[3]);
    } else {
	Output("Stencil off.\n");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\primtest\tproto.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

enum {
    TEST_NULL = -1,
    TEST_HINT,
    TEST_ALIAS,
    TEST_ALPHA,
    TEST_BLEND,
    TEST_DEPTH,
    TEST_DITHER,
    TEST_FOG,
    TEST_LIGHT,
    TEST_LOGICOP,
    TEST_SCISSOR,
    TEST_SHADE,
    TEST_STENCIL,
    TEST_STIPPLE,
    TEST_TEXTURE
};


extern void AliasInit(void *);
extern void AliasSet(long, void *);
extern void AliasStatus(long, void *);
extern long AliasUpdate(void *);
extern void AlphaInit(void *);
extern void AlphaSet(long, void *);
extern void AlphaStatus(long, void *);
extern long AlphaUpdate(void *);
extern void BlendInit(void *);
extern void BlendSet(long, void *);
extern void BlendStatus(long, void *);
extern long BlendUpdate(void *);
extern void DepthInit(void *);
extern void DepthSet(long, void *);
extern void DepthStatus(long, void *);
extern long DepthUpdate(void *);
extern void DitherInit(void *);
extern void DitherSet(long, void *);
extern void DitherStatus(long, void *);
extern long DitherUpdate(void *);
extern void FogInit(void *);
extern void FogSet(long, void *);
extern void FogStatus(long, void *);
extern long FogUpdate(void *);
extern void HintInit(void *);
extern void HintSet(long, void *);
extern void HintStatus(long, void *);
extern long HintUpdate(void *);
extern void LightInit(void *);
extern void LightSet(long, void *);
extern void LightStatus(long, void *);
extern long LightUpdate(void *);
extern void LogicOpInit(void *);
extern void LogicOpSet(long, void *);
extern void LogicOpStatus(long, void *);
extern long LogicOpUpdate(void *);
extern void ScissorInit(void *);
extern void ScissorSet(long, void *);
extern void ScissorStatus(long, void *);
extern long ScissorUpdate(void *);
extern void ShadeInit(void *);
extern void ShadeSet(long, void *);
extern void ShadeStatus(long, void *);
extern long ShadeUpdate(void *);
extern void StencilInit(void *);
extern void StencilSet(long, void *);
extern void StencilStatus(long, void *);
extern long StencilUpdate(void *);
extern void StippleInit(void *);
extern void StippleSet(long, void *);
extern void StippleStatus(long, void *);
extern long StippleUpdate(void *);
extern void TextureInit(void *);
extern void TextureSet(long, void *);
extern void TextureStatus(long, void *);
extern long TextureUpdate(void *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\swim.c ===
#include <windows.h>
#include <stdlib.h>
#include <math.h>
#include <GL/gl.h>
#include "atlantis.h"


void FishTransform(fishRec *fish)
{

    glTranslatef(fish->y, fish->z, -fish->x);
    glRotatef(-fish->psi, 0.0, 1.0, 0.0);
    glRotatef(fish->theta, 1.0, 0.0, 0.0); 
    glRotatef(-fish->phi, 0.0, 0.0, 1.0);
}

void WhalePilot(fishRec *fish)
{

    fish->phi = -20.0;
    fish->theta = 0.0;
    fish->psi -= 0.5;

    fish->x += WHALESPEED * fish->v * cos(fish->psi/RAD) * cos(fish->theta/RAD);
    fish->y += WHALESPEED * fish->v * sin(fish->psi/RAD) * cos(fish->theta/RAD);
    fish->z += WHALESPEED * fish->v * sin(fish->theta/RAD);
}

void SharkPilot(fishRec *fish)
{
    static int sign = 1;
    float X, Y, Z, tpsi, ttheta, thetal;

    fish->xt = 60000.0;
    fish->yt = 0.0;
    fish->zt = 0.0;

    X = fish->xt - fish->x;
    Y = fish->yt - fish->y;
    Z = fish->zt - fish->z;

    thetal = fish->theta;

    ttheta = RAD * atan(Z/(sqrt(X*X+Y*Y)));

    if (ttheta > fish->theta+0.25) {
        fish->theta += 0.5;
    } else if (ttheta < fish->theta-0.25) {
        fish->theta -= 0.5;
    }

    if (fish->theta > 90.0) {
	fish->theta =  90.0;
    }
    if (fish->theta < -90.0) {
	fish->theta = -90.0;
    }

    fish->dtheta = fish->theta - thetal;

    tpsi =  RAD * atan2(Y, X);
        
    fish->attack = 0;

    if (fabs(tpsi-fish->psi) < 10.0) {
        fish->attack = 1;
    } else if (fabs(tpsi-fish->psi) < 45.0) {
        if (fish->psi > tpsi) {
            fish->psi -= 0.5;
            if (fish->psi < -180.0) {
		fish->psi += 360.0;
	    }
        } else if (fish->psi < tpsi) {
            fish->psi += 0.5;
            if (fish->psi >  180.0) {
		fish->psi -= 360.0;
	    }
        }
    } else {
        if (rand()%100 > 98) {
	    sign = 1 - sign;
	}
        fish->psi += sign;
        if (fish->psi > 180.0) {
	    fish->psi -= 360.0;
	}
        if (fish->psi < -180.0) {
	    fish->psi += 360.0;
	}
    }

    if (fish->attack) {
        if (fish->v < 1.1) {
	    fish->spurt = 1;
	}
        if (fish->spurt) {
	    fish->v += 0.2;
	}
        if (fish->v > 5.0) {
	    fish->spurt = 0;
	}
        if ((fish->v > 1.0) && (!fish->spurt)) {
	    fish->v -= 0.2;
	}
    } else {
        if (!(rand()%400) && (!fish->spurt)) {
	    fish->spurt = 1;
	}
        if (fish->spurt) {
	    fish->v += 0.05;
	}
        if (fish->v > 3.0) {
	    fish->spurt = 0;
	}
        if ((fish->v > 1.0) && (!fish->spurt)) {
	    fish->v -= 0.05;
	}
    }

    fish->x += SHARKSPEED * fish->v * cos(fish->psi/RAD) * cos(fish->theta/RAD);
    fish->y += SHARKSPEED * fish->v * sin(fish->psi/RAD) * cos(fish->theta/RAD);
    fish->z += SHARKSPEED * fish->v * sin(fish->theta/RAD);
}

void SharkMiss(int i)
{
    int j;
    float avoid, thetal;
    float X, Y, Z, R;

    for (j = 0; j < NUM_SHARKS; j++) {
        if (j != i) { 
            X = sharks[j].x - sharks[i].x;
            Y = sharks[j].y - sharks[i].y;
            Z = sharks[j].z - sharks[i].z;

            R = sqrt(X*X+Y*Y+Z*Z);

            avoid = 1.0;
            thetal = sharks[i].theta;

            if (R < SHARKSIZE) {
                if (Z > 0.0) {
                    sharks[i].theta -= avoid;
                } else {
                    sharks[i].theta += avoid;
                }
            }

            sharks[i].dtheta += (sharks[i].theta - thetal);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\backtrac.cxx ===
extern "C" {
#include <windows.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include <GL/glaux.h>
};

#ifdef GLX_MOTIF
#include <GL/glx.h>
#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/CascadeB.h>
#include <Xm/Frame.h>
#include <Xm/MainW.h>
#include <Xm/PushB.h>
#include <Xm/PushBG.h>
#include <Xm/RowColumn.h>
#include <Xm/ToggleB.h>
#include <GLwMDrawA.h>
#include <sys/time.h>
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include "scene.hxx"
#include "cbacks.hxx"
#include "menu.h"

LRESULT APIENTRY MyWndProc(HWND, UINT, WPARAM, LPARAM);
VOID SubclassWindow (HWND, WNDPROC);
void vCustomizeWnd(void);


extern light lights[];

extern GLboolean bAutoMotion(void);
extern void draw(void);

#ifdef GLX_MOTIF
static Display *display;
XtAppContext app_context;
Widget glw;
const int max_args = 20;
#endif

int quick_moves = 0;
int auto_motion = 0;

#ifdef GLX_MOTIF
XVisualInfo *find_visual()
{
  int attr[256], i, stencil, dbuffer;
  XVisualInfo *vi;

  i = 0;
  attr[i++] = GLX_RGBA;
  attr[i++] = GLX_RED_SIZE;
  attr[i++] = 1;
  attr[i++] = GLX_GREEN_SIZE;
  attr[i++] = 1;
  attr[i++] = GLX_BLUE_SIZE;
  attr[i++] = 1;
  attr[i++] = GLX_DEPTH_SIZE;
  attr[i++] = 1;
  dbuffer = i;
  attr[i++] = GLX_DOUBLEBUFFER;
  stencil = i;
  attr[i++] = GLX_STENCIL_SIZE;
  attr[i++] = 1;
  attr[i++] = (int)None;

  vi = glXChooseVisual(display, DefaultScreen(display), attr);
  if (vi == NULL) {
    fprintf(stderr, "Unable to find visual with stencil buffer.\n");
    fprintf(stderr, "(Things won't look quite as good).\n");
    attr[stencil] = (int)None;
    vi = glXChooseVisual(display, DefaultScreen(display), attr);
    if (vi == NULL) {
      fprintf(stderr, "Unable to find double-buffered visual.\n");
      fprintf(stderr, "(Things will look even worse).\n");
      attr[dbuffer] = (int)None;
      vi = glXChooseVisual(display, DefaultScreen(display), attr);
      if (vi == NULL) fprintf(stderr, "Can't find visual at all.\n");
    }
  }
  return vi;
}
#endif

#ifdef GLX_MOTIF
Widget create_widgets(Widget parent)
{
  Widget main_window;
  Widget menu_bar;
  Widget menu_pane;
  Widget button;
  Widget cascade;
  Widget frame;
  XVisualInfo *vi;

  Arg args[max_args];
  int argcount;

  char buffer[128];

  int i;

  main_window = XmCreateMainWindow(parent, "main1", NULL, 0);
  XtManageChild(main_window);

  menu_bar = XmCreateMenuBar(main_window, "menu_bar", NULL, 0);
  XtManageChild(menu_bar);

  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", NULL, 0);
  button = XmCreatePushButton(menu_pane, "Exit", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)exitCB, NULL);

  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "File", args, 1);
  XtManageChild(cascade);


  argcount = 0;
  XtSetArg(args[argcount], XmNradioBehavior, True); argcount++;
  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args, argcount);
  XtSetArg(args[0], XmNset, TRUE);
  for (i = 0; i < nindices; i++) {
    if (i == def_refraction_index) argcount = 1;
    else argcount = 0;
    button = XmCreateToggleButton(menu_pane, (char *)indices[i].name,
	args, argcount);
    XtManageChild(button);
    XtAddCallback(button, XmNvalueChangedCallback,
		  (XtCallbackProc)refractionCB,
		  (XtPointer)(&indices[i].index));
  }
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Material", args, 1);
  XtManageChild(cascade);


  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", NULL, 0);

  XtSetArg(args[0], XmNset, draw_square);
  button = XmCreateToggleButton(menu_pane, "Draw Square", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_square);

  XtSetArg(args[0], XmNset, draw_shadows);
  button = XmCreateToggleButton(menu_pane, "Draw Shadows", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_shadows);

  XtSetArg(args[0], XmNset, draw_refraction);
  button = XmCreateToggleButton(menu_pane, "Draw Refraction", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_refraction);

  XtSetArg(args[0], XmNset, draw_sphere);
  button = XmCreateToggleButton(menu_pane, "Draw Sphere", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_sphere);

  XtSetArg(args[0], XmNset, draw_lights);
  button = XmCreateToggleButton(menu_pane, "Draw Lights", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_lights);

#ifdef TEXTURE
  XtSetArg(args[0], XmNset, draw_texture);
  button = XmCreateToggleButton(menu_pane, "Texture Map", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
                (XtCallbackProc)drawSomethingCB, &draw_texture);
#endif

  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Draw", args, 1);
  XtManageChild(cascade);

  argcount = 0;
  XtSetArg(args[argcount], XmNradioBehavior, True); argcount++;
  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args, argcount);
  XtSetArg(args[0], XmNset, TRUE);
  for (i = 0; i < npossible_divisions; i++) {
    if (i == def_divisions_index) argcount = 1;
    else argcount = 0;
    sprintf(buffer, "%d", possible_divisions[i]);
    button = XmCreateToggleButton(menu_pane, buffer, args, argcount);
    XtManageChild(button);
    XtAddCallback(button, XmNvalueChangedCallback,
		  (XtCallbackProc)subdivisionCB, &possible_divisions[i]);
  }
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Subdivision", args, 1);
  XtManageChild(cascade);


  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args, argcount);
  button = XmCreatePushButton(menu_pane, "Reset Position", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback,
		(XtCallbackProc)resetLightsCB, NULL);

  XtSetArg(args[0], XmNset, TRUE);
  for (i = 0; i < nlights; i++) {
    button = XmCreateToggleButton(menu_pane, lights[i].name, args,
				  lights[i].on ? 1 : 0);
    XtManageChild(button);
    XtAddCallback(button, XmNvalueChangedCallback,
		  (XtCallbackProc)light_onCB, &lights[i]);
  }
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Lights", args, 1);
  XtManageChild(cascade);


  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args,
				   argcount);
  XtSetArg(args[0], XmNset, quick_moves);
  button = XmCreateToggleButton(menu_pane, "Quick Motion",
				args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)intToggleCB, &quick_moves);

  XtSetArg(args[0], XmNset, auto_motion);
  button = XmCreateToggleButton(menu_pane, "Rotate Automatically",
				args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)autoMotionCB, NULL);

  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Motion", args, 1);
  XtManageChild(cascade);


  argcount = 0;
  XtSetArg(args[argcount], XmNmarginWidth, 0); argcount++;
  XtSetArg(args[argcount], XmNmarginHeight, 0); argcount++;
  XtSetArg(args[argcount], XmNshadowThickness, 1); argcount++;
  XtSetArg(args[argcount], XmNshadowType, XmSHADOW_OUT); argcount++;
  frame = XmCreateFrame(main_window, "frame", args, argcount);
  XtManageChild(frame);


  argcount = 0;
  vi = find_visual();
  if (vi) {
    XtSetArg(args[argcount], GLwNvisualInfo, vi); argcount++;
  }
  else {
    XtSetArg(args[argcount], GLwNrgba, TRUE); argcount++;
    XtSetArg(args[argcount], GLwNdepthSize, 1); argcount++;
    XtSetArg(args[argcount], GLwNdoublebuffer, TRUE); argcount++;
  }
  XtSetArg(args[argcount], XmNbottomAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNtopAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNleftAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNrightAttachment, XmATTACH_FORM); argcount++;
  glw = GLwCreateMDrawingArea(frame, "glwidget", args, argcount);
  XtManageChild(glw);
  XtAddCallback(glw, GLwNginitCallback, (XtCallbackProc)initCB, 0);
  XtAddCallback(glw, GLwNexposeCallback, (XtCallbackProc)exposeCB, 0);
  XtAddCallback(glw, GLwNresizeCallback, (XtCallbackProc)resizeCB, 0);
  XtAddCallback(glw, GLwNinputCallback, (XtCallbackProc)inputCB, 0);

  return main_window;
}
#endif

void main(int argc, char **argv)
{
    auxInitDisplayMode(AUX_RGBA | AUX_STENCIL | AUX_DOUBLE );
    auxInitPosition(100, 100, 300, 300);
    auxInitWindow("BackTrace");
    vCustomizeWnd();
    scene_load_texture((char *)def_texfile);

    vInit();
    auxReshapeFunc(vResize);

    //
    // we've a choice of using accelerator or auxKeyFunc
    // the use of auxKeyFunc here is solely for demonstration purpose
    //
    auxKeyFunc(AUX_SPACE, vQuickMove);
    auxKeyFunc(AUX_RETURN, vResetLights);
    auxKeyFunc(AUX_p, vAutoMotion);

    auxKeyFunc(AUX_q, vDrawAll);
    auxKeyFunc(AUX_w, vDrawSquare);
    auxKeyFunc(AUX_e, vDrawShadow);
    auxKeyFunc(AUX_r, vDrawRefraction);
    auxKeyFunc(AUX_t, vDrawSphere);
    auxKeyFunc(AUX_y, vDrawLight);
    auxKeyFunc(AUX_u, vDrawTexture);

    auxKeyFunc(AUX_a, vRefractionAIR);
    auxKeyFunc(AUX_s, vRefractionICE);
    auxKeyFunc(AUX_d, vRefractionWATER);
    auxKeyFunc(AUX_f, vRefractionZincGLASS);
    auxKeyFunc(AUX_g, vRefractionLightGLASS);
    auxKeyFunc(AUX_h, vRefractionHeavyGLASS);

    auxKeyFunc(AUX_1, vSubdivision10);
    auxKeyFunc(AUX_2, vSubdivision20);
    auxKeyFunc(AUX_3, vSubdivision30);
    auxKeyFunc(AUX_4, vSubdivision40);

    auxKeyFunc(AUX_R, vRLight_on);
    auxKeyFunc(AUX_G, vGLight_on);
    auxKeyFunc(AUX_B, vBLight_on);

    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, vMouseDown);
    auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, vMouseDown);
    auxMouseFunc(AUX_RIGHTBUTTON, AUX_MOUSEDOWN, vMouseDown);

    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, vLeftMouseUp);
    auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSEUP, vMiddleMouseUp);
    auxMouseFunc(AUX_RIGHTBUTTON, AUX_MOUSEUP, vRightMouseUp);

    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSELOC, vMouseMove);
    auxMouseFunc(AUX_MIDDLEBUTTON, AUX_MOUSELOC, vMouseMove);
    auxMouseFunc(AUX_RIGHTBUTTON, AUX_MOUSELOC, vMouseMove);

    auxMainLoop(draw);

    return;
}


#ifdef GLX_MOTIF
void main(int argc, char **argv)
{
  Widget app_shell;
  Arg args[max_args];
  int argcount;

  scene_load_texture((char *)def_texfile);

  XtToolkitInitialize();
  app_context = XtCreateApplicationContext();
  display = XtOpenDisplay(app_context, NULL, argv[0],
                          "XMdemos", NULL, 0, &argc, argv);
  if (!display) {
    XtWarning("Can't open display.");
    exit(0);
  }

  argcount = 0;
  XtSetArg(args[argcount], XmNmaxAspectX, 1); argcount++;
  XtSetArg(args[argcount], XmNmaxAspectY, 1); argcount++;
  XtSetArg(args[argcount], XmNminAspectX, 1); argcount++;
  XtSetArg(args[argcount], XmNminAspectY, 1); argcount++;
  app_shell =
    XtAppCreateShell(argv[0], "XMdemos", applicationShellWidgetClass,
                     display, args, argcount);

  create_widgets(app_shell);

  XtRealizeWidget(app_shell);

  XtAppMainLoop(app_context);

}
#endif



/**************************************************************************\
*
*  function:  MyWndProc
*
*  input parameters:  normal window procedure parameters.
*
\**************************************************************************/
LRESULT APIENTRY MyWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
  WNDPROC     pfnOldProc;
  static UINT_PTR uiTmID = 0;
  int wmId, wmEvent;

  pfnOldProc = (WNDPROC) GetWindowLongPtr (hwnd, GWLP_USERDATA);

  switch (message) {

    case WM_COMMAND: {
        HMENU hmenu;

        hmenu = GetMenu(auxGetHWND());
        wmId    = LOWORD(wParam);
        wmEvent = HIWORD(wParam);
        switch (wmId) {
            case IDM_EXIT      : vExit(); break;
            case IDM_AIR       :
            case IDM_ICE       :
            case IDM_WATER     :
            case IDM_ZINC      :
            case IDM_LIGHT     :
            case IDM_HEAVY     : vRefraction(wmId - IDM_AIR); break;

            case IDM_SQUARE    :
            {
                if (draw_square)
                    CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_square);
                break;
            }
            case IDM_SHADOW    :
            {
                if (draw_shadows)
                    CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_shadows);
                break;
            }
            case IDM_REFRACTION:
            {
                if (draw_refraction)
                    CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_refraction);
                break;
            }
            case IDM_SPHERE    :
            {
                if (draw_sphere)
                    CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_sphere);
                break;
            }
            case IDM_LIGHTS    :
            {
                if (draw_lights)
                    CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_lights);
                break;
            }
            case IDM_TEXTURE   :
            {
                if (draw_texture)
                    CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_UNCHECKED);
                else
                    CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_CHECKED);
                vDrawStuff(&draw_texture);
                break;
            }
            case IDM_ALL       : vDrawAll(); break;
            case IDM_10        :
            case IDM_20        :
            case IDM_30        :
            case IDM_40        : vSubdivision(wmId - IDM_10); break;

            case IDM_RESETLGT  : vResetLights(); break;

            case IDM_RED       :
            case IDM_GREEN     :
            case IDM_BLUE      : vLight_on(wmId - IDM_RED); break;

            case IDM_QUICK     : vQuickMove(); break;
            case IDM_AUTO      : vAutoMotion(); break;
            default:
                break;
        }
    }

    case WM_USER:
        if (auto_motion) {
            uiTmID = SetTimer(hwnd, 1, 1, NULL);

            if (uiTmID == 0)
                OutputDebugString("failed to create timer\n");

        } else {
            if (uiTmID != 0) {
                KillTimer(hwnd, uiTmID);
                uiTmID = 0;
            }
        }
        return 0;

    case WM_TIMER: {
        //static int cnt=0;
        //char text[128];

        bAutoMotion();
        //wsprintf(text, "WM_TIMER %d\n", cnt++);
        //OutputDebugString(text);
        return 0;
    }
    case WM_DESTROY:
        if (uiTmID != 0)
            KillTimer(hwnd, uiTmID);
        return CallWindowProc(pfnOldProc, hwnd, message, wParam, lParam);

    default:
        return CallWindowProc(pfnOldProc, hwnd, message, wParam, lParam);

  } /* end switch */

  return 0;
}

/**************************************************************************\
*  function:  SubclassWindow
*
*  input parameters:
*   hwnd            - window handle to be subclassed,
*   SubclassWndProc - the new window procedure.
*
\**************************************************************************/
VOID SubclassWindow (HWND hwnd, WNDPROC SubclassWndProc)
{
  LONG_PTR pfnOldProc;

  pfnOldProc = GetWindowLongPtr (hwnd, GWLP_WNDPROC);

  SetWindowLongPtr (hwnd, GWLP_USERDATA, (LONG_PTR) pfnOldProc);
  SetWindowLongPtr (hwnd, GWLP_WNDPROC,  (LONG_PTR) SubclassWndProc);
}

/******************************Public*Routine******************************\
*
* vCustomizeWnd
*
* Effects: Subclass the window created by the toolkit
*          Add menu bar to the window
*          Setup timer
*
* History:
*  01-Dec-1993
*
\**************************************************************************/

void vCustomizeWnd(void)
{
    HWND    hWnd;

    if ((hWnd = auxGetHWND()) == NULL) {
	OutputDebugString("auxGetHWND() failed\n");
	return;
    }

    SubclassWindow (hWnd, MyWndProc);
    SendMessage(hWnd, WM_USER, 0L, 0L);
    SetMenu(hWnd, LoadMenu(GetModuleHandle(NULL), "Backtrac"));
    DrawMenuBar(hWnd);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\menu.h ===
#define IDM_EXIT        1000

#define IDM_AIR         1001
#define IDM_ICE         1002
#define IDM_WATER       1003
#define IDM_ZINC        1004
#define IDM_LIGHT       1005
#define IDM_HEAVY       1006

#define IDM_SQUARE      1007
#define IDM_SHADOW      1008
#define IDM_REFRACTION  1009
#define IDM_SPHERE      1010
#define IDM_LIGHTS      1011
#define IDM_TEXTURE     1012
#define IDM_ALL         1013

#define IDM_10          1014
#define IDM_20          1015
#define IDM_30          1016
#define IDM_40          1017

#define IDM_RESETLGT    1018

#define IDM_RED         1019
#define IDM_GREEN       1020
#define IDM_BLUE        1021

#define IDM_QUICK       1022
#define IDM_AUTO        1023
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\shark.c ===
#include <windows.h>
#include "gl.h"
#include "math.h"
#include "atlantis.h"


static float N001[3] = {0.000000 ,1.000000 ,0.000000};
static float N002[3] = {0.000077 ,-0.020611 ,0.999788};
static float N003[3] = {0.961425 ,0.258729 ,-0.093390};
static float N004[3] = {0.510811 ,-0.769633 ,-0.383063};
static float N005[3] = {0.400123 ,0.855734 ,-0.328055};
static float N006[3] = {-0.770715 ,0.610204 ,-0.183440};
static float N007[3] = {-0.915597 ,-0.373345 ,-0.149316};
static float N008[3] = {-0.972788 ,0.208921 ,-0.100179};
static float N009[3] = {-0.939713 ,-0.312268 ,-0.139383};
static float N010[3] = {-0.624138 ,-0.741047 ,-0.247589};
static float N011[3] = {0.591434 ,-0.768401 ,-0.244471};
static float N012[3] = {0.935152 ,-0.328495 ,-0.132598};
static float N013[3] = {0.997102 ,0.074243 ,-0.016593};
static float N014[3] = {0.969995 ,0.241712 ,-0.026186};
static float N015[3] = {0.844539 ,0.502628 ,-0.184714};
static float N016[3] = {-0.906608 ,0.386308 ,-0.169787};
static float N017[3] = {-0.970016 ,0.241698 ,-0.025516};
static float N018[3] = {-0.998652 ,0.050493 ,-0.012045};
static float N019[3] = {-0.942685 ,-0.333051 ,-0.020556};
static float N020[3] = {-0.660944 ,-0.750276 ,0.015480};
static float N021[3] = {0.503549 ,-0.862908 ,-0.042749};
static float N022[3] = {0.953202 ,-0.302092 ,-0.012089};
static float N023[3] = {0.998738 ,0.023574 ,0.044344};
static float N024[3] = {0.979297 ,0.193272 ,0.060202};
static float N025[3] = {0.798300 ,0.464885 ,0.382883};
static float N026[3] = {-0.756590 ,0.452403 ,0.472126};
static float N027[3] = {-0.953855 ,0.293003 ,0.065651};
static float N028[3] = {-0.998033 ,0.040292 ,0.048028};
static float N029[3] = {-0.977079 ,-0.204288 ,0.059858};
static float N030[3] = {-0.729117 ,-0.675304 ,0.111140};
static float N031[3] = {0.598361 ,-0.792753 ,0.116221};
static float N032[3] = {0.965192 ,-0.252991 ,0.066332};
static float N033[3] = {0.998201 ,-0.002790 ,0.059892};
static float N034[3] = {0.978657 ,0.193135 ,0.070207};
static float N035[3] = {0.718815 ,0.680392 ,0.142733};
static float N036[3] = {-0.383096 ,0.906212 ,0.178936};
static float N037[3] = {-0.952831 ,0.292590 ,0.080647};
static float N038[3] = {-0.997680 ,0.032417 ,0.059861};
static float N039[3] = {-0.982629 ,-0.169881 ,0.074700};
static float N040[3] = {-0.695424 ,-0.703466 ,0.146700};
static float N041[3] = {0.359323 ,-0.915531 ,0.180805};
static float N042[3] = {0.943356 ,-0.319387 ,0.089842};
static float N043[3] = {0.998272 ,-0.032435 ,0.048993};
static float N044[3] = {0.978997 ,0.193205 ,0.065084};
static float N045[3] = {0.872144 ,0.470094 ,-0.135565};
static float N046[3] = {-0.664282 ,0.737945 ,-0.119027};
static float N047[3] = {-0.954508 ,0.288570 ,0.075107};
static float N048[3] = {-0.998273 ,0.032406 ,0.048993};
static float N049[3] = {-0.979908 ,-0.193579 ,0.048038};
static float N050[3] = {-0.858736 ,-0.507202 ,-0.072938};
static float N051[3] = {0.643545 ,-0.763887 ,-0.048237};
static float N052[3] = {0.955580 ,-0.288954 ,0.058068};
static float N053[3] = {0.000000 ,1.000000 ,0.000000};
static float N054[3] = {0.000000 ,1.000000 ,0.000000};
static float N055[3] = {0.000000 ,1.000000 ,0.000000};
static float N056[3] = {0.000000 ,1.000000 ,0.000000};
static float N057[3] = {0.000000 ,1.000000 ,0.000000};
static float N058[3] = {0.000050 ,0.793007 ,-0.609213};
static float N059[3] = {0.913510 ,0.235418 ,-0.331779};
static float N060[3] = {-0.807970 ,0.495000 ,-0.319625};
static float N061[3] = {0.000000 ,0.784687 ,-0.619892};
static float N062[3] = {0.000000 ,-1.000000 ,0.000000};
static float N063[3] = {0.000000 ,1.000000 ,0.000000};
static float N064[3] = {0.000000 ,1.000000 ,0.000000};
static float N065[3] = {0.000000 ,1.000000 ,0.000000};
static float N066[3] = {-0.055784 ,0.257059 ,0.964784};
static float N067[3] = {0.000000 ,1.000000 ,0.000000};
static float N068[3] = {0.000000 ,1.000000 ,0.000000};
static float N069[3] = {-0.000505 ,-0.929775 ,-0.368127};
static float N070[3] = {0.000000 ,1.000000 ,0.000000};
static float N071[3] = {-0.987102 ,0.131723 ,-0.090984};
static float N072[3] = {-0.987102 ,0.131723 ,-0.090984};
static float N073[3] = {-0.987102 ,0.131723 ,-0.090984};
static float N074[3] = {0.000000 ,1.000000 ,0.000000};
static float N075[3] = {0.000000 ,1.000000 ,0.000000};
static float N076[3] = {0.000000 ,1.000000 ,0.000000};
static float N077[3] = {0.995210 ,0.071962 ,-0.066168};
static float N078[3] = {0.995210 ,0.071962 ,-0.066168};
static float N079[3] = {0.995210 ,0.071962 ,-0.066168};
static float N080[3] = {0.000000 ,1.000000 ,0.000000};
static float N081[3] = {0.000000 ,1.000000 ,0.000000};
static float N082[3] = {0.000000 ,1.000000 ,0.000000};
static float P001[3] = {0.00, 0.00, 0.00};
static float P002[3] = {0.00, -36.59, 5687.72};
static float P003[3] = {90.00, 114.73, 724.38};
static float P004[3] = {58.24, -146.84, 262.35};
static float P005[3] = {27.81, 231.52, 510.43};
static float P006[3] = {-27.81, 230.43, 509.76};
static float P007[3] = {-46.09, -146.83, 265.84};
static float P008[3] = {-90.00, 103.84, 718.53};
static float P009[3] = {-131.10, -165.92, 834.85};
static float P010[3] = {-27.81, -285.31, 500.00};
static float P011[3] = {27.81, -285.32, 500.00};
static float P012[3] = {147.96, -170.89, 845.50};
static float P013[3] = {180.00, 0.00, 2000.00};
static float P014[3] = {145.62, 352.67, 2000.00};
static float P015[3] = {55.62, 570.63, 2000.00};
static float P016[3] = {-55.62, 570.64, 2000.00};
static float P017[3] = {-145.62, 352.68, 2000.00};
static float P018[3] = {-180.00, 0.01, 2000.00};
static float P019[3] = {-178.20, -352.66, 2001.61};
static float P020[3] = {-55.63, -570.63, 2000.00};
static float P021[3] = {55.62, -570.64, 2000.00};
static float P022[3] = {179.91, -352.69, 1998.39};
static float P023[3] = {150.00, 0.00, 3000.00};
static float P024[3] = {121.35, 293.89, 3000.00};
static float P025[3] = {46.35, 502.93, 2883.09};
static float P026[3] = {-46.35, 497.45, 2877.24};
static float P027[3] = {-121.35, 293.90, 3000.00};
static float P028[3] = {-150.00, 0.00, 3000.00};
static float P029[3] = {-152.21, -304.84, 2858.68};
static float P030[3] = {-46.36, -475.52, 3000.00};
static float P031[3] = {46.35, -475.53, 3000.00};
static float P032[3] = {155.64, -304.87, 2863.50};
static float P033[3] = {90.00, 0.00, 4000.00};
static float P034[3] = {72.81, 176.33, 4000.00};
static float P035[3] = {27.81, 285.32, 4000.00};
static float P036[3] = {-27.81, 285.32, 4000.00};
static float P037[3] = {-72.81, 176.34, 4000.00};
static float P038[3] = {-90.00, 0.00, 4000.00};
static float P039[3] = {-72.81, -176.33, 4000.00};
static float P040[3] = {-27.81, -285.31, 4000.00};
static float P041[3] = {27.81, -285.32, 4000.00};
static float P042[3] = {72.81, -176.34, 4000.00};
static float P043[3] = {30.00, 0.00, 5000.00};
static float P044[3] = {24.27, 58.78, 5000.00};
static float P045[3] = {9.27, 95.11, 5000.00};
static float P046[3] = {-9.27, 95.11, 5000.00};
static float P047[3] = {-24.27, 58.78, 5000.00};
static float P048[3] = {-30.00, 0.00, 5000.00};
static float P049[3] = {-24.27, -58.78, 5000.00};
static float P050[3] = {-9.27, -95.10, 5000.00};
static float P051[3] = {9.27, -95.11, 5000.00};
static float P052[3] = {24.27, -58.78, 5000.00};
static float P053[3] = {0.00, 0.00, 0.00};
static float P054[3] = {0.00, 0.00, 0.00};
static float P055[3] = {0.00, 0.00, 0.00};
static float P056[3] = {0.00, 0.00, 0.00};
static float P057[3] = {0.00, 0.00, 0.00};
static float P058[3] = {0.00, 1212.72, 2703.08};
static float P059[3] = {50.36, 0.00, 108.14};
static float P060[3] = {-22.18, 0.00, 108.14};
static float P061[3] = {0.00, 1181.61, 6344.65};
static float P062[3] = {516.45, -887.08, 2535.45};
static float P063[3] = {-545.69, -879.31, 2555.63};
static float P064[3] = {618.89, -1005.64, 2988.32};
static float P065[3] = {-635.37, -1014.79, 2938.68};
static float P066[3] = {0.00, 1374.43, 3064.18};
static float P067[3] = {158.49, -11.89, 1401.56};
static float P068[3] = {-132.08, -17.90, 1394.31};
static float P069[3] = {0.00, -418.25, 5765.04};
static float P070[3] = {0.00, 1266.91, 6629.60};
static float P071[3] = {-139.12, -124.96, 997.98};
static float P072[3] = {-139.24, -110.18, 1020.68};
static float P073[3] = {-137.33, -94.52, 1022.63};
static float P074[3] = {-137.03, -79.91, 996.89};
static float P075[3] = {-135.21, -91.48, 969.14};
static float P076[3] = {-135.39, -110.87, 968.76};
static float P077[3] = {150.23, -78.44, 995.53};
static float P078[3] = {152.79, -92.76, 1018.46};
static float P079[3] = {154.19, -110.20, 1020.55};
static float P080[3] = {151.33, -124.15, 993.77};
static float P081[3] = {150.49, -111.19, 969.86};
static float P082[3] = {150.79, -92.41, 969.70};
static float iP002[3] = {0.00, -36.59, 5687.72};
static float iP004[3] = {58.24, -146.84, 262.35};
static float iP007[3] = {-46.09, -146.83, 265.84};
static float iP010[3] = {-27.81, -285.31, 500.00};
static float iP011[3] = {27.81, -285.32, 500.00};
static float iP023[3] = {150.00, 0.00, 3000.00};
static float iP024[3] = {121.35, 293.89, 3000.00};
static float iP025[3] = {46.35, 502.93, 2883.09};
static float iP026[3] = {-46.35, 497.45, 2877.24};
static float iP027[3] = {-121.35, 293.90, 3000.00};
static float iP028[3] = {-150.00, 0.00, 3000.00};
static float iP029[3] = {-121.35, -304.84, 2853.86};
static float iP030[3] = {-46.36, -475.52, 3000.00};
static float iP031[3] = {46.35, -475.53, 3000.00};
static float iP032[3] = {121.35, -304.87, 2853.86};
static float iP033[3] = {90.00, 0.00, 4000.00};
static float iP034[3] = {72.81, 176.33, 4000.00};
static float iP035[3] = {27.81, 285.32, 4000.00};
static float iP036[3] = {-27.81, 285.32, 4000.00};
static float iP037[3] = {-72.81, 176.34, 4000.00};
static float iP038[3] = {-90.00, 0.00, 4000.00};
static float iP039[3] = {-72.81, -176.33, 4000.00};
static float iP040[3] = {-27.81, -285.31, 4000.00};
static float iP041[3] = {27.81, -285.32, 4000.00};
static float iP042[3] = {72.81, -176.34, 4000.00};
static float iP043[3] = {30.00, 0.00, 5000.00};
static float iP044[3] = {24.27, 58.78, 5000.00};
static float iP045[3] = {9.27, 95.11, 5000.00};
static float iP046[3] = {-9.27, 95.11, 5000.00};
static float iP047[3] = {-24.27, 58.78, 5000.00};
static float iP048[3] = {-30.00, 0.00, 5000.00};
static float iP049[3] = {-24.27, -58.78, 5000.00};
static float iP050[3] = {-9.27, -95.10, 5000.00};
static float iP051[3] = {9.27, -95.11, 5000.00};
static float iP052[3] = {24.27, -58.78, 5000.00};
static float iP053[3] = {0.00, 0.00, 0.00};
static float iP061[3] = {0.00, 1181.61, 6344.65};
static float iP069[3] = {0.00, -418.25, 5765.04};
static float iP070[3] = {0.00, 1266.91, 6629.60};


void Fish001(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N007);
    glVertex3fv(P007);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N004);
    glVertex3fv(P004);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glNormal3fv(N007);
    glVertex3fv(P007);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N004);
    glVertex3fv(P004);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P071);
    glVertex3fv(P072);
    glVertex3fv(P073);
    glVertex3fv(P074);
    glVertex3fv(P075);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P077);
    glVertex3fv(P078);
    glVertex3fv(P079);
    glVertex3fv(P080);
    glVertex3fv(P081);
    glVertex3fv(P082);
    glEnd();
}

void Fish002(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
}

void Fish003(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glEnd();
}

void Fish004(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N061);
    glVertex3fv(P061);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N061);
    glVertex3fv(P061);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N061);
    glVertex3fv(P061);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N061);
    glVertex3fv(P061);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N061);
    glVertex3fv(P061);
    glEnd();
}

void Fish005(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
}

void Fish006(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glEnd();
}

void Fish007(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
}

void Fish008(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
}

void Fish009(void)
{
    glBegin(GL_POLYGON);
    glVertex3fv(P059);
    glVertex3fv(P012);
    glVertex3fv(P009);
    glVertex3fv(P060);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P012);
    glVertex3fv(P004);
    glVertex3fv(P007);
    glVertex3fv(P009);
    glEnd();
}

void Fish_1(void)
{
    Fish004();                                                  
    Fish005();                                                  
    Fish003();                                                  
    Fish007();                                                  
    Fish006();                                                  
    Fish002();                                                  
    Fish008();                                                  
    Fish009();                                                  
    Fish001();                                                  
}

void Fish_2(void)
{
    Fish005();                                                  
    Fish004();                                                  
    Fish003();                                                  
    Fish008();                                                  
    Fish006();                                                  
    Fish002();                                                  
    Fish007();                                                  
    Fish009();                                                  
    Fish001();                                                  
}

void Fish_3(void)
{
    Fish005();                                                  
    Fish004();                                                  
    Fish007();                                                  
    Fish003();                                                  
    Fish002();                                                  
    Fish008();                                                  
    Fish009();                                                  
    Fish001();                                                  
    Fish006();                                                  
}

void Fish_4(void)
{
    Fish005();                                                  
    Fish004();                                                  
    Fish008();                                                  
    Fish003();                                                  
    Fish002();                                                  
    Fish007();                                                  
    Fish009();                                                  
    Fish001();                                                  
    Fish006();                                                  
}

void Fish_5(void)
{
    Fish009();                                                  
    Fish006();                                                  
    Fish007();                                                  
    Fish001();                                                  
    Fish002();                                                  
    Fish003();                                                  
    Fish008();                                                  
    Fish004();                                                  
    Fish005();                                                  
}

void Fish_6(void)
{
    Fish009();                                                  
    Fish006();                                                  
    Fish008();                                                  
    Fish001();                                                  
    Fish002();                                                  
    Fish007();                                                  
    Fish003();                                                  
    Fish004();                                                  
    Fish005();                                                  
}

void Fish_7(void)
{
    Fish009();                                                  
    Fish001();                                                  
    Fish007();                                                  
    Fish005();                                                  
    Fish002();                                                  
    Fish008();                                                  
    Fish003();                                                  
    Fish004();                                                  
    Fish006();                                                  
}

void Fish_8(void)
{
    Fish009();                                                  
    Fish008();                                                  
    Fish001();                                                  
    Fish002();                                                  
    Fish007();                                                  
    Fish003();                                                  
    Fish005();                                                  
    Fish004();                                                  
    Fish006();                                                  
}

void DrawShark(fishRec *fish) 
{
    float mat[4][4];
    int n, phi;
    float seg1, seg2, seg3, seg4, segup;
    float thrash, chomp;

    fish->htail = (int)(fish->htail - (int)(5.0 * fish->v)) % 360;

    thrash = 50.0 * fish->v;

    seg1 = 0.6 * thrash * sin(fish->htail*RRAD);
    seg2 = 1.8 * thrash * sin((fish->htail+45.0)*RRAD);
    seg3 = 3.0 * thrash * sin((fish->htail+90.0)*RRAD);
    seg4 = 4.0 * thrash * sin((fish->htail+110.0)*RRAD);

    chomp = 0.0;
    if (fish->v > 2.0) {
	chomp = -(fish->v - 2.0) * 200.0;
    }

    P004[1] = iP004[1] + chomp; 
    P007[1] = iP007[1] + chomp; 
    P010[1] = iP010[1] + chomp; 
    P011[1] = iP011[1] + chomp; 

    P023[0] = iP023[0] + seg1; 
    P024[0] = iP024[0] + seg1; 
    P025[0] = iP025[0] + seg1; 
    P026[0] = iP026[0] + seg1; 
    P027[0] = iP027[0] + seg1; 
    P028[0] = iP028[0] + seg1; 
    P029[0] = iP029[0] + seg1; 
    P030[0] = iP030[0] + seg1; 
    P031[0] = iP031[0] + seg1; 
    P032[0] = iP032[0] + seg1; 
    P033[0] = iP033[0] + seg2; 
    P034[0] = iP034[0] + seg2; 
    P035[0] = iP035[0] + seg2; 
    P036[0] = iP036[0] + seg2; 
    P037[0] = iP037[0] + seg2; 
    P038[0] = iP038[0] + seg2; 
    P039[0] = iP039[0] + seg2; 
    P040[0] = iP040[0] + seg2; 
    P041[0] = iP041[0] + seg2; 
    P042[0] = iP042[0] + seg2; 
    P043[0] = iP043[0] + seg3; 
    P044[0] = iP044[0] + seg3; 
    P045[0] = iP045[0] + seg3; 
    P046[0] = iP046[0] + seg3; 
    P047[0] = iP047[0] + seg3; 
    P048[0] = iP048[0] + seg3; 
    P049[0] = iP049[0] + seg3; 
    P050[0] = iP050[0] + seg3; 
    P051[0] = iP051[0] + seg3; 
    P052[0] = iP052[0] + seg3; 
    P002[0] = iP002[0] + seg4; 
    P061[0] = iP061[0] + seg4; 
    P069[0] = iP069[0] + seg4; 
    P070[0] = iP070[0] + seg4;

    fish->vtail += ((fish->dtheta - fish->vtail) * 0.1);

    if (fish->vtail >  0.5) {
	fish->vtail = 0.5;
    } else if (fish->vtail < -0.5) {
	fish->vtail = -0.5;
    }

    segup = thrash * fish->vtail;

    P023[1] = iP023[1] + segup; 
    P024[1] = iP024[1] + segup; 
    P025[1] = iP025[1] + segup; 
    P026[1] = iP026[1] + segup; 
    P027[1] = iP027[1] + segup; 
    P028[1] = iP028[1] + segup; 
    P029[1] = iP029[1] + segup; 
    P030[1] = iP030[1] + segup; 
    P031[1] = iP031[1] + segup; 
    P032[1] = iP032[1] + segup; 
    P033[1] = iP033[1] + segup * 5.0; 
    P034[1] = iP034[1] + segup * 5.0; 
    P035[1] = iP035[1] + segup * 5.0; 
    P036[1] = iP036[1] + segup * 5.0; 
    P037[1] = iP037[1] + segup * 5.0; 
    P038[1] = iP038[1] + segup * 5.0; 
    P039[1] = iP039[1] + segup * 5.0; 
    P040[1] = iP040[1] + segup * 5.0; 
    P041[1] = iP041[1] + segup * 5.0; 
    P042[1] = iP042[1] + segup * 5.0; 
    P043[1] = iP043[1] + segup * 12.0; 
    P044[1] = iP044[1] + segup * 12.0; 
    P045[1] = iP045[1] + segup * 12.0; 
    P046[1] = iP046[1] + segup * 12.0; 
    P047[1] = iP047[1] + segup * 12.0; 
    P048[1] = iP048[1] + segup * 12.0; 
    P049[1] = iP049[1] + segup * 12.0; 
    P050[1] = iP050[1] + segup * 12.0; 
    P051[1] = iP051[1] + segup * 12.0; 
    P052[1] = iP052[1] + segup * 12.0; 
    P002[1] = iP002[1] + segup * 17.0; 
    P061[1] = iP061[1] + segup * 17.0; 
    P069[1] = iP069[1] + segup * 17.0; 
    P070[1] = iP070[1] + segup * 17.0;

    glPushMatrix();

    glTranslatef(0.0, 0.0, -3000.0);

    glGetFloatv(GL_MODELVIEW_MATRIX, &mat[0][0]);
    n = 0;
    if (mat[0][2] >= 0.0) {
	n += 1;
    }
    if (mat[1][2] >= 0.0) {
	n += 2;
    }
    if (mat[2][2] >= 0.0) {
	n += 4;
    }

    glScalef(2.0, 1.0, 1.0);

    glEnable(GL_CULL_FACE);
    switch (n) {
      case 0:
        Fish_1();
        break;
      case 1:
        Fish_2();
        break;
      case 2:
        Fish_3();
        break;
      case 3:
        Fish_4();
        break;
      case 4:
        Fish_5();
        break;
      case 5:
        Fish_6();
        break;
      case 6:
        Fish_7();
        break;
      case 7:
        Fish_8();
        break;
    }
    glDisable(GL_CULL_FACE);

    glPopMatrix();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\dolphin.c ===
#include <windows.h>
#include <gl.h>
#include <math.h>
#include "atlantis.h"


static float N001[3] = {-0.005937 ,-0.101998 ,-0.994767};
static float N002[3] = {0.936780 ,-0.200803 ,0.286569};
static float N003[3] = {-0.233062 ,0.972058 ,0.028007};
static float N004[3] = {0.000000 ,1.000000 ,0.000000};
static float N005[3] = {0.898117 ,0.360171 ,0.252315};
static float N006[3] = {-0.915437 ,0.348456 ,0.201378};
static float N007[3] = {0.602263 ,-0.777527 ,0.180920};
static float N008[3] = {-0.906912 ,-0.412015 ,0.088061};
static float N009[3] = {-0.015623 ,0.999878 ,0.000000};
static float N010[3] = {0.000000 ,-0.992278 ,0.124035};
static float N011[3] = {0.000000 ,-0.936329 ,-0.351123};
static float N012[3] = {0.884408 ,-0.429417 ,-0.182821};
static float N013[3] = {0.921121 ,0.311084 ,-0.234016};
static float N014[3] = {0.382635 ,0.877882 ,-0.287948};
static float N015[3] = {-0.380046 ,0.888166 ,-0.258316};
static float N016[3] = {-0.891515 ,0.392238 ,-0.226607};
static float N017[3] = {-0.901419 ,-0.382002 ,-0.203763};
static float N018[3] = {-0.367225 ,-0.911091 ,-0.187243};
static float N019[3] = {0.339539 ,-0.924846 ,-0.171388};
static float N020[3] = {0.914706 ,-0.378617 ,-0.141290};
static float N021[3] = {0.950662 ,0.262713 ,-0.164994};
static float N022[3] = {0.546359 ,0.801460 ,-0.243218};
static float N023[3] = {-0.315796 ,0.917068 ,-0.243431};
static float N024[3] = {-0.825687 ,0.532277 ,-0.186875};
static float N025[3] = {-0.974763 ,-0.155232 ,-0.160435};
static float N026[3] = {-0.560596 ,-0.816658 ,-0.137119};
static float N027[3] = {0.380210 ,-0.910817 ,-0.160786};
static float N028[3] = {0.923772 ,-0.358322 ,-0.135093};
static float N029[3] = {0.951202 ,0.275053 ,-0.139859};
static float N030[3] = {0.686099 ,0.702548 ,-0.188932};
static float N031[3] = {-0.521865 ,0.826719 ,-0.210220};
static float N032[3] = {-0.923820 ,0.346739 ,-0.162258};
static float N033[3] = {-0.902095 ,-0.409995 ,-0.134646};
static float N034[3] = {-0.509115 ,-0.848498 ,-0.144404};
static float N035[3] = {0.456469 ,-0.880293 ,-0.129305};
static float N036[3] = {0.873401 ,-0.475489 ,-0.105266};
static float N037[3] = {0.970825 ,0.179861 ,-0.158584};
static float N038[3] = {0.675609 ,0.714187 ,-0.183004};
static float N039[3] = {-0.523574 ,0.830212 ,-0.191360};
static float N040[3] = {-0.958895 ,0.230808 ,-0.165071};
static float N041[3] = {-0.918285 ,-0.376803 ,-0.121542};
static float N042[3] = {-0.622467 ,-0.774167 ,-0.114888};
static float N043[3] = {0.404497 ,-0.908807 ,-0.102231};
static float N044[3] = {0.930538 ,-0.365155 ,-0.027588};
static float N045[3] = {0.921920 ,0.374157 ,-0.100345};
static float N046[3] = {0.507346 ,0.860739 ,0.041562};
static float N047[3] = {-0.394646 ,0.918815 ,-0.005730};
static float N048[3] = {-0.925411 ,0.373024 ,-0.066837};
static float N049[3] = {-0.945337 ,-0.322309 ,-0.049551};
static float N050[3] = {-0.660437 ,-0.750557 ,-0.022072};
static float N051[3] = {0.488835 ,-0.871950 ,-0.027261};
static float N052[3] = {0.902599 ,-0.421397 ,0.087969};
static float N053[3] = {0.938636 ,0.322606 ,0.122020};
static float N054[3] = {0.484605 ,0.871078 ,0.079878};
static float N055[3] = {-0.353607 ,0.931559 ,0.084619};
static float N056[3] = {-0.867759 ,0.478564 ,0.134054};
static float N057[3] = {-0.951583 ,-0.296030 ,0.082794};
static float N058[3] = {-0.672355 ,-0.730209 ,0.121384};
static float N059[3] = {0.528336 ,-0.842452 ,0.105525};
static float N060[3] = {0.786913 ,-0.564760 ,0.248627};
static float N061[3] = {0.000000 ,1.000000 ,0.000000};
static float N062[3] = {0.622098 ,0.765230 ,0.165584};
static float N063[3] = {-0.631711 ,0.767816 ,0.106773};
static float N064[3] = {-0.687886 ,0.606351 ,0.398938};
static float N065[3] = {-0.946327 ,-0.281623 ,0.158598};
static float N066[3] = {-0.509549 ,-0.860437 ,0.002776};
static float N067[3] = {0.462594 ,-0.876692 ,0.131977};
static float N068[3] = {0.000000 ,-0.992278 ,0.124035};
static float N069[3] = {0.000000 ,-0.970143 ,-0.242536};
static float N070[3] = {0.015502 ,0.992159 ,-0.124020};
static float N071[3] = {0.000000 ,1.000000 ,0.000000};
static float N072[3] = {0.000000 ,1.000000 ,0.000000};
static float N073[3] = {0.000000 ,1.000000 ,0.000000};
static float N074[3] = {0.000000 ,-1.000000 ,0.000000};
static float N075[3] = {-0.242536 ,0.000000 ,-0.970143};
static float N076[3] = {-0.010336 ,-0.992225 ,-0.124028};
static float N077[3] = {-0.880770 ,0.461448 ,0.106351};
static float N078[3] = {-0.880770 ,0.461448 ,0.106351};
static float N079[3] = {-0.880770 ,0.461448 ,0.106351};
static float N080[3] = {-0.880770 ,0.461448 ,0.106351};
static float N081[3] = {-0.571197 ,0.816173 ,0.087152};
static float N082[3] = {-0.880770 ,0.461448 ,0.106351};
static float N083[3] = {-0.571197 ,0.816173 ,0.087152};
static float N084[3] = {-0.571197 ,0.816173 ,0.087152};
static float N085[3] = {-0.880770 ,0.461448 ,0.106351};
static float N086[3] = {-0.571197 ,0.816173 ,0.087152};
static float N087[3] = {-0.880770 ,0.461448 ,0.106351};
static float N088[3] = {-0.880770 ,0.461448 ,0.106351};
static float N089[3] = {-0.880770 ,0.461448 ,0.106351};
static float N090[3] = {-0.880770 ,0.461448 ,0.106351};
static float N091[3] = {0.000000 ,1.000000 ,0.000000};
static float N092[3] = {0.000000 ,1.000000 ,0.000000};
static float N093[3] = {0.000000 ,1.000000 ,0.000000};
static float N094[3] = {1.000000 ,0.000000 ,0.000000};
static float N095[3] = {-1.000000 ,0.000000 ,0.000000};
static float N096[3] = {0.000000 ,1.000000 ,0.000000};
static float N097[3] = {-0.697296 ,0.702881 ,0.140491};
static float N098[3] = {0.918864 ,0.340821 ,0.198819};
static float N099[3] = {-0.932737 ,0.201195 ,0.299202};
static float N100[3] = {0.029517 ,0.981679 ,0.188244};
static float N101[3] = {0.000000 ,1.000000 ,0.000000};
static float N102[3] = {0.813521 ,-0.204936 ,0.544229};
static float N103[3] = {0.000000 ,1.000000 ,0.000000};
static float N104[3] = {0.000000 ,1.000000 ,0.000000};
static float N105[3] = {0.000000 ,1.000000 ,0.000000};
static float N106[3] = {0.000000 ,1.000000 ,0.000000};
static float N107[3] = {0.000000 ,1.000000 ,0.000000};
static float N108[3] = {0.000000 ,1.000000 ,0.000000};
static float N109[3] = {0.000000 ,1.000000 ,0.000000};
static float N110[3] = {-0.781480 ,-0.384779 ,0.491155};
static float N111[3] = {-0.722243 ,0.384927 ,0.574627};
static float N112[3] = {-0.752278 ,0.502679 ,0.425901};
static float N113[3] = {0.547257 ,0.367910 ,0.751766};
static float N114[3] = {0.725949 ,-0.232568 ,0.647233};
static float N115[3] = {-0.747182 ,-0.660786 ,0.071280};
static float N116[3] = {0.931519 ,0.200748 ,0.303270};
static float N117[3] = {-0.828928 ,0.313757 ,0.463071};
static float N118[3] = {0.902554 ,-0.370967 ,0.218587};
static float N119[3] = {-0.879257 ,-0.441851 ,0.177973};
static float N120[3] = {0.642327 ,0.611901 ,0.461512};
static float N121[3] = {0.964817 ,-0.202322 ,0.167910};
static float N122[3] = {0.000000 ,1.000000 ,0.000000};
static float N123[3] = {-0.980734 ,0.041447 ,0.190900};
static float N124[3] = {-0.980734 ,0.041447 ,0.190900};
static float N125[3] = {-0.980734 ,0.041447 ,0.190900};
static float N126[3] = {0.000000 ,1.000000 ,0.000000};
static float N127[3] = {0.000000 ,1.000000 ,0.000000};
static float N128[3] = {0.000000 ,1.000000 ,0.000000};
static float N129[3] = {0.963250 ,0.004839 ,0.268565};
static float N130[3] = {0.963250 ,0.004839 ,0.268565};
static float N131[3] = {0.963250 ,0.004839 ,0.268565};
static float N132[3] = {0.000000 ,1.000000 ,0.000000};
static float N133[3] = {0.000000 ,1.000000 ,0.000000};
static float N134[3] = {0.000000 ,1.000000 ,0.000000};
static float P001[3] = {5.68, -300.95, 1324.70};
static float P002[3] = {338.69, -219.63, 9677.03};
static float P003[3] = {12.18, 474.59, 9138.14};
static float P004[3] = {-7.49, -388.91, 10896.74};
static float P005[3] = {487.51, 198.05, 9350.78};
static float P006[3] = {-457.61, 68.74, 9427.85};
static float P007[3] = {156.52, -266.72, 10311.68};
static float P008[3] = {-185.56, -266.51, 10310.47};
static float P009[3] = {124.39, -261.46, 1942.34};
static float P010[3] = {-130.05, -261.46, 1946.03};
static float P011[3] = {141.07, -320.11, 1239.38};
static float P012[3] = {156.48, -360.12, 2073.41};
static float P013[3] = {162.00, -175.88, 2064.44};
static float P014[3] = {88.16, -87.72, 2064.02};
static float P015[3] = {-65.21, -96.13, 2064.02};
static float P016[3] = {-156.48, -180.96, 2064.44};
static float P017[3] = {-162.00, -368.93, 2082.39};
static float P018[3] = {-88.16, -439.22, 2082.39};
static float P019[3] = {65.21, -440.32, 2083.39};
static float P020[3] = {246.87, -356.02, 2576.95};
static float P021[3] = {253.17, -111.15, 2567.15};
static float P022[3] = {132.34, 51.41, 2559.84};
static float P023[3] = {-97.88, 40.44, 2567.15};
static float P024[3] = {-222.97, -117.49, 2567.15};
static float P025[3] = {-252.22, -371.53, 2569.92};
static float P026[3] = {-108.44, -518.19, 2586.75};
static float P027[3] = {97.88, -524.79, 2586.75};
static float P028[3] = {370.03, -421.19, 3419.70};
static float P029[3] = {351.15, -16.98, 3423.17};
static float P030[3] = {200.66, 248.46, 3430.37};
static float P031[3] = {-148.42, 235.02, 3417.91};
static float P032[3] = {-360.21, -30.27, 3416.84};
static float P033[3] = {-357.90, -414.89, 3407.04};
static float P034[3] = {-148.88, -631.35, 3409.90};
static float P035[3] = {156.38, -632.59, 3419.70};
static float P036[3] = {462.61, -469.21, 4431.51};
static float P037[3] = {466.60, 102.25, 4434.98};
static float P038[3] = {243.05, 474.34, 4562.02};
static float P039[3] = {-191.23, 474.40, 4554.42};
static float P040[3] = {-476.12, 111.05, 4451.11};
static float P041[3] = {-473.36, -470.74, 4444.78};
static float P042[3] = {-266.95, -748.41, 4447.78};
static float P043[3] = {211.14, -749.91, 4429.73};
static float P044[3] = {680.57, -370.27, 5943.46};
static float P045[3] = {834.01, 363.09, 6360.63};
static float P046[3] = {371.29, 804.51, 6486.26};
static float P047[3] = {-291.43, 797.22, 6494.28};
static float P048[3] = {-784.13, 370.75, 6378.01};
static float P049[3] = {-743.29, -325.82, 5943.46};
static float P050[3] = {-383.24, -804.77, 5943.46};
static float P051[3] = {283.47, -846.09, 5943.46};
static float iP001[3] = {5.68, -300.95, 1324.70};
static float iP002[3] = {338.69, -219.63, 9677.03};
static float iP003[3] = {12.18, 624.93, 8956.39};
static float iP004[3] = {-7.49, -388.91, 10896.74};
static float iP005[3] = {487.51, 198.05, 9350.78};
static float iP006[3] = {-457.61, 199.04, 9353.01};
static float iP007[3] = {156.52, -266.72, 10311.68};
static float iP008[3] = {-185.56, -266.51, 10310.47};
static float iP009[3] = {124.39, -261.46, 1942.34};
static float iP010[3] = {-130.05, -261.46, 1946.03};
static float iP011[3] = {141.07, -320.11, 1239.38};
static float iP012[3] = {156.48, -360.12, 2073.41};
static float iP013[3] = {162.00, -175.88, 2064.44};
static float iP014[3] = {88.16, -87.72, 2064.02};
static float iP015[3] = {-65.21, -96.13, 2064.02};
static float iP016[3] = {-156.48, -180.96, 2064.44};
static float iP017[3] = {-162.00, -368.93, 2082.39};
static float iP018[3] = {-88.16, -439.22, 2082.39};
static float iP019[3] = {65.21, -440.32, 2083.39};
static float iP020[3] = {246.87, -356.02, 2576.95};
static float iP021[3] = {253.17, -111.15, 2567.15};
static float iP022[3] = {132.34, 51.41, 2559.84};
static float iP023[3] = {-97.88, 40.44, 2567.15};
static float iP024[3] = {-222.97, -117.49, 2567.15};
static float iP025[3] = {-252.22, -371.53, 2569.92};
static float iP026[3] = {-108.44, -518.19, 2586.75};
static float iP027[3] = {97.88, -524.79, 2586.75};
static float iP028[3] = {370.03, -421.19, 3419.70};
static float iP029[3] = {351.15, -16.98, 3423.17};
static float iP030[3] = {200.66, 248.46, 3430.37};
static float iP031[3] = {-148.42, 235.02, 3417.91};
static float iP032[3] = {-360.21, -30.27, 3416.84};
static float iP033[3] = {-357.90, -414.89, 3407.04};
static float iP034[3] = {-148.88, -631.35, 3409.90};
static float iP035[3] = {156.38, -632.59, 3419.70};
static float iP036[3] = {462.61, -469.21, 4431.51};
static float iP037[3] = {466.60, 102.25, 4434.98};
static float iP038[3] = {243.05, 474.34, 4562.02};
static float iP039[3] = {-191.23, 474.40, 4554.42};
static float iP040[3] = {-476.12, 111.05, 4451.11};
static float iP041[3] = {-473.36, -470.74, 4444.78};
static float iP042[3] = {-266.95, -748.41, 4447.78};
static float iP043[3] = {211.14, -749.91, 4429.73};
static float iP044[3] = {680.57, -370.27, 5943.46};
static float iP045[3] = {834.01, 363.09, 6360.63};
static float iP046[3] = {371.29, 804.51, 6486.26};
static float iP047[3] = {-291.43, 797.22, 6494.28};
static float iP048[3] = {-784.13, 370.75, 6378.01};
static float iP049[3] = {-743.29, -325.82, 5943.46};
static float iP050[3] = {-383.24, -804.77, 5943.46};
static float iP051[3] = {283.47, -846.09, 5943.46};
static float P052[3] = {599.09, -300.15, 7894.03};
static float P053[3] = {735.48, 306.26, 7911.92};
static float P054[3] = {246.22, 558.53, 8460.50};
static float P055[3] = {-230.41, 559.84, 8473.23};
static float P056[3] = {-698.66, 320.83, 7902.59};
static float P057[3] = {-643.29, -299.16, 7902.59};
static float P058[3] = {-341.47, -719.30, 7902.59};
static float P059[3] = {252.57, -756.12, 7902.59};
static float P060[3] = {458.39, -265.31, 9355.44};
static float P061[3] = {433.38, -161.90, 9503.03};
static float P062[3] = {224.04, 338.75, 9450.30};
static float P063[3] = {-165.71, 341.04, 9462.35};
static float P064[3] = {-298.11, 110.13, 10180.37};
static float P065[3] = {-473.99, -219.71, 9355.44};
static float P066[3] = {-211.97, -479.87, 9355.44};
static float P067[3] = {192.86, -491.45, 9348.73};
static float P068[3] = {-136.29, -319.84, 1228.73};
static float P069[3] = {1111.17, -314.14, 1314.19};
static float P070[3] = {-1167.34, -321.61, 1319.45};
static float P071[3] = {1404.86, -306.66, 1235.45};
static float P072[3] = {-1409.73, -314.14, 1247.66};
static float P073[3] = {1254.01, -296.87, 1544.58};
static float P074[3] = {-1262.09, -291.70, 1504.26};
static float P075[3] = {965.71, -269.26, 1742.65};
static float P076[3] = {-900.97, -276.74, 1726.07};
static float iP068[3] = {-136.29, -319.84, 1228.73};
static float iP069[3] = {1111.17, -314.14, 1314.19};
static float iP070[3] = {-1167.34, -321.61, 1319.45};
static float iP071[3] = {1404.86, -306.66, 1235.45};
static float iP072[3] = {-1409.73, -314.14, 1247.66};
static float iP073[3] = {1254.01, -296.87, 1544.58};
static float iP074[3] = {-1262.09, -291.70, 1504.26};
static float iP075[3] = {965.71, -269.26, 1742.65};
static float iP076[3] = {-900.97, -276.74, 1726.07};
static float P077[3] = {1058.00, -448.81, 8194.66};
static float P078[3] = {-1016.51, -456.43, 8190.62};
static float P079[3] = {-1515.96, -676.45, 7754.93};
static float P080[3] = {1856.75, -830.34, 7296.56};
static float P081[3] = {1472.16, -497.38, 7399.68};
static float P082[3] = {-1775.26, -829.51, 7298.46};
static float P083[3] = {911.09, -252.51, 7510.99};
static float P084[3] = {-1451.94, -495.62, 7384.30};
static float P085[3] = {1598.75, -669.26, 7769.90};
static float P086[3] = {-836.53, -250.08, 7463.25};
static float P087[3] = {722.87, -158.18, 8006.41};
static float P088[3] = {-688.86, -162.28, 7993.89};
static float P089[3] = {-626.92, -185.30, 8364.98};
static float P090[3] = {647.72, -189.46, 8354.99};
static float P091[3] = {0.00, 835.01, 5555.62};
static float P092[3] = {0.00, 1350.18, 5220.86};
static float P093[3] = {0.00, 1422.94, 5285.27};
static float P094[3] = {0.00, 1296.75, 5650.19};
static float P095[3] = {0.00, 795.63, 6493.88};
static float iP091[3] = {0.00, 835.01, 5555.62};
static float iP092[3] = {0.00, 1350.18, 5220.86};
static float iP093[3] = {0.00, 1422.94, 5285.27};
static float iP094[3] = {0.00, 1296.75, 5650.19};
static float iP095[3] = {0.00, 795.63, 6493.88};
static float P096[3] = {-447.38, -165.99, 9499.60};
static float P097[3] = {-194.91, -357.14, 10313.32};
static float P098[3] = {135.35, -357.66, 10307.94};
static float iP097[3] = {-194.91, -357.14, 10313.32};
static float iP098[3] = {135.35, -357.66, 10307.94};
static float P099[3] = {-380.53, -221.14, 9677.98};
static float P100[3] = {0.00, 412.99, 9629.33};
static float P101[3] = {5.70, 567.00, 7862.98};
static float P102[3] = {59.51, -412.55, 10677.58};
static float iP102[3] = {59.51, -412.55, 10677.58};
static float P103[3] = {6.50, 484.74, 9009.94};
static float P104[3] = {-9.86, 567.62, 7858.65};
static float P105[3] = {-41.86, 476.51, 9078.17};
static float P106[3] = {22.75, 568.13, 7782.83};
static float P107[3] = {58.93, 568.42, 7775.94};
static float P108[3] = {49.20, 476.83, 9078.24};
static float P109[3] = {99.21, 566.00, 7858.65};
static float P110[3] = {-187.62, -410.04, 10674.12};
static float iP110[3] = {-187.62, -410.04, 10674.12};
static float P111[3] = {-184.25, -318.70, 10723.88};
static float iP111[3] = {-184.25, -318.70, 10723.88};
static float P112[3] = {-179.61, -142.81, 10670.26};
static float P113[3] = {57.43, -147.94, 10675.26};
static float P114[3] = {54.06, -218.90, 10712.44};
static float P115[3] = {-186.35, -212.09, 10713.76};
static float P116[3] = {205.90, -84.61, 10275.97};
static float P117[3] = {-230.96, -83.26, 10280.09};
static float iP118[3] = {216.78, -509.17, 10098.94};
static float iP119[3] = {-313.21, -510.79, 10102.62};
static float P118[3] = {216.78, -509.17, 10098.94};
static float P119[3] = {-313.21, -510.79, 10102.62};
static float P120[3] = {217.95, 96.34, 10161.62};
static float P121[3] = {71.99, -319.74, 10717.70};
static float iP121[3] = {71.99, -319.74, 10717.70};
static float P122[3] = {0.00, 602.74, 5375.84};
static float iP122[3] = {0.00, 602.74, 5375.84};
static float P123[3] = {-448.94, -203.14, 9499.60};
static float P124[3] = {-442.64, -185.20, 9528.07};
static float P125[3] = {-441.07, -148.05, 9528.07};
static float P126[3] = {-443.43, -128.84, 9499.60};
static float P127[3] = {-456.87, -146.78, 9466.67};
static float P128[3] = {-453.68, -183.93, 9466.67};
static float P129[3] = {428.43, -124.08, 9503.03};
static float P130[3] = {419.73, -142.14, 9534.56};
static float P131[3] = {419.92, -179.96, 9534.56};
static float P132[3] = {431.20, -199.73, 9505.26};
static float P133[3] = {442.28, -181.67, 9475.96};
static float P134[3] = {442.08, -143.84, 9475.96};


void Dolphin001(void)
{
    glNormal3fv(N071);
    glBegin(GL_POLYGON);
    glVertex3fv(P001);
    glVertex3fv(P068);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P068);
    glVertex3fv(P076);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P068);
    glVertex3fv(P070);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P076);
    glVertex3fv(P070);
    glVertex3fv(P074);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P070);
    glVertex3fv(P072);
    glVertex3fv(P074);
    glEnd();
    glNormal3fv(N119);
    glBegin(GL_POLYGON);
    glVertex3fv(P072);
    glVertex3fv(P070);
    glVertex3fv(P074);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P074);
    glVertex3fv(P070);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P070);
    glVertex3fv(P068);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P076);
    glVertex3fv(P068);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P068);
    glVertex3fv(P001);
    glVertex3fv(P010);
    glEnd();
}

void Dolphin002(void)
{
    glNormal3fv(N071);
    glBegin(GL_POLYGON);
    glVertex3fv(P011);
    glVertex3fv(P001);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P075);
    glVertex3fv(P011);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P069);
    glVertex3fv(P011);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P069);
    glVertex3fv(P075);
    glVertex3fv(P073);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P071);
    glVertex3fv(P069);
    glVertex3fv(P073);
    glEnd();
    glNormal3fv(N119);
    glBegin(GL_POLYGON);
    glVertex3fv(P001);
    glVertex3fv(P011);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P009);
    glVertex3fv(P011);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P011);
    glVertex3fv(P069);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P069);
    glVertex3fv(P073);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P069);
    glVertex3fv(P071);
    glVertex3fv(P073);
    glEnd();
}

void Dolphin003(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glEnd();
}

void Dolphin004(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glEnd();
}

void Dolphin005(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glEnd();
}

void Dolphin006(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N093);
    glVertex3fv(P093);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N093);
    glVertex3fv(P093);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N122);
    glVertex3fv(P122);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N122);
    glVertex3fv(P122);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glEnd();
}

void Dolphin007(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glEnd();
}

void Dolphin008(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glEnd();
}

void Dolphin009(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
}

void Dolphin010(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N080);
    glVertex3fv(P080);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N090);
    glVertex3fv(P090);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N080);
    glVertex3fv(P080);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glNormal3fv(N090);
    glVertex3fv(P090);
    glEnd();
}

void Dolphin011(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N082);
    glVertex3fv(P082);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N082);
    glVertex3fv(P082);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
}

void Dolphin012(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glEnd();
}

void Dolphin013(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glNormal3fv(N117);
    glVertex3fv(P117);
    glNormal3fv(N112);
    glVertex3fv(P112);
    glNormal3fv(N113);
    glVertex3fv(P113);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N114);
    glVertex3fv(P114);
    glNormal3fv(N113);
    glVertex3fv(P113);
    glNormal3fv(N112);
    glVertex3fv(P112);
    glNormal3fv(N115);
    glVertex3fv(P115);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N114);
    glVertex3fv(P114);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glNormal3fv(N113);
    glVertex3fv(P113);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N114);
    glVertex3fv(P114);
    glNormal3fv(N007);
    glVertex3fv(P007);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N007);
    glVertex3fv(P007);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P002);
    glVertex3fv(P007);
    glVertex3fv(P008);
    glVertex3fv(P099);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P007);
    glVertex3fv(P114);
    glVertex3fv(P115);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N117);
    glVertex3fv(P117);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N117);
    glVertex3fv(P117);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N112);
    glVertex3fv(P112);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N112);
    glVertex3fv(P112);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N115);
    glVertex3fv(P115);
    glEnd();
}

void Dolphin014(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N111);
    glVertex3fv(P111);
    glNormal3fv(N110);
    glVertex3fv(P110);
    glNormal3fv(N102);
    glVertex3fv(P102);
    glNormal3fv(N121);
    glVertex3fv(P121);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N111);
    glVertex3fv(P111);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glNormal3fv(N110);
    glVertex3fv(P110);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glNormal3fv(N110);
    glVertex3fv(P110);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P098);
    glVertex3fv(P097);
    glVertex3fv(P111);
    glVertex3fv(P121);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P002);
    glVertex3fv(P099);
    glVertex3fv(P097);
    glVertex3fv(P098);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N110);
    glVertex3fv(P110);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glNormal3fv(N118);
    glVertex3fv(P118);
    glNormal3fv(N102);
    glVertex3fv(P102);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N119);
    glVertex3fv(P119);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N118);
    glVertex3fv(P118);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N118);
    glVertex3fv(P118);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N118);
    glVertex3fv(P118);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N098);
    glVertex3fv(P098);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N118);
    glVertex3fv(P118);
    glNormal3fv(N098);
    glVertex3fv(P098);
    glNormal3fv(N102);
    glVertex3fv(P102);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N102);
    glVertex3fv(P102);
    glNormal3fv(N098);
    glVertex3fv(P098);
    glNormal3fv(N121);
    glVertex3fv(P121);
    glEnd();
}

void Dolphin015(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glNormal3fv(N117);
    glVertex3fv(P117);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glNormal3fv(N064);
    glVertex3fv(P064);
    glNormal3fv(N117);
    glVertex3fv(P117);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N120);
    glVertex3fv(P120);
    glNormal3fv(N116);
    glVertex3fv(P116);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
}

void Dolphin016(void)
{

    glDisable(GL_DEPTH_TEST);
    glBegin(GL_POLYGON);
    glVertex3fv(P123);
    glVertex3fv(P124);
    glVertex3fv(P125);
    glVertex3fv(P126);
    glVertex3fv(P127);
    glVertex3fv(P128);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P129);
    glVertex3fv(P130);
    glVertex3fv(P131);
    glVertex3fv(P132);
    glVertex3fv(P133);
    glVertex3fv(P134);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P103);
    glVertex3fv(P105);
    glVertex3fv(P108);
    glEnd();
    glEnable(GL_DEPTH_TEST);
}

void DrawDolphin(fishRec *fish)
{
    float seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
    float pitch, thrash, chomp;

    fish->htail = (int)(fish->htail - (int)(10.0 * fish->v)) % 360;

    thrash = 70.0 * fish->v;

    seg0 = 1.0 * thrash * sin((fish->htail)*RRAD);
    seg3 = 1.0 * thrash * sin((fish->htail)*RRAD);
    seg1 = 2.0 * thrash * sin((fish->htail+4.0)*RRAD);
    seg2 = 3.0 * thrash * sin((fish->htail+6.0)*RRAD);
    seg4 = 4.0 * thrash * sin((fish->htail+10.0)*RRAD);
    seg5 = 4.5 * thrash * sin((fish->htail+15.0)*RRAD);
    seg6 = 5.0 * thrash * sin((fish->htail+20.0)*RRAD);
    seg7 = 6.0 * thrash * sin((fish->htail+30.0)*RRAD);

    pitch = fish->v * sin((fish->htail+180.0)*RRAD);

    if (fish->v > 2.0) {
	chomp = -(fish->v - 2.0) * 200.0;
    }
    chomp = 100.0;

    P012[1] = iP012[1] + seg5;
    P013[1] = iP013[1] + seg5;
    P014[1] = iP014[1] + seg5;
    P015[1] = iP015[1] + seg5;
    P016[1] = iP016[1] + seg5;
    P017[1] = iP017[1] + seg5;
    P018[1] = iP018[1] + seg5;
    P019[1] = iP019[1] + seg5;

    P020[1] = iP020[1] + seg4;
    P021[1] = iP021[1] + seg4;
    P022[1] = iP022[1] + seg4;
    P023[1] = iP023[1] + seg4;
    P024[1] = iP024[1] + seg4;
    P025[1] = iP025[1] + seg4;
    P026[1] = iP026[1] + seg4;
    P027[1] = iP027[1] + seg4;

    P028[1] = iP028[1] + seg2;
    P029[1] = iP029[1] + seg2;
    P030[1] = iP030[1] + seg2;
    P031[1] = iP031[1] + seg2;
    P032[1] = iP032[1] + seg2;
    P033[1] = iP033[1] + seg2;
    P034[1] = iP034[1] + seg2;
    P035[1] = iP035[1] + seg2;

    P036[1] = iP036[1] + seg1;
    P037[1] = iP037[1] + seg1;
    P038[1] = iP038[1] + seg1;
    P039[1] = iP039[1] + seg1;
    P040[1] = iP040[1] + seg1;
    P041[1] = iP041[1] + seg1;
    P042[1] = iP042[1] + seg1;
    P043[1] = iP043[1] + seg1;

    P044[1] = iP044[1] + seg0;
    P045[1] = iP045[1] + seg0;
    P046[1] = iP046[1] + seg0;
    P047[1] = iP047[1] + seg0;
    P048[1] = iP048[1] + seg0;
    P049[1] = iP049[1] + seg0;
    P050[1] = iP050[1] + seg0;
    P051[1] = iP051[1] + seg0;

    P009[1] = iP009[1] + seg6;
    P010[1] = iP010[1] + seg6;
    P075[1] = iP075[1] + seg6;
    P076[1] = iP076[1] + seg6;

    P001[1] = iP001[1] + seg7;
    P011[1] = iP011[1] + seg7;
    P068[1] = iP068[1] + seg7;
    P069[1] = iP069[1] + seg7;
    P070[1] = iP070[1] + seg7;
    P071[1] = iP071[1] + seg7;
    P072[1] = iP072[1] + seg7;
    P073[1] = iP073[1] + seg7;
    P074[1] = iP074[1] + seg7;

    P091[1] = iP091[1] + seg3;
    P092[1] = iP092[1] + seg3;
    P093[1] = iP093[1] + seg3;
    P094[1] = iP094[1] + seg3;
    P095[1] = iP095[1] + seg3;
    P122[1] = iP122[1] + seg3 * 1.5;

    P097[1] = iP097[1] + chomp;
    P098[1] = iP098[1] + chomp;
    P102[1] = iP102[1] + chomp;
    P110[1] = iP110[1] + chomp;
    P111[1] = iP111[1] + chomp;
    P121[1] = iP121[1] + chomp;
    P118[1] = iP118[1] + chomp;
    P119[1] = iP119[1] + chomp;

    glPushMatrix();

    glRotatef(pitch, 1.0, 0.0, 0.0);

    glTranslatef(0.0, 0.0, 7000.0);

    glRotatef(180.0, 0.0, 1.0, 0.0);

    glEnable(GL_CULL_FACE);
    Dolphin014();                                               
    Dolphin010();                                               
    Dolphin009();                                               
    Dolphin012();                                               
    Dolphin013();                                               
    Dolphin006();                                               
    Dolphin002();                                               
    Dolphin001();                                               
    Dolphin003();                                               
    Dolphin015();                                               
    Dolphin004();                                               
    Dolphin005();                                               
    Dolphin007();                                               
    Dolphin008();                                               
    Dolphin011(); 
    Dolphin016();                                               
    glDisable(GL_CULL_FACE);

    glPopMatrix();                                              
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\cbacks.cxx ===
#ifdef GLX_MOTIF
#include <X11/keysym.h>

#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/ToggleB.h>
#include <GL/glx.h>
#include <GLwMDrawA.h>
#include <sys/time.h>
#endif

extern "C" {
#include <windows.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include <GL/glaux.h>
}

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include "scene.hxx"
#include "cbacks.hxx"
#include "menu.h"

#ifdef GLX_MOTIF
extern Widget glw;
extern XtAppContext app_context;
GLXContext glx_context;
#endif

extern light lights[];
extern int quick_moves;
extern int auto_motion;
static float dtheta[nlights];
static float last_motion_update;

//struct timeval starttime;
SYSTEMTIME starttime;

static int button_down;
static int winx, winy;
GLint mouse_x, mouse_y;

static int name_selected;

#ifdef GLX_MOTIF
static XtWorkProcId workproc = NULL;
#endif

const float time_fudge = .0001;

inline
float current_time()
{
  //struct timeval time;
  SYSTEMTIME time;

  //gettimeofday(&time, NULL);
  GetSystemTime(&time);

  //return ((double)(time.tv_sec - starttime.tv_sec) +
  //	  (double)(time.tv_usec - starttime.tv_usec) / 1000000.0);

  return ((float)(time.wSecond - starttime.wSecond) +
        (float)(time.wMilliseconds - starttime.wMilliseconds) / (float)1000.0);

}

inline float rand(float min, float max) 
{
  double r;
  r = (double)rand() / (double)RAND_MAX;
  return (float)(min + r * (max - min));
}

/******************************Public*Routine******************************\
*
* void draw(void)
*
* History:
*  29-Nov-1993                      Replaced with wgl and aux calls
*
\**************************************************************************/

void draw(void)
{

#ifdef GLX_MOTIF
  GLwDrawingAreaMakeCurrent(glw, glx_context);
//#else
  //wglMakeCurrent(auxGetHDC(), auxGetHGLRC());
#endif

  scene_draw();

#ifdef GLX_MOTIF
  GLwDrawingAreaSwapBuffers(glw);
#else
  // Win32's SwapBuffers takes HDC
  // SwapBuffers(auxGetHDC);
  auxSwapBuffers();
#endif

}

/******************************Public*Routine******************************\
*
* vQuickMove(void)
*
* //void intToggleCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  set or reset the global flag quick_moves
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vQuickMove(void)
{
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());

#ifdef GLX_MOTIF
  int *data;
  XmToggleButtonCallbackStruct *ptr;

  ptr = (XmToggleButtonCallbackStruct *)call_data;
  data = (int *)client_data;
  *data = ptr->set;
#endif

  quick_moves = quick_moves ? 0 : 1;

  if (quick_moves)
    CheckMenuItem(hmenu, IDM_QUICK, MF_BYCOMMAND | MF_CHECKED);
  else
    CheckMenuItem(hmenu, IDM_QUICK, MF_BYCOMMAND | MF_UNCHECKED);

  // This redraw may or may not be needed - do it to be safe
  draw();
}

/******************************Public*Routine******************************\
*
* vResetLights(void)
*
* // void resetLightsCB(Widget w)
*
* Effects:
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vResetLights(void)
{
  scene_reset_lights();
  draw();
}

/******************************Public*Routine******************************\
*
* vAutoMotion(void)
*
* // void autoMotionCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  !!! turns on/off the timer?
*           (Re)set the global auto_moves
*
* Warnings:
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vAutoMotion(void)
{
  int i;
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());


#ifdef GLX_MOTIF
  XmToggleButtonCallbackStruct *ptr;

  ptr = (XmToggleButtonCallbackStruct *)call_data;

  auto_motion = ptr->set;
#endif

  auto_motion = auto_motion ? 0 : 1;
  SendMessage(auxGetHWND(), WM_USER, 0L, 0L);

  if (auto_motion) {
    CheckMenuItem(hmenu, IDM_AUTO, MF_BYCOMMAND | MF_CHECKED);

    for (i = 0; i < nlights; i++)
        dtheta[i] = rand(-1, 1);
    last_motion_update = current_time();
  } else {
    CheckMenuItem(hmenu, IDM_AUTO, MF_BYCOMMAND | MF_UNCHECKED);
  }

#ifdef GLX_MOTIF
  if (auto_motion) {
    workproc = XtAppAddWorkProc(app_context, drawWP, NULL);
    for (i = 0; i < nlights; i++) dtheta[i] = rand(-1, 1);
    last_motion_update = current_time();
  } else {
    XtRemoveWorkProc(workproc);
  }
#endif

}


/******************************Public*Routine******************************\
*
* vInit(void)
*
* // void initCB(Widget w)
*
* Effects:
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vInit(void)
{
  RECT  rect;
  HMENU hmenu;
  HWND  hWnd;
  int   i;

#ifdef GLX_MOTIF
  Arg args[1];
  XVisualInfo *vi;

  XtSetArg(args[0], GLwNvisualInfo, &vi);
  XtGetValues(w, args, 1);
 
  // !!! creating indirect context, make current
  //
  glx_context = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE);
  GLwDrawingAreaMakeCurrent(w, glx_context);
#endif

#ifdef TESTTEST
  PIXELFORMATDESCRIPTOR pfd;
  HDC                   hDC;
  HGLRC                 hRC;
  INT                   iPixelFormat;

  hDC = auxGetHDC();

  iPixelFormat = GetPixelFormat(hDC);
  DescribePixelFormat(hDC, iPixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &pfd);

  if ((pfd.dwFlags & PFD_SUPPORT_GDI) == 0) {

    OutputDebugString("PFD_SUPPORT_GDI not supported!\n");

    pfd.dwFlags |= PFD_SUPPORT_GDI;

  }

  if (!SetPixelFormat(hDC, iPixelFormat, &pfd))
    OutputDebugString("PFD_SUPPORT_GDI still not supported!\n");


  //
  // Maynot need this
  //
  hRC = wglCreateContext(hDC);
  if (!wglMakeCurrent(hDC, hRC))
    OutputDebugString("MakeCurrentFailed!\n");
#endif



  scene_init(); 

  //gettimeofday(&starttime, NULL);
  //srand(starttime.tv_usec);

  GetSystemTime(&starttime);
  srand(starttime.wMilliseconds);

  hWnd = auxGetHWND();
  GetClientRect(hWnd, &rect);

  glViewport(0, 0, rect.right, rect.bottom);
  glClear(GL_COLOR_BUFFER_BIT);

  //
  // this is for initizating the menu items
  //
  hmenu = GetMenu(hWnd);

  for (i=0; i < nlights; i++) {
    if (lights[i].on)
      CheckMenuItem(hmenu, IDM_RED+i, MF_BYCOMMAND | MF_CHECKED);
    else
      CheckMenuItem(hmenu, IDM_RED+i, MF_BYCOMMAND | MF_UNCHECKED);
  }

  if (draw_square)
    CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_CHECKED);
  if (draw_shadows)
    CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_CHECKED);
  if (draw_refraction)
    CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_CHECKED);
  if (draw_lights)
    CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_CHECKED);
  if (draw_sphere)
    CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_CHECKED);
  if (draw_texture)
    CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_CHECKED);

  CheckMenuItem(hmenu, IDM_AIR+def_refraction_index, MF_BYCOMMAND | MF_CHECKED);
  CheckMenuItem(hmenu, IDM_10+def_divisions_index, MF_BYCOMMAND | MF_CHECKED);

}

/******************************Public*Routine******************************\
*
* vExpose
*
* // !!! void exposeCB(Widget w)
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vExpose(int x, int y)
{
  draw();
}

/******************************Public*Routine******************************\
*
* vResize
*
* // void resizeCB(Widget w, XtPointer client_data, XtPointer call)
*
* Effects:  changes globals winx, winy and aspect
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vResize(GLsizei width, GLsizei height)
{
#ifdef GLX_MOTIF
  GLwDrawingAreaCallbackStruct *call_data;
  call_data = (GLwDrawingAreaCallbackStruct *)call;

  GLwDrawingAreaMakeCurrent(w, glx_context);
  winx = call_data->width;
  winy = call_data->height;
#endif

  winx = width;
  winy = height;

  glViewport(0, 0, winx, winy);

  aspect = (GLfloat)winx / (GLfloat)winy;
}

#ifdef GLX_MOTIF
//
// !!! mouse down/up function??
//
void inputCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  int picked;
  GLwDrawingAreaCallbackStruct *call;

  char buffer[5];
  int bufsize = 5;
  KeySym key;
  XComposeStatus compose;

  static int mousex, mousey;
  /* Just to confuse everybody, I've made these go from 0-1. */
  float dmousex, dmousey;
  float r1, r2;

  call = (GLwDrawingAreaCallbackStruct *)call_data;
  
  GLwDrawingAreaMakeCurrent(w, glx_context);
  switch(call->event->type) {
  case ButtonPress:
    button_down = call->event->xbutton.button;
    mousex = call->event->xbutton.x;
    mousey = call->event->xbutton.y;
    picked = scene_pick(mousex, mousey);
    if (picked >= name_lights) name_selected = picked;
    break;
  case ButtonRelease:
    if (quick_moves) 
      scene_move_update(name_selected, button_down == Button2, 
			button_down == Button3, button_down = Button1);
    button_down = 0; 
    break;
  case MotionNotify:
    if (button_down == Button1) {
      /* This is the "default" mouse button - moves things in theta
       * since this is easy and computationally cheap */
      dmousex = (double)(call->event->xmotion.x - mousex) / (double)winx;
      scene_move(name_selected, 0, 0, dmousex, quick_moves ? 0 : 1);
    } else if (button_down == Button2) {
      /* Change the radius - figue out the component of the mouse motion
       * that's going toward the center of the screen */
      mousex = (winx / 2) - mousex;
      mousey = (winy / 2) - mousey;
      r1 = sqrt((float)(mousex*mousex) / (float)(winx*winx) + 
		(float)(mousey*mousey) / (float)(winy*winy));
      mousex = call->event->xmotion.x;
      mousey = call->event->xmotion.y;
      mousex = (winx / 2) - mousex;
      mousey = (winy / 2) - mousey;
      r2 = sqrt((float)(mousex*mousex) / (float)(winx*winx) + 
		(float)(mousey*mousey) / (float)(winy*winy));
      scene_move(name_selected, r2 - r1, 0, 0, quick_moves ? 0 : 1);
    } else if (button_down == Button3) {
      /* Change phi - this is expensive */
      dmousex = (double)(call->event->xmotion.x - mousex) / (double)winx;
      scene_move(name_selected, 0, dmousex, 0, quick_moves ? 0 : 1);
    }
    mousex = call->event->xmotion.x;
    mousey = call->event->xmotion.y;
    break;
  case KeyPress:
    XLookupString(&(call->event->xkey), buffer, bufsize, &key, &compose);
    if (key == XK_Escape) exit(0);
    break;                            
  default:
    break;
  }

  draw();
}
#endif

/******************************Public*Routine******************************\
*
* vDrawAll(void)
*
* //void drawAllCB(Widget w)
*
* Effects:
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vDrawAll(void)
{
  HMENU hmenu;
  int       i;
  static int fAll=0;

  hmenu = GetMenu(auxGetHWND());

  fAll = fAll ? 0 : 1;

  if (fAll) {
    for (i=0; i < 6; i++)
       CheckMenuItem(hmenu, IDM_SQUARE+i, MF_BYCOMMAND | MF_CHECKED);

    CheckMenuItem(hmenu, IDM_ALL, MF_BYCOMMAND | MF_CHECKED);
    draw_square = 1;
    draw_shadows = 1;
    draw_refraction = 1;
    draw_sphere = 1;
    draw_lights = 1;

  } else {
    CheckMenuItem(hmenu, IDM_ALL, MF_BYCOMMAND | MF_UNCHECKED);
  }

  draw();
}

/******************************Public*Routine******************************\
*
* //void drawSomethingCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  functions for auxKeyFunc can't have parameters so we have
*           these similar functions here.
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vDrawSquare(void)
{
#ifdef GLX_MOTIF
  XmToggleButtonCallbackStruct *ptr;
  int *data;
  int i;

  ptr = (XmToggleButtonCallbackStruct *)call_data;
  data = (int *)client_data;
  *data = ptr->set;
#endif
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_square = draw_square ? 0 : 1;
  if (draw_square)
      CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_SQUARE, MF_BYCOMMAND | MF_UNCHECKED);

  draw();
}

void vDrawShadow(void)
{
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_shadows = draw_shadows ? 0 : 1;
  if (draw_shadows)
      CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_SHADOW, MF_BYCOMMAND | MF_UNCHECKED);
  draw();
}

void vDrawRefraction(void)
{
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_refraction = draw_refraction ? 0 : 1;
  if (draw_refraction)
      CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_REFRACTION, MF_BYCOMMAND | MF_UNCHECKED);
  draw();
}
void vDrawSphere(void)
{
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_sphere = draw_sphere ? 0 : 1;
  if (draw_sphere)
      CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_SPHERE, MF_BYCOMMAND | MF_UNCHECKED);
  draw();
}
void vDrawLight(void)
{
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_lights = draw_lights ? 0 : 1;
  if (draw_lights)
      CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_LIGHTS, MF_BYCOMMAND | MF_UNCHECKED);
  draw();
}
void vDrawTexture(void)
{
  HMENU hmenu;

  hmenu = GetMenu(auxGetHWND());

  draw_texture = draw_texture ? 0 : 1;
  if (draw_texture)
      CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_CHECKED);
  else
      CheckMenuItem(hmenu, IDM_TEXTURE, MF_BYCOMMAND | MF_UNCHECKED);
  draw();
}

void vDrawStuff(int *what)
{
  *what = *what ? 0 : 1;
  draw();
}

/******************************Public*Routine******************************\
*
* //void refractionCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  functions for auxKeyFunc can't have parameters so we have
*           these similar functions here.
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vRefractionAIR(void)
{
#ifdef GLX_MOTIF
  XmToggleButtonCallbackStruct *ptr;
  GLfloat refraction;

  ptr = (XmToggleButtonCallbackStruct *)call_data;
  if (!ptr->set) return;
  refraction = *((GLfloat *)client_data);
#endif

  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+0, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[0].index;
  refraction_change(refraction);
  draw();
}

void vRefractionICE(void)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+1, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[1].index;
  refraction_change(refraction);
  draw();
}

void vRefractionWATER(void)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+2, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[2].index;
  refraction_change(refraction);
  draw();
}

void vRefractionZincGLASS(void)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+3, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[3].index;
  refraction_change(refraction);
  draw();
}
void vRefractionLightGLASS(void)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+4, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[4].index;
  refraction_change(refraction);
  draw();
}
void vRefractionHeavyGLASS(void)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+5, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[5].index;
  refraction_change(refraction);
  draw();
}

void vRefraction(int type)
{
  GLfloat refraction;
  HMENU   hmenu;
  int         i;

  hmenu = GetMenu(auxGetHWND());
  for (i = 0; i < nindices; i++)
    CheckMenuItem(hmenu, IDM_AIR+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_AIR+type, MF_BYCOMMAND | MF_CHECKED);
  refraction = indices[type].index;
  refraction_change(refraction);
  draw();
}

/******************************Public*Routine******************************\
*
* vSubdivision
*
* //void subdivisionCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  functions for auxKeyFunc can't have parameters so we have
*           these similar functions here.
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vSubdivision10(void)
{
#ifdef GLX_MOTIF
  XmToggleButtonCallbackStruct *ptr;
  int subdivisions;

  ptr = (XmToggleButtonCallbackStruct *)call_data;
  if (!ptr->set) return;
  subdivisions = *((int *)client_data);
#endif

  HMENU hmenu;
  int       i;

  hmenu = GetMenu(auxGetHWND());

  for (i = 0; i < npossible_divisions; i++)
    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_10, MF_BYCOMMAND | MF_CHECKED);
  divisions_change(possible_divisions[0]);

  draw();
}

void vSubdivision20(void)
{
  HMENU hmenu;
  int       i;

  hmenu = GetMenu(auxGetHWND());

  for (i = 0; i < npossible_divisions; i++)
    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_20, MF_BYCOMMAND | MF_CHECKED);
  divisions_change(possible_divisions[1]);

  draw();
}

void vSubdivision30(void)
{
  HMENU hmenu;
  int       i;

  hmenu = GetMenu(auxGetHWND());

  for (i = 0; i < npossible_divisions; i++)
    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_30, MF_BYCOMMAND | MF_CHECKED);
  divisions_change(possible_divisions[2]);

  draw();
}

void vSubdivision40(void)
{
  HMENU hmenu;
  int       i;

  hmenu = GetMenu(auxGetHWND());

  for (i = 0; i < npossible_divisions; i++)
    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_40, MF_BYCOMMAND | MF_CHECKED);
  divisions_change(possible_divisions[3]);

  draw();
}


void vSubdivision(int which)
{
  HMENU hmenu;
  int       i;

  hmenu = GetMenu(auxGetHWND());

  for (i = 0; i < npossible_divisions; i++)
    CheckMenuItem(hmenu, IDM_10+i, MF_BYCOMMAND | MF_UNCHECKED);

  CheckMenuItem(hmenu, IDM_10+which, MF_BYCOMMAND | MF_CHECKED);

  divisions_change(possible_divisions[which]);
  draw();
}

/******************************Public*Routine******************************\
*
* v[RGB]Light_on
*
* //void light_onCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects:  functions for auxKeyFunc can't have parameters so we have
*           these similar functions here.
* History:
*  30-Nov-1993
*
\**************************************************************************/
#define RED_LIGHT   0
#define GREEN_LIGHT 1
#define BLUE_LIGHT  2

void vRLight_on(void)
{
#ifdef GLX_MOTIF
  XmToggleButtonCallbackStruct *ptr;

  ptr = (XmToggleButtonCallbackStruct *)call_data;
  lights_onoff((light *)client_data - lights, ptr->set);
#endif

  int fOn;
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());

  fOn = lights[RED_LIGHT].on ? 0 : 1;
  if (fOn)
    CheckMenuItem(hmenu, IDM_RED, MF_BYCOMMAND | MF_CHECKED);
  else
    CheckMenuItem(hmenu, IDM_RED, MF_BYCOMMAND | MF_UNCHECKED);
  lights_onoff(RED_LIGHT, fOn);
  draw();
}

void vGLight_on(void)
{
  int fOn;
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());

  fOn = lights[GREEN_LIGHT].on ? 0 : 1;
  if (fOn)
    CheckMenuItem(hmenu, IDM_GREEN, MF_BYCOMMAND | MF_CHECKED);
  else
    CheckMenuItem(hmenu, IDM_GREEN, MF_BYCOMMAND | MF_UNCHECKED);
  lights_onoff(GREEN_LIGHT, fOn);
  draw();
}

void vBLight_on(void)
{
  int fOn;
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());

  fOn = lights[BLUE_LIGHT].on ? 0 : 1;
  if (fOn)
    CheckMenuItem(hmenu, IDM_BLUE, MF_BYCOMMAND | MF_CHECKED);
  else
    CheckMenuItem(hmenu, IDM_BLUE, MF_BYCOMMAND | MF_UNCHECKED);
  lights_onoff(BLUE_LIGHT, fOn);
  draw();
}

void vLight_on(int which)
{
  int fOn;
  HMENU   hmenu;

  hmenu = GetMenu(auxGetHWND());

  fOn = lights[which].on ? 0 : 1;

  if (fOn)
    CheckMenuItem(hmenu, IDM_RED+which, MF_BYCOMMAND | MF_CHECKED);
  else
    CheckMenuItem(hmenu, IDM_RED+which, MF_BYCOMMAND | MF_UNCHECKED);

  lights_onoff(which, fOn);
  draw();
}




/******************************Public*Routine******************************\
*
* vExit
*
* //void exitCB(Widget w, XtPointer client_data, XtPointer call_data)
*
* Effects: !!! this is redundant unless we do stuff other than auxQuit
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

void vExit(void)
{
#ifdef GLX_MOTIF
  exit(0);
#endif

    auxQuit();
}

/******************************Public*Routine******************************\
*
* bAutoMotion(void)
*
* // Boolean drawWP(XtPointer data)
*
* Effects:  !!! for WM_TIMER ?
*
* History:
*  30-Nov-1993
*
\**************************************************************************/

GLboolean bAutoMotion(void)
{
  float t, dt;
  int i;

  t = current_time();
  dt = t - last_motion_update;
  dt = (dt < 0) ? -dt : dt;

  if (dt < time_fudge) {
    char text[128];

    wsprintf(text, "dt = %lx\n", dt);
    OutputDebugString(text);
    return FALSE;
  }

  for (i = 0; i < nlights; i++) {
    scene_move(name_lights + i, 0, 0, dtheta[i] * dt, 1);
  }

  last_motion_update = t;

  draw();
  return FALSE;
}



void vMouseDown(AUX_EVENTREC *event)
{
  int    picked;

  mouse_x = event->data[AUX_MOUSEX];
  mouse_y = event->data[AUX_MOUSEY];

  picked = scene_pick(mouse_x, mouse_y);
  if (picked >= name_lights)
     name_selected = picked;

  return;
}

void vLeftMouseUp(AUX_EVENTREC *event)
{
  if (quick_moves)
    scene_move_update(name_selected, 0,     // dr
		                     0,     // dphi
                                     1);    // dtheta

  return;
}

void vMiddleMouseUp(AUX_EVENTREC *event)
{
  if (quick_moves)
    scene_move_update(name_selected, 1,     // dr
		                     0,     // dphi
                                     0);    // dtheta

  return;
}

void vRightMouseUp(AUX_EVENTREC *event)
{
  if (quick_moves)
    scene_move_update(name_selected, 0,     // dr
		                     1,     // dphi
                                     0);    // dtheta

  return;
}

void CALLBACK vMouseMove(AUX_EVENTREC *event)
{
  float dmousex;
  float r1, r2;
  GLint button = event->data[AUX_MOUSESTATUS];
  GLint x = event->data[AUX_MOUSEX];
  GLint y = event->data[AUX_MOUSEY];
   

  switch( button ) {
    case AUX_LEFTBUTTON:
      /* This is the "default" mouse button - moves things in theta
       * since this is easy and computationally cheap */
      dmousex = (float)((double)(x - mouse_x) / (double)winx);
      scene_move(name_selected, 0, 0, dmousex, quick_moves ? 0 : 1);
      break;

    case AUX_MIDDLEBUTTON:
      /* Change the radius - figue out the component of the mouse motion
       * that's going toward the center of the screen */
      mouse_x = (winx / 2) - mouse_x;
      mouse_y = (winy / 2) - mouse_y;
      r1 = (float)sqrt((double)(mouse_x*mouse_x) / (double)(winx*winx) +
    	(double)(mouse_y*mouse_y) / (double)(winy*winy));
      mouse_x = x;
      mouse_y = y;
      mouse_x = (winx / 2) - mouse_x;
      mouse_y = (winy / 2) - mouse_y;
      r2 = (float)sqrt((double)(mouse_x*mouse_x) / (double)(winx*winx) +
	  (double)(mouse_y*mouse_y) / (double)(winy*winy));
      scene_move(name_selected, r2 - r1, 0, 0, quick_moves ? 0 : 1);
      break;

    case AUX_RIGHTBUTTON :
      /* Change phi - this is expensive */
      dmousex = (float)((double)(x - mouse_x) / (double)winx);
      scene_move(name_selected, 0, dmousex, 0, quick_moves ? 0 : 1);
      break;
    }

    mouse_x = x;
    mouse_y = y;
}

//
// hack these since cfront generates these...
//
PVOID __nw(unsigned int ui)
{
    return LocalAlloc(LMEM_FIXED, ui);
}


VOID __dl(PVOID pv)
{

    LocalFree(pv);
    return;
}

PVOID __vec_new(void *p, int x, int y, void *q)
{
    return LocalAlloc(LMEM_FIXED, x*y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\point.cxx ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
extern "C" {
#include <windows.h>
#include <GL/gl.h>
}

#include <math.h>
#include <stdio.h>

#define POINT_EXTERN
#include "scene.hxx"

// Change this back to inline
Point Point::rotate_abouty(GLfloat c, GLfloat s)
{
  val.pt[0] = c*pt[0] + s*pt[2];
  val.pt[1] = pt[1];
  val.pt[2] = -s*pt[0] + c*pt[2];
  return val;
}



void Point::refract_self(Point light, Point N, GLfloat I)
{
  GLfloat t;
  Point dlight;

  dlight = refract_direction(light, N, I);
  t = -pt[2] / dlight.pt[2];
  pt[0] = pt[0] + dlight.pt[0]*t;
  pt[1] = pt[1] + dlight.pt[1]*t;
  pt[2] = 0;
}

Point Point::refract_direction(Point light, Point N, GLfloat I)
{
  GLfloat cos1, sin1, cos2, sin2, m;
  GLfloat dlight[3], dN[3], axis[3];

  /* dlight = (light - *this).unit() * -1.0; */
  dlight[0] = pt[0] - light.pt[0];
  dlight[1] = pt[1] - light.pt[1];
  dlight[2] = pt[2] - light.pt[2];
  m = (GLfloat)sqrt((double)(dlight[0]*dlight[0] + dlight[1]*dlight[1] + dlight[2]*dlight[2]));
  dlight[0] /= m;
  dlight[1] /= m;
  dlight[2] /= m;

  // dN = N * -1.0;
  dN[0] = -N.pt[0];
  dN[1] = -N.pt[1];
  dN[2] = -N.pt[2];

  // cos1 = dN.dot(dlight);
  cos1 = dN[0]*dlight[0] + dN[1]*dlight[1] + dN[2]*dlight[2];

  if (1.0 - cos1*cos1 < point_fudge) {
    val = dN;
    return val;
  }

  // axis = ((dN * dlight) * dN).unit();
  val.pt[0] = dN[1]*dlight[2] - dlight[1]*dN[2];
  val.pt[1] = dN[2]*dlight[0] - dlight[2]*dN[0];
  val.pt[2] = dN[0]*dlight[1] - dN[1]*dlight[0];
  axis[0] = val.pt[1]*dN[2] - dN[1]*val.pt[2];
  axis[1] = val.pt[2]*dN[0] - dN[2]*val.pt[0];
  axis[2] = val.pt[0]*dN[1] - val.pt[1]*dN[0];
  m = (GLfloat)sqrt((double)(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]));
  axis[0] /= m;
  axis[1] /= m;
  axis[2] /= m;

  if (axis[0]*axis[0] > point_fudge)
    sin1 = (dlight[0] - dN[0] * cos1) / axis[0];
  else if (axis[1]*axis[1] > point_fudge)
    sin1 = (dlight[1] - dN[1] * cos1) / axis[1];
  else sin1 = dlight[2] - dN[2] * cos1;

  sin2 = sin1 / I;
  cos2 = (sin1*sin1 < 1.0) ? (GLfloat)sqrt((double)(1.0 - sin2*sin2)) : (GLfloat)0;

  dlight[0] = dN[0]*cos2 + axis[0]*sin2;
  dlight[1] = dN[1]*cos2 + axis[1]*sin2;
  dlight[2] = dN[2]*cos2 + axis[2]*sin2;

  /* I'm not sure this is quite legal */
  if (dlight[2] > 0.0) dlight[2] = -dlight[2];

  val = dlight;

  return val;
}

void Point::print()
{
  print("%f %f %f\n");
}

void Point::print(const char *format)
{
  printf(format, this->pt[0], this->pt[1], this->pt[2], 1.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\insectco.h ===
#define CMAPSTART 640


#define SHADOW_COLOR    0

#define GRAY (CMAPSTART+43)
#define GRID (CMAPSTART+44)
#define SKYBLUE (CMAPSTART+45)
#define RAMPB (CMAPSTART+46)
#define RAMPE (CMAPSTART+55)
#define RAMPB2 (CMAPSTART+56)
#define RAMPE2 (CMAPSTART+65)
#define RAMPB3 (CMAPSTART+66)
#define RAMPE3 (CMAPSTART+75)
#define RAMPB4 (CMAPSTART+76)
#define RAMPE4 (CMAPSTART+85)
#define RAMPB5 (CMAPSTART+86)
#define RAMPE5 (CMAPSTART+95)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\atlantis\whale.c ===
#include <windows.h>
#include <gl.h>
#include <math.h>
#include "atlantis.h"


static float N001[3] = {0.019249 ,0.011340 ,-0.999750};
static float N002[3] = {-0.132579 ,0.954547 ,0.266952};
static float N003[3] = {-0.196061 ,0.980392 ,-0.019778};
static float N004[3] = {0.695461 ,0.604704 ,0.388158};
static float N005[3] = {0.870600 ,0.425754 ,0.246557};
static float N006[3] = {-0.881191 ,0.392012 ,0.264251};
static float N007[3] = {0.000000 ,1.000000 ,0.000000};
static float N008[3] = {-0.341437 ,0.887477 ,0.309523};
static float N009[3] = {0.124035 ,-0.992278 ,0.000000};
static float N010[3] = {0.242536 ,0.000000 ,-0.970143};
static float N011[3] = {0.588172 ,0.000000 ,0.808736};
static float N012[3] = {0.929824 ,-0.340623 ,-0.139298};
static float N013[3] = {0.954183 ,0.267108 ,-0.134865};
static float N014[3] = {0.495127 ,0.855436 ,-0.151914};
static float N015[3] = {-0.390199 ,0.906569 ,-0.160867};
static float N016[3] = {-0.923605 ,0.354581 ,-0.145692};
static float N017[3] = {-0.955796 ,-0.260667 ,-0.136036};
static float N018[3] = {-0.501283 ,-0.853462 ,-0.142540};
static float N019[3] = {0.405300 ,-0.901974 ,-0.148913};
static float N020[3] = {0.909913 ,-0.392746 ,-0.133451};
static float N021[3] = {0.936494 ,0.331147 ,-0.115414};
static float N022[3] = {0.600131 ,0.793724 ,-0.099222};
static float N023[3] = {-0.231556 ,0.968361 ,-0.093053};
static float N024[3] = {-0.844369 ,0.525330 ,-0.105211};
static float N025[3] = {-0.982725 ,-0.136329 ,-0.125164};
static float N026[3] = {-0.560844 ,-0.822654 ,-0.093241};
static float N027[3] = {0.263884 ,-0.959981 ,-0.093817};
static float N028[3] = {0.842057 ,-0.525192 ,-0.122938};
static float N029[3] = {0.921620 ,0.367565 ,-0.124546};
static float N030[3] = {0.613927 ,0.784109 ,-0.090918};
static float N031[3] = {-0.448754 ,0.888261 ,-0.098037};
static float N032[3] = {-0.891865 ,0.434376 ,-0.126077};
static float N033[3] = {-0.881447 ,-0.448017 ,-0.149437};
static float N034[3] = {-0.345647 ,-0.922057 ,-0.174183};
static float N035[3] = {0.307998 ,-0.941371 ,-0.137688};
static float N036[3] = {0.806316 ,-0.574647 ,-0.140124};
static float N037[3] = {0.961346 ,0.233646 ,-0.145681};
static float N038[3] = {0.488451 ,0.865586 ,-0.110351};
static float N039[3] = {-0.374290 ,0.921953 ,-0.099553};
static float N040[3] = {-0.928504 ,0.344533 ,-0.138485};
static float N041[3] = {-0.918419 ,-0.371792 ,-0.135189};
static float N042[3] = {-0.520666 ,-0.833704 ,-0.183968};
static float N043[3] = {0.339204 ,-0.920273 ,-0.195036};
static float N044[3] = {0.921475 ,-0.387382 ,-0.028636};
static float N045[3] = {0.842465 ,0.533335 ,-0.076204};
static float N046[3] = {0.380110 ,0.924939 ,0.002073};
static float N047[3] = {-0.276128 ,0.961073 ,-0.009579};
static float N048[3] = {-0.879684 ,0.473001 ,-0.049250};
static float N049[3] = {-0.947184 ,-0.317614 ,-0.044321};
static float N050[3] = {-0.642059 ,-0.764933 ,-0.051363};
static float N051[3] = {0.466794 ,-0.880921 ,-0.077990};
static float N052[3] = {0.898509 ,-0.432277 ,0.076279};
static float N053[3] = {0.938985 ,0.328141 ,0.103109};
static float N054[3] = {0.442420 ,0.895745 ,0.043647};
static float N055[3] = {-0.255163 ,0.966723 ,0.018407};
static float N056[3] = {-0.833769 ,0.540650 ,0.111924};
static float N057[3] = {-0.953653 ,-0.289939 ,0.080507};
static float N058[3] = {-0.672357 ,-0.730524 ,0.119461};
static float N059[3] = {0.522249 ,-0.846652 ,0.102157};
static float N060[3] = {0.885868 ,-0.427631 ,0.179914};
static float N061[3] = {0.000000 ,1.000000 ,0.000000};
static float N062[3] = {0.648942 ,0.743116 ,0.163255};
static float N063[3] = {-0.578967 ,0.807730 ,0.111219};
static float N064[3] = {0.000000 ,1.000000 ,0.000000};
static float N065[3] = {-0.909864 ,-0.352202 ,0.219321};
static float N066[3] = {-0.502541 ,-0.818090 ,0.279610};
static float N067[3] = {0.322919 ,-0.915358 ,0.240504};
static float N068[3] = {0.242536 ,0.000000 ,-0.970143};
static float N069[3] = {0.000000 ,1.000000 ,0.000000};
static float N070[3] = {0.000000 ,1.000000 ,0.000000};
static float N071[3] = {0.000000 ,1.000000 ,0.000000};
static float N072[3] = {0.000000 ,1.000000 ,0.000000};
static float N073[3] = {0.000000 ,1.000000 ,0.000000};
static float N074[3] = {0.000000 ,1.000000 ,0.000000};
static float N075[3] = {0.031220 ,0.999025 ,-0.031220};
static float N076[3] = {0.000000 ,1.000000 ,0.000000};
static float N077[3] = {0.446821 ,0.893642 ,0.041889};
static float N078[3] = {0.863035 ,-0.100980 ,0.494949};
static float N079[3] = {0.585597 ,-0.808215 ,0.062174};
static float N080[3] = {0.000000 ,1.000000 ,0.000000};
static float N081[3] = {1.000000 ,0.000000 ,0.000000};
static float N082[3] = {0.000000 ,1.000000 ,0.000000};
static float N083[3] = {-1.000000 ,0.000000 ,0.000000};
static float N084[3] = {-0.478893 ,0.837129 ,-0.264343};
static float N085[3] = {0.000000 ,1.000000 ,0.000000};
static float N086[3] = {0.763909 ,0.539455 ,-0.354163};
static float N087[3] = {0.446821 ,0.893642 ,0.041889};
static float N088[3] = {0.385134 ,-0.908288 ,0.163352};
static float N089[3] = {-0.605952 ,0.779253 ,-0.159961};
static float N090[3] = {0.000000 ,1.000000 ,0.000000};
static float N091[3] = {0.000000 ,1.000000 ,0.000000};
static float N092[3] = {0.000000 ,1.000000 ,0.000000};
static float N093[3] = {0.000000 ,1.000000 ,0.000000};
static float N094[3] = {1.000000 ,0.000000 ,0.000000};
static float N095[3] = {-1.000000 ,0.000000 ,0.000000};
static float N096[3] = {0.644444 ,-0.621516 ,0.445433};
static float N097[3] = {-0.760896 ,-0.474416 ,0.442681};
static float N098[3] = {0.636888 ,-0.464314 ,0.615456};
static float N099[3] = {-0.710295 ,0.647038 ,0.277168};
static float N100[3] = {0.009604 ,0.993655 ,0.112063};
static float N101[3] = {0.000000 ,1.000000 ,0.000000};
static float N102[3] = {0.000000 ,1.000000 ,0.000000};
static float N103[3] = {0.000000 ,1.000000 ,0.000000};
static float N104[3] = {0.031837 ,0.999285 ,0.020415};
static float N105[3] = {0.031837 ,0.999285 ,0.020415};
static float N106[3] = {0.031837 ,0.999285 ,0.020415};
static float N107[3] = {0.014647 ,0.999648 ,0.022115};
static float N108[3] = {0.014647 ,0.999648 ,0.022115};
static float N109[3] = {0.014647 ,0.999648 ,0.022115};
static float N110[3] = {-0.985141 ,0.039475 ,0.167149};
static float N111[3] = {-0.985141 ,0.039475 ,0.167149};
static float N112[3] = {-0.985141 ,0.039475 ,0.167149};
static float N113[3] = {0.000000 ,1.000000 ,0.000000};
static float N114[3] = {0.000000 ,1.000000 ,0.000000};
static float N115[3] = {0.000000 ,1.000000 ,0.000000};
static float N116[3] = {0.000000 ,1.000000 ,0.000000};
static float N117[3] = {0.000000 ,1.000000 ,0.000000};
static float N118[3] = {0.000000 ,1.000000 ,0.000000};
static float N119[3] = {0.000000 ,1.000000 ,0.000000};
static float N120[3] = {0.000000 ,1.000000 ,0.000000};
static float N121[3] = {0.000000 ,1.000000 ,0.000000};
static float iP001[3] = {18.74, 13.19, 3.76};
static float P001[3] = {18.74, 13.19, 3.76};
static float P002[3] = {0.00, 390.42, 10292.57};
static float P003[3] = {55.80, 622.31, 8254.35};
static float P004[3] = {20.80, 247.66, 10652.13};
static float P005[3] = {487.51, 198.05, 9350.78};
static float P006[3] = {-457.61, 199.04, 9353.01};
static float P007[3] = {0.00, 259.00, 10276.27};
static float P008[3] = {-34.67, 247.64, 10663.71};
static float iP009[3] = {97.46, 67.63, 593.82};
static float iP010[3] = {-84.33, 67.63, 588.18};
static float iP011[3] = {118.69, 8.98, -66.91};
static float P009[3] = {97.46, 67.63, 593.82};
static float P010[3] = {-84.33, 67.63, 588.18};
static float P011[3] = {118.69, 8.98, -66.91};
static float iP012[3] = {156.48, -31.95, 924.54};
static float iP013[3] = {162.00, 110.22, 924.54};
static float iP014[3] = {88.16, 221.65, 924.54};
static float iP015[3] = {-65.21, 231.16, 924.54};
static float iP016[3] = {-156.48, 121.97, 924.54};
static float iP017[3] = {-162.00, -23.93, 924.54};
static float iP018[3] = {-88.16, -139.10, 924.54};
static float iP019[3] = {65.21, -148.61, 924.54};
static float iP020[3] = {246.87, -98.73, 1783.04};
static float iP021[3] = {253.17, 127.76, 1783.04};
static float iP022[3] = {132.34, 270.77, 1783.04};
static float iP023[3] = {-97.88, 285.04, 1783.04};
static float iP024[3] = {-222.97, 139.80, 1783.04};
static float iP025[3] = {-225.29, -86.68, 1783.04};
static float iP026[3] = {-108.44, -224.15, 1783.04};
static float iP027[3] = {97.88, -221.56, 1783.04};
static float iP028[3] = {410.55, -200.66, 3213.87};
static float iP029[3] = {432.19, 148.42, 3213.87};
static float iP030[3] = {200.66, 410.55, 3213.87};
static float iP031[3] = {-148.42, 432.19, 3213.87};
static float iP032[3] = {-407.48, 171.88, 3213.87};
static float iP033[3] = {-432.19, -148.42, 3213.87};
static float iP034[3] = {-148.88, -309.74, 3213.87};
static float iP035[3] = {156.38, -320.17, 3213.87};
static float iP036[3] = {523.39, -303.81, 4424.57};
static float iP037[3] = {574.66, 276.84, 4424.57};
static float iP038[3] = {243.05, 492.50, 4424.57};
static float iP039[3] = {-191.23, 520.13, 4424.57};
static float iP040[3] = {-523.39, 304.01, 4424.57};
static float iP041[3] = {-574.66, -231.83, 4424.57};
static float iP042[3] = {-266.95, -578.17, 4424.57};
static float iP043[3] = {211.14, -579.67, 4424.57};
static float iP044[3] = {680.57, -370.27, 5943.46};
static float iP045[3] = {834.01, 363.09, 5943.46};
static float iP046[3] = {371.29, 614.13, 5943.46};
static float iP047[3] = {-291.43, 621.86, 5943.46};
static float iP048[3] = {-784.13, 362.60, 5943.46};
static float iP049[3] = {-743.29, -325.82, 5943.46};
static float iP050[3] = {-383.24, -804.77, 5943.46};
static float iP051[3] = {283.47, -846.09, 5943.46};
static float P012[3] = {156.48, -31.95, 924.54};
static float P013[3] = {162.00, 110.22, 924.54};
static float P014[3] = {88.16, 221.65, 924.54};
static float P015[3] = {-65.21, 231.16, 924.54};
static float P016[3] = {-156.48, 121.97, 924.54};
static float P017[3] = {-162.00, -23.93, 924.54};
static float P018[3] = {-88.16, -139.10, 924.54};
static float P019[3] = {65.21, -148.61, 924.54};
static float P020[3] = {246.87, -98.73, 1783.04};
static float P021[3] = {253.17, 127.76, 1783.04};
static float P022[3] = {132.34, 270.77, 1783.04};
static float P023[3] = {-97.88, 285.04, 1783.04};
static float P024[3] = {-222.97, 139.80, 1783.04};
static float P025[3] = {-225.29, -86.68, 1783.04};
static float P026[3] = {-108.44, -224.15, 1783.04};
static float P027[3] = {97.88, -221.56, 1783.04};
static float P028[3] = {410.55, -200.66, 3213.87};
static float P029[3] = {432.19, 148.42, 3213.87};
static float P030[3] = {200.66, 410.55, 3213.87};
static float P031[3] = {-148.42, 432.19, 3213.87};
static float P032[3] = {-407.48, 171.88, 3213.87};
static float P033[3] = {-432.19, -148.42, 3213.87};
static float P034[3] = {-148.88, -309.74, 3213.87};
static float P035[3] = {156.38, -320.17, 3213.87};
static float P036[3] = {523.39, -303.81, 4424.57};
static float P037[3] = {574.66, 276.84, 4424.57};
static float P038[3] = {243.05, 492.50, 4424.57};
static float P039[3] = {-191.23, 520.13, 4424.57};
static float P040[3] = {-523.39, 304.01, 4424.57};
static float P041[3] = {-574.66, -231.83, 4424.57};
static float P042[3] = {-266.95, -578.17, 4424.57};
static float P043[3] = {211.14, -579.67, 4424.57};
static float P044[3] = {680.57, -370.27, 5943.46};
static float P045[3] = {834.01, 363.09, 5943.46};
static float P046[3] = {371.29, 614.13, 5943.46};
static float P047[3] = {-291.43, 621.86, 5943.46};
static float P048[3] = {-784.13, 362.60, 5943.46};
static float P049[3] = {-743.29, -325.82, 5943.46};
static float P050[3] = {-383.24, -804.77, 5943.46};
static float P051[3] = {283.47, -846.09, 5943.46};
static float P052[3] = {599.09, -332.24, 7902.59};
static float P053[3] = {735.48, 306.26, 7911.92};
static float P054[3] = {321.55, 558.53, 7902.59};
static float P055[3] = {-260.54, 559.84, 7902.59};
static float P056[3] = {-698.66, 320.83, 7902.59};
static float P057[3] = {-643.29, -299.16, 7902.59};
static float P058[3] = {-341.47, -719.30, 7902.59};
static float P059[3] = {252.57, -756.12, 7902.59};
static float P060[3] = {458.39, -265.31, 9355.44};
static float iP061[3] = {353.63, 138.70, 10214.20};
static float P061[3] = {353.63, 138.70, 10214.20};
static float P062[3] = {224.04, 438.98, 9364.77};
static float P063[3] = {-165.71, 441.27, 9355.44};
static float iP064[3] = {-326.40, 162.04, 10209.54};
static float P064[3] = {-326.40, 162.04, 10209.54};
static float P065[3] = {-473.99, -219.71, 9355.44};
static float P066[3] = {-211.97, -479.87, 9355.44};
static float P067[3] = {192.86, -504.03, 9355.44};
static float iP068[3] = {-112.44, 9.25, -64.42};
static float iP069[3] = {1155.63, 0.00, -182.46};
static float iP070[3] = {-1143.13, 0.00, -181.54};
static float iP071[3] = {1424.23, 0.00, -322.09};
static float iP072[3] = {-1368.01, 0.00, -310.38};
static float iP073[3] = {1255.57, 2.31, 114.05};
static float iP074[3] = {-1149.38, 0.00, 117.12};
static float iP075[3] = {718.36, 0.00, 433.36};
static float iP076[3] = {-655.90, 0.00, 433.36};
static float P068[3] = {-112.44, 9.25, -64.42};
static float P069[3] = {1155.63, 0.00, -182.46};
static float P070[3] = {-1143.13, 0.00, -181.54};
static float P071[3] = {1424.23, 0.00, -322.09};
static float P072[3] = {-1368.01, 0.00, -310.38};
static float P073[3] = {1255.57, 2.31, 114.05};
static float P074[3] = {-1149.38, 0.00, 117.12};
static float P075[3] = {718.36, 0.00, 433.36};
static float P076[3] = {-655.90, 0.00, 433.36};
static float P077[3] = {1058.00, -2.66, 7923.51};
static float P078[3] = {-1016.51, -15.47, 7902.87};
static float P079[3] = {-1363.99, -484.50, 7593.38};
static float P080[3] = {1478.09, -861.47, 7098.12};
static float P081[3] = {1338.06, -284.68, 7024.15};
static float P082[3] = {-1545.51, -860.64, 7106.60};
static float P083[3] = {1063.19, -70.46, 7466.60};
static float P084[3] = {-1369.18, -288.11, 7015.34};
static float P085[3] = {1348.44, -482.50, 7591.41};
static float P086[3] = {-1015.45, -96.80, 7474.86};
static float P087[3] = {731.04, 148.38, 7682.58};
static float P088[3] = {-697.03, 151.82, 7668.81};
static float P089[3] = {-686.82, 157.09, 7922.29};
static float P090[3] = {724.73, 147.75, 7931.39};
static float iP091[3] = {0.00, 327.10, 2346.55};
static float iP092[3] = {0.00, 552.28, 2311.31};
static float iP093[3] = {0.00, 721.16, 2166.41};
static float iP094[3] = {0.00, 693.42, 2388.80};
static float iP095[3] = {0.00, 389.44, 2859.97};
static float P091[3] = {0.00, 327.10, 2346.55};
static float P092[3] = {0.00, 552.28, 2311.31};
static float P093[3] = {0.00, 721.16, 2166.41};
static float P094[3] = {0.00, 693.42, 2388.80};
static float P095[3] = {0.00, 389.44, 2859.97};
static float iP096[3] = {222.02, -183.67, 10266.89};
static float iP097[3] = {-128.90, -182.70, 10266.89};
static float iP098[3] = {41.04, 88.31, 10659.36};
static float iP099[3] = {-48.73, 88.30, 10659.36};
static float P096[3] = {222.02, -183.67, 10266.89};
static float P097[3] = {-128.90, -182.70, 10266.89};
static float P098[3] = {41.04, 88.31, 10659.36};
static float P099[3] = {-48.73, 88.30, 10659.36};
static float P100[3] = {0.00, 603.42, 9340.68};
static float P101[3] = {5.70, 567.00, 7862.98};
static float P102[3] = {521.61, 156.61, 9162.34};
static float P103[3] = {83.68, 566.67, 7861.26};
static float P104[3] = {-9.86, 567.62, 7858.65};
static float P105[3] = {31.96, 565.27, 7908.46};
static float P106[3] = {22.75, 568.13, 7782.83};
static float P107[3] = {58.93, 568.42, 7775.94};
static float P108[3] = {55.91, 565.59, 7905.86};
static float P109[3] = {99.21, 566.00, 7858.65};
static float P110[3] = {-498.83, 148.14, 9135.10};
static float P111[3] = {-495.46, 133.24, 9158.48};
static float P112[3] = {-490.82, 146.23, 9182.76};
static float P113[3] = {-489.55, 174.11, 9183.66};
static float P114[3] = {-492.92, 189.00, 9160.28};
static float P115[3] = {-497.56, 176.02, 9136.00};
static float P116[3] = {526.54, 169.68, 9137.70};
static float P117[3] = {523.49, 184.85, 9161.42};
static float P118[3] = {518.56, 171.78, 9186.06};
static float P119[3] = {516.68, 143.53, 9186.98};
static float P120[3] = {519.73, 128.36, 9163.26};
static float P121[3] = {524.66, 141.43, 9138.62};


void Whale001(void)
{

    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N074);
    glVertex3fv(P074);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N072);
    glVertex3fv(P072);
    glNormal3fv(N074);
    glVertex3fv(P074);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N072);
    glVertex3fv(P072);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N074);
    glVertex3fv(P074);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N074);
    glVertex3fv(P074);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N070);
    glVertex3fv(P070);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N076);
    glVertex3fv(P076);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N068);
    glVertex3fv(P068);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N010);
    glVertex3fv(P010);
    glEnd();
}

void Whale002(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glNormal3fv(N073);
    glVertex3fv(P073);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N071);
    glVertex3fv(P071);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N073);
    glVertex3fv(P073);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N009);
    glVertex3fv(P009);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N011);
    glVertex3fv(P011);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N073);
    glVertex3fv(P073);
    glNormal3fv(N075);
    glVertex3fv(P075);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N069);
    glVertex3fv(P069);
    glNormal3fv(N071);
    glVertex3fv(P071);
    glNormal3fv(N073);
    glVertex3fv(P073);
    glEnd();
}

void Whale003(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N001);
    glVertex3fv(P001);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glEnd();
}

void Whale004(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N015);
    glVertex3fv(P015);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N016);
    glVertex3fv(P016);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N017);
    glVertex3fv(P017);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N014);
    glVertex3fv(P014);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N013);
    glVertex3fv(P013);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N018);
    glVertex3fv(P018);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N019);
    glVertex3fv(P019);
    glNormal3fv(N012);
    glVertex3fv(P012);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glEnd();
}

void Whale005(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N022);
    glVertex3fv(P022);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N023);
    glVertex3fv(P023);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N024);
    glVertex3fv(P024);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N021);
    glVertex3fv(P021);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N020);
    glVertex3fv(P020);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N025);
    glVertex3fv(P025);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N026);
    glVertex3fv(P026);
    glNormal3fv(N027);
    glVertex3fv(P027);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glEnd();
}

void Whale006(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N093);
    glVertex3fv(P093);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N093);
    glVertex3fv(P093);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N091);
    glVertex3fv(P091);
    glNormal3fv(N092);
    glVertex3fv(P092);
    glNormal3fv(N094);
    glVertex3fv(P094);
    glNormal3fv(N095);
    glVertex3fv(P095);
    glEnd();
}

void Whale007(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N030);
    glVertex3fv(P030);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N029);
    glVertex3fv(P029);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N028);
    glVertex3fv(P028);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N035);
    glVertex3fv(P035);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N034);
    glVertex3fv(P034);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N031);
    glVertex3fv(P031);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N032);
    glVertex3fv(P032);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N033);
    glVertex3fv(P033);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glEnd();
}

void Whale008(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N043);
    glVertex3fv(P043);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N042);
    glVertex3fv(P042);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N036);
    glVertex3fv(P036);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N041);
    glVertex3fv(P041);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N040);
    glVertex3fv(P040);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N037);
    glVertex3fv(P037);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N038);
    glVertex3fv(P038);
    glNormal3fv(N039);
    glVertex3fv(P039);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glEnd();
}

void Whale009(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N051);
    glVertex3fv(P051);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N044);
    glVertex3fv(P044);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N050);
    glVertex3fv(P050);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N049);
    glVertex3fv(P049);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N048);
    glVertex3fv(P048);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N045);
    glVertex3fv(P045);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N046);
    glVertex3fv(P046);
    glNormal3fv(N047);
    glVertex3fv(P047);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
}

void Whale010(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N080);
    glVertex3fv(P080);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N090);
    glVertex3fv(P090);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N080);
    glVertex3fv(P080);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N081);
    glVertex3fv(P081);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N085);
    glVertex3fv(P085);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N083);
    glVertex3fv(P083);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N087);
    glVertex3fv(P087);
    glNormal3fv(N077);
    glVertex3fv(P077);
    glNormal3fv(N090);
    glVertex3fv(P090);
    glEnd();
}

void Whale011(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N082);
    glVertex3fv(P082);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N088);
    glVertex3fv(P088);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N089);
    glVertex3fv(P089);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N086);
    glVertex3fv(P086);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N078);
    glVertex3fv(P078);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N084);
    glVertex3fv(P084);
    glNormal3fv(N082);
    glVertex3fv(P082);
    glNormal3fv(N079);
    glVertex3fv(P079);
    glEnd();
}

void Whale012(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N059);
    glVertex3fv(P059);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N058);
    glVertex3fv(P058);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N057);
    glVertex3fv(P057);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N056);
    glVertex3fv(P056);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N053);
    glVertex3fv(P053);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N052);
    glVertex3fv(P052);
    glEnd();
}

void Whale013(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N096);
    glVertex3fv(P096);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glNormal3fv(N096);
    glVertex3fv(P096);
    glNormal3fv(N098);
    glVertex3fv(P098);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N066);
    glVertex3fv(P066);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N067);
    glVertex3fv(P067);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N096);
    glVertex3fv(P096);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N060);
    glVertex3fv(P060);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N096);
    glVertex3fv(P096);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N096);
    glVertex3fv(P096);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glNormal3fv(N098);
    glVertex3fv(P098);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N065);
    glVertex3fv(P065);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N097);
    glVertex3fv(P097);
    glNormal3fv(N099);
    glVertex3fv(P099);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P005);
    glVertex3fv(P006);
    glVertex3fv(P099);
    glVertex3fv(P098);
    glEnd();
}

void Whale014(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N004);
    glVertex3fv(P004);
    glNormal3fv(N005);
    glVertex3fv(P005);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P006);
    glVertex3fv(P005);
    glVertex3fv(P004);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N006);
    glVertex3fv(P006);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N008);
    glVertex3fv(P008);
    glNormal3fv(N004);
    glVertex3fv(P004);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N004);
    glVertex3fv(P004);
    glEnd();
}

void Whale015(void)
{
    glBegin(GL_POLYGON);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N055);
    glVertex3fv(P055);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N003);
    glVertex3fv(P003);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N054);
    glVertex3fv(P054);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N063);
    glVertex3fv(P063);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glEnd();
    glBegin(GL_POLYGON);
    glNormal3fv(N100);
    glVertex3fv(P100);
    glNormal3fv(N002);
    glVertex3fv(P002);
    glNormal3fv(N062);
    glVertex3fv(P062);
    glEnd();
}

void Whale016(void)
{
    glBegin(GL_POLYGON);
    glVertex3fv(P104);
    glVertex3fv(P105);
    glVertex3fv(P106);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P107);
    glVertex3fv(P108);
    glVertex3fv(P109);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P110);
    glVertex3fv(P111);
    glVertex3fv(P112);
    glVertex3fv(P113);
    glVertex3fv(P114);
    glVertex3fv(P115);
    glEnd();
    glBegin(GL_POLYGON);
    glVertex3fv(P116);
    glVertex3fv(P117);
    glVertex3fv(P118);
    glVertex3fv(P119);
    glVertex3fv(P120);
    glVertex3fv(P121);
    glEnd();
}


void DrawWhale(fishRec *fish)
{
    float seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7;
    float pitch, thrash, chomp;

    fish->htail = (int)(fish->htail - (int)(5.0 * fish->v)) % 360;

    thrash = 70.0 * fish->v;

    seg0 = 1.5 * thrash * sin((fish->htail)*RRAD);
    seg1 = 2.5 * thrash * sin((fish->htail+10.0)*RRAD);
    seg2 = 3.7 * thrash * sin((fish->htail+15.0)*RRAD);
    seg3 = 4.8 * thrash * sin((fish->htail+23.0)*RRAD);
    seg4 = 6.0 * thrash * sin((fish->htail+28.0)*RRAD);
    seg5 = 6.5 * thrash * sin((fish->htail+35.0)*RRAD);
    seg6 = 6.5 * thrash * sin((fish->htail+40.0)*RRAD);
    seg7 = 6.5 * thrash * sin((fish->htail+55.0)*RRAD);

    pitch = fish->v * sin((fish->htail-160.0)*RRAD);

    chomp = 0.0;
    if (fish->v > 2.0) {
	chomp = -(fish->v - 2.0) * 200.0;
    }

    P012[1] = iP012[1] + seg5;
    P013[1] = iP013[1] + seg5;
    P014[1] = iP014[1] + seg5;
    P015[1] = iP015[1] + seg5;
    P016[1] = iP016[1] + seg5;
    P017[1] = iP017[1] + seg5;
    P018[1] = iP018[1] + seg5;
    P019[1] = iP019[1] + seg5;

    P020[1] = iP020[1] + seg4;
    P021[1] = iP021[1] + seg4;
    P022[1] = iP022[1] + seg4;
    P023[1] = iP023[1] + seg4;
    P024[1] = iP024[1] + seg4;
    P025[1] = iP025[1] + seg4;
    P026[1] = iP026[1] + seg4;
    P027[1] = iP027[1] + seg4;

    P028[1] = iP028[1] + seg2;
    P029[1] = iP029[1] + seg2;
    P030[1] = iP030[1] + seg2;
    P031[1] = iP031[1] + seg2;
    P032[1] = iP032[1] + seg2;
    P033[1] = iP033[1] + seg2;
    P034[1] = iP034[1] + seg2;
    P035[1] = iP035[1] + seg2;

    P036[1] = iP036[1] + seg1;
    P037[1] = iP037[1] + seg1;
    P038[1] = iP038[1] + seg1;
    P039[1] = iP039[1] + seg1;
    P040[1] = iP040[1] + seg1;
    P041[1] = iP041[1] + seg1;
    P042[1] = iP042[1] + seg1;
    P043[1] = iP043[1] + seg1;

    P044[1] = iP044[1] + seg0;
    P045[1] = iP045[1] + seg0;
    P046[1] = iP046[1] + seg0;
    P047[1] = iP047[1] + seg0;
    P048[1] = iP048[1] + seg0;
    P049[1] = iP049[1] + seg0;
    P050[1] = iP050[1] + seg0;
    P051[1] = iP051[1] + seg0;

    P009[1] = iP009[1] + seg6;
    P010[1] = iP010[1] + seg6;
    P075[1] = iP075[1] + seg6;
    P076[1] = iP076[1] + seg6;

    P001[1] = iP001[1] + seg7;
    P011[1] = iP011[1] + seg7;
    P068[1] = iP068[1] + seg7;
    P069[1] = iP069[1] + seg7;
    P070[1] = iP070[1] + seg7;
    P071[1] = iP071[1] + seg7;
    P072[1] = iP072[1] + seg7;
    P073[1] = iP073[1] + seg7;
    P074[1] = iP074[1] + seg7;

    P091[1] = iP091[1] + seg3 * 1.1;
    P092[1] = iP092[1] + seg3;
    P093[1] = iP093[1] + seg3;
    P094[1] = iP094[1] + seg3;
    P095[1] = iP095[1] + seg3 * 0.9;

    P099[1] = iP099[1] + chomp;
    P098[1] = iP098[1] + chomp;
    P064[1] = iP064[1] + chomp;
    P061[1] = iP061[1] + chomp;
    P097[1] = iP097[1] + chomp;
    P096[1] = iP096[1] + chomp;

    glPushMatrix();

    glRotatef(pitch, 1.0, 0.0, 0.0);

    glTranslatef(0.0, 0.0, 8000.0);

    glRotatef(180.0, 0.0, 1.0, 0.0);

    glScalef(3.0, 3.0, 3.0);

    glEnable(GL_CULL_FACE);

    Whale001();                                                 
    Whale002();                                                 
    Whale003();                                                 
    Whale004();                                                 
    Whale005();                                                 
    Whale006();                                                 
    Whale007();                                                 
    Whale008();                                                 
    Whale009();                                                 
    Whale010();                                                 
    Whale011();                                                 
    Whale012();                                                 
    Whale013();                                                 
    Whale014();                                                 
    Whale015();                                                 
    Whale016();                                                 

    glDisable(GL_CULL_FACE);

    glPopMatrix();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\insect.h ===
#define HALFTONE 1
#define PI 3.1415926536
	/*  resolution of movement  */
#define RES 30
	/*  stuff for making body  */
#define SIN30 (0.5)
#define COS30 (0.866025404)
#define SIN60 (0.866025404)
#define COS60 (0.5)
#define SIN15 (0.258819045)
#define COS15 (0.965925826)
#define COS45 (0.707106781)
#define SIN45 (0.707106781)
#define A2 0.088388348	/*  (1.0/ (8.0 * sqrt(2.0)))  */
#define R2 0.125	/*  (sqrt(2 * A2 * A2))  */
#define A1 0.411611652	/*  (0.5 - A2)  */
#define R1 0.420994836  /*  (sqrt(A1 * A1 + A2 * A2))  */
#define REACH 1.6

/* Eclipse 8 bit color stuff */
#define ECLIPSE8_GRID 2
#define ECLIPSE8_GRAY 1
#define ECLIPSE8_NCOLORS 10
#define ECLIPSE8_SKYBLUE 3

extern GLuint screen,viewit,shadow,body,hip[6],thigh[6],shin[6],kneeball[6];
extern GLuint body_shadow,hip_shadow,thigh_shadow,shin_shadow,kneeball_shadow;


extern GLfloat degrees (float a);
extern float dot (float vec1[3], float vec2[3]);
extern float integer (float x);
extern float frac (float x);
extern float fabso (float x);
extern void getpolycolor (int p, float pts[][3]);
extern void getlightvector (void);

extern void createobjects (void);

extern float phi,theta;
extern float cx,cy,cz;

extern GLfloat ctheta,cphi;

extern GLfloat b1[4][3];
extern GLfloat b2[4][3];
extern GLfloat b3[4][3];
extern GLfloat b4[4][3];
extern GLfloat b5[4][3];
extern GLfloat b6[4][3];
extern GLfloat h1[4][3];
extern GLfloat h2[4][3];
extern GLfloat h3[3][3];
extern GLfloat t1[4][3];
extern GLfloat t2[3][3];
extern GLfloat t3[3][3];
extern GLfloat t4[3][3];
extern GLfloat t5[3][3];
extern GLfloat t6[3][3];
extern GLfloat t7[3][3];
extern GLfloat t8[4][3];
extern GLfloat s1[4][3];
extern GLfloat s2[4][3];
extern GLfloat s3[4][3];
extern GLfloat s4[4][3];
extern GLfloat s5[4][3];
extern GLfloat k1[4][3];

extern void doViewit (void);
extern void rotate60 (char c, int n, GLfloat a[][3]);
extern void gl_IdentifyMatrix (GLfloat mat[16]);
extern GLboolean lit (int p, float pts[][3]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\unitdisk.cxx ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
extern "C" {
#include <windows.h>
#include <GL/glu.h>
}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include "Unitdisk.hxx"

const float fudge = .000001;
const float M_2PI = 2.0 * M_PI;

Unitdisk::Unitdisk()
{
  rdivisions = 3;
  tdivisions = 10;
  points = normals = NULL;
  colors = NULL;
  points_size = normals_size = colors_size = 0;
  angle = M_PI;
  zaxis[0] = 0;
  zaxis[1] = 0;
  zaxis[2] = 1;

  still_in_xy = 1;

  sintable = costable = NULL;
}


Unitdisk::~Unitdisk()
{
}

void Unitdisk::draw()
{
  if (points == NULL) return;
  glNormal3f(0, 0, 1);
  if (colors == NULL) draw_nocolors();
  else if (normals == NULL) draw_colors_nonormals();
  else draw_colors_normals();
}

void Unitdisk::draw_nocolors()
{
  int r, t, p1, p2;
  int has_n;

  has_n = (normals != NULL);

  for (t = 1; t < tdivisions; t++) {
    glBegin(GL_QUAD_STRIP);
    p1 = t * (rdivisions + 1);
    p2 = (t - 1) * (rdivisions + 1);
    for (r = 0; r <= rdivisions; r++, p1++, p2++) {
      if (has_n) glNormal3fv(normals[p1].pt);
#ifdef TEXTURE
      glTexCoord2fv(points[p1].pt);
#endif
      glVertex3fv(points[p1].pt);
      if (has_n) glNormal3fv(normals[p2].pt);
#ifdef TEXTURE
      glTexCoord2fv(points[p2].pt);
#endif
      glVertex3fv(points[p2].pt);
    } 
    glEnd(); 
  }
  
  glBegin(GL_QUAD_STRIP); 
  p1 = 0;
  p2 = (rdivisions + 1) * (tdivisions - 1);
  for (r = 0; r <= rdivisions; r++, p1++, p2++) {
    if (has_n) glNormal3fv(normals[p1].pt);
#ifdef TEXTURE
    glTexCoord2fv(points[p1].pt);
#endif
    glVertex3fv(points[p1].pt);
    if (has_n) glNormal3fv(normals[p2].pt);
#ifdef TEXTURE
    glTexCoord2fv(points[p2].pt);
#endif
    glVertex3fv(points[p2].pt);
  }
  glEnd();
}

void Unitdisk::draw_colors_nonormals()
{  
  int r, t, p1, p2;

  for (t = 1; t < tdivisions; t++) {
    glBegin(GL_QUAD_STRIP);
    p1 = t * (rdivisions + 1);
    p2 = (t - 1) * (rdivisions + 1);
    for (r = 0; r <= rdivisions; r++, p1++, p2++) {
      glColor4fv(colors[p1].c);
#ifdef TEXTURE
      glTexCoord2fv(points[p1].pt);
#endif
      glVertex3fv(points[p1].pt);
      glColor4fv(colors[p2].c);
#ifdef TEXTURE
      glTexCoord2fv(points[p2].pt);
#endif
      glVertex3fv(points[p2].pt);
    } 
    glEnd(); 
  }
  
  glBegin(GL_QUAD_STRIP); 
  p1 = 0;
  p2 = (rdivisions + 1) * (tdivisions - 1);
  for (r = 0; r <= rdivisions; r++, p1++, p2++) {
    glColor4fv(colors[p1].c);
#ifdef TEXTURE
    glTexCoord2fv(points[p1].pt);
#endif
    glVertex3fv(points[p1].pt);
    glColor4fv(colors[p2].c);
#ifdef TEXTURE
    glTexCoord2fv(points[p2].pt);
#endif
    glVertex3fv(points[p2].pt);
  }
  glEnd();
}

void Unitdisk::draw_colors_normals()
{
  int r, t, p1, p2;

  for (t = 1; t < tdivisions; t++) {
    glBegin(GL_QUAD_STRIP);
    p1 = t * (rdivisions + 1);
    p2 = (t - 1) * (rdivisions + 1);
    for (r = 0; r <= rdivisions; r++, p1++, p2++) {
      glColor4fv(colors[p1].c);
      glNormal3fv(normals[p1].pt);
#ifdef TEXTURE
      glTexCoord2fv(points[p1].pt);
#endif
      glVertex3fv(points[p1].pt);
      glColor4fv(colors[p2].c);
      glNormal3fv(normals[p2].pt);
#ifdef TEXTURE
      glTexCoord2fv(points[p2].pt);
#endif
      glVertex3fv(points[p2].pt);
    } 
    glEnd(); 
  }
  
  glBegin(GL_QUAD_STRIP); 
  p1 = 0;
  p2 = (rdivisions + 1) * (tdivisions - 1);
  for (r = 0; r <= rdivisions; r++, p1++, p2++) {
    glColor4fv(colors[p1].c);
    glNormal3fv(normals[p1].pt);
#ifdef TEXTURE
    glTexCoord2fv(points[p1].pt);
#endif
    glVertex3fv(points[p1].pt);
    glColor4fv(colors[p2].c);
    glNormal3fv(normals[p2].pt);
#ifdef TEXTURE
    glTexCoord2fv(points[p2].pt);
#endif
    glVertex3fv(points[p2].pt);
  }
  glEnd();
}

void Unitdisk::draw_by_perimeter(int pass_colors, int pass_norms, 
				 int pass_tex)
{
  int i, index, r = rdivisions + 1;

  if (points == NULL) return;
  if (pass_colors && colors == NULL) {
    fprintf(stderr, "Warning:  No colors to draw in Unitdisk.c++");
    pass_colors = 0;
  }
  if (pass_norms && normals == NULL) {
    fprintf(stderr, "Warning:  No normals to draw in Unitdisk.c++");
    pass_norms = 0;
  }
  glBegin(GL_POLYGON);
  for (i = 0, index = rdivisions; i < tdivisions; i++, index += r) {
    if (pass_colors) glColor4fv(colors[index].c);
    if (pass_norms) glNormal3fv(normals[index].pt);
#ifdef TEXTURE
    if (pass_tex) glTexCoord2fv(points[index].pt);
#endif
    glVertex3fv(points[index].pt);
  }
  glEnd();
  
}

void Unitdisk::set_angle(float new_angle)
{
  angle = new_angle;
}

GLfloat Unitdisk::get_angle()
{
  return angle;
}

GLfloat Unitdisk::get_radius()
{
  return (GLfloat)cos((double)((M_PI - angle) / 2.0));
}

void Unitdisk::set_divisions(int new_rdivisions, int new_tdivisions)
{
  if (tdivisions != new_tdivisions) {
    delete sintable;
    delete costable;
    sintable = costable = NULL;
  }
  if (tdivisions != new_tdivisions || rdivisions != new_rdivisions) {
    rdivisions = new_rdivisions;
    tdivisions = new_tdivisions;
    free_points();
    free_normals();
    free_colors();
  }
}
  
int Unitdisk::get_rdivisions()
{
  return rdivisions;
}

int Unitdisk::get_tdivisions()
{
  return tdivisions;
}

void Unitdisk::alloc_points()
{
  int npoints = get_npoints();
  if (npoints > points_size) {
    delete points;
    points = new Point[npoints];
    points_size = npoints;
  }
}

void Unitdisk::alloc_normals()
{
  int npoints = get_npoints();
  if (npoints > normals_size) {
    delete normals;
    normals = new Point[npoints];
    normals_size = npoints;
  }
}

void Unitdisk::alloc_points_normals()
{
  alloc_points();
  alloc_normals();
}

void Unitdisk::free_points() 
{
  delete points;
  points = NULL;
  points_size = 0;
}

void Unitdisk::free_normals()
{
  delete normals;
  normals = NULL;
  normals_size = 0;
}

void Unitdisk::free_points_normals()
{
  free_points();
  free_normals();
}

void Unitdisk::fill_points()
{
  alloc_points();
  fill_either(points);
}

void Unitdisk::fill_normals()
{
  alloc_normals();
  fill_either(normals);
}

void Unitdisk::fill_points_normals()
{
  alloc_points();
  alloc_normals();
  fill_either(points);
  fill_either(normals);
}

void Unitdisk::copy_points(Unitdisk src) 
{
  set_divisions(src.rdivisions, src.tdivisions);
  alloc_points();
  copy_either(points, src.points);
}

void Unitdisk::copy_normals(Unitdisk src) 
{
  set_divisions(src.rdivisions, src.tdivisions);
  alloc_normals();
  copy_either(normals, src.normals);
}

void Unitdisk::copy_either(Point *dpt, Point *spt) {
  int i, npoints;
  npoints = get_npoints();
  for (i = 0; i < npoints; i++, dpt++, spt++) {
    dpt->pt[0] = spt->pt[0];
    dpt->pt[1] = spt->pt[1];
    dpt->pt[2] = spt->pt[2];
  }
}  

void Unitdisk::copy_normals_from_points(Unitdisk src) {
  set_divisions(src.rdivisions, src.tdivisions);
  alloc_normals();
  copy_either(normals, src.points);
}

void Unitdisk::copy_normals_from_points() {
  copy_normals_from_points(*this);
}

void Unitdisk::fill_either(Point *what) {
  int t, r;
  int i;

  fill_either_strip1(what);
  if (sintable == NULL) fill_trig_tables();
  i = rdivisions + 1;
  for (t = 1; t < tdivisions; t++) {
    for (r = 0; r <= rdivisions; r++) {
      what[i].pt[0] = costable[t] * what[r].pt[0];
      what[i].pt[1] = sintable[t] * what[r].pt[0];
      what[i].pt[2] = what[r].pt[2];
      i++;
    }
  }
}

void Unitdisk::fill_points_strip1()
{
  alloc_points();
  fill_either_strip1(points);
}

void Unitdisk::fill_either_strip1(Point *what) {
  float radius, rinc;
  int r;

  rinc = get_radius() / (float)rdivisions;
  radius = 0.0;
  for (r = 0; r <= rdivisions; r++, radius += rinc) {
    what[r].pt[0] = radius;
    what[r].pt[1] = 0;
    // Round-off error avoidance hack
    what[r].pt[2] = (GLfloat)(1.0 - what[r].pt[0]*what[r].pt[0]);
    if (what[r].pt[2] > 0.0) what[r].pt[2] = (GLfloat)sqrt((double)what[r].pt[2]);
    else what[r].pt[2] = 0.0;
  }
}

void Unitdisk::translate(Point trans)
{
  int i, npoints;
  npoints = get_npoints();
  for (i = 0; i < npoints; i++) {
    points[i].pt[0] += trans.pt[0];
    points[i].pt[1] += trans.pt[1];
    points[i].pt[2] += trans.pt[2];
  }
}

void Unitdisk::scale(float s) 
{
  int i, npoints;
  npoints = get_npoints();
  for (i = 0; i < npoints; i++) {
    points[i].pt[0] *= s;
    points[i].pt[1] *= s;
    points[i].pt[2] *= s;
  }
}

void Unitdisk::scale_translate(float s, Point trans) 
{
  int i, npoints;
  npoints = get_npoints();
  for (i = 0; i < npoints; i++) {
    points[i].pt[0] = points[i].pt[0]*s + trans.pt[0];
    points[i].pt[1] = points[i].pt[1]*s + trans.pt[1];
    points[i].pt[2] = points[i].pt[2]*s + trans.pt[2];
  }
}

int Unitdisk::get_npoints() 
{
  return (rdivisions + 1) * tdivisions;
}

void Unitdisk::project()
{
  int i, npoints;

  if (normals == NULL) {
    fprintf(stderr, "Warning:  No normals defined when project() called.\n");
    fill_normals();
  }
  if (points == NULL) fill_points();
  npoints = get_npoints();
  for (i = 0; i < npoints; i++) {
    /* I'm not sure quite what the justification for this is, but it
     * seems to work */
    if (normals[i].pt[2] < 0.0) normals[i].pt[2] = -normals[i].pt[2];
    points[i] = points[i].project_direction(normals[i]);
  }
}

void Unitdisk::project(Point projpt)
{
  int i, npoints = get_npoints();
  float x, y, z;
  Point *pt;

  if (points == NULL) fill_points();
  x = projpt.pt[0];
  y = projpt.pt[1];
  z = projpt.pt[2];
  pt = points;
  for (i = 0; i < npoints; i++, pt++) pt->project_self(x, y, z);
}

void Unitdisk::project_borrow_points(Unitdisk src) 
{
  int i, npoints = get_npoints();
  Point *pt, *spt, *sn;
  spt = src.points;
  sn = normals;
  alloc_points();
  pt = points;
  for (i = 0; i < npoints; i++, pt++, spt++, sn++) {
    /* I'm not sure quite what the justification for this is, but it
     * seems to work */
    if (normals[i].pt[2] < 0.0) normals[i].pt[2] = -normals[i].pt[2];
    pt->compute_projected(spt->pt[0], spt->pt[1], spt->pt[2], 
			  sn->pt[0], sn->pt[1], sn->pt[2]);
  }
}

void Unitdisk::refract_normals(Point light, GLfloat I)
{
  Point dlight;
  float cos1, sin1, cos2, sin2;
  int use_normals;
  int r, t, i;

  if (points == NULL) {
    fprintf(stderr, "Attempting to refract without points.\n");
    fill_normals();
  }

  use_normals = (normals != NULL);
  alloc_normals();

  /* Do the theta = 0 diagonal */
  for (r = 0; r <= rdivisions; r++) {
    /* Find the original normal - use the unit of the points if there are
     * no normals */
    if (!use_normals) normals[r] = points[r].unit();

    /* Compute the direction to the light */
    dlight = (light - points[r]).unit();

    /* Compute the cosine and the sine of the original angle */
    cos1 = dlight.dot(normals[r]);
    sin1 = (float)(1.0 - cos1*cos1);
    if (sin1 <= 0.0) continue;
    sin1 = (float)sqrt((double)sin1);

    /* Compute the cosine and the sine of the new angle */
    sin2 = sin1 / I;
    cos2 = (float)sqrt((double)(1.0 - sin2*sin2));

    /* Rotate the normal by the new sine and cosine */
    normals[r] = normals[r].rotate_abouty(cos2, -sin2);
  }

  /* Copy the rest of the rows from the current row */
  i = rdivisions + 1;
  if (sintable == NULL) fill_trig_tables();
  for (t = 1; t < tdivisions; t++) {
    for (r = 0; r <= rdivisions; r++) {
      normals[i].pt[0] = costable[t] * normals[r].pt[0];
      normals[i].pt[1] = sintable[t] * normals[r].pt[0];
      normals[i].pt[2] = normals[r].pt[2];
      i++;
    }
  }

}

void Unitdisk::face_direction(Point d)
{
  face_direction(d, *this);
}

void Unitdisk::face_direction(Point d, Unitdisk src) 
{
  Point *spt, *dpt, *sn, *dn;
  float sin1, cos1;
  float x;
  int npoints, i;

  if (d.pt[1]) {
    fprintf(stderr, 
	    "Internal error:  Can't face in direction not in xz plane.");
    return;
  }

  cos1 = d.pt[2];
  sin1 = d.pt[0];
  
  if (sin1 * sin1 > fudge) {
    spt = src.points;
    dpt = points;
    sn = src.normals;
    dn = normals;
    /* Change this to be seperate loops for points&&normals, points, normals
     * (faster than testing every iteration */
    npoints = get_npoints();
    for (i = 0; i < npoints; i++) {
      if (points != NULL) {
	x = spt->pt[0];
	dpt->pt[0] = x*cos1 + spt->pt[2]*sin1;
	dpt->pt[1] = spt->pt[1];
	dpt->pt[2] = -x*sin1 + spt->pt[2]*cos1;
	spt++; dpt++;
      }
      if (normals != NULL) {
	x = sn->pt[0];
	dn->pt[0] = x*cos1 + sn->pt[2]*sin1;
	dn->pt[1] = sn->pt[1];
	dn->pt[2] = -x*sin1 + sn->pt[2]*cos1;
	sn++; dn++;
      }
    }
  } else if (points != NULL && points != src.points) {
    copy_points(src);
    if (normals != NULL) copy_normals(src);
  }
}  

void Unitdisk::alloc_colors()
{
  int ncolors = get_npoints();
  if (ncolors > colors_size) {
    delete colors;
    colors = new Color[ncolors];
    colors_size = ncolors;
  }
}

void Unitdisk::map_normals_to_colors() 
{
  int t, r;
  int i;

  if (normals == NULL) fill_normals();
  alloc_colors();
  i = 0;
  for (t = 1; t <= tdivisions; t++) {
    for (r = 0; r <= rdivisions; r++) {
      colors[i] *= normals[r].pt[2];
      colors[i].c[3] = 1;
      i++;
    }
  }
}

void Unitdisk::map_z_to_colors()
{
  int i, npoints = get_npoints();

  if (points == NULL) {
    fprintf(stderr, "Warning:  no points defined in map_z_to_colors()\n");
    fill_points();
  }

  alloc_colors();
  for (i = 0; i < npoints; i++) {
    colors[i] = points[i].pt[2];
    colors[i].c[3] = 1;
  }
}

void Unitdisk::scale_alpha_by_z()
{
  int i, npoints = get_npoints();
  
  if (colors == NULL) alloc_colors();
  if (points == NULL) {
    alloc_points();
    fill_points();
  }
  for (i = 0; i < npoints; i++) colors[i].c[3] *= points[i].pt[2];
}

void Unitdisk::scale_colors_by_z() 
{
  int i, npoints = get_npoints();

  if (colors == NULL) alloc_colors();
  if (points == NULL) {
    alloc_points();
    fill_points();
  }
  for (i = 0; i < npoints; i++) colors[i] *= points[i].pt[2];
}

void Unitdisk::scale_colors_by_normals(Point light)
{
  scale_colors_by_normals(light, *this);
}

void Unitdisk::scale_colors_by_normals(Point light, Unitdisk src_normals)
{
  scale_colors_by_either(light, src_normals.normals);
}

void Unitdisk::scale_colors_by_points(Point light, Unitdisk src_points)
{
  scale_colors_by_either(light, src_points.points);
}

void Unitdisk::scale_colors_by_either(Point light, Point *what)
{
  int t, r;
  int i;
  if (what == NULL) {
    fprintf(stderr, "Scaling colors to NULL pointer.\n");
    return;
  }
  if (light.pt[0] || light.pt[1] || light.pt[2] < 0.0) {
    fprintf(stderr, "Light not on z axis in scale_colors_by_normals.\n");
  }

  alloc_colors();
  for (r = 0; r <= rdivisions; r++) 
    colors[r] *= what[r].dot(light);
  i = rdivisions + 1;
  for (t = 1; t < tdivisions; t++) {
    for (r = 0; r <= rdivisions; r++) {
      colors[i] = colors[r];
      i++;
    }
  }
}  

void Unitdisk::set_colors(Color c)
{
  Color *dst;
  int i, npoints = get_npoints();
  alloc_colors();
  dst = colors;
  for (i = 0; i < npoints; i++, dst++) {
    dst->c[0] = c.c[0];
    dst->c[1] = c.c[1];
    dst->c[2] = c.c[2];
    dst->c[3] = c.c[3];
  }
}

void Unitdisk::add_colors(Color c)
{
  int i, npoints = get_npoints();
  alloc_colors();
  for (i = 0; i < npoints; i++) colors[i] += c;
}

void Unitdisk::free_colors()
{
  delete colors;
  colors = NULL;
  colors_size = 0;
}

inline float Unitdisk::area_triangle(Point a, Point b, Point c)
{
  return (float)(((a.pt[0]*b.pt[1] + b.pt[0]*c.pt[1] + c.pt[0]*a.pt[1]) -
	   (a.pt[1]*b.pt[0] + b.pt[1]*c.pt[0] + c.pt[1]*a.pt[0])) * .5);
}

inline float Unitdisk::area_triangle(GLfloat *a, GLfloat *b, 
				     GLfloat *c) 
{
  return (float)(((a[0]*b[1] + b[0]*c[1] + c[0]*a[1]) -
	   (a[1]*b[0] + b[1]*c[0] + c[1]*a[0])) * .5);
}

inline float Unitdisk::area_2triangle(GLfloat *a, GLfloat *b, 
				     GLfloat *c) 
{
  return ((a[0]*b[1] + b[0]*c[1] + c[0]*a[1]) -
	  (a[1]*b[0] + b[1]*c[0] + c[1]*a[0]));
}

void Unitdisk::scale_colors_by_darea(Unitdisk disk) 
{
  int pt1, pt2, pt3;
  int t, r, i;
  int npoints = get_npoints();
  float *rproducts1, *tproducts1, *rproducts2, *tproducts2;
  float area1, area2;

  rproducts1 = new float[npoints];
  tproducts1 = new float[npoints];
  rproducts2 = new float[npoints];
  tproducts2 = new float[npoints];

  /* Compute the products of the segments which make up the disk - 
   * these will later be used in the area calculations */
  i = 0;
  for (t = 0; t < tdivisions; t++) {
    for (r = 0; r < rdivisions; r++) {
      pt1 = i;
      pt2 = i + 1;
      rproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] -
		       points[pt1].pt[1]*points[pt2].pt[0]);
      rproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] - 
		       disk.points[pt1].pt[1]*disk.points[pt2].pt[0]);
      pt2 = ((t+1)%tdivisions)*(rdivisions + 1) + r;
      tproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] -
		       points[pt1].pt[1]*points[pt2].pt[0]);
      tproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] - 
		       disk.points[pt1].pt[1]*disk.points[pt2].pt[0]);
      i++;
    }
    pt1 = i;
    pt2 = ((t+1)%tdivisions)*(rdivisions + 1) + r;
    tproducts1[i] = (points[pt1].pt[0]*points[pt2].pt[1] -
		     points[pt1].pt[1]*points[pt2].pt[0]);
    tproducts2[i] = (disk.points[pt1].pt[0]*disk.points[pt2].pt[1] - 
		     disk.points[pt1].pt[1]*disk.points[pt2].pt[0]);
    i++;
  }

  /* Compute the area at the center of the disk */
  area1 = area2 = 0.0;
  r = 1;
  for (t = 0; t <= tdivisions; t++) {
    pt1 = (t%tdivisions)*(rdivisions+1) + r;
    area1 += tproducts1[pt1];
    area2 += tproducts2[pt1];
  }
  if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1));
  for (t = 0; t < tdivisions; t++) {
    colors[t*(rdivisions+1)] *= area1;
  }

  for (t = 0; t < tdivisions; t++) {
    for (r = 1; r < rdivisions; r++) {
      pt1 = (t ? t-1 : tdivisions-1)*(rdivisions+1) + r - 1;
      pt3 = t*(rdivisions + 1) + r - 1;
      pt2 = ((t+1) % tdivisions)*(rdivisions+1) + r - 1;
      area1 = rproducts1[pt1] + rproducts1[pt1 + 1];
      area1 += tproducts1[pt1 + 2] + tproducts1[pt3 + 2];
      area1 -= rproducts1[pt2 + 1] + rproducts1[pt2];
      area1 -= tproducts1[pt3] + tproducts1[pt1];
      area2 = rproducts2[pt1] + rproducts2[pt1 + 1];
      area2 += tproducts2[pt1 + 2] + tproducts2[pt3 + 2];
      area2 -= rproducts2[pt2 + 1] + rproducts2[pt2];
      area2 -= tproducts2[pt3] + tproducts2[pt1];
      if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1));
      colors[pt3 + 1] *= area1;
    }
  }

  /* Compute the area around the outside of the disk */
  r = rdivisions;
  for (t = 0; t < tdivisions; t++) {
    pt1 = (t ? t-1 : tdivisions-1)*(rdivisions+1) + r - 1;
    pt3 = t*(rdivisions + 1) + r - 1;
    pt2 = ((t+1) % tdivisions)*(rdivisions+1) + r - 1;
    area1 = rproducts1[pt1];
    area1 += tproducts1[pt1 + 1] + tproducts1[pt3 + 1];
    area1 -= rproducts1[pt2];
    area1 -= tproducts1[pt1] + tproducts1[pt3];
    area2 = rproducts2[pt1];
    area2 += tproducts2[pt1 + 1] + tproducts2[pt3 + 1];
    area2 -= rproducts2[pt2];
    area2 -= tproducts2[pt1] + tproducts2[pt3];
    if (area1 != 0.0) area1 = (float)fabs((double)(area2 / area1));
    colors[pt3 + 1] *= area1;
  }


  delete rproducts1;
  delete tproducts1;
  delete rproducts2;
  delete tproducts2;
}

void Unitdisk::fill_trig_tables()
{
  int t;

  delete sintable;
  delete costable;
  sintable = new float[tdivisions];
  costable = new float[tdivisions];
  for (t = 0; t < tdivisions; t++) {
    costable[t] = (float)cos((double)(M_2PI * (float)t / (float)tdivisions));
    sintable[t] = (float)sin((double)(M_2PI * (float)t / (float)tdivisions));
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\backtrac\scene.cxx ===
extern "C" {
#include <windows.h>
#include <GL/glaux.h>
#include <GL/glu.h>
#include <GL/gl.h>
}

#ifdef GLX_MOTIF
#include <GL/glx.h>
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>

#include "Unitdisk.hxx"
#include "scene.hxx"

const GLfloat I[16] = {
                        1, 0, 0, 0,
                        0, 1, 0, 0,
                        0, 0, 1, 0,
                        0, 0, 0, 1
                      };

Color white;
Color black;

const double M_2PI      = 2.0 * M_PI;
const float scene_fudge = .000001;


// Lights are native to the xz plane and are rotated into position -
// shadows and refraction will not have to be changed if lights are
// just rotating about the z axis

light lights[] = {
                  {{1, 0, 0, 1}, {0, 0, 0, 0}, {1, 0, 0, 0},
                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1},
                        "Red", 1},
                  {{0, 1, 0, 1}, {0, 0, 0, 0}, {0, 1, 0, 0},
                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1},
                        "Green", 1},
                  {{0, 0, 1, 1}, {0, 0, 0, 0}, {0, 0, 1, 0},
                     {1, 0, 0, 0,  0, 1, 0, 0,   0, 0, 1, 0,   0, 0, 0, 1},
                        "Blue", 1}
                 };

GLfloat light_init_position[nlights][4] = {
                                           {1.5, 0, 2.5, 1},
                                           {1, 0, 3, 1},
                                           {2, 0, 3, 1}
                                          };

GLfloat light_init_rotation[nlights] = {135, 0, 90};
GLfloat light_rotation[nlights];

Color world_ambient(.25, .25, .25);

GLfloat index = indices[def_refraction_index].index;

GLfloat square_ambient[4]  = {.25, .25, .25, 1};
GLfloat square_diffuse[4]  = {1, 1, 1, 1};
GLfloat square_specular[4] = {0, 0, 0, 1};

const GLfloat fov          = 45.0;
GLfloat aspect             = 1.0;
GLfloat eyep[3]            = {-6, 0, 6};
GLfloat lookp[3]           = {0, 0, 1};


#ifdef GLX_MOTIF
static GLXContext glx_context;
#endif

const int max_args = 20;

static int list_square;
static int lists_shadows;
static int lists_refraction;
static int lists_lights    = 5;
static int list_sphere     = 4;
static int list_spheredisk = 9;
static int list_lights_on  = 6;
static int list_lights_off = 7;
static int list_light_draw = 8;

int draw_square     = 1;
int draw_shadows    = 1;
int draw_refraction = 1;
int draw_sphere     = 1;
int draw_lights     = 1;
int draw_texture    = 0;

int possible_divisions[] = {10, 20, 30, 40};

// Sphere is stored as floats - more efficient
GLfloat *spherepts = NULL;
int nspherepts     = 0;
int spherediv      = 0;
Point sphere_position = {0, 0, 1, 1};
GLfloat sphere_size   = .5;
const GLfloat sphere_ambient[4]  = {0, 0, 0, 0};
const GLfloat sphere_specular[4] = {0, 0, 0, 0};
Unitdisk sphere_disk;
static void sphere_build();
static void sphere_list_init();
static void sphere_draw();

static void square_list_init();

static void lights_init_onoff();
static void lights_init_position();
static void lights_init_position(int i);
static void lights_list_init();
static void lights_list_init(int n);

static void light_draw_list_init();

Unitdisk disks[nlights];
int diskdiv = possible_divisions[def_divisions_index];
static void disk_build();
static void disk_build(int disk);


Unitdisk shadows[nlights];
static void shadow_list_init();
static void shadow_list_init(int n);
static void shadow_draw(int n);

Unitdisk refraction[nlights];
static void refraction_list_init();
static void refraction_list_init(int n);

static void shadow_refraction_full_build();
static void shadow_refraction_full_build(int n);

void scene_init();



#ifdef MYDEBUG
void lists_init();
void lights_init();
int  lights_move(int light, float dr, float dphi, float dtheta,
		       int update);

void lights_move_update(int light, int dr, int dphi, int dtheta);
#else
static void lists_init();
static void lights_init();
static int lights_move(int light, float dr, float dphi, float dtheta,
		       int update);
static void lights_move_update(int light, int dr, int dphi, int dtheta);
#endif


void scene_draw();

void texture_init();
AUX_RGBImageRec *teximage = NULL;

inline float sign(float a)
{
  // This is badly written so let's not call it too often, 'k?
  return (a > 0) ? (float)1 : (a < 0) ? (float) -1 : (float) 0;
}

inline double degrees(double a)
{
  return (a * 180.0 / M_PI);
}

inline double radians(double a)
{
  return (a * M_PI / 180.0);
}

inline double degrees_clamp(double a)
{
  while (a < 0.0) a += 360.0;
  while (a > 360.0) a -= 360.0;
  return a;
}

inline double radians_clamp(double a)
{
  while (a < 0.0) a += M_2PI;
  while (a > M_2PI) a -= M_2PI;
  return a;
}

void scene_init()
{
  int i;

  white.c[0] = white.c[1] = white.c[2] = white.c[3] = 1;
  black.c[0] = black.c[1] = black.c[2] = 0;
  black.c[3] = 1;

  lists_init();


  for (i = 0; i < nlights; i++) {
    lights[i].pos = light_init_position[i];
    light_rotation[i] = light_init_rotation[i];
    lights_init_position(i);
  }

  divisions_change(possible_divisions[def_divisions_index]);

  lights_init_onoff();
  lights_init();
  lights_init_position();

  texture_init();

  glClearStencil(0);

  // This is for profiling
  // exit(0);
}

static void scene_project()
{
  glMatrixMode(GL_PROJECTION);
  gluPerspective(fov, aspect, 0.01, 20.0);
  gluLookAt(eyep[0], eyep[1], eyep[2], lookp[0], lookp[1], lookp[2],
            1, 0, 0);
}

static void scene_rasterize()
{
  int i;

  glLoadName(name_square);
  if (draw_square) {
    if (draw_texture) glEnable(GL_TEXTURE_2D);
    glCallList(list_square);
    glDisable(GL_TEXTURE_2D);
  }
  if (draw_shadows)
    for (i = 0; i < nlights; i++)
      if (lights[i].on) {
	glPushMatrix();
	glRotatef(-light_rotation[i], 0, 0, 1);
	glCallList(lists_shadows + i);
	glPopMatrix();
      }
  if (draw_refraction)
    for (i = 0; i < nlights; i++)
      if (lights[i].on) {
	glPushMatrix();
	glRotatef(-light_rotation[i], 0, 0, 1);
	glCallList(lists_refraction + i);
	glPopMatrix();
      }

  glLoadName(name_sphere);
  /* Drawing the sphere here makes the sphere visible through itself when we
   * do the refraction redraw hack -- for now, just don't draw it */
  //  if (draw_sphere) glCallList(list_sphere);

  for (i = 0; i < nlights; i++)
    if (draw_lights) glCallList(lists_lights + i);
}

/* This draws an image of the scene seen through the sphere */
static void scene_draw_refracted()
{
  int i;

  if (!draw_sphere) return;


  /* Draw an image of the sphere into the stencil plane  -
   * must do this every time in case the lights have moved in front
   * of it */
  glEnable(GL_STENCIL_TEST);
  glClearStencil(0);
  glClear(GL_STENCIL_BUFFER_BIT);
  glStencilFunc(GL_ALWAYS, 0x1, 0x1);
  glStencilOp(GL_REPLACE, GL_KEEP, GL_REPLACE);

  glColorMask(0, 0, 0, 0);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  scene_project();

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  glCallList(list_sphere);
  glDisable(GL_CULL_FACE);
  glDisable(GL_DEPTH_TEST);

  glColorMask(1, 1, 1, 1);


  /* Set up a transform with a wider field of view  - this is inaccurate
   * but I don't have time to do it right */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(fov * index, aspect, 0.01, 20.0);
  gluLookAt(eyep[0], eyep[1], eyep[2], lookp[0], lookp[1], lookp[2],
            1, 0, 0);
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();


  /* Set up the stencil stuff which will be used to draw the image */
  glStencilFunc(GL_NOTEQUAL, 0x0, 0xffffffff);
  glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);


  /* Draw the image, gambling that we'll never see anything but the
   * floor through the table */
  glLoadName(name_sphere);
  if (draw_texture) glEnable(GL_TEXTURE_2D);
  if (draw_square) glCallList(list_square);
  if (draw_shadows)
    for (i = 0; i < nlights; i++)
      if (lights[i].on) {
	glPushMatrix();
	glRotatef(-light_rotation[i], 0, 0, 1);
	glCallList(lists_shadows + i);
	glPopMatrix();
      }
  if (draw_refraction)
    for (i = 0; i < nlights; i++)
      if (lights[i].on) {
	glPushMatrix();
	glRotatef(-light_rotation[i], 0, 0, 1);
	glCallList(lists_refraction + i);
	glPopMatrix();
      }
  glDisable(GL_TEXTURE_2D);


  /* Draw the sphere to make it look like it
   * has some substance */
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  scene_project();
  glCallList(list_spheredisk);

  glDisable(GL_STENCIL_TEST);
}


void scene_draw()
{
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  scene_project();

  /* Should draw an image of the square into the stencil buffer
   * to make sure that refractions which are not on the square do not get
   * drawn, but it can wait. */

  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  scene_rasterize();

  scene_draw_refracted();

}

const int pick_maxz = 0xffffffff;

int scene_pick(GLdouble x, GLdouble y)
{
  GLuint buffer[128];
  GLint vp[4], nhits, nnames;
  GLuint minz, hit = name_background;
  GLint i, j;

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  glGetIntegerv(GL_VIEWPORT, vp);

  glSelectBuffer(128, buffer);
  glRenderMode(GL_SELECT);

  // Where is this supposed to go, anyway?
  gluPickMatrix(x, vp[3] - y, 1, 1, vp);

  scene_project();

  glMatrixMode(GL_MODELVIEW);

  glInitNames();
  glPushName(name_background);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  scene_rasterize();
  glFlush();
  nhits = glRenderMode(GL_RENDER);

  minz = pick_maxz;
  for (i = j = 0; j < nhits; j++) {
    nnames = buffer[i];
    i++;
    if (buffer[i] < minz) {
      minz = buffer[i];
      hit = buffer[i + 1 + nnames];
    }
    i++;
    i += nnames + 1;
  }
  if (minz == pick_maxz) return name_background;
  else return hit;
}

void scene_reset_lights()
{
  int i;
  for (i = 0; i < nlights; i++) {
    lights[i].pos = light_init_position[i];
    light_rotation[i] = light_init_rotation[i];
  }
  lights_init_position();
  lights_list_init();
}

static void square_list_init()
{
  GLfloat x, y, inc;
  int i, j;
  glNewList(list_square, GL_COMPILE);
  glLoadName(name_square);
  glNormal3f(0, 0, 1);
  glEnable(GL_LIGHTING);
  glCallList(list_lights_on);
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, square_ambient);
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, square_diffuse);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, square_specular);
  inc = (GLfloat) (10.0 / diskdiv);
  glEnable(GL_CULL_FACE);

  for (i = 0, y = -5.0; i < diskdiv; i++, y += inc) {
    glBegin(GL_TRIANGLE_STRIP);
    for (j = 0, x = -5.0; j <= diskdiv; j++, x += inc) {
      glTexCoord2f(x, y + inc);
      glVertex2f(x, y + inc);
      glTexCoord2f(x, y);
      glVertex2f(x, y);
    }
    glEnd();
  }

  glDisable(GL_CULL_FACE);
  glCallList(list_lights_off);
  glDisable(GL_LIGHTING);
  glEndList();
}

static void spheredisk_list_init()
{
  glNewList(list_spheredisk, GL_COMPILE);
  glEnable(GL_BLEND);
  glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);
  glEnable(GL_LIGHTING);
  glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
  glEnable(GL_COLOR_MATERIAL);
  glMaterialfv(GL_AMBIENT, GL_FRONT_AND_BACK, sphere_ambient);
  glMaterialfv(GL_SPECULAR, GL_FRONT_AND_BACK, sphere_specular);
  glCallList(list_lights_on);
  sphere_disk.draw();
  glCallList(list_lights_off);
  glDisable(GL_COLOR_MATERIAL);
  glDisable(GL_LIGHTING);
  glDisable(GL_BLEND);
  glEndList();
}

void lights_onoff(int light, int val)
{
  lights[light].on = val;
  lights_init_onoff();
  lights_list_init(light);
  square_list_init();
}

void refraction_change(GLfloat refraction)
{
  if (refraction == index) return;
  index = refraction;
  shadow_refraction_full_build();
  refraction_list_init();
}

void divisions_change(int divisions)
{
  Point eye, look;

  if (divisions != spherediv) {
    spherediv = divisions;

    light_draw_list_init();
    lights_list_init();

    sphere_disk.set_divisions(spherediv, spherediv);
    sphere_disk.fill_points();
    sphere_disk.set_colors(white);
    sphere_disk.scale_alpha_by_z();
    eye = eyep;
    look = lookp;
    sphere_disk.face_direction((eye - look).unit());
    sphere_disk.copy_normals_from_points();
    sphere_disk.scale_translate(sphere_size, sphere_position);
    sphere_build();
    sphere_list_init();

    diskdiv = divisions;
    disk_build();
    shadow_refraction_full_build();
    square_list_init();
    spheredisk_list_init();
    shadow_list_init();
    refraction_list_init();
  }
}

int scene_move(int name, float dr, float dphi, float dtheta, int update)
{
  switch(name) {
  case name_background:
    return 0;
  case name_square:
    return 0;
  case name_sphere:
    return 0;
  default:
    if (name < name_lights || name > name_lights + nlights) return 0;
    return lights_move(name - name_lights, dr, dphi, dtheta, update);
  }
}

void scene_move_update(int name, int dr, int dphi, int dtheta)
{
  switch(name) {
  case name_background:
    break;
  case name_square:
    break;
  case name_sphere:
    break;
  default:
    if (name < name_lights || name > name_lights + nlights) break;
    lights_move_update(name - name_lights, dr, dphi, dtheta);
    break;
  }
}

#ifdef MYDEBUG
void lights_init_onoff()
#else
static void lights_init_onoff()
#endif
{
  int i;

  glNewList(list_lights_on, GL_COMPILE);
  for (i = 0; i < nlights; i++)
    if (lights[i].on) glEnable(GL_LIGHT0 + i);
    else glDisable(GL_LIGHT0 + i);
  glEndList();

  glNewList(list_lights_off, GL_COMPILE);
  for (i = 0; i < nlights; i++) glDisable(GL_LIGHT0 + i);
  glEndList();
}


#ifdef MYDEBUG
void lights_init_position()
#else
static void lights_init_position()
#endif
{
  int i;

  for (i = 0; i < nlights; i++) lights_init_position(i);

}

static void lights_init_position(int i)
{
  Point l, d;

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  l = lights[i].pos;
  l.pt[0] = (GLfloat)(lights[i].pos.pt[0] * cos((double)radians(light_rotation[i])));
  l.pt[1] = (GLfloat)(lights[i].pos.pt[0] * -sin((double)radians(light_rotation[i])));
  d = (sphere_position - l).unit();
  glLightfv(GL_LIGHT0 + i, GL_POSITION, l.pt);
  glLightfv(GL_LIGHT0 + i, GL_SPOT_DIRECTION, d.pt);
}

static void lights_list_init()
{
  int i;
  for (i = 0; i < nlights; i++) lights_list_init(i);
}

static void lights_list_init(int n)
{
  Color c;

  glNewList(lists_lights + n, GL_COMPILE);
  if (lights[n].on) {
    glLoadName(name_lights + n);

    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 1);
    glCallList(list_lights_on);

    c = lights[n].diffuse;
    glMaterialfv(GL_BACK, GL_AMBIENT, c.c);
    glMaterialfv(GL_BACK, GL_DIFFUSE, black.c);
    glMaterialfv(GL_BACK, GL_SPECULAR, black.c);

    glMaterialfv(GL_FRONT, GL_AMBIENT, (c * .75).c);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, white.c);
    glMaterialfv(GL_FRONT, GL_SPECULAR, white.c);

    glMatrixMode(GL_MODELVIEW);
    glPushMatrix();
    glRotatef(-light_rotation[n], 0, 0, 1);
    glTranslatef(lights[n].pos.pt[0], lights[n].pos.pt[1],
		 lights[n].pos.pt[2]);
    glRotatef((GLfloat)-degrees(atan2((double)(lights[n].pos.pt[2] - sphere_position.pt[2]),
			     (double)(lights[n].pos.pt[0]))), 0, 1, 0);
    glCallList(list_light_draw);
    glPopMatrix();

    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, 0);
    glDisable(GL_LIGHTING);
    glCallList(list_lights_off);
    glDisable(GL_DEPTH_TEST);
  } else {
    /* 5.0.1 for Elans seems to object strongly to replacing
     * empty display lists, so will put a placeholder command
     * in here */
    glColor3f(0, 0, 0);
  }
  glEndList();
}

static void light_draw_list_init()
{
  float c, s;
  int t;

  glNewList(list_light_draw, GL_COMPILE);
  glEnable(GL_NORMALIZE);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glScalef(.25, .15, .15);
  glBegin(GL_QUAD_STRIP);
  for (t = 0; t <= spherediv; t++) {
    c = (float) cos((double)(M_2PI * (float)t / (float)spherediv));
    s = (float) sin((double)(M_2PI * (float)t / (float)spherediv));
    glNormal3f((GLfloat).25, (GLfloat)(.968*s), (GLfloat)(.968*c));
    glVertex3f((GLfloat)0, (GLfloat)s, (GLfloat)c);
    glVertex3f((GLfloat)1, (GLfloat)(.75*s), (GLfloat)(.75*c));
  }
  glEnd();
  glNormal3f(1, 0, 0);
  glBegin(GL_TRIANGLE_STRIP);
  for (t = 0; t <= spherediv; t++) {
    c = (float)cos((double)(M_2PI * (float)t / (float)spherediv));
    s = (float)sin((double)(M_2PI * (float)t / (float)spherediv));
    glVertex3f((GLfloat)1, (GLfloat)(.75*s), (GLfloat)(.75*c));
    glVertex3f(1, 0, 0);
  }
  glEnd();
  glPopMatrix();
  glDisable(GL_NORMALIZE);
  glEndList();
}


#ifdef MYDEBUG
void lights_init()
#else
static void lights_init()
#endif
{
  int i;

  for (i = 0; i < nlights; i++) {
    glLightfv(GL_LIGHT0 + i, GL_DIFFUSE, lights[i].diffuse);
    glLightfv(GL_LIGHT0 + i, GL_SPECULAR, black.c);
    glLightfv(GL_LIGHT0 + i, GL_AMBIENT, black.c);
    glLightf(GL_LIGHT0 + i, GL_SPOT_EXPONENT, 4);
    glLightf(GL_LIGHT0 + i, GL_SPOT_CUTOFF, 90);
  }

  glLightfv(GL_LIGHT0 + nlights, GL_DIFFUSE, black.c);
  glLightfv(GL_LIGHT0 + nlights, GL_SPECULAR, black.c);
  glLightfv(GL_LIGHT0 + nlights, GL_AMBIENT, world_ambient.c);
  glEnable(GL_LIGHT0 + nlights);

  /* GL_LIGHT0 + nlights + 1 willl eventually be used to draw the
   * refractions - stay tuned. */
  glLightfv(GL_LIGHT0 + nlights + 1, GL_DIFFUSE, black.c);
  glLightfv(GL_LIGHT0 + nlights + 1, GL_SPECULAR, black.c);
  glLightfv(GL_LIGHT0 + nlights + 1, GL_AMBIENT, white.c);
}

#ifdef MYDEBUG
int lights_move(int light, float dr, float dphi, float dtheta,
#else
static int lights_move(int light, float dr, float dphi, float dtheta,

#endif
                       int update)
{
  float cphi, sphi, x, y;
  Point l, dl;

  if (!(dr || dphi || dtheta)) return 0;

  l = lights[light].pos - sphere_position;

  if (dr) {
    dl = l + l*dr;
    if (dl.mag() > sphere_size) l = dl;
  }

  if (dphi) {
    cphi = (float)cos((double)dphi);
    sphi = (float)sin((double)dphi);
    y = -l.pt[0]*sphi + l.pt[2]*cphi;

    /* This hack keeps with light from getting below the sphere -
     * the projection sections would completely get messed up if this ever
     * happened  - sphere_size is multiplied by two as a fudge factor*/
    if (y < 2.0*sphere_size) {
      dphi = (float)atan2((double)(l.pt[2] - 2.0*sphere_size), (double)l.pt[0]);
      cphi = (float)cos((double)dphi);
      sphi = (float)sin((double)dphi);

    }
    x = l.pt[0];
    l.pt[0] = x*cphi + l.pt[2]*sphi;
    l.pt[2] = -x*sphi + l.pt[2]*cphi;
  }

  if (dtheta) {
    light_rotation[light] += (GLfloat)degrees((double)dtheta);
    light_rotation[light] =  (GLfloat)degrees_clamp((double)light_rotation[light]);
  }

  lights[light].pos = l + sphere_position;
  lights[light].pos.pt[3] = 1;

  lights_init_position(light);
  lights_list_init(light);

  if (update) lights_move_update(light, dr ? 1 : 0, dphi ? 1 : 0,
				 dtheta ? 1 : 0);
  return 1;
}

#ifdef MYDEBUG
void lights_move_update(int light, int dr, int dphi,
#else
static void lights_move_update(int light, int dr, int dphi,
#endif
			       int dtheta)
{
  if (dr) {
    disk_build(light);
    shadow_refraction_full_build(light);
    shadow_list_init(light);
    refraction_list_init(light);
  } else if (dphi) {
    shadow_refraction_full_build(light);
    shadow_list_init(light);
    refraction_list_init(light);
  } else if (dtheta) {
  }

}



#ifdef MYDEBUG
int get_lists(int size)
#else
static int get_lists(int size)
#endif
{
  int i;
  i = glGenLists(size);
  if (size && !i) {
    fprintf(stderr, "Unable to allocate display lists.\n");
    exit(1);
  }
  return i;
}

#ifdef MYDEBUG
void lists_init()
#else
static void lists_init()
#endif
{
  list_square = get_lists(1);
  lists_shadows = get_lists(nlights);
  lists_refraction = get_lists(nlights);
  lists_lights = get_lists(nlights);
  list_sphere = get_lists(1);
  list_spheredisk = get_lists(1);
  list_lights_on = get_lists(1);
  list_lights_off = get_lists(1);
  list_light_draw = get_lists(1);
//  sphere_build();
}

static inline int sphere_npoints()
{
  return (spherediv+1)*spherediv*3;
}

void sphere_build()
{
  int nspherepts;
  int r, t, index;
  float c, s;
	
  delete spherepts;
  nspherepts = sphere_npoints();
  if (nspherepts == 0) return;
  spherepts = new GLfloat[nspherepts];

  index = 0;
  for (r = 0; r <= spherediv; r++) {
    spherepts[index++] = (GLfloat)sin((double)(M_PI * (float)r / (float)spherediv));
    spherepts[index++] = 0;
    spherepts[index++] = (GLfloat)-cos((double)(M_PI * (float)r / (float)spherediv));
  }
  for (t = 1; t < spherediv; t++) {
    c = (float)cos((double)(2.0 * M_PI * (float)t / (float)spherediv));
    s = (float)sin((double)(2.0 * M_PI * (float)t / (float)spherediv));
    for (r = 0; r <= spherediv; r++) {
      spherepts[index++] = c*spherepts[r*3];
      spherepts[index++] = s*spherepts[r*3];
      spherepts[index++] = spherepts[r*3 + 2];
    }
  }

}

void sphere_list_init()
{
  glNewList(list_sphere, GL_COMPILE);
  sphere_disk.draw_by_perimeter();
  glEndList();
}

void sphere_draw()
{
  int r, t, p1, p2;

  for (t = 1; t < spherediv; t++) {
    glBegin(GL_QUAD_STRIP);
    p1 = (t - 1) * (spherediv + 1);
    p2 = t * (spherediv + 1);
    for (r = 0; r <= spherediv; r++, p1++, p2++) {
      glNormal3fv(&spherepts[p1*3]);
      glVertex3fv(&spherepts[p1*3]);
      glNormal3fv(&spherepts[p2*3]);
      glVertex3fv(&spherepts[p2*3]);
    }
    glEnd();
  }

  glBegin(GL_QUAD_STRIP);
  p1 = (spherediv + 1) * (spherediv - 1);
  p2 = 0;
  for (r = 0; r <= spherediv; r++, p1++, p2++) {
    glNormal3fv(&spherepts[p1*3]);
    glVertex3fv(&spherepts[p1*3]);
    glNormal3fv(&spherepts[p2*3]);
    glVertex3fv(&spherepts[p2*3]);
  }
  glEnd();
}

static void disk_build()
{
  int i;
  for (i = 0; i < nlights; i++) disk_build(i);
}

static void disk_build(int disk)
{
  Point light;
  light = lights[disk].pos;

  disks[disk].free_points_normals();
  disks[disk].free_colors();

  disks[disk].set_divisions(diskdiv, diskdiv);
  disks[disk].set_angle((float)(2.0 *
			acos((double)(sphere_size / light.dist(sphere_position)))));
  disks[disk].fill_points();
}

static void shadow_list_init()
{
  int i;
  for (i = 0; i < nlights; i++) shadow_list_init(i);
}

static void shadow_list_init(int n)
{
  Color c(square_ambient[0], square_ambient[1], square_ambient[2]);

  c *= world_ambient;

  glNewList(lists_shadows + n, GL_COMPILE);
  glColorMask(lights[n].shadow_mask[0], lights[n].shadow_mask[1],
	      lights[n].shadow_mask[2], lights[n].shadow_mask[3]);
  glDisable(GL_DEPTH_TEST);
  glColor3fv(c.c);
  shadows[n].draw_by_perimeter(0, 0, 1);
  glColorMask(1, 1, 1, 1);
  glEndList();
}

static void refraction_list_init()
{
  int i;
  for (i = 0; i < nlights; i++) refraction_list_init(i);
}

static void refraction_list_init(int n) {
  /* This could be loads simpler if it weren't for the texture mapping -
   * that's where all this weirdness with GL_LIGHT0 + nlights + 1 comes
   * in */
  glNewList(lists_refraction + n, GL_COMPILE);

  glEnable(GL_LIGHTING);
  glCallList(list_lights_off);
  /* This is white ambient light */
  glEnable(GL_LIGHT0 + nlights + 1);
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, black.c);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, black.c);
  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT);
  glEnable(GL_COLOR_MATERIAL);

  glBlendFunc(GL_ONE, GL_ONE);
  glEnable(GL_BLEND);

  glDisable(GL_DEPTH_TEST);
  refraction[n].draw();

  glDisable(GL_BLEND);

  glDisable(GL_COLOR_MATERIAL);
  glDisable(GL_LIGHT0 + nlights + 1);
  glDisable(GL_LIGHTING);

  glEndList();
}

static void shadow_refraction_full_build()
{
  int i;
  for (i = 0; i < nlights; i++) shadow_refraction_full_build(i);
}

/* This entire function is written a bit oddly... */
static void shadow_refraction_full_build(int n)
{
  Color c;
  float dist_light;
  Point dlight, zaxis;

  /* Make sure that we're starting over from scratch */
  shadows[n].free_points_normals();
  shadows[n].free_colors();
  refraction[n].free_points_normals();
  refraction[n].free_colors();

  dlight = lights[n].pos - sphere_position;
  dist_light = dlight.mag();
  dlight.unitize();
  zaxis.pt[0] = 0;
  zaxis.pt[1] = 0;
  zaxis.pt[2] = 1;

  shadows[n].set_divisions(disks[n].get_rdivisions(),
			   disks[n].get_tdivisions());
  refraction[n].set_divisions(disks[n].get_rdivisions(),
			      disks[n].get_tdivisions());

  shadows[n].alloc_points();
  shadows[n].face_direction(dlight, disks[n]);
  shadows[n].scale_translate(sphere_size, sphere_position);

  c = square_diffuse;
  c *= lights[n].diffuse;

  refraction[n].copy_points(disks[n]);
  refraction[n].set_colors(c);
  refraction[n].scale_colors_by_z();

  refraction[n].scale(sphere_size);
  refraction[n].refract_normals(zaxis * dist_light, index);
  refraction[n].face_direction(dlight);

  refraction[n].project_borrow_points(shadows[n]);
  refraction[n].free_normals();
  shadows[n].project(lights[n].pos);
  if (index != 1.0) refraction[n].scale_colors_by_darea(shadows[n]);
}

int scene_load_texture(char *texfile)
{
#ifdef TEXTURE
  teximage = auxRGBImageLoad(texfile);
#else
  teximage = NULL;
#endif

  if (teximage == NULL) return 0;
  else return 1;
}

void texture_init()
{
  if (teximage == NULL) return;

  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage->sizeX, teximage->sizeY,
		    GL_RGB, GL_UNSIGNED_BYTE, teximage->data);

  glMatrixMode(GL_TEXTURE);
  glLoadIdentity();
  glRotatef(90, 0, 0, 1);
  /* This scales the texture so that it fits on the square */
  glTranslatef(.5, .5, 0);
  glScalef(2, 2, 1);
  glMatrixMode(GL_MODELVIEW);

  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER,
		 GL_NEAREST_MIPMAP_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
		 GL_LINEAR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\insect.c ===
#undef FLAT_SHADING

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <GL/gl.h>
#include "gl42ogl.h"
#include "tk.h"
#include "insect.h"
#include "insectco.h"

GLushort ls = 0xaaaa;


unsigned char   halftone[] = {
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,

    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,

    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,

    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
    0xAA, 0xAA,    0xAA, 0xAA,
    0x55, 0x55,    0x55, 0x55,
};


GLfloat sdepth = 10.;
float   light[3],
        phi = PI / 4.0,
        theta = PI / 4.0;
GLfloat ctheta = -900, cphi, cvtheta, cvphi;

float fabso (float a );

/* Changes for ECLIPSE 8 bit machine */
/*  don't use 7 and 8 for appearances. These are the text standards */
unsigned short ECLIPSE8_RAMP[10] = {4, 5, 6, 8, 9, 10, 11, 12, 13, 14};
GLboolean is_8bit;
short savearray[384];

/** change for new window control */
float halfwinx, halfwiny;
long worgx, worgy;
long wsizex, wsizey;
long pikx, piky;

GLboolean follow;


float px, py;
float light[3];
float cx, cy, cz, cvx, cvy, cvz;
float dmr[6], fr[6];

GLfloat knee[6];
GLfloat hip_phi[6];
GLfloat hip_theta[6];
GLboolean legup[6];
float legx[6], legy[6];


enum {
    NOTHING,
    FORWARD,
    BACKWARD,
    LEFT,
    MIDDLE
};

short function;



/*  mymakerange  -- color ramp utilities		*/
void
mymakerange (unsigned short a, unsigned short b, GLubyte red1, GLubyte red2,
	GLubyte  green1, GLubyte green2, GLubyte blue1, GLubyte blue2)
{
    float   i;
    int     j;
    float   dr,
            dg,
            db;

    i = (float) (b - a);
    dr = (float) (red2 - red1) / i;
    dg = (float) (green2 - green1) / i;
    db = (float) (blue2 - blue1) / i;

    for (j = 0; j <= (int) i; j++)
	mapcolor ((unsigned short) j + a,
		(short) (dr * (float) j + red1),
		(short) (dg * (float) j + green1),
		(short) (db * (float) j + blue1));
/*	mapcolor ((unsigned short) j + a,
		(GLubyte) (dr * (float) j + red1),
		(GLubyte) (dg * (float) j + green1),
		(GLubyte) (db * (float) j + blue1));
*/
}


/*  Set up Eclipse 8 bit color ramp */


void
make_eclipse8_range(unsigned short e_ramp[], int red1, int red2,
                    int green1, int green2, int blue1, int blue2)
{
    int i;
    float rinc, ginc, binc;

    rinc = (float)(red2 - red1) / (float)ECLIPSE8_NCOLORS;
    ginc = (float)(green2 - green1) / (float)ECLIPSE8_NCOLORS;
    binc = (float)(blue2 - blue1) / (float)ECLIPSE8_NCOLORS;

    for (i = 0; i < ECLIPSE8_NCOLORS; i++) {
	mapcolor(e_ramp[i],
	    (short)(i * rinc + red1),
	    (short)(i * ginc + green1),
	    (short)(i * binc + blue1));
    }
}


/*  setupcolors  -- load color map		*/

/* Changed for ECLIPSE 8 bit machine */
void
setupcolors (void) {
    if (!is_8bit) {
	mapcolor (GRAY, 128, 128, 128);
	mapcolor (GRID, 128, 200, 250);
	mapcolor (SKYBLUE, 50, 50, 150);
	mymakerange (RAMPB5, RAMPE5, 125, 250, 125, 250, 0, 0);
	mymakerange (RAMPB4, RAMPE4, 100, 200, 125, 250, 0, 0);
	mymakerange (RAMPB3, RAMPE3, 75, 150, 125, 250, 0, 0);
	mymakerange (RAMPB2, RAMPE2, 50, 100, 125, 250, 0, 0);
	mymakerange (RAMPB, RAMPE, 25, 50, 125, 250, 0, 0);
    } else {
	mapcolor (ECLIPSE8_GRAY, 128, 128, 128);
	mapcolor (ECLIPSE8_GRID, 128, 200, 250);
	mapcolor (ECLIPSE8_SKYBLUE, 50, 50, 150);
/*
	mapcolor (BLACK, 0, 0, 0);
	mapcolor (COLORS, 255, 0, 0);
	mapcolor (COLOR1, 0, 255, 0);
	mapcolor (COLOR2, 255, 255, 0);
*/
	make_eclipse8_range(ECLIPSE8_RAMP, 25, 250, 125, 250, 0, 0);
    }
}


/**** New routines for ECLIPSE 8 bit machine */

/* reduces color index value to the lower 16 indices in the color table
	see ECLIPSE8_RAMP[] for which entries are used for ramp */

short
reduce_index (short c)
{
    c = c - RAMPB + 4;
    while (c > 13)
	c -= 10;
    if (c > 6)
	c++;
    return(c);
}


void
getcoords (void)
{
    pikx = getvaluator(MOUSEX);
    piky = getvaluator(MOUSEY);
    if (pikx <= worgx || pikx >= worgx + wsizex || 
	piky <= worgy || piky >= worgy + wsizey) {
	pikx = worgx + wsizex / 2 + 1;
	piky = worgy + wsizey / 2 + 1;
    }
}


static void
getMouseCoords (void) {
    int x, y;

	tkGetMouseLoc (&x, &y);
	pikx = x;
	piky = wsizey - y;
	if ( (pikx < 0) || (pikx > wsizex) ||
 	     (piky < 0) || (piky > wsizey) ) {
		pikx = wsizex / 2 + 1;
		piky = wsizey / 2 + 1;
	}
}


int
l05 (int i)
{
    if (i < 0)
	return (i + 6);
    if (i > 5)
	return (i - 6);
    return (i);
}


int
sgn (float i)
{
    if (i < 0)
	return (-1);
    if (i > 0)
	return (1);
    return (0);
}


static void
fixWindow (void) {
    halfwinx = (float)wsizex / 2.0;
    halfwiny = (float)wsizey / 2.0;

    glViewport (0, 0, wsizex, wsizey);
    glPopMatrix();
    glPushMatrix();
    gluPerspective (80, wsizex / (float) wsizey, 0.01, 131072);
}


/*  draw_shadow  -- draw halftone shape of insect onto the floor  */
void
draw_shadow (void) {
    int     leg;

    glPushMatrix ();
    glCallList (shadow);

	glEnable (GL_POLYGON_STIPPLE);
    glTranslatef (px, py, 1.0);
    glCallList (body_shadow);
    for (leg = 0; leg < 6; leg++) {
	glPushMatrix ();
/*
	glRotatef ((GLfloat) (-leg * 600), 0, 0, 1);
*/
	glRotatef ((GLfloat) (-leg * 60), 0, 0, 1);
	glTranslatef (0.0, 0.5, 0.0);
	glCallList (hip_shadow);
/*
	glRotatef (hip_phi[leg], 0, 0, 1);
	glRotatef (hip_theta[leg], 1, 0, 0);
*/
	glRotatef (hip_phi[leg] / 10, 0, 0, 1);
	glRotatef (hip_theta[leg]/10, 1, 0, 0);
	glCallList (thigh_shadow);
	glCallList (kneeball_shadow);
	glTranslatef (0.0, 1.0, 0.0);
/*
	glRotatef (knee[leg], 1, 0, 0);
*/
	glRotatef (knee[leg]/10, 1, 0, 0);
	glCallList (shin_shadow);
	glPopMatrix ();
    }

	glDisable (GL_POLYGON_STIPPLE);
    glPopMatrix ();
}


/*  draw_hind  -- draw a rear leg.  First draw hip, then shin, then thigh
	and knee joint			*/
void
draw_hind (int leg)
{
    glPushMatrix ();
/*
    glRotatef ((GLfloat) (-leg * 600), 0, 0, 1);
*/
    glRotatef ((GLfloat) (-leg * 60), 0, 0, 1);
    glTranslatef (0.0, 0.5, 0.0);
    glCallList (hip[leg]);
/*
    glRotatef (hip_phi[leg], 0, 0, 1);
    glRotatef (hip_theta[leg], 1, 0, 0);
*/
    glRotatef (hip_phi[leg]/10, 0, 0, 1);
    glRotatef (hip_theta[leg]/10, 1, 0, 0);
    glPushMatrix ();		/* draw thigh */
    glTranslatef (0.0, 1.0, 0.0);
/*
    glRotatef (knee[leg], 1, 0, 0);
*/
    glRotatef (knee[leg]/10, 1, 0, 0);
    glCallList (shin[leg]);
    glPopMatrix ();
    if (cz < -5.0) {
	glCallList (kneeball[leg]);
	glCallList (thigh[leg]);
    }
    else {
	glCallList (kneeball[leg]);
	glCallList (thigh[leg]);
    }
    glPopMatrix ();
}


/*  draw_fore  -- draw a front leg.  First draw hip, then thigh,
	knee joint and finally shin		*/

void
draw_fore (int leg)
{
    glPushMatrix ();
/*
    glRotatef ((GLfloat) (-leg * 600), 0, 0, 1);
*/
    glRotatef ((GLfloat) (-leg * 60), 0, 0, 1);
    glTranslatef (0.0, 0.5, 0.0);
    glCallList (hip[leg]);
/*
    glRotatef (hip_phi[leg], 0, 0, 1);
    glRotatef (hip_theta[leg], 1, 0, 0);
*/
    glRotatef (hip_phi[leg]/10, 0, 0, 1);
    glRotatef (hip_theta[leg]/10, 1, 0, 0);
    glCallList (thigh[leg]);
    glCallList (kneeball[leg]);
    glTranslatef (0.0, 1.0, 0.0);
/*
    glRotatef (knee[leg], 1, 0, 0);
*/
    glRotatef (knee[leg]/10, 1, 0, 0);
    glCallList (shin[leg]);
    glPopMatrix ();
}


/*  draw_insect  -- draw rear legs, body and forelegs of insect 
	the order of drawing the objects is important to 
	insure proper hidden surface elimination -- painter's algorithm	*/
void
draw_insect (void) {
    GLfloat a;
    float   o;
    int     order;

    o = atan2 (cy + py, cx + px) + PI - (PI / 3.0);
    order = l05 ((int) integer (o / (PI / 3.0)));
    glPushMatrix ();		/* world */
    glTranslatef (px, py, 1.0);
    draw_hind (l05 (3 - order));
    draw_hind (l05 (4 - order));
    draw_hind (l05 (2 - order));
    glCallList (body);
    draw_fore (l05 (5 - order));
    draw_fore (l05 (1 - order));
    draw_fore (l05 (0 - order));
    glPopMatrix ();
}


/*  spin_scene  -- poll input devices, keyboard and mouse
	move eye position based upon user input			*/

void
spin_scene (void) {
    float   sin1,
            cos1,
            sin2,
            cos2,
            t;
    int     mx,
            my;


    /* big change to keep movement relative to window */
    /* check if still in window x and y are globals - see getcoords */
/*
    getcoords ();
    mx = 64 * ((pikx - worgx) - (wsizex / 2)) / wsizex;
    my = 64 * ((piky - worgy) - (wsizey / 2)) / wsizey;
*/

    getMouseCoords();
    mx = 64 * (pikx - (wsizex/2)) / wsizex;
    my = 64 * (piky - (wsizey/2)) / wsizey;


/*
    mx = (getvaluator (MOUSEX) - 640) / 16;
    my = (getvaluator (MOUSEY) - 512) / 16;
*/

    switch (function) {
      case BACKWARD:
	gl_sincos (ctheta, &sin1, &cos1);
	gl_sincos (cphi, &sin2, &cos2);
	cvz -= cos1;
	cvx -= sin2 * sin1;
	cvy -= cos2 * sin1;
	function = NOTHING;
        break;
      case FORWARD:
	gl_sincos (ctheta, &sin1, &cos1);
	gl_sincos (cphi, &sin2, &cos2);
	cvz += cos1;
	cvx += sin2 * sin1;
	cvy += cos2 * sin1;
	function = NOTHING;
	break;
      case LEFT:
	cvz = (float) - my;
	gl_sincos (cphi, &sin1, &cos1);
	cvx = cos1 * (float) (-mx);
	cvy = -sin1 * (float) (-mx);
	break;
      default:
	cvx = cvx * 0.7;
	cvy = cvy * 0.7;
	cvz = cvz * 0.7;
	break;
    }

    if (function == MIDDLE) {
	cvtheta = my;
	cvphi = mx;
    }
    else {
	cvtheta += -cvtheta / 4;
	if ((cvtheta < 4) && (cvtheta > -4))
	    cvtheta = 0;
	cvphi += -cvphi / 4;
	if ((cvphi < 4) && (cvphi > -4))
	    cvphi = 0;
	if (function != LEFT) function = NOTHING;
    }

    cx += cvx * 0.0078125;
    cy += cvy * 0.0078125;
    if (cz > 0.0) {
	cz = 0.0;
	cvz = 0.0;
    }
    else
	cz += cvz * 0.0078125;
    ctheta += cvtheta;
    cphi += cvphi;
}


GLfloat degrees (float a)
{
    return ((GLfloat) (a * 1800.0 / PI));
}


void
getstuff (void) {
    int     x,
            y,
            i;
    int     tr;

    legup[0] = GL_FALSE;
    legup[2] = GL_FALSE;
    legup[4] = GL_FALSE;
    legup[1] = GL_TRUE;
    legup[3] = GL_TRUE;
    legup[5] = GL_TRUE;

    px = 0.0;
    py = 0.0;
    for (i = 0; i < 6; i++) {
	legx[i] = 30.0 / 2.0 + (float) i;
	legy[i] = 30.0 / 2.0 + (float) i;
    }
}


void
dolegs (void) {
    int     i;
    float   r,
            l,
            gx,
            gy,
            k,
            t,
            a,
            ux,
            uy;
    int     leg,
            tr;

    for (leg = 0; leg < 6; leg++) {
	gx = legx[leg] - 30.0 / 2.0;
	gy = legy[leg] - 30.0 / 2.0;
	ux = gx / (30.0 / 2.0);
	uy = gy / (30.0 / 2.0);

	switch (leg) {
	    case 0: 
		gx += 0.0;
		gy += 30.0;
		break;
	    case 1: 
		gx += (30.0 * 0.8660254);
		gy += (30.0 * 0.5);
		break;
	    case 2: 
		gx += (30.0 * 0.8660254);
		gy += (30.0 * -0.5);
		break;
	    case 3: 
		gx += 0.0;
		gy += -30.0;
		break;
	    case 4: 
		gx += (30.0 * -0.8660254);
		gy += (30.0 * -0.5);;
		break;
	    case 5: 
		gx += (30.0 * -0.8660254);
		gy += (30.0 * 0.5);
		break;
	}
	r = sqrt ((gx * gx) + (gy * gy)) / 30.0;
	l = sqrt (1.0 + (r * r));
	k = acos ((5.0 - (l * l)) / 4.0);

	knee[leg] = (GLfloat) degrees (k);

	t = (2.0 * sin (k)) / l;
	if (t > 1.0)
	    t = 1.0;

	a = asin (t);
	if (l < 1.7320508)
	    a = PI - a;

	hip_theta[leg] =
	    (GLfloat) (degrees (a - atan2 (1.0, r)));

	if (gx == 0.0) {
	    hip_phi[leg] = (GLfloat) (900 * sgn (gy));
	}
	else {
	    hip_phi[leg] = (GLfloat) (degrees (atan2 (gy, gx)));
	}
	hip_phi[leg] += (-900 + 600 * leg);

	if (legup[leg]) {
	    hip_theta[leg] += (GLfloat)
		(200.0 * ((fr[leg] / 2.0) - fabso (dmr[leg] - (fr[leg] / 2.0))));
	}
    }
}


void
move_insect (void) {
    register int    i;
    register float  mx,
                    my,
                    vx,
                    vy,
                    dx,
                    dy,
                    dr,
                    lx,
                    ly,
                    lr,
                    dmx,
                    dmy;
    float   s,
            c;

/*  mx = (float) getvaluator (MOUSEX) / 640.0 - 1.0;
    my = (float) getvaluator (MOUSEY) / 512.0 - 1.0;
*/

/* changed to keep input within the window.
 x and y are globals - see getcoords */
/*
    getcoords ();
    mx = ((float)pikx - (float)worgx) / halfwinx - 1.0;
    my = ((float)piky - (float)worgy) / halfwiny - 1.0;
*/
	getMouseCoords();
	mx = pikx / halfwinx - 1.0; 
	my = piky / halfwiny - 1.0;



    gl_sincos (cphi, &s, &c);
    dx = mx * c + my * s;
    dy = -mx * s + my * c;
    mx = dx;
    my = dy;

    px += mx / (float) (RES);
    py += my / (float) (RES);

    if (follow) {
	cx -= mx / (float) (RES);
	cy -= my / (float) (RES);
    }

    dr = sqrt (mx * mx + my * my);
    dx = mx / dr;
    dy = my / dr;

    for (i = 0; i < 6; i++) {
	lx = legx[i] - (float) (RES / 2);
	ly = legy[i] - (float) (RES / 2);
	lr = (float) (RES / 2);
	lx = lx / lr;
	ly = ly / lr;
	dmx = (dx - lx);
	dmy = (dy - ly);
	dmr[i] = sqrt (dmx * dmx + dmy * dmy);
	if (legup[i]) {
	    dmx = 3 * dr * dmx / dmr[i];
	    dmy = 3 * dr * dmy / dmr[i];
	    legx[i] += dmx;
	    legy[i] += dmy;
	    if ((dmr[i]) < 0.15) {
		legup[i] = GL_FALSE;
	    }
	}
	else {
	    legx[i] -= mx;
	    legy[i] -= my;

	    if (!legup[l05 (i - 1)] && !legup[l05 (i + 1)] &&
		    (dmr[i] > REACH) &&
		    ((lx * dx + ly * dy) < 0.0)) {
		legup[i] = GL_TRUE;
		fr[i] = dmr[i];
		legx[i] += dmx;
		legy[i] += dmy;
	    }
	}
    }
}


void
rotate60 (char c, int n, GLfloat a[][3])
{
    int     i,
            j,
            l;
    float   nx,
            ny;

    switch (c) {
	case 'z': 
	    i = 0;
	    j = 1;
	    break;
	case 'y': 
	    i = 2;
	    j = 0;
	    break;
	case 'x': 
	    i = 1;
	    j = 2;
	    break;
    };
    for (l = 0; l < n; l++) {
	nx = a[l][i] * COS60 - a[l][j] * SIN60;
	ny = a[l][i] * SIN60 + a[l][j] * COS60;
	a[l][i] = nx;
	a[l][j] = ny;
    }
}


void
getpolycolor (int p, float pts[][3])
{
    float   norm[3];
    float   v1[3],
            v2[3],
            cons;
    int     i,
            get;
    float   c;

    for (i = 0; i < 3; i++)
	norm[i] = 0.0;
    i = 0;
    get = 1;
    i = 1;
    v1[0] = pts[1][0] - pts[0][0];
    v1[1] = pts[1][1] - pts[0][1];
    v1[2] = pts[1][2] - pts[0][2];

    v2[0] = pts[2][0] - pts[0][0];
    v2[1] = pts[2][1] - pts[0][1];
    v2[2] = pts[2][2] - pts[0][2];

    norm[0] = v1[1] * v2[2] - v1[2] * v2[1];
    norm[1] = v1[2] * v2[0] - v1[0] * v2[2];
    norm[2] = v1[0] * v2[1] - v1[1] * v2[0];

    cons = sqrt ((norm[0] * norm[0]) +
	    (norm[1] * norm[1]) + (norm[2] * norm[2]));
    for (i = 0; i < 3; i++)
	norm[i] = norm[i] / cons;

    c = dot (norm, light);
    if (c < 0.0)
	c = 0.0;
    if (c > 1.0)
	c = 1.0;
    switch (p) {
	case 0: 
	    c = (float) (RAMPE - RAMPB) * c + (float) (RAMPB);
            if (((unsigned short) c) > RAMPE) c = (float) RAMPE;
#ifdef FLAT_SHADING
	    c = COLOR1;
#endif
	    break;
	case 1: 
	    c = (float) (RAMPE2 - RAMPB2) * c + (float) (RAMPB2);
            if (((unsigned short) c) > RAMPE2) c = (float) RAMPE2;
#ifdef FLAT_SHADING
    	    c = COLOR2;
#endif
	    break;
	case 2: 
	    c = (float) (RAMPE3 - RAMPB3) * c + (float) (RAMPB3);
            if (((unsigned short) c) > RAMPE3) c = (float) RAMPE3;
#ifdef FLAT_SHADING
    	    c = COLOR2;
#endif
	    break;
	case 3: 
	    c = (float) (RAMPE4 - RAMPB4) * c + (float) (RAMPB4);
            if (((unsigned short) c) > RAMPE4) c = (float) RAMPE4;
#ifdef FLAT_SHADING
    	    c = COLOR2;
#endif
	    break;
	case 4: 
	    c = (float) (RAMPE5 - RAMPB5) * c + (float) (RAMPB5);
            if (((unsigned short) c) > RAMPE5) c = (float) RAMPE5;
#ifdef FLAT_SHADING
    	    c = COLOR2;
#endif
	    break;
    }

    /* Changed for 8 bit ECLIPSE machine */
    if (is_8bit)
	c = (float)reduce_index((int)c);
    glIndexi (c);	
}


GLboolean
lit (int p, float pts[][3])
{
    float   norm[3];
    float   v1[3],
            v2[3],
            cons;
    int     i,
            get;
    float   c;

    for (i = 0; i < 3; i++)
	norm[i] = 0.0;
    i = 0;
    get = 1;
    i = 1;
    v1[0] = pts[1][0] - pts[0][0];
    v1[1] = pts[1][1] - pts[0][1];
    v1[2] = pts[1][2] - pts[0][2];

    v2[0] = pts[2][0] - pts[0][0];
    v2[1] = pts[2][1] - pts[0][1];
    v2[2] = pts[2][2] - pts[0][2];

    norm[0] = v1[1] * v2[2] - v1[2] * v2[1];
    norm[1] = v1[2] * v2[0] - v1[0] * v2[2];
    norm[2] = v1[0] * v2[1] - v1[1] * v2[0];

    cons = sqrt ((norm[0] * norm[0]) +
	    (norm[1] * norm[1]) + (norm[2] * norm[2]));
    for (i = 0; i < 3; i++)
	norm[i] = norm[i] / cons;

    c = dot (norm, light);
    return (c > 0.0);
}


float   dot (float vec1[3], float vec2[3])
{
    float   xx;
    xx = (vec1[1] * vec2[1])
	+ (vec1[2] * vec2[2])
	+ (vec1[0] * vec2[0]);
    return ((float) xx);
}


void 
getlightvector (void) {
    float   f;
    light[2] = cos (theta);
    f = sin (theta);
    light[1] = -sin (phi) * f;
    light[0] = -cos (phi) * f;
}


float   integer (float x)
{
    if (x < 0.0)
	x -= 1.0;
    x = (float) (int) x;
    return (x);
}


float   frac (float x)
{
    return (x - integer (x));
}


float
fabso (float x)
{
    if (x < 0.0)
	return (-x);
    else
	return (x);
}


void
drawAll (void) {
   /* new for ECLIPSE 8 bit version */
   if (is_8bit)
      glClearIndex (ECLIPSE8_SKYBLUE);
   else
      glClearIndex (SKYBLUE);

   glClear (GL_COLOR_BUFFER_BIT);
   glPushMatrix();
   doViewit();
   glCallList (screen);
   draw_shadow();
   draw_insect();
   glPopMatrix();
}


static void Reshape(int width, int height)
{

      wsizex = width;
      wsizey = height;
      fixWindow();
}

static GLenum Key(int key, GLenum mask)
{
      switch (key) {
        case TK_ESCAPE:
          tkQuit();
          break;
	case TK_A:
	case TK_a:
	  function = FORWARD;
	  break;
	case TK_Z:
	case TK_z:
	  function = BACKWARD;
	  break;
	case TK_F:
	case TK_f:
	  follow = !follow;
	  break;
        default:
          return GL_FALSE;
      }
      return GL_TRUE;
}

static GLenum MouseUp(int mouseX, int mouseY, GLenum button)
{
	switch (button) {
	  case TK_LEFTBUTTON:
	    function = NOTHING;
	    break;
	  case TK_MIDDLEBUTTON:
	    function = NOTHING;
	    break;
	  default:
	    return GL_FALSE;
	}
      return GL_TRUE;
}

static GLenum MouseDown(int mouseX, int mouseY, GLenum button)
{

	switch (button) {
	  case TK_LEFTBUTTON:
	    function = LEFT;
	    break;
	  case TK_MIDDLEBUTTON:
	    function = MIDDLE;
	    break;
	  default:
	    return GL_FALSE;
	}
      return GL_TRUE;
}

static void animate (void) {
      spin_scene();
      move_insect();
      dolegs();
      drawAll();
      tkSwapBuffers();
}



/*	main routine -- handle tokens of window manager
		-- display shadow and insect
*/

void
main (int argc, char *argv[]) {
    int     i,
            j,
            k;
    short   dev,
            val;
    long    nplanes;
    GLboolean attached;


    follow = GL_TRUE;
    wsizex = 500;
    wsizey = 400;
    worgx = 252;
    worgy = 184;

    tkInitPosition(0, 0, wsizex, wsizey);

    tkInitDisplayMode(TK_INDEX|TK_DOUBLE|TK_DIRECT|TK_DEPTH16);

    if (tkInitWindow("Insect") == GL_FALSE) {
        tkQuit();
    }

    glPolygonStipple ((unsigned char *) halftone);
    glShadeModel(GL_FLAT);

    getlightvector ();

/* Changes for ECLIPSE 8 bit machine */



/*
 * Machines with enough bitplanes will use colormap entries CMAPSTART
 * to CMAPSTART+127.  If the machine doesn't have enough bitplanes,
 * only colors 0 to 15 will be used (it is assumed that all machines
 * have at least 4 bitplanes in colormap double-buffered mode).
 */
#ifdef ECLIPSE
    nplanes = glGetI(GD_BITS_NORM_DBL_CMODE);
    /* save color map in savearray */
    if ((1<<nplanes) > (CMAPSTART+127)) {
	is_8bit = GL_FALSE;
    }
    else {
	is_8bit = GL_TRUE;
    }
#else
	nplanes = 4;
	is_8bit = GL_TRUE;
#endif


    setupcolors ();
/* initialize transformation stuff */
    cx = 0.0;
    cy = 10.0;
    cz = -2.0;
    cvx = cvy = cvz = 0.0;
    ctheta = -900;
    cphi = 0;
    cvtheta = cvphi = 0.0;
    function = NOTHING;

    glPushMatrix();

    fixWindow();
    createobjects ();
    getstuff ();
    spin_scene ();
    move_insect ();
    dolegs ();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkMouseDownFunc(MouseDown);
    tkMouseUpFunc(MouseUp);
    tkIdleFunc(animate);
    tkExec();

    glPopMatrix();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\gl42ogl.h ===
#include <GL/gl.h>

/* screen == monitor */
#define YOUR_SCREEN_MAXX    1023
#define YOUR_SCREEN_MAXY     766

#define YOUR_WINDOW_PADX       8
#define YOUR_WINDOW_PADY      32

#define MOUSEX 266
#define MOUSEY 267


typedef unsigned short Colorindex;
typedef unsigned short Device;

typedef GLfloat Coord;
typedef GLint Icoord;

extern void
getorigin (long *x, long *y);
/* no origin redoing is done */

extern void
gl_sincos (GLfloat ang, float *sine, float *cosine);
/* ang is in tenths of degrees */

extern long
getvaluator (Device dev);
/* gl4: origin in bottom right
 *  tk: assumes origin in top left
 */

extern void
glGetMatrix (GLfloat mat[]);

#define maxDEPTH 4294967295.0

#define lsetdepth(ln, lf) \
    glDepthRange ( ln / maxDEPTH, lf / maxDEPTH)


extern void
mapcolor (Colorindex index, short r, short g, short b);

extern void
polf2i (long n, Icoord parray[][2]);

extern void
polf2 (long n, Coord parray[][2]);

extern void
polfi (long n, Icoord parray[][3]);

extern void
polf (long n, Coord parray[][3]);

extern void
poly2i (long n, Icoord parray[][2]);

extern void
poly2 (long n, Coord parray[][2]);

extern void
polyi (long n, Icoord parray[][3]);

extern void
poly (long n, Coord parray[][3]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\gl42ogl.c ===
#undef GEORGE_DEBUG

#ifdef GEORGE_DEBUG
#   include <stdio.h>
#endif

#include <windows.h>
#include <math.h>
#include <stdio.h>
#include <GL/gl.h>
#include "tk.h"

#include "gl42ogl.h"

int windX, windY;


void
getorigin (long *x, long *y) {
    *x = windX;
    *y = windY;
}


long
getvaluator (Device dev) {
/* gl4: origin in bottom right
 */
    long originX, originY;
    int mouseX, mouseY;
    long val;

/* cost in performance in repeated calls,
 *   but hey you want an easy port as possible
 */
    getorigin (&originX, &originY);
    switch (dev) {
	case MOUSEX:
	    tkGetMouseLoc (&mouseX, &mouseY);
	    val = mouseX + originX;
	    break;

	case MOUSEY:
	    tkGetMouseLoc (&mouseX, &mouseY);
	    val = YOUR_SCREEN_MAXY - (mouseY + originY);
	    break;

	default:
	    fprintf (stderr, "unsupported device: %d\n", dev);
	    break;
    }
    return (val);

}


#define PI 3.141593

void
gl_sincos (GLfloat ang, float *sine, float *cosine) {
    float rads = ang * PI / 1800;
    *sine   = (float)sin (rads);
    *cosine = (float)cos (rads);
}


void
glGetMatrix (GLfloat mat[]) {
    
    short i;
    GLint mode, ptr;
    static GLfloat tmp[100];

    glGetIntegerv (GL_MATRIX_MODE, &mode);
    switch (mode) {
	case GL_MODELVIEW:
	    glGetIntegerv (GL_MODELVIEW_STACK_DEPTH, &ptr);
	    glGetFloatv (GL_MODELVIEW_MATRIX, tmp);
	    break;
	case GL_PROJECTION:
	    glGetIntegerv (GL_PROJECTION_STACK_DEPTH, &ptr);
	    glGetFloatv (GL_PROJECTION_MATRIX, tmp);
	    break;
	case GL_TEXTURE:
	    glGetIntegerv (GL_TEXTURE_STACK_DEPTH, &ptr);
	    glGetFloatv (GL_TEXTURE_MATRIX, tmp);
	    break;
	default:
	    fprintf (stderr, "unknown matrix mode: %d\n", mode);
	    break;
    }

    for (i = 0; i < 16; i++)
	mat[i] = tmp[i];

}


void
mapcolor (Colorindex index, short r, short g, short b) {
/* gl4 -> rgb = [1,255]
 * ogl -> rgb = [0,1]
 */
    tkSetOneColor (index, r/255.0, g/255.0, b/255.0);
}


void
polf2i (long n, Icoord parray[][2]) {
    register long i;

    glBegin (GL_POLYGON);
    for (i = 0; i < n; i++)
	glVertex2iv (parray[i]);
    glEnd();
}


void
polf2 (long n, Coord parray[][2]) {
    register long i;

    glBegin (GL_POLYGON);
    for (i = 0; i < n; i++)
	glVertex2fv (parray[i]);
    glEnd();
}


void
polfi (long n, Icoord parray[][3]) {
    register long i;

    glBegin (GL_POLYGON);
    for (i = 0; i < n; i++)
	glVertex3iv (parray[i]);
    glEnd();
}


void
polf (long n, Coord parray[][3]) {
    register long i;

    glBegin (GL_POLYGON);
    for (i = 0; i < n; i++)
	glVertex3fv (parray[i]);
    glEnd();
}


void
poly2i (long n, Icoord parray[][2]) {
    register long i;

    glBegin (GL_LINE_LOOP);
    for (i = 0; i < n; i++)
	glVertex2iv (parray[i]);
    glEnd();
}


void
poly2 (long n, Coord parray[][2]) {
    register long i;

    glBegin (GL_LINE_LOOP);
    for (i = 0; i < n; i++)
	glVertex2fv (parray[i]);
    glEnd();
}


void
polyi (long n, Icoord parray[][3]) {
    register long i;

    glBegin (GL_LINE_LOOP);
    for (i = 0; i < n; i++)
	glVertex3iv (parray[i]);
    glEnd();
}


void
poly (long n, Coord parray[][3]) {
    register long i;

    glBegin (GL_LINE_LOOP);
    for (i = 0; i < n; i++)
	glVertex3fv (parray[i]);
    glEnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\parts.c ===
#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "gl42ogl.h"
#include "tk.h"
#include "insect.h"
#include "insectco.h"

#define BLACK 0

/* For ECLIPSE 8 bit machine */	
extern GLboolean is_8bit;

GLuint screen,viewit,shadow,body,hip[6],thigh[6],shin[6],kneeball[6];
GLuint body_shadow,hip_shadow,thigh_shadow,shin_shadow,kneeball_shadow;

GLfloat k2[6][3];
GLfloat k3[6][3];
GLfloat b7[12][3];
GLfloat b8[12][3];
GLint scr[4][2];

GLfloat b1[4][3] = {
    {
	R1 * SIN30 * -SIN15,
	    R1 * SIN30 * COS15,
	    R1 * COS30
    },

    {
	R1 * SIN30 * SIN15,
	    R1 * SIN30 * COS15,
	    R1 * COS30
    },

    {
	A2 * SIN30,
	    A1,
	    A2 * COS30
    },

    {
	-A2 * SIN30,
	    A1,
	    A2 * COS30
    }
};

GLfloat b4[4][3] = {
    {
	R1 * SIN30 * -SIN15,
	    R1 * SIN30 * COS15,
	    -R1 * COS30
    },

    {
	-A2 * SIN30,
	    A1,
	    -A2 * COS30
    },

    {
	A2 * SIN30,
	    A1,
	    -A2 * COS30
    },

    {
	R1 * SIN30 * SIN15,
	    R1 * SIN30 * COS15,
	    -R1 * COS30
    }
};

GLfloat b2[4][3] = {{
	R1 * SIN30 * -SIN45,
	    R1 * SIN30 * COS45,
	    R1 * COS30
},

{
    R1 * SIN30 * -SIN15,
	R1 * SIN30 * COS15,
	R1 * COS30
},

{
    -A2 * SIN30,
	A1,
	A2 * COS30
},

{
    (A2 * SIN30) * COS60 - A1 * SIN60,
	A1 * COS60 + (A2 * SIN30) * SIN60,
	A2 * COS30
}
};

GLfloat b5[4][3] = {{
	R1 * SIN30 * -SIN45,
	    R1 * SIN30 * COS45,
	    -R1 * COS30
},

{
    (A2 * SIN30) * COS60 - A1 * SIN60,
	A1 * COS60 + (A2 * SIN30) * SIN60,
	-A2 * COS30
},

{
    -A2 * SIN30,
	A1,
	-A2 * COS30
},

{
    R1 * SIN30 * -SIN15,
	R1 * SIN30 * COS15,
	-R1 * COS30
}
};

GLfloat b3[4][3] = {{
	(A2 * SIN30) * COS60 - A1 * SIN60,
	    A1 * COS60 + (A2 * SIN30) * SIN60,
	    A2 * COS30
},

{
    -A2 * SIN30,
	A1,
	A2 * COS30
},

{
    -A2,
	A1,
	0
},

{
    (A2) * COS60 - A1 * SIN60,
	A1 * COS60 + (A2) * SIN60,
	0
}
};

GLfloat b6[4][3] = {{
	(A2 * SIN30) * COS60 - A1 * SIN60,
	    A1 * COS60 + (A2 * SIN30) * SIN60,
	    -A2 * COS30
},

{
    (A2) * COS60 - A1 * SIN60,
	A1 * COS60 + (A2) * SIN60,
	0.0
},

{
    -A2,
	A1,
	0.0
},

{
    -A2 * SIN30,
	A1,
	-A2 * COS30
}
};

GLfloat h1[4][3] = {{
	A2, -A2, 0.0
},

{
    R2, 0.0, 0.0
},

{
    R2 * COS60,
	0,
	R2 * SIN60
},

{
    A2 * COS60,
	-A2,
	A2 * SIN60
}

};

GLfloat h2[4][3] = {{
	R2 * COS60,
	    0.0,
	    R2 * SIN60
},

{
    R2, 0.0, 0.0
},

{
    A2, A2, 0.0
},

{
    A2 * COS60,
	A2,
	A2 * SIN60
}
};

GLfloat h3[3][3] = {{
	A2, A2, 0.0
},

{
    0.0, R2, 0.0
},

{
    A2 * COS60,
	A2,
	A2 * SIN60
},
};

GLfloat t1[4][3] = {{
	-A2 * COS60,
	    A2,
	    A2 * SIN60
},

{
    A2 * COS60,
	A2,
	A2 * SIN60
},

{
    A2 * COS60,
	1 - A2 * COS60,
	A2 * SIN60
},

{
    -A2 * COS60,
	1 - A2 * COS60,
	A2 * SIN60
}
};

GLfloat t2[3][3] = {{
	-A2 * COS60,
	    A2,
	    A2 * SIN60
},

{
    -A2 * COS60,
	1 - A2 * COS60,
	A2 * SIN60
},

{
    -A2,
	A2,
	0.0
}
};

GLfloat t6[3][3] = {{
	-A2 * COS60,
	    A2,
	    -A2 * SIN60
},

{
    -A2,
	A2,
	0.0
},

{
    -A2 * COS60,
	1 - A2,
	0.0
}

};

GLfloat t3[3][3] = {{
	A2 * COS60,
	    A2,
	    A2 * SIN60
},

{
    A2,
	A2,
	0.0
},

{
    A2 * COS60,
	1 - A2 * COS60,
	A2 * SIN60
}
};

GLfloat t7[3][3] = {{
	A2 * COS60,
	    A2,
	    -A2 * SIN60
},

{
    A2 * COS60,
	1 - A2,
	0.0
},

{
    A2,
	A2,
	0.0
}
};

GLfloat t4[3][3] = {{
	-A2 * COS60,
	    1.0 - A2 * COS60,
	    A2 * SIN60
},

{
    -A2 * COS60,
	1.0 - A2,
	0.0
},

{
    -A2,
	A2,
	0.0
}
};

GLfloat t5[3][3] = {{
	A2 * COS60,
	    1.0 - A2 * COS60,
	    A2 * SIN60
},

{
    A2,
	A2,
	0.0
},

{
    A2 * COS60,
	1 - A2,
	0.0
}
};

GLfloat t8[4][3] = {{
	A2 * COS60,
	    A2,
	    -A2 * SIN60
},

{
    -A2 * COS60,
	A2,
	-A2 * SIN60
},

{
    -A2 * COS60,
	1 - A2,
	0.0
},

{
    A2 * COS60,
	1 - A2,
	0.0
}
};

GLfloat s1[4][3] = {{
	A2 * COS60,
	    -A2 * COS60,
	    -A2 * SIN60
},

{
    A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
},

{
    -A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
},

{
    -A2 * COS60,
	-A2 * COS60,
	-A2 * SIN60
}

};

GLfloat s2[4][3] = {{
	A2 * COS60,
	    -A2 * COS60,
	    -A2 * SIN60
},

{
    A2 * COS60,
	-A2,
	0.0
},

{
    A2 * COS60 * 0.4,
	-2.0,
	0.0
},

{
    A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
}

};

GLfloat s3[4][3] = {{
	-A2 * COS60,
	    -A2 * COS60,
	    -A2 * SIN60
},

{
    -A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
},

{
    -A2 * COS60 * 0.4,
	-2.0,
	0.0
},

{
    -A2 * COS60,
	-A2,
	0.0
}

};

GLfloat s4[4][3] = {{
	A2 * COS60,
	    -A2,
	    0.0
},

{
    -A2 * COS60,
	-A2,
	0.0
},

{
    -A2 * COS60 * 0.4,
	-2.0,
	0.0
},

{
    A2 * COS60 * 0.4,
	-2.0,
	0.0
}

};

GLfloat s5[4][3] = {{
	A2 * COS60 * 0.4,
	    -2.0,
	    0.0
},

{
    -A2 * COS60 * 0.4,
	-2.0,
	0.0
},

{
    -A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
},

{
    A2 * COS60 * 0.4,
	A2 * COS60 - 2.0,
	-A2 * SIN60 * 0.4
}
};

GLfloat k1[4][3] = {{
	-A2 * COS60,
	    1.0 - A2 * COS60,
	    A2 * SIN60
},

{
    A2 * COS60,
	1.0 - A2 * COS60,
	A2 * SIN60
},

{
    A2 * COS60,
	1.0 + A2 * COS60,
	A2 * SIN60
},

{
    -A2 * COS60,
	1.0 + A2 * COS60,
	A2 * SIN60
}
};

/*	make display list objects
	screen -- for checkerboard floor
	shadow -- matrix to project insect onto flat surface
	viewit -- viewing transformation
	and various parts of the body and their shadows
*/

void
doViewit (void) {
/*
    glFrustum (-8.0, 8.0, -8.0 * 0.75, 8.0 * 0.75, 10.0, 135.0);
    guPerspective (viewitFOV, viewitASPECT, 0.01, 131072.);
*/
    glRotatef (ctheta/10, 1, 0, 0);
    glRotatef (cphi/10, 0, 0, 1);
    glTranslatef (cx, cy, cz);
}



void
createobjects (void) {
    int     i,
            j,
            k;

    screen = glGenLists(32);
    if (screen == 0) tkQuit();

	shadow = screen + 1;
	body = screen + 2;
	body_shadow = screen + 3;
	/* hip   [4..9]
	 * thigh [10..15]
	 * knee  [16..21]
	 * shin  [22..27]
	 */
	hip[0] = screen + 4;
	thigh[0] = screen + 10;
	kneeball[0] = screen + 16;
	shin[0] = screen + 22;
	hip_shadow = screen + 28;
	thigh_shadow = screen + 29;
	kneeball_shadow = screen + 30;
	shin_shadow = screen + 31;
	
		

    glNewList (screen, GL_COMPILE);

    glShadeModel(GL_FLAT);

/* Changed for ECLIPSE 8 bit machine */
    if (is_8bit)
	glIndexi (ECLIPSE8_GRID);
    else
	glIndexi (GRID);

    k = 1;
    for (i = -8; i < 7; i++)
	for (j = -8; j < 7; j++) {
	    if (k == 0) {
		scr[0][0] = i * 3;
		scr[0][1] = j * 3;
		scr[1][0] = (i + 1) * 3;
		scr[1][1] = j * 3;
		scr[2][0] = (i + 1) * 3;
		scr[2][1] = (j + 1) * 3;
		scr[3][0] = i * 3;
		scr[3][1] = (j + 1) * 3;
		polf2i (4, scr);
	    }
	    k = 1 - k;
	}
    glEndList ();


    glNewList (shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    {
	float   sx,
	        sy,
	        sz;
	GLfloat mshadow[16];
	sx = -1.0;
	sy = -1.0;
	sz = 1.0;
	gl_IdentifyMatrix (mshadow);
/*
	mshadow[2][0] = -sx / sz;
	mshadow[2][1] = -sy / sz;
	mshadow[2][2] = 0.;
*/
      	mshadow[8] = -sx / sz;
 	mshadow[9] = -sy / sz;
	mshadow[10] = 0;
	glMultMatrixf (mshadow);
    }
    glIndexi (BLACK);
    glEndList ();

    for (i = 0; i < 12; i++) {
	b7[i][2] = R1 * SIN60;
	b7[i][0] = R1 * COS60 * cos ((float) i * (PI / 6.0) + (PI / 12.0));
	b7[i][1] = R1 * COS60 * sin ((float) i * (PI / 6.0) + (PI / 12.0));
	b8[11 - i][2] = -R1 * SIN60;
	b8[11 - i][0] = R1 * COS60 * cos ((float) i * (PI / 6.0) + (PI / 12.0));
	b8[11 - i][1] = R1 * COS60 * sin ((float) i * (PI / 6.0) + (PI / 12.0));
    }

    for (i = 0; i < 6; i++) {
	k2[i][0] = A2 * COS60;
	k2[i][1] = A2 * cos ((float) i * (PI / 3.0)) + 1.0;
	k2[i][2] = A2 * sin ((float) i * (PI / 3.0));
	k3[5 - i][0] = -A2 * COS60;
	k3[5 - i][1] = A2 * cos ((float) i * (PI / 3.0)) + 1.0;
	k3[5 - i][2] = A2 * sin ((float) i * (PI / 3.0));
    }

    glNewList (body, GL_COMPILE);

    glShadeModel(GL_FLAT);
    glEnable (GL_CULL_FACE);

    getpolycolor (0, b7);
    polf (12, b7);
    getpolycolor (0, b8);
    polf (12, b8);
    getpolycolor (0, b1);
    polf (4, b1);
    getpolycolor (0, b2);
    polf (4, b2);
    getpolycolor (0, b3);
    polf (4, b3);
    getpolycolor (0, b4);
    polf (4, b4);
    getpolycolor (0, b5);
    polf (4, b5);
    getpolycolor (0, b6);
    polf (4, b6);
    for (i = 0; i < 5; i++) {
	rotate60 ('z', 4, b1);
	rotate60 ('z', 4, b2);
	rotate60 ('z', 4, b3);
	rotate60 ('z', 4, b4);
	rotate60 ('z', 4, b5);
	rotate60 ('z', 4, b6);
	getpolycolor (0, b1);
	polf (4, b1);
	getpolycolor (0, b2);
	polf (4, b2);
	getpolycolor (0, b3);
	polf (4, b3);
	getpolycolor (0, b4);
	polf (4, b4);
	getpolycolor (0, b5);
	polf (4, b5);
	getpolycolor (0, b6);
	polf (4, b6);
    }

    glDisable (GL_CULL_FACE);


    glEndList ();

    glNewList (body_shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    glIndexi (SHADOW_COLOR);
    if (lit (3, b7))
	polf (12, b7);
    if (lit (3, b1))
	polf (4, b1);
    if (lit (3, b2))
	polf (4, b2);
    if (lit (3, b3))
	polf (4, b3);
    if (lit (3, b4))
	polf (4, b4);
    if (lit (3, b5))
	polf (4, b5);
    if (lit (3, b6))
	polf (4, b6);
    for (i = 0; i < 5; i++) {
	rotate60 ('z', 4, b1);
	rotate60 ('z', 4, b2);
	rotate60 ('z', 4, b3);
	rotate60 ('z', 4, b4);
	rotate60 ('z', 4, b5);
	rotate60 ('z', 4, b6);
	if (lit (3, b1))
	    polf (4, b1);
	if (lit (3, b2))
	    polf (4, b2);
	if (lit (3, b3))
	    polf (4, b3);
	if (lit (3, b4))
	    polf (4, b4);
	if (lit (3, b5))
	    polf (4, b5);
	if (lit (3, b6))
	    polf (4, b6);
    }
    glEndList ();

    for (j = 0; j < 6; j++) {
 	hip[j] = hip[0] + j;
	glNewList (hip[j], GL_COMPILE);

    glShadeModel(GL_FLAT);

	glEnable (GL_CULL_FACE);

	getpolycolor (1, h1);
	polf (4, h1);
	getpolycolor (1, h2);
	polf (4, h2);
	getpolycolor (1, h3);
	polf (3, h3);
	for (i = 0; i < 5; i++) {
	    rotate60 ('y', 4, h1);
	    rotate60 ('y', 4, h2);
	    rotate60 ('y', 3, h3);
	    getpolycolor (1, h1);
	    polf (4, h1);
	    getpolycolor (1, h2);
	    polf (4, h2);
	    getpolycolor (1, h3);
	    polf (3, h3);
	}
	phi += PI / 3.0;
	getlightvector ();

	glDisable (GL_CULL_FACE);


	glEndList ();
    }

    glNewList (hip_shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    /*glEnable (GL_CULL_FACE);*/
    glIndexi (SHADOW_COLOR);
    polf (4, h1);
    polf (4, h2);
    polf (3, h3);
    for (i = 0; i < 5; i++) {
	rotate60 ('y', 4, h1);
	rotate60 ('y', 4, h2);
	rotate60 ('y', 3, h3);
	polf (4, h1);
	polf (4, h2);
	polf (3, h3);
    }
    /*glDisable (GL_CULL_FACE);*/
    glEndList ();

    phi = 0.0;
    theta = PI / 4.0;
    getlightvector ();
    for (j = 0; j < 6; j++) {
  	thigh[j] = thigh[0] + j;
	glNewList (thigh[j], GL_COMPILE);

    glShadeModel(GL_FLAT);

	glEnable (GL_CULL_FACE);


	getpolycolor (2, t1);
	polf (4, t1);
	getpolycolor (2, t2);
	polf (3, t2);
	getpolycolor (2, t3);
	polf (3, t3);
	getpolycolor (2, t4);
	polf (3, t4);
	getpolycolor (2, t5);
	polf (3, t5);
	getpolycolor (2, t6);
	polf (3, t6);
	getpolycolor (2, t7);
	polf (3, t7);
	getpolycolor (2, t8);
	polf (4, t8);

	glDisable (GL_CULL_FACE);


	glEndList ();
	kneeball[j] = kneeball[0] + j;
	glNewList (kneeball[j], GL_COMPILE);

    glShadeModel(GL_FLAT);

	glEnable (GL_CULL_FACE);


	getpolycolor (3, k1);
	polf (4, k1);
	for (k = 0; k < 4; k++)
	    k1[k][1] -= 1.0;
	rotate60 ('x', 4, k1);
	for (k = 0; k < 4; k++)
	    k1[k][1] += 1.0;
	for (i = 0; i < 5; i++) {
	    if (i != 0) {
		getpolycolor (3, k1);
		polf (4, k1);
	    }
	    for (k = 0; k < 4; k++)
		k1[k][1] -= 1.0;
	    rotate60 ('x', 4, k1);
	    for (k = 0; k < 4; k++)
		k1[k][1] += 1.0;
	}
	getpolycolor (3, k2);
	polf (6, k2);
	getpolycolor (3, k3);
	polf (6, k3);


	glDisable (GL_CULL_FACE);


	glEndList ();
	shin[j] = shin[0] + j;
	glNewList (shin[j], GL_COMPILE);

    glShadeModel(GL_FLAT);

	glEnable (GL_CULL_FACE);


	getpolycolor (4, s1);
	polf (4, s1);
	getpolycolor (4, s2);
	polf (4, s2);
	getpolycolor (4, s3);
	polf (4, s3);
	getpolycolor (4, s4);
	polf (4, s4);
	getpolycolor (4, s5);
	polf (4, s5);


	glDisable (GL_CULL_FACE);


	glEndList ();
	theta -= PI / 3.0;
	getlightvector ();
    }
    glNewList (thigh_shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    /*glEnable (GL_CULL_FACE);*/
    glIndexi (SHADOW_COLOR);
    polf (4, t1);
    polf (3, t2);
    polf (3, t3);
    polf (3, t4);
    polf (3, t5);
    polf (3, t6);
    polf (3, t7);
    polf (4, t8);
    /*glDisable (GL_CULL_FACE);*/
    glEndList ();
    glNewList (kneeball_shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    /*glEnable (GL_CULL_FACE);*/
    glIndexi (SHADOW_COLOR);
    polf (4, k1);
    for (k = 0; k < 4; k++)
	k1[k][1] -= 1.0;
    rotate60 ('x', 4, k1);
    for (k = 0; k < 4; k++)
	k1[k][1] += 1.0;
    for (i = 0; i < 5; i++) {
	if (i != 0) {
	    polf (4, k1);
	}
	for (k = 0; k < 4; k++)
	    k1[k][1] -= 1.0;
	rotate60 ('x', 4, k1);
	for (k = 0; k < 4; k++)
	    k1[k][1] += 1.0;
    }
    polf (6, k2);
    polf (6, k3);
    /*glDisable (GL_CULL_FACE);*/
    glEndList ();
    glNewList (shin_shadow, GL_COMPILE);

    glShadeModel(GL_FLAT);

    /*glEnable (GL_CULL_FACE);*/
    glIndexi (SHADOW_COLOR);
    polf (4, s1);
    polf (4, s2);
    polf (4, s3);
    polf (4, s4);
    polf (4, s5);
    /*glDisable (GL_CULL_FACE);*/
    glEndList ();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\misc\miscutil.c ===
#include <stdlib.h>
#include <stdio.h>

int
miscParseGeometry(  char *Geometry,
                    int *x,
                    int *y,
                    int *Width,
                    int *Height
                )
{
    int Scanned = 0;

    if ( NULL != Geometry )
    {
        Scanned = sscanf( Geometry, "%ix%i+%i+%i", Width, Height, x, y );
    }
    return( Scanned );
}

char *
miscGetGeometryHelpString( void )
{
    return( "WidthxHeight+Left+Top" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\insect\mat.c ===
#include <windows.h>
#include <GL/gl.h>

void
gl_IdentifyMatrix( GLfloat mat[16])
{
int i,j;

for (i = 0; i < 16; i++)
    mat[i] = 0.0;

mat[0] = 1.0;
mat[5] = 1.0;
mat[10] = 1.0;
mat[15] = 1.0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\misc\spots.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <GL/gl.h>
#include "glaux.h"
#include "miscflt.h"
#include "miscutil.h"

#ifndef M_PI
#define M_PI    3.1415926539
#endif

#define TWO_PI  ((float)(2*M_PI))

typedef struct lightRec {
    float amb[4];
    float diff[4];
    float spec[4];
    float pos[4];
    float spotDir[3];
    float spotExp;
    float spotCutoff;
    float atten[3];

    float trans[3];
    float rot[3];
    float swing[3];
    float arc[3];
    float arcIncr[3];
} Light;

static int useSAME_AMB_SPEC = 1;

static float modelAmb[4]    = { POINT_TWO, POINT_TWO, POINT_TWO, ONE };
static float matAmb[4]      = { POINT_TWO, POINT_TWO, POINT_TWO, ONE };
static float matDiff[4]     = { POINT_EIGHT, POINT_EIGHT, POINT_EIGHT, ONE };
static float matSpec[4]     = { POINT_FOUR, POINT_FOUR, POINT_FOUR, ONE };
static float matEmission[4] = { ZERO, ZERO, ZERO, ONE };

static char *geometry = NULL;

#define NUM_LIGHTS 3
static Light spots[] = {
    {
        { POINT_TWO  , ZERO, ZERO, ONE },           /* ambient */
        { POINT_EIGHT, ZERO, ZERO, ONE },           /* diffuse */
        { POINT_FOUR , ZERO, ZERO, ONE },           /* specular */
        { ZERO, ZERO , ZERO, ONE },                 /* position */
        { ZERO, -ONE , ZERO },                      /* direction */
        { 20.0f }, { 60.0f },                       /* exponent, cutoff */
        { ONE, ZERO, ZERO },                        /* attenuation */
        { ZERO, 1.25f, ZERO },                      /* translation */
        { ZERO, ZERO, ZERO },                       /* rotation */
        { 20.0f, ZERO, 40.0f },                     /* swing */
        { ZERO, ZERO, ZERO },                       /* arc */
        { (float)(TWO_PI/70.0), ZERO, (float)(TWO_PI/140.0) }      /* arc increment */
    },
    {
        { ZERO, POINT_TWO, ZERO, ONE },             /* ambient */
        { ZERO, POINT_EIGHT, ZERO, ONE },           /* diffuse */
        { ZERO, POINT_FOUR, ZERO, ONE },            /* specular */
        { ZERO, ZERO, ZERO, ONE },                  /* position */
        { ZERO, -ONE, ZERO },                       /* direction */
        { 20.0f }, { 60.0f },                       /* exponent, cutoff */
        { ONE, ZERO, ZERO },                        /* attenuation */
        { ZERO, 1.25f, ZERO },                      /* translation */
        { ZERO, ZERO, ZERO },                       /* rotation */
        { 20.0f, ZERO, 40.0f },                     /* swing */
        { ZERO, ZERO, ZERO },                       /* arc */
        { (float)(TWO_PI/120.0), ZERO, (float)(TWO_PI/60.0) }      /* arc increment */
    },
    {
        { ZERO, ZERO, POINT_TWO, ONE },             /* ambient */
        { ZERO, ZERO, POINT_EIGHT, ONE },           /* diffuse */
        { ZERO, ZERO, POINT_FOUR, ONE },            /* specular */
        { ZERO, ZERO, ZERO, ONE },                  /* position */
        { ZERO, -ONE, ZERO },                       /* direction */
        { 20.0f }, { 60.0f },                       /* exponent, cutoff */
        { ONE, ZERO, ZERO },                        /* attenuation */
        { ZERO, 1.25f, ZERO },                      /* translation */
        { ZERO, ZERO, ZERO },                       /* rotation */
        { 20.0f, ZERO, 40.0f },                     /* swing */
        { ZERO, ZERO, ZERO },                       /* arc */
        { (float)(TWO_PI/50.0), ZERO, (float)(TWO_PI/100.0) }      /* arc increment */
    }
};

void Display( void );
void MyReshape( GLsizei Width, GLsizei Height );

static void
usage(int argc, char **argv)
{
    printf("\n");
    printf("usage: %s [options]\n", argv[0]);
    printf("\n");
    printf("  Options:\n");
    printf("    -geometry Specify size and position WxH+X+Y\n");
    printf("    -lm       Toggle lighting(SPECULAR and AMBIENT are/not same\n");
    printf("\n");
    exit(EXIT_FAILURE);
}

static void
initLights(void)
{
    int k;

    for (k=0; k<NUM_LIGHTS; ++k) {
        int lt = GL_LIGHT0+k;
        Light *light = &spots[k];

        glEnable(lt);
        glLightfv(lt, GL_AMBIENT, light->amb);
        glLightfv(lt, GL_DIFFUSE, light->diff);

        if (useSAME_AMB_SPEC)
            glLightfv(lt, GL_SPECULAR, light->amb);
        else
            glLightfv(lt, GL_SPECULAR, light->spec);

        glLightf(lt, GL_SPOT_EXPONENT, light->spotExp);
        glLightf(lt, GL_SPOT_CUTOFF, light->spotCutoff);
        glLightf(lt, GL_CONSTANT_ATTENUATION, light->atten[0]);
        glLightf(lt, GL_LINEAR_ATTENUATION, light->atten[1]);
        glLightf(lt, GL_QUADRATIC_ATTENUATION, light->atten[2]);
    }
}

static void
aimLights(void)
{
    int k;

    for (k=0; k<NUM_LIGHTS; ++k) {
        Light *light = &spots[k];

        light->rot[0] = light->swing[0] * SINF(light->arc[0]);
        light->arc[0] += light->arcIncr[0];
        if (light->arc[0] > TWO_PI) light->arc[0] -= TWO_PI;

        light->rot[1] = light->swing[1] * SINF(light->arc[1]);
        light->arc[1] += light->arcIncr[1];
        if (light->arc[1] > TWO_PI) light->arc[1] -= TWO_PI;

        light->rot[2] = light->swing[2] * SINF(light->arc[2]);
        light->arc[2] += light->arcIncr[2];
        if (light->arc[2] > TWO_PI) light->arc[2] -= TWO_PI;
    }
}

static void
setLights(void)
{
    int k;

    for (k=0; k<NUM_LIGHTS; ++k) {
        int lt = GL_LIGHT0+k;
        Light *light = &spots[k];

        glPushMatrix();
        glTranslatef(light->trans[0], light->trans[1], light->trans[2]);
        glRotatef(light->rot[0], ONE, ZERO, ZERO);
        glRotatef(light->rot[1], ZERO, ONE, ZERO);
        glRotatef(light->rot[2], ZERO, ZERO, ONE);
        glLightfv(lt, GL_POSITION, light->pos);
        glLightfv(lt, GL_SPOT_DIRECTION, light->spotDir);
        glPopMatrix();
    }
}

static void
drawLights(void)
{
    int k;

    glDisable(GL_LIGHTING);
    for (k=0; k<NUM_LIGHTS; ++k) {
        Light *light = &spots[k];

        glColor4fv(light->diff);

        glPushMatrix();
        glTranslatef(light->trans[0], light->trans[1], light->trans[2]);
        glRotatef(light->rot[0], ONE,  ZERO, ZERO);
        glRotatef(light->rot[1], ZERO, ONE,  ZERO);
        glRotatef(light->rot[2], ZERO, ZERO, ONE);
        glBegin(GL_LINES);
        glVertex3f(light->pos[0], light->pos[1], light->pos[2]);
        glVertex3f(light->spotDir[0], light->spotDir[1], light->spotDir[2]);
        glEnd();
        glPopMatrix();
    }
    glEnable(GL_LIGHTING);
}

static void
drawPlane(int w, int h)
{
    int i, j;
    float dw = ONE/w;
    float dh = ONE/h;

    glNormal3f(ZERO, ZERO, ONE);
    for (j=0; j<h; ++j) {
        glBegin(GL_TRIANGLE_STRIP);
        for (i=0; i<=w; ++i) {
            glVertex2f(dw * i, dh * (j+1));
            glVertex2f(dw * i, dh * j);
        }
        glEnd();
    }
}

int
main(int argc, char **argv)
{
    int width = 300, height = 300;
    int left  = 50,  top = 50;
    int i;

    /* process commmand line args */
    for (i = 1; i < argc; ++i)
    {
        if (!strcmp("-geometry", argv[i]))
        {
            i++;

            if ( !miscParseGeometry(argv[i],
                                    &left,
                                    &top,
                                    &width,
                                    &height )
                )
            {
                usage(argc, argv);
            }
        }
        else if (!strcmp("-lm", argv[i]))
        {
            useSAME_AMB_SPEC = !useSAME_AMB_SPEC;
        }
        else
        {
            usage(argc, argv);
        }
    }

    auxInitPosition( left, top, width, height );
    auxInitDisplayMode( AUX_RGBA | AUX_DOUBLE );
    auxInitWindow( "spotlight swing" );
    auxIdleFunc( Display );
    auxReshapeFunc( MyReshape );

    glMatrixMode(GL_PROJECTION);
    glFrustum(-1.0, 1.0, -1.0, 1.0, 2.0, 6.0);

    glMatrixMode(GL_MODELVIEW);
    glTranslatef(ZERO, ZERO, -THREE);
    glRotatef(45.0f, ONE, ZERO, ZERO);

    glEnable(GL_LIGHTING);
    glEnable(GL_NORMALIZE);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, modelAmb);
    glLightModelf(GL_LIGHT_MODEL_LOCAL_VIEWER, (float)GL_TRUE);
    glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, (float)GL_FALSE);

    glMaterialfv(GL_FRONT, GL_AMBIENT, matAmb);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, matDiff);
    glMaterialfv(GL_FRONT, GL_SPECULAR, matSpec);
    glMaterialfv(GL_FRONT, GL_EMISSION, matEmission);
    glMaterialf(GL_FRONT, GL_SHININESS, TEN);

    initLights();

    auxMainLoop( Display );

    return(0);
}

void
Display( void )
{
    static float spin = ZERO;

    glClear(GL_COLOR_BUFFER_BIT);

    glPushMatrix();
    glRotatef(spin += 0.5f, ZERO, ONE, ZERO);
    if (spin > 360.0f) spin -= 360.0f;

    aimLights();
    setLights();

    glPushMatrix();
    glRotatef(-NINETY, ONE, ZERO, ZERO);
    glScalef(1.9f, 1.9f, ONE);
    glTranslatef(-HALF, -HALF, ZERO);
    drawPlane(16, 16);
    glPopMatrix();

    drawLights();
    glPopMatrix();

    auxSwapBuffers();
}

void
MyReshape( GLsizei Width, GLsizei Height )
{
    glViewport(0, 0, Width, Height);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\misc\scube.c ===
/*
 * 1992 David G Yu -- Silicon Graphics Computer Systems
 */
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <limits.h>
#include <GL/gl.h>
#include "glaux.h"
#include "miscutil.h"
#include "miscflt.h"

#define WINDOW_WIDTH    300
#define WINDOW_HEIGHT   300
#define WINDOW_TOP      30
#define WINDOW_LEFT     10

static int useRGB = 1;
static int useLighting = 1;
static int useFog = 0;
static int useDB = 1;
static int useLogo = 0;
static int useQuads = 1;

#define GREY    0
#define RED     1
#define GREEN   2
#define BLUE    3
#define CYAN    4
#define MAGENTA 5
#define YELLOW  6
#define BLACK   7

static float materialColor[8][4] = {
    { 0.8f, 0.8f, 0.8f, ONE  },
    { 0.8f, ZERO, ZERO, ONE  },
    { ZERO, 0.8f, ZERO, ONE  },
    { ZERO, ZERO, 0.8f, ONE  },
    { ZERO, 0.8f, 0.8f, ONE  },
    { 0.8f, ZERO, 0.8f, ONE  },
    { 0.8f, 0.8f, ZERO, ONE  },
    { ZERO, ZERO, ZERO, 0.4f },
};

static float lightPos[4]    = {  TWO ,  4.0f,  TWO ,  ONE       };
static float lightDir[4]    = { -TWO , -4.0f, -TWO ,  ONE       };
static float lightAmb[4]    = {  0.2f,  0.2f,  0.2f,  ONE       };
static float lightDiff[4]   = {  0.8f,  0.8f,  0.8f,  ONE       };
static float lightSpec[4]   = {  0.4f,  0.4f,  0.4f,  ONE       };
static float groundPlane[4] = {  ZERO,  ONE ,  ZERO,  1.499f    };
static float backPlane[4]   = {  ZERO,  ZERO,  ONE ,  0.899f    };
static float fogColor[4]    = {  ZERO,  ZERO,  ZERO,  ZERO      };
static float fogIndex[1]    = {  ZERO };

static int ColorMapSize = 0;        /* This also tells us if the colormap   */
                                    /* has been initialized                 */

static unsigned char shadowPattern[128] = {
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,     /* 50% Grey */
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55,
    0xaa, 0xaa, 0xaa, 0xaa, 0x55, 0x55, 0x55, 0x55
};

static unsigned char sgiPattern[128] = {
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,     /* SGI Logo */
    0xff, 0xbd, 0xff, 0x83, 0xff, 0x5a, 0xff, 0xef,
    0xfe, 0xdb, 0x7f, 0xef, 0xfd, 0xdb, 0xbf, 0xef,
    0xfb, 0xdb, 0xdf, 0xef, 0xf7, 0xdb, 0xef, 0xef,
    0xfb, 0xdb, 0xdf, 0xef, 0xfd, 0xdb, 0xbf, 0x83,
    0xce, 0xdb, 0x73, 0xff, 0xb7, 0x5a, 0xed, 0xff,
    0xbb, 0xdb, 0xdd, 0xc7, 0xbd, 0xdb, 0xbd, 0xbb,
    0xbe, 0xbd, 0x7d, 0xbb, 0xbf, 0x7e, 0xfd, 0xb3,
    0xbe, 0xe7, 0x7d, 0xbf, 0xbd, 0xdb, 0xbd, 0xbf,
    0xbb, 0xbd, 0xdd, 0xbb, 0xb7, 0x7e, 0xed, 0xc7,
    0xce, 0xdb, 0x73, 0xff, 0xfd, 0xdb, 0xbf, 0xff,
    0xfb, 0xdb, 0xdf, 0x87, 0xf7, 0xdb, 0xef, 0xfb,
    0xf7, 0xdb, 0xef, 0xfb, 0xfb, 0xdb, 0xdf, 0xfb,
    0xfd, 0xdb, 0xbf, 0xc7, 0xfe, 0xdb, 0x7f, 0xbf,
    0xff, 0x5a, 0xff, 0xbf, 0xff, 0xbd, 0xff, 0xc3,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
};

static float cube_vertexes[6][4][4] = {
    { { -ONE , -ONE , -ONE ,  ONE  },
      { -ONE , -ONE ,  ONE ,  ONE  },
      { -ONE ,  ONE ,  ONE ,  ONE  },
      { -ONE ,  ONE , -ONE ,  ONE  } },

    { {  ONE ,  ONE ,  ONE ,  ONE  },
      {  ONE , -ONE ,  ONE ,  ONE  },
      {  ONE , -ONE , -ONE ,  ONE  },
      {  ONE ,  ONE , -ONE ,  ONE  } },

    { { -ONE , -ONE , -ONE ,  ONE  },
      {  ONE , -ONE , -ONE ,  ONE  },
      {  ONE , -ONE ,  ONE ,  ONE  },
      { -ONE , -ONE ,  ONE ,  ONE  } },

    { {  ONE ,  ONE ,  ONE ,  ONE  },
      {  ONE ,  ONE , -ONE ,  ONE  },
      { -ONE ,  ONE , -ONE ,  ONE  },
      { -ONE ,  ONE ,  ONE ,  ONE  } },

    { { -ONE , -ONE , -ONE ,  ONE  },
      { -ONE ,  ONE , -ONE ,  ONE  },
      {  ONE ,  ONE , -ONE ,  ONE  },
      {  ONE , -ONE , -ONE ,  ONE  } },

    { {  ONE ,  ONE ,  ONE ,  ONE  },
      { -ONE ,  ONE ,  ONE ,  ONE  },
      { -ONE , -ONE ,  ONE ,  ONE  },
      {  ONE , -ONE ,  ONE ,  ONE  } }
};

static float cube_normals[6][4] = {
    { -ONE ,  ZERO,  ZERO,  ZERO },
    {  ONE ,  ZERO,  ZERO,  ZERO },
    {  ZERO, -ONE ,  ZERO,  ZERO },
    {  ZERO,  ONE ,  ZERO,  ZERO },
    {  ZERO,  ZERO, -ONE ,  ZERO },
    {  ZERO,  ZERO,  ONE ,  ZERO }
};

void MyInit( void );
void MyReshape( GLsizei Width, GLsizei Height );
void Display( void );
void EnableLighting( void );
void EnableFog( void );
void FogModeLinear( void );
void FogModeExp( void );
void FogModeExp2( void );
void MakeColorMap( void );

static void
usage(int argc, char **argv)
{
    printf("\n");
    printf("usage: %s [options]\n", argv[0]);
    printf("\n");
    printf("    display a spinning cube and its shadow\n");
    printf("\n");
    printf("  Options:\n");
    printf("    -geometry  window size and location\n");
    printf("    -c         toggle color index mode\n");
    printf("    -l         toggle lighting\n");
    printf("    -f         toggle fog\n");
    printf("    -db        toggle double buffering\n");
    printf("    -logo      toggle sgi logo for the shadow pattern\n");
    printf("    -quads     toggle use of GL_QUADS to draw the checkerboard\n");
    printf("\n");
    exit(EXIT_FAILURE);
}

static void
setColor(int c)
{
    if (useLighting) {
        if (useRGB) {
            glMaterialfv(GL_FRONT_AND_BACK,
                         GL_AMBIENT_AND_DIFFUSE, &materialColor[c][0]);
        } else {
            glMaterialfv(GL_FRONT_AND_BACK,
                         GL_COLOR_INDEXES, &materialColor[c][0]);
        }
    } else {
        if (useRGB) {
            glColor4fv(&materialColor[c][0]);
        } else {
            glIndexf(materialColor[c][1]);
        }
    }
}

static void
drawCube(int color)
{
    int i;

    setColor(color);

    for (i = 0; i < 6; ++i)
    {
        glNormal3fv(&cube_normals[i][0]);
        glBegin(GL_POLYGON);
            glVertex4fv(&cube_vertexes[i][0][0]);
            glVertex4fv(&cube_vertexes[i][1][0]);
            glVertex4fv(&cube_vertexes[i][2][0]);
            glVertex4fv(&cube_vertexes[i][3][0]);
        glEnd();
    }
}

static void
drawCheck(int w, int h, int evenColor, int oddColor)
{
    static int     initialized = 0;
    static int     usedLighting = 0;
    static GLuint  checklist = 0;

    if (!initialized || (usedLighting != useLighting))
    {
        static float   square_normal[4] = { ZERO, ZERO, ONE , ZERO };
        static float   square[4][4];
        int    i, j;

        if (!checklist)
        {
            checklist = glGenLists(1);
        }
        glNewList(checklist, GL_COMPILE_AND_EXECUTE);

        if (useQuads) {
            glNormal3fv(square_normal);
            glBegin(GL_QUADS);
        }

        for (j = 0; j < h; ++j)
        {
            for (i = 0; i < w; ++i)
            {
                square[0][0] = (float)( -1.0 + 2.0/w * i     );
                square[0][1] = (float)( -1.0 + 2.0/h * (j+1) );
                square[0][2] = (float)( 0.0                  );
                square[0][3] = (float)( 1.0                  );

                square[1][0] = (float)( -1.0 + 2.0/w * i     );
                square[1][1] = (float)( -1.0 + 2.0/h * j     );
                square[1][2] = (float)( 0.0                  );
                square[1][3] = (float)( 1.0                  );

                square[2][0] = (float)( -1.0 + 2.0/w * (i+1) );
                square[2][1] = (float)( -1.0 + 2.0/h * j     );
                square[2][2] = (float)( 0.0                  );
                square[2][3] = (float)( 1.0                  );

                square[3][0] = (float)( -1.0 + 2.0/w * (i+1) );
                square[3][1] = (float)( -1.0 + 2.0/h * (j+1) );
                square[3][2] = (float)( 0.0                  );
                square[3][3] = (float)( 1.0                  );

                if (i & 1 ^ j & 1) {
                    setColor(oddColor);
                } else {
                    setColor(evenColor);
                }

                if (!useQuads) {
                    glBegin(GL_POLYGON);
                }
                glVertex4fv(&square[0][0]);
                glVertex4fv(&square[1][0]);
                glVertex4fv(&square[2][0]);
                glVertex4fv(&square[3][0]);
                if (!useQuads) {
                    glEnd();
                }
            }
        }

        if (useQuads) {
            glEnd();
        }

        glEndList();

        initialized = 1;
        usedLighting = useLighting;
    }
    else
    {
        glCallList(checklist);
    }
}

static void
myShadowMatrix(float ground[4], float light[4])
{
    float  dot;
    float  shadowMat[4][4];

    dot = ground[0] * light[0] +
          ground[1] * light[1] +
          ground[2] * light[2] +
          ground[3] * light[3];

    shadowMat[0][0] = dot  - light[0] * ground[0];
    shadowMat[1][0] = ZERO - light[0] * ground[1];
    shadowMat[2][0] = ZERO - light[0] * ground[2];
    shadowMat[3][0] = ZERO - light[0] * ground[3];

    shadowMat[0][1] = ZERO - light[1] * ground[0];
    shadowMat[1][1] = dot  - light[1] * ground[1];
    shadowMat[2][1] = ZERO - light[1] * ground[2];
    shadowMat[3][1] = ZERO - light[1] * ground[3];

    shadowMat[0][2] = ZERO - light[2] * ground[0];
    shadowMat[1][2] = ZERO - light[2] * ground[1];
    shadowMat[2][2] = dot  - light[2] * ground[2];
    shadowMat[3][2] = ZERO - light[2] * ground[3];

    shadowMat[0][3] = ZERO - light[3] * ground[0];
    shadowMat[1][3] = ZERO - light[3] * ground[1];
    shadowMat[2][3] = ZERO - light[3] * ground[2];
    shadowMat[3][3] = dot  - light[3] * ground[3];

    glMultMatrixf((const GLfloat*)shadowMat);
}

int
main(int argc, char **argv)
{

    int width   = WINDOW_WIDTH;
    int height  = WINDOW_HEIGHT;
    int top     = WINDOW_TOP;
    int left    = WINDOW_LEFT;
    int i;
    int DisplayMode;

    /* process commmand line args */
    for (i = 1; i < argc; ++i)
    {
	if (!strcmp("-geometry", argv[i]))
	{
            i++;

            if ( !miscParseGeometry(argv[i],
                                    &left,
                                    &top,
                                    &width,
                                    &height )
                )
            {
                usage(argc, argv);
            }
	}
	else if (!strcmp("-c", argv[i]))
	{
	    useRGB = !useRGB;
	}
	else if (!strcmp("-l", argv[i]))
	{
	    useLighting = !useLighting;
	}
	else if (!strcmp("-f", argv[i]))
	{
	    useFog = !useFog;
	}
	else if (!strcmp("-db", argv[i]))
	{
	    useDB = !useDB;
	}
	else if (!strcmp("-logo", argv[i]))
	{
	    useLogo = !useLogo;
	}
	else if (!strcmp("-quads", argv[i]))
	{
	    useQuads = !useQuads;
	}
	else
	{
	    usage(argc, argv);
	}
    }

    auxInitPosition( left, top, width, height );

    DisplayMode  = AUX_DEPTH16;
    DisplayMode |= useRGB ? AUX_RGB    : AUX_INDEX;
    DisplayMode |= useDB  ? AUX_DOUBLE : AUX_SINGLE;

    auxInitDisplayMode( DisplayMode );

    auxInitWindow( *argv );
    auxIdleFunc( Display );
    auxReshapeFunc( MyReshape );

    auxKeyFunc( AUX_L, EnableLighting );
    auxKeyFunc( AUX_l, EnableLighting );
    auxKeyFunc( AUX_F, EnableFog      );
    auxKeyFunc( AUX_f, EnableFog      );
    auxKeyFunc( AUX_1, FogModeLinear  );
    auxKeyFunc( AUX_2, FogModeExp     );
    auxKeyFunc( AUX_3, FogModeExp2    );

    MakeColorMap();
    MyInit();
    auxMainLoop( Display );

    return(0);
}

void
MyInit( void )
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 3.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(ZERO, ZERO, -TWO );

    glEnable(GL_DEPTH_TEST);

    if (useLighting) {
        glEnable(GL_LIGHTING);
    }
    glEnable(GL_LIGHT0);
    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);
    glLightfv(GL_LIGHT0, GL_AMBIENT, lightAmb);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightDiff);
    glLightfv(GL_LIGHT0, GL_SPECULAR, lightSpec);
    /*
    glLightfv(GL_LIGHT0, GL_SPOT_DIRECTION, lightDir);
    glLightf(GL_LIGHT0, GL_SPOT_EXPONENT, 80);
    glLightf(GL_LIGHT0, GL_SPOT_CUTOFF, 25);
    */

    glEnable(GL_NORMALIZE);

    if (useFog) {
        glEnable(GL_FOG);
    }
    glFogfv(GL_FOG_COLOR, fogColor);
    glFogfv(GL_FOG_INDEX, fogIndex);
    glFogf(GL_FOG_MODE, (GLfloat)GL_EXP);
    glFogf(GL_FOG_DENSITY, HALF);
    glFogf(GL_FOG_START, ONE );
    glFogf(GL_FOG_END, THREE);

    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);

    glShadeModel(GL_SMOOTH);

    glBlendFunc(GL_ONE_MINUS_SRC_ALPHA, GL_SRC_ALPHA);
    if (useLogo) {
        glPolygonStipple((const GLubyte *)sgiPattern);
    } else {
        glPolygonStipple((const GLubyte *)shadowPattern);
    }

    glClearColor(ZERO, ZERO, ZERO, ONE );
    glClearIndex(ZERO);
    glClearDepth(1);

}

void
MyReshape( GLsizei Width, GLsizei Height )
{
    glViewport(0, 0, Width, Height);
}

void
Display( void )
{
    static int i = 0;
    GLfloat cubeXform[4][4];

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    glTranslatef(ZERO, -1.5f, ZERO);
    glRotatef(-NINETY, ONE , ZERO, ZERO);
    glScalef(TWO , TWO , TWO );

    drawCheck(6, 6, BLUE, YELLOW);              /* draw ground */
    glPopMatrix();

    glPushMatrix();
    glTranslatef(ZERO, ZERO, -0.9f);
    glScalef(TWO , TWO , TWO );

    drawCheck(6, 6, BLUE, YELLOW);              /* draw back */
    glPopMatrix();

    glPushMatrix();
    glTranslatef(ZERO, 0.2f, ZERO);
    glScalef(0.3f, 0.3f, 0.3f);
    glRotatef((float)((360.0 / (30.0 * 1.0)) * (double)i), ONE , ZERO, ZERO);
    glRotatef((float)((360.0 / (30.0 * 2.0)) * (double)i), ZERO, ONE , ZERO);
    glRotatef((float)((360.0 / (30.0 * 4.0)) * (double)i), ZERO, ZERO, ONE );
    glScalef(ONE , TWO , ONE );
    glGetFloatv(GL_MODELVIEW_MATRIX, (GLfloat *)cubeXform);

    drawCube(RED);                              /* draw cube */
    glPopMatrix();

    glDepthMask(GL_FALSE);
    if (useRGB) {
        glEnable(GL_BLEND);
    } else {
        glEnable(GL_POLYGON_STIPPLE);
    }
    if (useFog) {
        glDisable(GL_FOG);
    }

    glPushMatrix();
    myShadowMatrix(groundPlane, lightPos);
    glTranslatef(ZERO, ZERO, TWO );
    glMultMatrixf((const GLfloat *) cubeXform);

    drawCube(BLACK);                            /* draw ground shadow */
    glPopMatrix();

    glPushMatrix();
    myShadowMatrix(backPlane, lightPos);
    glTranslatef(ZERO, ZERO, TWO);
    glMultMatrixf((const GLfloat *) cubeXform);

    drawCube(BLACK);                            /* draw back shadow */
    glPopMatrix();

    glDepthMask(GL_TRUE);
    if (useRGB) {
        glDisable(GL_BLEND);
    } else {
        glDisable(GL_POLYGON_STIPPLE);
    }
    if (useFog) {
        glEnable(GL_FOG);
    }

    auxSwapBuffers();

    if ( i++ == 120 )
        i = 0;
}

void
EnableLighting( void )
{
    useLighting = !useLighting;
    useLighting ? glEnable(GL_LIGHTING) : glDisable(GL_LIGHTING);
}

void
EnableFog( void )
{
    useFog = !useFog;
    useFog ? glEnable(GL_FOG) : glDisable(GL_FOG);
}

void
FogModeLinear( void )
{
  glFogf(GL_FOG_MODE, (GLfloat)GL_LINEAR);
}

void
FogModeExp( void )
{
    glFogf(GL_FOG_MODE, (GLfloat)GL_EXP);
}

void
FogModeExp2( void )
{
    glFogf(GL_FOG_MODE, (GLfloat)GL_EXP2);
}

void
MakeColorMap( void )
{
    if (!useRGB)
    {
        int  mapSize;
        int  rampSize;
        int  entry;
        int  i;

        mapSize  = auxGetColorMapSize();
        rampSize = mapSize / 8;

        for (entry = 0; entry < mapSize; ++entry)
        {
            int     hue = entry / rampSize;
            float   red, green, blue, val;

            val =  ((float)(entry % rampSize)) / (float)(rampSize-1);

            red   = (hue==0 || hue==1 || hue==5 || hue==6) ? val : 0;
            green = (hue==0 || hue==2 || hue==4 || hue==6) ? val : 0;
            blue  = (hue==0 || hue==3 || hue==4 || hue==5) ? val : 0;

            auxSetOneColor( entry, (float)red, (float)green, (float)blue );
        }

        for (i = 0; i < 8; ++i)
        {
            materialColor[i][0] = (float)(i*rampSize + 0.2 * (rampSize-1));
            materialColor[i][1] = (float)(i*rampSize + 0.8 * (rampSize-1));
            materialColor[i][2] = (float)(i*rampSize + 1.0 * (rampSize-1));
            materialColor[i][3] = ZERO;
        }
        fogIndex[0] = (float)(-0.2 * (rampSize-1));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\misc\miscflt.h ===
#ifndef __MISCFLT_H__
#define __MISCFLT_H__

#define ZERO            (0.0f)
#define POINT_TWO       (0.2f)
#define POINT_FOUR      (0.4f)
#define POINT_EIGHT     (0.8f)
#define HALF            (0.5f)
#define ONE             (1.0f)
#define TWO             (2.0f)
#define THREE           (3.0f)
#define FOUR            (4.0f)
#define FIVE            (5.0f)
#define TEN             (10.0f)
#define NINETY          (90.0f)

#define SINF(x)         ((float)sin(x))


#endif /* __MISCFLT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\phong\auxtea.h ===
/* Rim, body, lid, and bottom data must be reflected in x and y; 
 * handle and spout data across the y axis only.
 */

long patchdata[][16] = {
    {102,103,104,105,4,5,6,7,8,9,10,11,12,13,14,15},		   /* rim */
    {12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27},		   /* body */
    {24,25,26,27,29,30,31,32,33,34,35,36,37,38,39,40},		   /* body */
    {96,96,96,96,97,98,99,100,101,101,101,101,0,1,2,3,},	   /* lid */
    {0,1,2,3,106,107,108,109,110,111,112,113,114,115,116,117},	   /* lid */
    {118,118,118,118,124,122,119,121,123,126,125,120,40,39,38,37}, /* bottom */
    {41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56},		   /* handle */
    {53,54,55,56,57,58,59,60,61,62,63,64,28,65,66,67},		   /* handle */
    {68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83},		   /* spout */
    {80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95}		   /* spout */
};

float cpdata[][3] = {
{0.2,0,2.7},{0.2,-0.112,2.7},{0.112,-0.2,2.7},{0,-0.2,2.7},{1.3375,0,2.53125},
{1.3375,-0.749,2.53125},{0.749,-1.3375,2.53125},{0,-1.3375,2.53125},
{1.4375,0,2.53125},{1.4375,-0.805,2.53125},{0.805,-1.4375,2.53125},
{0,-1.4375,2.53125},{1.5,0,2.4},{1.5,-0.84,2.4},{0.84,-1.5,2.4},{0,-1.5,2.4},
{1.75,0,1.875},{1.75,-0.98,1.875},{0.98,-1.75,1.875},{0,-1.75,1.875},{2,0,1.35},
{2,-1.12,1.35},{1.12,-2,1.35},{0,-2,1.35},{2,0,0.9},{2,-1.12,0.9},{1.12,-2,0.9},
{0,-2,0.9},{-2,0,0.9},{2,0,0.45},{2,-1.12,0.45},{1.12,-2,0.45},{0,-2,0.45},
{1.5,0,0.225},{1.5,-0.84,0.225},{0.84,-1.5,0.225},{0,-1.5,0.225},{1.5,0,0.15},
{1.5,-0.84,0.15},{0.84,-1.5,0.15},{0,-1.5,0.15},{-1.6,0,2.025},{-1.6,-0.3,2.025},
{-1.5,-0.3,2.25},{-1.5,0,2.25},{-2.3,0,2.025},{-2.3,-0.3,2.025},{-2.5,-0.3,2.25},
{-2.5,0,2.25},{-2.7,0,2.025},{-2.7,-0.3,2.025},{-3,-0.3,2.25},{-3,0,2.25},
{-2.7,0,1.8},{-2.7,-0.3,1.8},{-3,-0.3,1.8},{-3,0,1.8},{-2.7,0,1.575},
{-2.7,-0.3,1.575},{-3,-0.3,1.35},{-3,0,1.35},{-2.5,0,1.125},{-2.5,-0.3,1.125},
{-2.65,-0.3,0.9375},{-2.65,0,0.9375},{-2,-0.3,0.9},{-1.9,-0.3,0.6},{-1.9,0,0.6},
{1.7,0,1.425},{1.7,-0.66,1.425},{1.7,-0.66,0.6},{1.7,0,0.6},{2.6,0,1.425},
{2.6,-0.66,1.425},{3.1,-0.66,0.825},{3.1,0,0.825},{2.3,0,2.1},{2.3,-0.25,2.1},
{2.4,-0.25,2.025},{2.4,0,2.025},{2.7,0,2.4},{2.7,-0.25,2.4},{3.3,-0.25,2.4},
{3.3,0,2.4},{2.8,0,2.475},{2.8,-0.25,2.475},{3.525,-0.25,2.49375},
{3.525,0,2.49375},{2.9,0,2.475},{2.9,-0.15,2.475},{3.45,-0.15,2.5125},
{3.45,0,2.5125},{2.8,0,2.4},{2.8,-0.15,2.4},{3.2,-0.15,2.4},{3.2,0,2.4},
{0,0,3.15},{0.8,0,3.15},{0.8,-0.45,3.15},{0.45,-0.8,3.15},{0,-0.8,3.15},
{0,0,2.85},{1.4,0,2.4},{1.4,-0.784,2.4},{0.784,-1.4,2.4},{0,-1.4,2.4},
{0.4,0,2.55},{0.4,-0.224,2.55},{0.224,-0.4,2.55},{0,-0.4,2.55},{1.3,0,2.55},
{1.3,-0.728,2.55},{0.728,-1.3,2.55},{0,-1.3,2.55},{1.3,0,2.4},{1.3,-0.728,2.4},
{0.728,-1.3,2.4},{0,-1.3,2.4},{0,0,0},{1.425,-0.798,0},{1.5,0,0.075},{1.425,0,0},
{0.798,-1.425,0},{0,-1.5,0.075},{0,-1.425,0},{1.5,-0.84,0.075},{0.84,-1.5,0.075}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\misc\miscutil.h ===
#ifndef __MISCUTIL_H__
#define __MISCUTIL_H__

int miscParseGeometry( char *geometry, int *x, int *y, int *width, int *height );
char *miscGetGeometryHelpString( void );

#endif /* __MISCUTIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\puzzle\trackbal.h ===
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * if ox,oy is the window's center and sizex,sizey is its size, then
 * the proper transformation from screen coordinates (sc) to world
 * coordinates (wc) is:
 * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0
 * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
axis_to_quat(float a[3], float phi, float q[4]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\puzzle\trackbal.c ===
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 */
#include <math.h>
#include "trackbal.h"

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void
vzero(float *v)
{
    v[0] = 0.0;
    v[1] = 0.0;
    v[2] = 0.0;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0) t = 1.0;
    if (t < -1.0) t = -1.0;
    phi = 2.0 * asin(t);

    axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,sin(phi/2.0));
    q[3] = cos(phi/2.0);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
	z = sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    int i;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0 - 2.0 * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0 * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0 * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0;

    m[1][0] = 2.0 * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0 - 2.0 * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0;

    m[2][0] = 2.0 * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0 - 2.0 * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\phong\test.cxx ===
/*
 *  This program renders a wireframe Bezier surface,
 *  using two-dimensional evaluators.
 */

#include "testres.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <malloc.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>
#include "auxtea.h"
#include "vector.h"

/****************************************************************/
/* Macros */
/****************************************************************/
#define MIN_SAMPLE 5
#define IMAGE_WIDTH 64
#define IMAGE_HEIGHT 64
#define POLY_TEAPOT 11
#define BEZ_TEAPOT 12
#define COORD_SYS 14

#define MAX_NUM_FRAMES 24
#define __glPi          ((GLfloat) 3.14159265358979323846)
#define __glDegreesToRadians    (__glPi / (GLfloat) 180.0)


/****************************************************************/
/* Typedefs */
/****************************************************************/
typedef struct
{
    GLdouble x, y, z;
} Vertex;

enum _render_type {POLYGON_TEAPOT, GLAUX_TEAPOT, BEZIER_TEAPOT,
                   GLAUX_SSPHERE, GLAUX_WSPHERE, TRIANGLES, LINE, LINES,
                   SQUARE, EVAL};
/****************************************************************/
/* Globals */
/****************************************************************/
HWND g_hWnd;
HMENU g_hMenu;
HANDLE OutputHandle;

GLenum shade_model = GL_PHONG_WIN;
GLenum phong_hint = GL_NICEST;

GLenum cull_face = GL_BACK; 
GLenum front_face = GL_CCW; 
BOOL cull_enable = FALSE;    
BOOL depth_mode = TRUE;    
BOOL timing_enable = FALSE;
BOOL bValidConsole = FALSE;
BOOL doSpin = FALSE;

GLfloat curr_angle=0.0, scale, scale2;
GLint sample = MIN_SAMPLE;
GLint sampleEval = 32;
char drawwithpolys=GL_FALSE ;
BOOL bTexEnable = GL_FALSE, bLightEnable = GL_TRUE;
BOOL bTwoSided = FALSE;
BOOL bColorMaterial = FALSE;
BOOL bNormalize = TRUE;
BOOL bAntiAlias = FALSE;
BOOL bAux = GL_FALSE;
GLfloat sc_x = 1.0, sc_y = 1.0, sc_z = 1.0;

GLint width = IMAGE_WIDTH, height = IMAGE_HEIGHT ;
GLubyte image[3*IMAGE_WIDTH*IMAGE_HEIGHT] ;
GLdouble VTemp ;

GLfloat ctrlpoints[4][4][3] = {
    {{-1.5, -1.5, 0.0}, {-0.5, -1.5, 1.0}, {0.5, -1.5, 1.0}, {1.5, -1.5, 0.0}},
    {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0}, {0.5, -0.5, 3.0}, {1.5, -0.5, 0.0}},
    {{-1.5, 0.5, 1.0},  {-0.5, 0.5, 3.0},  {0.5, 0.5, 3.0},  {1.5, 0.5, 0.0}}, 
    {{-1.5, 1.5, 0.0}, {-0.5, 1.5, 1.0}, {0.5, 1.5, 1.0},  {1.5, 1.5, 0.0}}
};

#if 0
GLfloat ctrlpoints[4][4][3] = {
    {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0},
    {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}},
    {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0},
    {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}},
    {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0},
    {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}},
    {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0},
    {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};
#endif

static DWORD startelapsed, endelapsed;
float  bsecs=0.0, bavg=0.0, bcum=0.0;
DWORD  bnum_frames=0;
float  psecs=0.0, pavg=0.0, pcum=0.0;
DWORD  pnum_frames=0;

GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}},
                          {{1.0, 0.0}, {1.0, 1.0}}} ;

enum _render_type render_type = TRIANGLES;


/****************************************************************/
/* Prototypes */
/****************************************************************/
void display() ;
void BezTeapot(GLfloat) ;
void MouseWheel(AUX_MOUSEWHEEL_EVENTREC *);
void CustomizeWnd (HINSTANCE);
LONG APIENTRY MyWndProc(HWND, UINT, UINT, LONG);
void SubclassWindow (HWND, WNDPROC);
ULONG DbgPrint(PSZ Format, ...);
void DrawTris(void);
void DrawSquare(void);
void DrawLines(void);
void DrawEval(void);
void initEval(void);
void init_texture(void);
/****************************************************************/
/* Code */
/****************************************************************/
void 
MouseWheel(AUX_MOUSEWHEEL_EVENTREC *mw)
//MouseWheel (int fwKeys, int zDelta, int xPos, int yPos)
{
    if (mw->zDelta > 0)
    { 
        sc_x *=1.1;
        sc_y *=1.1;
        sc_z *=1.1;
    }
    else 
    {
        sc_x *=0.9;
        sc_y *=0.9;
        sc_z *=0.9;
    }
}


void loadImage(void)
{
int i, j ;
GLubyte col = 0 ;

    for(i=0; i<width; i++)
        for(j=0; j<height; j++)
            if( ((j/8)%2 && (i/8)%2) || (!((j/8)%2) && !((i/8)%2)) )
            {
                image[(i*height+j)*3] = 127 ;
                image[(i*height+j)*3+1] = 127 ;
                image[(i*height+j)*3+2] = 127 ;
            }
            else
            {
                image[(i*height+j)*3] = 0 ;
                image[(i*height+j)*3+1] = 0 ;
                image[(i*height+j)*3+2] = 0 ;
            }
}


void PolyTeapot(GLfloat scale)
{
FILE *fd;
Vertex *vertices;
int index[3];
int i, dummy;
int num_vertices, num_triangles;
Vertex v1, v2, normal ;

    fd = fopen("teapot.geom","r");
    fscanf(fd, "%d %d %d", &num_vertices, &num_triangles, &dummy);

    vertices = (Vertex *)malloc(num_vertices*sizeof(Vertex));

    for (i=0; i < num_vertices; i++)
    fscanf(fd, "%lf %lf %lf", &vertices[i].x, &vertices[i].y,
           &vertices[i].z);

    glNewList(POLY_TEAPOT, GL_COMPILE) ;
    glPushMatrix ();
    glScalef (scale, scale, scale);
    glTranslatef (0.0, -1.4, 0.0);
    for (i=0; i < num_triangles; i++)
    {
    //glBegin(GL_POLYGON);
    glBegin(GL_TRIANGLES);
        fscanf(fd, "%d %d %d %d", &dummy, &index[0], &index[1], &index[2]);
        index[0]--; index[1]--; index[2]--;
        
        VSub(v1, vertices[index[1]], vertices[index[0]]) ;
        VSub(v2, vertices[index[2]], vertices[index[1]]) ;
        VCross(normal, v2, v1) ;
        VNormalize(normal, normal) ;
        glNormal3d(normal.x, normal.y, normal.z) ;
        glVertex3d(vertices[index[0]].x, vertices[index[0]].y, 
                        vertices[index[0]].z);
        glVertex3d(vertices[index[1]].x, vertices[index[1]].y, 
                        vertices[index[1]].z);
        glVertex3d(vertices[index[2]].x, vertices[index[2]].y, 
                        vertices[index[2]].z);
    glEnd();
    }
    glPopMatrix ();
    glEndList() ;
    DbgPrint("Done, Initializing the displaylist\n") ;
    fclose(fd);
}



void spin(void)
{
    curr_angle+=10.0 ;
    if(curr_angle > 360.0) curr_angle-=360.0 ;
    display() ;

    if (drawwithpolys)
    {
        pnum_frames++;
        pcum += psecs;
        if (pnum_frames == MAX_NUM_FRAMES)
        {
            pavg = pcum/(float)MAX_NUM_FRAMES;
            DbgPrint("Average over %d poly frames: %f secs per frame\n", 
                     MAX_NUM_FRAMES, pavg);
            pnum_frames = 0;
            pcum = 0.0; pavg = 0.0;
        }
    }
    else
    {
        bnum_frames++;
        bcum += bsecs;
        if (bnum_frames == MAX_NUM_FRAMES)
        {
            bavg = bcum/(float)MAX_NUM_FRAMES;
            DbgPrint("Average over %d poly frames: %f secs per frame\n", 
                     MAX_NUM_FRAMES, bavg);
            bnum_frames = 0;
            bcum = 0.0; bavg = 0.0;
        }
    }
}



void toggle(void)
{
    doSpin = !(doSpin) ;
    if (doSpin)
        auxIdleFunc(spin) ;
    else 
        auxIdleFunc(NULL) ;
}

void scale_up(void)
{
  sc_x *=1.1;
  sc_y *=1.1;
  sc_z *=1.1;
}
void scale_down(void)
{
  sc_x *=0.9;
  sc_y *=0.9;
  sc_z *=0.9;
}

void beztype(void)
{
    bAux = !(bAux) ;
}

          
void cull (void)
{
  if (cull_enable)
      glEnable(GL_CULL_FACE);
  else
      glDisable(GL_CULL_FACE);
}


void depth(void)
{
    if (depth_mode) 
    {
        glEnable(GL_DEPTH_TEST);
        glDepthFunc(GL_LESS);
        glDepthMask(GL_TRUE);
    }
    else 
    {
        glDisable(GL_DEPTH_TEST);
        glDepthMask(GL_FALSE);
    }
}


void lighting(void)
{
    if (bLightEnable)
    {
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
    }
    else
    {
        glDisable(GL_LIGHTING);
        glDisable(GL_LIGHT0);
    }
}


void texture(void)
{
    if (bTexEnable)
        glEnable(GL_TEXTURE_2D);
    else
        glDisable(GL_TEXTURE_2D);
}

void init_texture(void)
{
    /* Texture stuff */
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL) ;
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT) ;
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT) ;
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST) ;
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST) ;
    glTexImage2D(GL_TEXTURE_2D, 0, 3, width, height, 0, GL_RGB, 
                 GL_UNSIGNED_BYTE, image) ;
    texture();
}


void initlights(void)
{
    //GLfloat ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat position[] = { 0.0, 0.0, 2.0, 0.0 };
    //GLfloat position[] = { 0.0, 0.0, 2.0, 0.0 };
    GLfloat mat_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
    GLfloat mat_diffuse1[] = { 0.8, 0.5, 0.2, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 60.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_POSITION, position);

    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
    //glMaterialfv(GL_BACK_AND_BACK, GL_DIFFUSE, mat_diffuse1);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, mat_shininess);
}


void DrawCoordSys(GLfloat size)
{
    glNewList(COORD_SYS, GL_COMPILE) ;
    glDisable(GL_LIGHTING); 
    glDisable(GL_LIGHT0); 
    glDisable(GL_TEXTURE_2D);
    glBegin(GL_LINES) ;
        glColor3f(1.0, 0.0, 0.0) ;
        glVertex3f(0.0, 0.0, 0.0) ;
        glVertex3f(1.0*size, 0.0, 0.0) ;

        glColor3f(0.0, 1.0, 0.0) ;
        glVertex3f(0.0, 0.0, 0.0) ;
        glVertex3f(0.0, 1.0*size, 0.0) ;

        glColor3f(0.0, 0.0, 1.0) ;
        glVertex3f(0.0, 0.0, 0.0) ;
        glVertex3f(0.0, 0.0, 1.0*size) ;
    glEnd() ;
    glEndList() ;
}



void display(void)
{
    int i, j;

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    //glRotatef(curr_angle, 1.0, 1.0, 1.0); 
    glRotatef(curr_angle, 0.0, 0.0, 1.0); 
	glScalef (sc_x, sc_y, sc_z);
	
    if (timing_enable)
        startelapsed = GetTickCount();
      
    switch (render_type)
    {
      case GLAUX_TEAPOT:
        auxSolidTeapot(scale2);
        break;
      case BEZIER_TEAPOT:
        BezTeapot(scale) ;
        break;
      case POLYGON_TEAPOT:
        glCallList(POLY_TEAPOT) ; 
        break;
      case GLAUX_SSPHERE:
        auxSolidSphere(scale2);
        break;
      case GLAUX_WSPHERE:
        auxWireSphere(scale2);
        break;
      case TRIANGLES:
        DrawTris();
        break;
      case SQUARE:
        DrawSquare();
        break;
      case LINES:
        DrawLines();
        break;
      case EVAL:
        DrawEval();
        break;
      default:
        break;
    };
    glFlush() ;
    
    if (timing_enable)
    {
        endelapsed = GetTickCount();
        bsecs = (endelapsed - startelapsed) / (float)1000;
        DbgPrint ("Time to draw bezier tpot frame = %f\n", bsecs);
    }
    
    glPopMatrix ();
    auxSwapBuffers();
}

void myinit(void)
{
    glClearColor (0.7, 0.3, 0.1, 1.0);
    glColor3f(0.2, 0.5, 0.8); 
    loadImage() ;

    //DrawCoordSys(5.0) ;
    // BezTeapot(scale) ;
    PolyTeapot(1.0) ;
    auxSolidTeapot(scale2);

    glEnable(GL_AUTO_NORMAL);
    if (bNormalize)
	    glEnable(GL_NORMALIZE);
    else
	    glDisable(GL_NORMALIZE);

    glShadeModel(shade_model);
    //glHint (GL_PHONG_HINT_WIN, phong_hint);

    glFrontFace(front_face);
    glCullFace(cull_face);
    
    if (bAntiAlias)
    {
        glEnable (GL_POLYGON_SMOOTH);
        glEnable (GL_LINE_SMOOTH);
        glEnable (GL_POINT_SMOOTH);
    }
    else
    {
        glDisable (GL_POLYGON_SMOOTH);
        glDisable (GL_LINE_SMOOTH);
        glDisable (GL_POINT_SMOOTH);
    }
 
    depth ();
    cull ();
    initlights ();
    lighting ();
    init_texture ();
    initEval ();
    
    if (bTwoSided)
        glLightModeli (GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    else
        glLightModeli (GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);

    glColorMaterial (GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);

    if (bColorMaterial) 
        glEnable(GL_COLOR_MATERIAL);
    else
        glDisable(GL_COLOR_MATERIAL);
}


void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
    else
	glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void initEval (void)
{
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
        0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glEnable(GL_MAP2_VERTEX_3);

    glMapGrid2f((GLfloat)sampleEval, 0.0, 1.0, (GLfloat)sampleEval, 0.0, 1.0);
    glEnable(GL_AUTO_NORMAL);
}


BOOL CheckExtension(char *extName, char *extString)
{
  /*
   ** Search for extName in the extensions string.  Use of strstr()
   ** is not sufficient because extension names can be prefixes of
   ** other extension names.  Could use strtok() but the constant
   ** string returned by glGetString can be in read-only memory.
   */
  char *p = (char *)extString;
  char *end;
  int extNameLen;

  extNameLen = strlen(extName);
  end = p + strlen(p);

  while (p < end) {
      int n = strcspn(p, " ");
      if ((extNameLen == n) && (strncmp(extName, p, n) == 0)) {
          return GL_TRUE;
      }
      p += (n + 1);
  }
  return GL_FALSE;
}




//*------------------------------------------------------------------------
//| WinMain:
//|     Parameters:
//|         hInstance     - Handle to current Data Segment
//|         hPrevInstance - Always NULL in Win32
//|         lpszCmdLine   - Pointer to command line info
//|         nCmdShow      - Integer value specifying how to start app.,
//|                            (Iconic [7] or Normal [1,5])
//*------------------------------------------------------------------------
int WINAPI WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     lpszCmdLine,
                    int       nCmdShow)
{
int nReturn = 0;
char *exts;
const char *ext_string;
int  new_ext_supported = GL_FALSE;

    scale = 1.0;
    scale2 = 2.0;

    auxInitDisplayMode (AUX_RGB | AUX_DEPTH16 | AUX_DOUBLE);
    //auxInitDisplayMode (AUX_RGB | AUX_DEPTH16 | AUX_SINGLE);
    auxInitPosition (10, 10, 500, 500);
    auxInitWindow ("Test");
    myinit();

    exts = (char *) glGetString (GL_EXTENSIONS);
    DbgPrint ("The extensions available are : %s\n", exts);
    if ( CheckExtension("GL_EXT_bgra", exts) )
        DbgPrint ("GL_EXT_new_extension available\n");
    else
        DbgPrint ("GL_EXT_new_extension not available\n");

    CustomizeWnd(hInstance);

    //bValidConsole = AllocConsole();
    if (bValidConsole)
        OutputHandle = GetStdHandle( STD_OUTPUT_HANDLE );

    auxReshapeFunc (myReshape);
    if (doSpin)
        auxIdleFunc(spin) ;
    else 
        auxIdleFunc(NULL) ;
    auxKeyFunc(AUX_p, toggle) ;
    auxKeyFunc(AUX_l, lighting) ;
    auxKeyFunc(AUX_t, texture) ;
    auxKeyFunc(AUX_a, beztype) ;
    auxKeyFunc(AUX_j, scale_up) ;
    auxKeyFunc(AUX_k, scale_down) ;
    auxMouseWheelFunc(MouseWheel) ;
    auxMainLoop(display);
    return (0);
}



void BezTeapot(GLfloat scale)
{
    float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
    long i, j, k, l;

    //glNewList(BEZ_TEAPOT, GL_COMPILE);
    glPushMatrix ();
    glRotatef(270.0, 1.0, 0.0, 0.0);
    glScalef (scale, scale, scale);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
    for (i = 0; i < 10; i++) 
    {
	    for (j = 0; j < 4; j++)
	        for (k = 0; k < 4; k++) 
		        for (l = 0; l < 3; l++) 
                {
		            p[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
		            q[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
		            if (l == 1) q[j][k][l] *= (float)-1.0;
		            if (i < 6) {
			        r[j][k][l] = cpdata[patchdata[i][j*4+(3-k)]][l];
			        if (l == 0) r[j][k][l] *= (float)-1.0;
			        s[j][k][l] = cpdata[patchdata[i][j*4+k]][l];
			        if (l == 0) s[j][k][l] *= (float)-1.0;
			        if (l == 1) s[j][k][l] *= (float)-1.0;
		         }
	}
	glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 0, 1, 4, 2, &texpts[0][0][0]);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &p[0][0][0]);
	glEnable(GL_MAP2_VERTEX_3); glEnable(GL_MAP2_TEXTURE_COORD_2);
	glMapGrid2f((GLfloat)sample, 0.0, 1.0, (GLfloat)sample, 0.0, 1.0);
	glEvalMesh2(GL_FILL, 0, sample, 0, sample);
	glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &q[0][0][0]);
	glEvalMesh2(GL_FILL, 0, sample, 0, sample);
	if (i < 6) {
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &r[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, sample, 0, sample);
	    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4, 0, 1, 12, 4, &s[0][0][0]);
	    glEvalMesh2(GL_FILL, 0, sample, 0, sample);
	}
    }
    glDisable(GL_MAP2_VERTEX_3); glDisable(GL_MAP2_TEXTURE_COORD_2);
    glPopMatrix ();
    // glEndList();
}

void CustomizeWnd(HINSTANCE hInstance)
{
    if ((g_hWnd = auxGetHWND()) == NULL) 
    {
        OutputDebugString("auxGetHWND() failed\n");
        return;
    }
    
    SubclassWindow (g_hWnd, (WNDPROC) MyWndProc);
    SendMessage(g_hWnd, WM_USER, 0L, 0L);
    g_hMenu = LoadMenu(GetModuleHandle(NULL), MAKEINTRESOURCE(APPMENU));
    SetMenu(g_hWnd, g_hMenu);
    DrawMenuBar(g_hWnd);
    
    return;
}

/**************************************************************************\
*  function:  SubclassWindow
*
*  input parameters:
*   hwnd            - window handle to be subclassed,
*   SubclassWndProc - the new window procedure.
*
\**************************************************************************/
VOID SubclassWindow (HWND hwnd, WNDPROC SubclassWndProc)
{
  LONG pfnOldProc;

  pfnOldProc = GetWindowLong (hwnd, GWL_WNDPROC);

  SetWindowLong (hwnd, GWL_USERDATA, (LONG) pfnOldProc);
  SetWindowLong (hwnd, GWL_WNDPROC,  (LONG) SubclassWndProc);
}


/**************************************************************************\
*
*  function:  MyWndProc
*
*  input parameters:  normal window procedure parameters.
*
\**************************************************************************/
LONG APIENTRY MyWndProc(HWND hwnd, UINT message, UINT wParam, LONG lParam)
{
  WNDPROC     pfnOldProc;
  static UINT uiTmID = 0;
  
  pfnOldProc = (WNDPROC) GetWindowLong (hwnd, GWL_USERDATA);
  switch (message) {

    case WM_INITMENUPOPUP: 
      CheckMenuItem (g_hMenu, MENU_FLAT, 
                     ((shade_model == GL_FLAT)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_GOURAUD, 
                     ((shade_model == GL_SMOOTH)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_PHONG_NICEST, 
                    (((shade_model == GL_PHONG_WIN) &&
                      (phong_hint == GL_NICEST)) ? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_PHONG_FASTEST, 
                    (((shade_model == GL_PHONG_WIN) &&
                      (phong_hint == GL_FASTEST)) ? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_PHONG_DONT_CARE, 
                    (((shade_model == GL_PHONG_WIN) &&
                      (phong_hint == GL_DONT_CARE)) ? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_LIGHTING,
                     ((bLightEnable)? MF_CHECKED:MF_UNCHECKED));
      if (!bLightEnable)
      {
          EnableMenuItem (g_hMenu, MENU_TWO_SIDED, MF_GRAYED);
          EnableMenuItem (g_hMenu, MENU_COLORMATERIAL, MF_GRAYED);
          EnableMenuItem (g_hMenu, MENU_NORMALIZE, MF_GRAYED);
      }
      else
      {
          EnableMenuItem (g_hMenu, MENU_TWO_SIDED, MF_ENABLED);
          EnableMenuItem (g_hMenu, MENU_COLORMATERIAL, MF_ENABLED);
          EnableMenuItem (g_hMenu, MENU_NORMALIZE, MF_ENABLED);
      }
      CheckMenuItem (g_hMenu, MENU_TWO_SIDED,
                     ((bTwoSided)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_COLORMATERIAL,
                     ((bColorMaterial)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_NORMALIZE,
                     ((bNormalize)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_POLY, 
                     ((render_type == POLYGON_TEAPOT)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_BEZ, 
                     ((render_type == BEZIER_TEAPOT)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_AUX,
                     ((render_type == GLAUX_TEAPOT)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_SOLID_SPHERE,
                     ((render_type == GLAUX_SSPHERE)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_WIRE_SPHERE,
                     ((render_type == GLAUX_WSPHERE)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_SQUARE,
                     ((render_type == SQUARE)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_TRIANGLES,
                     ((render_type == TRIANGLES)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_LINES,
                     ((render_type == LINES)? 
                                                 MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_EVAL,
                     ((render_type == EVAL)? 
                                                 MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_DEPTH,
                     ((depth_mode)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_ANTIALIAS,
                     ((bAntiAlias)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_TIMING,
                     ((timing_enable)? MF_CHECKED:MF_UNCHECKED));

      CheckMenuItem (g_hMenu, MENU_TEXTURE_TOGGLE,
                     ((bTexEnable)? MF_CHECKED:MF_UNCHECKED));
      EnableMenuItem (g_hMenu, MENU_TEXTURE_SWAP, MF_GRAYED);
      EnableMenuItem (g_hMenu, MENU_POINT_FILTER, MF_GRAYED);
      EnableMenuItem (g_hMenu, MENU_LINEAR_FILTER, MF_GRAYED);

      if (!cull_enable)
      {
          EnableMenuItem (g_hMenu, MENU_FRONTFACE, MF_GRAYED);
          EnableMenuItem (g_hMenu, MENU_BACKFACE, MF_GRAYED);
          CheckMenuItem (g_hMenu, MENU_CULL, MF_UNCHECKED);
      }
      else
      {
          EnableMenuItem (g_hMenu, MENU_FRONTFACE, MF_ENABLED);
          EnableMenuItem (g_hMenu, MENU_BACKFACE, MF_ENABLED);
          CheckMenuItem (g_hMenu, MENU_CULL, MF_CHECKED);
      }
      
      CheckMenuItem (g_hMenu, MENU_BACKFACE,
                     ((cull_face==GL_BACK)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_FRONTFACE,
                     ((cull_face==GL_FRONT)? MF_CHECKED:MF_UNCHECKED));
      
      CheckMenuItem (g_hMenu, MENU_CCW,
                     ((front_face==GL_CCW)? MF_CHECKED:MF_UNCHECKED));
      CheckMenuItem (g_hMenu, MENU_CW,
                     ((front_face==GL_CW)? MF_CHECKED:MF_UNCHECKED));
      break;
      
    case WM_COMMAND: 

      switch (LOWORD(wParam))
      {
        case MENU_CULL:
          cull_enable = !cull_enable;
          cull ();
          break;  
        case MENU_BACKFACE:
          cull_face = GL_BACK;
          if (cull_enable) glCullFace (cull_face);
          break;  
        case MENU_FRONTFACE:
          cull_face = GL_FRONT;
          if (cull_enable) glCullFace (cull_face);
          break;  
        case MENU_CCW:
          front_face = GL_CCW;
          glFrontFace (front_face);
          break;  
        case MENU_CW:
          front_face = GL_CW;
          glFrontFace (front_face);
          break;  
        case MENU_FLAT:
          shade_model = GL_FLAT;
          glShadeModel (GL_FLAT);
          break;
        case MENU_GOURAUD:
          shade_model = GL_SMOOTH;
          glShadeModel (GL_SMOOTH);
          break;
        case MENU_PHONG_NICEST:
          shade_model = GL_PHONG_WIN;
          phong_hint = GL_NICEST;
          glShadeModel (GL_PHONG_WIN);
          glHint (GL_PHONG_HINT_WIN, GL_NICEST);
          break;
        case MENU_PHONG_FASTEST:
          shade_model = GL_PHONG_WIN;
          phong_hint = GL_FASTEST;
          glShadeModel (GL_PHONG_WIN);
          glHint (GL_PHONG_HINT_WIN, GL_FASTEST);
          break;
        case MENU_PHONG_DONT_CARE:
          shade_model = GL_PHONG_WIN;
          phong_hint = GL_DONT_CARE;
          glShadeModel (GL_PHONG_WIN);
          glHint (GL_PHONG_HINT_WIN, GL_DONT_CARE);
          break;
        case MENU_LIGHTING:
          bLightEnable = !bLightEnable;
          lighting ();
          break;
        case MENU_COLORMATERIAL:
          bColorMaterial = !bColorMaterial;
          if (bColorMaterial) 
              glEnable (GL_COLOR_MATERIAL);
          else
              glDisable (GL_COLOR_MATERIAL);
          break;
        case MENU_NORMALIZE:
          bNormalize = !bNormalize;
          if (bNormalize) 
              glEnable (GL_NORMALIZE);
          else
              glDisable (GL_NORMALIZE);
          break;
        case MENU_TWO_SIDED:
          bTwoSided = !bTwoSided;
          if (bTwoSided)
              glLightModeli (GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
          else
              glLightModeli (GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
        case MENU_DEPTH:
          depth_mode = !depth_mode;
          depth ();
          break;
        case MENU_ANTIALIAS:
          bAntiAlias = !bAntiAlias;
          if (bAntiAlias)
          {
              glEnable (GL_POLYGON_SMOOTH);
              glEnable (GL_LINE_SMOOTH);
              glEnable (GL_POINT_SMOOTH);
          }
          else
          {
              glDisable (GL_POLYGON_SMOOTH);
              glDisable (GL_LINE_SMOOTH);
              glDisable (GL_POINT_SMOOTH);
          }
          break;
        case MENU_TEXTURE_TOGGLE:
          bTexEnable = !bTexEnable;
          texture ();
          break;
        case MENU_TIMING:
          timing_enable = !timing_enable;
          break;
        case MENU_POLY:
          render_type = POLYGON_TEAPOT;
          break;
        case MENU_AUX:
          render_type = GLAUX_TEAPOT;
          break;
        case MENU_SOLID_SPHERE:
          render_type = GLAUX_SSPHERE;
          break;
        case MENU_WIRE_SPHERE:
          render_type = GLAUX_WSPHERE;
          break;
        case MENU_TRIANGLES:
          render_type = TRIANGLES;
          break;
        case MENU_SQUARE:
          render_type = SQUARE;
          break;
        case MENU_LINES:
          render_type = LINES;
          break;
        case MENU_EVAL:
          render_type = EVAL;
          break;
        case MENU_BEZ:
          render_type = BEZIER_TEAPOT;
          break;
        default:
          MessageBox (NULL, "Not yet implemented\r\n", "Warning", MB_OK);
          return 0;
      }
      if (!doSpin)
          InvalidateRect (hwnd, NULL, TRUE);
      break;

    case WM_USER:
    case WM_DESTROY:
    default:
        return (pfnOldProc)(hwnd, message, wParam, lParam);

  } /* end switch */
  //DoGlStuff ();
  
  return 0;        
}

/******************************Public*Routine******************************\
* DbgPrint
*
* Formatted string output to the debugger.
*
\**************************************************************************/

ULONG
DbgPrint(PCH DebugMessage, ...)
{
    va_list ap;
    char buffer[256];
    BOOL success;
    DWORD num_written;
    
    va_start(ap, DebugMessage);

    vsprintf(buffer, DebugMessage, ap);

    if (!bValidConsole)
        OutputDebugStringA(buffer);
    else
        success = WriteConsole (OutputHandle, buffer, strlen(buffer), 
                                &num_written, NULL);
        
    va_end(ap);

    return(0);
}

void
DrawTris(void)
{
    GLfloat mat_specular[] = { 1.0, 0.0, 0.0, 0.0 };

    glBegin (GL_TRIANGLES);
        glColor3f(1.0, 0.0, 0.0);
      //glNormal3d (-0.75, 0.01, 0.0);
      glNormal3d (0.0, 0.0, 1.0);
    glVertex3f (-3.7, 0.1, -0.1);

        glColor3f(0.0, 1.0, 0.0);
      //glNormal3d (0.8, 0.0, 0.0);
      glNormal3d (0.0, -1.0, 0.0);
    glVertex3f (-3.7, -4.0, -0.1);

        glColor3f(0.0, 0.0, 1.0);
      //glNormal3d (0.0, 0.0, 1.0);
      glNormal3d (0.0, 0.0, 1.0);
    glVertex3f (0.0, 0.1, -0.1);
    glEnd ();


#if 0
    //glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
    glBegin (GL_TRIANGLES);
        glColor3f(0.0, 1.0, 0.0);
      //glNormal3d (-0.75, 0.01, 0.0);
    glVertex3f (3.7, 0.1, -0.1);

        glColor3f(0.0, 1.0, 0.0);
      glNormal3d (0.8, 0.0, 0.0);
    glVertex3f (3.7, -4.1, -0.1);

        glColor3f(0.0, 1.0, 0.0);
      glNormal3d (0.0, 0.0, 1.0);
    glVertex3f (0.0, 0.1, -0.1);
    glEnd ();
#endif

    glColor3f(0.2, 0.5, 0.8); 
}

//Drawn CCW
void
DrawSquare(void)
{
    GLfloat mat_specular[] = { 1.0, 0.0, 0.0, 0.0 };
    GLfloat lx, ly, lz;
    GLdouble angle = 60.000 * __glDegreesToRadians;
    

    lz = (GLfloat) cos (angle);
    lx = ly = (GLfloat) sin (angle) * 0.7071067;

    glBegin (GL_POLYGON);
    //glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
          glColor3f(1.0, 0.0, 0.0);
        glTexCoord2f (0.0, 0.0); 
      glNormal3f (-lx, ly, lz);
    glVertex3f (-1.5, 1.5, -0.1);
      //glNormal3d (0.0, 0.0, 1.0);

          glColor3f(0.0, 1.0, 0.0);
        glTexCoord2f (0.0, 1.0); 
      glNormal3f (-lx, -ly, lz);
    glVertex3f (-1.5, -1.5, -0.1);
      //glNormal3d (0.0, -1.0, 0.0);


          glColor3f(0.0, 1.0, 0.0);
        glTexCoord2f (1.0, 1.0); 
      glNormal3f (lx, -ly, lz);
    glVertex3f (1.5, -1.5, -0.1);
      //glNormal3d (0.0, -1.0, 0.0);

          glColor3f(0.0, 1.0, 0.0);
        glTexCoord2f (1.0, 0.0); 
      glNormal3f (lx, ly, lz);
    glVertex3f (1.5, 1.5, -0.1);
      //glNormal3d (0.0, 0.0, 1.0);

    glEnd ();

    glColor3f(0.2, 0.5, 0.8);
}
#if 0
void
DrawSquare(void)
{
    GLfloat mat_specular[] = { 1.0, 0.0, 0.0, 0.0 };

    glBegin (GL_POLYGON);
    //glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, mat_specular);
        glColor3f(1.0, 0.0, 0.0);
      //glNormal3d (-0.5, 0.5, 0.0);
      glNormal3d (0.0, 0.0, 1.0);
    glVertex3f (-3.7, 3.1, -0.1);

        glColor3f(0.0, 1.0, 0.0);
      glNormal3d (0.0, -1.0, 0.0);
      //glNormal3d (-0.5, -0.5, 0.1);
    glVertex3f (-3.7, -3.1, -0.1);


        glColor3f(0.0, 1.0, 0.0);
      glNormal3d (0.0, -1.0, 0.0);
      //glNormal3d (0.5, -0.5, 0.0);
    glVertex3f (3.7, -3.1, -0.1);

        glColor3f(0.0, 1.0, 0.0);
      glNormal3d (0.0, 0.0, 1.0);
      //glNormal3d (0.5, 0.5, 0.0);
    glVertex3f (3.7, 3.1, -0.1);

    glEnd ();

    glColor3f(0.2, 0.5, 0.8); 
}
#endif


void
DrawLines(void)
{
    glBegin (GL_LINES);
      glColor3f(1.0, 0.0, 0.0);
      glNormal3d(0.0, 1.0, 0.0);
    glVertex3f (-1.7, 0.1, -0.1);
      glColor3f(0.0, 1.0, 0.0);
      glNormal3d(0.0, 0.0, 1.0);
    glVertex3f (-1.7, -1.1, -0.1);

      glColor3f(0.0, 0.0, 1.0);
      glNormal3d(0.0, 1.0, 0.0);
    glVertex3f (0.0, 0.0, -0.1);
      glColor3f(0.0, 0.0, 1.0);
      glNormal3d(0.0, 0.0, 1.0);
    glVertex3f (5.0, 0.0, -0.1);

      glColor3f(0.0, 1.0, 0.0);
      glNormal3d(0.0, 1.0, 0.0);
    glVertex3f (0.0, 0.0, -0.1);
      glColor3f(0.0, 1.0, 0.0);
      glNormal3d(0.0, 0.0, 1.0);
    glVertex3f (0.0, 5.0, -0.1);

      glColor3f(1.0, 0.0, 0.0);
      glNormal3d(0.0, 1.0, 0.0);
    glVertex3f (0.0, 0.0, -0.1);
      glColor3f(0.0, 0.0, 1.0);
      glNormal3d(0.0, 0.0, 1.0);
    glVertex3f (0.0, 0.0, -5.1);
    glEnd ();

    glColor3f(0.2, 0.5, 0.8); 
}

void
DrawEval (void)
{
    //glMapGrid2f((GLfloat)sampleEval, 0.0, 1.0, (GLfloat)sampleEval, 0.0, 1.0);
    initEval ();
    glEvalMesh2(GL_FILL,0,sampleEval,0,sampleEval) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\phong\testres.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995, 1996 Microsoft Corporation. All Rights Reserved.
 *
 ***************************************************************************/

#define MENU_ABOUT                      1
#define MENU_EXIT                       2
#define MENU_TEXTURE_TOGGLE             3
#define MENU_TEXTURE_SWAP               4
#define MENU_FULLSCREEN                 7
#define MENU_NEXT_MODE                  8
#define MENU_PREVIOUS_MODE              9
#define MENU_STATS                      10
#define MENU_FLAT                       12
#define MENU_GOURAUD                    13
#define MENU_ZBUFFER                    15
#define MENU_PERSPCORRECT               16
#define MENU_POINT_FILTER               17
#define MENU_LINEAR_FILTER              18
#define MENU_CLEARS                     19
#define MENU_POLY                       20
#define MENU_BEZ                        21
#define MENU_AUX                        22
#define MENU_SPECULAR                   23
#define MENU_LIGHTING                   31
#define MENU_DITHERING                  24
#define MENU_TIMING                     25
#define MENU_ANTIALIAS                  26
#define MENU_DEPTH                      28
#define MENU_FIRST_FORMAT               40
#define MENU_FIRST_DRIVER               100
#define MENU_FIRST_MODE                 200
#define MENU_FILE_OPEN_PMESH            40001
#define IDR_MYACCELERATOR1              40002
#define APPMENU                         40003

#define MENU_CULL                       27
#define MENU_BACKFACE                   47
#define MENU_FRONTFACE                  42
#define MENU_CCW                        43
#define MENU_CW                         44

#define MENU_SOLID_SPHERE               40004
#define MENU_WIRE_SPHERE                40005
#define MENU_TRIANGLES                  40006
#define MENU_LINES                      40007
#define MENU_TWO_SIDED                  40008
#define MENU_SQUARE                     40009

#define MENU_COLORMATERIAL              40010
#define MENU_NORMALIZE                  40011

#define MENU_PHONG_NICEST               40012
#define MENU_PHONG_FASTEST              40013
#define MENU_PHONG_DONT_CARE            40014

#define MENU_EVAL                       40015

#define MENU_ANTIALIAS                  40016

#define IDC_STATIC                     -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\phong\vector.h ===
/****************************************************************************
*                vector.h
*
*  This module contains macros to perform operations on vectors.
*
*****************************************************************************/

/* Misc. Vector Math Macro Definitions */


/* Vector Add */
#define VAdd(a, b, c) {(a).x=(b).x+(c).x;(a).y=(b).y+(c).y;(a).z=(b).z+(c).z;}
#define VAddEq(a, b) {(a).x+=(b).x;(a).y+=(b).y;(a).z+=(b).z;}

/* Vector Subtract */
#define VSub(a, b, c) {(a).x=(b).x-(c).x;(a).y=(b).y-(c).y;(a).z=(b).z-(c).z;}
#define VSubEq(a, b) {(a).x-=(b).x;(a).y-=(b).y;(a).z-=(b).z;}

/* Scale - Multiply Vector by a Scalar */
#define VScale(a, b, k) {(a).x=(b).x*(k);(a).y=(b).y*(k);(a).z=(b).z*(k);}
#define VScaleEq(a, k) {(a).x*=(k);(a).y*=(k);(a).z*=(k);}

/* Inverse Scale - Divide Vector by a Scalar */
#define VInverseScale(a, b, k) {(a).x=(b).x/(k);(a).y=(b).y/(k);(a).z=(b).z/(k);}
#define VInverseScaleEq(a, k) {(a).x/=(k);(a).y/=(k);(a).z/=(k);}

/* Dot Product - Gives Scalar angle (a) between two vectors (b) and (c) */
#define VDot(a, b, c) {a=(b).x*(c).x+(b).y*(c).y+(b).z*(c).z;}

/* Cross Product - returns Vector (a) = (b) x (c) 
   WARNING:  a must be different from b and c.*/
#define VCross(a,b,c) {(a).x=(b).y*(c).z-(b).z*(c).y; \
                       (a).y=(b).z*(c).x-(b).x*(c).z; \
                       (a).z=(b).x*(c).y-(b).y*(c).x;}

/* Evaluate - returns Vector (a) = Multiply Vector (b) by Vector (c) */
#define VEvaluate(a, b, c) {(a).x=(b).x*(c).x;(a).y=(b).y*(c).y;(a).z=(b).z*(c).z;}
#define VEvaluateEq(a, b) {(a).x*=(b).x;(a).y*=(b).y;(a).z*=(b).z;}

/* Divide - returns Vector (a) = Divide Vector (b) by Vector (c) */
#define VDiv(a, b, c) {(a).x=(b).x/(c).x;(a).y=(b).y/(c).y;(a).z=(b).z/(c).z;}
#define VDivEq(a, b) {(a).x/=(b).x;(a).y/=(b).y;(a).z/=(b).z;}

/* Square a Vector */
#define	VSqr(a) {(a).x*(a).x;(a).y*(a).y;(a).z*(a).z;}

/* Simple Scalar Square Macro */
#define	Sqr(a)	((a)*(a))

/* Square a Vector (b) and Assign to another Vector (a) */
#define VSquareTerms(a, b) {(a).x=(b).x*(b).x;(a).y=(b).y*(b).y;(a).z=(b).z*(b).z;}

/* Vector Length - returs Scalar Euclidean Length (a) of Vector (b) */
#define VLength(a, b) {a=sqrt((b).x*(b).x+(b).y*(b).y+(b).z*(b).z);}

/* Normalize a Vector - returns a vector (length of 1) that points at (b) */
#define VNormalize(a,b) {VTemp=sqrt((b).x*(b).x+(b).y*(b).y+(b).z*(b).z);(a).x=(b).x/VTemp;(a).y=(b).y/VTemp;(a).z=(b).z/VTemp;}

/* Compute a Vector (a) Halfway Between Two Given Vectors (b) and (c) */
#define VHalf(a, b, c) {(a).x=0.5*((b).x+(c).x);(a).y=0.5*((b).y+(c).y);(a).z=0.5*((b).z+(c).z);}

/* Linear Combination of vectors, A = b*B + c*C */
#define VComb(A, b, B, c, C) {(A).x=(b)*(B).x+(c)*(C).x;(A).y=(b)*(B).y+(c)*(C).y;(A).z=(b)*(B).z+(c)*(C).z;}

/* Add Scalar Multiple, A = b*B + C */
#define VAddS(A, b, B, C) {(A).x=(b)*(B).x+(C).x;(A).y=(b)*(B).y+(C).y;(A).z=(b)*(B).z+(C).z;}

/* A point on the Ray */
#define RayPoint( ray, t, point )	VAddS(point, t, (ray)->D, (ray)->P )


/* Copy a vector a into b */
#define VCopy(a, b)	{(b).x=(a).x;(b).y=(a).y;(b).z=(a).z;}

/* Negate a vector */
#define VNeg(a, b)	{(a).x=-(b).x;(a).y=-(b).y;(a).z=-(b).z;}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\atmosphe.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#define ATMOSPHERE_EXTERN
#include "atmosphe.h"

const Weather clear("Clear", 0.);
const Weather foggy("Foggy", .04, .5, white, Color(.6, .6, 1), white);
const Weather very_foggy("Very Foggy", .25, .5, white, white, white);
const Weather rainy("Rainy", .01, 1., black, Color(.35, .35, .35), black);

Weather weathers[nweathers] = {clear, foggy, very_foggy, rainy};

const float root3_2 = sqrt(3.) / 2.;

inline float clamp(float a, float min = 0, float max = 1)
{
  if (a < min) return min;
  else if (a > max) return max;
  else return a;
}

Weather::Weather()
{
  strcpy(name, "No name");
  fog_density = 0;
  fog_color = white;
  fog_spread = 1;
  sun_brightness = 1;
  light_sun = GL_LIGHT0;
  light_ambient = GL_LIGHT1;
  sky_top = blue;
  sky_bottom = white;
}

Weather::Weather(const char *n, GLfloat fd, GLfloat fs, Color fc, 
		 Color s1, Color s2, GLfloat sb,
		 GLenum ls, GLenum la)
{
  strcpy(name, n);
  fog_density = fd;
  fog_color = fc;
  fog_spread = fs;
  sun_brightness = sb;
  light_sun = ls;
  light_ambient = la;
  sky_top = s1;
  sky_bottom = s2;
}

Weather::~Weather()
{
}

Weather Weather::operator=(Weather a)
{
  strcpy(name, a.name);

  fog_density = a.fog_density;
  fog_color = a.fog_color;
  fog_spread = a.fog_spread;

  sun_brightness = a.sun_brightness;

  light_sun = a.light_sun;
  light_ambient = a.light_ambient;

  sky_top = a.sky_top;
  sky_bottom = a.sky_bottom;

  return *this;
}

void Weather::apply(Point sun)
{
  Color c;

  if (fog_density != 0) {
    glFogf(GL_FOG_DENSITY, fog_density);
    glFogfv(GL_FOG_COLOR, fog_color.c);
    glFogi(GL_FOG_MODE, GL_EXP2);
  }
  glLightfv(light_sun, GL_AMBIENT, black.c);
  c = white;
  c *= sun_brightness;
  glLightfv(light_sun, GL_DIFFUSE, c.c);
  glLightfv(light_sun, GL_SPECULAR, white.c);
  if (sun.pt[2] >= 0.0) glEnable(light_sun);
  else glDisable(light_sun);

  c = white;
  c *= .25;
  glLightfv(light_ambient, GL_AMBIENT, c.c);
  glLightfv(light_ambient, GL_DIFFUSE, black.c);
  glLightfv(light_ambient, GL_SPECULAR, black.c);
  glEnable(light_ambient);
}

void Weather::draw_sky(Point sun)
{
  Point p;
  float c;
  Color bottom, top;

  if (sun.pt[2] >= .5) c = 1.;
  else if (sun.pt[2] >= -.5) 
    c = sqrt(1. - sun.pt[2]*sun.pt[2])*.5 + sun.pt[2]*root3_2;
  else c = 0;

  bottom = sky_bottom * c;
  top = sky_top * c;

  /* This is drawn as a far-away quad */
  glBegin(GL_QUADS);
  glColor3fv(bottom.c);
  glVertex3f(-1, -1, -1);
  glVertex3f(1, -1, -1);
  glColor3fv(top.c);
  glVertex3f(1, 1, -1);
  glVertex3f(-1, 1, -1);
  glEnd();
}

GLfloat Weather::shadow_blur()
{
  return clamp(fog_density * 10.);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\puzzle\puzzle.c ===
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <malloc.h>
#include <time.h>
#include <math.h>
#include "tk.h"
#include "trackbal.h"

#define WIDTH 4
#define HEIGHT 5
#define PIECES 10
#define OFFSETX -2
#define OFFSETY -2.5
#define OFFSETZ -0.5

typedef char Config[HEIGHT][WIDTH];

struct puzzle {
    struct puzzle *backptr;
    struct puzzle *solnptr;
    Config pieces;
    struct puzzle *next;
    unsigned hashvalue;
};

#define HASHSIZE 10691

struct puzzlelist {
    struct puzzle *puzzle;
    struct puzzlelist *next;
};

static char convert[PIECES+1] = {0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4};

static unsigned char colors[PIECES+1][3] = {
  {  0,  0,  0},
  {255,255,127},
  {255,255,127},
  {255,255,127},
  {255,255,127},
  {255,127,255},
  {255,127,255},
  {255,127,255},
  {255,127,255},
  {255,127,127},
  {255,255,255},
};

static struct puzzle *hashtable[HASHSIZE];
static struct puzzle *startPuzzle;
static struct puzzlelist *puzzles;
static struct puzzlelist *lastentry;

#define MOVE_SPEED 0.2
static unsigned char movingPiece;
static float move_x,move_y;
static float curquat[4];
static int doubleBuffer=1;
static int depth=1;

static char xsize[PIECES+1] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 };
static char ysize[PIECES+1] = { 0, 1, 1, 1, 1, 2, 2, 2, 2, 1, 2 };
static float zsize[PIECES+1] = { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.6 };
static GLuint listbase;

static Config startConfig = {
    {  8, 10, 10,  7 },
    {  8, 10, 10,  7 },
    {  6,  9,  9,  5 },
    {  6,  4,  3,  5 },
    {  2,  0,  0,  1 }
};

static Config thePuzzle = {
    {  8, 10, 10,  7 },
    {  8, 10, 10,  7 },
    {  6,  9,  9,  5 },
    {  6,  4,  3,  5 },
    {  2,  0,  0,  1 }
};

static int xadds[4]={-1, 0, 1, 0};
static int yadds[4]={ 0,-1, 0, 1};

static long W = 400, H = 300;
static GLint viewport[4];

#define srandom srand
#define random() (rand() >> 2)

unsigned hash(Config config)
{
    int i,j,value;

    value=0;
    for (i=0; i<HEIGHT; i++) {
	for (j=0; j<WIDTH; j++) {
	    value=value+convert[config[i][j]];
	    value*=6;
	}
    }
    return(value);
}

int solution(Config config)
{
    if (config[4][1]==10 && config[4][2]==10) return(1);
    return(0);
}

float boxcoords[][3] = {
    { 0.2, 0.2, 0.9 },
    { 0.8, 0.2, 0.9 },
    { 0.8, 0.8, 0.9 },
    { 0.2, 0.8, 0.9 },
    { 0.2, 0.1, 0.8 },
    { 0.8, 0.1, 0.8 },
    { 0.9, 0.2, 0.8 },
    { 0.9, 0.8, 0.8 },
    { 0.8, 0.9, 0.8 },
    { 0.2, 0.9, 0.8 },
    { 0.1, 0.8, 0.8 },
    { 0.1, 0.2, 0.8 },
    { 0.2, 0.1, 0.2 },
    { 0.8, 0.1, 0.2 },
    { 0.9, 0.2, 0.2 },
    { 0.9, 0.8, 0.2 },
    { 0.8, 0.9, 0.2 },
    { 0.2, 0.9, 0.2 },
    { 0.1, 0.8, 0.2 },
    { 0.1, 0.2, 0.2 },
    { 0.2, 0.2, 0.1 },
    { 0.8, 0.2, 0.1 },
    { 0.8, 0.8, 0.1 },
    { 0.2, 0.8, 0.1 },
};

float boxnormals[][3] = {
    { 0, 0, 1 },		/*  0 */
    { 0, 1, 0 },
    { 1, 0, 0 },
    { 0, 0,-1 },
    { 0,-1, 0 },
    {-1, 0, 0 },
    { 0.7071, 0.7071, 0.0000},	/*  6 */
    { 0.7071,-0.7071, 0.0000},
    {-0.7071, 0.7071, 0.0000},
    {-0.7071,-0.7071, 0.0000},
    { 0.7071, 0.0000, 0.7071},	/* 10 */
    { 0.7071, 0.0000,-0.7071},
    {-0.7071, 0.0000, 0.7071},
    {-0.7071, 0.0000,-0.7071},
    { 0.0000, 0.7071, 0.7071},	/* 14 */
    { 0.0000, 0.7071,-0.7071},
    { 0.0000,-0.7071, 0.7071},
    { 0.0000,-0.7071,-0.7071},
    { 0.5774, 0.5774, 0.5774},	/* 18 */
    { 0.5774, 0.5774,-0.5774},
    { 0.5774,-0.5774, 0.5774},
    { 0.5774,-0.5774,-0.5774},
    {-0.5774, 0.5774, 0.5774},
    {-0.5774, 0.5774,-0.5774},
    {-0.5774,-0.5774, 0.5774},
    {-0.5774,-0.5774,-0.5774},
};

int boxfaces[][4] = {
    {  0,  1,  2,  3 },		/*  0 */
    {  9,  8, 16, 17 },
    {  6, 14, 15,  7 },
    { 20, 23, 22, 21 },
    { 12, 13,  5,  4 },
    { 19, 11, 10, 18 },
    {  7, 15, 16,  8 },		/*  6 */
    { 13, 14,  6,  5 },
    { 18, 10,  9, 17 },
    { 19, 12,  4, 11 },
    {  1,  6,  7,  2 },		/* 10 */
    { 14, 21, 22, 15 },
    { 11,  0,  3, 10 },
    { 20, 19, 18, 23 },
    {  3,  2,  8,  9 },		/* 14 */
    { 17, 16, 22, 23 },
    {  4,  5,  1,  0 },
    { 20, 21, 13, 12 },
    {  2,  7,  8, -1 },		/* 18 */
    { 16, 15, 22, -1 },
    {  5,  6,  1, -1 },
    { 13, 21, 14, -1 },
    { 10,  3,  9, -1 },
    { 18, 17, 23, -1 },
    { 11,  4,  0, -1 },
    { 20, 12, 19, -1 },
};

#define NBOXFACES (sizeof(boxfaces)/sizeof(boxfaces[0]))

/* Draw a box.  Bevel as desired. */
void drawBox(int piece, float xoff, float yoff)
{
    int xlen, ylen;
    int i,j,k;
    float x,y,z;
    float zlen;
    float *v;

    xlen=xsize[piece];
    ylen=ysize[piece];
    zlen=zsize[piece];

    glColor3ubv(colors[piece]);
    glBegin(GL_QUADS);
    for (i=0; i<18; i++) {
	glNormal3fv(boxnormals[i]);
	for (k=0; k<4; k++) {
	    if (boxfaces[i][k] == -1) continue;
	    v=boxcoords[boxfaces[i][k]];
	    x=v[0] + OFFSETX;
	    if (v[0] > 0.5) x += xlen-1;
	    y=v[1] + OFFSETY;
	    if (v[1] > 0.5) y += ylen-1;
	    z=v[2] + OFFSETZ;
	    if (v[2] > 0.5) z += zlen-1;
	    glVertex3f(xoff+x,yoff+y,z);
	}
    }
    glEnd();
    glBegin(GL_TRIANGLES);
    for (i=18; i<NBOXFACES; i++) {
	glNormal3fv(boxnormals[i]);
	for (k=0; k<3; k++) {
	    if (boxfaces[i][k] == -1) continue;
	    v=boxcoords[boxfaces[i][k]];
	    x=v[0] + OFFSETX;
	    if (v[0] > 0.5) x += xlen-1;
	    y=v[1] + OFFSETY;
	    if (v[1] > 0.5) y += ylen-1;
	    z=v[2] + OFFSETZ;
	    if (v[2] > 0.5) z += zlen-1;
	    glVertex3f(xoff+x,yoff+y,z);
	}
    }
    glEnd();
}

float containercoords[][3] = {
    { -0.1, -0.1,  1.0 },
    { -0.1, -0.1, -0.1 },
    {  4.1, -0.1, -0.1 },
    {  4.1, -0.1,  1.0 },
    {  1.0, -0.1,  0.6 },	/*  4 */
    {  3.0, -0.1,  0.6 },
    {  1.0, -0.1,  0.0 },
    {  3.0, -0.1,  0.0 },
    {  1.0,  0.0,  0.0 },	/*  8 */
    {  3.0,  0.0,  0.0 },
    {  3.0,  0.0,  0.6 },
    {  1.0,  0.0,  0.6 },
    {  0.0,  0.0,  1.0 },	/* 12 */
    {  4.0,  0.0,  1.0 },
    {  4.0,  0.0,  0.0 },
    {  0.0,  0.0,  0.0 },
    {  0.0,  5.0,  0.0 },	/* 16 */
    {  0.0,  5.0,  1.0 },
    {  4.0,  5.0,  1.0 },
    {  4.0,  5.0,  0.0 },
    { -0.1,  5.1, -0.1 },	/* 20 */
    {  4.1,  5.1, -0.1 },
    {  4.1,  5.1,  1.0 },
    { -0.1,  5.1,  1.0 },
};

float containernormals[][3] = {
    { 0,-1, 0 },
    { 0,-1, 0 },
    { 0,-1, 0 },
    { 0,-1, 0 },
    { 0,-1, 0 },
    { 0, 1, 0 },
    { 0, 1, 0 },
    { 0, 1, 0 },
    { 1, 0, 0 },
    { 1, 0, 0 },
    { 1, 0, 0 },
    {-1, 0, 0 },
    {-1, 0, 0 },
    {-1, 0, 0 },
    { 0, 1, 0 }, 
    { 0, 0,-1 },
    { 0, 0,-1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
    { 0, 0, 1 },
};

int containerfaces[][4] = {
    {  1,  6,  4,  0 },
    {  0,  4,  5,  3 },
    {  1,  2,  7,  6 },
    {  7,  2,  3,  5 },
    { 16, 19, 18, 17 },

    { 23, 22, 21, 20 },
    { 12, 11,  8, 15 },
    { 10, 13, 14,  9 },

    { 15, 16, 17, 12 },
    {  2, 21, 22,  3 },
    {  6,  8, 11,  4 },

    {  1,  0, 23, 20 },
    { 14, 13, 18, 19 },
    {  9,  7,  5, 10 },

    { 12, 13, 10, 11 },	

    {  1, 20, 21,  2 },
    {  4, 11, 10,  5 },

    { 15,  8, 19, 16 },
    { 19,  8,  9, 14 },
    {  8,  6,  7,  9 },
    {  0,  3, 13, 12 },
    { 13,  3, 22, 18 },
    { 18, 22, 23, 17 },
    { 17, 23,  0, 12 },
};

#define NCONTFACES (sizeof(containerfaces)/sizeof(containerfaces[0]))

/* Draw the container */
void drawContainer(void)
{
    int i,k;
    float *v;

    /* Y is reversed here because the model has it reversed */

    /* Arbitrary bright wood-like color */
    glColor3ub(209, 103, 23);
    glBegin(GL_QUADS);
    for (i=0; i<NCONTFACES; i++) {
	v=containernormals[i];
	glNormal3f(v[0], -v[1], v[2]);
	for (k=3; k>=0; k--) {
	    v=containercoords[containerfaces[i][k]];
	    glVertex3f(v[0]+OFFSETX, -(v[1]+OFFSETY), v[2]+OFFSETZ);
	}
    }
    glEnd();
}

void drawAll(int withTags)
{
    int i,j;
    int piece;
    char done[PIECES+1];
    float m[4][4];

    build_rotmatrix(m, curquat); 
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0,0,10, 0,0,0, 0,-1,0);
    glMultMatrixf(&(m[0][0]));

    if (depth) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    } else {
	glClear(GL_COLOR_BUFFER_BIT);
    }
    for (i=1; i <= PIECES; i++) {
	done[i] = 0;
    }
    glLoadName(0);
    drawContainer();
    for (i=0; i<HEIGHT; i++) {
	for (j=0; j<WIDTH; j++) {
	    piece = thePuzzle[i][j];
	    if (piece == 0) continue;
	    if (done[piece]) continue;
	    done[piece] = 1;
	    glLoadName(piece);
	    if (piece == movingPiece) {
		drawBox(piece, move_x, move_y);
	    } else {
		drawBox(piece, j, i);
	    }
	}
    }
}

void redraw(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1.0, 0.1, 100.0);

    drawAll(GL_FALSE);

    if (doubleBuffer) tkSwapBuffers();
}

void solidifyChain(struct puzzle *puzzle)
{
    int i;

    i=0;
    while (puzzle->backptr) {
	i++;
	puzzle->backptr->solnptr = puzzle;
	puzzle=puzzle->backptr;
    }
    printf("%d moves to complete!\n", i);
}

int addConfig(Config config, struct puzzle *back)
{
    unsigned hashvalue;
    struct puzzle *newpiece;
    struct puzzlelist *newlistentry;

    hashvalue=hash(config);

    newpiece=hashtable[hashvalue % HASHSIZE];
    while (newpiece != NULL) {
	if (newpiece->hashvalue == hashvalue) {
	    int i,j;

	    for (i=0; i<WIDTH; i++) {
		for (j=0; j<HEIGHT; j++) {
		    if (convert[config[j][i]] != 
		        convert[newpiece->pieces[j][i]]) goto nomatch;
		}
	    }
	    return 0;
	}
nomatch:
	newpiece=newpiece->next;
    }

    newpiece=(struct puzzle *) malloc(sizeof(struct puzzle));
    newpiece->next=hashtable[hashvalue % HASHSIZE];
    newpiece->hashvalue=hashvalue;
    memcpy(newpiece->pieces, config, HEIGHT*WIDTH);
    newpiece->backptr=back;
    newpiece->solnptr=NULL;
    hashtable[hashvalue % HASHSIZE]=newpiece;

    newlistentry=(struct puzzlelist *) malloc(sizeof(struct puzzlelist));
    newlistentry->puzzle=newpiece;
    newlistentry->next=NULL;

    if (lastentry) {
	lastentry->next=newlistentry;
    } else {
	puzzles=newlistentry;
    }
    lastentry=newlistentry;

    if (back == NULL) {
	startPuzzle = newpiece;
    }

    if (solution(config)) {
	solidifyChain(newpiece);
	return 1;
    }

    return 0;
}

/* Checks if a space can move */
int canmove0(Config pieces, int x, int y, int dir, Config newpieces) 
{
    char piece;
    int xadd, yadd;
    int l,m;

    xadd=xadds[dir];
    yadd=yadds[dir];

    if (x+xadd<0 || x+xadd>=WIDTH ||
	y+yadd<0 || y+yadd>=HEIGHT) return 0;
    piece=pieces[y+yadd][x+xadd];
    if (piece==0) return 0;
    memcpy(newpieces, pieces, HEIGHT*WIDTH);
    for (l=0; l<WIDTH; l++) { 
	for (m=0; m<HEIGHT; m++) {
	    if (newpieces[m][l]==piece)
		newpieces[m][l]=0;
	}
    }
    xadd= -xadd;
    yadd= -yadd;
    for (l=0; l<WIDTH; l++) { 
	for (m=0; m<HEIGHT; m++) {
	    if (pieces[m][l]==piece) {
		int newx, newy;

		newx=l+xadd;
		newy=m+yadd;
		if (newx<0 || newx>=WIDTH ||
		    newy<0 || newy>=HEIGHT) return 0;
		if (newpieces[newy][newx] != 0) return 0;
		newpieces[newy][newx]=piece;
	    }
	}
    }
    return 1;
}

/* Checks if a piece can move */
int canmove(Config pieces, int x, int y, int dir, Config newpieces) 
{
    int xadd, yadd;

    xadd=xadds[dir];
    yadd=yadds[dir];

    if (x+xadd<0 || x+xadd>=WIDTH ||
	y+yadd<0 || y+yadd>=HEIGHT) return 0;
    if (pieces[y+yadd][x+xadd] == pieces[y][x]) {
	return canmove(pieces, x+xadd, y+yadd, dir, newpieces);
    }
    if (pieces[y+yadd][x+xadd] != 0) return 0;
    return canmove0(pieces, x+xadd, y+yadd, (dir+2) % 4, newpieces);
}

int generateNewConfigs(struct puzzle *puzzle)
{
    int i,j,k;
    Config pieces;
    Config newpieces;

    memcpy(pieces, puzzle->pieces, HEIGHT*WIDTH);
    for (i=0; i<WIDTH; i++) {
	for (j=0; j<HEIGHT; j++) {
	    if (pieces[j][i] == 0) {
		for (k=0; k<4; k++) {
		    if (canmove0(pieces, i, j, k, newpieces)) {
			if (addConfig(newpieces, puzzle)) return 1;
		    }
		}
	    }
	}
    }
    return 0;
}

void freeSolutions(void)
{
    struct puzzlelist *nextpuz;
    struct puzzle *puzzle, *next;
    int i;

    while (puzzles) {
	nextpuz = puzzles->next;
	free((char *) puzzles);
	puzzles=nextpuz;
    }
    lastentry = NULL;
    for (i=0; i<HASHSIZE; i++) {
	puzzle = hashtable[i];
	hashtable[i] = NULL;
	while (puzzle) {
	    next = puzzle->next;
	    free((char *) puzzle);
	    puzzle = next;
	}
    }
    startPuzzle = NULL;
}

int continueSolving(void)
{
    struct puzzle *nextpuz;    
    int i,j;
    int movedPiece;
    int movedir;
    int fromx, fromy;
    int tox, toy;

    if (startPuzzle == NULL) return 0;
    if (startPuzzle->solnptr == NULL) {
	freeSolutions();
	return 0;
    }

    nextpuz = startPuzzle->solnptr;
    movedPiece=0;
    movedir=0;
    for (i=0; i<HEIGHT; i++) {
	for (j=0; j<WIDTH; j++) {
	    if (startPuzzle->pieces[i][j] != nextpuz->pieces[i][j]) {
		if (startPuzzle->pieces[i][j]) {
		    movedPiece=startPuzzle->pieces[i][j];
		    fromx=j;
		    fromy=i;
		    if (i<HEIGHT-1 && nextpuz->pieces[i+1][j] == movedPiece) {
			movedir=3;
		    } else {
			movedir=2;
		    }
		    goto found_piece;
		} else {
		    movedPiece=nextpuz->pieces[i][j];
		    if (i<HEIGHT-1 && 
			    startPuzzle->pieces[i+1][j] == movedPiece) {
			fromx=j;
			fromy=i+1;
			movedir=1;
		    } else {
			fromx=j+1;
			fromy=i;
			movedir=0;
		    }
		    goto found_piece;
		}
	    }
	}
    }
    printf("What!  No change?\n");
    freeSolutions();
    return 0;

found_piece:
    if (!movingPiece) {
	movingPiece = movedPiece;
	move_x = fromx;
	move_y = fromy;
    }
    move_x += xadds[movedir] * MOVE_SPEED;
    move_y += yadds[movedir] * MOVE_SPEED;

    tox = fromx + xadds[movedir];
    toy = fromy + yadds[movedir];

    if (move_x > tox - MOVE_SPEED/2 && move_x < tox + MOVE_SPEED/2 &&
	    move_y > toy - MOVE_SPEED/2 && move_y < toy + MOVE_SPEED/2) {
	startPuzzle = nextpuz;
	movingPiece=0;
    }

    memcpy(thePuzzle, startPuzzle->pieces, HEIGHT*WIDTH);
    return 1;
}

int solvePuzzle(void)
{
    struct puzzlelist *nextpuz;
    int i;

    if (solution(thePuzzle)) {
	printf("Puzzle already solved!\n");
	return 0;
    }
    addConfig(thePuzzle, NULL);
    i=0;

    while (puzzles) {
	i++;
	if (generateNewConfigs(puzzles->puzzle)) break;
	nextpuz=puzzles->next;
	free((char *) puzzles);
	puzzles=nextpuz;
    }
    if (puzzles == NULL) {
	freeSolutions();
	printf("I can't solve it! (%d positions examined)\n", i);
	return 1;
    }
    return 1;
}

int selectPiece(int mousex, int mousey) 
{
    long hits;
    GLuint selectBuf[1024];
    GLuint closest;
    GLuint dist;

    glSelectBuffer(1024, selectBuf);
    (void) glRenderMode(GL_SELECT);
    glInitNames();

    /* Because LoadName() won't work with no names on the stack */
    glPushName(-1);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPickMatrix(mousex, H-mousey, 4, 4, viewport);
    gluPerspective(45, 1.0, 0.1, 100.0);

    drawAll(GL_TRUE);

    hits = glRenderMode(GL_RENDER);
    if (hits <= 0) {
	return 0;
    }

    closest=0;
    dist=4294967295;
    while (hits) {
	if (selectBuf[(hits-1)*4+1] < dist) {
	    dist = selectBuf[(hits-1)*4+1];
	    closest = selectBuf[(hits-1)*4+3];
	}
	hits--;
    }
    return closest;
}

void nukePiece(int piece)
{
    int i,j;

    for (i=0; i<HEIGHT; i++) {
	for (j=0; j<WIDTH; j++) {
	    if (thePuzzle[i][j] == piece) {
		thePuzzle[i][j] = 0;
	    }
	}
    }
}

void multMatrices(const GLfloat a[16], const GLfloat b[16], GLfloat r[16])
{
    int i, j;

    for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
            r[i*4+j] =
                a[i*4+0]*b[0*4+j] +
                a[i*4+1]*b[1*4+j] +
                a[i*4+2]*b[2*4+j] +
                a[i*4+3]*b[3*4+j];
        }
    }
}

void makeIdentity(GLfloat m[16])
{
    m[0+4*0] = 1; m[0+4*1] = 0; m[0+4*2] = 0; m[0+4*3] = 0;
    m[1+4*0] = 0; m[1+4*1] = 1; m[1+4*2] = 0; m[1+4*3] = 0;
    m[2+4*0] = 0; m[2+4*1] = 0; m[2+4*2] = 1; m[2+4*3] = 0;
    m[3+4*0] = 0; m[3+4*1] = 0; m[3+4*2] = 0; m[3+4*3] = 1;
}

/*
** inverse = invert(src)
*/
int invertMatrix(const GLfloat src[16], GLfloat inverse[16])
{
    int i, j, k, swap;
    double t;
    GLfloat temp[4][4];

    for (i=0; i<4; i++) {
	for (j=0; j<4; j++) {
	    temp[i][j] = src[i*4+j];
	}
    }
    makeIdentity(inverse);

    for (i = 0; i < 4; i++) {
	/*
	** Look for largest element in column
	*/
	swap = i;
	for (j = i + 1; j < 4; j++) {
	    if (fabs(temp[j][i]) > fabs(temp[i][i])) {
		swap = j;
	    }
	}

	if (swap != i) {
	    /*
	    ** Swap rows.
	    */
	    for (k = 0; k < 4; k++) {
		t = temp[i][k];
		temp[i][k] = temp[swap][k];
		temp[swap][k] = t;

		t = inverse[i*4+k];
		inverse[i*4+k] = inverse[swap*4+k];
		inverse[swap*4+k] = t;
	    }
	}

	if (temp[i][i] == 0) {
	    /*
	    ** No non-zero pivot.  The matrix is singular, which shouldn't
	    ** happen.  This means the user gave us a bad matrix.
	    */
	    return 0;
	}

	t = temp[i][i];
	for (k = 0; k < 4; k++) {
	    temp[i][k] /= t;
	    inverse[i*4+k] /= t;
	}
	for (j = 0; j < 4; j++) {
	    if (j != i) {
		t = temp[j][i];
		for (k = 0; k < 4; k++) {
		    temp[j][k] -= temp[i][k]*t;
		    inverse[j*4+k] -= inverse[i*4+k]*t;
		}
	    }
	}
    }
    return 1;
}

/*
** This is a screwball function.  What it does is the following:
** Given screen x and y coordinates, compute the corresponding object space 
**   x and y coordinates given that the object space z is 0.9 + OFFSETZ.
** Since the tops of (most) pieces are at z = 0.9 + OFFSETZ, we use that 
**   number.
*/
int computeCoords(int piece, int mousex, int mousey, 
	GLfloat *selx, GLfloat *sely)
{
    GLfloat modelMatrix[16];
    GLfloat projMatrix[16];
    GLfloat finalMatrix[16];
    GLfloat in[4];
    GLfloat a,b,c,d;
    GLfloat top, bot;
    GLfloat z;
    GLfloat w;
    GLfloat height;

    if (piece == 0) return 0;
    height = zsize[piece] - 0.1 + OFFSETZ;

    glGetFloatv(GL_PROJECTION_MATRIX, projMatrix);
    glGetFloatv(GL_MODELVIEW_MATRIX, modelMatrix);
    multMatrices(modelMatrix, projMatrix, finalMatrix);
    if (!invertMatrix(finalMatrix, finalMatrix)) return 0;

    in[0] = (2.0 * (mousex - viewport[0]) / viewport[2]) - 1;
    in[1] = (2.0 * ((H - mousey) - viewport[1]) / viewport[3]) - 1;

    a = in[0] * finalMatrix[0*4+2] +
	    in[1] * finalMatrix[1*4+2] + 
	    finalMatrix[3*4+2];
    b = finalMatrix[2*4+2];
    c = in[0] * finalMatrix[0*4+3] +
	    in[1] * finalMatrix[1*4+3] +
	    finalMatrix[3*4+3];
    d = finalMatrix[2*4+3];

    /* 
    ** Ok, now we need to solve for z:
    **   (a + b z) / (c + d z) = height.
    ** ("height" is the height in object space we want to solve z for)
    **
    ** ==>  a + b z = height c + height d z
    **      bz - height d z = height c - a
    **      z = (height c - a) / (b - height d)
    */
    top = height * c - a;
    bot = b - height * d;
    if (bot == 0.0) return 0;

    z = top / bot;

    /* 
    ** Ok, no problem.
    ** Now we solve for x and y.  We know that w = c + d z, so we compute it.
    */
    w = c + d * z;

    /*
    ** Now for x and y:
    */
    *selx = (in[0] * finalMatrix[0*4+0] +
	    in[1] * finalMatrix[1*4+0] +
	    z * finalMatrix[2*4+0] +
	    finalMatrix[3*4+0]) / w - OFFSETX;
    *sely = (in[0] * finalMatrix[0*4+1] +
	    in[1] * finalMatrix[1*4+1] +
	    z * finalMatrix[2*4+1] +
	    finalMatrix[3*4+1]) / w - OFFSETY;
    return 1;
}

static int selected;
static int selectx, selecty;
static float selstartx, selstarty;

void grabPiece(int piece, float selx, float sely)
{
    int hit;

    selectx=selx;
    selecty=sely;
    if (selectx < 0 || selecty < 0 || selectx >= WIDTH || selecty >= HEIGHT) {
	return;
    }
    hit = thePuzzle[selecty][selectx];
    if (hit != piece) return;
    if (hit) {
	movingPiece=hit;
	while (selectx > 0 && thePuzzle[selecty][selectx-1] == movingPiece) {
	    selectx--;
	}
	while (selecty > 0 && thePuzzle[selecty-1][selectx] == movingPiece) {
	    selecty--;
	}
	move_x=selectx;
	move_y=selecty;
	selected=1;
	selstartx=selx;
	selstarty=sely;
    } else {
	selected=0;
    }
}

void moveSelection(float selx, float sely)
{
    float deltax, deltay;
    int dir;
    Config newpieces;

    if (!selected) return;
    deltax = selx - selstartx;
    deltay = sely - selstarty;

    if (fabs(deltax) > fabs(deltay)) {
	deltay = 0;
	if (deltax > 0) {
	    if (deltax > 1) deltax = 1;
	    dir = 2;
	} else {
	    if (deltax < -1) deltax = -1;
	    dir = 0;
	}
    } else {
	deltax = 0;
	if (deltay > 0) {
	    if (deltay > 1) deltay = 1;
	    dir = 3;
	} else {
	    if (deltay < -1) deltay = -1;
	    dir = 1;
	}
    }
    if (canmove(thePuzzle, selectx, selecty, dir, newpieces)) {
	move_x = deltax + selectx;
	move_y = deltay + selecty;
	if (deltax > 0.5) {
	    memcpy(thePuzzle, newpieces, HEIGHT*WIDTH);
	    selectx++;
	    selstartx++;
	} else if (deltax < -0.5) {
	    memcpy(thePuzzle, newpieces, HEIGHT*WIDTH);
	    selectx--;
	    selstartx--;
	} else if (deltay > 0.5) {
	    memcpy(thePuzzle, newpieces, HEIGHT*WIDTH);
	    selecty++;
	    selstarty++;
	} else if (deltay < -0.5) {
	    memcpy(thePuzzle, newpieces, HEIGHT*WIDTH);
	    selecty--;
	    selstarty--;
	}
    } else {
	if (deltay > 0 && thePuzzle[selecty][selectx] == 10 &&
		selectx == 1 && selecty == 3) {
	    /* Allow visual movement of solution piece outside of the box */
	    move_x = selectx;
	    move_y = sely - selstarty + selecty;
	} else {
	    move_x = selectx;
	    move_y = selecty;
	}
    }
}

void dropSelection(void)
{
    if (!selected) return;
    movingPiece = 0;
    selected = 0;
}

static int left_mouse, right_mouse;
static int mousex, mousey;
static int solving;
static int spinning;
static float lastquat[4];
static int sel_piece;

static void Reshape(int width, int height)
{

    W = width;
    H = height;
    glViewport(0, 0, W, H);
    glGetIntegerv(GL_VIEWPORT, viewport);
}

static GLenum Key(int key, GLenum mask)
{
    int piece;
    int x, y;

    if (!left_mouse && !right_mouse) {
	switch(key) {
	  case TK_ESCAPE:
	    tkQuit();
	  case TK_d:
	  case TK_D:
	    if (solving) {
		freeSolutions();
		solving=0;
		movingPiece=0;
	    }
	    tkGetMouseLoc(&x, &y);
	    piece = selectPiece(x, y);
	    if (piece) {
		nukePiece(piece);
	    }
	    break;
	  case TK_S:
	  case TK_s:
	    if (solving) {
		freeSolutions();
		solving=0;
		movingPiece=0;
	    } else {
		printf("Solving...\n");
		if (solvePuzzle()) {
		    solving = 1;
		}
	    }
	    break;
	  case TK_R:
	  case TK_r:
	    if (solving) {
		freeSolutions();
		solving=0;
		movingPiece=0;
	    }
	    memcpy(thePuzzle, startConfig, HEIGHT*WIDTH);
	    break;
	  case TK_b:
	  case TK_B:
	    depth=1-depth;
	    if (depth) {
		glEnable(GL_DEPTH_TEST);
	    } else {
		glDisable(GL_DEPTH_TEST);
	    }
	    break;
	  default:
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

static GLenum MouseUp(int mouseX, int mouseY, GLenum button)
{

    if (button & TK_LEFTBUTTON) {
	left_mouse = GL_FALSE;
	dropSelection();
	return GL_TRUE;
    } else if (button & TK_RIGHTBUTTON) {
	right_mouse = GL_FALSE;
	return GL_TRUE;
    }
    return GL_FALSE;
}

static GLenum MouseDown(int mouseX, int mouseY, GLenum button)
{
    int piece;
    float selx, sely;

    mousex = mouseX;
    mousey = mouseY;
    if (button & TK_LEFTBUTTON) {
	if (solving) {
	    freeSolutions();
	    solving=0;
	    movingPiece=0;
	}
	left_mouse = GL_TRUE;
	sel_piece = selectPiece(mousex, mousey);
	if (computeCoords(sel_piece, mousex, mousey, &selx, &sely)) {
	    grabPiece(sel_piece, selx, sely);
	}
	return GL_TRUE;
    } else if (button & TK_RIGHTBUTTON) {
	right_mouse = GL_TRUE;
	return GL_TRUE;
    }
    return GL_FALSE;
}

void animate(void)
{
    int piece;
    float selx, sely;
    int x, y;

    if (right_mouse || left_mouse) {
	tkGetMouseLoc(&x, &y);
	if (right_mouse && !left_mouse) {
	    if (mousex != x || mousey != y) {
		trackball(lastquat, 
			  2.0*(W-mousex)/W - 1.0, 
			  2.0*mousey/H - 1.0,
			  2.0*(W-x)/W - 1.0, 
			  2.0*y/H - 1.0);
		spinning = 1;
	    } else {
		spinning = 0;
	    }
	} else {
	    computeCoords(sel_piece, x, y, &selx, &sely);
	    moveSelection(selx, sely);
	}
	mousex = x;
	mousey = y;
    }
    if (spinning) {
	add_quats(lastquat, curquat, curquat);
    }
    redraw();
    if (solving) {
	if (!continueSolving()) {
	    solving = 0;
	}
    }
}

void init(void) 
{
    static float lmodel_ambient[] = { 0.0, 0.0, 0.0, 0.0 };
    static float lmodel_twoside[] = { GL_FALSE };
    static float lmodel_local[] = { GL_FALSE };
    static float light0_ambient[] = { 0.1, 0.1, 0.1, 1.0 };
    static float light0_diffuse[] = { 1.0, 1.0, 1.0, 0.0 };
    static float light0_position[] = { 0.8660254, 0.5, 1, 0 };
    static float light0_specular[] = { 0.0, 0.0, 0.0, 0.0 };
    static float bevel_mat_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    static float bevel_mat_shininess[] = { 40.0 };
    static float bevel_mat_specular[] = { 0.0, 0.0, 0.0, 0.0 };
    static float bevel_mat_diffuse[] = { 1.0, 0.0, 0.0, 0.0 };

    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glClearDepth(1.0);

    glClearColor(0.5, 0.5, 0.5, 0.0);
    glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
    glEnable(GL_LIGHT0);

    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_local);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glEnable(GL_LIGHTING);

    glMaterialfv(GL_FRONT, GL_AMBIENT, bevel_mat_ambient);
    glMaterialfv(GL_FRONT, GL_SHININESS, bevel_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, bevel_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, bevel_mat_diffuse);

    glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    glEnable(GL_COLOR_MATERIAL);
    glShadeModel(GL_FLAT);

    trackball(curquat, 0.0, 0.0, 0.0, 0.0);
    srandom(time(NULL));
}

static void Usage(void)
{
    printf("Usage: puzzle [-s]\n");
    printf("   -s:  Run in single buffered mode\n");
    exit(-1);
}

void main(long argc, char** argv)
{
    long i;

    for (i = 1; i < argc; i++) {
        if (argv[i][0] == '-') {
            switch (argv[i][1]) {
              case 's':
                doubleBuffer = 0;
                break;
              default:
                Usage();
            }
        } else {
            Usage();
        }
    }


    tkInitPosition(0, 0, W, H);

    tkInitDisplayMode(TK_DEPTH16|TK_RGB|TK_DOUBLE|TK_DIRECT);

    if (tkInitWindow("Puzzle") == GL_FALSE) {
        tkQuit();
    }

    init();

    glGetIntegerv(GL_VIEWPORT, viewport);

    printf("\n\n\n\n\n\n");
    printf("r   Reset puzzle\n");
    printf("s   Solve puzzle (may take a few seconds to compute)\n");
    printf("d   Destroy a piece - makes the puzzle easier\n");
    printf("b   Toggles the depth buffer on and off\n");
    printf("\n");
    printf("Right mouse spins the puzzle\n");
    printf("Left mouse moves pieces\n");


    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);
    tkKeyDownFunc(Key);
    tkMouseDownFunc(MouseDown);
    tkMouseUpFunc(MouseUp);
    tkIdleFunc(animate);
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\callback.h ===
#ifndef CALLBACKS_H
#define CALLBACKS_H

extern int cb_demo_mode;

void intToggleCB(Widget w, XtPointer client_data, XtPointer call_data);

void initCB(Widget w);
void exposeCB(Widget w);
void resizeCB(Widget w, XtPointer client_data, XtPointer call);
void inputCB(Widget w, XtPointer client_data, XtPointer call_data);

#ifdef X11
Boolean drawWP(XtPointer data);
#else
BOOL drawWP(HWND hWnd);
#endif

void weatherCB(Widget w, XtPointer client_data, XtPointer call_data);

void currentTimeCB(Widget w);
void time10amCB(Widget w);
void time12pmCB(Widget w);
void time4pmCB(Widget w);

/* This sets how fast time in the demo moves as opposed to
 * real time -- client_data is secretly an int */
void timeSpeedCB(Widget w, XtPointer client_data, XtPointer call_data);

void demo_modeCB(Widget w, XtPointer client_data, XtPointer call_data);
void resetViewerCB(Widget w, XtPointer client_data, XtPointer call_data);

void exitCB(Widget w, XtPointer client_data, XtPointer call_data);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\atmosphe.h ===
#ifndef ATMOSPHERE_H
#define ATMOSPHERE_H

#ifndef ATMOSPHERE_EXTERN
#define ATMOSPHERE_EXTERN extern
#endif

#include "Color.h"
#include "Point.h"

const int weather_max_name = 64;
class Weather {
 public:
  Weather();
  Weather(const char *n, GLfloat fd, GLfloat fs = 1, Color fc = white, 
	  Color s1 = blue, Color s2 = white,
	  GLfloat sb = 1,
	  GLenum ls = GL_LIGHT0, GLenum la = GL_LIGHT1);
  ~Weather();

  Weather operator=(Weather a);

  /* The sun position is used to determine how light / dark it is */
  void apply(Point sun);
  void draw_sky(Point sun);

  /* This is how much to blur shadows due to haze or fog */
  GLfloat shadow_blur();

  char name[weather_max_name];

  GLfloat fog_density;
  Color fog_color;
  /* Fog spread relates the height to the density of the fog -- 1.0
   * leads to uniform fog */
  GLfloat fog_spread;

  Color sky_top;
  Color sky_bottom;

  GLenum light_sun, light_ambient;
  GLfloat sun_brightness;

 private:
};
const int nweathers = 4;
extern Weather weathers[nweathers];
const int def_weather_index = 0;

#undef ATMOSPHERE_EXTERN

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\callback.cxx ===
#ifdef X11
#include <X11/Intrinsic.h>
#include <X11/keysym.h>
#include <Xm/Xm.h>

#include <GL/glx.h>
#include <GLwMDrawA.h>
#endif

#include <windows.h>
#include <GL/glu.h>

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef X11
#include <sys/time.h>
#else
#include <time.h>
#endif

#ifdef WIN32
#include "stonehen.h"
#endif

#include "atmosphe.h"
#include "scene.h"

#include "callback.h"

int cb_demo_mode = 0;
float demo_time;

#ifdef X11
extern Widget glw;
extern XtAppContext app_context;
GLXContext glx_context;
#endif

static int needs_wp = 0;
#ifdef X11
static XtWorkProcId workproc = NULL;
#else
static int workproc = 0;
#endif

static int winx, winy;

static int button_down = 0;
int mousex, mousey;
/* What's moving */
GLint target;

/* Location of the telescope */
GLfloat tx, ty;

/* Movements of the camera position to be applied at the next redraw */
float rot_pendx = 0, rot_pendz = 0, trans_pend = 0;

/* How fast the camera is moving */
float trans_speed = 0;

/* This is how fast demo time moves relative to real time */
GLfloat time_scale = 0;

TimeDate last_update;

float last_time = 0;
const float time_fudge = 1000;
inline unsigned long current_time()
{
#ifdef X11
  struct timeval time;
  gettimeofday(&time, NULL);
  return (time.tv_sec * 1000000 + time.tv_usec);
#else
  return (GetTickCount() * 1000);
#endif
}

inline float clamp(float x, float min, float max)
{
  if (x < min) return min;
  else if (x > max) return max;
  else return x;
}

static void add_workproc(Widget w)
{
  needs_wp++;
#ifdef X11
  if (workproc == NULL)
    workproc = XtAppAddWorkProc(app_context, drawWP, NULL);
#else
  workproc = SetTimer(w, 1, 1000, NULL);
#endif
}

static void remove_workproc(Widget w)
{
  needs_wp--;
  if (needs_wp == 0) {
#ifdef X11
    XtRemoveWorkProc(workproc);
    workproc = NULL;
#else
    KillTimer(w, 1);
    workproc = 0;
#endif
  } else if (needs_wp < 0) {
    fprintf(stderr, "Internal Error:  No workproc to remove!\n");
    needs_wp = 0;
    workproc = NULL;
  }
}

static void reset_viewer()
{
  scene_viewer_center();
}

#ifdef X11
void intToggleCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  int *data;
  XmToggleButtonCallbackStruct *ptr;
  ptr = (XmToggleButtonCallbackStruct *)call_data;
  data = (int *)client_data;
  *data = ptr->set;
  // This redraw may or may not be needed - do it to be safe
  drawWP(NULL);
}


void initCB(Widget w)
{
  Arg args[1];
  XVisualInfo *vi;

  glw = w;

  XtSetArg(args[0], GLwNvisualInfo, &vi);
  XtGetValues(w, args, 1);
 
  glx_context = glXCreateContext(XtDisplay(w), vi, 0, GL_FALSE);
  GLwDrawingAreaMakeCurrent(w, glx_context);

  scene_init();

  last_update.read_time();

  resetViewerCB(NULL, NULL, NULL);
}

void exposeCB(Widget w)
{
  drawWP(NULL);
}
#endif

void resizeCB(Widget w, XtPointer client_data, XtPointer call)
{
#ifdef X11
  GLwDrawingAreaCallbackStruct *call_data;

  GLwDrawingAreaMakeCurrent(w, glx_context);

  call_data = (GLwDrawingAreaCallbackStruct *)call;

  winx = call_data->width;
  winy = call_data->height;
#else
  RECT rect;
  GetClientRect(w, &rect);

  winx = WINDSIZEX(rect);
  winy = WINDSIZEY(rect);
#endif
  
  glViewport(0, 0, winx, winy);
  
  aspect = (GLfloat)winx / (GLfloat)winy;
}

void inputCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  GLwDrawingAreaCallbackStruct *call;

  int bufsize = 5;
#ifdef X11
  char buffer[5];
  KeySym key;
  XComposeStatus compose;
#endif

  float dx, dy, r1, r2;

#ifdef X11
  GLwDrawingAreaMakeCurrent(w, glx_context);
#endif

  call = (GLwDrawingAreaCallbackStruct *)call_data;

  switch(call->event->type) {
  case ButtonPress:
    last_time = current_time();
    button_down = call->event->xbutton.button;
    mousex = call->event->xbutton.x;
    mousey = call->event->xbutton.y;
    /* Determine if the target should be the camera position 
     * or the telescope */
    if (use_telescope) {
      scene_get_position_telescope(&tx, &ty);
      scene_get_radius_telescope(&r1);
      dx = (tx + .5) - ((GLfloat)(winx - mousex)/(GLfloat)winx);
      dy = (ty + .5) - ((GLfloat)(winy - mousey)/(GLfloat)winy);
      r2 = sqrt(dx*dx + dy*dy);
      if (r2 < r1) target = name_telescope;
      else target = name_background;
    } else target = name_background;
    add_workproc(w);
    break;
  case ButtonRelease:
#ifdef X11
    if (call->event->xbutton.button == Button3) {
      /* Use Button3 to stop */
      if (trans_speed) remove_workproc(w);
      trans_speed = 0;
    }
#endif
    remove_workproc(w);
    button_down = 0;
    break;
  case MotionNotify:
    switch(button_down) {
    case Button1:
      /* Use Button1 to control the way in which the viewer is looking 
       * or to move the telescope around */
      if (target == name_background) {
	dx = (float)(call->event->xmotion.x - mousex) / (float)winx;
	dy = (float)(call->event->xmotion.y - mousey) / (float)winy;
	rot_pendx -= dy * fov;
	rot_pendz -= dx * fov;
      } else {
	dx = (float)(mousex - call->event->xmotion.x) / (float)winx;
	dy = (float)(mousey - call->event->xmotion.y) / (float)winy;
	tx += dx;
	ty += dy;
	tx = clamp(tx, -.5, .5);
	ty = clamp(ty, -.5, .5);
	scene_position_telescope(tx, ty);
      }
      break;
    case Button2:
      /* Use Button2 to change speed */
      dx = (float)(mousex - call->event->xmotion.x) / 
	(float)winx;
      if (dx && !trans_speed) add_workproc(w);
#ifdef WIN32
      else if (!dx && trans_speed) remove_workproc(w);
#endif
      trans_speed += dx;
      break;
    }
    mousex = call->event->xmotion.x;
    mousey = call->event->xmotion.y;
    break;

#ifdef X11 // We can handle our own keys...
  case KeyPress:
    XLookupString(&(call->event->xkey), buffer, bufsize, &key, &compose);
    if (key == XK_Escape) exit(0);
    break;                            
#endif

  default:
    break;
  }
}

const float speed_t = .5;
const float speed_r = 15.;
const float speed_rx = 10.;
void demo_mode_update(float dt)
{
  float t;
  
  if (!cb_demo_mode) return;
  
  dt /= 1000000;
  demo_time += dt;
  
  t = demo_time;
  
  if (t < 10.5) {
    trans_speed = speed_t;
    return;
  } else t -= 10.5;
  
  if (t < 1) {
    trans_speed = 0;
    rot_pendz = 0;
    return;
  } else t -= 1;
  
  if (t < 3.) {
    trans_speed = 0.;
    rot_pendz = dt * speed_r;
    return;
  } else t -= 3.;
  
  if (t < 2.) {
    rot_pendx = -dt * speed_rx;
    return;
  } else t -= 2.;

  if (t < 2.) {
    return;
  } else t -= 2.;

  if (t < 2.) {
    rot_pendx = dt * speed_rx;
    return;
  } else t -= 2.;
  

  if (t < 3.) {
    trans_speed = 0.;
    rot_pendz = dt * speed_r;
    return;
  } else t -= 3.;

  if (t < 30.) {
    trans_speed  = speed_t;
    rot_pendz = 0;
    return;
  } else t -= 30.;
  
  if (t < 1.) {
    trans_speed = 0;
    return;
  } else t -= 1.;

  if (t < 1.3) {
    rot_pendz = -dt * speed_r;
    return;
  } else t -= 1.3;

  // Pan back to see entire thing
  if (t < 23) {
    trans_speed = speed_t;
    return;
  } else t -= 23;

  // Hold before starting over
  if (t < 20) {
    trans_speed = 0;
    return;
  }
  else t -= 20;

  demo_time = 0.;
  reset_viewer();
}

Boolean drawWP(Widget w)
{
  /* Right now, there's two completely independent time measurements:
   * one for the time of day in the demo and one for changing the camera
   * position */
  TimeDate t, dt;
  float elapsed_time, time;
#ifdef WIN32
  HDC hDC;
#endif

  if (time_scale != 0.0) {
    t.read_time();
    dt = (t - last_update) * time_scale;
    scene_inc_time(dt);
    last_update = t;
  }

  time = current_time();
  if (time - last_time > time_fudge) {
    elapsed_time = time - last_time;
    demo_mode_update(elapsed_time);
    trans_pend = trans_speed * (elapsed_time / 1000000);
    last_time = time;
  }

  scene_viewer_rotatex(rot_pendx);
  scene_viewer_rotatez(rot_pendz);
  scene_viewer_translate(trans_pend);
  rot_pendx = 0;
  rot_pendz = 0;
  trans_pend = 0;

#ifdef X11
  GLwDrawingAreaMakeCurrent(glw, glx_context);
  scene_render();
  /* This is a total hack */
//  if (!use_antialias)
GLwDrawingAreaSwapBuffers(glw);
#else
  hDC = GetDC(w);
  scene_render();
  SwapBuffers(hDC);
  ReleaseDC(w, hDC);
#endif  

  return FALSE;
}

#ifdef X11
void weatherCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  Weather *data;
  XmToggleButtonCallbackStruct *ptr;
  ptr = (XmToggleButtonCallbackStruct *)call_data;
  if (ptr->set) scene_set_weather(*((Weather *)client_data));
  drawWP(NULL);
}
#endif

void currentTimeCB(Widget w)
{
  scene_set_time(TimeDate().read_time());
  drawWP(w);
}

void time10amCB(Widget w)
{
  scene_set_time(TimeDate(10, 0));
  drawWP(w);
}

void time12pmCB(Widget w)
{
  scene_set_time(TimeDate(12, 0));
  drawWP(w);
}

void time4pmCB(Widget w)
{
  scene_set_time(TimeDate(16, 0));
  drawWP(w);
}

void timeSpeedCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  
#ifdef X11
  if (!((XmToggleButtonCallbackStruct *)call_data)->set) return;
  time_scale = (int)client_data;
#endif
  if (time_scale == 0.0) remove_workproc(w);
  else add_workproc(w);
  last_update.read_time();
}

void demo_modeCB(Widget w, XtPointer client_data, XtPointer call_data)
{
#ifdef X11
  int val  = ((XmToggleButtonCallbackStruct *)call_data)->set;
#else
  int val = cb_demo_mode;
#endif
  if (!val) {
    remove_workproc(w);
    resetViewerCB(w, NULL, NULL);
    last_time = current_time();
  } else {
    reset_viewer();
    add_workproc(w);
    trans_speed = 0;
    demo_time = 0;
    rot_pendx = -5;
  }
  drawWP(w);
}

void resetViewerCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  trans_speed = 0;
  rot_pendx = rot_pendz = trans_pend = 0;
  rot_pendx = -5;
  reset_viewer();
  return;
}
     

void exitCB(Widget w, XtPointer client_data, XtPointer call_data)
{
  exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\color.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#ifndef COLOR_H
#define COLOR_H

class Color {
 public:
  inline Color() {};
  inline Color(GLfloat r, GLfloat g, GLfloat b, GLfloat a = 1.0);
  
  inline Color operator=(GLfloat *a);
  inline Color operator=(GLfloat a);
  inline Color operator+(Color a);
  inline Color operator+=(Color a);
  inline Color operator*(Color a);
  inline Color operator*(GLfloat a);
  inline Color operator*=(Color a);
  inline Color operator*=(GLfloat *a);
  inline Color operator*=(GLfloat a);
 
  inline GLfloat& operator[](int index);

  inline Color clamp();
  
  inline void glcolor();

  inline void print();
  inline void print(const char *format);

  GLfloat c[4];
};

const Color white(1., 1., 1., 1.), black(0., 0., 0., 1.);
const Color red(1, 0, 0), green(0, 1, 0), blue(0, 0, 1);

inline Color::Color(GLfloat r, GLfloat g, GLfloat b, GLfloat a)
{
  c[0] = r;
  c[1] = g;
  c[2] = b;
  c[3] = a;
}

inline Color Color::operator=(GLfloat a)
{
  c[0] = c[1] = c[2] = c[3] = a;
  return *this;
}

inline Color Color::operator=(GLfloat *a)
{
  c[0] = a[0];
  c[1] = a[1];
  c[2] = a[2];
  c[3] = a[3];
  return *this;
}

inline Color Color::operator+(Color a) 
{
  Color val;
  val.c[0] = c[0] + a.c[0];
  val.c[1] = c[1] + a.c[1];
  val.c[2] = c[2] + a.c[2];
  val.c[3] = c[3] + a.c[3];
  return val;
}

inline Color Color::operator+=(Color a)
{
  c[0] += a.c[0];
  c[1] += a.c[1];
  c[2] += a.c[2];
  c[3] += a.c[3];
  return *this;
}

inline Color Color::operator*(Color a)
{
  Color val;
  val.c[0] = c[0] * a.c[0];
  val.c[1] = c[1] * a.c[1];
  val.c[2] = c[2] * a.c[2];
  val.c[3] = c[3] * a.c[3];
  return val;
}

inline Color Color::operator*(GLfloat a)
{
  Color val;
  val.c[0] = c[0] * a;
  val.c[1] = c[1] * a;
  val.c[2] = c[2] * a;
  val.c[3] = c[3] * a;
  return val;
}

inline Color Color::operator*=(Color a)
{
  c[0] *= a.c[0];
  c[1] *= a.c[1];
  c[2] *= a.c[2];
  return *this;
}

inline Color Color::operator*=(GLfloat *a) 
{
  c[0] *= a[0];
  c[1] *= a[1];
  c[2] *= a[2];
  return *this;
}

inline Color Color::operator*=(GLfloat a)
{
  c[0] *= a;
  c[1] *= a;
  c[2] *= a;
  c[3] *= a;
  
  return *this;
}

inline GLfloat& Color::operator[](int index)
{
  return c[index];
}

inline Color Color::clamp()
{
  Color val;
  val.c[0] = c[0] < 0.0 ? 0.0 : (c[0] > 1.0 ? 1.0 : c[0]);
  val.c[1] = c[1] < 0.0 ? 0.0 : (c[1] > 1.0 ? 1.0 : c[1]);
  val.c[2] = c[2] < 0.0 ? 0.0 : (c[2] > 1.0 ? 1.0 : c[2]);
  val.c[3] = c[3] < 0.0 ? 0.0 : (c[3] > 1.0 ? 1.0 : c[3]);
  return val;
}

inline void Color::glcolor()
{
  glColor4fv(c);
}

inline void Color::print()
{
  print("%f %f %f %f\n");
}

inline void Color::print(const char *format)
{
  printf(format, c[0], c[1], c[2], c[3]);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\ellipse.h ===
#ifndef ELLIPSE_H
#define ELLIPSE_H

#include "Stone.h"

const int nsarcens = 8;
const int nlintels = 4;

class EllipseSt {
 public:
  EllipseSt();
  ~EllipseSt() {};
  
  void erode(float p);
  
  void draw();
  void draw_shadow(Point dlight, GLfloat blur = 0.0,
                   Color color = black, Color diffuse = black);
  
 private:
  GLfloat r1, r2;
  
  Stone sarcens[nsarcens], lintels[nlintels];
  
  void copy_zero();
  
  void draw_sarcens();
  void draw_lintels();
  
  void draw_sarcens_shadows(Point dlight, GLfloat blur,
                            Color color, Color diffuse);
  void draw_lintels_shadows(Point dlight, GLfloat blur,
                            Color color, Color diffuse);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\main.cxx ===
#include <GL/glu.h>
#include <GL/glx.h>

#include <X11/Intrinsic.h>
#include <Xm/Xm.h>
#include <Xm/CascadeB.h>
#include <Xm/Frame.h>
#include <Xm/MainW.h>
#include <Xm/PushB.h>
#include <Xm/PushBG.h>
#include <Xm/RowColumn.h>
#include <Xm/ToggleB.h>
#include <GLwMDrawA.h>

#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "atmosphe.h"
#include "scene.h"
#include "callback.h"

static Display *display;
XtAppContext app_context;
Widget glw;

const int max_args = 20;

XVisualInfo *find_visual() 
{
  int attr[256], i, stencil, dbuffer, accum;
  XVisualInfo *vi;

  i = 0;
  attr[i++] = GLX_RGBA;
  attr[i++] = GLX_RED_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_GREEN_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_BLUE_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_DEPTH_SIZE;  attr[i++] = 1;
  dbuffer = i;
  attr[i++] = GLX_DOUBLEBUFFER;
  stencil = i;
  attr[i++] = GLX_STENCIL_SIZE;
  attr[i++] = 1;
  accum = i;
  attr[i++] = GLX_ACCUM_RED_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_ACCUM_BLUE_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_ACCUM_GREEN_SIZE;  attr[i++] = 1;
  attr[i++] = GLX_ACCUM_ALPHA_SIZE;  attr[i++] = 1;
  attr[i++] = (int)None;

  vi = glXChooseVisual(display, DefaultScreen(display), attr);
  if (vi == NULL) {
    fprintf(stderr, "Unable to find visual with accumulation buffer.\n");
    fprintf(stderr, "(Fancy fog won't work).\n");
    attr[accum] = (int)None;
    vi = glXChooseVisual(display, DefaultScreen(display), attr);
    if (vi == NULL) {
      fprintf(stderr, "Unable to find visual with stencil buffer.\n");
      fprintf(stderr, "(Things won't look quite as good).\n");
      attr[stencil] = (int)None;
      vi = glXChooseVisual(display, DefaultScreen(display), attr);
      if (vi == NULL) {
	fprintf(stderr, "Unable to find double-buffered visual.\n");
	fprintf(stderr, "(Things will look even worse).\n");
	attr[dbuffer] = (int)None;
	vi = glXChooseVisual(display, DefaultScreen(display), attr);
	if (vi == NULL) fprintf(stderr, "Can't find visual at all.\n");
      }
    }
  }
  return vi;
}

Widget create_widgets(Widget parent)
{
  Widget main_window;
  Widget menu_bar;
  Widget menu_pane; 
  Widget button;
  Widget cascade;
  Widget frame;
  XVisualInfo *vi;

  Arg args[max_args];
  int argcount;

#ifdef X11
  char buffer[128];
#endif

  int i;

  main_window = XmCreateMainWindow(parent, "main1", NULL, 0);
  XtManageChild(main_window);
 
  menu_bar = XmCreateMenuBar(main_window, "menu_bar", NULL, 0);
  XtManageChild(menu_bar);
    
  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", NULL, 0);
  button = XmCreatePushButton(menu_pane, "Exit", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, (XtCallbackProc)exitCB, NULL);
      
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "File", args, 1);
  XtManageChild(cascade);



  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", NULL, 0);
  XtSetArg(args[0], XmNset, use_lighting);
  button = XmCreateToggleButton(menu_pane, "Lighting", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback, 
                (XtCallbackProc)intToggleCB, &use_lighting);
  XtSetArg(args[0], XmNset, draw_shadows);
  button = XmCreateToggleButton(menu_pane, "Shadows", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback, 
                (XtCallbackProc)intToggleCB, &draw_shadows);


  XtSetArg(args[0], XmNset, use_normal_fog);
  button = XmCreateToggleButton(menu_pane, "Fog", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback, 
                (XtCallbackProc)intToggleCB, &use_normal_fog);

#ifdef TEXTURE
  XtSetArg(args[0], XmNset, use_textures);
  button = XmCreateToggleButton(menu_pane, "Texture Map", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback, 
                (XtCallbackProc)intToggleCB, &use_textures);
#endif

  XtSetArg(args[0], XmNset, use_telescope);
  button = XmCreateToggleButton(menu_pane, "Telescope", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)intToggleCB, &use_telescope);

  XtSetArg(args[0], XmNset, use_antialias);
  button = XmCreateToggleButton(menu_pane, "Antialias", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)intToggleCB, &use_antialias);

  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "SPFX", args, 1);
  XtManageChild(cascade);


  argcount = 0;
  XtSetArg(args[argcount], XmNradioBehavior, True); argcount++;
  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args, argcount);
  XtSetArg(args[0], XmNset, TRUE);
  for (i = 0; i < nweathers; i++) {
    if (i == def_weather_index) argcount = 1;
    else argcount = 0;
    button = XmCreateToggleButton(menu_pane, (char *)weathers[i].name, 
				  args, argcount);
    XtManageChild(button);
    XtAddCallback(button, XmNvalueChangedCallback, 
		  (XtCallbackProc)weatherCB,
		  (XtPointer)(&weathers[i]));
  }
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Weather", args, 1);
  XtManageChild(cascade);


  argcount = 0;
  XtSetArg(args[argcount], XmNradioBehavior, True); argcount++;
  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", args, argcount);
  button = XmCreatePushButton(menu_pane, "Current Time", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, 
		(XtCallbackProc)currentTimeCB, NULL);
  button = XmCreatePushButton(menu_pane, "10 a.m.", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, 
		(XtCallbackProc)time10amCB, NULL);
  button = XmCreatePushButton(menu_pane, "Noon", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, 
		(XtCallbackProc)time12pmCB, NULL);
  button = XmCreatePushButton(menu_pane, "4 p.m.", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, 
		(XtCallbackProc)time4pmCB, NULL);

  XtSetArg(args[0], XmNset, 1); argcount = 1;
  button = XmCreateToggleButton(menu_pane, "Hold Time", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)timeSpeedCB, (XtPointer)0);
  button = XmCreateToggleButton(menu_pane, "Scale = 1:1", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)timeSpeedCB, (XtPointer)1);
  button = XmCreateToggleButton(menu_pane, "Scane = 1:10", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)timeSpeedCB, (XtPointer)10);
  button = XmCreateToggleButton(menu_pane, "Scane = 1:100", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)timeSpeedCB, (XtPointer)100);
  button = XmCreateToggleButton(menu_pane, "Scane = 1:500", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)timeSpeedCB, (XtPointer)500);  

  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Time", args, 1);
  XtManageChild(cascade);


  menu_pane = XmCreatePulldownMenu(menu_bar, "menu_pane", NULL, 0);
  XtSetArg(args[0], XmNset, cb_demo_mode); argcount = 1;
  button = XmCreateToggleButton(menu_pane, "Demo Mode", args, 1);
  XtManageChild(button);
  XtAddCallback(button, XmNvalueChangedCallback,
		(XtCallbackProc)demo_modeCB, (XtPointer)0);
  button = XmCreatePushButton(menu_pane, "Reset viewer", NULL, 0);
  XtManageChild(button);
  XtAddCallback(button, XmNactivateCallback, 
		(XtCallbackProc)resetViewerCB, NULL);
  XtSetArg(args[0], XmNsubMenuId, menu_pane);
  cascade = XmCreateCascadeButton(menu_bar, "Misc", args, 1);
  XtManageChild(cascade);


  argcount = 0;
  XtSetArg(args[argcount], XmNmarginWidth, 0); argcount++;
  XtSetArg(args[argcount], XmNmarginHeight, 0); argcount++;
  XtSetArg(args[argcount], XmNshadowThickness, 1); argcount++;
  XtSetArg(args[argcount], XmNshadowType, XmSHADOW_OUT); argcount++;
  frame = XmCreateFrame(main_window, "frame", args, argcount);
  XtManageChild(frame);

  argcount = 0;
  vi = find_visual();
  if (vi) {
    XtSetArg(args[argcount], GLwNvisualInfo, vi); argcount++;
  }
  else {
    XtSetArg(args[argcount], GLwNrgba, TRUE); argcount++;
    XtSetArg(args[argcount], GLwNdepthSize, 1); argcount++;
    XtSetArg(args[argcount], GLwNdoublebuffer, TRUE); argcount++;
  }
  XtSetArg(args[argcount], XmNbottomAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNtopAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNleftAttachment, XmATTACH_FORM); argcount++;
  XtSetArg(args[argcount], XmNrightAttachment, XmATTACH_FORM); argcount++;
  glw = GLwCreateMDrawingArea(frame, "glwidget", args, argcount);
  XtManageChild(glw);
  XtAddCallback(glw, GLwNginitCallback, (XtCallbackProc)initCB, 0);
  XtAddCallback(glw, GLwNexposeCallback, (XtCallbackProc)exposeCB, 0);
  XtAddCallback(glw, GLwNresizeCallback, (XtCallbackProc)resizeCB, 0);
  XtAddCallback(glw, GLwNinputCallback, (XtCallbackProc)inputCB, 0);

  return main_window;
}

void _cdecl main(int argc, char **argv)
{
  Widget app_shell;
  Arg args[max_args];
  int argcount;

  XtToolkitInitialize();
  app_context = XtCreateApplicationContext();
  display = XtOpenDisplay(app_context, NULL, argv[0],
                          "XMdemos", NULL, 0, &argc, argv);
  if (!display) {
    XtWarning("Can't open display.");
    exit(0);
  }

  argcount = 0;
  XtSetArg(args[argcount], XmNmaxAspectX, 1); argcount++;
  XtSetArg(args[argcount], XmNmaxAspectY, 1); argcount++;
  XtSetArg(args[argcount], XmNminAspectX, 1); argcount++;
  XtSetArg(args[argcount], XmNminAspectY, 1); argcount++;
  app_shell = 
    XtAppCreateShell(argv[0], "XMdemos", applicationShellWidgetClass,
                     display, args, argcount);
  
  create_widgets(app_shell);

  XtRealizeWidget(app_shell);

  XtAppMainLoop(app_context);
  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\ellipse.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <stdio.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Ellipse.h"

EllipseSt::EllipseSt()
{
  Point sar_dim, lin_dim;

  sar_dim.set(.3, .5, 1.2);
  lin_dim.set(.3, 1.2, .2);

  sarcens[0].set_dimensions(sar_dim);
  lintels[0].set_dimensions(lin_dim);
  sarcens[0].translate(5, 0, sar_dim.pt[2]);
  lintels[0].translate(4.9, 0, 2.*sar_dim.pt[2] + lin_dim.pt[2]);
  copy_zero();

  sarcens[0].rotate_self_aboutz(17);
  sarcens[1].rotate_self_aboutz(33);
  lintels[0].rotate_self_aboutz(25);

  sarcens[2].rotate_self_aboutz(-17);
  sarcens[3].rotate_self_aboutz(-33);
  lintels[1].rotate_self_aboutz(-25);

  sarcens[4].rotate_self_aboutz(197);
  sarcens[5].rotate_self_aboutz(213);
  lintels[2].rotate_self_aboutz(205);

  sarcens[6].rotate_self_aboutz(-197);
  sarcens[7].rotate_self_aboutz(-213);
  lintels[3].rotate_self_aboutz(-205);
}  
  
void EllipseSt::erode(float p)
{
  int i;

  for (i = 0; i < nsarcens; i++) sarcens[i].erode(p);
  for (i = 0; i < nlintels; i++) lintels[i].erode(p);
}

void EllipseSt::draw()
{
  glPushMatrix();
  glScalef(1, 1.1, 1);
  draw_sarcens();
  draw_lintels();
  glPopMatrix();
}

void EllipseSt::draw_sarcens()
{
  int i;
  for (i = 0; i < nsarcens; i++) sarcens[i].draw();
}

void EllipseSt::draw_lintels()
{
  int i;
  for (i = 0; i < nlintels; i++) lintels[i].draw();
}

void EllipseSt::draw_shadow(Point dlight, GLfloat blur,
			  Color color, Color diffuse)
{
  draw_sarcens_shadows(dlight, blur, color, diffuse);
  draw_lintels_shadows(dlight, blur, color, diffuse);
}

void EllipseSt::draw_sarcens_shadows(Point dlight, GLfloat blur,
				   Color color, Color diffuse)
{
  int i;
  for (i = 0; i < nsarcens; i++) 
	sarcens[i].draw_shadow(dlight, blur, color, diffuse);
}

void EllipseSt::draw_lintels_shadows(Point dlight, GLfloat blur,
				   Color color, Color diffuse)
{
  int i;
  for (i = 0; i < nlintels; i++) 
	lintels[i].draw_shadow(dlight, blur, color, diffuse);
}

void EllipseSt::copy_zero()
{
  int i;

  for (i = 1; i < nsarcens; i++) sarcens[i] = sarcens[0];
  for (i = 1; i < nlintels; i++) lintels[i] = lintels[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\point.cxx ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <GL/gl.h>

#include <math.h>
#include <stdio.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#define POINT_EXTERN
#include "Point.h"

Point Point::rotate_abouty(GLfloat c, GLfloat s)
{
  val.pt[0] = c*pt[0] + s*pt[2];
  val.pt[1] = pt[1];
  val.pt[2] = -s*pt[0] + c*pt[2];
  return val;
}

Point Point::rotate_aboutz(GLfloat c, GLfloat s)
{
  val.pt[0] = c*pt[0] - s*pt[1];
  val.pt[1] = s*pt[0] + c*pt[1];
  val.pt[2] = pt[2];
  return val;
}

void Point::refract_self(Point light, Point N, GLfloat I)
{
  GLfloat t;
  Point dlight;

  dlight = refract_direction(light, N, I);
  t = -pt[2] / dlight.pt[2]; 
  pt[0] = pt[0] + dlight.pt[0]*t;
  pt[1] = pt[1] + dlight.pt[1]*t;
  pt[2] = 0;
}

Point Point::refract_direction(Point light, Point N, GLfloat I) 
{
  GLfloat cos1, sin1, cos2, sin2, m;
  GLfloat dlight[3], dN[3], axis[3];
  
  /* dlight = (light - *this).unit() * -1.0; */ 
  dlight[0] = pt[0] - light.pt[0]; 
  dlight[1] = pt[1] - light.pt[1]; 
  dlight[2] = pt[2] - light.pt[2]; 
  m = sqrt(dlight[0]*dlight[0] + dlight[1]*dlight[1] + dlight[2]*dlight[2]);
  dlight[0] /= m;
  dlight[1] /= m;
  dlight[2] /= m;
  
  // dN = N * -1.0; 
  dN[0] = -N.pt[0]; 
  dN[1] = -N.pt[1]; 
  dN[2] = -N.pt[2]; 
  
  // cos1 = dN.dot(dlight); 
  cos1 = dN[0]*dlight[0] + dN[1]*dlight[1] + dN[2]*dlight[2];
  
  if (1.0 - cos1*cos1 < point_fudge) {
    val = dN;
    return val;
  }
  
  // axis = ((dN * dlight) * dN).unit(); 
  val.pt[0] = dN[1]*dlight[2] - dlight[1]*dN[2];
  val.pt[1] = dN[2]*dlight[0] - dlight[2]*dN[0];
  val.pt[2] = dN[0]*dlight[1] - dN[1]*dlight[0];
  axis[0] = val.pt[1]*dN[2] - dN[1]*val.pt[2];
  axis[1] = val.pt[2]*dN[0] - dN[2]*val.pt[0];
  axis[2] = val.pt[0]*dN[1] - val.pt[1]*dN[0];
  m = sqrt(axis[0]*axis[0] + axis[1]*axis[1] + axis[2]*axis[2]);
  axis[0] /= m;
  axis[1] /= m;
  axis[2] /= m;
  
  if (axis[0]*axis[0] > point_fudge)  
    sin1 = (dlight[0] - dN[0] * cos1) / axis[0]; 
  else if (axis[1]*axis[1] > point_fudge)  
    sin1 = (dlight[1] - dN[1] * cos1) / axis[1]; 
  else sin1 = dlight[2] - dN[2] * cos1; 
  
  sin2 = sin1 / I; 
  cos2 = (sin1*sin1 < 1.0) ? sqrt(1.0 - sin2*sin2) : 0; 
  
  dlight[0] = dN[0]*cos2 + axis[0]*sin2;
  dlight[1] = dN[1]*cos2 + axis[1]*sin2;
  dlight[2] = dN[2]*cos2 + axis[2]*sin2;
  
  /* I'm not sure this is quite legal */ 
  if (dlight[2] > 0.0) dlight[2] = -dlight[2];   
  
  val = dlight;

  return val;
}

void Point::print()
{
  print("%f %f %f\n");
}

void Point::print(const char *format)
{
  printf(format, this->pt[0], this->pt[1], this->pt[2], 1.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\point.h ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#ifndef POINT_H
#define POINT_H

#ifndef POINT_EXTERN
#define POINT_EXTERN extern
#endif 

#include <math.h>

const float point_fudge = .000001;

class Point {
 public:
  inline Point operator=(Point a);
  inline Point operator=(GLfloat *a);
  inline Point operator+(Point a);
  inline Point operator+=(Point a);
  inline Point operator-(Point a);
  // This takes a cross-product
  inline Point operator*(Point b);
  inline Point operator*(GLfloat b);
  inline Point operator*=(GLfloat b);
  inline Point operator/(GLfloat b);
  inline Point operator/=(GLfloat b);
  inline GLfloat& operator[](int index);
  
  inline void set(GLfloat x, GLfloat y, GLfloat z, GLfloat w = 1.0);
  
  inline GLfloat dist(Point b);
  inline GLfloat dot(Point b);
  inline GLfloat dot(GLfloat x, GLfloat y, GLfloat z);
  inline GLfloat mag();
  inline GLfloat magsquared();
  inline Point unit();
  inline void unitize();
  
  inline Point scale(Point p);
  
  // Angle is in RADIANS
  inline Point rotate(Point axis, GLfloat angle);
  inline Point rotate(Point axis, GLfloat c, GLfloat s);
  inline void rotate_self(Point axis, GLfloat c, GLfloat s);
  Point rotate_abouty(GLfloat c, GLfloat s);
  Point rotate_aboutz(GLfloat c, GLfloat s);
  
  // Returns point projected through proj_pt into XY plane
  // Does nothing if proj_pt - *this is parallel to XY plane
  inline Point project(Point proj_pt);
  inline void project_self(Point proj_pt);
  inline void Point::project_self(GLfloat px, GLfloat py, GLfloat pz);
  inline Point project_direction(Point direction);
  inline Point Point::project_direction(GLfloat x, GLfloat y, GLfloat z);
  // This projects (px, py, pz) into this in direction (dx, dy, dz)
  inline void Point::compute_projected(GLfloat px, GLfloat py, GLfloat pz,
					 GLfloat x, GLfloat y, GLfloat z);

  // Returns point projected through light and refracted into XY
  // plane.  
  // N is normal at point (ie normal at *this)
  // I is the index of refraction
  inline Point refract(Point light, Point N, GLfloat I);
  void refract_self(Point light, Point N, GLfloat I);
  Point refract_direction(Point light, Point N, GLfloat I);
  
  inline void glvertex();
  inline void glnormal();
  
  void print();
  void print(const char *format);
  
  GLfloat pt[4];
 private:
};

POINT_EXTERN Point val;

#define DOT(a, b) (a.pt[0]*b.pt[0] + a.pt[1]*b.pt[1] + a.pt[2]*b.pt[2])
#define THIS_DOT(b) (pt[0]*b.pt[0] + pt[1]*b.pt[1] + pt[2]*b.pt[2])

inline Point Point::operator=(Point a)
{
  pt[0] = a.pt[0];
  pt[1] = a.pt[1];
  pt[2] = a.pt[2];
  pt[3] = a.pt[3];
  return *this;
}

inline Point Point::operator=(GLfloat *a)
{
  pt[0] = a[0]; 
  pt[1] = a[1]; 
  pt[2] = a[2]; 
  pt[3] = 1;
  return *this;
}

inline Point Point::operator+(Point a)
{  
  val.pt[0] = pt[0] + a.pt[0];
  val.pt[1] = pt[1] + a.pt[1];
  val.pt[2] = pt[2] + a.pt[2]; 
  return val; 
}

inline Point Point::operator+=(Point a)
{
  pt[0] += a.pt[0];
  pt[1] += a.pt[1];
  pt[2] += a.pt[2];
  return *this;
}

inline Point Point::operator-(Point a)
{
  val.pt[0] = pt[0] - a.pt[0];
  val.pt[1] = pt[1] - a.pt[1];
  val.pt[2] = pt[2] - a.pt[2];
  return val;
}
  
inline Point Point::operator*(Point b)
{
  val.pt[0] = pt[1]*b.pt[2] - b.pt[1]*pt[2];
  val.pt[1] = pt[2]*b.pt[0] - b.pt[2]*pt[0];
  val.pt[2] = pt[0]*b.pt[1] - pt[1]*b.pt[0];
  return val;
}

inline Point Point::operator*(GLfloat b)
{
  val.pt[0] = pt[0] * b;
  val.pt[1] = pt[1] * b;
  val.pt[2] = pt[2] * b;
  return val;
}

inline Point Point::operator*=(GLfloat b)
{
  pt[0] *= b;
  pt[1] *= b;
  pt[2] *= b;
  return *this;
}

inline Point Point::operator/(GLfloat b)
{
  val.pt[0] = pt[0] / b;
  val.pt[1] = pt[1] / b;
  val.pt[2] = pt[2] / b;
  return val;
}

inline Point Point::operator/=(GLfloat b)
{
  pt[0] /= b;
  pt[1] /= b;
  pt[2] /= b;
  return *this;
}

inline GLfloat& Point::operator[](int index)
{
  return pt[index];
}

inline void Point::set(GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
  pt[0] = x;
  pt[1] = y;
  pt[2] = z;
  pt[3] = w;
}

inline GLfloat Point::dist(Point b)
{
  return (*this - b).mag();
}

inline GLfloat Point::dot(Point b)
{
  return pt[0]*b.pt[0] + pt[1]*b.pt[1] + pt[2]*b.pt[2];
}

inline GLfloat Point::dot(GLfloat x, GLfloat y, GLfloat z)
{ 
  return pt[0]*x + pt[1]*y + pt[2]*z;
}

inline GLfloat Point::mag()
{
  return sqrt(pt[0]*pt[0] + pt[1]*pt[1] + 
              pt[2]*pt[2]);
}

inline GLfloat Point::magsquared()
{
  return pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2];
}

inline Point Point::unit()
{
  GLfloat m = sqrt(pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2]);
  val.pt[0] = pt[0] / m;
  val.pt[1] = pt[1] / m;
  val.pt[2] = pt[2] / m;
  return val;
}

inline void Point::unitize()
{
  GLfloat m = sqrt(pt[0]*pt[0] + pt[1]*pt[1] + pt[2]*pt[2]);
  pt[0] /= m;
  pt[1] /= m;
  pt[2] /= m;
}

inline Point Point::scale(Point p) 
{
  val.pt[0] = pt[0] * p.pt[0];
  val.pt[1] = pt[1] * p.pt[1];
  val.pt[2] = pt[2] * p.pt[2];
  return val;
}

inline Point Point::rotate(Point axis, GLfloat angle)
{
  return rotate(axis, cos(angle), sin(angle));
}

inline Point Point::rotate(Point axis, GLfloat c, GLfloat s)
{
  float x = axis.pt[0], y = axis.pt[1], z = axis.pt[2], t = 1.0 - c;
  float tx, ty;
  
  tx = t*x;
  /* Taking advantage of inside info that this is a common case */
  if (y == 0.0) {
    val.pt[0] = pt[0]*(tx*x + c) + pt[1]*(-s*z) + pt[2]*(tx*z);
    val.pt[1] = pt[0]*(s*z) + pt[1]*c + pt[2]*(-s*x);
    val.pt[2] = pt[0]*(tx*z) + pt[1]*s*x + pt[2]*(t*z*z + c);
  } else {
    ty = t*y;
    val.pt[0] = pt[0]*(tx*x + c) + pt[1]*(tx*y - s*z) +
      pt[2]*(tx*z + s*y);
    val.pt[1] = pt[0]*(tx*y + s*z) + pt[1]*(ty*y + c) +
      pt[2]*(ty*z - s*x);
    val.pt[2] = pt[0]*(tx*z - s*y) + pt[1]*(ty*z + s*x) +
      pt[2]*(t*z*z + c);
  }
  return val;
}

inline void Point::rotate_self(Point axis, GLfloat c, GLfloat s)
{
  float Px, Py, Pz;
  float x = axis.pt[0], y = axis.pt[1], z = axis.pt[2], t = 1.0 - c;
  float tx, ty;
  
  tx = t*x;
  Px = pt[0];
  Py = pt[1];
  Pz = pt[2];
  /* Taking advantage of inside info that this is a common case */
  if (!y) {
    pt[0] = Px*(tx*x + c) +	Py*(-s*z) + 	Pz*(tx*z);
    pt[1] = Px*(s*z) + 		Py*c + 		Pz*(-s*x);
    pt[2] = Px*(tx*z) + 	Py*s*x + 	Pz*(t*z*z + c);
  } else {
    ty = t*y;
    pt[0] = Px*(tx*x + c) + 	Py*(tx*y - s*z) +
      Pz*(tx*z + s*y);
    pt[1] = Px*(tx*y + s*z) + 	Py*(ty*y + c) +
      Pz*(ty*z - s*x);
    pt[2] = Px*(tx*z - s*y) + 	Py*(ty*z + s*x) +
      Pz*(t*z*z + c);
  }
}  

inline void Point::glvertex() 
{
  glVertex3fv(pt);
}

inline void Point::glnormal()
{
  glNormal3fv(pt);
}

inline Point Point::project(Point proj_pt)
{
  GLfloat dirx = pt[0] - proj_pt.pt[0], 
      diry = pt[1] - proj_pt.pt[1],
      dirz = pt[2] - proj_pt.pt[2];
  GLfloat t;

  if (fabs(dirz) < point_fudge) val = *this;
  else {
    t = -proj_pt.pt[2] / dirz;
    val.pt[0] = proj_pt.pt[0] + dirx*t;
    val.pt[1] = proj_pt.pt[1] + diry*t;
    val.pt[2] = 0.0;
  }
  return val;
}

// This naively assumes that proj_pt[z] != this->pt[z]
inline void Point::project_self(Point proj_pt)
{
  GLfloat dirx = pt[0] - proj_pt.pt[0], 
      diry = pt[1] - proj_pt.pt[1],
      dirz = pt[2] - proj_pt.pt[2];
  GLfloat t;

  t = -proj_pt.pt[2] / dirz;
  pt[0] = proj_pt.pt[0] + dirx*t;
  pt[1] = proj_pt.pt[1] + diry*t;
  pt[2] = 0.0;
}

inline void Point::project_self(GLfloat px, GLfloat py, GLfloat pz)
{
  GLfloat dirx = pt[0] - px, 
  diry = pt[1] - py,
  dirz = pt[2] - pz, t;

  t = -pz / dirz;
  pt[0] = px + dirx*t;
  pt[1] = py + diry*t;
  pt[2] = 0.0;
}

inline Point Point::project_direction(Point direction) {
  GLfloat t;

  t = -pt[2] / direction.pt[2];
  val.pt[0] = pt[0] + direction.pt[0]*t;
  val.pt[1] = pt[1] + direction.pt[1]*t;
  val.pt[2] = 0;
  return val;
}

inline Point Point::project_direction(GLfloat x, GLfloat y, GLfloat z) 
{
  GLfloat t;

  t = -pt[2] / z;
  val.pt[0] = pt[0] + x*t;
  val.pt[1] = pt[1] + y*t;
  val.pt[2] = 0;
  return val;
}

inline void Point::compute_projected(GLfloat px, GLfloat py, GLfloat pz,
				     GLfloat dx, GLfloat dy, GLfloat dz)
{
  GLfloat t = -pz / dz;
  pt[0] = px + dx*t;
  pt[1] = py + dy*t;
  pt[2] = 0;
}


#undef POINT_EXTERN

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\ring.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <math.h>
#include <stdio.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Ring.h"

inline float radians(float a) {return a * M_PI / 180.0;};

Ring::Ring() 
{
  Point sar_dim, lin_dim;

  radius = 10;

  nstones = 30;

  sar_dim.set(.2, .5, 1);
  sarcen.set_dimensions(sar_dim);
  sarcen.translate(radius, 0, sar_dim.pt[2]);

  angle = 360.0 / (float)nstones;

  lin_dim.set(.2, .99 * tan(2.0 * M_PI / (float)nstones) * 
	      (radius - sar_dim.pt[0]) / 2.0, .2);
  lintel.set_dimensions(lin_dim);
  lintel.translate(radius, 0, 2.*sar_dim.pt[2] + lin_dim.pt[2]);
}


 Ring::~Ring()
{
}

void Ring::erode(float p)
{
  sarcen.erode(p);
  lintel.erode(p);
}

void Ring::draw()
{
  draw_sarcens();
  draw_lintels();
}

void Ring::draw_sarcens()
{
  int i;
  for (i = 0; i < nstones; i++) {
    glPushMatrix();
    glRotatef(i * angle, 0, 0, 1);
    sarcen.draw();
    glPopMatrix();
  }
}

void Ring::draw_lintels()
{
  int i;
  glPushMatrix();
  glRotatef(angle / 2.0, 0, 0, 1);
  for (i = 0; i < nstones; i++) {
    glPushMatrix();
    glRotatef(i * angle, 0, 0, 1);
    lintel.draw();
    glPopMatrix();
  }
  glPopMatrix();
}

void Ring::draw_shadow(Point dlight, GLfloat blur,
		       Color color, Color diffuse)
{
  draw_sarcens_shadows(dlight, blur, color, diffuse);
  draw_lintels_shadows(dlight, blur, color, diffuse);
}

void Ring::draw_sarcens_shadows(Point dlight, GLfloat blur,
				Color color, Color diffuse)
{
  int i;
  Stone proto;

  proto = sarcen;
  for (i = 0; i < nstones; i++) {
    proto.rotate_self_aboutz(angle);
    proto.draw_shadow(dlight, blur, color, diffuse);
  }
}

void Ring::draw_lintels_shadows(Point dlight, GLfloat blur,
				Color color, Color diffuse)
{  
  int i;
  Stone proto;

  proto = lintel;

  proto.rotate_self_aboutz(angle / 2.0);

  for (i = 0; i < nstones; i++) {
    proto.rotate_self_aboutz(angle);
    proto.draw_shadow(dlight, blur, color, diffuse);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\roundwal.h ===
#ifndef ROUNDWALL_H
#define ROUNDWALL_H

class Roundwall {
 public:
  Roundwall();
  ~Roundwall() {};
  
  void draw();
  
  void set_divisions(int d);

  float height;
  float radius;

 private:
  int divisions;
  float *sint, *cost;

  void delete_tables();
  void compute_tables();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\rgbimage.cxx ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> 
#include <GL/gl.h>
#include "stonehen.h"


#define IMAGIC      0x01da
#define IMAGIC_SWAP 0xda01

#define SWAP_SHORT_BYTES(x) ((((x) & 0xff) << 8) | (((x) & 0xff00) >> 8))
#define SWAP_LONG_BYTES(x) (((((x) & 0xff) << 24) | (((x) & 0xff00) << 8)) | \
                            ((((x) & 0xff0000) >> 8) | (((x) & 0xff000000) >> 24)))

typedef struct _rawImageRec {
    unsigned short imagic;
    unsigned short type;
    unsigned short dim;
    unsigned short sizeX, sizeY, sizeZ;
    unsigned long min, max;
    unsigned long wasteBytes;
    char name[80];
    unsigned long colorMap;
    FILE *file;
    unsigned char *tmp, *tmpR, *tmpG, *tmpB;
    unsigned long rleEnd;
    unsigned long *rowStart;
    unsigned long *rowSize;
} rawImageRec;


static rawImageRec *RawImageOpen(char *fileName)
{
    rawImageRec *raw;
    unsigned long *rowStart, *rowSize, ulTmp;
    int x;

    raw = (rawImageRec *)malloc(sizeof(rawImageRec));
    if (raw == NULL) {
	fprintf(stderr, "Out of memory!\n");
	exit(-1);
    }
    if ((raw->file = fopen(fileName, "rb")) == NULL) {
	perror(fileName);
	exit(-1);
    }

    fread(raw, 1, 12, raw->file);

    if (raw->imagic == IMAGIC_SWAP) {
        raw->type = SWAP_SHORT_BYTES(raw->type);
        raw->dim = SWAP_SHORT_BYTES(raw->dim);
        raw->sizeX = SWAP_SHORT_BYTES(raw->sizeX);
        raw->sizeY = SWAP_SHORT_BYTES(raw->sizeY);
        raw->sizeZ = SWAP_SHORT_BYTES(raw->sizeZ);
    }
    raw->tmp = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpR = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpG = (unsigned char *)malloc(raw->sizeX*256);
    raw->tmpB = (unsigned char *)malloc(raw->sizeX*256);
    if (raw->tmp == NULL || raw->tmpR == NULL || raw->tmpG == NULL ||
	raw->tmpB == NULL) {
	fprintf(stderr, "Out of memory!\n");
	exit(-1);
    }

    if ((raw->type & 0xFF00) == 0x0100) {
	x = raw->sizeY * raw->sizeZ * sizeof(long);
	raw->rowStart = (unsigned long *)malloc(x);
	raw->rowSize = (unsigned long *)malloc(x);
	if (raw->rowStart == NULL || raw->rowSize == NULL) {
	    fprintf(stderr, "Out of memory!\n");
	    exit(-1);
	}
	raw->rleEnd = 512 + (2 * x);
	fseek(raw->file, 512, SEEK_SET);
	fread(raw->rowStart, 1, x, raw->file);
	fread(raw->rowSize, 1, x, raw->file);
        if (raw->imagic == IMAGIC_SWAP) {
            x /= sizeof(long);
            rowStart = raw->rowStart;
            rowSize = raw->rowSize;
            while (x--) {
                ulTmp = *rowStart;
                *rowStart++ = SWAP_LONG_BYTES(ulTmp);
                ulTmp = *rowSize;
                *rowSize++ = SWAP_LONG_BYTES(ulTmp);
            }
        }
    }
    return raw;
}

static void RawImageClose(rawImageRec *raw)
{

    fclose(raw->file);
    free(raw->tmp);
    free(raw->tmpR);
    free(raw->tmpG);
    free(raw->tmpB);
    free(raw);
}

static void RawImageGetRow(rawImageRec *raw, unsigned char *buf, int y, int z)
{
    unsigned char *iPtr, *oPtr, pixel;
    int count;

    if ((raw->type & 0xFF00) == 0x0100) {
	fseek(raw->file, raw->rowStart[y+z*raw->sizeY], SEEK_SET);
	fread(raw->tmp, 1, (unsigned int)raw->rowSize[y+z*raw->sizeY],
	      raw->file);

	iPtr = raw->tmp;
	oPtr = buf;
	while (1) {
	    pixel = *iPtr++;
	    count = (int)(pixel & 0x7F);
	    if (!count) {
		return;
	    }
	    if (pixel & 0x80) {
		while (count--) {
		    *oPtr++ = *iPtr++;
		}
	    } else {
		pixel = *iPtr++;
		while (count--) {
		    *oPtr++ = pixel;
		}
	    }
	}
    } else {
	fseek(raw->file, 512+(y*raw->sizeX)+(z*raw->sizeX*raw->sizeY),
	      SEEK_SET);
	fread(buf, 1, raw->sizeX, raw->file);
    }
}

static void RawImageGetData(rawImageRec *raw, RGBImageRec *final)
{
    unsigned char *ptr;
    int i, j;

    final->data = (unsigned char *)malloc((raw->sizeX+1)*(raw->sizeY+1)*4);
    if (final->data == NULL) {
	fprintf(stderr, "Out of memory!\n");
	exit(-1);
    }

    ptr = final->data;
    for (i = 0; i < raw->sizeY; i++) {
	RawImageGetRow(raw, raw->tmpR, i, 0);
	RawImageGetRow(raw, raw->tmpG, i, 1);
	RawImageGetRow(raw, raw->tmpB, i, 2);
	for (j = 0; j < raw->sizeX; j++) {
	    *ptr++ = *(raw->tmpR + j);
	    *ptr++ = *(raw->tmpG + j);
	    *ptr++ = *(raw->tmpB + j);
	}
    }
}

RGBImageRec *RGBImageLoad(char *fileName)
{
    rawImageRec *raw;
    RGBImageRec *final;

    raw = RawImageOpen(fileName);
    final = (RGBImageRec *)malloc(sizeof(RGBImageRec));
    if (final == NULL) {
	fprintf(stderr, "Out of memory!\n");
	exit(-1);
    }
    final->sizeX = raw->sizeX;
    final->sizeY = raw->sizeY;
    RawImageGetData(raw, final);
    RawImageClose(raw);
    return final;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\roundwal.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <math.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Roundwal.h"

Roundwall::Roundwall()
{
  height = 2;
  radius = 20;
  divisions = 20;
  sint = cost = NULL;
}

void Roundwall::draw()
{
  float texx = 0;
  int i;
  if (sint == NULL) compute_tables();
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= divisions; i++, texx += 1.) {
    glTexCoord2f(texx, 0);
    glNormal3f(-cost[i], -sint[i], 0);
    glVertex3f(radius * cost[i], radius * sint[i], 0);
    glTexCoord2f(texx, 1);
    glVertex3f(radius * cost[i], radius * sint[i], height);
  }
  glEnd();
}

void Roundwall::set_divisions(int d)
{
  if (divisions != d) delete_tables();
  divisions = d;
}

void Roundwall::delete_tables()
{
  delete sint;
  delete cost;
  sint = cost = NULL;
}

void Roundwall::compute_tables()
{
  int i;
  float t, dt;

  delete_tables();
  cost = new float[divisions + 1];
  sint = new float[divisions + 1];

  dt = 2. * M_PI / divisions;
  for (i = 0, t = 0.; i <= divisions; i++, t += dt) {
    cost[i] = cos(t);
    sint[i] = sin(t);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\scene.cxx ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <GL/glu.h>

/*
#ifdef X11
#include <GL/glx.h>
extern "C" {
#include <tk.h>
};
#endif
*/

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Point.h"
#include "Ring.h"
#include "Roundwal.h"
#include "Ellipse.h"
#include "Telescop.h"

#define SCENE_EXTERN
#include "scene.h"

GLfloat mat_view[16];
GLfloat view_rotx = 0;
GLfloat fov = 45.0, aspect = 1.0;
static Point eyep = {0, 0, .5};
static Point lookp = {0.05, 1, .25};

TimeDate current_time;

static int list_ground;
static int list_texture_ground;
static int list_trees;
static int list_texture_trees;
static int list_ring;
static int list_ellipse;
static int list_texture_stones;
static int list_shadows;
static int list_telescope;
static int list_texture_telescope;
int draw_ground = 1;
int draw_trees = 0;
int draw_ring = 1;
int draw_ellipse = 1;
int draw_shadows = 0;

int use_lighting = 1;
int use_textures = 0;
int texture_hack = 0;		//HACK HACK HACK - only texture map the stone
int use_normal_fog = 0;
int use_fancy_fog = 0;
int use_telescope = 0;
int use_antialias = 0;

static void scene_identity();
static void scene_project(GLfloat f = fov, float dx = 0, float dy = 0);
static void scene_draw(int rend = 1);
static void scene_render_telescope();

static void draw_background();

Point sun_position = {0., .707, .707, 0.};
Color ambient(.25, .25, .25, 1.);
static void lights_init();

static void lists_init();

static void ground_list_init();
static void ground_draw();

Roundwall trees;
static void trees_list_init();
static void trees_draw();

Ring ring;
static void ring_list_init();
static void ring_draw();

EllipseSt ellipse;
static void ellipse_list_init();
static void ellipse_draw();

static void shadows_list_init();
static void shadows_draw();

Weather weather;

Telescope telescope;
GLfloat magnif = .5;
static void telescope_list_init();
static void telescope_draw();

/* Read the back buffer into the accum buffer, adding in the appropriate
 * alpha values */
static void fog_read_image();
/* Add the accum buffer to the back buffer */
static void fog_write_image();


inline float clamp(float x, float min, float max)
{
  if (x < min) return min;
  else if (x > max) return max;
  else return x;
}

void scene_init() 
{

  scene_identity();
  scene_viewer_center();

  glEnable(GL_CULL_FACE);
  glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);


  glEnable(GL_NORMALIZE);

  /* Initial time will be four in the afternoon */
  scene_set_time(TimeDate(16, 0));
  scene_set_weather(weathers[def_weather_index]);

  lights_init();
  lists_init();
}


inline double time_minutes(int hour, int minute, int second)
{
  return (double)hour*60.0 + (double)minute + (double)second / 60.0;
}

static void scene_time_changed()
{
  sun_position = current_time.sun_direction();
     
  weather.apply(sun_position);

  lights_init();
  shadows_list_init();
}
  
void scene_set_time(TimeDate t)
{
  current_time = t;
  scene_time_changed();
}

void scene_inc_time(TimeDate t)
{
  current_time += t;
  scene_time_changed();
}

/* This is a hack -- has to be called several times to get the antialiasing
 * to work */
static void scene_inner_render(GLfloat dx = 0, GLfloat dy = 0)
{
  /* This draws layered fog if the use_fancy_fog flag is on --
   * it's going to be slow on anything but high-end stuff */
  if (use_fancy_fog && weather.fog_density != 0.) {
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glEnable(GL_FOG);
    draw_background();
    scene_project(fov, dx, dy);
    glClear(GL_DEPTH_BUFFER_BIT);
    if (use_lighting) glEnable(GL_LIGHTING);
    scene_draw();
    if (use_lighting) glDisable(GL_LIGHTING);
    fog_read_image();
    glDisable(GL_FOG);
  } else 
    if (use_normal_fog && weather.fog_density != 0.) glEnable(GL_FOG);
    else glDisable(GL_FOG);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  /* This is the part where we actually draw the image */
  glClear(GL_DEPTH_BUFFER_BIT);
  draw_background();
  scene_project(fov, dx, dy);
  glClear(GL_DEPTH_BUFFER_BIT);
  if (use_lighting) glEnable(GL_LIGHTING);
  scene_draw();
  if (use_lighting) glDisable(GL_LIGHTING);

  if (use_fancy_fog && weather.fog_density != 0.) {
    fog_write_image();
  }

  if (use_telescope) scene_render_telescope();
}

void scene_render()
{
  GLint vp[4];

  scene_inner_render();

  if (!use_antialias) return;

  if (use_fancy_fog) {
    fprintf(stderr, "Cannot antialias while using fancy fog.\n");
    return;
  }


  glGetIntegerv(GL_VIEWPORT, vp);
  glAccum(GL_LOAD, .5);

  scene_inner_render(2. / (float)vp[2], 2. / (float)vp[3]);
  glAccum(GL_ACCUM, .5);

/*
  scene_inner_render(-2. / (float)vp[2], -2. / (float)vp[3]);
  glAccum(GL_ACCUM, .25); 
*/
  glAccum(GL_RETURN, 1);
/*
  glDrawBuffer(GL_BACK);
  glFlush();
*/
}

static void scene_render_telescope()
{
  telescope.draw_setup(fov, aspect);

  /* Don't fog the telescope - moisture makes it rust.
   * Seriously, it's in a strange coordinate system and fog will look
   * bad on it. */
  glPushAttrib(GL_ENABLE_BIT);
  glDisable(GL_FOG);
  if (use_textures) {
    glCallList(list_texture_telescope);
    glEnable(GL_TEXTURE_2D);
  }
  glCallList(list_telescope);
  glPopAttrib();

  if (use_lighting) glEnable(GL_LIGHTING);
  glEnable(GL_STENCIL_TEST);
  glClearStencil(0);
  glClear(GL_STENCIL_BUFFER_BIT);
  glStencilFunc(GL_ALWAYS, 0x1, 0x1);
  glStencilOp(GL_REPLACE, GL_REPLACE, GL_REPLACE); 

  glDisable(GL_CULL_FACE);
  telescope.draw_lens();
  glEnable(GL_CULL_FACE);

  telescope.draw_takedown();

  if (use_lighting) glDisable(GL_LIGHTING);

  glStencilFunc(GL_NOTEQUAL, 0x0, 0xffffffff);
  glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);

  scene_identity();

  draw_background();

  glMatrixMode(GL_PROJECTION);
  glTranslatef(telescope.xpos / magnif, -telescope.ypos / magnif, 0);
  scene_project(fov * magnif);

  glClear(GL_DEPTH_BUFFER_BIT);

  /* Pushing the lighting bit used to do really bad things, but 
   * hopefully they've all gone away */
  glPushAttrib(GL_LIGHTING_BIT);
  lights_init();
  if (use_lighting) glEnable(GL_LIGHTING);
  scene_draw();
  if (use_lighting) glDisable(GL_LIGHTING);
  glPopAttrib();

  glDisable(GL_STENCIL_TEST);
}

static void scene_identity()
{
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
}

static void scene_project(GLfloat f, float dx, float dy)
{
  glMatrixMode(GL_PROJECTION);
  glOrtho(-1 - dx, 1, -1 - dy, 1, 0, -1);
  gluPerspective(f, aspect, 0.01, 40.0);
  glMatrixMode(GL_MODELVIEW);
  glRotatef(view_rotx, 1, 0, 0);
  gluLookAt(eyep.pt[0], eyep.pt[1], eyep.pt[2], 
	    lookp.pt[0], lookp.pt[1], lookp.pt[2],
            0, 0, 1);
  glMultMatrixf(mat_view);
lights_init();
}

/* scene_draw() just draws the geometry - it's used for rendering and
 * picking. */
static void scene_draw(int rend)
{
  if (draw_ground) {
    if (rend) {
      if (use_textures) {
	glCallList(list_texture_ground);
	glEnable(GL_TEXTURE_2D);
      } else glEnable(GL_COLOR_MATERIAL);
    }
    glCallList(list_ground);

    if (rend) {
      glDisable(GL_TEXTURE_2D);
      glDisable(GL_COLOR_MATERIAL);
    }
  }

  if (draw_shadows) {
    if (use_textures && rend && !draw_ground) {
      glCallList(list_texture_ground);
      glEnable(GL_TEXTURE_2D);
    }
    glCallList(list_shadows);
    if (use_textures && rend) glDisable(GL_TEXTURE_2D);
  }

  if (draw_trees) {
    if (use_textures && rend) {
      glCallList(list_texture_trees);
      glEnable(GL_TEXTURE_2D);
    }
    glCallList(list_trees);
    if (use_textures && rend) glDisable(GL_TEXTURE_2D);
  }

  glClear(GL_DEPTH_BUFFER_BIT);

  if (draw_ring) {
    if (rend) {
      if (use_textures || texture_hack) {
	glCallList(list_texture_stones);
	glEnable(GL_TEXTURE_2D);
      }
      glEnable(GL_COLOR_MATERIAL);
      glColor3f(.5, .5, .5);
    }
    glCallList(list_ring);
    if (rend) {
      if (use_textures || texture_hack) glDisable(GL_TEXTURE_2D);
      glDisable(GL_COLOR_MATERIAL);
    }
  }

  if (draw_ellipse) {
    if (use_textures && rend) {
      // Hack to avoid doing something expensive twice in a row
      if (!draw_ring) glCallList(list_texture_stones);
      glEnable(GL_TEXTURE_2D);
    }
    glCallList(list_ellipse);
    if (use_textures && rend) glDisable(GL_TEXTURE_2D);
  }
}

static void draw_background()
{
  weather.draw_sky(sun_position);
}

void scene_viewer_center()
{
  glPushMatrix();
  glLoadIdentity();
  glGetFloatv(GL_MODELVIEW_MATRIX, mat_view);
  glPopMatrix();
  view_rotx = 0;
}

void scene_viewer_rotate_worldz(GLfloat degrees)
{
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glRotatef(degrees, 0, 0, 1);
  glMultMatrixf(mat_view);
  glGetFloatv(GL_MODELVIEW_MATRIX, mat_view);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
}

void scene_viewer_rotatez(GLfloat degrees)
{
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glRotatef(degrees, 0, 0, 1);
  glMultMatrixf(mat_view);
  glGetFloatv(GL_PROJECTION_MATRIX, mat_view);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
}

void scene_viewer_rotatex(GLfloat degrees)
{
  view_rotx += degrees;
  view_rotx = clamp(view_rotx, -60, 60);
  scene_identity();
  scene_project();
  lights_init();
}

void scene_viewer_translate(GLfloat dist)
{
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glTranslatef(0, dist, 0);
  glMultMatrixf(mat_view);
  glGetFloatv(GL_PROJECTION_MATRIX, mat_view);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  scene_identity();
  scene_project();
  lights_init();
}

void scene_position_telescope(GLfloat x, GLfloat y)
{
  telescope.xpos = x;
  telescope.ypos = y;
}

void scene_get_position_telescope(GLfloat *x, GLfloat *y)
{
  *x = telescope.xpos;
  *y = telescope.ypos;
}

void scene_get_radius_telescope(GLfloat *r)
{
  *r = telescope.get_radius();
}

void scene_set_weather(Weather w)
{
  weather = w;
  weather.apply(sun_position);
  shadows_list_init();
}

static int get_lists(int size)
{
  int i;
  i = glGenLists(size);
  if (size && !i) {
    fprintf(stderr, "Unable to allocate %d display lists.\n");
    exit(1);
  }
  return i;
}

static void lights_init()
{
  glLightfv(GL_LIGHT0, GL_POSITION, sun_position.pt);

  /* This light gives a diffuse coefficient when the sun is off - 
   * it's used for drawing shadows */
  glLightfv(GL_LIGHT1, GL_AMBIENT, black.c);
  glLightfv(GL_LIGHT1, GL_DIFFUSE, black.c);
  glLightfv(GL_LIGHT1, GL_SPECULAR, black.c);
}

#ifdef TEXTURE
static void textures_list_init()
{
  TK_RGBImageRec *teximage = NULL;
  
  teximage = tkRGBImageLoad((char *)texfile_stones);
  glNewList(list_texture_stones, GL_COMPILE);
  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage->sizeX, teximage->sizeY, 
		    GL_RGB, GL_UNSIGNED_BYTE, teximage->data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
		 GL_NEAREST_MIPMAP_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
		 GL_LINEAR);
  glMatrixMode(GL_TEXTURE);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glDisable(GL_TEXTURE_GEN_S);
  glDisable(GL_TEXTURE_GEN_T);
  glEndList();

  /* tk is obnoxious and doesn't seem to provide any mechanism for this */
  free(teximage->data);
  free(teximage);

  teximage = tkRGBImageLoad((char *)texfile_ground);
  glNewList(list_texture_ground, GL_COMPILE);
  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage->sizeX, teximage->sizeY, 
		    GL_RGB, GL_UNSIGNED_BYTE, teximage->data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
		  GL_NEAREST_MIPMAP_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
		  GL_LINEAR);
  glMatrixMode(GL_TEXTURE);
  glLoadIdentity();
  glScalef(100, 100, 1);
  glMatrixMode(GL_MODELVIEW);
  glDisable(GL_TEXTURE_GEN_S);
  glDisable(GL_TEXTURE_GEN_T);
  glEndList();

  free(teximage->data);
  free(teximage);

  /* Figure out some way to get an alpha component out of the tk --
   * otherwise we're really hosed */
  teximage = tkRGBImageLoad((char *)texfile_trees);
  glNewList(list_texture_trees, GL_COMPILE);
  /* In the final scenerio we probably won't want to mipmap this, but it's
   * not square and I don't feel like bothering to scale it */
  gluBuild2DMipmaps(GL_TEXTURE_2D, 3, teximage->sizeX, teximage->sizeY,
		    GL_RGB, GL_UNSIGNED_BYTE, teximage->data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
		  GL_NEAREST_MIPMAP_NEAREST);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER,
		  GL_LINEAR);
  glMatrixMode(GL_TEXTURE);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glDisable(GL_TEXTURE_GEN_S);
  glDisable(GL_TEXTURE_GEN_T);
  glEndList();

  free(teximage->data);
  free(teximage);

  teximage = tkRGBImageLoad((char *)texfile_telescope);
  glNewList(list_texture_telescope, GL_COMPILE);
  glTexImage2D(GL_TEXTURE_2D, 0, 3, teximage->sizeX, teximage->sizeY,
	       0, GL_RGB, GL_UNSIGNED_BYTE, teximage->data);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glMatrixMode(GL_TEXTURE);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
  glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
  glEnable(GL_TEXTURE_GEN_S);
  glEnable(GL_TEXTURE_GEN_T);
  glEndList();

  free(teximage->data);
  free(teximage);
}
#endif

static void lists_init()
{
  list_ground = get_lists(1);
  list_texture_ground = get_lists(1);
  list_trees = get_lists(1);
  list_texture_trees = get_lists(1);
  list_ring = get_lists(1);
  list_ellipse = get_lists(1);
  list_texture_stones = get_lists(1);
  list_shadows = get_lists(1);
  list_telescope = get_lists(1);
  list_texture_telescope = get_lists(1);

  ground_list_init();
  trees_list_init();
  shadows_list_init();
  ring_list_init();
  ellipse_list_init();
#ifdef TEXTURE
  textures_list_init();
#endif
  telescope_list_init();
}

static void ground_list_init()
{
  glNewList(list_ground, GL_COMPILE);
  ground_draw();
  glEndList();
}

static void ground_draw() 
{
  glColor3f(0, .75, 0);

  glLoadName(name_ground);

  glNormal3f(0, 0, 1);

  glPushMatrix();
  /* Making something this big would confuse the zbuffer, but we're 
   * clearing that AFTER drawing this, so it's ok */
  glScalef(100, 100, 1);
  glBegin(GL_QUADS);
  glTexCoord2f(0, 0);
  glVertex2f(-1, -1);
  glTexCoord2f(1, 0);
  glVertex2f(1, -1);
  glTexCoord2f(1, 1);
  glVertex2f(1, 1);
  glTexCoord2f(0, 1);
  glVertex2f(-1, 1);
  glEnd();
  glPopMatrix();
}

static void trees_list_init()
{
  glNewList(list_trees, GL_COMPILE);
  trees_draw();
  glEndList();
}

static void trees_draw()
{
  glEnable(GL_COLOR_MATERIAL);
  glColor3f(0, .5, 0);

  glLoadName(name_trees);
  
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  trees.draw();
  glDisable(GL_BLEND);

  glDisable(GL_COLOR_MATERIAL);
}

static void ring_list_init()
{
  glNewList(list_ring, GL_COMPILE);
  ring_draw();
  glEndList();
}

static void ring_draw()
{
  glLoadName(name_ring);

  glEnable(GL_DEPTH_TEST);
  ring.erode(.1);
  ring.draw();
  glDisable(GL_DEPTH_TEST);
}

static void ellipse_list_init()
{
  glNewList(list_ellipse, GL_COMPILE);
  ellipse_draw();
  glEndList();
}

static void ellipse_draw()
{
  glEnable(GL_COLOR_MATERIAL);
  glColor3f(.5, .5, .5);
  
  glEnable(GL_DEPTH_TEST);

  glLoadName(name_ellipse);

  ellipse.erode(.1);
  ellipse.draw();

  glDisable(GL_DEPTH_TEST);

  glDisable(GL_COLOR_MATERIAL);
}

static void shadows_list_init()
{
  glNewList(list_shadows, GL_COMPILE);
  shadows_draw();
  glEndList();
}

static void shadows_draw()
{
  Color grass(0, .75, 0);

  glPushAttrib(GL_ENABLE_BIT);

  /* Turn the sun off */
  glDisable(GL_LIGHT0);
  glEnable(GL_LIGHT1);
  glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, grass.c);
  glColor3fv((grass * .5).c);

  glDisable(GL_CULL_FACE);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glEnable(GL_BLEND);
  ring.draw_shadow(sun_position, weather.shadow_blur(), 
		   grass * .5, grass);
  ellipse.draw_shadow(sun_position, weather.shadow_blur(), 
		      grass * .5, grass);
  glPopAttrib();
}

static void telescope_list_init()
{
  glNewList(list_telescope, GL_COMPILE);
  telescope_draw();
  glEndList();
}

static void telescope_draw()
{
  glLoadName(name_telescope);
  glEnable(GL_COLOR_MATERIAL);
  glDisable(GL_CULL_FACE);
  glClear(GL_DEPTH_BUFFER_BIT);
  glEnable(GL_DEPTH_TEST);
  telescope.draw_body();
  glDisable(GL_DEPTH_TEST);
  glEnable(GL_CULL_FACE);
  glDisable(GL_COLOR_MATERIAL);
}

static void fog_read_image()
{
  glPushMatrix();
  glLoadIdentity();

  /* This creates an alpha gradient across the image */
/*  glColorMask(0, 0, 0, 1);
  glBegin(GL_QUADS);
  glColor4f(1, 1, 1, 1);
  glVertex2f(-1, -1);
  glVertex2f(1, -1);
  glColor4f(1, 1, 1, 0);
  glVertex2f(1, 1);
  glVertex2f(-1, 1);
  glEnd();
  glColorMask(1, 1, 1, 1);
*/
  glDrawBuffer(GL_BACK);
  glReadBuffer(GL_BACK);
  glAccum(GL_LOAD, 1);

  glPopMatrix();
}

static void fog_write_image()
{
  glDrawBuffer(GL_BACK);

  /* Put this back in once we're done testing */
//  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glAccum(GL_RETURN, 1);  
  glDisable(GL_BLEND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\ring.h ===
#ifndef RING_H
#define RING_H

#include "Stone.h"

class Ring {
 public:
  Ring();
  ~Ring();

  void erode(float p);

  void draw();
  void draw_shadow(Point dlight, GLfloat blur = 0.0,
		   Color color = black, Color diffuse = black);

 private:
  GLfloat radius, angle;
  int nstones;

  Stone sarcen;
  Stone lintel;

  void draw_sarcens();
  void draw_lintels();

  void draw_sarcens_shadows(Point dlight, GLfloat blur,
			    Color color, Color diffuse);
  void draw_lintels_shadows(Point dlight, GLfloat blur,
			    Color color, Color diffuse);
};
  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\scene.h ===
#ifndef SCENE_H
#define SCENE_H

#ifndef SCENE_EXTERN
#define SCENE_EXTERN extern
#endif

#include "TimeDate.h"
#include "atmosphe.h"

void scene_init();

void scene_set_time(TimeDate t);
void scene_inc_time(TimeDate t);

void scene_render();

void scene_viewer_center();
/* This rotates about the origin in the world coordinate system */
void scene_viewer_rotate_worldz(GLfloat degrees);
/* This rotates about the z axis */
void scene_viewer_rotatez(GLfloat degrees);
void scene_viewer_rotatex(GLfloat degrees);
/* This translates in y */
void scene_viewer_translate(GLfloat dist);

void scene_position_telescope(GLfloat x, GLfloat y);
void scene_get_position_telescope(GLfloat *x, GLfloat *y);
void scene_get_radius_telescope(GLfloat *r);

void scene_set_weather(Weather w);

const GLint name_background = 0;
const GLint name_ground = 1;
const GLint name_trees = 2;
const GLint name_ring = 3;
const GLint name_ellipse = 4;
const GLint name_telescope = 5;

extern int draw_ground;
extern int draw_trees;
extern int draw_ring;
extern int draw_ellipse;
extern int draw_shadows;

extern int use_lighting;
extern int use_textures;
extern int use_normal_fog;
extern int use_fancy_fog;
extern int use_telescope;
extern int use_antialias;

extern GLfloat fov, aspect;


const char texfile_ground[] = DATADIR "grass.rgb";
const char texfile_trees[] = DATADIR "treewall.rgb";
const char texfile_stones[] = DATADIR "marble.rgb";
const char texfile_telescope[] = DATADIR "cv.rgb";

extern Weather weather;

#undef SCENE_EXTERN
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\setpixel.h ===
BOOL bSetupPixelFormat(HDC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\setpixel.cxx ===
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include "stonehen.h"
#include "setpixel.h"

HPALETTE ghpalOld, ghPalette = (HPALETTE) 0;

unsigned char threeto8[8] = {
    0, 0111>>1, 0222>>1, 0333>>1, 0444>>1, 0555>>1, 0666>>1, 0377
};

unsigned char twoto8[4] = {
    0, 0x55, 0xaa, 0xff
};

unsigned char oneto8[2] = {
    0, 255
};

unsigned char
ComponentFromIndex(UCHAR i, UINT nbits, UINT shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits) {

    case 1:
        val &= 0x1;
        return oneto8[val];

    case 2:
        val &= 0x3;
        return twoto8[val];

    case 3:
        val &= 0x7;
        return threeto8[val];

    default:
        return 0;
    }
}

void
CreateRGBPalette(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    LOGPALETTE *pPal;
    int n, i;

    ppfd = &pfd;
    n = GetPixelFormat(hdc);
    DescribePixelFormat(hdc, n, sizeof(PIXELFORMATDESCRIPTOR), ppfd);

    if (ppfd->dwFlags & PFD_NEED_PALETTE) {
        n = 1 << ppfd->cColorBits;
        pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                n * sizeof(PALETTEENTRY));
        pPal->palVersion = 0x300;
        pPal->palNumEntries = n;
        for (i=0; i<n; i++) {
            pPal->palPalEntry[i].peRed =
                    ComponentFromIndex(i, ppfd->cRedBits, ppfd->cRedShift);
            pPal->palPalEntry[i].peGreen =
                    ComponentFromIndex(i, ppfd->cGreenBits, ppfd->cGreenShift);
            pPal->palPalEntry[i].peBlue =
                    ComponentFromIndex(i, ppfd->cBlueBits, ppfd->cBlueShift);
            pPal->palPalEntry[i].peFlags = 0;
        }
        ghPalette = CreatePalette(pPal);
        LocalFree(pPal);

        ghpalOld = SelectPalette(hdc, ghPalette, FALSE);
        n = RealizePalette(hdc);
    }
}

BOOL bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int pixelformat;

    ppfd = &pfd;

    ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;
    ppfd->dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    ppfd->dwLayerMask = PFD_MAIN_PLANE;

    ppfd->iPixelType = PFD_TYPE_RGBA;
    ppfd->cColorBits = 24;

    ppfd->cDepthBits = 16;			//GLX_DEPTH_SIZE


    ppfd->cRedBits = 8;				//GLX_RED_SIZE
    ppfd->cRedShift = 0;
    ppfd->cGreenBits = 8;			//GLX_GREEN_SIZE
    ppfd->cGreenShift = 8;
    ppfd->cBlueBits = 8;			//GLX_BLUE_SIZE
    ppfd->cBlueShift = 16;
    ppfd->cAlphaBits = 0;
    ppfd->cAlphaShift = 0;
    ppfd->cAccumBits = 0;			//ACCUM NOT SUPPORTED
    ppfd->cAccumRedBits = 0; 			//GLX_ACCUM_RED_SIZE
    ppfd->cAccumGreenBits = 0;			//GLX_ACCUM_GREEN_SIZE
    ppfd->cAccumBlueBits = 0; 			//GLX_ACCUM_BLUE_SIZE
    ppfd->cAccumAlphaBits = 0;			//GLX_ACCUM_ALPHA_SIZE

    ppfd->cStencilBits = 24;			//GLX_STENCIL_SIZE
    ppfd->cAuxBuffers = 0;
    ppfd->bReserved = 0;
    ppfd->dwVisibleMask = 
    ppfd->dwDamageMask = 0;

    pixelformat = ChoosePixelFormat(hdc, ppfd);

    if ( (pixelformat = ChoosePixelFormat(hdc, ppfd)) == 0 )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    if (SetPixelFormat(hdc, pixelformat, ppfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    CreateRGBPalette(hdc);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\stone.h ===
#ifndef STONE_H
#define STONE_H

#include "Color.h"
#include "Point.h"

class Stone {
 public:
  Stone();
  ~Stone();
  Stone operator=(Stone a);

  void set_dimensions(GLfloat x, GLfloat y, GLfloat z);
  void set_dimensions(Point p);
  Point get_dimensions() {return dimensions;};

  /* p = 0 --> sharp corners, p == 1 --> completely rounded corners */
  void erode(float p);
  float get_erosion() {return erosion;};

  void translate(GLfloat x, GLfloat y, GLfloat z);
  void translate(Point p);

  /* Angle in degrees */
  void rotate_self_aboutz(GLfloat angle);

  void draw();

  void draw_shadow(Point dlight);
  void draw_shadow(Point dlight, GLfloat blur, Color color, Color diffuse);

 private:
  Point translation;
  GLfloat rotation;
  /* dimensions contains the length, width, and height of the stone */
  Point dimensions;

  GLfloat erosion;

  Point points[24];
  int points_valid;
  void compute_points();

  int transforms_valid;
  inline Point trans_rot_point(Point p, float c, float s);
  inline Point transform_point(Point p, float c, float s);
  void transform_points();
  
  void draw_faces(int flat = 0);
  void draw_faces(Point *p, int flat = 0);

  void draw_edges(int flat = 0);
  void draw_edges(Point *p, int flat = 0);
  void draw_edge(Point n1, Point n2, Point *p, int a, int b, int c, int d,
		 int flat = 0);

  void draw_corners(int flat = 0) {draw_corners(points, flat);};
  void draw_corners(Point *p, int flat = 0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\stonerc.h ===
#define IDM_EXIT		100
#define IDM_LIGHTING		200
#define IDM_SHADOWS		201
#define IDM_FOG			202
#define IDM_TEXTUREMAP		203
#define IDM_TELESCOPE		204
#define IDM_ANTIALIAS		205
#define IDM_CLEAR		300
#define IDM_FOGGY		301	
#define IDM_VERYFOGGY		302
#define IDM_RAINY		303
#define IDM_CURRENTTIME		400
#define IDM_10AM		401
#define IDM_NOON		402
#define IDM_4PM			403
#define IDM_HOLDTIME		410
#define IDM_SCALE1		411
#define IDM_SCALE10		412
#define IDM_SCALE100		413
#define IDM_SCALE500		414
#define IDM_DEMOMODE		500
#define IDM_RESET		501
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\telescop.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <math.h>
#include <stdio.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Color.h"
#include "Telescop.h"

inline float radians(float a) {return M_PI * a / 180.0;}

Telescope::Telescope(GLfloat x, GLfloat y)
{
  xpos = x;
  ypos = y;

  divisions = 20;
  radius = .1;
  
  disk = gluNewQuadric();
  cylinder = gluNewQuadric();
  gluQuadricNormals(disk, GLU_FLAT);
  gluQuadricNormals(cylinder, GLU_SMOOTH);
  gluQuadricTexture(disk, GL_TRUE);
  gluQuadricTexture(cylinder, GL_TRUE);

}

Telescope::~Telescope()
{
  gluDeleteQuadric(disk);
  gluDeleteQuadric(cylinder);
}

void Telescope::draw_setup(GLfloat fov, GLfloat aspect, int perspective) 
{
  GLfloat near_plane;

  /* Worry about the aspect ratio later */
  near_plane = .5 / tan(radians(fov / 2.0));

  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  if (perspective) gluPerspective(fov, aspect, near_plane - .01, 10.0);
  else 
    fprintf(stderr, 
	    "Warning: Drawing telescope using orthographic projection.\n"); 
  gluLookAt(0, 0, -near_plane, 
	    0, 0, 1, 
	    0, 1, 0);

  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  glTranslatef(xpos, ypos, 0); 
}

void Telescope::draw_fake()
{
  glBegin(GL_QUADS);
  glColor3f(1, 1, 1);
  glVertex3f(-radius, -radius, .01);
  glVertex3f(radius, -radius, .01);
  glVertex3f(radius, radius, .01);
  glVertex3f(-radius, radius, .01);
  glEnd();
}

void Telescope::draw_body() 
{
  Color c;
  
  glPushMatrix();

  glColor3f(1, 1, 0);
  gluDisk(disk, radius, 1.1 * radius, divisions, 1);
  gluCylinder(cylinder, 1.1 * radius, 1.1 * radius, .1 * radius, divisions, 1);
  glTranslatef(0, 0, .1*radius);
  gluDisk(disk, radius, 1.1 * radius, divisions, 1);

  glPushAttrib(GL_ENABLE_BIT);
  glDisable(GL_TEXTURE_2D);
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, white.c);
  glColor3f(0, 0, 0);
  gluCylinder(cylinder, 1.05 * radius, .95 * radius, .25, divisions, 1);
  glPopAttrib();

  /* Would just do this with a push / pop, but that seems to be broken.
   * glGetMaterialfv also seems to be broken, so we can't use that either. */
  glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, black.c);

  glTranslatef(0, 0, .25);
  glColor3f(1, 1, 0);
  gluDisk(disk, .95 * radius, 1.05 * radius, divisions, 1);
  gluCylinder(cylinder, 1.05 * radius, 1.05 * radius, .1 * radius, 
	      divisions, 1);
  glTranslatef(0, 0, .1*radius);
  gluDisk(disk, .95 * radius, 1.05 * radius, divisions, 1);

  glPopMatrix();
}

void Telescope::draw_takedown()
{
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glMatrixMode(GL_MODELVIEW);
  glPopMatrix();
}

void Telescope::draw_lens()
{
  gluDisk(disk, 0, radius, divisions, 1);
}

void Telescope::set_divisions(int d)
{
  // Someday we'll put all the quadric stuff in display lists...
  divisions = d;
}

int Telescope::get_divisions()
{
  return divisions;
}

void Telescope::set_radius(GLfloat r)
{
  // Someday this might have to update some display lists
  radius = r;
}

GLfloat Telescope::get_radius()
{
  return radius;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\telescop.h ===
#ifndef TELESCOPE_H
#define TELESCOPE_H

class Telescope {
 public:
  Telescope(GLfloat x = 0, GLfloat y = 0);
  ~Telescope();

  /* This draws the "outside" of the telescope - the fov and aspect are
   * needed since it is drawn in eye coordinates */
  void draw_setup(GLfloat fov, GLfloat aspect = 1.0, int perspective = 1);
  void draw_fake();
  void draw_body();
  void draw_takedown();
  
  /* This just draws the lens - usually it will be used to draw the lens
   * into the stencil buffer */
  void draw_lens();

  /* How finally to divide things as we're drawing */
  void set_divisions(int d);
  int get_divisions();

  /* This is the radius of the lens - the rest of the dimensions depend
   * upon it */
  void set_radius(GLfloat r);
  GLfloat get_radius();

  /* Positions are in eye coordinates and go from [0, 1] */
  GLfloat xpos, ypos;
 private:
  int divisions;

  GLfloat radius; 

  GLUquadricObj *disk;
  GLUquadricObj *cylinder;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\stonehen.h ===
#include <windows.h>
#include "stonerc.h"

#pragma warning (disable : 4244)

#define M_PI 3.1415926

typedef HWND Widget;
typedef VOID *XtPointer;
typedef BOOL Boolean;
typedef UINT Dimension;

#define WINDSIZEX(Rect)   (Rect.right  - Rect.left)
#define WINDSIZEY(Rect)   (Rect.bottom - Rect.top)

#define WM_INIT		WM_USER

typedef struct
{
    int	button;
    int x;
    int y;
}XButton;

typedef struct
{
    int	x;
    int	y;
}XMotion;

typedef struct
{
    int	    type;
    XButton xbutton;
    XMotion xmotion;
} XEvent;

typedef struct
{
    int     reason;
    XEvent  *event;
    Dimension width, height;		/* for resize callback */
} GLwDrawingAreaCallbackStruct;

/*
** RGB Image Structure
*/

typedef struct _RGBImageRec {
    GLint sizeX, sizeY;
    unsigned char *data;
} RGBImageRec;


#define Button1		1
#define Button2		2

#define ButtonPress	1
#define ButtonRelease	2
#define	MotionNotify	3

RGBImageRec *RGBImageLoad(char *);

#define TK_RGBImageRec RGBImageRec
#define tkRGBImageLoad RGBImageLoad
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\stone.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
#include "stonehen.h"
#endif

#include "Stone.h"

const GLfloat root2 = 1.4142136;
const GLfloat root3 = sqrt(3.);
const GLfloat rt_half = .70710678;

inline float radians(float a) {return M_PI * a / 180.0; }

inline float sign(float a) {return (a > 0. ? 1 : (a < 0. ? -1 : 0)); }

Stone::Stone() 
{
  translation.set(0, 0, 0);
  rotation = 0;
  dimensions.set(1, 1, 1);

  erosion = 0;

  points_valid = transforms_valid = 0;
}

Stone::~Stone() 
{
}

Stone Stone::operator=(Stone a)
{
  int i;

  translation = a.translation;
  rotation = a.rotation;
  dimensions = a.dimensions;

  erosion = a.erosion;

  if (a.points_valid && a.transforms_valid) {
    for (i = 0; i < 24; i++) points[i] = a.points[i];
    points_valid = transforms_valid = 1;
  } else points_valid = transforms_valid = 0;

  return *this;
}

void Stone::set_dimensions(GLfloat x, GLfloat y, GLfloat z)
{
  dimensions.set(x, y, z);
  points_valid = 0;
}

void Stone::set_dimensions(Point p)
{
  dimensions = p;
  points_valid = 0;
}

void Stone::erode(float p)
{
  erosion += p;
  points_valid = 0;
}

void Stone::translate(GLfloat x, GLfloat y, GLfloat z)
{
  translation.pt[0] += x;
  translation.pt[1] += y;
  translation.pt[2] += z;
  points_valid = 0;
}

void Stone::translate(Point p)
{
  translation += p;
  points_valid = 0;
}

void Stone::rotate_self_aboutz(GLfloat angle)
{
  rotation += angle;
  points_valid = 0;
}

void Stone::draw()
{
  compute_points();

  glPushMatrix();
  glRotatef(rotation, 0, 0, 1);
  glTranslatef(translation.pt[0], translation.pt[1], translation.pt[2]);
  glScalef(dimensions.pt[0], dimensions.pt[1], dimensions.pt[2]);

  draw_faces();
  draw_edges();
  draw_corners();

  glPopMatrix();
}

void Stone::compute_points()
{
  GLfloat e = 1.0 - erosion;

  if (points_valid) return;

  points[0].set(1, e, e);
  points[1].set(e, 1, e);
  points[2].set(e, e, 1);

  points[3].set(-e, e, 1);
  points[4].set(-e, 1, e);
  points[5].set(-1, e, e);

  points[6].set(e, -e, 1);
  points[7].set(e, -1, e);
  points[8].set(1, -e, e);

  points[9 ].set(e, e, -1);
  points[10].set(e, 1, -e);
  points[11].set(1, e, -e);

  points[12].set(-1, -e, e);
  points[13].set(-e, -1, e);
  points[14].set(-e, -e, 1);

  points[15].set(1, -e, -e);
  points[16].set(e, -1, -e);
  points[17].set(e, -e, -1);

  points[18].set(-1, e, -e);
  points[19].set(-e, 1, -e);
  points[20].set(-e, e, -1);
  
  points[21].set(-e, -e, -1);
  points[22].set(-e, -1, -e);
  points[23].set(-1, -e, -e);

  points_valid = 1;
  transforms_valid = 0;
}

inline Point Stone::trans_rot_point(Point p, float c, float s)
{
  Point val;
  val = p + translation;
  val = val.rotate_aboutz(c, s);
  return val;
}

inline Point Stone::transform_point(Point p, float c, float s)
{
  Point val;
  val = p.scale(dimensions);
  val += translation;
  val = val.rotate_aboutz(c, s);
  return val;
}

void Stone::transform_points()
{
  float c, s;
  int i;

  if (points_valid && transforms_valid) return;
  points_valid = 0;
  compute_points();

  c = cos(radians(rotation));
  s = sin(radians(rotation));

  for (i = 0; i < 24; i++) points[i] = transform_point(points[i], c, s);

  points_valid = 0;
  transforms_valid = 1;
}	

void Stone::draw_faces(int flat)
{
  draw_faces(points, flat);
}

void Stone::draw_faces(Point *p, int flat)
{
  glBegin(GL_QUADS);

  glNormal3f(1, 0, 0);
  if (flat) glTexCoord2fv(p[15].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[15].pt);
  if (flat) glTexCoord2fv(p[11].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[11].pt);
  if (flat) glTexCoord2fv(p[0].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[0].pt);
  if (flat) glTexCoord2fv(p[8].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[8].pt);

  glNormal3f(-1, 0, 0);
  if (flat) glTexCoord2fv(p[12].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[12].pt);
  if (flat) glTexCoord2fv(p[5].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[5].pt);
  if (flat) glTexCoord2fv(p[18].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[18].pt);
  if (flat) glTexCoord2fv(p[23].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[23].pt);

  glNormal3f(0, 1, 0);
  if (flat) glTexCoord2fv(p[4].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[4].pt);
  if (flat) glTexCoord2fv(p[1].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[1].pt);
  if (flat) glTexCoord2fv(p[10].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[10].pt);
  if (flat) glTexCoord2fv(p[19].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[19].pt);
  
  glNormal3f(0, -1, 0);
  if (flat) glTexCoord2fv(p[22].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[22].pt);
  if (flat) glTexCoord2fv(p[16].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[16].pt);
  if (flat) glTexCoord2fv(p[7].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[7].pt);
  if (flat) glTexCoord2fv(p[13].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[13].pt);

  glNormal3f(0, 0, 1);
  if (flat) glTexCoord2fv(p[14].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[14].pt);
  if (flat) glTexCoord2fv(p[6].pt); 
  else glTexCoord2f(1, 0);
  glVertex3fv(p[6].pt);
  if (flat) glTexCoord2fv(p[2].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[2].pt);
  if (flat) glTexCoord2fv(p[3].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[3].pt);

  glNormal3f(0, 0, -1);
  if (flat) glTexCoord2fv(p[20].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[20].pt);
  if (flat) glTexCoord2fv(p[9].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[9].pt);
  if (flat) glTexCoord2fv(p[17].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[17].pt);
  if (flat) glTexCoord2fv(p[21].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[21].pt);

  glEnd();
}

void Stone::draw_edges(int flat)
{
  draw_edges(points, flat);
}

void Stone::draw_edges(Point *p, int flat)
{
  Point n1, n2;

  glBegin(GL_QUADS);

  n1.set(0, 1, 0);
  n2.set(1, 0, 0);
  draw_edge(n1, n2, p, 10, 1, 0, 11, flat);

  n1.set(1, 0, 0);
  n2.set(0, -1, 0);
  draw_edge(n1, n2, p, 15, 8, 7, 16, flat);

  n1.set(1, 0, 0);
  n2.set(0, 0, 1);
  draw_edge(n1, n2, p, 8, 0, 2, 6, flat);

  n1.set(1, 0, 0);
  n2.set(0, 0, -1);
  draw_edge(n1, n2, p, 11, 15, 17, 9, flat);

  n1.set(0, 1, 0);
  n2.set(-1, 0, 0);
  draw_edge(n1, n2, p, 4, 19, 18, 5, flat);

  n1.set(-1, 0, 0);
  n2.set(0, -1, 0);
  draw_edge(n1, n2, p, 12, 23, 22, 13, flat);
  
  n1.set(-1, 0, 0);
  n2.set(0, 0, 1);
  draw_edge(n1, n2, p, 5, 12, 14, 3, flat);

  n2.set(-1, 0, 0);
  n1.set(0, 0, -1);
  draw_edge(n1, n2, p, 20, 21, 23, 18, flat);
    
  n1.set(0, 1, 0);
  n2.set(0, 0, 1);
  draw_edge(n1, n2, p, 1, 4, 3, 2, flat);

  n1.set(0, 1, 0);
  n2.set(0, 0, -1);
  draw_edge(n1, n2, p, 19, 10, 9, 20, flat);

  n1.set(0, -1, 0);
  n2.set(0, 0, 1);
  draw_edge(n1, n2, p, 13, 7, 6, 14, flat);

  n1.set(0, -1, 0);
  n2.set(0, 0, -1); 
  draw_edge(n1, n2, p, 16, 22, 21, 17, flat);

  glEnd();
}

void Stone::draw_edge(Point n1, Point n2, Point *p, 
		      int a, int b, int c, int d, int flat)
{
  glNormal3fv(n1.pt);
  if (flat) glTexCoord2fv(p[a].pt);
  else glTexCoord2f(0, 0);
  glVertex3fv(p[a].pt);
  if (flat) glTexCoord2fv(p[b].pt);
  else glTexCoord2f(0, 1);
  glVertex3fv(p[b].pt);
  glNormal3fv(n2.pt);
  if (flat) glTexCoord2fv(p[c].pt);
  else glTexCoord2f(1, 1);
  glVertex3fv(p[c].pt);
  if (flat) glTexCoord2fv(p[d].pt);
  else glTexCoord2f(1, 0);
  glVertex3fv(p[d].pt);
}

void Stone::draw_corners(Point *p, int flat)
{
  GLfloat e = 1.0 - erosion;

  glBegin(GL_TRIANGLES);

  if (flat) glTexCoord2fv(p[0].pt);
  else glTexCoord2f(0, 0);
  glNormal3f(1, 0, 0);
  glVertex3fv(p[0].pt);
  if (flat) glTexCoord2fv(p[1].pt);
  else glTexCoord2f(1, 0);
  glNormal3f(0, 1, 0);
  glVertex3fv(p[1].pt);
  if (flat) glTexCoord2fv(p[2].pt);
  else glTexCoord2f(.5, 1);
  glNormal3f(0, 0, 1);
  glVertex3fv(p[2].pt);

  if (flat) glTexCoord2fv(p[3].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(0, 0, 1);
  glVertex3fv(p[3].pt);
  if (flat) glTexCoord2fv(p[4].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, 1, 0);
  glVertex3fv(p[4].pt);
  if (flat) glTexCoord2fv(p[5].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(-1, 0, 0);
  glVertex3fv(p[5].pt);

  if (flat) glTexCoord2fv(p[6].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(0, 0, 1);
  glVertex3fv(p[6].pt);
  if (flat) glTexCoord2fv(p[7].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, -1, 0);
  glVertex3fv(p[7].pt);
  if (flat) glTexCoord2fv(p[8].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(1, 0, 0);
  glVertex3fv(p[8].pt);

  if (flat) glTexCoord2fv(p[9].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(0, 0, -1);
  glVertex3fv(p[9].pt);
  if (flat) glTexCoord2fv(p[10].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, 1, 0);
  glVertex3fv(p[10].pt);
  if (flat) glTexCoord2fv(p[11].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(1, 0, 0);
  glVertex3fv(p[11].pt);

  if (flat) glTexCoord2fv(p[12].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(-1, 0, 0);
  glVertex3fv(p[12].pt);
  if (flat) glTexCoord2fv(p[13].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, -1, 0);
  glVertex3fv(p[13].pt);
  if (flat) glTexCoord2fv(p[14].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(0, 0, 1);
  glVertex3fv(p[14].pt);

  if (flat) glTexCoord2fv(p[15].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(1, 0, 0);
  glVertex3fv(p[15].pt);
  if (flat) glTexCoord2fv(p[16].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, -1, 0);
  glVertex3fv(p[16].pt);
  if (flat) glTexCoord2fv(p[17].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(0, 0, -1);
  glVertex3fv(p[17].pt);

  if (flat) glTexCoord2fv(p[18].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(-1, 0, 0);
  glVertex3fv(p[18].pt);
  if (flat) glTexCoord2fv(p[19].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, 1, 0);
  glVertex3fv(p[19].pt);
  if (flat) glTexCoord2fv(p[20].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(0, 0, -1);
  glVertex3fv(p[20].pt);

  if (flat) glTexCoord2fv(p[21].pt); 
  else glTexCoord2f(0, 0);
  glNormal3f(0, 0, -1);
  glVertex3fv(p[21].pt);
  if (flat) glTexCoord2fv(p[22].pt); 
  else glTexCoord2f(1, 0);
  glNormal3f(0, -1, 0);
  glVertex3fv(p[22].pt);
  if (flat) glTexCoord2fv(p[23].pt); 
  else glTexCoord2f(.5, 1);
  glNormal3f(-1, 0, 0);
  glVertex3fv(p[23].pt);

  glEnd();
}

void Stone::draw_shadow(Point dlight) 
{
  Point p[24];
  int i;

  transform_points();
  for (i = 0; i < 24; i++) {
    p[i] = points[i];
    if (p[i].pt[2] < 0.0) p[i].pt[2] = 0.0;
    p[i] = p[i].project_direction(dlight);
  }
  draw_faces(p, 1);
  draw_edges(p, 1);
  draw_corners(p, 1);
}

void Stone::draw_shadow(Point dlight, GLfloat blur, 
			Color color, Color diffuse)
{
  float b = 1.0 + blur;
  float c, s;
  Point p[8], pp[8];
  Point d, n;
  Color colorp, diffusep;
  int draw[6];
  int i;

  if (blur == 0.0) {
    draw_shadow(dlight);
    return;
  }

  colorp = color;
  color.c[3] = 1;
  colorp.c[3] = 0;
  diffusep = diffuse;
  diffuse.c[3] = 1;
  diffusep.c[3] = 0;

  /* We're being slightly cowardly here and ignoring the erosion - it
   * shouldn't make a big difference */
  p[0].set(-1, -1, -1);
  pp[0] = p[0];
  p[1].set(1, -1, -1);
  pp[1] = p[1];
  p[2].set(1, 1, -1);
  pp[2] = p[2];
  p[3].set(-1, 1, -1);
  pp[3] = p[3];
  p[4].set(-1, -1, 1);
  pp[4] = p[4];
  p[5].set(1, -1, 1);
  pp[5] = p[5];
  p[6].set(1, 1, 1);
  pp[6] = p[6];
  p[7].set(-1, 1, 1);
  pp[7] = p[7];

  c = cos(radians(rotation));
  s = sin(radians(rotation));
  for (i = 0; i < 8; i++) {
    p[i] = transform_point(p[i], c, s);

    /* This is a complete and utter hack - the net effect is that
     * points which are higher are displaced further when the penumbra 
     * is drawn */
    d = dimensions;
    d.pt[0] += blur * (pp[i].pt[2] + translation.pt[2]);
    d.pt[1] += blur * (pp[i].pt[2] + translation.pt[2]);
    d.pt[2] += blur * (pp[i].pt[2] + translation.pt[2]);
    pp[i] = pp[i].scale(d);
    pp[i] = trans_rot_point(pp[i], c, s);
    if (p[i].pt[2] < 0.0) p[i].pt[2] = 0.0;

    p[i] = p[i].project_direction(dlight);
    if (pp[i].pt[2] < 0.0) pp[i].pt[2] = 0.0;
    pp[i] = pp[i].project_direction(dlight);
  }

  /* Compute whether or not we should draw various parts of the shadow
   * based upon the normal direction */
  if (dlight.pt[2] > 0.0) dlight *= -1.0;
  n.set(0, 0, -1);
  n = n.rotate_aboutz(c, s);
  draw[0] = (dlight.dot(n) < 0.0);
  n.set(0, -1, 0);
  n = n.rotate_aboutz(c, s);
  draw[1] = (dlight.dot(n) < 0.0);
  n.set(1, 0, 0);
  n = n.rotate_aboutz(c, s);
  draw[2] = (dlight.dot(n) < 0.0);
  n.set(0, 1, 0);
  n = n.rotate_aboutz(c, s);
  draw[3] = (dlight.dot(n) < 0.0);
  n.set(-1, 0, 0);
  n = n.rotate_aboutz(c, s);
  draw[4] = (dlight.dot(n) < 0.0);
  n.set(0, 0, 1);
  n = n.rotate_aboutz(c, s);
  draw[5] = (dlight.dot(n) < 0.0);

  /* This part draws the "real" shadow */
  glColor4fv(color.c);
  glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);

  glBegin(GL_QUADS);

  if (draw[0]) {
    glVertex2fv(p[0].pt);
    glVertex2fv(p[1].pt);
    glVertex2fv(p[2].pt);
    glVertex2fv(p[3].pt);
  }

  if (draw[1]) {
    glVertex2fv(p[0].pt);
    glVertex2fv(p[1].pt);
    glVertex2fv(p[5].pt);
    glVertex2fv(p[4].pt);
  }

  if (draw[2]) {
    glVertex2fv(p[1].pt);
    glVertex2fv(p[2].pt);
    glVertex2fv(p[6].pt);
    glVertex2fv(p[5].pt);
  }

  if (draw[3]) {
    glVertex2fv(p[2].pt);
    glVertex2fv(p[3].pt);
    glVertex2fv(p[7].pt);
    glVertex2fv(p[6].pt);
  }

  if (draw[4]) {
    glVertex2fv(p[3].pt);
    glVertex2fv(p[0].pt);
    glVertex2fv(p[4].pt);
    glVertex2fv(p[7].pt);
  }

  if (draw[5]) {
    glVertex2fv(p[4].pt);
    glVertex2fv(p[5].pt);
    glVertex2fv(p[6].pt);
    glVertex2fv(p[7].pt);
  }

  glEnd();

  /* This part draws the penumbra */

  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

  glBegin(GL_QUADS);

  /* Top */
  if (draw[5]) {
    if (!draw[4]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[4].pt);
      glVertex2fv(p[5].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[5].pt);
      glVertex2fv(pp[4].pt);
    }

    if (!draw[2]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[5].pt);
      glVertex2fv(p[6].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[6].pt);
      glVertex2fv(pp[5].pt);
    }

    if (!draw[3]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[6].pt);
      glVertex2fv(p[7].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[7].pt);
      glVertex2fv(pp[6].pt);
    }

    if (!draw[4]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[7].pt);
      glVertex2fv(p[4].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[4].pt);
      glVertex2fv(pp[7].pt);
    }
  }
  /* End of Top */

  /* Sides */
  if ((draw[1] || draw[4]) && !(draw[1] && draw[4])) {
    glColor4fv(color.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
    glVertex2fv(p[0].pt);
    glVertex2fv(p[4].pt);
    glColor4fv(colorp.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
    glVertex2fv(pp[4].pt);
    glVertex2fv(pp[0].pt);
  }

  if ((draw[1] || draw[2]) && !(draw[1] && draw[2])) {
    glColor4fv(color.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
    glVertex2fv(p[1].pt);
    glVertex2fv(p[5].pt);
    glColor4fv(colorp.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
    glVertex2fv(pp[5].pt);
    glVertex2fv(pp[1].pt);
  }

  if ((draw[3] || draw[2]) && !(draw[3] && draw[2])) {
    glColor4fv(color.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
    glVertex2fv(p[2].pt);
    glVertex2fv(p[6].pt);
    glColor4fv(colorp.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
    glVertex2fv(pp[6].pt);
    glVertex2fv(pp[2].pt);
  }

  if ((draw[3] || draw[4]) && !(draw[3] && draw[4])) {
    glColor4fv(color.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
    glVertex2fv(p[3].pt);
    glVertex2fv(p[7].pt);
    glColor4fv(colorp.c);
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
    glVertex2fv(pp[7].pt);
    glVertex2fv(pp[3].pt);
  }
  /* End of Sides */

  /* Bottom */
  if (draw[0]) {
    if (!draw[1]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, diffuse.c);
      glVertex2fv(p[0].pt);
      glVertex2fv(p[1].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, diffusep.c);
      glVertex2fv(pp[1].pt);
      glVertex2fv(pp[0].pt);
    }
    
    if (!draw[2]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[1].pt);
      glVertex2fv(p[2].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[2].pt);
      glVertex2fv(pp[1].pt);
    }

    if (!draw[3]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[2].pt);
      glVertex2fv(p[3].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[3].pt);
      glVertex2fv(pp[2].pt);
    }
    
    if (!draw[4]) {
      glColor4fv(color.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffuse.c);
      glVertex2fv(p[3].pt);
      glVertex2fv(p[0].pt);
      glColor4fv(colorp.c);
      glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, diffusep.c);
      glVertex2fv(pp[0].pt);
      glVertex2fv(pp[3].pt);
    }
  }
  /* End of Bottom */

  glEnd();

  glDisable(GL_BLEND);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\stonehen.cxx ===
/******************************************************************************\
*       This is a part of the Microsoft Source Code Samples. 
*       Copyright (C) 1993 Microsoft Corporation.
*       All rights reserved. 
*       This source code is only intended as a supplement to 
*       Microsoft Development Tools and/or WinHelp documentation.
*       See these sources for detailed information regarding the 
*       Microsoft samples programs.
\******************************************************************************/


#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>

#include "stonehen.h"
#include <stdio.h>
#include <stdlib.h>

#include "atmosphe.h"
#include "scene.h"
#include "callback.h"
#include "setpixel.h"

extern int use_lighting;
extern int draw_shadows;
extern int use_normal_fog;
extern int use_textures;
extern int texture_hack;	// HACK HACK - only texture map stones for now
extern int use_telescope;
extern int use_antialias;
extern int cb_demo_mode;

BOOL Con;

BOOL bTimeScale[5];
extern GLfloat time_scale;

GLfloat TimeScale[] = {0, 1, 10, 100, 500};

char szAppName[] = "Stonehenge";

extern TimeDate last_update;

int curr_weather;

HGLRC hRC;

int  iTimer;

/* forward declarations of helper functions in this module */
HWND   WINAPI InitializeWindow (HINSTANCE, int);
VOID   WINAPI InitializeMenu (HWND, HMENU);
LONG   WINAPI CommandHandler (HWND, UINT, LONG);
LONG   WINAPI MainWndProc (HWND, UINT, UINT, LONG);

/* entry point of this executable */
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    MSG        msg;
    HWND       hWnd;

    /* previous instances do not exist in Win32 */
    if (hPrevInstance)
    return 0;

    if (!(hWnd = InitializeWindow (hInstance, nCmdShow)))
        return FALSE;

    /* main window message loop */
    while (GetMessage (&msg, NULL, 0, 0))
    {
      	TranslateMessage (&msg);
      	DispatchMessage (&msg);
    }

    /* return success of application */
    return TRUE;
}

HWND WINAPI InitializeWindow (HINSTANCE hInstance, int nCmdShow)
    {
    WNDCLASS   wc;
    HWND       hWnd;
    RECT       rect;

    /* Register the frame class */
    wc.style         = CS_OWNDC;
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon (hInstance, szAppName);
    wc.hCursor       = LoadCursor (NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = szAppName;
    wc.lpszClassName = szAppName;

    if (!RegisterClass (&wc) )
    return FALSE;

    rect.left = 100;
    rect.top  = 100;
    rect.right = 652;
    rect.bottom = 500;

    AdjustWindowRect(&rect, WS_OVERLAPPEDWINDOW, FALSE);
    /* Create the frame */
    hWnd = CreateWindow (szAppName,
             "OpenGL Stonehenge Demo",
             WS_OVERLAPPEDWINDOW,
             rect.left,
             rect.top,
             WINDSIZEX(rect),
             WINDSIZEY(rect),
             NULL,
             NULL,
             hInstance,
             NULL);

    /* make sure window was created */
    if (!hWnd)
    return FALSE;

    InitializeMenu(hWnd, (HMENU) GetMenu(hWnd));

    SendMessage(hWnd, WM_INIT, NULL, NULL);

    /* show and update main window */
    ShowWindow (hWnd, nCmdShow);

    UpdateWindow (hWnd);

    return hWnd;
}



/* main window procedure */
LONG WINAPI MainWndProc (
    HWND    hWnd,
    UINT    uMsg,
    UINT    uParam,
    LONG    lParam)
{
    LONG    lRet = 1;

    switch (uMsg)
    {
    case WM_CREATE:
        {
	    HDC			    hDC;

	    /* This is equivalent to the find_visual routine */
            hDC = GetDC(hWnd);
/*
            pfd.nSize = sizeof(PIXELFORMATDESCRIPTOR);
            pfd.nVersion = 1;
            pfd.dwFlags = PFD_DRAW_TO_WINDOW |
                          PFD_SUPPORT_OPENGL |
                          PFD_DOUBLEBUFFER);		//GLX_DOUBLEBUFFER
            pfd.iPixelType = PFD_TYPE_RGBA;		//GLX_RGBA
            pfd.cColorBits = 8;
            pfd.cRedBits = 1;				//GLX_RED_SIZE
            pfd.cRedShift = 0;
            pfd.cGreenBits = 1;				//GLX_GREEN_SIZE
            pfd.cGreenShift = 0;
            pfd.cBlueBits = 1;				//GLX_BLUE_SIZE
            pfd.cBlueShift = 0;
            pfd.cAlphaBits = 0;
            pfd.cAlphaShift = 0;
            pfd.cAccumBits = 0;				//ACCUM NOT SUPPORTED
            pfd.cAccumRedBits = 0; 			//GLX_ACCUM_RED_SIZE
            pfd.cAccumGreenBits = 0;			//GLX_ACCUM_GREEN_SIZE
            pfd.cAccumBlueBits = 0; 			//GLX_ACCUM_BLUE_SIZE
            pfd.cAccumAlphaBits = 0;			//GLX_ACCUM_ALPHA_SIZE
            pfd.cDepthBits = 1;				//GLX_DEPTH_SIZE
            pfd.cStencilBits = 1;			//GLX_STENCIL_SIZE
            pfd.cAuxBuffers = 0;
            pfd.iLayerType = PFD_MAIN_PLANE;
            pfd.bReserved = 0;
            pfd.dwLayerMask = 
            pfd.dwVisibleMask = 
            pfd.dwDamageMask = 0;

            iPixelFormat = ChoosePixelFormat(hDC, &pfd);
            if (iPixelFormat == 0) {
                char        text[128];

                wsprintf(text, "ChoosePixelFormat failed %d", GetLastError());
                MessageBox (GetFocus(),
                        text,
                        szAppName, MB_SYSTEMMODAL|MB_OK|MB_ICONHAND);
            }

*/
	    bSetupPixelFormat(hDC);

            hRC = wglCreateContext( hDC );
            Con = wglMakeCurrent( hDC, hRC );
	    
	    ReleaseDC(hWnd, hDC);

	    // iTimer = SetTimer(hWnd, 1, 1000, NULL);
	}
	break;


    case WM_TIMER:
	{
	
	PostMessage(hWnd, WM_PAINT, NULL, NULL);

	}
	break;

    case WM_PAINT:
        { 
	HDC		hDC;
	PAINTSTRUCT	ps;

	hDC = BeginPaint(hWnd, &ps);
	EndPaint(hWnd, &ps);

	drawWP(hWnd);

        }
	break;

    case WM_INIT:
	{
	    scene_init();

	    last_update.read_time();

	    resetViewerCB(NULL, NULL, NULL);
	
	}
	break;

    case WM_SIZE:
        {

	 resizeCB(hWnd, NULL, NULL);
	
        }
        break;

    case WM_COMMAND:
        /* handle all command messages in a localized function */
         lRet = CommandHandler (hWnd, uParam, lParam);
        break;

    case WM_LBUTTONDOWN:
	{
	GLwDrawingAreaCallbackStruct *call_data;

	call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct));
	call_data->event = (XEvent *) LocalAlloc(0, sizeof(XEvent));

	call_data->event->type = ButtonPress;
	call_data->event->xbutton.button = Button1;
	call_data->event->xbutton.x = LOWORD(lParam);
	call_data->event->xbutton.y = HIWORD(lParam);

	inputCB(hWnd, NULL, (LPVOID)call_data);
	LocalFree(call_data->event);
	LocalFree(call_data);
	}
	break;

    case WM_RBUTTONDOWN:
	{
	GLwDrawingAreaCallbackStruct *call_data;

	call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct));
	call_data->event = (XEvent *) LocalAlloc(0, sizeof(XEvent));

	call_data->event->type = ButtonPress;
	call_data->event->xbutton.button = Button2;
	call_data->event->xbutton.x = LOWORD(lParam);
	call_data->event->xbutton.y = HIWORD(lParam);

	inputCB(hWnd, NULL, (LPVOID)call_data);
	LocalFree(call_data->event);
	LocalFree(call_data);
	}
	break;

    case WM_LBUTTONUP:
	{
	GLwDrawingAreaCallbackStruct *call_data;

	call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct));
	call_data->event = (XEvent *) LocalAlloc(0, sizeof(XEvent));

	call_data->event->type = ButtonRelease;
	call_data->event->xbutton.button = Button1;

	inputCB(hWnd, NULL, (LPVOID)call_data);
	LocalFree(call_data->event);
	LocalFree(call_data);
	}
	break;

    case WM_RBUTTONUP:
	{
	GLwDrawingAreaCallbackStruct *call_data;

	call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct));
	call_data->event = (XEvent *) LocalAlloc(0, sizeof(XEvent));

	call_data->event->type = ButtonRelease;
	call_data->event->xbutton.button = Button2;

	inputCB(hWnd, NULL, (LPVOID)call_data);
	LocalFree(call_data->event);
	LocalFree(call_data);
	}
	break;

    case WM_MOUSEMOVE:
	{
	GLwDrawingAreaCallbackStruct *call_data;

	call_data = (GLwDrawingAreaCallbackStruct *) LocalAlloc(0, sizeof(GLwDrawingAreaCallbackStruct));
	call_data->event = (XEvent *) LocalAlloc(0, sizeof(XEvent));

	call_data->event->type = MotionNotify;
	call_data->event->xmotion.x = LOWORD(lParam);
	call_data->event->xmotion.y = HIWORD(lParam);

	inputCB(hWnd, NULL, (LPVOID)call_data);
	LocalFree(call_data->event);
	LocalFree(call_data);
	}
	break;

    case WM_CLOSE:
        {

	HGLRC hRC;

	if(hRC = wglGetCurrentContext())
	    wglDeleteContext(hRC);

	//KillTimer(iTimer);

        /* call destroy window to cleanup and go away */
        DestroyWindow (hWnd);
        }
        break;

    case WM_DESTROY:
        {
	wglDeleteContext(wglGetCurrentContext());
        PostQuitMessage (0);
        }
        break;

    default:
        /* pass all unhandled messages to DefWindowProc */
        lRet = DefWindowProc (hWnd, uMsg, uParam, lParam);
        break;
    }

    /* return 1 if handled message, 0 if not */
    return lRet;
}


/* handle all WM_COMMAND messages here */
LONG WINAPI CommandHandler (
    HWND    hWnd,
    UINT    uParam,
    LONG    lParam)
{
    int	    i;
    HMENU   hMenu;

    switch (LOWORD(uParam))
    {
    case IDM_EXIT:
        /* exit application */
        PostMessage (hWnd, WM_CLOSE, 0, 0L);
        break;

    case IDM_LIGHTING:
	hMenu = GetMenu(hWnd);
	use_lighting = !use_lighting;
	CheckMenuItem(hMenu,IDM_LIGHTING,(use_lighting?MF_CHECKED:MF_UNCHECKED));
	break;

    case IDM_SHADOWS:
	hMenu = GetMenu(hWnd);
	draw_shadows = !draw_shadows;
	CheckMenuItem(hMenu,IDM_SHADOWS,(draw_shadows?MF_CHECKED:MF_UNCHECKED));
	break;

    case IDM_FOG:
	hMenu = GetMenu(hWnd);
	use_normal_fog = !use_normal_fog;
	CheckMenuItem(hMenu,IDM_FOG,(use_normal_fog?MF_CHECKED:MF_UNCHECKED));
	break;

#ifdef TEXTURE
    case IDM_TEXTUREMAP:
	hMenu = GetMenu(hWnd);
/* HACK HACK HACK
 * This would be right, but for now I only want to map the stones, nothing
 * else, so I have a new variable - texture_hack
 
	use_textures = !use_textures;
	CheckMenuItem(hMenu,IDM_TEXTUREMAP,(use_textures?MF_CHECKED:MF_UNCHECKED));
 */
	texture_hack = !texture_hack;
	CheckMenuItem(hMenu,IDM_TEXTUREMAP,(texture_hack?MF_CHECKED:MF_UNCHECKED));
	break;
#endif

    case IDM_TELESCOPE:
	hMenu = GetMenu(hWnd);
	use_telescope = !use_telescope;
	CheckMenuItem(hMenu,IDM_TELESCOPE,(use_telescope?MF_CHECKED:MF_UNCHECKED));
	break;

    case IDM_ANTIALIAS:
	hMenu = GetMenu(hWnd);
	use_antialias = !use_antialias;
	CheckMenuItem(hMenu,IDM_ANTIALIAS,(use_antialias?MF_CHECKED:MF_UNCHECKED));
	break;

    case IDM_CLEAR:
    case IDM_FOGGY:
    case IDM_VERYFOGGY:
    case IDM_RAINY:
	hMenu = GetMenu(hWnd);
	/* If this value is already checked, we do nothing */
	if(curr_weather != (LOWORD(uParam) - IDM_CLEAR))
	{
	    CheckMenuItem(hMenu, curr_weather + IDM_CLEAR, MF_UNCHECKED);

	    CheckMenuItem(hMenu, LOWORD(uParam), MF_CHECKED);
	    curr_weather = LOWORD(uParam) - IDM_CLEAR;
	    scene_set_weather(weathers[curr_weather]);
	}

	break;

    case IDM_CURRENTTIME:
	currentTimeCB(hWnd);
	break;

    case IDM_10AM:
	time10amCB(hWnd);
	break;

    case IDM_NOON:
	time12pmCB(hWnd);
	break;

    case IDM_4PM:
	time4pmCB(hWnd);
	break;

    case IDM_HOLDTIME:
    case IDM_SCALE1:
    case IDM_SCALE10:
    case IDM_SCALE100:
    case IDM_SCALE500:	
	hMenu = GetMenu(hWnd);
	/* If this value is already checked, we do nothing */
	if(!bTimeScale[LOWORD(uParam) - IDM_HOLDTIME])
	{
	    for(i=0;!bTimeScale[i];i++);

	    time_scale = TimeScale[LOWORD(uParam) - IDM_HOLDTIME];

	    CheckMenuItem(hMenu, IDM_HOLDTIME + i, MF_UNCHECKED);
	    bTimeScale[i] = FALSE;

	    CheckMenuItem(hMenu, LOWORD(uParam), MF_CHECKED);
	    bTimeScale[LOWORD(uParam) - IDM_HOLDTIME] = TRUE;

	    timeSpeedCB(hWnd, NULL, NULL);
	}
	break;

    case IDM_DEMOMODE:
	hMenu = GetMenu(hWnd);
	
	cb_demo_mode = !cb_demo_mode;
	CheckMenuItem(hMenu,IDM_DEMOMODE,(cb_demo_mode?MF_CHECKED:MF_UNCHECKED));
	demo_modeCB(hWnd, NULL, NULL);
	break;

    case IDM_RESET:
	resetViewerCB(hWnd, NULL, NULL);
	break;

    default:
        return FALSE;
    }
    return TRUE;
}

VOID WINAPI InitializeMenu (HWND hWnd, HMENU hMenu)
{

    curr_weather = def_weather_index;

    CheckMenuItem(hMenu, IDM_CLEAR + curr_weather, MF_CHECKED);

    CheckMenuItem(hMenu, IDM_LIGHTING, MF_CHECKED);

    bTimeScale[0] = TRUE;
    bTimeScale[1] = FALSE;
    bTimeScale[2] = FALSE;
    bTimeScale[3] = FALSE;
    bTimeScale[4] = FALSE;

    CheckMenuItem(hMenu, IDM_HOLDTIME, MF_CHECKED);

    cb_demo_mode = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\timedate.h ===
#ifndef TIMEDATE_H
#define TIMEDATE_H

#include "Point.h"

#include <time.h>

class TimeDate {
 public:
  TimeDate() {};
  TimeDate(int hour, int minute = 0, int second = 0, long usecond = 0);
  TimeDate(struct tm t2) {t = t2;};
  
  TimeDate operator=(TimeDate a);
  TimeDate operator+(TimeDate a);
  TimeDate operator+(struct tm t2);
  TimeDate operator+=(TimeDate a);
  TimeDate operator-(TimeDate a);
  TimeDate operator*(float f);

  /* This reads the current clock time and returns itself */
  TimeDate read_time();

  void print();

  Point sun_direction(float lon = -93, float lat = 45);
 private:
  /* Call this if the time can only have gotten bigger */
  TimeDate correct_bigger();
  /* Call this if the time could have gotten bigger or smaller */
  TimeDate correct_smaller();

  struct tm t;
  /* This won't be quite accurate down to microseconds, but should be
   * reasonably close */
  long usec;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\global.h ===
/******************************Module*Header*******************************\
* Module Name: global.h
*
* Global declarations and constants.
*
* Created: 09-Mar-1995 15:16:47
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include "gl/gl.h"
#include "gl/glu.h"
#include "scene.h"

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

// ListBox functions.

extern void LBprintf(PCH, ...);
extern void LBreset(void);

// Global window handles.  Always handy to have around.

extern HINSTANCE ghInstance;
extern HWND hwndMain;
extern HWND hwndList;

extern CHAR lpstrFile[];

// Internal math routines.

#define ZERO_EPS    (GLfloat) 0.00000001
extern void calcNorm(GLfloat *norm, GLfloat *p1, GLfloat *p2, GLfloat *p3);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\glwindow.c ===
/******************************Module*Header*******************************\
* Module Name: glwindow.c
*
* OpenGL window maintenance.
*
* Created: 09-Mar-1995 15:10:10
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#include "global.h"
#include "glwindow.h"
#include "nff.h"
#include "trackbal.h"

// Move global stuff into SCENE struct.

HGLRC ghrc = (HGLRC) 0;
HPALETTE ghpalOld, ghPalette = (HPALETTE) 0;
BOOL bUseStatic = FALSE;
UINT uiSysPalUse = SYSPAL_STATIC;

extern void DoGlStuff(HWND, HDC);
extern HGLRC hrcInitGL(HWND, HDC);
extern void stateInit(HWND, HDC);
extern void vCleanupGL(HGLRC, HDC);
extern BOOL bSetupPixelFormat(HDC);
extern void CreateRGBPalette(HDC);
extern VOID vSetSize(HWND);
extern void ForceRedraw(HWND);
extern SCENE *OpenScene(LPSTR lpstrFile);

CHAR lpstrFile[256];

// Global ambient lights.

static GLfloat lightAmbient[4] = {0.4f, 0.4f, 0.4f, 1.0f};
static GLfloat lightAmbientLow[4] = {0.2f, 0.2f, 0.2f, 1.0f};

//!!!move to SCENE structure
// Trackball stuff

POINT   gptWindow;
SIZE    gszWindow;                  // already in SCENE
float   curquat[4], lastquat[4];
LONG    glMouseDownX, glMouseDownY;
BOOL    gbLeftMouse = FALSE;
BOOL    gbSpinning = FALSE;

float   zoom = 1.0f;

//!!!move to SCENE structure
typedef enum enumPOLYDRAW {
    POLYDRAW_FILLED = 0,
    POLYDRAW_LINES  = 1,
    POLYDRAW_POINTS = 2
    } POLYDRAW;
typedef enum enumSHADE {
    SHADE_SMOOTH    = 0,
    SHADE_FLAT      = 1
    } SHADE;
typedef enum enumLIGHT {
    LIGHT_OFF       = 0,
    LIGHT_INFINITE  = 1,
    LIGHT_LOCAL     = 2
    } LIGHT;
SHADE    gShadeMode = SHADE_SMOOTH;
POLYDRAW gPolyDrawMode = POLYDRAW_FILLED;
LIGHT    gLightMode = LIGHT_INFINITE;

/******************************Public*Routine******************************\
* MyCreateGLWindow
*
* Setup the windows.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HWND MyCreateGLWindow(HINSTANCE hInstance, LPTSTR lpstr)
{
    WNDCLASS  wc;
    RECT rcl;
    HWND hwnd;

    lstrcpy(lpstrFile, lpstr);

// Create the OpenGL window.

    wc.style = CS_OWNDC;
    wc.lpfnWndProc = GLWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "GLWClass";
    RegisterClass(&wc);

    hwnd = CreateWindow(
        "GLWClass",
        "OpenGL stuff",
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
        //CW_USEDEFAULT,
        //CW_USEDEFAULT,
        300,
        0,
        100,
        100,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    //!!!hack -- not really the right coordinates
    gptWindow.x = 0;
    gptWindow.y = 300;
    gszWindow.cx = 100;
    gszWindow.cy = 100;

    if (hwnd)
    {
        ShowWindow(hwnd, SW_NORMAL);
        UpdateWindow(hwnd);
    }

    SetTimer(hwnd, 1, 1, NULL);

    return hwnd;
}

/******************************Public*Routine******************************\
* GLWndProc
*
* WndProc for the OpenGL window.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long FAR PASCAL GLWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    long    lRet = 0;
    RECT    rcl;
    HDC     hdc;
    PAINTSTRUCT ps;
    SCENE   *scene;

    if (message != WM_CREATE)
        scene = (SCENE *) GetWindowLong(hwnd, GWL_USERDATA);

// Process window message.

    switch (message)
    {
    case WM_CREATE:
        //LBprintf("WM_CREATE");

        if(hdc = GetDC(hwnd))
        {
            if (ghrc == (HGLRC) 0)
                ghrc = hrcInitGL(hwnd, hdc);

            scene = OpenScene(lpstrFile);
            if (scene)
            {
                SetWindowLong(hwnd, GWL_USERDATA, (LONG) scene);
                rcl.left = 0;
                rcl.top = 0;
                rcl.right = scene->szWindow.cx;
                rcl.bottom = scene->szWindow.cy;
                AdjustWindowRect(&rcl, WS_OVERLAPPEDWINDOW, 0);
                SetWindowPos(hwnd, NULL, 0, 0,
                             rcl.right, rcl.bottom,
                             SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOCOPYBITS);

                stateInit(hwnd, hdc);
            }
            else
                lRet = -1;

            ReleaseDC(hwnd,hdc);
        }
        break;

    case WM_MOVE:
        gptWindow.x = (int) LOWORD(lParam);
        gptWindow.y = (int) HIWORD(lParam);

        break;

    case WM_SIZE:
        gszWindow.cx = LOWORD(lParam);
        gszWindow.cy = HIWORD(lParam);
        scene->szWindow.cx = LOWORD(lParam);
        scene->szWindow.cy = HIWORD(lParam);
        vSetSize(hwnd);
        ForceRedraw(hwnd);

        break;

    case WM_PAINT:
        //LBprintf("WM_PAINT");

        hdc = BeginPaint( hwnd, &ps );

        DoGlStuff( hwnd, hdc );

        EndPaint( hwnd, &ps );
        break;

    case WM_PALETTECHANGED:
        //LBprintf("WM_PALETTECHANGED");

        if (hwnd != (HWND) wParam)
        {
            if (hdc = GetDC(hwnd))
            {
                UnrealizeObject(ghPalette);
                SelectPalette(hdc, ghPalette, TRUE);
                if (RealizePalette(hdc) != GDI_ERROR)
                    lRet = 1;
            }
        }
        break;

    case WM_QUERYNEWPALETTE:
        //LBprintf("WM_QUERYNEWPALETTE");

        if (hdc = GetDC(hwnd))
        {
            UnrealizeObject(ghPalette);
            SelectPalette(hdc, ghPalette, FALSE);
            if (RealizePalette(hdc) != GDI_ERROR)
                lRet = 1;
        }
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_ESCAPE:     // <ESC> is quick exit

            PostMessage(hwnd, WM_DESTROY, 0, 0);
            break;

        case VK_UP:
            zoom *= .8f;
            if (zoom < 1.0f && zoom > .8f)
                zoom = 1.0f;
            LBprintf("Zoom = %f", zoom);
            vSetSize(hwnd);
            break;

        case VK_DOWN:
            zoom *= 1.25f;
            if (zoom > 1.0f && zoom < 1.25f)
                zoom = 1.0f;
            LBprintf("Zoom = %f", zoom);
            vSetSize(hwnd);
            break;

        default:
            break;
        }
        break;

    case WM_CHAR:
        switch(wParam)
        {
        case 's':
        case 'S':
            gShadeMode = (gShadeMode + 1) % 2;
            glShadeModel( gShadeMode == SHADE_FLAT ? GL_FLAT : GL_SMOOTH );
            LBprintf("glShadeModel(%s)", gShadeMode == SHADE_FLAT ? "GL_FLAT" :
                                                                    "GL_SMOOTH");
            break;

        case 'p':
        case 'P':
            gPolyDrawMode = (gPolyDrawMode + 1) % 3;
            switch (gPolyDrawMode)
            {
            case POLYDRAW_POINTS:
                glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
                break;
            case POLYDRAW_LINES:
                glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
                break;
            case POLYDRAW_FILLED:
            default:
                glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
                break;
            }
            LBprintf("glPolygonMode(%s)", gPolyDrawMode == POLYDRAW_POINTS ? "GL_POINT" :
                                          gPolyDrawMode == POLYDRAW_LINES  ? "GL_LINE" :
                                                                             "GL_FILL");
            break;

        case 'l':
        case 'L':
            gLightMode = (gLightMode + 1) % 3;
            if ( gLightMode != LIGHT_OFF )
            {
                int i;

                glEnable(GL_NORMALIZE);
                glEnable(GL_LIGHTING);
                glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
                glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,
                              gLightMode == LIGHT_LOCAL ? GL_TRUE : GL_FALSE);
                for (i = 0; i < scene->Lights.count; i++)
                {
                    glCallList(scene->Lights.listBase + i);
                    glEnable(GL_LIGHT0 + i);
                }

                /* If no other lights, turn on ambient on higher */

                if (!scene->Lights.count)
                    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, &lightAmbient);
                else
                    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, &lightAmbientLow);
            }
            else
            {
                glDisable(GL_NORMALIZE);
                glDisable(GL_LIGHTING);
            }
            LBprintf("Light = %s", gLightMode == LIGHT_OFF      ? "disabled" :
                                   gLightMode == LIGHT_INFINITE ? "infinite" :
                                                                  "local");
            break;

        default:
            break;
        }

        ForceRedraw(hwnd);

        break;

    case WM_LBUTTONDOWN:

        SetCapture(hwnd);

        glMouseDownX = LOWORD(lParam);
        glMouseDownY = HIWORD(lParam);
        gbLeftMouse = TRUE;

        ForceRedraw(hwnd);

        break;

    case WM_LBUTTONUP:

        ReleaseCapture();

        gbLeftMouse = FALSE;

        ForceRedraw(hwnd);

        break;

    case WM_TIMER:
        hdc = GetDC(hwnd);
        DoGlStuff( hwnd, hdc );
        ReleaseDC(hwnd, hdc);

        break;

    case WM_DESTROY:
        KillTimer(hwnd, 1);
        hdc = GetDC(hwnd);
        vCleanupGL(ghrc, hdc);
        ReleaseDC(hwnd, hdc);
        PostQuitMessage( 0 );
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

unsigned char threeto8[8] = {
    0, 0111>>1, 0222>>1, 0333>>1, 0444>>1, 0555>>1, 0666>>1, 0377
};

unsigned char twoto8[4] = {
    0, 0x55, 0xaa, 0xff
};

unsigned char oneto8[2] = {
    0, 255
};

unsigned char
ComponentFromIndex(i, nbits, shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits) {

    case 1:
        val &= 0x1;
        return oneto8[val];

    case 2:
        val &= 0x3;
        return twoto8[val];

    case 3:
        val &= 0x7;
        return threeto8[val];

    default:
        return 0;
    }
}

void
CreateRGBPalette(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    LOGPALETTE *pPal;
    int n, i;

    ppfd = &pfd;
    n = GetPixelFormat(hdc);
    DescribePixelFormat(hdc, n, sizeof(PIXELFORMATDESCRIPTOR), ppfd);

    if (ppfd->dwFlags & PFD_NEED_PALETTE) {
        n = 1 << ppfd->cColorBits;
        pPal = (PLOGPALETTE)LocalAlloc(LMEM_FIXED, sizeof(LOGPALETTE) +
                n * sizeof(PALETTEENTRY));
        pPal->palVersion = 0x300;
        pPal->palNumEntries = n;
        for (i=0; i<n; i++) {
            pPal->palPalEntry[i].peRed =
                    ComponentFromIndex(i, ppfd->cRedBits, ppfd->cRedShift);
            pPal->palPalEntry[i].peGreen =
                    ComponentFromIndex(i, ppfd->cGreenBits, ppfd->cGreenShift);
            pPal->palPalEntry[i].peBlue =
                    ComponentFromIndex(i, ppfd->cBlueBits, ppfd->cBlueShift);
            pPal->palPalEntry[i].peFlags = (i == 0 || i == 255) ? 0 : PC_NOCOLLAPSE;
        }
        ghPalette = CreatePalette(pPal);
        LocalFree(pPal);

        if (ppfd->dwFlags & PFD_NEED_SYSTEM_PALETTE)
        {
            uiSysPalUse = SetSystemPaletteUse(hdc, SYSPAL_NOSTATIC);
            bUseStatic = TRUE;
        }

        ghpalOld = SelectPalette(hdc, ghPalette, FALSE);
        n = RealizePalette(hdc);
        UnrealizeObject(ghPalette);
        n = RealizePalette(hdc);
    }
}

BOOL bSetupPixelFormat(HDC hdc)
{
    PIXELFORMATDESCRIPTOR pfd, *ppfd;
    int pixelformat;

    ppfd = &pfd;

    memset(ppfd, 0, sizeof(PIXELFORMATDESCRIPTOR));
    ppfd->nSize = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion = 1;
    ppfd->dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER;
    ppfd->dwLayerMask = PFD_MAIN_PLANE;

    ppfd->iPixelType = PFD_TYPE_RGBA;
    ppfd->cColorBits = 24;

    ppfd->cDepthBits = 16;
    ppfd->cAccumBits = 0;
    ppfd->cStencilBits = 0;

    pixelformat = ChoosePixelFormat(hdc, ppfd);

    if ( (pixelformat = ChoosePixelFormat(hdc, ppfd)) == 0 )
    {
        MessageBox(NULL, "ChoosePixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    if (SetPixelFormat(hdc, pixelformat, ppfd) == FALSE)
    {
        MessageBox(NULL, "SetPixelFormat failed", "Error", MB_OK);
        return FALSE;
    }

    CreateRGBPalette(hdc);

    return TRUE;
}

HGLRC hrcInitGL(HWND hwnd, HDC hdc)
{
    HGLRC hrc;

    /* Create a Rendering Context */

    bSetupPixelFormat( hdc );
    hrc = wglCreateContext( hdc );

    /* Make it Current */

    wglMakeCurrent( hdc, hrc );

    return hrc;
}

void stateInit(HWND hwnd, HDC hdc)
{
    GLint i;
    SCENE *scene = (SCENE *) GetWindowLong(hwnd, GWL_USERDATA);   //!!! pass instead

    glDrawBuffer(GL_BACK);

    /* Set the clear color */

    glClearColor( scene->rgbaClear.r, scene->rgbaClear.g,
                  scene->rgbaClear.b, scene->rgbaClear.a );

    /* Turn on z-buffer */

    glEnable(GL_DEPTH_TEST);

    /* Turn on backface culling */

    glFrontFace(GL_CCW);
    //glEnable(GL_CULL_FACE);

    /* Shading */

    glShadeModel( gShadeMode == SHADE_FLAT ? GL_FLAT : GL_SMOOTH );

    /* Polygon draw mode */

    switch (gPolyDrawMode)
    {
    case POLYDRAW_POINTS:
        glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
        break;
    case POLYDRAW_LINES:
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        break;
    case POLYDRAW_FILLED:
    default:
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        break;
    }

    /* Turn on the lights */

    if ( gLightMode != LIGHT_OFF )
    {
        glEnable(GL_NORMALIZE);
        glEnable(GL_LIGHTING);
        glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
        glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,
                      gLightMode == LIGHT_LOCAL ? GL_TRUE : GL_FALSE);
        for (i = 0; i < scene->Lights.count; i++)
        {
            glCallList(scene->Lights.listBase + i);
            glEnable(GL_LIGHT0 + i);
        }

        /* If no other lights, turn on ambient on higher */

        if (!scene->Lights.count)
            glLightModelfv(GL_LIGHT_MODEL_AMBIENT, &lightAmbient);
        else
            glLightModelfv(GL_LIGHT_MODEL_AMBIENT, &lightAmbientLow);
    }
    else
    {
        glDisable(GL_NORMALIZE);
        glDisable(GL_LIGHTING);
    }

    /* Setup viewport */

    vSetSize(hwnd);

    /* Initialize trackball */

    trackball(curquat, 0.0, 0.0, 0.0, 0.0);
}

VOID vSetSize(HWND hwnd)
{
    SCENE *scene = (SCENE *) GetWindowLong(hwnd, GWL_USERDATA);   //!!! pass instead
    MyXYZ xyzZoomFrom;
    GLfloat localPerspective = scene->AspectRatio;

    /* Adjust aspect ratio to window size */

    localPerspective *= ((GLfloat) scene->szWindow.cx / (GLfloat) scene->szWindow.cy);

    /* Compute the vector from xyzAt to xyzFrom */

    xyzZoomFrom.x = scene->xyzFrom.x - scene->xyzAt.x;
    xyzZoomFrom.y = scene->xyzFrom.y - scene->xyzAt.y;
    xyzZoomFrom.z = scene->xyzFrom.z - scene->xyzAt.z;

    /* Scale by the zoom factor */

    xyzZoomFrom.x *= zoom;
    xyzZoomFrom.y *= zoom;
    xyzZoomFrom.z *= zoom;

    /* Compute new xyzFrom */

    xyzZoomFrom.x += scene->xyzAt.x;
    xyzZoomFrom.y += scene->xyzAt.y;
    xyzZoomFrom.z += scene->xyzAt.x;

    /* Set up viewport extents */

    glViewport(0, 0, scene->szWindow.cx, scene->szWindow.cy);

    /* Set up the projection matrix */

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    //gluPerspective(scene->ViewAngle, scene->AspectRatio,
    //               scene->Hither, scene->Yon);
    gluPerspective(scene->ViewAngle, localPerspective,
                   scene->Hither, scene->Yon * zoom);

    /* Set up the model matrix */

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    //gluLookAt(scene->xyzFrom.x,scene->xyzFrom.y,scene->xyzFrom.z,
    //          scene->xyzAt.x,scene->xyzAt.y,scene->xyzAt.z,
    //          scene->xyzUp.x,scene->xyzUp.y,scene->xyzUp.z);
    gluLookAt(xyzZoomFrom.x,xyzZoomFrom.y,xyzZoomFrom.z,
              scene->xyzAt.x,scene->xyzAt.y,scene->xyzAt.z,
              scene->xyzUp.x,scene->xyzUp.y,scene->xyzUp.z);
}

void
vCleanupGL(HGLRC hrc, HDC hdc)
{
    //if (ghPalette)
    //    DeleteObject(SelectObject(ghdcMem, ghpalOld));

    /*  Destroy our context */

    wglDeleteContext( hrc );

    if (bUseStatic)
        SetSystemPaletteUse(hdc, uiSysPalUse);
}

void
ForceRedraw(HWND hwnd)
{
    MSG msg;

    if (!PeekMessage(&msg, hwnd, WM_PAINT, WM_PAINT, PM_NOREMOVE) )
    {
        InvalidateRect(hwnd, NULL, FALSE);
    }
}

void
DoGlStuff( HWND hwnd, HDC hdc )
{
    SCENE *scene = (SCENE *) GetWindowLong(hwnd, GWL_USERDATA);   //!!! pass instead
    USHORT usMouseCurX, usMouseCurY;
    POINT  pt;
    float  matRot[4][4];

    if (gbLeftMouse)
    {
        if (GetCursorPos(&pt))
        {
        // Subtract current window origin to convert to window coordinates.

            pt.x -= gptWindow.x;
            pt.y -= gptWindow.y;

        // If mouse has moved since button was pressed, change quaternion.

            if (pt.x != glMouseDownX || pt.y != glMouseDownY)
            {
                //trackball(lastquat,
                //          2.0*(gszWindow.cx-glMouseDownX)/gszWindow.cx-1.0,
                //          2.0*glMouseDownY/gszWindow.cy-1.0,
                //          2.0*(gszWindow.cx-pt.x)/gszWindow.cx-1.0,
                //          2.0*pt.y/gszWindow.cy-1.0);
                trackball(lastquat,
                          2.0*(glMouseDownX)/gszWindow.cx-1.0,
                          2.0*(gszWindow.cy-glMouseDownY)/gszWindow.cy-1.0,
                          2.0*(pt.x)/gszWindow.cx-1.0,
                          2.0*(gszWindow.cy-pt.y)/gszWindow.cy-1.0);

                gbSpinning = TRUE;
            }
            else
                gbSpinning = FALSE;

            glMouseDownX = pt.x;
            glMouseDownY = pt.y;
        }
    }

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    glPushMatrix();

    if (gbSpinning)
        add_quats(lastquat, curquat, curquat);

    build_rotmatrix(matRot, curquat);
    glMultMatrixf(&(matRot[0][0]));

    if (scene->Objects.count)
    {
        //LBprintf("call display list");

        glCallList(scene->Objects.listBase);
    }

    glPopMatrix();

    SwapBuffers(hdc);
}

SCENE *OpenScene(LPSTR lpstrFile)
{
    SCENE *scene = (SCENE *) NULL;
    CHAR *pchExt;

// Find the extension.

    pchExt = lpstrFile;
    while ((*pchExt != '.') && (*pchExt != '\0'))
        pchExt++;

    if (*pchExt == '.')
    {
    // Use extension as the key to call appropriate parser.

        if (!lstrcmpi(pchExt, ".nff"))
            scene = NffOpenScene(lpstrFile);
        else if (!lstrcmpi(pchExt, ".obj"))
            scene = ObjOpenScene(lpstrFile);
        else
            LBprintf("Unknown extension: %s", pchExt);
    }

    return scene;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\stonehen\timedate.cxx ===
#include <windows.h>
#include <GL/glu.h>

#ifdef X11
#include <GL/glx.h>
#endif

#ifdef WIN32
#include "stonehen.h"
#endif

#include "TimeDate.h"

#include <stdio.h>
#include <stdlib.h>
#ifdef X11
#include <sys/time.h>
#else
#include <time.h>
#endif

inline float sign(float a) {return a > 0.0 ? 1. : (a < 0.0 ? -1. : 0.);}

inline float degrees(float a) {return a * 180.0 / M_PI;}
inline float radians(float a) {return a * M_PI / 180.0;}

inline float arcsin(float a) {return atan2(a, sqrt(1.-a*a));}

/* Thirty days hath September... */
const int mday[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

TimeDate::TimeDate(int hour, int minute, int second, long usecond)
{
  read_time();
  t.tm_hour = hour;
  t.tm_min = minute;
  t.tm_sec = second;
  usec = usecond;
}

TimeDate TimeDate::operator=(TimeDate a)
{
  usec = a.usec;
  t = a.t;
  return *this;
}

TimeDate TimeDate::operator+(TimeDate a)
{
  TimeDate td;
  td = *this + a.t;
  td.usec = usec + a.usec;
  return td;
}

TimeDate TimeDate::operator+(struct tm t2)
{
  TimeDate td;
  td.usec = 0;
  td.t.tm_sec = t.tm_sec + t2.tm_sec;
  td.t.tm_min = t.tm_min + t2.tm_min;
  td.t.tm_hour = t.tm_hour + t2.tm_hour;
  td.t.tm_mday = t.tm_mday + t2.tm_mday;
  td.t.tm_mon = t.tm_mon + t2.tm_mon;
  td.t.tm_year = t.tm_year + t2.tm_year;
  td.t.tm_wday = t.tm_wday + t2.tm_wday;
  td.t.tm_yday = t.tm_yday + t2.tm_yday;
  return td;
}

TimeDate TimeDate::operator+=(TimeDate a)
{
  /* This is slower than it needs to be */
  *this = *this + a.t;
  return *this;
}

TimeDate TimeDate::operator-(TimeDate a)
{
  TimeDate td;
  td.usec = usec - a.usec;
  td.t.tm_sec = t.tm_sec - a.t.tm_sec;
  td.t.tm_min = t.tm_min - a.t.tm_min;
  td.t.tm_hour = t.tm_hour - a.t.tm_hour;
  td.t.tm_mday = t.tm_mday - a.t.tm_mday;
  td.t.tm_mon = t.tm_mon - a.t.tm_mon;
  td.t.tm_year = t.tm_year - a.t.tm_year;
  td.t.tm_wday = t.tm_wday - a.t.tm_wday;
  td.t.tm_yday = t.tm_yday - a.t.tm_yday;
  return td;
}

TimeDate TimeDate::operator*(float f)
{
  TimeDate td;
  td.usec = (long)((float)usec * f);
  td.t.tm_sec = (int)((float)t.tm_sec * f);
  td.t.tm_min = (int)((float)t.tm_min * f);
  td.t.tm_hour = (int)((float)t.tm_hour * f);
  td.t.tm_mday = (int)((float)t.tm_mday * f);
  td.t.tm_mon = (int)((float)t.tm_mon * f);
  td.t.tm_year = (int)((float)t.tm_year * f);
  td.t.tm_wday = (int)((float)t.tm_wday * f);
  td.t.tm_yday = (int)((float)t.tm_yday * f);
  return td;
}

TimeDate TimeDate::read_time()
{

#ifdef X11
  struct timeval tv;
#else
  LPSYSTEMTIME lpst;
#endif

  time_t cal_time;
  struct tm *tmp;

  cal_time = time(NULL);
  tmp = localtime(&cal_time);

#ifdef X11
  gettimeofday(&tv);
  usec = tv.tv_usec;
#else
  lpst = (LPSYSTEMTIME) malloc(sizeof(SYSTEMTIME));
  GetSystemTime(lpst);
  usec = 1000 * lpst->wMilliseconds;
#endif

  t = *tmp;
  return *this;
}

void TimeDate::print()
{
  puts(asctime(&t));
}


/* The sun_direction routine comes from an awk program by Stuart Levy
 * (slevy@geom.umn.edu) */

/* Day number of March 21st, roughly the vernal equinox */
const float equinox = mday[0] + mday[1] + 21;

/*
 *        Date     E.T. [degrees]
 *        Jan 1    0.82
 *        Jan 31   3.35
 *        Mar 1    3.08
 *        Mar 31   1.02
 *        Apr 30  -0.71
 *        May 30  -0.62
 *        Jun 29   0.87
 *        Jul 29   1.60
 *        Aug 28   0.28
 *        Sep 27  -2.28
 *        Oct 27  -4.03
 *        Nov 26  -3.15
 *        Dec 26   0.19
 */
const float et[] = {
  .82, 3.35, 3.08, 1.02, -.71, -.62, .87,
  1.60, .28, -2.28, -4.03, -3.15, .19, 2.02};

const float DEG = 180. / M_PI;

Point TimeDate::sun_direction(float lon, float lat)
{
  float yearday, eti, etoffset, ET, HA, LON, decl, altitude, azimuth;
  int etindex;
  Point dir;
  long tmp_usec;
  int m;

  tmp_usec = usec;
  usec = 0;
  *this = correct_smaller();

  /*
   *   hour angle of the sun (time since local noon):
   *       HA = (time - noon) * 15 degrees/hour
   *          + (observer''s east longitude - long. of time zone''s 
   *			       central meridian
   *                           POSITIVE east, NEGATIVE west)
   *          - (15 degrees if time above was daylight savings time, else 0)
   *          - "equation of time" (depends on date, correcting the 
   *		   hour angle for
   *               the earth''s elliptical orbit and the slope of the ecliptic)
   */
  yearday = (float)t.tm_mday + 
    ((float)t.tm_hour + (float)t.tm_min / 60.0) / 24.0;
  for (m = 0; m < t.tm_mon; m++) yearday += mday[m];

  /*
   * Index into equation-of-time table, tabulated at 30-day intervals
   * We''ve added an extra entry at the end of the et table, corresponding
   * to January 25th of the following year, to make interpolation work
   * throughout the year.
   * Use simple linear interpolation.
   */
  eti = (yearday - 1.) / 30.;
#ifdef X11
  etoffset = eti - trunc(eti);
  etindex = (int)trunc(eti) + 1;
#else
  etoffset = eti - (int)eti;
  etindex = (int)eti + 1;
#endif
  ET = et[etindex - 1] + etoffset*(et[etindex+1 - 1] - et[etindex - 1]);
  /* The 90. puts us in the Central time zone */
  HA = ((float)t.tm_hour + (float)t.tm_min/60. - 12.)*15. +
    lon + 90. - ET;

  /*
   *    Sun''s declination:
   *        sun''s longitude = (date - March 21) * 360 degrees / 365.25 days
   *                [This ignores the earth''s elliptical orbit...]
   */
  LON = (yearday - equinox) * 360. / 365.25;
  decl = DEG * arcsin( sin(LON/DEG) * sin(23.4/DEG) );

  /* 
   *    Then a spherical triangle calculation to convert the Sun''s
   *    hour angle and declination, and the observer''s latitude,
   *    to give the Sun''s altitude and azimuth (angle east from north).
   */
  altitude = DEG * arcsin( sin(decl/DEG)*sin(lat/DEG) 
			  + cos(decl/DEG)*cos(lat/DEG)*cos(HA/DEG) );
  azimuth = DEG * atan2( -cos(decl/DEG)*sin(HA/DEG), 
			sin(decl/DEG)*cos(lat/DEG) 
			- cos(decl/DEG)*cos(HA/DEG)*sin(lat/DEG) );

  /*
  printf("On %d/%d at %d:%02d, lat %g, lon %g\n", 
	 t.tm_mon + 1, t.tm_mday + 1, t.tm_hour, t.tm_min, lat, lon);
  printf("HA %.1f ET %.1f Sun lon %.1f decl %.1f alt %.1f az %.1f\n", 
	 HA,ET,LON,decl,altitude,azimuth);
  */
  
  dir.pt[2] = sin(radians(altitude));
  dir.pt[0] = cos(radians(azimuth));
  dir.pt[1] = sin(radians(azimuth));
  dir.pt[3] = 0;
  dir.unitize();
  // dir.print();

  usec = tmp_usec;

  return dir;
}

TimeDate TimeDate::correct_bigger()
{
  TimeDate td;
  int days;

  td.t = t;
  td.usec = usec;

  td.t.tm_sec += (int)(td.usec / 1000000);
  td.usec %= 1000000;
  td.t.tm_min += td.t.tm_sec / 60;
  td.t.tm_sec %= 60;
  td.t.tm_hour += td.t.tm_min / 60;
  td.t.tm_min %= 60;

  if (td.t.tm_hour > 23) {
    days = td.t.tm_hour / 24;
    td.t.tm_hour %= 24;
    td.t.tm_mday += days;
    td.t.tm_wday = (td.t.tm_wday + days) % 7;
    td.t.tm_yday = (td.t.tm_yday + days) % 365;
    while (td.t.tm_mday > mday[td.t.tm_mon]) {
      td.t.tm_mday -= mday[td.t.tm_mon++];
      if (td.t.tm_mon >= 12) {
	td.t.tm_year += td.t.tm_mon / 12;
	td.t.tm_mon %= 12;
      }
    }
  }
  return td;
}

TimeDate TimeDate::correct_smaller()
{
  TimeDate td;

  td.t = t;
  td.usec = usec;

  while (td.usec < 0) {
    td.t.tm_sec--;
    td.usec += 1000000;
  }
  while (td.t.tm_sec < 0) {
    td.t.tm_min--;
    td.t.tm_sec += 60;
  }
  while (td.t.tm_min < 0) {
    td.t.tm_hour--;
    td.t.tm_min += 60;
  }
  while (td.t.tm_hour < 0) {
    td.t.tm_mday--;
    if (td.t.tm_wday) td.t.tm_wday--;
    else td.t.tm_wday = 6;
    td.t.tm_yday--;
    td.t.tm_hour += 24;
  }
  if (td.t.tm_mon < 0 || td.t.tm_year < 0 || td.t.tm_yday < 0)  {
    fprintf(stderr, "Warning:  day < 0 in TimeDate.c++.\n");
    td.t.tm_mon = td.t.tm_year = td.t.tm_yday = 0;
  }
  return td.correct_bigger();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\math.c ===
/******************************Module*Header*******************************\
* Module Name: math.c
*
* Useful math routines.
*
* Created: 14-Mar-1995 22:35:54
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <math.h>
#include <gl/gl.h>

#include "global.h"

/******************************Public*Routine******************************\
* calcNorm
*
* Compute the normal vector for the given three vertices.  Assume CCW
* ordering.
*
* History:
*  14-Mar-1995 -by- Gilman Wong [gilmanw]
* Taken from Otto's screen saver code.
\**************************************************************************/

void calcNorm(GLfloat *norm, GLfloat *p1, GLfloat *p2, GLfloat *p3)
{
    GLfloat crossX, crossY, crossZ;
    GLfloat abX, abY, abZ;
    GLfloat acX, acY, acZ;
    GLfloat sqrLength;
    GLfloat invLength;

    if (!norm || !p1 || !p2 || !p3)
    {
        LBprintf("calcNorm: bad array (0x%lx, 0x%lx, 0x%lx, 0x%lx)",
                 norm, p1, p2, p3);
        return;
    }

    abX = p2[0] - p1[0];       // calculate p2 - p1
    abY = p2[1] - p1[1];
    abZ = p2[2] - p1[2];

    acX = p3[0] - p1[0];       // calculate p3 - p1
    acY = p3[1] - p1[1];
    acZ = p3[2] - p1[2];

    crossX = (abY * acZ) - (abZ * acY);    // get cross product
    crossY = (abZ * acX) - (abX * acZ);    // (p2 - p1) X (p3 - p1)
    crossZ = (abX * acY) - (abY * acX);

    sqrLength = (crossX * crossX) + (crossY * crossY) +
                 (crossZ * crossZ);

    if (sqrLength > ZERO_EPS)
        invLength = (float) (1.0 / sqrt(sqrLength));
    else
        invLength = 1.0f;

    norm[0] = crossX * invLength;
    norm[1] = crossY * invLength;
    norm[2] = crossZ * invLength;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\trackbal.c ===
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 */
#include <math.h>
#include "trackbal.h"

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void
vzero(float *v)
{
    v[0] = 0.0;
    v[1] = 0.0;
    v[2] = 0.0;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0) t = 1.0;
    if (t < -1.0) t = -1.0;
    phi = 2.0 * asin(t);

    axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,sin(phi/2.0));
    q[3] = cos(phi/2.0);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440) {    /* Inside sphere */
	z = sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    int i;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0 - 2.0 * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0 * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0 * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0;

    m[1][0] = 2.0 * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0 - 2.0 * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0 * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0;

    m[2][0] = 2.0 * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0 * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0 - 2.0 * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0;

    m[3][0] = 0.0;
    m[3][1] = 0.0;
    m[3][2] = 0.0;
    m[3][3] = 1.0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\glwindow.h ===
/******************************Module*Header*******************************\
* Module Name: glwindow.h
*
* Declarations for glwindow.c.
*
* Created: 14-Mar-1995 23:44:13
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _GLWIND_H_
#define _GLWIND_H_

HWND MyCreateGLWindow(HINSTANCE hInstance, LPTSTR lpsz);
long FAR PASCAL GLWndProc(HWND, UINT, WPARAM, LPARAM);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\trackbal.h ===
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * if ox,oy is the window's center and sizex,sizey is its size, then
 * the proper transformation from screen coordinates (sc) to world
 * coordinates (wc) is:
 * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0
 * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
axis_to_quat(float a[3], float phi, float q[4]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\nff.c ===
/******************************Module*Header*******************************\
* Module Name: nff.c
*
* Parse the Neutral File Format (.NFF) by Eric Haines of 3D/Eye Inc.
*
* Documentation on NFF available from a varity of sources including:
*
*   Eric Haines, 3D/Eye Inc., 2359 N. Triphammer Rd., Ithaca, NY, 14850,
*   erich@eye.com.
*
*   Murray, J. D. and van Ryper, W., _Encyclopedia of Graphics File Formats_,
*   O'Reilly & Associates, 1994, pp. 471-478.
*
* Created: 14-Mar-1995 23:26:34
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

#include "global.h"
#include "nff.h"

#define STATIC

typedef struct tagNFFPRIV
{
    BOOL bInList;       // TRUE while compiling display list
    BOOL bKayHack;      // support for the 'k' backface color hack
} NFFPRIV;

GLint maxLights;

STATIC void parseNffFile(SCENE *, LPTSTR);
STATIC void DoDisplayList(SCENE *);
STATIC void EndDisplayList(SCENE *);
STATIC void parseNffViewpoint(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffBackground(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffLight(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffColor(SCENE *scene, FILE *file, char *ach, int n, GLenum matSide);
STATIC void parseNffCone(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffSphere(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffPolygon(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseNffPolygonPatch(SCENE *scene, FILE *file, char *ach, int n);

SCENE *NffOpenScene(LPTSTR lpstr)
{
    SCENE *scene;

    scene = (SCENE *) LocalAlloc(LMEM_FIXED, sizeof(SCENE) + sizeof(NFFPRIV));
    if (scene)
    {
        NFFPRIV *nffPriv = (NFFPRIV *) (scene + 1);

        glGetIntegerv(GL_MAX_LIGHTS, &maxLights);

        scene->xyzFrom.x = 0.0;
        scene->xyzFrom.y = 0.0;
        scene->xyzFrom.z = 5.0;

        scene->xyzAt.x = 0.0;
        scene->xyzAt.y = 0.0;
        scene->xyzAt.z = 0.0;

        scene->xyzUp.x = 0.0;
        scene->xyzUp.y = 1.0;
        scene->xyzUp.z = 0.0;

        scene->ViewAngle   = 45.0f;
        scene->Hither      = 0.1f;
        scene->Yon         = 1000000000.0f; // always "infinity" for NFF
        scene->AspectRatio = 1.0f;          // always 1.0 for NFF

        scene->szWindow.cx = 300;
        scene->szWindow.cy = 300;

        scene->rgbaClear.r = (GLfloat) 0.0; // default is black
        scene->rgbaClear.g = (GLfloat) 0.0;
        scene->rgbaClear.b = (GLfloat) 0.0;
        scene->rgbaClear.a = (GLfloat) 1.0;

        scene->Lights.count = 0;
        scene->Lights.listBase = 1;

        scene->Objects.count = 1;
        scene->Objects.listBase = maxLights + 1;

        scene->pvData = (VOID *) nffPriv;
        nffPriv->bInList = FALSE;
        nffPriv->bKayHack = FALSE;

        LBprintf("================================");
        LBprintf("Parsing NFF file, please wait...");
        LBprintf("================================");
        parseNffFile(scene, lpstr);
        LBprintf("Here we go!");
    }
    else
    {
        LBprintf("NffOpenScene: memory allocation failure");
    }

    return scene;
}

STATIC void parseNffFile(SCENE *scene, LPTSTR lpstr)
{
    FILE *file;
    char ach[512];
    char achToken[5];

    file = fopen(lpstr, "r");

    if (file)
    {
        BOOL bKeepGoing = TRUE;

        do
        {
            if (fgets(ach, 512, file) != NULL)
            {
                switch(ach[0])
                {
                case 'v':
                case 'V':
                    parseNffViewpoint(scene, file, ach, 512);
                    break;

                case 'b':
                case 'B':
                    parseNffBackground(scene, file, ach, 512);
                    break;

                case 'l':
                case 'L':
                    parseNffLight(scene, file, ach, 512);
                    break;

                case 'f':
                case 'F':
                    if (((NFFPRIV *)scene->pvData)->bKayHack)
                        parseNffColor(scene, file, ach, 512, GL_FRONT);
                    else
                        parseNffColor(scene, file, ach, 512, GL_FRONT_AND_BACK);
                    break;

                case 'k':
                case 'K':
                    parseNffColor(scene, file, ach, 512, GL_BACK);
                    ((NFFPRIV *)scene->pvData)->bKayHack = TRUE;
                    break;

                case 'c':
                case 'C':
                    parseNffCone(scene, file, ach, 512);
                    break;

                case 's':
                case 'S':
                    parseNffSphere(scene, file, ach, 512);
                    break;

                case 'p':
                case 'P':
                    if ((ach[1] == 'p') || (ach[1] == 'P'))
                        parseNffPolygonPatch(scene, file, ach, 512);
                    else
                        parseNffPolygon(scene, file, ach, 512);
                    break;

                case '#':
                    LBprintf(ach);
                    break;

                default:
                    LBprintf("unknown: %s", ach);
                    break;
                }
            }
            else
            {
                bKeepGoing = FALSE;
                //LBprintf("possible EOF");
            }

        } while (bKeepGoing || !feof(file));
        fclose(file);

        EndDisplayList(scene);
    }
    else
    {
        LBprintf("fopen failed %s", lpstr);
        LBprintf("USAGE: viewer [NFF filename].NFF");
    }
}

STATIC void DoDisplayList(SCENE *scene)
{
    if (!((NFFPRIV *)scene->pvData)->bInList)
    {
        ((NFFPRIV *)scene->pvData)->bInList = TRUE;

        glNewList(scene->Objects.listBase, GL_COMPILE);

        //LBprintf("BEGIN DISPLAY LIST");
    }
}

STATIC void EndDisplayList(SCENE *scene)
{
    if (((NFFPRIV *)scene->pvData)->bInList)
    {
        ((NFFPRIV *)scene->pvData)->bInList = FALSE;

        glEndList();

        //LBprintf("END DISPLAY LIST");
    }
}

STATIC void parseNffViewpoint(SCENE *scene, FILE *file, char *ach, int n)
{
    if (((NFFPRIV *)scene->pvData)->bInList)
        LBprintf("NFF error: setting viewpoint too late");

    fgets(ach, n, file);
    sscanf(ach, "from %g %g %g", &scene->xyzFrom.x, &scene->xyzFrom.y, &scene->xyzFrom.z);
    fgets(ach, n, file);
    sscanf(ach, "at %g %g %g", &scene->xyzAt.x, &scene->xyzAt.y, &scene->xyzAt.z);
    fgets(ach, n, file);
    sscanf(ach, "up %g %g %g", &scene->xyzUp.x, &scene->xyzUp.y, &scene->xyzUp.z);
    fgets(ach, n, file);
    sscanf(ach, "angle %g", &scene->ViewAngle);
    fgets(ach, n, file);
    //!!!dbug -- possible front plane clipping problem; should calculate the
    //!!!        bounding sphere and use this to set near plane, but for now
    //!!!        set it to zero
    //sscanf(ach, "hither %g", &scene->Hither);
    scene->Hither = 0.001f;
    fgets(ach, n, file);
    sscanf(ach, "resolution %ld %ld", &scene->szWindow.cx, &scene->szWindow.cy);

// Estimate the yon plane as 2.5 times the distance from eye to object.

    scene->Yon = ((scene->xyzAt.x - scene->xyzFrom.x) * (scene->xyzAt.x - scene->xyzFrom.x)) +
                 ((scene->xyzAt.y - scene->xyzFrom.y) * (scene->xyzAt.y - scene->xyzFrom.y)) +
                 ((scene->xyzAt.z - scene->xyzFrom.z) * (scene->xyzAt.z - scene->xyzFrom.z));
    scene->Yon = sqrt(scene->Yon) * 2.5f;

    #if 0
    LBprintf("Viewpoint");
    LBprintf("from %g %g %g", scene->xyzFrom.x, scene->xyzFrom.y, scene->xyzFrom.z);
    LBprintf("at %g %g %g", scene->xyzAt.x, scene->xyzAt.y, scene->xyzAt.z);
    LBprintf("up %g %g %g", scene->xyzUp.x, scene->xyzUp.y, scene->xyzUp.z);
    LBprintf("angle %g", scene->ViewAngle);
    LBprintf("hither %g", scene->Hither);
    LBprintf("resolution %ld %ld", scene->szWindow.cx, scene->szWindow.cy);
    LBprintf("yon (estimate) %g", scene->Yon);
    #endif
}

STATIC void parseNffBackground(SCENE *scene, FILE *file, char *ach, int n)
{
    if (((NFFPRIV *)scene->pvData)->bInList)
        LBprintf("NFF error: setting background color too late");

    //LBprintf(ach);

    sscanf(ach, "b %g %g %g", &scene->rgbaClear.r, &scene->rgbaClear.g, &scene->rgbaClear.b);
}

STATIC void parseNffLight(SCENE *scene, FILE *file, char *ach, int n)
{
    GLfloat xyz[3];
    GLfloat rgb[4] = {1.0f, 1.0f, 1.0f, 1.0f};
    //!!! specular light should be the same as diffuse
    //static GLfloat lightSpecular[4] = {1.0f, 1.0f, 1.0f, 1.0f};

    if (((NFFPRIV *)scene->pvData)->bInList)
        LBprintf("NFF error: setting lights too late");

    sscanf(ach, "l %g %g %g %g %g %g", &xyz[0], &xyz[1], &xyz[2]
                                     , &rgb[0], &rgb[1], &rgb[2]);

    if (scene->Lights.count < (maxLights + 1))
    {
        glNewList(scene->Lights.listBase + scene->Lights.count, GL_COMPILE);

        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_POSITION, xyz);
        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_DIFFUSE, rgb);
        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_SPECULAR, rgb);

        glEndList();

        scene->Lights.count++;
    }
}

STATIC void parseNffColor(SCENE *scene, FILE *file, char *ach, int n, GLenum matSide)
{
    GLfloat rgb[4] = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat Kd, Ks, Shine, Trans, Refract;
    GLfloat lightSpecular[4] = {1.0f, 1.0f, 1.0f, 1.0f};

    DoDisplayList(scene);

    if (matSide == GL_BACK)
        sscanf(ach, "k %g %g %g %g %g %g %g %g", &rgb[0], &rgb[1], &rgb[2],
                                                 &Kd, &Ks, &Shine,
                                                 &Trans, &Refract);
    else
        sscanf(ach, "f %g %g %g %g %g %g %g %g", &rgb[0], &rgb[1], &rgb[2],
                                                 &Kd, &Ks, &Shine,
                                                 &Trans, &Refract);

    rgb[0] *= Kd; rgb[1] *= Kd; rgb[2] *= Kd;
    lightSpecular[0] *= Ks; lightSpecular[1] *= Ks; lightSpecular[2] *= Ks;

    glMaterialfv(matSide, GL_SPECULAR, lightSpecular);
    glMaterialfv(matSide, GL_AMBIENT_AND_DIFFUSE, rgb);
    glMaterialfv(matSide, GL_SHININESS, (GLfloat *) &Shine);
}

STATIC void parseNffCone(SCENE *scene, FILE *file, char *ach, int n)
{
    GLfloat xBase, yBase, zBase, rBase;
    GLfloat xApex, yApex, zApex, rApex;
    DoDisplayList(scene);

    LBprintf("*** Cylinder not implemented yet!");
    fgets(ach, n, file);
    sscanf(ach, "%g %g %g %g", &xBase, &yBase, &zBase, &rBase);
    fgets(ach, n, file);
    sscanf(ach, "%g %g %g %g", &xApex, &yApex, &zApex, &rApex);

    LBprintf("  base %g %g %g %g", xBase, yBase, zBase, rBase);
    LBprintf("  apex %g %g %g %g", xApex, yApex, zApex, rApex);
}

STATIC void parseNffSphere(SCENE *scene, FILE *file, char *ach, int n)
{
    GLfloat x, y, z, r;
    DoDisplayList(scene);

    LBprintf("*** Sphere not implemented yet!");
    sscanf(ach, "%g %g %g %g", &x, &y, &z, &r);

    LBprintf("  %g %g %g %g", x, y, z, r);
}

STATIC void parseNffPolygon(SCENE *scene, FILE *file, char *ach, int n)
{
    GLuint i, numVert;
    GLfloat *aVerts, *pVert;
    GLfloat aNorm[3];

    DoDisplayList(scene);

    sscanf(ach, "p %ld", &numVert);

    aVerts = (GLfloat *) LocalAlloc(LMEM_FIXED, sizeof(GLfloat) * numVert * 3);
    if (aVerts)
    {
        for ( i = 0, pVert = aVerts; i < numVert; i++, pVert+=3 )
        {
            fgets(ach, n, file);
            sscanf(ach, "%g %g %g", &pVert[0], &pVert[1], &pVert[2]);
        }

        calcNorm(aNorm, &aVerts[0], &aVerts[3], &aVerts[6]);

        glBegin(numVert == 3 ? GL_TRIANGLES :
                numVert == 4 ? GL_QUADS :
                               GL_POLYGON);
        {
            glNormal3fv(aNorm);
            for ( i = 0, pVert = aVerts; i < numVert; i++, pVert+=3 )
                glVertex3fv(pVert);
        }
        glEnd();

        LocalFree(pVert);
    }
}

STATIC void parseNffPolygonPatch(SCENE *scene, FILE *file, char *ach, int n)
{
    GLfloat x, y, z;
    GLfloat nx, ny, nz;
    GLuint count;

    DoDisplayList(scene);

    sscanf(ach, "pp %ld", &count);

    glBegin(count == 3 ? GL_TRIANGLES :
            count == 4 ? GL_QUADS :
                         GL_POLYGON);
    for ( ; count; count--)
    {
        fgets(ach, n, file);
        sscanf(ach, "%g %g %g %g %g %g", &x, &y, &z, &nx, &ny, &nz);

        glNormal3f(nx, ny, nz);
        glVertex3f(x, y, z);
    }
    glEnd();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\obj.c ===
/******************************Module*Header*******************************\
* Module Name: nff.c
*
* Parse the Wavefront OBJ format.
*
* Documentation on OBJ available from:
*
*   Wavefront Technologies, 530 E. Montecito St., Santa Barbara, CA 93103,
*   Phone: 805-962-8117.
*
*   Murray, J. D. and van Ryper, W., _Encyclopedia of Graphics File Formats_,
*   O'Reilly & Associates, 1994, pp. 727-734.
*
* Created: 15-Mar-1995 23:27:08
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <math.h>

#include "global.h"
#include "nff.h"

#define STATIC

typedef struct tagOBJPRIV
{
    BOOL bInList;       // TRUE while compiling display list

// Vertex arrays

    MyXYZ   *pxyzGeoVert;   // array of geometric vertices
    MyXYZ   *pxyzTexVert;   // array of texture vertices
    MyXYZ   *pxyzNorm;      // array of vertex normals

// Number allocated for each array

    GLuint  numGeoVert;     // total number of geometric vertices
    GLuint  numTexVert;     // total number of texture vertices
    GLuint  numNorm;        // total number of normals

// Number of vertices currently in each array

    GLuint  curGeoVert;     // current number of geometric vertices
    GLuint  curTexVert;     // current number of texture vertices
    GLuint  curNorm;        // current number of normals

    GLfloat rMax;

} OBJPRIV;

GLint maxLights;

STATIC void parseObjFile(SCENE *, LPTSTR);
STATIC void DoDisplayList(SCENE *);
STATIC void EndDisplayList(SCENE *);
STATIC void parseObjNormal(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseObjTextureVertex(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseObjVertex(SCENE *scene, FILE *file, char *ach, int n);
STATIC void parseObjFace(SCENE *scene, FILE *file, char *ach, int n);
STATIC void fakeObjLight(SCENE *scene, GLfloat x, GLfloat y, GLfloat z);

SCENE *ObjOpenScene(LPTSTR lpstr)
{
    SCENE *scene;

    scene = (SCENE *) LocalAlloc(LMEM_FIXED, sizeof(SCENE) + sizeof(OBJPRIV));
    if (scene)
    {
        OBJPRIV *objPriv = (OBJPRIV *) (scene + 1);

        glGetIntegerv(GL_MAX_LIGHTS, &maxLights);

        scene->xyzFrom.x = 0.0;
        scene->xyzFrom.y = 0.0;
        //scene->xyzFrom.z = 5.0;

        scene->xyzAt.x = 0.0;
        scene->xyzAt.y = 0.0;
        scene->xyzAt.z = 0.0;

        scene->xyzUp.x = 0.0;
        scene->xyzUp.y = 1.0;
        scene->xyzUp.z = 0.0;

        scene->ViewAngle   = 45.0f;
        scene->Hither      = 0.1f;
        //scene->Yon         = 100.0f;
        scene->AspectRatio = 1.0f;

        scene->szWindow.cx = 400;
        scene->szWindow.cy = 400;

        scene->rgbaClear.r = (GLfloat) 0.0; // default is black
        scene->rgbaClear.g = (GLfloat) 0.0;
        scene->rgbaClear.b = (GLfloat) 0.0;
        scene->rgbaClear.a = (GLfloat) 1.0;

        scene->Lights.count = 0;
        scene->Lights.listBase = 1;

        scene->Objects.count = 1;
        scene->Objects.listBase = maxLights + 1;

        scene->pvData = (VOID *) objPriv;
        objPriv->bInList     = FALSE;
        objPriv->pxyzGeoVert = (MyXYZ *) NULL;
        objPriv->pxyzTexVert = (MyXYZ *) NULL;
        objPriv->pxyzNorm    = (MyXYZ *) NULL;
        objPriv->numGeoVert  = 0;
        objPriv->numTexVert  = 0;
        objPriv->numNorm     = 0;
        objPriv->curGeoVert  = 0;
        objPriv->curTexVert  = 0;
        objPriv->curNorm     = 0;
        objPriv->rMax        = (GLfloat) 0.0;

        LBprintf("================================");
        LBprintf("Parsing OBJ file, please wait...");
        LBprintf("================================");
        parseObjFile(scene, lpstr);
        LBprintf("Here we go!");

        scene->xyzFrom.z = 2.0f * objPriv->rMax * tan(90.0f - scene->ViewAngle);
        scene->Yon = (scene->xyzAt.z - scene->xyzFrom.z) * (scene->xyzAt.z - scene->xyzFrom.z);
        scene->Yon = sqrt(scene->Yon) * 2.5f;

        fakeObjLight(scene, objPriv->rMax, objPriv->rMax, scene->xyzFrom.z);
    }
    else
    {
        LBprintf("ObjOpenScene: memory allocation failure");
    }

    return scene;
}

STATIC void parseObjFile(SCENE *scene, LPTSTR lpstr)
{
    FILE *file;
    char ach[512];
    char *pch;
    OBJPRIV *objPriv = (OBJPRIV *) scene->pvData;

    file = fopen(lpstr, "rt");

    if (file)
    {
        BOOL bKeepGoing = TRUE;

    // Do a quick first pass through the file so we know how big to
    // make the arrays.

        do
        {
            if (fgets(ach, sizeof(ach), file) != NULL)
            {
            // Skip leading whitespace.  Some input files have this.

                pch = ach;
                while (*pch && isspace(*pch)) pch++;

                switch(pch[0])
                {
                case 'V':
                case 'v':
                    switch(pch[1])
                    {
                    case 'N':
                    case 'n':
                        objPriv->numNorm++;
                        break;
                    case 'T':
                    case 't':
                        //objPriv->numTexVert++;
                        break;
                    case 'P':
                    case 'p':
                        break;
                    default:
                        objPriv->numGeoVert++;
                        break;
                    }
                    break;

                default:
                    break;
                }
            }
            else
            {
                bKeepGoing = FALSE;
                //LBprintf("possible EOF");
            }

        } while (bKeepGoing || !feof(file));
        rewind(file);

    // Allocate the arrays.

        objPriv->pxyzGeoVert = (MyXYZ *)
            LocalAlloc(LMEM_FIXED, sizeof(MyXYZ) * (objPriv->numNorm +
                                                    objPriv->numTexVert +
                                                    objPriv->numGeoVert));
        objPriv->pxyzTexVert = objPriv->pxyzGeoVert + objPriv->numGeoVert;
        objPriv->pxyzNorm    = objPriv->pxyzTexVert + objPriv->numTexVert;

    // Parse the file for real.

        bKeepGoing = TRUE;
        do
        {
            if (fgets(ach, sizeof(ach), file) != NULL)
            {
            // Skip leading whitespace.  Some input files have this.

                pch = ach;
                while (*pch && isspace(*pch)) pch++;

                switch(pch[0])
                {
                case 'G':
                case 'g':
                    //LBprintf(ach);
                    break;

                case 'V':
                case 'v':
                    switch(pch[1])
                    {
                    case 'N':
                    case 'n':
                        parseObjNormal(scene, file, pch, sizeof(ach) - (pch - ach));
                        break;
                    case 'T':
                    case 't':
                        //parseObjTextureVertex(scene, file, pch, sizeof(ach) - (pch - ach));
                        break;
                    case 'P':
                    case 'p':
                        break;
                    default:
                        parseObjVertex(scene, file, pch, sizeof(ach) - (pch - ach));
                        break;
                    }
                    break;

                case 'f':
                case 'F':
                    switch(pch[1])
                    {
                    case 'O':
                    case 'o':
                        parseObjFace(scene, file, &pch[1], sizeof(ach) - (pch - ach) - 1);
                        break;
                    default:
                        parseObjFace(scene, file, pch, sizeof(ach) - (pch - ach));
                        break;
                    }
                    break;

                case '#':
                    LBprintf(pch);
                    break;

                default:
                    //LBprintf("unknown: %s", ach);
                    break;
                }
            }
            else
            {
                bKeepGoing = FALSE;
                //LBprintf("possible EOF");
            }

        } while (bKeepGoing || !feof(file));
        fclose(file);

        EndDisplayList(scene);
    }
    else
    {
        LBprintf("fopen failed %s", lpstr);
        LBprintf("USAGE: viewer [OBJ filename].OBJ");
    }
}

STATIC void DoDisplayList(SCENE *scene)
{
    if (!((OBJPRIV *)scene->pvData)->bInList)
    {
        ((OBJPRIV *)scene->pvData)->bInList = TRUE;

        glNewList(scene->Objects.listBase, GL_COMPILE);

        //LBprintf("BEGIN DISPLAY LIST");
    }
}

STATIC void EndDisplayList(SCENE *scene)
{
    if (((OBJPRIV *)scene->pvData)->bInList)
    {
        ((OBJPRIV *)scene->pvData)->bInList = FALSE;

        glEndList();

        //LBprintf("END DISPLAY LIST");
    }
}

STATIC void parseObjNormal(SCENE *scene, FILE *file, char *ach, int n)
{
    OBJPRIV *objPriv = (OBJPRIV *) scene->pvData;

    sscanf(ach, "vn %g %g %g", &objPriv->pxyzNorm[objPriv->curNorm].x,
                               &objPriv->pxyzNorm[objPriv->curNorm].y,
                               &objPriv->pxyzNorm[objPriv->curNorm].z);

    objPriv->curNorm++;
}

STATIC void parseObjTextureVertex(SCENE *scene, FILE *file, char *ach, int n)
{
    OBJPRIV *objPriv = (OBJPRIV *) scene->pvData;

    sscanf(ach, "vt %g %g %g", &objPriv->pxyzTexVert[objPriv->curTexVert].x,
                               &objPriv->pxyzTexVert[objPriv->curTexVert].y,
                               &objPriv->pxyzTexVert[objPriv->curTexVert].z);

    objPriv->curTexVert++;
}

STATIC void parseObjVertex(SCENE *scene, FILE *file, char *ach, int n)
{
    OBJPRIV *objPriv = (OBJPRIV *) scene->pvData;

    sscanf(ach, "v %g %g %g", &objPriv->pxyzGeoVert[objPriv->curGeoVert].x,
                              &objPriv->pxyzGeoVert[objPriv->curGeoVert].y,
                              &objPriv->pxyzGeoVert[objPriv->curGeoVert].z);

    objPriv->curGeoVert++;
}

STATIC void parseObjFace(SCENE *scene, FILE *file, char *ach, int n)
{
    OBJPRIV *objPriv = (OBJPRIV *) scene->pvData;
    char *pch;
    GLuint i, numVert = 0;
    char achFormat[20];
    BOOL bReadTex = FALSE, bReadNorm = FALSE;
    GLuint v, vt, vn;
    GLfloat rMax;
    GLuint vv[3];
    MyXYZ  faceNorm;

    DoDisplayList(scene);

// Determine number of vertices.
// Each vertex is represented by a field of non-whitespace characters
// which are numbers or '/' characters.

    pch = &ach[1];
    while ( *pch )
    {
        while (*pch && isspace(*pch))
            pch++;

        if (*pch)
            numVert++;

        while (*pch && !isspace(*pch))
            pch++;
    }

// Bail if there aren't enough vertices to define a face.

    if (numVert < 3)
    {
        LBprintf("bad line: %s", ach);
        return;
    }

// Determine type of vertex info available.  Each vertex has the form
// v[/[vt][/[vn]]].  Some examples include:
//
//      f 1/2/3 ...
//      f 1//3  ...
//      f 1/2   ...
//      f 1/2/  ...
//      f 1     ...
//      f 1//   ...
//          etc.

    pch = &ach[1];

    while (*pch && isspace(*pch))
        pch++;

    if (*pch && isdigit(*pch))
        lstrcpy(achFormat, "%ld");

    while (*pch && isdigit(*pch))
        pch++;

    if (*pch == '/')
    {
        lstrcat(achFormat, "/");
        pch++;
    }

    if (*pch && isdigit(*pch))
    {
        bReadTex = TRUE;
        lstrcat(achFormat, "%ld");

        while (*pch && isdigit(*pch))
            pch++;
    }

    if (*pch == '/')
    {
        lstrcat(achFormat, "/");
        pch++;
    }

    if (*pch && isdigit(*pch))
    {
        bReadNorm = TRUE;
        lstrcat(achFormat, "%ld");

        while (*pch && isdigit(*pch))
            pch++;
    }

// If we need to compute our own normal, let's do it now.

    pch = &ach[1];

    if (!bReadNorm)
    {
        for ( i = 0; i < 3; i++ )
        {
            while (*pch && isspace(*pch))
                pch++;

            sscanf(pch, "%ld", &vv[i]);
            if (vv[i] > 0)
                vv[i] = vv[i] - 1;
            else
                vv[i] = objPriv->curGeoVert + vv[i];

            while (*pch && !isspace(*pch))
                pch++;

        }

        calcNorm((GLfloat *) &faceNorm,
                 (GLfloat *) &objPriv->pxyzGeoVert[vv[0]],
                 (GLfloat *) &objPriv->pxyzGeoVert[vv[1]],
                 (GLfloat *) &objPriv->pxyzGeoVert[vv[2]]);
    }

// Finally, parse out the vertices.

    pch = &ach[1];

    glBegin(numVert == 3 ? GL_TRIANGLES :
            numVert == 4 ? GL_QUADS :
                           GL_POLYGON);
    if (!bReadTex && !bReadNorm)
    {
        glNormal3fv((GLfloat *) &faceNorm);

        for ( i = 0; i < numVert; i++ )
        {
            while (*pch && isspace(*pch))
                pch++;

            sscanf(pch, achFormat, &v);
            if (v > 0)
                v = v - 1;
            else
                v = objPriv->curGeoVert + v;

            glVertex3fv((GLfloat *)&objPriv->pxyzGeoVert[v]);

            if (fabs(objPriv->pxyzGeoVert[v].x) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].x);
            if (fabs(objPriv->pxyzGeoVert[v].y) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].y);
            if (fabs(objPriv->pxyzGeoVert[v].z) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].z);

            while (*pch && !isspace(*pch))
                pch++;

        }
    }
    else if (!bReadTex && bReadNorm)
    {
        for ( i = 0; i < numVert; i++ )
        {
            while (*pch && isspace(*pch))
                pch++;

            sscanf(pch, achFormat, &v, &vn);
            if (v > 0)
                v = v - 1;
            else
                v = objPriv->curGeoVert + v;
            if (vn > 0)
                vn = vn - 1;
            else
                vn = objPriv->curGeoVert + vn;

            glNormal3fv((GLfloat *)&objPriv->pxyzNorm[vn]);
            glVertex3fv((GLfloat *)&objPriv->pxyzGeoVert[v]);

            if (fabs(objPriv->pxyzGeoVert[v].x) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].x);
            if (fabs(objPriv->pxyzGeoVert[v].y) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].y);
            if (fabs(objPriv->pxyzGeoVert[v].z) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].z);

            while (*pch && !isspace(*pch))
                pch++;

        }
    }
    else if (bReadTex && !bReadNorm)
    {
        glNormal3fv((GLfloat *) &faceNorm);

        for ( i = 0; i < numVert; i++ )
        {
            while (*pch && isspace(*pch))
                pch++;

            sscanf(pch, achFormat, &v, &vt);
            if (v > 0)
                v = v - 1;
            else
                v = objPriv->curGeoVert + v;
            if (vt > 0)
                vt = vt - 1;
            else
                vt = objPriv->curGeoVert + vt;

            //!!! ignore texture vertex for now; just use the geometry
            glVertex3fv((GLfloat *)&objPriv->pxyzGeoVert[v]);

            if (fabs(objPriv->pxyzGeoVert[v].x) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].x);
            if (fabs(objPriv->pxyzGeoVert[v].y) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].y);
            if (fabs(objPriv->pxyzGeoVert[v].z) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].z);

            while (*pch && !isspace(*pch))
                pch++;

        }
    }
    else
    {
        for ( i = 0; i < numVert; i++ )
        {
            while (*pch && isspace(*pch))
                pch++;

            sscanf(pch, achFormat, &v, &vt, &vn);
            if (v > 0)
                v = v - 1;
            else
                v = objPriv->curGeoVert + v;
            if (vt > 0)
                vt = vt - 1;
            else
                vt = objPriv->curGeoVert + vt;
            if (vn > 0)
                vn = vn - 1;
            else
                vn = objPriv->curGeoVert + vn;

            //!!! ignore texture vertex for now; just use the geometry
            glNormal3fv((GLfloat *)&objPriv->pxyzNorm[vn]);
            glVertex3fv((GLfloat *)&objPriv->pxyzGeoVert[v]);

            if (fabs(objPriv->pxyzGeoVert[v].x) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].x);
            if (fabs(objPriv->pxyzGeoVert[v].y) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].y);
            if (fabs(objPriv->pxyzGeoVert[v].z) > objPriv->rMax)
                objPriv->rMax = fabs(objPriv->pxyzGeoVert[v].z);

            while (*pch && !isspace(*pch))
                pch++;

        }
    }
    glEnd();
}

STATIC void fakeObjLight(SCENE *scene, GLfloat x, GLfloat y, GLfloat z)
{
    MyXYZ xyz;
    MyRGBA rgb = {1.0f, 1.0f, 1.0f, 1.0f};

    xyz.x = x;
    xyz.y = y;
    xyz.z = z;

    if (scene->Lights.count < (maxLights + 1))
    {
        glNewList(scene->Lights.listBase + scene->Lights.count, GL_COMPILE);

        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_POSITION, (GLfloat *) &xyz);
        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_DIFFUSE, (GLfloat *) &rgb);
        glLightfv(GL_LIGHT0 + scene->Lights.count, GL_SPECULAR, (GLfloat *) &rgb);

        glEndList();

        scene->Lights.count++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\nff.h ===
/******************************Module*Header*******************************\
* Module Name: nff.h
*
* Declarations for nff.c.
*
* Created: 14-Mar-1995 23:44:46
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

SCENE *NffOpenScene(LPTSTR lpsz);
SCENE *ObjOpenScene(LPTSTR lpsz);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\scene.h ===
/******************************Module*Header*******************************\
* Module Name: scene.h
*
* Structures used to describe a scene.
*
* Created: 09-Mar-1995 14:51:33
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef _SCENE_H_
#define _SCENE_H_

typedef struct tagMyXYZ
{
    GLfloat x;
    GLfloat y;
    GLfloat z;

} MyXYZ;

typedef struct tagMyRGBA
{
    GLfloat r;
    GLfloat g;
    GLfloat b;
    GLfloat a;

} MyRGBA;

typedef struct tagMultList
{
    GLuint  count;
    GLuint  listBase;

} MultiList;

typedef struct tagSCENE
{
// Viewing parameters.

    MyXYZ   xyzFrom;
    MyXYZ   xyzAt;
    MyXYZ   xyzUp;
    float   ViewAngle;
    float   Hither;
    float   Yon;
    float   AspectRatio;
    SIZE    szWindow;

// Clear color.

    MyRGBA  rgbaClear;

// Lights.

    MultiList Lights;

// Objects.

    MultiList Objects;

// State

// For use by format parser.

    VOID *pvData;

} SCENE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\demos\viewer\viewer.c ===
/******************************Module*Header*******************************\
* Module Name: viewer.c
*
* Main window.
*
* Created: 14-Mar-1995 23:42:08
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

#include "global.h"
#include "glwindow.h"

// Window functions.

void MyCreateWindows(HINSTANCE);
long FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM);

// Global window handles.  Always handy to have around.

HINSTANCE ghInstance;
HWND hwndMain = (HWND) NULL;
HWND hwndList = (HWND) NULL;

/******************************Public*Routine******************************\
* WinMain
*
* Main loop.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI
WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine,
        int nCmdShow)
{
    MSG msg;
    SCENE *scene;

    MyCreateWindows(hInstance);
    MyCreateGLWindow(hInstance, lpCmdLine);

    while ( GetMessage(&msg, (HWND) NULL, (UINT) NULL, (UINT) NULL) )
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    return (msg.wParam);
}

/******************************Public*Routine******************************\
* MyCreateWindows
*
* Setup the windows.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void MyCreateWindows(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    RECT rcl;

    ghInstance = hInstance;

// Register and create the main window, which contains the info listbox.

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, "ViewerIcon");
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = "MainWClass";
    RegisterClass(&wc);

    hwndMain = CreateWindow(
        "MainWClass",
        "3D Viewer",
        WS_OVERLAPPEDWINDOW|WS_MAXIMIZE,
        0,
        0,
        300,
        768,
        NULL,
        NULL,
        hInstance,
        NULL
        );

    if (hwndMain)
    {
        ShowWindow(hwndMain, SW_NORMAL);
        UpdateWindow(hwndMain);

    // Create the list box to fill the main window.

        GetClientRect(hwndMain, &rcl);

        hwndList = CreateWindow(
            "LISTBOX",
            "3D Viewer Info",
            WS_CHILD | WS_VISIBLE | WS_VSCROLL
            | WS_HSCROLL | LBS_NOINTEGRALHEIGHT,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            hwndMain,
            NULL,
            hInstance,
            NULL
            );

        if (hwndList)
        {
            SendMessage(
                hwndList,
                WM_SETFONT,
                (WPARAM) GetStockObject(ANSI_FIXED_FONT),
                (LPARAM) FALSE
                );

            LBreset();
            ShowWindow(hwndList, SW_NORMAL);
            UpdateWindow(hwndList);
        }
    }

}

/******************************Public*Routine******************************\
* MainWndProc
*
* WndProc for the main window.  List box is maintained here.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

long FAR PASCAL MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    RECT    rcl;
    long    lRet = 0;

// Process window message.

    switch (message)
    {
    case WM_SIZE:
        lRet = DefWindowProc(hwndList, message, wParam, lParam);
        GetClientRect(hwndMain, &rcl);
        MoveWindow(
            hwndList,
            rcl.left, rcl.top,
            (rcl.right - rcl.left), (rcl.bottom - rcl.top),
            TRUE
            );
        UpdateWindow(hwndList);
        break;

    case WM_KEYDOWN:
        switch (wParam)
        {
        case VK_ESCAPE:     // <ESC> is quick exit

            PostMessage(hwnd, WM_DESTROY, 0, 0);
            break;

        default:
            break;
        }
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    default:
        lRet = DefWindowProc(hwnd, message, wParam, lParam);
        break;
    }

    return lRet;
}

/******************************Public*Routine******************************\
* LBprintf
*
* ListBox printf implementation.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBprintf(PCH msg, ...)
{
    va_list ap;
    char buffer[256];

    va_start(ap, msg);

    vsprintf(buffer, msg, ap);

    SendMessage(hwndList, LB_ADDSTRING, (WPARAM) 0, (LPARAM) buffer);
    SendMessage(hwndList, WM_SETREDRAW, (WPARAM) TRUE, (LPARAM) 0);
    InvalidateRect(hwndList, NULL, TRUE);
    UpdateWindow(hwndList);

    va_end(ap);
}

/******************************Public*Routine******************************\
* LBreset
*
* Reset ListBox state (clear).
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void LBreset()
{
    SendMessage(hwndList, LB_RESETCONTENT, (WPARAM) FALSE, (LPARAM) 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\gldd\lib\ddwin.cxx ===
#include "precomp.hxx"
#pragma hdrstop

#include <stdio.h>

#include "glddint.hxx"

// Track the last error returned from a call made by this library
HRESULT hrGlddLast = DD_OK;

// Get the last Win32 error and turn it into an HRESULT
#define WIN32_HR() ((HRESULT)GetLastError())

// Window class
static char *pszClass = "glddWindow";

// Global IDirectDraw
static LPDIRECTDRAW pdd = NULL;

// Structure to pass window creation data
#pragma pack(1)
struct GLDDCREATESTRUCT
{
    WORD wSize;
    GLDDWINDOW gw;
};
#pragma pack()

/******************************Public*Routine******************************\
*
* glddWndProc
*
* Window procedure for gldd windows
*
* History:
*  Fri Aug 30 13:00:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

LRESULT glddWndProc(HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm)
{
    PAINTSTRUCT ps;
    LRESULT lr;
    GLDDWINDOW gw;
    GLDDCREATESTRUCT *pgcs;

    // Set up the window-related data immediately on WM_CREATE so that
    // a callback can be made for it as well as after it
    if (uiMsg == WM_CREATE)
    {
        pgcs = (GLDDCREATESTRUCT *)((CREATESTRUCT *)lpm)->lpCreateParams;
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pgcs->gw);
    }
    
    gw = (GLDDWINDOW)GetWindowLong(hwnd, GWL_USERDATA);

    // Pass off window messages if requested
    if (gw != NULL && gw->_cbMessage != NULL)
    {
        if (gw->_cbMessage(gw, hwnd, uiMsg, wpm, lpm, &lr))
        {
            return lr;
        }
    }
    
    switch(uiMsg)
    {
    case WM_PAINT:
        // Validate paint region.  The assumption is that the app will either
        // interpose and catch the WM_PAINT itself or it's dynamic so
        // the screen will be repainted shortly anyway.  Either way,
        // there's nothing for the library to do.
        BeginPaint(hwnd, &ps);
        EndPaint(hwnd, &ps);
        break;
        
    case WM_CLOSE:
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:
        // Doesn't work with multiple windows
        PostQuitMessage(1);
        break;
        
    default:
        return DefWindowProc(hwnd, uiMsg, wpm, lpm);
    }

    return 0;
}

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Tables to convert color components between bit sizes
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};

/******************************Public*Routine******************************\
*
* glddComponentFromIndex
*
* Converts a color index to a color component
*
* History:
*  Fri Aug 30 14:04:45 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

unsigned char glddComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }

    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* glddUpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddUpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }
}

/******************************Public*Routine******************************\
*
* glddMapInSystemColors
*
* Reorganizes the given palette to include the system colors in
* the lower and upper ten slots
*
* History:
*  Fri Aug 30 14:07:32 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddMapInSystemColors(PALETTEENTRY *ppe)
{
    int iOld, iNew, iDef;
    PALETTEENTRY peTmp[256-STATIC_COLORS];
    
    // Find matches between the given palette and the current system colors.
    glddUpdateStaticMapping(ppe);

    // Place the first half of the system colors at the beginning of
    // the palette and the second half at the end of the palette.
    // The colors in the given palette which match the system colors most
    // closely are deleted and the remainder are packed into the middle
    // entries.
    iNew = 0;
    for (iOld = 0; iOld < 256; iOld++)
    {
        for (iDef = 0; iDef < STATIC_COLORS; iDef++)
        {
            if (iOld == aiDefaultOverride[iDef])
            {
                break;
            }
        }

        if (iDef == STATIC_COLORS)
        {
            peTmp[iNew++] = ppe[iOld];
        }
    }

    memcpy(ppe, apeDefaultPalEntry,
           sizeof(PALETTEENTRY)*(STATIC_COLORS/2));
    memcpy(ppe+STATIC_COLORS/2, peTmp,
           sizeof(PALETTEENTRY)*(256-STATIC_COLORS));
    memcpy(ppe+256-STATIC_COLORS/2, apeDefaultPalEntry+STATIC_COLORS/2,
           sizeof(PALETTEENTRY)*(STATIC_COLORS/2));
}

/******************************Public*Routine******************************\
*
* _GLDDWINDOW::_GLDDWINDOW
*
* Initialize fresh window to NULL
*
* History:
*  Fri Aug 30 14:08:11 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

_GLDDWINDOW::_GLDDWINDOW(void)
{
    _hwnd = NULL;
    _hrc = NULL;
    _pddc = NULL;
    _pddsFront = NULL;
    _pddsBack = NULL;
    _pddsZ = NULL;
}

/******************************Public*Routine******************************\
*
* _GLDDWINDOW::Create
*
* Creates a new rendering window
*
* History:
*  Fri Aug 30 14:34:15 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL _GLDDWINDOW::Create(char *pszTitle, int x, int y,
                         int iWidth, int iHeight, int iDepth,
                         DWORD dwFlags)
{
    RECT rct;
    DDSURFACEDESC ddsd, ddsdFront;
    PIXELFORMATDESCRIPTOR pfd;
    GLDDCREATESTRUCT gcs;
    DDSCAPS ddscaps;
    LPDIRECTDRAWSURFACE pddsRender;
    int ipfd;
    HDC hdc;
    BOOL bRet;
    DWORD dwZDepth;

    // Create base window
    if (dwFlags & GLDD_FULL_SCREEN)
    {
        rct.left = 0;
        rct.top = 0;
        rct.right = iWidth;
        rct.bottom = iHeight;
    }
    else
    {
        rct.left = x;
        rct.top = y;
        rct.right = x+iWidth;
        rct.bottom = y+iHeight;
        AdjustWindowRect(&rct, WS_OVERLAPPEDWINDOW, FALSE);
    }

    gcs.wSize = sizeof(gcs);
    gcs.gw = this;
    _hwnd = CreateWindow(pszClass, pszTitle,
                         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN |
                         WS_CLIPSIBLINGS,
                         rct.left, rct.top,
                         rct.right-rct.left, rct.bottom-rct.top,
                         NULL, NULL, GetModuleHandle(NULL), &gcs);
    if (_hwnd == NULL)
    {
        hrGlddLast = WIN32_HR();
        return FALSE;
    }

    if (dwFlags & GLDD_FULL_SCREEN)
    {
	DWORD dwDdFlags;

        // If fullscreen, take over the screen, switch the video mode and
        // create a complex flipping surface
        
	dwDdFlags = DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN;
	if (dwFlags & GLDD_USE_MODE_X)
	{
	    dwDdFlags |= DDSCL_ALLOWMODEX;
	}
        hrGlddLast = pdd->SetCooperativeLevel(_hwnd, dwDdFlags);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }

        hrGlddLast = pdd->SetDisplayMode(iWidth, iHeight, iDepth);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        
        memset(&ddsdFront, 0, sizeof(DDSURFACEDESC));
	ddsdFront.dwSize = sizeof(ddsdFront);
    	ddsdFront.dwFlags = DDSD_CAPS;
    	ddsdFront.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
        if (dwFlags & GLDD_BACK_BUFFER)
        {
            ddsdFront.dwFlags |= DDSD_BACKBUFFERCOUNT;
            ddsdFront.dwBackBufferCount = 1;
            ddsdFront.ddsCaps.dwCaps |= DDSCAPS_FLIP | DDSCAPS_COMPLEX;
        }
        hrGlddLast = pdd->CreateSurface(&ddsdFront, &_pddsFront, NULL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        hrGlddLast = _pddsFront->GetSurfaceDesc(&ddsdFront);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        
        if (dwFlags & GLDD_BACK_BUFFER)
        {
            ddscaps.dwCaps = DDSCAPS_BACKBUFFER;
            hrGlddLast = _pddsFront->GetAttachedSurface(&ddscaps, &_pddsBack);
            if (hrGlddLast != DD_OK)
            {
                return FALSE;
            }

            // Ensure that the back buffer went into video memory so
            // that flipping isn't emulated
            if ((dwFlags & GLDD_STRICT_MEMORY) &&
                (_pddsBack->GetSurfaceDesc(&ddsd) != DD_OK ||
                 (ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0))
            {
                hrGlddLast = DDERR_OUTOFVIDEOMEMORY;
                return FALSE;
            }
        }
    }
    else
    {
        // If windowed, get access to the screen and attach a clipper
        // for visrgn management.
        
        hrGlddLast = pdd->SetCooperativeLevel(NULL, DDSCL_NORMAL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }

        memset(&ddsdFront, 0, sizeof(ddsdFront));
        ddsdFront.dwSize = sizeof(DDSURFACEDESC);
        ddsdFront.dwFlags = DDSD_CAPS;
        ddsdFront.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
        hrGlddLast = pdd->CreateSurface(&ddsdFront, &_pddsFront, NULL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }

        hrGlddLast = _pddsFront->GetSurfaceDesc(&ddsdFront);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        
        hrGlddLast = pdd->CreateClipper(0, &_pddc, NULL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        hrGlddLast = _pddc->SetHWnd(0, _hwnd);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        // Works with multiple windows?  Depends on whether
        // multiple primary creates have individual state
        hrGlddLast = _pddsFront->SetClipper(_pddc);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
    
        if (dwFlags & GLDD_BACK_BUFFER)
        {
            memset(&ddsd, 0, sizeof(DDSURFACEDESC));
            ddsd.dwSize = sizeof(DDSURFACEDESC);
            ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
            ddsd.dwWidth = iWidth;
            ddsd.dwHeight = iHeight;
            ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
            if (dwFlags & GLDD_VIDEO_MEMORY)
            {
                ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
            }
            else
            {
                ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
            }
            hrGlddLast = pdd->CreateSurface(&ddsd, &_pddsBack, NULL);
            if (hrGlddLast != DD_OK)
            {
                return FALSE;
            }

            // Ensure that the back buffer went where we wanted it
            if ((dwFlags & GLDD_STRICT_MEMORY) &&
                (_pddsBack->GetSurfaceDesc(&ddsd) != DD_OK ||
                 ((ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0) !=
                 ((dwFlags & GLDD_VIDEO_MEMORY) == 0)))
            {
                if (dwFlags & GLDD_VIDEO_MEMORY)
                {
                    hrGlddLast = DDERR_OUTOFVIDEOMEMORY;
                }
                else
                {
                    hrGlddLast = DDERR_OUTOFMEMORY;
                }
                return FALSE;
            }
        }
    }

    // If we're double-buffered, use the back buffer as the rendering target.
    // Otherwise use the front buffer.
    if (dwFlags & GLDD_BACK_BUFFER)
    {
        pddsRender = _pddsBack;
    }
    else
    {
        pddsRender = _pddsFront;
    }

    // Create a palette for paletted surfaces
    if (ddsdFront.ddpfPixelFormat.dwRGBBitCount < 16)
    {
	int i;
        PALETTEENTRY ppe[256];

        for (i = 0; i < 256; i++)
        {
            ppe[i].peRed = glddComponentFromIndex(i, 3, 0);
            ppe[i].peGreen = glddComponentFromIndex(i, 3, 3);
            ppe[i].peBlue = glddComponentFromIndex(i, 2, 6);
            ppe[i].peFlags = 0;
        }
        if ((dwFlags & GLDD_FULL_SCREEN) == 0)
        {
            glddMapInSystemColors(ppe);
        }
        
	hrGlddLast = pdd->CreatePalette(DDPCAPS_8BIT | DDPCAPS_INITIALIZE,
                                        ppe, &_pddp, NULL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        if (_pddsBack != NULL)
        {
            hrGlddLast = _pddsBack->SetPalette(_pddp);
            if (hrGlddLast != DD_OK)
            {
                return FALSE;
            }
        }
        // Works with multiple windows?
	hrGlddLast = _pddsFront->SetPalette(_pddp);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
    }

    // Create a Z buffer if requested
    if (dwFlags & (GLDD_Z_BUFFER_16 | GLDD_Z_BUFFER_32))
    {
        memset(&ddsd, 0, sizeof(DDSURFACEDESC));
        ddsd.dwSize = sizeof(DDSURFACEDESC);
        ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS |
            DDSD_ZBUFFERBITDEPTH;
        ddsd.dwWidth = iWidth;
        ddsd.dwHeight = iHeight;
        dwZDepth = (dwFlags & GLDD_Z_BUFFER_16) ? 16 : 32;
        ddsd.dwZBufferBitDepth = dwZDepth;
        ddsd.ddsCaps.dwCaps = DDSCAPS_ZBUFFER;
        if (dwFlags & GLDD_VIDEO_MEMORY)
        {
            ddsd.ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;
        }
        else
        {
            ddsd.ddsCaps.dwCaps |= DDSCAPS_SYSTEMMEMORY;
        }
        hrGlddLast = pdd->CreateSurface(&ddsd, &_pddsZ, NULL);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
        
        // Ensure that the Z buffer went where we wanted it
        if ((dwFlags & GLDD_STRICT_MEMORY) &&
            (_pddsZ->GetSurfaceDesc(&ddsd) != DD_OK ||
             ((ddsd.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) == 0) !=
             ((dwFlags & GLDD_VIDEO_MEMORY) == 0)))
        {
            if (dwFlags & GLDD_VIDEO_MEMORY)
            {
                hrGlddLast = DDERR_OUTOFVIDEOMEMORY;
            }
            else
            {
                hrGlddLast = DDERR_OUTOFMEMORY;
            }
            return FALSE;
        }
        
        hrGlddLast = pddsRender->AddAttachedSurface(_pddsZ);
        if (hrGlddLast != DD_OK)
        {
            return FALSE;
        }
    }
    else
    {
        dwZDepth = 0;
    }

    // Create an OpenGL rendering context
    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_GENERIC_FORMAT | PFD_SUPPORT_DIRECTDRAW;
    if (dwFlags & GLDD_GENERIC_ACCELERATED)
    {
	pfd.dwFlags |= PFD_GENERIC_ACCELERATED;
    }
    pfd.iPixelType = PFD_TYPE_RGBA;
    if (dwFlags & GLDD_ACCUM_BUFFER)
    {
        pfd.cAccumBits = 64;
    }
    if (dwFlags & GLDD_STENCIL_BUFFER)
    {
        pfd.cStencilBits = 8;
    }
    pfd.cDepthBits = (BYTE)dwZDepth;

    hrGlddLast = pddsRender->GetDC(&hdc);
    if (hrGlddLast != DD_OK)
    {
        return FALSE;
    }

    bRet = TRUE;
    
    ipfd = ChoosePixelFormat(hdc, &pfd);

    if (ipfd <= 0 ||
        DescribePixelFormat(hdc, ipfd, sizeof(pfd), &pfd) <= 0 ||
        !SetPixelFormat(hdc, ipfd, &pfd) ||
        (_hrc = wglCreateContext(hdc)) == NULL)
    {
        hrGlddLast = WIN32_HR();
        bRet = FALSE;
    }
    
    pddsRender->ReleaseDC(hdc);

    if (!bRet)
    {
        return FALSE;
    }

    _iWidth = iWidth;
    _iHeight = iHeight;
    _dwFlags = dwFlags;

    ShowWindow(_hwnd, SW_SHOWDEFAULT);
    UpdateWindow(_hwnd);
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* _GLDDWINDOW::~_GLDDWINDOW
*
* Clean up
*
* History:
*  Fri Aug 30 14:37:12 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

_GLDDWINDOW::~_GLDDWINDOW(void)
{
    if (_hrc != NULL)
    {
        if (wglGetCurrentContext() == _hrc)
        {
            wglMakeCurrent(NULL, NULL);
        }
        wglDeleteContext(_hrc);
    }
    if (_pddsBack != NULL)
    {
        _pddsBack->Release();
    }
    if (_pddsZ != NULL)
    {
        _pddsZ->Release();
    }
    if (_pddp != NULL)
    {
        _pddp->Release();
    }
    if (_pddc != NULL)
    {
        if (_pddsFront != NULL)
        {
            LPDIRECTDRAWCLIPPER pddc;

            // Only detach our clipper if it's still the current clipper
            if (_pddsFront->GetClipper(&pddc) == DD_OK &&
                pddc == _pddc)
            {
                _pddsFront->SetClipper(NULL);
            }
        }

        _pddc->Release();
    }
    if (_pddsFront != NULL)
    {
        _pddsFront->Release();
    }

    if (_dwFlags & GLDD_FULL_SCREEN)
    {
        // Recover from mode changes
        pdd->SetCooperativeLevel(_hwnd, DDSCL_NORMAL);
        pdd->RestoreDisplayMode();
    }
    
    if (_hwnd != NULL)
    {
        DestroyWindow(_hwnd);
    }
}

/******************************Public*Routine******************************\
*
* glddRegisterClass
*
* Register a window class if necessary
*
* History:
*  Fri Aug 30 14:37:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glddRegisterClass(void)
{
    static ATOM aClass = 0;
    WNDCLASS wc;

    if (aClass == 0)
    {
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = glddWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = pszClass;
        aClass = RegisterClass(&wc);
        if (aClass == 0)
        {
            hrGlddLast = WIN32_HR();
            return FALSE;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* glddCreateWindow
*
* Create a new rendering window
*
* History:
*  Fri Aug 30 14:38:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLDDWINDOW glddCreateWindow(char *pszTitle, int x, int y,
                            int iWidth, int iHeight, int iDepth,
                            DWORD dwFlags)
{
    GLDDWINDOW gw;
        
    if (!glddRegisterClass())
    {
        return NULL;
    }

    // If we haven't initialized the global IDirectDraw, do so
    if (pdd == NULL)
    {
        hrGlddLast = DirectDrawCreate(NULL, &pdd, NULL);
        if (hrGlddLast != DD_OK)
        {
            return NULL;
        }
    }
        
    gw = new _GLDDWINDOW;
    if (gw == NULL)
    {
        hrGlddLast = E_OUTOFMEMORY;
        return NULL;
    }

    if (gw->Create(pszTitle, x, y, iWidth, iHeight, iDepth, dwFlags))
    {
        return gw;
    }
    else
    {
        delete gw;
        return NULL;
    }
}

/******************************Public*Routine******************************\
*
* glddDestroyWindow
*
* Clean up a rendering window
*
* History:
*  Fri Aug 30 14:39:20 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddDestroyWindow(GLDDWINDOW gw)
{
    delete gw;
}

/******************************Public*Routine******************************\
*
* glddGetGlrc
*
* Return a rendering window's OpenGL rendering context
*
* History:
*  Fri Aug 30 14:39:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HGLRC glddGetGlrc(GLDDWINDOW gw)
{
    return gw->_hrc;
}

/******************************Public*Routine******************************\
*
* glddGetLastError
*
* Returns the last error recorded by the library
*
* History:
*  Fri Aug 30 14:39:39 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HRESULT glddGetLastError(void)
{
#if DBG
    char pszMsg[80];

    if (hrGlddLast != DD_OK)
    {
        sprintf(pszMsg, "glddGetLastError returning 0x%08lX\n", hrGlddLast);
        OutputDebugString(pszMsg);
    }
#endif
    return hrGlddLast;
}

/******************************Public*Routine******************************\
*
* glddMakeCurrent
*
* Makes the given rendering window's OpenGL rendering context current
*
* History:
*  Fri Aug 30 14:39:47 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glddMakeCurrent(GLDDWINDOW gw)
{
    BOOL b;
    HDC hdc;
    LPDIRECTDRAWSURFACE pddsRender;

    if (gw->_dwFlags & GLDD_BACK_BUFFER)
    {
        pddsRender = gw->_pddsBack;
    }
    else
    {
        pddsRender = gw->_pddsFront;
    }
    
    hrGlddLast = pddsRender->GetDC(&hdc);
    if (hrGlddLast != DD_OK)
    {
        return FALSE;
    }
    
    b = wglMakeCurrent(hdc, gw->_hrc);

    pddsRender->ReleaseDC(hdc);
    
    if (!b)
    {
        hrGlddLast = WIN32_HR();
    }
    
    return b;
}

/******************************Public*Routine******************************\
*
* glddSwapBuffers
*
* Performs double-buffer swapping through blt or flip
*
* History:
*  Fri Aug 30 14:40:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glddSwapBuffers(GLDDWINDOW gw)
{
    // Check for a back buffer
    if ((gw->_dwFlags & GLDD_BACK_BUFFER) == 0)
    {
        hrGlddLast = E_INVALIDARG;
        return FALSE;
    }
    
    if (gw->_dwFlags & GLDD_FULL_SCREEN)
    {
        hrGlddLast = gw->_pddsFront->Flip(NULL, DDFLIP_WAIT);
        return hrGlddLast == DD_OK;
    }
    else
    {
        RECT rctSrc, rctDst;
        POINT pt;

        GetClientRect(gw->_hwnd, &rctDst);
        pt.x = 0;
        pt.y = 0;
        ClientToScreen(gw->_hwnd, &pt);
        rctDst.left = pt.x;
        rctDst.top = pt.y;
        rctDst.right += pt.x;
        rctDst.bottom += pt.y;
        rctSrc.left = 0;
        rctSrc.top = 0;
        rctSrc.right = gw->_iWidth;
        rctSrc.bottom = gw->_iHeight;
        hrGlddLast = gw->_pddsFront->Blt(&rctDst, gw->_pddsBack,
                                         &rctSrc, DDBLT_WAIT,
                                         NULL);
        return hrGlddLast == DD_OK;
    }
}

/******************************Public*Routine******************************\
*
* glddIdleCallback
*
* Set the idle-time callback
*
* History:
*  Fri Aug 30 14:41:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddIdleCallback(GLDDWINDOW gw, GLDDIDLECALLBACK cb)
{
    gw->_cbIdle = cb;
}

/******************************Public*Routine******************************\
*
* glddMessageCallback
*
* Set the message interposition callback
*
* History:
*  Fri Aug 30 14:41:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddMessageCallback(GLDDWINDOW gw, GLDDMESSAGECALLBACK cb)
{
    gw->_cbMessage = cb;
}

/******************************Public*Routine******************************\
*
* glddRun
*
* Run the message loop
*
* History:
*  Fri Aug 30 14:41:58 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glddRun(GLDDWINDOW gw)
{
    MSG msg;
    BOOL bQuit;

    bQuit = FALSE;
    while (!bQuit)
    {
        // NULL hwnd doesn't work with multiple windows but
        // is necessary to get quit message
        while (!bQuit && PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                bQuit = TRUE;
            }
        }

        // Call the idle callback if one exists
        if (gw->_cbIdle)
        {
            gw->_cbIdle(gw);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\gldd\lib\gldd.h ===
#ifndef __GLDD_H__
#define __GLDD_H__

#include <windows.h>
#include <ddraw.h>
#include <gl/gl.h>

#ifndef __GLDD_INTERNAL__
typedef void *GLDDWINDOW;
#endif

typedef void (CALLBACK *GLDDIDLECALLBACK)(GLDDWINDOW gw);
typedef BOOL (CALLBACK *GLDDMESSAGECALLBACK)
    (GLDDWINDOW gw, HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm,
     LRESULT *plr);

#define GLDD_BACK_BUFFER        	0x00000001
#define GLDD_Z_BUFFER_16        	0x00000002
#define GLDD_Z_BUFFER_32        	0x00000004
#define GLDD_ACCUM_BUFFER       	0x00000008
#define GLDD_STENCIL_BUFFER     	0x00000010
#define GLDD_VIDEO_MEMORY       	0x00000020
#define GLDD_FULL_SCREEN        	0x00000040
#define GLDD_STRICT_MEMORY      	0x00000080
#define GLDD_GENERIC_ACCELERATED	0x00000100
#define GLDD_USE_MODE_X                 0x00000200

#ifdef __cplusplus
extern "C" {
#endif
    
GLDDWINDOW glddCreateWindow(char *pszTitle, int x, int y,
                            int iWidth, int iHeight, int iDepth,
                            DWORD dwFlags);
void glddDestroyWindow(GLDDWINDOW gw);

HGLRC glddGetGlrc(GLDDWINDOW gw);
HRESULT glddGetLastError(void);

BOOL glddMakeCurrent(GLDDWINDOW gw);
BOOL glddSwapBuffers(GLDDWINDOW gw);
void glddRun(GLDDWINDOW gw);

void glddIdleCallback(GLDDWINDOW gw, GLDDIDLECALLBACK cb);
void glddMessageCallback(GLDDWINDOW gw, GLDDMESSAGECALLBACK cb);

#ifdef __cplusplus
}
#endif
    
#endif // __GLDD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\gldd\single\vtex.c ===
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>

#include <windows.h>
#include <vfw.h>

#include <gldd.h>
#include <gl/glu.h>
#include <gl/glaux.h>

#define PI 3.14159265358979323846

#define NLETTERS 64
#define FIRST_LETTER '@'

#define NOBJS 6

GLenum doubleBuffer;
GLenum videoMemory;
GLenum noSwap;
GLenum noClear;
GLenum fullScreen;
GLenum useMcd;
GLenum modeX;
GLenum stretch;
GLenum paletted;
GLenum timings;
GLenum spin;

GLenum updateMovie = GL_TRUE;
GLenum linearFilter = GL_FALSE;

int fullWidth, fullHeight, fullDepth;
int winWidth, winHeight;
int texWidth, texHeight;
int movX, movY;
int movWidth, movHeight;
GLuint clearBits;
DWORD ticks;
int frames;

GLint letters;
GLYPHMETRICSFLOAT letterMetrics[NLETTERS];

double xrot, yrot;

GLDDWINDOW gwMain = NULL;

PFNGLCOLORTABLEEXTPROC pfnColorTableEXT;
PFNGLCOLORSUBTABLEEXTPROC pfnColorSubTableEXT;

LPDIRECTDRAWSURFACE pddsTex;
DDSURFACEDESC ddsdTex;

char *aviFileName = "d:\\winnt\\clock.avi";
PAVISTREAM aviStream;
long aviLength;
long curFrame;
PGETFRAME aviGetFrame;
BITMAPINFO *pbmiMovie;

typedef struct _Object
{
    void (*build_fn)(void);
    GLenum canCull;
    GLenum needsZ;
    GLint dlist;
} Object;

int objIdx = 0;

float c[6][4][3] = {
    {
	{
	    1.0f, 1.0f, -1.0f
	},
	{
	    -1.0f, 1.0f, -1.0f
	},
	{
	    -1.0f, -1.0f, -1.0f
	},
	{
	    1.0f, -1.0f, -1.0f
	}
    },
    {
	{
	    1.0f, 1.0f, 1.0f
	},
	{
	    1.0f, 1.0f, -1.0f
	},
	{
	    1.0f, -1.0f, -1.0f
	},
	{
	    1.0f, -1.0f, 1.0f
	}
    },
    {
	{
	    -1.0f, 1.0f, 1.0f
	},
	{
	    1.0f, 1.0f, 1.0f
	},
	{
	    1.0f, -1.0f, 1.0f
	},
	{
	    -1.0f, -1.0f, 1.0f
	}
    },
    {
	{
	    -1.0f, 1.0f, -1.0f
	},
	{
	    -1.0f, 1.0f, 1.0f
	},
	{
	    -1.0f, -1.0f, 1.0f
	},
	{
	    -1.0f, -1.0f, -1.0f
	}
    },
    {
	{
	    -1.0f, 1.0f, 1.0f
	},
	{
	    -1.0f, 1.0f, -1.0f
	},
	{
	    1.0f, 1.0f, -1.0f
	},
	{
	    1.0f, 1.0f, 1.0f
	}
    },
    {
	{
	    -1.0f, -1.0f, -1.0f
	},
	{
	    -1.0f, -1.0f, 1.0f
	},
	{
	    1.0f, -1.0f, 1.0f
	},
	{
	    1.0f, -1.0f, -1.0f
	}
    }
};

float n[6][3] = {
    {
	0.0f, 0.0f, -1.0f
    },
    {
	1.0f, 0.0f, 0.0f
    },
    {
	0.0f, 0.0f, 1.0f
    },
    {
	-1.0f, 0.0f, 0.0f
    },
    {
	0.0f, 1.0f, 0.0f
    },
    {
	0.0f, -1.0f, 0.0f
    }
};

float t[6][4][2] = {
    {
	{
	    1.0f,  1.0f
	},
	{
	    -0.0f, 1.0f
	},
	{
	    -0.0f, -0.0f
	},
	{
	    1.0f,  -0.0f
	}
    },
    {
	{
	    1.0f,  1.0f
	},
	{
	    -0.0f, 1.0f
	},
	{
	    -0.0f, -0.0f
	},
	{
	    1.0f,  -0.0f
	}
    },
    {
	{
	    -0.0f,  1.0f
	},
	{
	    1.0f, 1.0f
	},
	{
	    1.0f, -0.0f
	},
	{
	    -0.0f,  -0.0f
	}
    },
    {
	{
	    1.0f,  1.0f
	},
	{
	    -0.0f, 1.0f
	},
	{
	    -0.0f, -0.0f
	},
	{
	    1.0f,  -0.0f
	}
    },
    {
	{
	    1.0f,  1.0f
	},
	{
	    -0.0f, 1.0f
	},
	{
	    -0.0f, -0.0f
	},
	{
	    1.0f,  -0.0f
	}
    },
    {
	{
	    1.0f,  1.0f
	},
	{
	    -0.0f, 1.0f
	},
	{
	    -0.0f, -0.0f
	},
	{
	    1.0f,  -0.0f
	}
    },
};

void BuildSphere(void)
{
    GLUquadricObj *quadObj;

    quadObj = gluNewQuadric ();
    gluQuadricDrawStyle (quadObj, GLU_FILL);
    gluQuadricNormals (quadObj, GLU_SMOOTH);
    gluQuadricTexture (quadObj, GL_TRUE);
    gluSphere (quadObj, 1.0, 16, 16);
    gluDeleteQuadric(quadObj);
}

void BuildCube(void)
{
    GLint i;

    for (i = 0; i < 6; i++)
    {
	glBegin(GL_POLYGON);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][0]); glVertex3fv(c[i][0]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][3]); glVertex3fv(c[i][3]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][2]); glVertex3fv(c[i][2]);
	    glNormal3fv(n[i]); glTexCoord2fv(t[i][1]); glVertex3fv(c[i][1]);
	glEnd();
    }
}

void BuildCylinder(void)
{
    GLUquadricObj *quadObj;
    
    glPushMatrix ();
    glRotatef ((GLfloat)90.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
    glTranslatef ((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);
    quadObj = gluNewQuadric ();
    gluQuadricDrawStyle (quadObj, GLU_FILL);
    gluQuadricTexture (quadObj, GL_TRUE);
    gluCylinder (quadObj, 1.0, 1.0, 1.5, 20, 2);
    glPopMatrix ();
    gluDeleteQuadric(quadObj);
}

void BuildCone(void)
{
    GLUquadricObj *quadObj;
    
    quadObj = gluNewQuadric ();
    gluQuadricDrawStyle (quadObj, GLU_FILL);
    gluQuadricTexture (quadObj, GL_TRUE);
    gluCylinder (quadObj, 1.0, 0.0, 1.5, 20, 2);
    gluDeleteQuadric(quadObj);
}

void BuildTeapot(void)
{
    auxSolidTeapot(1.0);
}

#define STRING "OpenGL"

void BuildString(void)
{
    char *str;
    int i, l;
    float wd, ht;
    GLfloat fv4[4];

    str = STRING;
    l = strlen(str);
    
    wd = 0.0f;
    for (i = 0; i < l-1; i++)
    {
        wd += letterMetrics[str[i]-FIRST_LETTER].gmfCellIncX;
    }
    wd += letterMetrics[str[i]-FIRST_LETTER].gmfBlackBoxX;
    ht = letterMetrics[str[0]-FIRST_LETTER].gmfBlackBoxY;
    
    glPushMatrix();

    glScalef(1.0f, 2.0f, 1.0f);
    glTranslatef(-wd/2.0f, -ht/2.0f, 0.0f);
    
    fv4[0] = 1.0f/wd;
    fv4[1] = 0.0f;
    fv4[2] = 0.0f;
    fv4[3] = 0.0f;
    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR );
    glTexGenfv(GL_S, GL_EYE_PLANE, fv4 );

    fv4[0] = 0.0f;
    fv4[1] = -1.0f/ht;
    fv4[2] = 0.0f;
    fv4[3] = 0.0f;
    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR );
    glTexGenfv(GL_T, GL_EYE_PLANE, fv4 );

    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_GEN_T);

    glListBase(letters-FIRST_LETTER);
    glCallLists(l, GL_UNSIGNED_BYTE, str);

    glListBase(0);
    glPopMatrix();
    glDisable(GL_TEXTURE_GEN_S);
    glDisable(GL_TEXTURE_GEN_T);
}

Object objects[NOBJS] =
{
    BuildCube, GL_TRUE, GL_FALSE, 0,
    BuildSphere, GL_TRUE, GL_FALSE, 0,
    BuildCylinder, GL_FALSE, GL_TRUE, 0,
    BuildCone, GL_FALSE, GL_TRUE, 0,
    BuildTeapot, GL_FALSE, GL_TRUE, 0,
    BuildString, GL_TRUE, GL_TRUE, 0,
};

void BuildLists(void)
{
    int i;
    GLint base;
    
    base = glGenLists(NOBJS);
    for (i = 0; i < NOBJS; i++)
    {
        objects[i].dlist = base+i;
        glNewList(objects[i].dlist, GL_COMPILE);
        objects[i].build_fn();
        glEndList();
    }
}
    
void Quit(char *fmt, ...)
{
    va_list args;

    if (fmt != NULL)
    {
        va_start(args, fmt);
        vprintf(fmt, args);
        va_end(args);
    }

    if (aviGetFrame != NULL)
    {
        AVIStreamGetFrameClose(aviGetFrame);
    }

    if (aviStream != NULL)
    {
        AVIStreamRelease(aviStream);
        AVIFileExit();
    }
    
    if (gwMain != NULL)
    {
        glddDestroyWindow(gwMain);
    }
    
    exit(1);
}

void Draw(void)
{
    DWORD fticks;

    fticks = GetTickCount();
    
    glClear(clearBits);

    glLoadIdentity();
    glRotated(xrot, 1.0, 0.0, 0.0);
    glRotated(yrot, 0.0, 1.0, 0.0);
    
    glCallList(objects[objIdx].dlist);

    glFlush();
    if (doubleBuffer && !noSwap)
    {
	glddSwapBuffers(gwMain);
    }

    ticks += GetTickCount()-fticks;
    frames++;

    if (timings && ticks > 1000)
    {
        printf("%d frames in %d ticks, %.3lf f/s\n", frames, ticks,
               (double)frames*1000.0/ticks);
        frames = 0;
        ticks = 0;
    }
}

void *UpdateBmi(BITMAPINFO *pbmi)
{
    if (pbmi->bmiHeader.biSize != sizeof(BITMAPINFOHEADER))
    {
        Quit("Unknown stream format data\n");
    }

    memcpy(pbmiMovie->bmiColors, pbmi->bmiColors, 256*sizeof(RGBQUAD));

    // Return pointer to data after BITMAPINFO
    return pbmi->bmiColors+256;
}

void FrameToTex(long frame)
{
    HDC hdc;
    HRESULT hr;
    LPVOID pvFrame, pvData;

    pvFrame = AVIStreamGetFrame(aviGetFrame, frame);
    if (pvFrame == NULL)
    {
        Quit("AVIStreamGetFrame failed\n");
    }

    // Skip past BITMAPINFO at start of frame.
    // If it becomes interesting to support palette changes per frame
    // this should call UpdateBmi
#if 0
    pvData = (LPVOID)((BYTE *)pvFrame+sizeof(BITMAPINFO)+255*sizeof(RGBQUAD));
#else
    pvData = UpdateBmi(pvFrame);
    if (paletted)
    {
        pfnColorSubTableEXT(GL_TEXTURE_2D, 0, 256, GL_BGRA_EXT,
                            GL_UNSIGNED_BYTE, pbmiMovie->bmiColors);
    }
#endif

    if (stretch)
    {
        hr = pddsTex->lpVtbl->GetDC(pddsTex, &hdc);
        if (hr != DD_OK)
        {
            Quit("Stretch GetDC failed, 0x%08lX\n", hr);
        }

        StretchDIBits(hdc, 0, 0, texWidth, texHeight,
                      0, 0, movWidth, movHeight, pvData, pbmiMovie,
                      DIB_RGB_COLORS, SRCCOPY);
    
        pddsTex->lpVtbl->ReleaseDC(pddsTex, hdc);
    }
    else if (!paletted)
    {
        hr = pddsTex->lpVtbl->GetDC(pddsTex, &hdc);
        if (hr != DD_OK)
        {
            Quit("Set GetDC failed, 0x%08lX\n", hr);
        }

        // The only AVI sources currently allowed are 8bpp so if the texture
        // isn't paletted a conversion is necessary
        SetDIBitsToDevice(hdc, movX, movY, movWidth, movHeight,
                          0, 0, 0, movHeight, pvData, pbmiMovie,
                          DIB_RGB_COLORS);

        pddsTex->lpVtbl->ReleaseDC(pddsTex, hdc);
    }
    else
    {
        UINT cbLine;
        int y;
        BYTE *pbSrc, *pbDst;
        HRESULT hr;

        hr = pddsTex->lpVtbl->Lock(pddsTex, NULL, &ddsdTex,
                                   DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT,
                                   NULL);
        if (hr != S_OK)
        {
            Quit("Unable to lock texture, 0x%08lX\n", hr);
        }

        cbLine = (movWidth+3) & ~3;
        pbSrc = (BYTE *)pvData;
        pbDst = (BYTE *)ddsdTex.lpSurface+ddsdTex.lPitch*movY+movX;
        
#if 1
        for (y = 0; y < movHeight; y++)
        {
            memcpy(pbDst, pbSrc, movWidth);
            pbSrc += cbLine;
            pbDst += ddsdTex.lPitch;
        }
#else
        for (y = 0; y < movHeight; y++)
        {
            memset(pbDst, y*256/movHeight, movWidth);
            pbSrc += cbLine;
            pbDst += ddsdTex.lPitch;
        }
#endif

        pddsTex->lpVtbl->Unlock(pddsTex, ddsdTex.lpSurface);
    }
}

void Animate(GLDDWINDOW gw)
{
    if (updateMovie)
    {
        if (++curFrame == aviLength)
        {
            curFrame = 0;
        }
        FrameToTex(curFrame);
    }

    if (spin)
    {
        xrot += 2;
        yrot += 3;
    }
    
    Draw();
}

void SetView(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (double)winWidth/winHeight, 0.1, 10);
    gluLookAt(0.0, 0.0, 5.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
    glMatrixMode(GL_MODELVIEW);
}

void ToggleGl(GLenum state)
{
    if (glIsEnabled(state))
    {
        glDisable(state);
    }
    else
    {
        glEnable(state);
    }
}

void SetObject(int idx)
{
    objIdx = idx;

    clearBits = GL_COLOR_BUFFER_BIT;

    if (objects[objIdx].canCull)
    {
        glFrontFace(GL_CCW);
        glCullFace(GL_BACK);
        glEnable(GL_CULL_FACE);
    }
    else
    {
        glDisable(GL_CULL_FACE);
    }
    
    if (objects[objIdx].needsZ)
    {
        clearBits |= GL_DEPTH_BUFFER_BIT;
        glEnable(GL_DEPTH_TEST);
    }
    else
    {
        glDisable(GL_DEPTH_TEST);
    }
}

void SetTexFilter(void)
{
    GLenum filter;

    
    filter = linearFilter ? GL_LINEAR : GL_NEAREST;
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filter);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filter);
}

void ClearTex(void)
{
    DDBLTFX ddbltfx;
    RECT drct;
    HRESULT hr;
    
    drct.left = 0;
    drct.top = 0;
    drct.right = texWidth;
    drct.bottom = texHeight;
    
    memset(&ddbltfx, 0, sizeof(ddbltfx));
    ddbltfx.dwSize = sizeof(ddbltfx);
    ddbltfx.dwFillColor = 0;
    
    hr = pddsTex->lpVtbl->Blt(pddsTex, &drct, NULL, NULL,
                              DDBLT_COLORFILL | DDBLT_WAIT, &ddbltfx);
    if (hr != DD_OK)
    {
        Quit("Blt failed, 0x%08lX\n", hr);
    }
}

void Key(UINT key)
{
    switch(key)
    {
    case VK_ESCAPE:
        Quit(NULL);
        break;

    case VK_SPACE:
        spin = !spin;
        break;

    case 'D':
        ToggleGl(GL_DITHER);
        break;
        
    case 'F':
        linearFilter = !linearFilter;
        SetTexFilter();
        break;
        
    case 'H':
        stretch = !stretch;
        break;
        
    case 'M':
        updateMovie = !updateMovie;
        break;
        
    case 'O':
        if (++objIdx == NOBJS)
        {
            objIdx = 0;
        }
        SetObject(objIdx);
        break;
        
    case 'S':
        spin = !spin;
        break;
        
    case 'T':
        timings = !timings;
        frames = 0;
        ticks = 0;
        break;

    case 'X':
        ToggleGl(GL_TEXTURE_2D);
        break;

    default:
        break;
    }
}

BOOL Message(GLDDWINDOW gw, HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm,
             LRESULT *plr)
{
    switch(uiMsg)
    {
    case WM_KEYDOWN:
        Key((UINT)wpm);
        break;

    case WM_SIZE:
        winWidth = LOWORD(lpm);
        winHeight = HIWORD(lpm);
        SetView();
        break;
        
    default:
        return FALSE;
    }

    *plr = 0;
    return TRUE;
}

void GetStreamFormat(void)
{
    HRESULT hr;
    LONG fmtSize;
    void *pvFmt;
    
    hr = AVIStreamFormatSize(aviStream, 0, &fmtSize);
    if (hr != S_OK)
    {
        Quit("AVIStreamFormatSize failed, 0x%08lX\n", hr);
    }
    
    pvFmt = malloc(fmtSize);
    if (pvFmt == NULL)
    {
        Quit("Unable to allocate format buffer\n");
    }

    hr = AVIStreamReadFormat(aviStream, 0, pvFmt, &fmtSize);
    if (hr != S_OK)
    {
        Quit("AVIStreamReadFormat failed, 0x%08lX\n", hr);
    }

    UpdateBmi((BITMAPINFO *)pvFmt);

    free(pvFmt);
}

void OpenMovie(void)
{
    HRESULT hr;
    AVISTREAMINFO sinfo;
    BITMAPINFOHEADER *pbmih;

    AVIFileInit();
    
    hr = AVIStreamOpenFromFile(&aviStream, aviFileName, streamtypeVIDEO,
                               0, OF_READ | OF_SHARE_DENY_WRITE, NULL);
    if (hr != S_OK)
    {
        Quit("AVIStreamOpenFromFile failed, 0x%08lX\n", hr);
    }

    aviLength = AVIStreamLength(aviStream);

    hr = AVIStreamInfo(aviStream, &sinfo, sizeof(sinfo));
    if (hr != S_OK)
    {
        Quit("AVIStreamInfo failed, 0x%08lX\n", hr);
    }

    if (sinfo.dwFlags & AVISTREAMINFO_FORMATCHANGES)
    {
        printf("WARNING: Stream contains format changes, unhandled\n");
    }

    GetStreamFormat();
    
    movWidth = sinfo.rcFrame.right-sinfo.rcFrame.left;
    movHeight = sinfo.rcFrame.bottom-sinfo.rcFrame.top;

#if 1
    printf("Movie '%s' is %d x %d\n", aviFileName, movWidth, movHeight);
#endif
    
#if 0
    if ((movWidth & (movWidth-1)) != 0 ||
        (movHeight & (movHeight-1)) != 0)
    {
        Quit("Movie must have frames that are a power of two in size, "
             "movie is %d x %d\n", movWidth, movHeight);
    }
#endif

    pbmih = &pbmiMovie->bmiHeader;
    memset(pbmih, 0, sizeof(BITMAPINFOHEADER));
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = movWidth;
    pbmih->biHeight = movHeight;
    pbmih->biPlanes = 1;
    pbmih->biBitCount = 8;
    pbmih->biCompression = BI_RGB;

    aviGetFrame = AVIStreamGetFrameOpen(aviStream, pbmih);
    if (aviGetFrame == NULL)
    {
        Quit("AVIStreamGetFrameOpen failed\n");
    }
}

BOOL WINAPI texCallback(LPDDSURFACEDESC pddsd, LPVOID pv)
{
    if ((paletted && pddsd->ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8) ||
        (!paletted && pddsd->ddpfPixelFormat.dwFlags == DDPF_RGB))
    {
        ddsdTex = *pddsd;
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

void CreateTex(int minWidth, int minHeight)
{
    LPDIRECTDRAW pdd;
    HRESULT hr;

    texWidth = 1;
    texHeight = 1;
    while (texWidth < minWidth && texWidth < winWidth)
    {
        texWidth *= 2;
    }
    if (texWidth > winWidth)
    {
        texWidth /= 2;
    }
    while (texHeight < minHeight && texHeight < winHeight)
    {
        texHeight *= 2;
    }
    if (texHeight > winHeight)
    {
        texHeight /= 2;
    }
    
    if (!wglEnumTextureFormats(texCallback, NULL))
    {
	Quit("wglEnumTextureFormats failed, %d\n", GetLastError());
    }

    hr = DirectDrawCreate(NULL, &pdd, NULL);
    if (hr != DD_OK)
    {
        Quit("DirectDrawCreate failed, 0x%08lX\n", hr);
    }
    hr = pdd->lpVtbl->SetCooperativeLevel(pdd, NULL, DDSCL_NORMAL);
    if (hr != DD_OK)
    {
        Quit("SetCooperativeLevel failed, 0x%08lX\n", hr);
    }

    ddsdTex.dwFlags |= DDSD_WIDTH | DDSD_HEIGHT;
    ddsdTex.dwWidth = texWidth;
    ddsdTex.dwHeight = texHeight;
    ddsdTex.ddsCaps.dwCaps &= ~DDSCAPS_MIPMAP;
    
    hr = pdd->lpVtbl->CreateSurface(pdd, &ddsdTex, &pddsTex, NULL);
    if (hr != DD_OK)
    {
        Quit("Texture CreateSurface failed, 0x%08lX\n", hr);
    }

    ClearTex();
}

void Init(void)
{
    HDC hdc, screen;
    HFONT fnt;
    
    pfnColorTableEXT = (PFNGLCOLORTABLEEXTPROC)
        wglGetProcAddress("glColorTableEXT");
    if (pfnColorTableEXT == NULL)
    {
        Quit("glColorTableEXT not supported\n");
    }
    pfnColorSubTableEXT = (PFNGLCOLORSUBTABLEEXTPROC)
        wglGetProcAddress("glColorSubTableEXT");
    if (pfnColorSubTableEXT == NULL)
    {
        Quit("glColorSubTableEXT not supported\n");
    }
    
    pbmiMovie = (BITMAPINFO *)malloc(sizeof(BITMAPINFO)+255*sizeof(RGBQUAD));
    if (pbmiMovie == NULL)
    {
        Quit("Unable to allocate pbmiMovie\n");
    }
    
    OpenMovie();
    
    // Must come after movie is open so width and height are set
    CreateTex(movWidth, movHeight);

    movX = (texWidth-movWidth)/2;
    movY = (texHeight-movHeight)/2;
    
    wglBindDirectDrawTexture(pddsTex);
    
    // Create texture palette if necessary
    if (paletted)
    {
        pfnColorTableEXT(GL_TEXTURE_2D, GL_RGB, 256, GL_BGRA_EXT,
                         GL_UNSIGNED_BYTE, pbmiMovie->bmiColors);
    }

    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    linearFilter = GL_FALSE;
    SetTexFilter();
    
    glEnable(GL_TEXTURE_2D);

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);

    // Fill in initial movie frame
    curFrame = 0;
    FrameToTex(curFrame);

    // Provide letters for objects to compose themselves from
    screen = GetDC(NULL);
    hdc = CreateCompatibleDC(screen);
    if (hdc == NULL)
    {
        Quit("CreateCompatibleDC failed, %d\n", GetLastError());
    }

    fnt = CreateFont(72, 0, 0, 0, FW_HEAVY, FALSE, FALSE, FALSE,
                     ANSI_CHARSET, OUT_TT_ONLY_PRECIS,
                     CLIP_DEFAULT_PRECIS, PROOF_QUALITY, DEFAULT_PITCH |
                     TMPF_TRUETYPE | FF_DONTCARE, "Arial");
    if (fnt == NULL)
    {
        Quit("CreateFont failed, %d\n", GetLastError());
    }

    SelectObject(hdc, fnt);

    letters = glGenLists(NLETTERS);
    
    if (!wglUseFontOutlines(hdc, FIRST_LETTER, NLETTERS, letters, 0.0f, 0.1f,
                            WGL_FONT_POLYGONS, letterMetrics))
    {
        Quit("wglUseFontOutlines failed, %d\n", GetLastError());
    }

    DeleteDC(hdc);
    DeleteObject(fnt);
    ReleaseDC(NULL, screen);
    
    BuildLists();

    SetObject(0);
    
    xrot = 0.0;
    yrot = 0.0;

    SetView();
}

GLenum Args(int argc, char **argv)
{
    GLint i;

    winWidth = 320;
    winHeight = 320;
    doubleBuffer = GL_TRUE;
    videoMemory = GL_FALSE;
    noSwap = GL_FALSE;
    noClear = GL_FALSE;
    fullScreen = GL_FALSE;
    fullWidth = 640;
    fullHeight = 480;
    fullDepth = 16;
    useMcd = GL_FALSE;
    modeX = GL_FALSE;
    stretch = GL_TRUE;
    paletted = GL_TRUE;
    timings = GL_FALSE;
    spin = GL_TRUE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    paletted = GL_FALSE;
	} else if (strcmp(argv[i], "-stretch") == 0) {
	    stretch = GL_TRUE;
	} else if (strcmp(argv[i], "-nostretch") == 0) {
	    stretch = GL_FALSE;
	} else if (strcmp(argv[i], "-nospin") == 0) {
            spin = GL_FALSE;
	} else if (strcmp(argv[i], "-vm") == 0) {
	    videoMemory = GL_TRUE;
	} else if (strcmp(argv[i], "-noswap") == 0) {
	    noSwap = GL_TRUE;
	} else if (strcmp(argv[i], "-noclear") == 0) {
	    noClear = GL_TRUE;
	} else if (strcmp(argv[i], "-full") == 0) {
	    fullScreen = GL_TRUE;
	} else if (strcmp(argv[i], "-modex") == 0) {
	    modeX = GL_TRUE;
	    fullWidth = 320;
	    fullHeight = 240;
	    fullDepth = 8;
	} else if (strcmp(argv[i], "-mcd") == 0) {
	    useMcd = GL_TRUE;
	} else if (strcmp(argv[i], "-surf") == 0) {
            if (i+2 >= argc ||
                argv[i+1][0] == '-' ||
                argv[i+2][0] == '-')
            {
                printf("-surf (No numbers).\n");
                return GL_FALSE;
            }
            else
            {
                winWidth = atoi(argv[++i]);
                winHeight = atoi(argv[++i]);
            }
	} else if (strcmp(argv[i], "-fdim") == 0) {
            if (i+3 >= argc ||
                argv[i+1][0] == '-' ||
                argv[i+2][0] == '-' ||
                argv[i+3][0] == '-')
            {
                printf("-fdim (No numbers).\n");
                return GL_FALSE;
            }
            else
            {
                fullWidth = atoi(argv[++i]);
                fullHeight = atoi(argv[++i]);
                fullDepth = atoi(argv[++i]);
            }
        } else if (strcmp(argv[i], "-mov") == 0) {
            if (i+1 >= argc ||
                argv[i+1][0] == '-')
            {
                printf("-mov (No filename).\n");
                return GL_FALSE;
            }
            else
            {
                aviFileName = argv[++i];
            }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void __cdecl main(int argc, char **argv)
{
    DWORD dwFlags;
    GLDDWINDOW gw;

    if (Args(argc, argv) == GL_FALSE) {
	exit(1);
    }

    dwFlags = GLDD_Z_BUFFER_16;
    dwFlags |= doubleBuffer ? GLDD_BACK_BUFFER : 0;
    dwFlags |= videoMemory ? GLDD_VIDEO_MEMORY : 0;
    dwFlags |= useMcd ? GLDD_GENERIC_ACCELERATED : 0;
    if (fullScreen)
    {
        dwFlags |= GLDD_FULL_SCREEN;
	dwFlags |= modeX ? GLDD_USE_MODE_X : 0;
        winWidth = fullWidth;
        winHeight = fullHeight;
    }

    gw = glddCreateWindow("Video Texture", 10, 30, winWidth, winHeight,
                          fullDepth, dwFlags);
    if (gw == NULL)
    {
        printf("glddCreateWindow failed with 0x%08lX\n", glddGetLastError());
        exit(1);
    }
    gwMain = gw;

    glddMakeCurrent(gw);
    
    Init();

    glddIdleCallback(gw, Animate);
    glddMessageCallback(gw, Message);
    glddRun(gw);

    Quit(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\glut.h ===
#ifndef __glut_h__
#define __glut_h__

/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <GL/gl.h>
#include <GL/glu.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GLUT API revision history:
 *
 * GLUT_API_VERSION is updated to reflect incompatible GLUT
 * API changes (interface changes, semantic changes, deletions,
 * or additions).
 *
 * GLUT_API_VERSION=1  First public release of GLUT.  11/29/94
 *
 * GLUT_API_VERSION=2  Added support for OpenGL/GLX multisampling,
 * extension.  Supports new input devices like tablet, dial and button
 * box, and Spaceball.  Easy to query OpenGL extensions.
 *
 */
#ifndef GLUT_API_VERSION	/* allow this to be overriden */
#define GLUT_API_VERSION		2
#endif

/*
 * GLUT implementation revision history:
 *
 * GLUT_XLIB_IMPLEMENTATION is updated to reflect both GLUT
 * API revisions and implementation revisions (ie, bug fixes).
 *
 * GLUT_XLIB_IMPLEMENTATION=1  mjk's first public release of
 * GLUT Xlib-based implementation.  11/29/94
 *
 * GLUT_XLIB_IMPLEMENTATION=2  mjk's second public release of
 * GLUT Xlib-based implementation providing GLUT version 2 
 * interfaces.
 *
 * GLUT_WIN32_IMPLEMENTATION=2 Drew Bliss's addition of Win32 targeting,
 * supporting GLUT version 2 interfaces
 */
#ifndef GLUT_XLIB_IMPLEMENTATION	/* allow this to be overriden */
#define GLUT_XLIB_IMPLEMENTATION	2
#endif

#ifndef GLUT_WIN32_IMPLEMENTATION	/* allow this to be overriden */
#define GLUT_WIN32_IMPLEMENTATION	2
#endif

/* display mode bit masks */
#define GLUT_RGB			0
#define GLUT_RGBA			GLUT_RGB
#define GLUT_INDEX			1
#define GLUT_SINGLE			0
#define GLUT_DOUBLE			2
#define GLUT_ACCUM			4
#define GLUT_ALPHA			8
#define GLUT_DEPTH			16
#define GLUT_STENCIL			32
#if (GLUT_API_VERSION >= 2)
#define GLUT_MULTISAMPLE		128
#define GLUT_STEREO			256
#endif

/* mouse buttons */
#define GLUT_LEFT_BUTTON		0
#define GLUT_MIDDLE_BUTTON		1
#define GLUT_RIGHT_BUTTON		2

/* mouse button callback state */
#define GLUT_DOWN			0
#define GLUT_UP				1

#if (GLUT_API_VERSION >= 2)
/* function keys */
#define GLUT_KEY_F1			1
#define GLUT_KEY_F2			2
#define GLUT_KEY_F3			3
#define GLUT_KEY_F4			4
#define GLUT_KEY_F5			5
#define GLUT_KEY_F6			6
#define GLUT_KEY_F7			7
#define GLUT_KEY_F8			8
#define GLUT_KEY_F9			9
#define GLUT_KEY_F10			10
#define GLUT_KEY_F11			11
#define GLUT_KEY_F12			12
/* directional keys */
#define GLUT_KEY_LEFT			100
#define GLUT_KEY_UP			101
#define GLUT_KEY_RIGHT			102
#define GLUT_KEY_DOWN			103
#define GLUT_KEY_PAGE_UP		104
#define GLUT_KEY_PAGE_DOWN		105
#define GLUT_KEY_HOME			106
#define GLUT_KEY_END			107
#define GLUT_KEY_INSERT			108
#endif

/* entry/exit callback state */
#define GLUT_LEFT			0
#define GLUT_ENTERED			1

/* menu usage callback state */
#define GLUT_MENU_NOT_IN_USE		0
#define GLUT_MENU_IN_USE		1

/* visibility callback state */
#define GLUT_NOT_VISIBLE		0
#define GLUT_VISIBLE			1

/* color index component selection values */
#define GLUT_RED			0
#define GLUT_GREEN			1
#define GLUT_BLUE			2

/* stroke font opaque addresses (use constants instead in source code) */
extern void *glutStrokeRoman;
extern void *glutStrokeMonoRoman;

/* stroke font constants (use these in GLUT program) */
#define GLUT_STROKE_ROMAN		(&glutStrokeRoman)
#define GLUT_STROKE_MONO_ROMAN		(&glutStrokeMonoRoman)

/* bitmap font opaque addresses (use constants instead in source code) */
extern void *glutBitmap9By15;
extern void *glutBitmap8By13;
extern void *glutBitmapTimesRoman10;
extern void *glutBitmapTimesRoman24;

/* bitmap font constants (use these in GLUT program) */
#define GLUT_BITMAP_9_BY_15		(&glutBitmap9By15)
#define GLUT_BITMAP_8_BY_13		(&glutBitmap8By13)
#define GLUT_BITMAP_TIMES_ROMAN_10	(&glutBitmapTimesRoman10)
#define GLUT_BITMAP_TIMES_ROMAN_24	(&glutBitmapTimesRoman24)

/* glutGet parameters */
#define GLUT_WINDOW_X			100
#define GLUT_WINDOW_Y			101
#define GLUT_WINDOW_WIDTH		102
#define GLUT_WINDOW_HEIGHT		103
#define GLUT_WINDOW_BUFFER_SIZE		104
#define GLUT_WINDOW_STENCIL_SIZE	105
#define GLUT_WINDOW_DEPTH_SIZE		106
#define GLUT_WINDOW_RED_SIZE		107
#define GLUT_WINDOW_GREEN_SIZE		108
#define GLUT_WINDOW_BLUE_SIZE		109
#define GLUT_WINDOW_ALPHA_SIZE		110
#define GLUT_WINDOW_ACCUM_RED_SIZE	111
#define GLUT_WINDOW_ACCUM_GREEN_SIZE	112
#define GLUT_WINDOW_ACCUM_BLUE_SIZE	113
#define GLUT_WINDOW_ACCUM_ALPHA_SIZE	114
#define GLUT_WINDOW_DOUBLEBUFFER	115
#define GLUT_WINDOW_RGBA		116
#define GLUT_WINDOW_PARENT		117
#define GLUT_WINDOW_NUM_CHILDREN	118
#define GLUT_WINDOW_COLORMAP_SIZE	119
#if (GLUT_API_VERSION >= 2)
#define GLUT_WINDOW_NUM_SAMPLES		120
#define GLUT_WINDOW_STEREO		121
#endif
#define GLUT_SCREEN_WIDTH		200
#define GLUT_SCREEN_HEIGHT		201
#define GLUT_SCREEN_WIDTH_MM		202
#define GLUT_SCREEN_HEIGHT_MM		203
#define GLUT_MENU_NUM_ITEMS		300
#define GLUT_DISPLAY_MODE_POSSIBLE	400
#define GLUT_INIT_WINDOW_X		500
#define GLUT_INIT_WINDOW_Y		501
#define GLUT_INIT_WINDOW_WIDTH		502
#define GLUT_INIT_WINDOW_HEIGHT		503
#define GLUT_INIT_DISPLAY_MODE		504
#define GLUT_ENTRY_CALLBACKS            505

#if (GLUT_API_VERSION >= 2)
#define GLUT_ELAPSED_TIME		700
#endif

#if (GLUT_API_VERSION >= 2)
/* glutDeviceGet parameters */
#define GLUT_HAS_KEYBOARD		600
#define GLUT_HAS_MOUSE			601
#define GLUT_HAS_SPACEBALL		602
#define GLUT_HAS_DIAL_AND_BUTTON_BOX	603
#define GLUT_HAS_TABLET			604
#define GLUT_NUM_MOUSE_BUTTONS		605
#define GLUT_NUM_SPACEBALL_BUTTONS	606
#define GLUT_NUM_BUTTON_BOX_BUTTONS	607
#define GLUT_NUM_DIALS			608
#define GLUT_NUM_TABLET_BUTTONS		609
#endif

/* GLUT initialization sub-API */
extern void glutInit (int *, char **);
extern void glutInitDisplayMode (unsigned long);
extern void glutInitWindowPosition (int, int);
extern void glutInitWindowSize (int, int);
extern void glutMainLoop (void);

/* GLUT window sub-api */
extern int glutCreateWindow (char *);
extern int glutCreateSubWindow (int, int, int, int, int);
extern void glutDestroyWindow (int);
extern void glutPostRedisplay (void);
extern void glutSwapBuffers (void);
extern int glutGetWindow (void);
extern void glutSetWindow (int);
extern void glutSetWindowTitle (char *);
extern void glutSetIconTitle (char *);
extern void glutPositionWindow (int, int);
extern void glutReshapeWindow (int, int);
extern void glutPopWindow (void);
extern void glutPushWindow (void);
extern void glutIconifyWindow (void);
extern void glutShowWindow (void);
extern void glutHideWindow (void);

/* GLUT menu sub-API */
extern int glutCreateMenu (void (*)(int));
extern void glutDestroyMenu (int);
extern int glutGetMenu (void);
extern void glutSetMenu (int);
extern void glutAddMenuEntry (char *, int);
extern void glutAddSubMenu (char *, int);
extern void glutChangeToMenuEntry (int, char *, int);
extern void glutChangeToSubMenu (int, char *, int);
extern void glutRemoveMenuItem (int);
extern void glutAttachMenu (int);
extern void glutDetachMenu (int);

/* GLUT callback sub-api */
extern void glutDisplayFunc (void (*)(void));
extern void glutReshapeFunc (void (*)(int, int));
extern void glutKeyboardFunc (void (*)(unsigned char, int, int));
extern void glutMouseFunc (void (*)(int, int, int, int));
extern void glutMotionFunc (void (*)(int, int));
extern void glutPassiveMotionFunc (void (*)(int, int));
extern void glutEntryFunc (void (*)(int));
extern void glutVisibilityFunc (void (*)(int));
extern void glutIdleFunc (void (*)(void));
extern void glutTimerFunc (unsigned long, void (*)(int), int);
extern void glutMenuStateFunc (void (*)(int));
#if (GLUT_API_VERSION >= 2)
extern void glutSpecialFunc (void (*)(int, int, int));
extern void glutSpaceballMotionFunc (void (*)(int, int, int));
extern void glutSpaceballRotateFunc (void (*)(int, int, int));
extern void glutSpaceballButtonFunc (void (*)(int, int));
extern void glutButtonBoxFunc (void (*)(int, int));
extern void glutDialsFunc (void (*)(int, int));
extern void glutTabletMotionFunc (void (*)(int, int));
extern void glutTabletButtonFunc (void (*)(int, int, int, int));
#endif

/* GLUT color index sub-api */
extern void glutSetColor (int, GLfloat, GLfloat, GLfloat);
extern GLfloat glutGetColor (int, int);
extern void glutCopyColormap (int);

/* GLUT state retrieval sub-api */
extern int glutGet (GLenum);
extern int glutDeviceGet (GLenum);

/* GLUT font sub-API */
extern void glutStrokeCharacter (void *, int);
extern void glutBitmapCharacter (void *, int);

/* GLUT pre-built models sub-API */
extern void glutWireSphere (GLdouble, GLint, GLint);
extern void glutSolidSphere (GLdouble, GLint, GLint);
extern void glutWireCone (GLdouble, GLdouble, GLint, GLint);
extern void glutSolidCone (GLdouble, GLdouble, GLint, GLint);
extern void glutWireCube (GLdouble);
extern void glutSolidCube (GLdouble);
extern void glutWireTorus (GLdouble, GLdouble, GLint, GLint);
extern void glutSolidTorus (GLdouble, GLdouble, GLint, GLint);
extern void glutWireDodecahedron (void);
extern void glutSolidDodecahedron (void);
extern void glutWireTeapot (GLdouble);
extern void glutSolidTeapot (GLdouble);
extern void glutWireOctahedron (void);
extern void glutSolidOctahedron (void);
extern void glutWireTetrahedron (void);
extern void glutSolidTetrahedron (void);
extern void glutWireIcosahedron (void);
extern void glutSolidIcosahedron (void);

#if (GLUT_API_VERSION >= 2)
/* GLUT extension support sub-API */
extern int glutExtensionSupported (char *);
#endif

#ifdef __cplusplus
}
#endif

#endif /* __glut_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\capxfont.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

/* capturexfont.c connects to an X server and downloads a
   bitmap font from which a C source file is generated,
   encoding  the font for GLUT's use. Example usage:
   capturexfont.c 9x15 glutBitmap9By15 > glut_9x15.c */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <GL/gl.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>

#define MAX_GLYPHS_PER_GRAB 512  /* this is big enough for 2^9
                                    glyph character sets */

static void
outputChar(int num, int width, int height,
  int xoff, int yoff, int advance, int data)
{
  printf("static BitmapCharRec ch%d = {", num);
  printf("%d,", width);
  printf("%d,", height);
  printf("(GLfloat)%d,", xoff);
  printf("(GLfloat)%d,", yoff);
  printf("(GLfloat)%d,", advance);
  if (data) {
    printf("ch%ddata", num);
  } else {
    printf("0");
  }
  printf("};\n\n");
}

/* Can't just use isprint because it only works for the range
   of ASCII characters (ie, TRUE for isascii) and capturexfont
   might be run on 16-bit fonts. */
#define PRINTABLE(ch)  (isascii(ch) ? isprint(ch) : 0)

void
captureXFont(Display * dpy, Font font, char *xfont, char *name)
{
  int first, last, count;
  int cnt, len;
  Pixmap offscreen;
  Window drawable;
  XFontStruct *fontinfo;
  XImage *image;
  GC xgc;
  XGCValues values;
  int width, height;
  int i, j, k;
  XCharStruct *charinfo;
  XChar2b character;
  GLubyte *bitmapData;
  int x, y;
  int spanLength;
  int charWidth, charHeight, maxSpanLength, pixwidth;
  int grabList[MAX_GLYPHS_PER_GRAB];
  int glyphsPerGrab = MAX_GLYPHS_PER_GRAB;
  int numToGrab;
  int rows, pages, byte1, byte2, index;

  drawable = RootWindow(dpy, DefaultScreen(dpy));

  fontinfo = XQueryFont(dpy, font);
  pages = fontinfo->max_char_or_byte2 - fontinfo->min_char_or_byte2 + 1;
  first = (fontinfo->min_byte1 << 8) + fontinfo->min_char_or_byte2;
  last = (fontinfo->max_byte1 << 8) + fontinfo->max_char_or_byte2;
  count = last - first + 1;

  width = fontinfo->max_bounds.rbearing -
    fontinfo->min_bounds.lbearing;
  height = fontinfo->max_bounds.ascent +
    fontinfo->max_bounds.descent;
  /* 16-bit fonts have more than one row; indexing into
     per_char is trickier. */
  rows = fontinfo->max_byte1 - fontinfo->min_byte1 + 1;

  maxSpanLength = (width + 7) / 8;
  /* For portability reasons we don't use alloca for
     bitmapData, but we could. */
  bitmapData = malloc(height * maxSpanLength);
  /* Be careful determining the width of the pixmap; the X
     protocol allows pixmaps of width 2^16-1 (unsigned short
     size) but drawing coordinates max out at 2^15-1 (signed
     short size).  If the width is too large, we need to limit
     the glyphs per grab. */
  if ((glyphsPerGrab * 8 * maxSpanLength) >= (1 << 15)) {
    glyphsPerGrab = (1 << 15) / (8 * maxSpanLength);
  }
  pixwidth = glyphsPerGrab * 8 * maxSpanLength;
  offscreen = XCreatePixmap(dpy, drawable, pixwidth, height, 1);

  values.font = font;
  values.background = 0;
  values.foreground = 0;
  xgc = XCreateGC(dpy, offscreen,
    GCFont | GCBackground | GCForeground, &values);
  XFillRectangle(dpy, offscreen, xgc, 0, 0,
    8 * maxSpanLength * glyphsPerGrab, height);
  XSetForeground(dpy, xgc, 1);

  numToGrab = 0;
  if (fontinfo->per_char == NULL) {
    charinfo = &(fontinfo->min_bounds);
    charWidth = charinfo->rbearing - charinfo->lbearing;
    charHeight = charinfo->ascent + charinfo->descent;
    spanLength = (charWidth + 7) / 8;
  }
  printf("\n/* GENERATED FILE -- DO NOT MODIFY */\n\n");
  printf("#include \"gltbitmp.h\"\n\n");
  for (i = first; count; i++, count--) {
    int undefined;
    if (rows == 1) {
      undefined = (fontinfo->min_char_or_byte2 > i ||
        fontinfo->max_char_or_byte2 < i);
    } else {
      byte2 = i & 0xff;
      byte1 = i >> 8;
      undefined = (fontinfo->min_char_or_byte2 > byte2 ||
        fontinfo->max_char_or_byte2 < byte2 ||
        fontinfo->min_byte1 > byte1 ||
        fontinfo->max_byte1 < byte1);

    }
    if (undefined) {
      goto PossiblyDoGrab;
    }
    if (fontinfo->per_char != NULL) {
      if (rows == 1) {
        index = i - fontinfo->min_char_or_byte2;
      } else {
        byte2 = i & 0xff;
        byte1 = i >> 8;
        index =
          (byte1 - fontinfo->min_byte1) * pages +
          (byte2 - fontinfo->min_char_or_byte2);
      }
      charinfo = &(fontinfo->per_char[index]);
      charWidth = charinfo->rbearing - charinfo->lbearing;
      charHeight = charinfo->ascent + charinfo->descent;
      if (charWidth == 0 || charHeight == 0) {
        if (charinfo->width != 0) {
          /* Still must move raster pos even if empty character 

           */
          outputChar(i, 0, 0, 0, 0, charinfo->width, 0);
        }
        goto PossiblyDoGrab;
      }
    }
    grabList[numToGrab] = i;
    character.byte2 = i & 255;
    character.byte1 = i >> 8;

    /* XXX We could use XDrawImageString16 which would also
       paint the backing rectangle but X server bugs in some
       scalable font rasterizers makes it more effective to do
       XFillRectangles to clear the pixmap and then
       XDrawImage16 for the text.  */
    XDrawString16(dpy, offscreen, xgc,
      -charinfo->lbearing + 8 * maxSpanLength * numToGrab,
      charinfo->ascent, &character, 1);

    numToGrab++;

  PossiblyDoGrab:

    if (numToGrab >= glyphsPerGrab || count == 1) {
      image = XGetImage(dpy, offscreen,
        0, 0, pixwidth, height, 1, XYPixmap);
      for (j = numToGrab - 1; j >= 0; j--) {
        if (fontinfo->per_char != NULL) {
          byte2 = grabList[j] & 0xff;
          byte1 = grabList[j] >> 8;
          index =
            (byte1 - fontinfo->min_byte1) * pages +
            (byte2 - fontinfo->min_char_or_byte2);
          charinfo = &(fontinfo->per_char[index]);
          charWidth = charinfo->rbearing - charinfo->lbearing;
          charHeight = charinfo->ascent + charinfo->descent;
          spanLength = (charWidth + 7) / 8;
        }
        memset(bitmapData, 0, height * spanLength);
        for (y = 0; y < charHeight; y++) {
          for (x = 0; x < charWidth; x++) {
            if (XGetPixel(image, j * maxSpanLength * 8 + x,
                charHeight - 1 - y)) {
              /* Little endian machines (such as DEC Alpha)
                 could  benefit from reversing the bit order
                 here and changing the GL_UNPACK_LSB_FIRST
                 parameter in glutBitmapCharacter to GL_TRUE. */
              bitmapData[y * spanLength + x / 8] |=
                (1 << (7 - (x & 7)));
            }
          }
        }
        if (PRINTABLE(grabList[j])) {
          printf("/* char: 0x%x '%c' */\n\n",
            grabList[j], grabList[j]);
        } else {
          printf("/* char: 0x%x */\n\n", grabList[j]);
        }
        printf("static GLubyte ch%ddata[] = {\n", grabList[j]);
        len = (charinfo->ascent + charinfo->descent) *
          ((charinfo->rbearing - charinfo->lbearing + 7) / 8);
        cnt = 0;
        while (cnt < len) {
          for (k = 0; k < 16 && cnt < len; k++, cnt++) {
            printf("0x%x,", bitmapData[cnt]);
          }
          printf("\n");
        }
        printf("};\n\n");
        outputChar(grabList[j], charWidth, charHeight,
          -charinfo->lbearing, charinfo->descent,
          charinfo->width, 1);
      }
      XDestroyImage(image);
      numToGrab = 0;
      if (count > 0) {
        XSetForeground(dpy, xgc, 0);
        XFillRectangle(dpy, offscreen, xgc, 0, 0,
          8 * maxSpanLength * glyphsPerGrab, height);
        XSetForeground(dpy, xgc, 1);
      }
    }
  }
  XFreeGC(dpy, xgc);
  XFreePixmap(dpy, offscreen);
  /* For portability reasons we don't use alloca for
     bitmapData, but we could. */
  free(bitmapData);

  printf("static BitmapCharPtr chars[] = {\n");
  for (i = first; i <= last; i++) {
    int undefined;
    byte2 = i & 0xff;
    byte1 = i >> 8;
    undefined = (fontinfo->min_char_or_byte2 > byte2 ||
      fontinfo->max_char_or_byte2 < byte2 ||
      fontinfo->min_byte1 > byte1 ||
      fontinfo->max_byte1 < byte1);
    if (undefined) {
      printf("0,\n");
    } else {
      if (fontinfo->per_char != NULL) {
        if (rows == 1) {
          index = i - fontinfo->min_char_or_byte2;
        } else {
          byte2 = i & 0xff;
          byte1 = i >> 8;
          index =
            (byte1 - fontinfo->min_byte1) * pages +
            (byte2 - fontinfo->min_char_or_byte2);
        }
        charinfo = &(fontinfo->per_char[index]);
        charWidth = charinfo->rbearing - charinfo->lbearing;
        charHeight = charinfo->ascent + charinfo->descent;
        if (charWidth == 0 || charHeight == 0) {
          if (charinfo->width == 0) {
            printf("0,\n");
            continue;
          }
        }
      }
      printf("&ch%d,\n", i);
    }
  }
  printf("};\n\n");
  printf("BitmapFontRec %s = {\n", name);
  printf("\"%s\",\n", xfont);
  printf("%d,\n", last - first + 1);
  printf("%d,\n", first);
  printf("chars\n");
  printf("};\n\n");
  XFreeFont(dpy, fontinfo);
}

int
main(int argc, char **argv)
{
  Display *dpy;
  Font font;

  if (argc != 3) {
    fprintf(stderr, "usage: bagxfont XFONT NAME\n");
    exit(1);
  }
  dpy = XOpenDisplay(NULL);
  if (dpy == NULL) {
    fprintf(stderr, "bagxfont: could not open X display\n");
    exit(1);
  }
  font = XLoadFont(dpy, argv[1]);
  if (font == None) {
    fprintf(stderr, "bagxfont: bad font\n");
    exit(1);
  }
  captureXFont(dpy, font, argv[1], argv[2]);
  XCloseDisplay(dpy);
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\gldd\single\ddwave.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>

#include <gldd.h>
#include <gl/glu.h>


#pragma warning(disable:4244)

#define PI 3.14159265358979323846

#define GETCOORD(frame, x, y) (&(theMesh.coords[frame*theMesh.numCoords+(x)+(y)*(theMesh.widthX+1)]))
#define GETFACET(frame, x, y) (&(theMesh.facets[frame*theMesh.numFacets+(x)+(y)*theMesh.widthX]))


GLenum rgb, doubleBuffer, directRender;
GLenum videoMemory, noSwap, noClear, fullScreen, useMcd, modeX;
int fullWidth, fullHeight, fullDepth;

GLint colorIndexes1[3];
GLint colorIndexes2[3];
GLenum clearMask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;

GLenum smooth = GL_TRUE;
GLenum lighting = GL_TRUE;
GLenum depth = GL_TRUE;
GLenum stepMode = GL_FALSE;
GLenum spinMode = GL_FALSE;
GLint contouring = 0;

GLint widthX, widthY;
GLint checkerSize;
float height;

GLint frames, curFrame = 0, nextFrame = 0;
GLboolean displayFrameRate = GL_FALSE;
static GLint frameCount = 0;

struct facet {
    float color[3];
    float normal[3];
};
struct coord {
    float vertex[3];
    float normal[3];
};
struct mesh {
    GLint widthX, widthY;
    GLint numFacets;
    GLint numCoords;
    GLint frames;
    struct coord *coords;
    struct facet *facets;
} theMesh;

GLubyte contourTexture1[] = {
    255, 255, 255, 255,
    255, 255, 255, 255,
    255, 255, 255, 255,
    127, 127, 127, 127,
};
GLubyte contourTexture2[] = {
    255, 255, 255, 255,
    255, 127, 127, 127,
    255, 127, 127, 127,
    255, 127, 127, 127,
};

GLDDWINDOW gwMain = NULL;

void Quit(void)
{
    if (gwMain != NULL)
    {
        glddDestroyWindow(gwMain);
    }
    exit(1);
}

static void Animate(GLDDWINDOW gw)
{
    struct coord *coord;
    struct facet *facet;
    float *lastColor;
    float *thisColor;
    GLint i, j;
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    if (!noClear)
    {
        glClear(clearMask);
    }

    if (nextFrame || !stepMode) {
	curFrame++;
    }

    if (curFrame >= theMesh.frames) {
	// mf: do frame rate calcs here
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += theMesh.frames;

	curFrame = 0;
    }

    if ((nextFrame || !stepMode) && spinMode) {
	glRotatef(5.0, 0.0, 0.0, 1.0);
    }
    nextFrame = 0;

    for (i = 0; i < theMesh.widthX; i++) {
	glBegin(GL_QUAD_STRIP);
	lastColor = NULL;
	for (j = 0; j < theMesh.widthY; j++) {
	    facet = GETFACET(curFrame, i, j);
	    if (!smooth && lighting) {
		glNormal3fv(facet->normal);
	    }
	    if (lighting) {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, 
				 facet->color);
		}
	    } else {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glIndexf(facet->color[1]);
		}
	    }

	    if (!lastColor || (thisColor[0] != lastColor[0] && smooth)) {
		if (lastColor) {
		    glEnd();
		    glBegin(GL_QUAD_STRIP);
		}
		coord = GETCOORD(curFrame, i, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);

		coord = GETCOORD(curFrame, i+1, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);
	    }

	    coord = GETCOORD(curFrame, i, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    coord = GETCOORD(curFrame, i+1, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    lastColor = thisColor;
	}
	glEnd();
    }

    glFlush();
    if (doubleBuffer && !noSwap) {
	glddSwapBuffers(gw);
    }
}

static void InitMesh(void)
{
    struct coord *coord;
    struct facet *facet;
    float dp1[3], dp2[3];
    float *pt1, *pt2, *pt3;
    float angle, d, x, y;
    GLint numFacets, numCoords, frameNum, i, j;

    theMesh.widthX = widthX;
    theMesh.widthY = widthY;
    theMesh.frames = frames;

    numFacets = widthX * widthY;
    numCoords = (widthX + 1) * (widthY + 1);

    theMesh.numCoords = numCoords;
    theMesh.numFacets = numFacets;

    theMesh.coords = (struct coord *)malloc(frames*numCoords*
					    sizeof(struct coord));
    theMesh.facets = (struct facet *)malloc(frames*numFacets*
					    sizeof(struct facet));
    if (theMesh.coords == NULL || theMesh.facets == NULL) {
	printf("Out of memory.\n");
	exit(1);
    }

    for (frameNum = 0; frameNum < frames; frameNum++) {
	for (i = 0; i <= widthX; i++) {
	    x = i / (float)widthX;
	    for (j = 0; j <= widthY; j++) {
		y = j / (float)widthY;

		d = sqrt(x*x+y*y);
		if (d == 0.0) {
		    d = 0.0001;
		}
		angle = 2 * PI * d + (2 * PI / frames * frameNum);

		coord = GETCOORD(frameNum, i, j);

		coord->vertex[0] = x - 0.5;
		coord->vertex[1] = y - 0.5;
		coord->vertex[2] = (height - height * d) * cos(angle);

		coord->normal[0] = -(height / d) * x * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[1] = -(height / d) * y * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[2] = -1;

		d = 1.0 / sqrt(coord->normal[0]*coord->normal[0]+
			       coord->normal[1]*coord->normal[1]+1);
		coord->normal[0] *= d;
		coord->normal[1] *= d;
		coord->normal[2] *= d;
	    }
	}
	for (i = 0; i < widthX; i++) {
	    for (j = 0; j < widthY; j++) {
		facet = GETFACET(frameNum, i, j);
		if (((i/checkerSize)%2)^(j/checkerSize)%2) {
		    if (rgb) {
			facet->color[0] = 1.0;
			facet->color[1] = 0.2;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes1[0];
			facet->color[1] = colorIndexes1[1];
			facet->color[2] = colorIndexes1[2];
		    }
		} else {
		    if (rgb) {
			facet->color[0] = 0.2;
			facet->color[1] = 1.0;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes2[0];
			facet->color[1] = colorIndexes2[1];
			facet->color[2] = colorIndexes2[2];
		    }
		}
		pt1 = GETCOORD(frameNum, i, j)->vertex;
		pt2 = GETCOORD(frameNum, i, j+1)->vertex;
		pt3 = GETCOORD(frameNum, i+1, j+1)->vertex;

		dp1[0] = pt2[0] - pt1[0];
		dp1[1] = pt2[1] - pt1[1];
		dp1[2] = pt2[2] - pt1[2];

		dp2[0] = pt3[0] - pt2[0];
		dp2[1] = pt3[1] - pt2[1];
		dp2[2] = pt3[2] - pt2[2];

		facet->normal[0] = dp1[1] * dp2[2] - dp1[2] * dp2[1];
		facet->normal[1] = dp1[2] * dp2[0] - dp1[0] * dp2[2];
		facet->normal[2] = dp1[0] * dp2[1] - dp1[1] * dp2[0];

		d = 1.0 / sqrt(facet->normal[0]*facet->normal[0]+
			       facet->normal[1]*facet->normal[1]+
			       facet->normal[2]*facet->normal[2]);

		facet->normal[0] *= d;
		facet->normal[1] *= d;
		facet->normal[2] *= d;
	    }
	}
    }
}

static void InitMaterials(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {60.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {60.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};

    glMatrixMode(GL_PROJECTION);
    gluPerspective(450, 1.0, 0.5, 10.0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    if (rgb) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    }

    if (rgb) {
	glEnable(GL_COLOR_MATERIAL);
    } else {
        Quit();
    }
}

static void InitTexture(void)
{

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}

static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    if (smooth) {
        glShadeModel(GL_SMOOTH);
    } else {
        glShadeModel(GL_FLAT);
    }
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    InitMaterials();
    InitTexture();
    InitMesh();

    glMatrixMode(GL_MODELVIEW);
    glTranslatef(0.0, 0.4, -1.8);
    glScalef(2.0, 2.0, 2.0);
    glRotatef(-35.0, 1.0, 0.0, 0.0);
    glRotatef(35.0, 0.0, 0.0, 1.0);
}

static GLenum Key(UINT key)
{
    switch (key) {
      case VK_ESCAPE:
	Quit();
      case 'C':
	contouring++;
	if (contouring == 1) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexImage2D(GL_TEXTURE_2D, 0, 3, 4, 4, 0, GL_LUMINANCE,
			 GL_UNSIGNED_BYTE, (GLvoid *)contourTexture1);
	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGenfv(GL_S, GL_OBJECT_PLANE, map);
	    glTexGenfv(GL_T, GL_OBJECT_PLANE, map);
	    glEnable(GL_TEXTURE_2D);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else if (contouring == 2) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glPushMatrix();
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	    glTexGenfv(GL_S, GL_EYE_PLANE, map);
	    glTexGenfv(GL_T, GL_EYE_PLANE, map);
	    glPopMatrix();
	} else {
	    contouring = 0;
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	    glDisable(GL_TEXTURE_2D);
	}
	break;
      case 'S':
	smooth = !smooth;
	if (smooth) {
	    glShadeModel(GL_SMOOTH);
	} else {
	    glShadeModel(GL_FLAT);
	}
	break;
      case 'L':
	lighting = !lighting;
	if (lighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
	    if (rgb) {
		glEnable(GL_COLOR_MATERIAL);
	    }
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
	    if (rgb) {
		glDisable(GL_COLOR_MATERIAL);
	    }
	}
	break;
      case 'D':
	depth = !depth;
	if (depth) {
	    glEnable(GL_DEPTH_TEST);
	    clearMask |= GL_DEPTH_BUFFER_BIT;
	} else {
	    glDisable(GL_DEPTH_TEST);
	    clearMask &= ~GL_DEPTH_BUFFER_BIT;
	}
	break;
      case VK_SPACE:
	stepMode = !stepMode;
	if (stepMode) {
	    glddIdleCallback(gwMain, 0);
	} else {
	    glddIdleCallback(gwMain, Animate);
	}
	break;
      case 'N':
	if (stepMode) {
	    nextFrame = 1;
	}
	break;
      case 'F':
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case 'A':
	spinMode = !spinMode;
	break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

BOOL Message(GLDDWINDOW gw, HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm,
             LRESULT *plr)
{
    switch(uiMsg)
    {
    case WM_KEYDOWN:
        Key((UINT)wpm);
        break;

    default:
        return FALSE;
    }

    *plr = 0;
    return TRUE;
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;
    directRender = GL_FALSE;
    videoMemory = GL_FALSE;
    noSwap = GL_FALSE;
    noClear = GL_FALSE;
    fullScreen = GL_FALSE;
    fullWidth = 640;
    fullHeight = 480;
    fullDepth = 16;
    useMcd = GL_FALSE;
    modeX = GL_FALSE;

    frames = 10;
    widthX = 10;
    widthY = 10;
    checkerSize = 2;
    height = 0.2;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-vm") == 0) {
	    videoMemory = GL_TRUE;
	} else if (strcmp(argv[i], "-noswap") == 0) {
	    noSwap = GL_TRUE;
	} else if (strcmp(argv[i], "-noclear") == 0) {
	    noClear = GL_TRUE;
	} else if (strcmp(argv[i], "-full") == 0) {
	    fullScreen = GL_TRUE;
	} else if (strcmp(argv[i], "-modex") == 0) {
	    modeX = GL_TRUE;
	    fullWidth = 320;
	    fullHeight = 240;
	    fullDepth = 8;
	} else if (strcmp(argv[i], "-mcd") == 0) {
	    useMcd = GL_TRUE;
	} else if (strcmp(argv[i], "-fdim") == 0) {
            if (i+3 >= argc ||
                argv[i+1][0] == '-' ||
                argv[i+2][0] == '-' ||
                argv[i+3][0] == '-')
            {
                printf("-fdim (No numbers).\n");
                return GL_FALSE;
            }
            else
            {
                fullWidth = atoi(argv[++i]);
                fullHeight = atoi(argv[++i]);
                fullDepth = atoi(argv[++i]);
            }
	} else if (strcmp(argv[i], "-grid") == 0) {
	    if (i+2 >= argc || argv[i+1][0] == '-' || argv[i+2][0] == '-') {
		printf("-grid (No numbers).\n");
		return GL_FALSE;
	    } else {
		widthX = atoi(argv[++i]);
		widthY = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-size") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-checker (No number).\n");
		return GL_FALSE;
	    } else {
		checkerSize = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-wave") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-wave (No number).\n");
		return GL_FALSE;
	    } else {
		height = atof(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-frames") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-frames (No number).\n");
		return GL_FALSE;
	    } else {
		frames = atoi(argv[++i]);
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void __cdecl main(int argc, char **argv)
{
    DWORD dwFlags;
    GLDDWINDOW gw;
    int iWidth, iHeight;

    if (Args(argc, argv) == GL_FALSE) {
	exit(1);
    }

    dwFlags = GLDD_Z_BUFFER_16;
    dwFlags |= doubleBuffer ? GLDD_BACK_BUFFER : 0;
    dwFlags |= videoMemory ? GLDD_VIDEO_MEMORY : 0;
    dwFlags |= useMcd ? GLDD_GENERIC_ACCELERATED : 0;
    if (fullScreen)
    {
        dwFlags |= GLDD_FULL_SCREEN;
	dwFlags |= modeX ? GLDD_USE_MODE_X : 0;
        iWidth = fullWidth;
        iHeight = fullHeight;
    }
    else
    {
        iWidth = 320;
        iHeight = 320;
    }

    gw = glddCreateWindow("Wave Demo", 10, 30, iWidth, iHeight, fullDepth,
                          dwFlags);
    if (gw == NULL)
    {
        printf("glddCreateWindow failed with 0x%08lX\n", glddGetLastError());
        exit(1);
    }
    gwMain = gw;

    glddMakeCurrent(gw);
    
    Init();

    glddIdleCallback(gw, Animate);
    glddMessageCallback(gw, Message);
    glddRun(gw);
    glddDestroyWindow(gw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glt8x13.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltbitmp.h"

static BitmapCharRec ch0 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)8,0};

static BitmapCharRec ch32 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)8,0};

static BitmapCharRec ch127 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)8,0};

static BitmapCharRec ch160 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)8,0};

/* char: 255 */

static GLubyte ch255data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,0x0,0x0,0x48,0x48,
};

static BitmapCharRec ch255 = {6,12,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch255data};

/* char: 254 */

static GLubyte ch254data[] = {
0x80,0x80,0xb8,0xc4,0x84,0x84,0xc4,0xb8,0x80,0x80,
};

static BitmapCharRec ch254 = {6,10,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch254data};

/* char: 253 */

static GLubyte ch253data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,0x0,0x0,0x20,0x10,
};

static BitmapCharRec ch253 = {6,12,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch253data};

/* char: 252 */

static GLubyte ch252data[] = {
0x74,0x88,0x88,0x88,0x88,0x88,0x0,0x0,0x48,0x48,
};

static BitmapCharRec ch252 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch252data};

/* char: 251 */

static GLubyte ch251data[] = {
0x74,0x88,0x88,0x88,0x88,0x88,0x0,0x0,0x48,0x30,
};

static BitmapCharRec ch251 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch251data};

/* char: 250 */

static GLubyte ch250data[] = {
0x74,0x88,0x88,0x88,0x88,0x88,0x0,0x0,0x20,0x10,
};

static BitmapCharRec ch250 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch250data};

/* char: 249 */

static GLubyte ch249data[] = {
0x74,0x88,0x88,0x88,0x88,0x88,0x0,0x0,0x10,0x20,
};

static BitmapCharRec ch249 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch249data};

/* char: 248 */

static GLubyte ch248data[] = {
0x80,0x78,0xc4,0xa4,0x94,0x8c,0x78,0x4,
};

static BitmapCharRec ch248 = {6,8,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch248data};

/* char: 247 */

static GLubyte ch247data[] = {
0x20,0x20,0x0,0xf8,0x0,0x20,0x20,
};

static BitmapCharRec ch247 = {5,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch247data};

/* char: 246 */

static GLubyte ch246data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x0,0x0,0x48,0x48,
};

static BitmapCharRec ch246 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch246data};

/* char: 245 */

static GLubyte ch245data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch245 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch245data};

/* char: 244 */

static GLubyte ch244data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x0,0x0,0x48,0x30,
};

static BitmapCharRec ch244 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch244data};

/* char: 243 */

static GLubyte ch243data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x0,0x0,0x20,0x10,
};

static BitmapCharRec ch243 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch243data};

/* char: 242 */

static GLubyte ch242data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x0,0x0,0x10,0x20,
};

static BitmapCharRec ch242 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch242data};

/* char: 241 */

static GLubyte ch241data[] = {
0x84,0x84,0x84,0x84,0xc4,0xb8,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch241 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch241data};

/* char: 240 */

static GLubyte ch240data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,0x8,0x50,0x30,0x48,
};

static BitmapCharRec ch240 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch240data};

/* char: 239 */

static GLubyte ch239data[] = {
0xf8,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x50,0x50,
};

static BitmapCharRec ch239 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch239data};

/* char: 238 */

static GLubyte ch238data[] = {
0xf8,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x90,0x60,
};

static BitmapCharRec ch238 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch238data};

/* char: 237 */

static GLubyte ch237data[] = {
0xf8,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x40,0x20,
};

static BitmapCharRec ch237 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch237data};

/* char: 236 */

static GLubyte ch236data[] = {
0xf8,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x20,0x40,
};

static BitmapCharRec ch236 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch236data};

/* char: 235 */

static GLubyte ch235data[] = {
0x78,0x84,0x80,0xfc,0x84,0x78,0x0,0x0,0x48,0x48,
};

static BitmapCharRec ch235 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch235data};

/* char: 234 */

static GLubyte ch234data[] = {
0x78,0x84,0x80,0xfc,0x84,0x78,0x0,0x0,0x48,0x30,
};

static BitmapCharRec ch234 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch234data};

/* char: 233 */

static GLubyte ch233data[] = {
0x78,0x84,0x80,0xfc,0x84,0x78,0x0,0x0,0x20,0x10,
};

static BitmapCharRec ch233 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch233data};

/* char: 232 */

static GLubyte ch232data[] = {
0x78,0x84,0x80,0xfc,0x84,0x78,0x0,0x0,0x10,0x20,
};

static BitmapCharRec ch232 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch232data};

/* char: 231 */

static GLubyte ch231data[] = {
0x20,0x10,0x78,0x84,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch231 = {6,8,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch231data};

/* char: 230 */

static GLubyte ch230data[] = {
0x6c,0x92,0x90,0x7c,0x12,0x6c,
};

static BitmapCharRec ch230 = {7,6,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch230data};

/* char: 229 */

static GLubyte ch229data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x30,0x48,0x30,
};

static BitmapCharRec ch229 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch229data};

/* char: 228 */

static GLubyte ch228data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x0,0x48,0x48,
};

static BitmapCharRec ch228 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch228data};

/* char: 227 */

static GLubyte ch227data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch227 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch227data};

/* char: 226 */

static GLubyte ch226data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x0,0x48,0x30,
};

static BitmapCharRec ch226 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch226data};

/* char: 225 */

static GLubyte ch225data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x0,0x20,0x10,
};

static BitmapCharRec ch225 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch225data};

/* char: 224 */

static GLubyte ch224data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,0x0,0x0,0x10,0x20,
};

static BitmapCharRec ch224 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch224data};

/* char: 223 */

static GLubyte ch223data[] = {
0x80,0xb8,0xc4,0x84,0x84,0xf8,0x84,0x84,0x78,
};

static BitmapCharRec ch223 = {6,9,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch223data};

/* char: 222 */

static GLubyte ch222data[] = {
0x80,0x80,0x80,0xf8,0x84,0x84,0x84,0xf8,0x80,
};

static BitmapCharRec ch222 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch222data};

/* char: 221 */

static GLubyte ch221data[] = {
0x20,0x20,0x20,0x20,0x50,0x88,0x88,0x0,0x20,0x10,
};

static BitmapCharRec ch221 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch221data};

/* char: 220 */

static GLubyte ch220data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x48,0x48,
};

static BitmapCharRec ch220 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch220data};

/* char: 219 */

static GLubyte ch219data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x48,0x30,
};

static BitmapCharRec ch219 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch219data};

/* char: 218 */

static GLubyte ch218data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x20,0x10,
};

static BitmapCharRec ch218 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch218data};

/* char: 217 */

static GLubyte ch217data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x10,0x20,
};

static BitmapCharRec ch217 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch217data};

/* char: 216 */

static GLubyte ch216data[] = {
0x80,0x78,0xc4,0xa4,0xa4,0xa4,0x94,0x94,0x8c,0x78,0x4,
};

static BitmapCharRec ch216 = {6,11,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch216data};

/* char: 215 */

static GLubyte ch215data[] = {
0x84,0x48,0x30,0x30,0x48,0x84,
};

static BitmapCharRec ch215 = {6,6,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch215data};

/* char: 214 */

static GLubyte ch214data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x28,0x28,
};

static BitmapCharRec ch214 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch214data};

/* char: 213 */

static GLubyte ch213data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x28,0x14,
};

static BitmapCharRec ch213 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch213data};

/* char: 212 */

static GLubyte ch212data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x24,0x18,
};

static BitmapCharRec ch212 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch212data};

/* char: 211 */

static GLubyte ch211data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x10,0x8,
};

static BitmapCharRec ch211 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch211data};

/* char: 210 */

static GLubyte ch210data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x8,0x10,
};

static BitmapCharRec ch210 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch210data};

/* char: 209 */

static GLubyte ch209data[] = {
0x82,0x86,0x8a,0x92,0xa2,0xc2,0x82,0x0,0x28,0x14,
};

static BitmapCharRec ch209 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch209data};

/* char: 208 */

static GLubyte ch208data[] = {
0xfc,0x42,0x42,0x42,0xe2,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch208 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch208data};

/* char: 207 */

static GLubyte ch207data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x50,0x50,
};

static BitmapCharRec ch207 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch207data};

/* char: 206 */

static GLubyte ch206data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x48,0x30,
};

static BitmapCharRec ch206 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch206data};

/* char: 205 */

static GLubyte ch205data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x20,0x10,
};

static BitmapCharRec ch205 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch205data};

/* char: 204 */

static GLubyte ch204data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x10,0x20,
};

static BitmapCharRec ch204 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch204data};

/* char: 203 */

static GLubyte ch203data[] = {
0xfc,0x80,0x80,0xf0,0x80,0x80,0xfc,0x0,0x48,0x48,
};

static BitmapCharRec ch203 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch203data};

/* char: 202 */

static GLubyte ch202data[] = {
0xfc,0x80,0x80,0xf0,0x80,0x80,0xfc,0x0,0x48,0x30,
};

static BitmapCharRec ch202 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch202data};

/* char: 201 */

static GLubyte ch201data[] = {
0xfc,0x80,0x80,0xf0,0x80,0x80,0xfc,0x0,0x20,0x10,
};

static BitmapCharRec ch201 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch201data};

/* char: 200 */

static GLubyte ch200data[] = {
0xfc,0x80,0x80,0xf0,0x80,0x80,0xfc,0x0,0x10,0x20,
};

static BitmapCharRec ch200 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch200data};

/* char: 199 */

static GLubyte ch199data[] = {
0x20,0x10,0x78,0x84,0x80,0x80,0x80,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch199 = {6,11,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch199data};

/* char: 198 */

static GLubyte ch198data[] = {
0x9e,0x90,0x90,0xf0,0x9c,0x90,0x90,0x90,0x6e,
};

static BitmapCharRec ch198 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch198data};

/* char: 197 */

static GLubyte ch197data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x30,0x48,0x30,
};

static BitmapCharRec ch197 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch197data};

/* char: 196 */

static GLubyte ch196data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x0,0x48,0x48,
};

static BitmapCharRec ch196 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch196data};

/* char: 195 */

static GLubyte ch195data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x0,0x50,0x28,
};

static BitmapCharRec ch195 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch195data};

/* char: 194 */

static GLubyte ch194data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x0,0x48,0x30,
};

static BitmapCharRec ch194 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch194data};

/* char: 193 */

static GLubyte ch193data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x0,0x20,0x10,
};

static BitmapCharRec ch193 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch193data};

/* char: 192 */

static GLubyte ch192data[] = {
0x84,0x84,0xfc,0x84,0x84,0x48,0x30,0x0,0x10,0x20,
};

static BitmapCharRec ch192 = {6,10,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch192data};

/* char: 191 */

static GLubyte ch191data[] = {
0x78,0x84,0x84,0x80,0x40,0x20,0x20,0x0,0x20,
};

static BitmapCharRec ch191 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch191data};

/* char: 190 */

static GLubyte ch190data[] = {
0x6,0x1a,0x12,0xa,0x66,0x92,0x10,0x20,0x90,0x60,
};

static BitmapCharRec ch190 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch190data};

/* char: 189 */

static GLubyte ch189data[] = {
0x1e,0x10,0xc,0x2,0xf2,0x4c,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch189 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch189data};

/* char: 188 */

static GLubyte ch188data[] = {
0x6,0x1a,0x12,0xa,0xe6,0x42,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch188 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch188data};

/* char: 187 */

static GLubyte ch187data[] = {
0x90,0x48,0x24,0x12,0x24,0x48,0x90,
};

static BitmapCharRec ch187 = {7,7,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch187data};

/* char: 186 */

static GLubyte ch186data[] = {
0xf0,0x0,0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch186 = {4,6,(GLfloat)-1,(GLfloat)-3,(GLfloat)8,ch186data};

/* char: 185 */

static GLubyte ch185data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch185 = {3,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)8,ch185data};

/* char: 184 */

static GLubyte ch184data[] = {
0xc0,0x40,
};

static BitmapCharRec ch184 = {2,2,(GLfloat)-3,(GLfloat)2,(GLfloat)8,ch184data};

/* char: 183 */

static GLubyte ch183data[] = {
0xc0,
};

static BitmapCharRec ch183 = {2,1,(GLfloat)-3,(GLfloat)-4,(GLfloat)8,ch183data};

/* char: 182 */

static GLubyte ch182data[] = {
0x28,0x28,0x28,0x28,0x68,0xe8,0xe8,0xe8,0x7c,
};

static BitmapCharRec ch182 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch182data};

/* char: 181 */

static GLubyte ch181data[] = {
0x80,0xb4,0xcc,0x84,0x84,0x84,0x84,
};

static BitmapCharRec ch181 = {6,7,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch181data};

/* char: 180 */

static GLubyte ch180data[] = {
0x80,0x40,
};

static BitmapCharRec ch180 = {2,2,(GLfloat)-3,(GLfloat)-8,(GLfloat)8,ch180data};

/* char: 179 */

static GLubyte ch179data[] = {
0x60,0x90,0x10,0x20,0x90,0x60,
};

static BitmapCharRec ch179 = {4,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)8,ch179data};

/* char: 178 */

static GLubyte ch178data[] = {
0xf0,0x80,0x60,0x10,0x90,0x60,
};

static BitmapCharRec ch178 = {4,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)8,ch178data};

/* char: 177 */

static GLubyte ch177data[] = {
0xf8,0x0,0x20,0x20,0xf8,0x20,0x20,
};

static BitmapCharRec ch177 = {5,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch177data};

/* char: 176 */

static GLubyte ch176data[] = {
0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch176 = {4,4,(GLfloat)-2,(GLfloat)-5,(GLfloat)8,ch176data};

/* char: 175 */

static GLubyte ch175data[] = {
0xfc,
};

static BitmapCharRec ch175 = {6,1,(GLfloat)-1,(GLfloat)-8,(GLfloat)8,ch175data};

/* char: 174 */

static GLubyte ch174data[] = {
0x38,0x44,0xaa,0xb2,0xaa,0xaa,0x92,0x44,0x38,
};

static BitmapCharRec ch174 = {7,9,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch174data};

/* char: 173 */

static GLubyte ch173data[] = {
0xfc,
};

static BitmapCharRec ch173 = {6,1,(GLfloat)-1,(GLfloat)-4,(GLfloat)8,ch173data};

/* char: 172 */

static GLubyte ch172data[] = {
0x4,0x4,0x4,0xfc,
};

static BitmapCharRec ch172 = {6,4,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch172data};

/* char: 171 */

static GLubyte ch171data[] = {
0x12,0x24,0x48,0x90,0x48,0x24,0x12,
};

static BitmapCharRec ch171 = {7,7,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch171data};

/* char: 170 */

static GLubyte ch170data[] = {
0xf8,0x0,0x78,0x88,0x78,0x8,0x70,
};

static BitmapCharRec ch170 = {5,7,(GLfloat)-1,(GLfloat)-2,(GLfloat)8,ch170data};

/* char: 169 */

static GLubyte ch169data[] = {
0x38,0x44,0x92,0xaa,0xa2,0xaa,0x92,0x44,0x38,
};

static BitmapCharRec ch169 = {7,9,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch169data};

/* char: 168 */

static GLubyte ch168data[] = {
0xd8,
};

static BitmapCharRec ch168 = {5,1,(GLfloat)-1,(GLfloat)-8,(GLfloat)8,ch168data};

/* char: 167 */

static GLubyte ch167data[] = {
0x60,0x90,0x10,0x60,0x90,0x90,0x60,0x80,0x90,0x60,
};

static BitmapCharRec ch167 = {4,10,(GLfloat)-2,(GLfloat)0,(GLfloat)8,ch167data};

/* char: 166 */

static GLubyte ch166data[] = {
0x80,0x80,0x80,0x80,0x0,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch166 = {1,9,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch166data};

/* char: 165 */

static GLubyte ch165data[] = {
0x10,0x10,0x7c,0x10,0x7c,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch165 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch165data};

/* char: 164 */

static GLubyte ch164data[] = {
0x84,0x78,0x48,0x48,0x78,0x84,
};

static BitmapCharRec ch164 = {6,6,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch164data};

/* char: 163 */

static GLubyte ch163data[] = {
0xdc,0x62,0x20,0x20,0x20,0x70,0x20,0x22,0x1c,
};

static BitmapCharRec ch163 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch163data};

/* char: 162 */

static GLubyte ch162data[] = {
0x20,0x70,0xa8,0xa0,0xa0,0xa8,0x70,0x20,
};

static BitmapCharRec ch162 = {5,8,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch162data};

/* char: 161 */

static GLubyte ch161data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x0,0x80,
};

static BitmapCharRec ch161 = {1,9,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch161data};

/* char: 126 '~' */

static GLubyte ch126data[] = {
0x90,0xa8,0x48,
};

static BitmapCharRec ch126 = {5,3,(GLfloat)-1,(GLfloat)-6,(GLfloat)8,ch126data};

/* char: 125 '}' */

static GLubyte ch125data[] = {
0xe0,0x10,0x10,0x20,0x18,0x20,0x10,0x10,0xe0,
};

static BitmapCharRec ch125 = {5,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch125data};

/* char: 124 '|' */

static GLubyte ch124data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch124 = {1,9,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch124data};

/* char: 123 '{' */

static GLubyte ch123data[] = {
0x38,0x40,0x40,0x20,0xc0,0x20,0x40,0x40,0x38,
};

static BitmapCharRec ch123 = {5,9,(GLfloat)-2,(GLfloat)0,(GLfloat)8,ch123data};

/* char: 122 'z' */

static GLubyte ch122data[] = {
0xfc,0x40,0x20,0x10,0x8,0xfc,
};

static BitmapCharRec ch122 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch122data};

/* char: 121 'y' */

static GLubyte ch121data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,
};

static BitmapCharRec ch121 = {6,8,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch121data};

/* char: 120 'x' */

static GLubyte ch120data[] = {
0x84,0x48,0x30,0x30,0x48,0x84,
};

static BitmapCharRec ch120 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch120data};

/* char: 119 'w' */

static GLubyte ch119data[] = {
0x44,0xaa,0x92,0x92,0x82,0x82,
};

static BitmapCharRec ch119 = {7,6,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch119data};

/* char: 118 'v' */

static GLubyte ch118data[] = {
0x20,0x50,0x50,0x88,0x88,0x88,
};

static BitmapCharRec ch118 = {5,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch118data};

/* char: 117 'u' */

static GLubyte ch117data[] = {
0x74,0x88,0x88,0x88,0x88,0x88,
};

static BitmapCharRec ch117 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch117data};

/* char: 116 't' */

static GLubyte ch116data[] = {
0x38,0x44,0x40,0x40,0x40,0xf8,0x40,0x40,
};

static BitmapCharRec ch116 = {6,8,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch116data};

/* char: 115 's' */

static GLubyte ch115data[] = {
0x78,0x84,0x18,0x60,0x84,0x78,
};

static BitmapCharRec ch115 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch115data};

/* char: 114 'r' */

static GLubyte ch114data[] = {
0x40,0x40,0x40,0x40,0x44,0xb8,
};

static BitmapCharRec ch114 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch114data};

/* char: 113 'q' */

static GLubyte ch113data[] = {
0x4,0x4,0x4,0x74,0x8c,0x84,0x8c,0x74,
};

static BitmapCharRec ch113 = {6,8,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch113data};

/* char: 112 'p' */

static GLubyte ch112data[] = {
0x80,0x80,0x80,0xb8,0xc4,0x84,0xc4,0xb8,
};

static BitmapCharRec ch112 = {6,8,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch112data};

/* char: 111 'o' */

static GLubyte ch111data[] = {
0x78,0x84,0x84,0x84,0x84,0x78,
};

static BitmapCharRec ch111 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch111data};

/* char: 110 'n' */

static GLubyte ch110data[] = {
0x84,0x84,0x84,0x84,0xc4,0xb8,
};

static BitmapCharRec ch110 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch110data};

/* char: 109 'm' */

static GLubyte ch109data[] = {
0x82,0x92,0x92,0x92,0x92,0xec,
};

static BitmapCharRec ch109 = {7,6,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch109data};

/* char: 108 'l' */

static GLubyte ch108data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x60,
};

static BitmapCharRec ch108 = {5,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch108data};

/* char: 107 'k' */

static GLubyte ch107data[] = {
0x84,0x88,0x90,0xe0,0x90,0x88,0x80,0x80,0x80,
};

static BitmapCharRec ch107 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch107data};

/* char: 106 'j' */

static GLubyte ch106data[] = {
0x70,0x88,0x88,0x8,0x8,0x8,0x8,0x18,0x0,0x8,
};

static BitmapCharRec ch106 = {5,10,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch106data};

/* char: 105 'i' */

static GLubyte ch105data[] = {
0xf8,0x20,0x20,0x20,0x20,0x60,0x0,0x20,
};

static BitmapCharRec ch105 = {5,8,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch105data};

/* char: 104 'h' */

static GLubyte ch104data[] = {
0x84,0x84,0x84,0x84,0xc4,0xb8,0x80,0x80,0x80,
};

static BitmapCharRec ch104 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch104data};

/* char: 103 'g' */

static GLubyte ch103data[] = {
0x78,0x84,0x78,0x80,0x70,0x88,0x88,0x74,
};

static BitmapCharRec ch103 = {6,8,(GLfloat)-1,(GLfloat)2,(GLfloat)8,ch103data};

/* char: 102 'f' */

static GLubyte ch102data[] = {
0x40,0x40,0x40,0x40,0xf8,0x40,0x40,0x44,0x38,
};

static BitmapCharRec ch102 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch102data};

/* char: 101 'e' */

static GLubyte ch101data[] = {
0x78,0x84,0x80,0xfc,0x84,0x78,
};

static BitmapCharRec ch101 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch101data};

/* char: 100 'd' */

static GLubyte ch100data[] = {
0x74,0x8c,0x84,0x84,0x8c,0x74,0x4,0x4,0x4,
};

static BitmapCharRec ch100 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch100data};

/* char: 99 'c' */

static GLubyte ch99data[] = {
0x78,0x84,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch99 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch99data};

/* char: 98 'b' */

static GLubyte ch98data[] = {
0xb8,0xc4,0x84,0x84,0xc4,0xb8,0x80,0x80,0x80,
};

static BitmapCharRec ch98 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch98data};

/* char: 97 'a' */

static GLubyte ch97data[] = {
0x74,0x8c,0x84,0x7c,0x4,0x78,
};

static BitmapCharRec ch97 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch97data};

/* char: 96 '`' */

static GLubyte ch96data[] = {
0x10,0x60,0xe0,
};

static BitmapCharRec ch96 = {4,3,(GLfloat)-2,(GLfloat)-6,(GLfloat)8,ch96data};

/* char: 95 '_' */

static GLubyte ch95data[] = {
0xfe,
};

static BitmapCharRec ch95 = {7,1,(GLfloat)0,(GLfloat)1,(GLfloat)8,ch95data};

/* char: 94 '^' */

static GLubyte ch94data[] = {
0x88,0x50,0x20,
};

static BitmapCharRec ch94 = {5,3,(GLfloat)-1,(GLfloat)-6,(GLfloat)8,ch94data};

/* char: 93 ']' */

static GLubyte ch93data[] = {
0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,
};

static BitmapCharRec ch93 = {4,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch93data};

/* char: 92 '\' */

static GLubyte ch92data[] = {
0x2,0x2,0x4,0x8,0x10,0x20,0x40,0x80,0x80,
};

static BitmapCharRec ch92 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch92data};

/* char: 91 '[' */

static GLubyte ch91data[] = {
0xf0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xf0,
};

static BitmapCharRec ch91 = {4,9,(GLfloat)-2,(GLfloat)0,(GLfloat)8,ch91data};

/* char: 90 'Z' */

static GLubyte ch90data[] = {
0xfc,0x80,0x80,0x40,0x20,0x10,0x8,0x4,0xfc,
};

static BitmapCharRec ch90 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch90data};

/* char: 89 'Y' */

static GLubyte ch89data[] = {
0x10,0x10,0x10,0x10,0x10,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch89 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch89data};

/* char: 88 'X' */

static GLubyte ch88data[] = {
0x82,0x82,0x44,0x28,0x10,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch88 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch88data};

/* char: 87 'W' */

static GLubyte ch87data[] = {
0x44,0xaa,0x92,0x92,0x92,0x82,0x82,0x82,0x82,
};

static BitmapCharRec ch87 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch87data};

/* char: 86 'V' */

static GLubyte ch86data[] = {
0x10,0x28,0x28,0x28,0x44,0x44,0x44,0x82,0x82,
};

static BitmapCharRec ch86 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch86data};

/* char: 85 'U' */

static GLubyte ch85data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x84,
};

static BitmapCharRec ch85 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch85data};

/* char: 84 'T' */

static GLubyte ch84data[] = {
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xfe,
};

static BitmapCharRec ch84 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch84data};

/* char: 83 'S' */

static GLubyte ch83data[] = {
0x78,0x84,0x4,0x4,0x78,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch83 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch83data};

/* char: 82 'R' */

static GLubyte ch82data[] = {
0x84,0x88,0x90,0xa0,0xf8,0x84,0x84,0x84,0xf8,
};

static BitmapCharRec ch82 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch82data};

/* char: 81 'Q' */

static GLubyte ch81data[] = {
0x4,0x78,0x94,0xa4,0x84,0x84,0x84,0x84,0x84,0x78,
};

static BitmapCharRec ch81 = {6,10,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch81data};

/* char: 80 'P' */

static GLubyte ch80data[] = {
0x80,0x80,0x80,0x80,0xf8,0x84,0x84,0x84,0xf8,
};

static BitmapCharRec ch80 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch80data};

/* char: 79 'O' */

static GLubyte ch79data[] = {
0x78,0x84,0x84,0x84,0x84,0x84,0x84,0x84,0x78,
};

static BitmapCharRec ch79 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch79data};

/* char: 78 'N' */

static GLubyte ch78data[] = {
0x84,0x84,0x84,0x8c,0x94,0xa4,0xc4,0x84,0x84,
};

static BitmapCharRec ch78 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch78data};

/* char: 77 'M' */

static GLubyte ch77data[] = {
0x82,0x82,0x82,0x92,0x92,0xaa,0xc6,0x82,0x82,
};

static BitmapCharRec ch77 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch77data};

/* char: 76 'L' */

static GLubyte ch76data[] = {
0xfc,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch76 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch76data};

/* char: 75 'K' */

static GLubyte ch75data[] = {
0x84,0x88,0x90,0xa0,0xc0,0xa0,0x90,0x88,0x84,
};

static BitmapCharRec ch75 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch75data};

/* char: 74 'J' */

static GLubyte ch74data[] = {
0x70,0x88,0x8,0x8,0x8,0x8,0x8,0x8,0x3c,
};

static BitmapCharRec ch74 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch74data};

/* char: 73 'I' */

static GLubyte ch73data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,
};

static BitmapCharRec ch73 = {5,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch73data};

/* char: 72 'H' */

static GLubyte ch72data[] = {
0x84,0x84,0x84,0x84,0xfc,0x84,0x84,0x84,0x84,
};

static BitmapCharRec ch72 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch72data};

/* char: 71 'G' */

static GLubyte ch71data[] = {
0x74,0x8c,0x84,0x9c,0x80,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch71 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch71data};

/* char: 70 'F' */

static GLubyte ch70data[] = {
0x80,0x80,0x80,0x80,0xf0,0x80,0x80,0x80,0xfc,
};

static BitmapCharRec ch70 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch70data};

/* char: 69 'E' */

static GLubyte ch69data[] = {
0xfc,0x80,0x80,0x80,0xf0,0x80,0x80,0x80,0xfc,
};

static BitmapCharRec ch69 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch69data};

/* char: 68 'D' */

static GLubyte ch68data[] = {
0xfc,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch68 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch68data};

/* char: 67 'C' */

static GLubyte ch67data[] = {
0x78,0x84,0x80,0x80,0x80,0x80,0x80,0x84,0x78,
};

static BitmapCharRec ch67 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch67data};

/* char: 66 'B' */

static GLubyte ch66data[] = {
0xfc,0x42,0x42,0x42,0x7c,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch66 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch66data};

/* char: 65 'A' */

static GLubyte ch65data[] = {
0x84,0x84,0x84,0xfc,0x84,0x84,0x84,0x48,0x30,
};

static BitmapCharRec ch65 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch65data};

/* char: 64 '@' */

static GLubyte ch64data[] = {
0x78,0x80,0x94,0xac,0xa4,0x9c,0x84,0x84,0x78,
};

static BitmapCharRec ch64 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch64data};

/* char: 63 '?' */

static GLubyte ch63data[] = {
0x10,0x0,0x10,0x10,0x8,0x4,0x84,0x84,0x78,
};

static BitmapCharRec ch63 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch63data};

/* char: 62 '>' */

static GLubyte ch62data[] = {
0x80,0x40,0x20,0x10,0x8,0x10,0x20,0x40,0x80,
};

static BitmapCharRec ch62 = {5,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch62data};

/* char: 61 '=' */

static GLubyte ch61data[] = {
0xfc,0x0,0x0,0xfc,
};

static BitmapCharRec ch61 = {6,4,(GLfloat)-1,(GLfloat)-2,(GLfloat)8,ch61data};

/* char: 60 '<' */

static GLubyte ch60data[] = {
0x8,0x10,0x20,0x40,0x80,0x40,0x20,0x10,0x8,
};

static BitmapCharRec ch60 = {5,9,(GLfloat)-2,(GLfloat)0,(GLfloat)8,ch60data};

/* char: 59 ';' */

static GLubyte ch59data[] = {
0x80,0x60,0x70,0x0,0x0,0x20,0x70,0x20,
};

static BitmapCharRec ch59 = {4,8,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch59data};

/* char: 58 ':' */

static GLubyte ch58data[] = {
0x40,0xe0,0x40,0x0,0x0,0x40,0xe0,0x40,
};

static BitmapCharRec ch58 = {3,8,(GLfloat)-2,(GLfloat)1,(GLfloat)8,ch58data};

/* char: 57 '9' */

static GLubyte ch57data[] = {
0x70,0x8,0x4,0x4,0x74,0x8c,0x84,0x84,0x78,
};

static BitmapCharRec ch57 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch57data};

/* char: 56 '8' */

static GLubyte ch56data[] = {
0x78,0x84,0x84,0x84,0x78,0x84,0x84,0x84,0x78,
};

static BitmapCharRec ch56 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch56data};

/* char: 55 '7' */

static GLubyte ch55data[] = {
0x40,0x40,0x20,0x20,0x10,0x10,0x8,0x4,0xfc,
};

static BitmapCharRec ch55 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch55data};

/* char: 54 '6' */

static GLubyte ch54data[] = {
0x78,0x84,0x84,0xc4,0xb8,0x80,0x80,0x40,0x38,
};

static BitmapCharRec ch54 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch54data};

/* char: 53 '5' */

static GLubyte ch53data[] = {
0x78,0x84,0x4,0x4,0xc4,0xb8,0x80,0x80,0xfc,
};

static BitmapCharRec ch53 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch53data};

/* char: 52 '4' */

static GLubyte ch52data[] = {
0x8,0x8,0xfc,0x88,0x88,0x48,0x28,0x18,0x8,
};

static BitmapCharRec ch52 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch52data};

/* char: 51 '3' */

static GLubyte ch51data[] = {
0x78,0x84,0x4,0x4,0x38,0x10,0x8,0x4,0xfc,
};

static BitmapCharRec ch51 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch51data};

/* char: 50 '2' */

static GLubyte ch50data[] = {
0xfc,0x80,0x40,0x30,0x8,0x4,0x84,0x84,0x78,
};

static BitmapCharRec ch50 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch50data};

/* char: 49 '1' */

static GLubyte ch49data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0xa0,0x60,0x20,
};

static BitmapCharRec ch49 = {5,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch49data};

/* char: 48 '0' */

static GLubyte ch48data[] = {
0x30,0x48,0x84,0x84,0x84,0x84,0x84,0x48,0x30,
};

static BitmapCharRec ch48 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch48data};

/* char: 47 '/' */

static GLubyte ch47data[] = {
0x80,0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x2,
};

static BitmapCharRec ch47 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch47data};

/* char: 46 '.' */

static GLubyte ch46data[] = {
0x40,0xe0,0x40,
};

static BitmapCharRec ch46 = {3,3,(GLfloat)-2,(GLfloat)1,(GLfloat)8,ch46data};

/* char: 45 '-' */

static GLubyte ch45data[] = {
0xfc,
};

static BitmapCharRec ch45 = {6,1,(GLfloat)-1,(GLfloat)-4,(GLfloat)8,ch45data};

/* char: 44 ',' */

static GLubyte ch44data[] = {
0x80,0x60,0x70,
};

static BitmapCharRec ch44 = {4,3,(GLfloat)-1,(GLfloat)1,(GLfloat)8,ch44data};

/* char: 43 '+' */

static GLubyte ch43data[] = {
0x20,0x20,0xf8,0x20,0x20,
};

static BitmapCharRec ch43 = {5,5,(GLfloat)-1,(GLfloat)-2,(GLfloat)8,ch43data};

/* char: 42 '*' */

static GLubyte ch42data[] = {
0x48,0x30,0xfc,0x30,0x48,
};

static BitmapCharRec ch42 = {6,5,(GLfloat)-1,(GLfloat)-2,(GLfloat)8,ch42data};

/* char: 41 ')' */

static GLubyte ch41data[] = {
0x80,0x40,0x40,0x20,0x20,0x20,0x40,0x40,0x80,
};

static BitmapCharRec ch41 = {3,9,(GLfloat)-2,(GLfloat)0,(GLfloat)8,ch41data};

/* char: 40 '(' */

static GLubyte ch40data[] = {
0x20,0x40,0x40,0x80,0x80,0x80,0x40,0x40,0x20,
};

static BitmapCharRec ch40 = {3,9,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch40data};

/* char: 39 ''' */

static GLubyte ch39data[] = {
0x80,0x60,0x70,
};

static BitmapCharRec ch39 = {4,3,(GLfloat)-1,(GLfloat)-6,(GLfloat)8,ch39data};

/* char: 38 '&' */

static GLubyte ch38data[] = {
0x74,0x88,0x94,0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch38 = {6,7,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch38data};

/* char: 37 '%' */

static GLubyte ch37data[] = {
0x88,0x54,0x48,0x20,0x10,0x10,0x48,0xa4,0x44,
};

static BitmapCharRec ch37 = {6,9,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch37data};

/* char: 36 '$' */

static GLubyte ch36data[] = {
0x20,0xf0,0x28,0x70,0xa0,0x78,0x20,
};

static BitmapCharRec ch36 = {5,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch36data};

/* char: 35 '#' */

static GLubyte ch35data[] = {
0x48,0x48,0xfc,0x48,0xfc,0x48,0x48,
};

static BitmapCharRec ch35 = {6,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)8,ch35data};

/* char: 34 '"' */

static GLubyte ch34data[] = {
0x90,0x90,0x90,
};

static BitmapCharRec ch34 = {4,3,(GLfloat)-2,(GLfloat)-6,(GLfloat)8,ch34data};

/* char: 33 '!' */

static GLubyte ch33data[] = {
0x80,0x0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch33 = {1,9,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch33data};

/* char: 31 */

static GLubyte ch31data[] = {
0x80,
};

static BitmapCharRec ch31 = {1,1,(GLfloat)-3,(GLfloat)-3,(GLfloat)8,ch31data};

/* char: 30 */

static GLubyte ch30data[] = {
0xdc,0x62,0x20,0x20,0x20,0x70,0x20,0x22,0x1c,
};

static BitmapCharRec ch30 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch30data};

/* char: 29 */

static GLubyte ch29data[] = {
0x80,0x40,0xfe,0x10,0xfe,0x4,0x2,
};

static BitmapCharRec ch29 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch29data};

/* char: 28 */

static GLubyte ch28data[] = {
0x88,0x48,0x48,0x48,0x48,0xfc,
};

static BitmapCharRec ch28 = {6,6,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch28data};

/* char: 27 */

static GLubyte ch27data[] = {
0xfe,0x80,0x20,0x8,0x2,0x8,0x20,0x80,
};

static BitmapCharRec ch27 = {7,8,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch27data};

/* char: 26 */

static GLubyte ch26data[] = {
0xfe,0x2,0x8,0x20,0x80,0x20,0x8,0x2,
};

static BitmapCharRec ch26 = {7,8,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch26data};

/* char: 25 */

static GLubyte ch25data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch25 = {1,13,(GLfloat)-3,(GLfloat)2,(GLfloat)8,ch25data};

/* char: 24 */

static GLubyte ch24data[] = {
0x10,0x10,0x10,0x10,0x10,0xff,
};

static BitmapCharRec ch24 = {8,6,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch24data};

/* char: 23 */

static GLubyte ch23data[] = {
0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
};

static BitmapCharRec ch23 = {8,8,(GLfloat)0,(GLfloat)-3,(GLfloat)8,ch23data};

/* char: 22 */

static GLubyte ch22data[] = {
0x10,0x10,0x10,0x10,0x10,0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
};

static BitmapCharRec ch22 = {4,13,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch22data};

/* char: 21 */

static GLubyte ch21data[] = {
0x80,0x80,0x80,0x80,0x80,0xf8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch21 = {5,13,(GLfloat)-3,(GLfloat)2,(GLfloat)8,ch21data};

/* char: 20 */

static GLubyte ch20data[] = {
0xff,
};

static BitmapCharRec ch20 = {8,1,(GLfloat)0,(GLfloat)1,(GLfloat)8,ch20data};

/* char: 19 */

static GLubyte ch19data[] = {
0xff,
};

static BitmapCharRec ch19 = {8,1,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch19data};

/* char: 18 */

static GLubyte ch18data[] = {
0xff,
};

static BitmapCharRec ch18 = {8,1,(GLfloat)0,(GLfloat)-3,(GLfloat)8,ch18data};

/* char: 17 */

static GLubyte ch17data[] = {
0xff,
};

static BitmapCharRec ch17 = {8,1,(GLfloat)0,(GLfloat)-5,(GLfloat)8,ch17data};

/* char: 16 */

static GLubyte ch16data[] = {
0xff,
};

static BitmapCharRec ch16 = {8,1,(GLfloat)0,(GLfloat)-7,(GLfloat)8,ch16data};

/* char: 15 */

static GLubyte ch15data[] = {
0x10,0x10,0x10,0x10,0x10,0xff,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
};

static BitmapCharRec ch15 = {8,13,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch15data};

/* char: 14 */

static GLubyte ch14data[] = {
0xf8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch14 = {5,8,(GLfloat)-3,(GLfloat)-3,(GLfloat)8,ch14data};

/* char: 13 */

static GLubyte ch13data[] = {
0x80,0x80,0x80,0x80,0x80,0xf8,
};

static BitmapCharRec ch13 = {5,6,(GLfloat)-3,(GLfloat)2,(GLfloat)8,ch13data};

/* char: 12 */

static GLubyte ch12data[] = {
0x10,0x10,0x10,0x10,0x10,0xf0,
};

static BitmapCharRec ch12 = {4,6,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch12data};

/* char: 11 */

static GLubyte ch11data[] = {
0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,
};

static BitmapCharRec ch11 = {4,8,(GLfloat)0,(GLfloat)-3,(GLfloat)8,ch11data};

/* char: 10 */

static GLubyte ch10data[] = {
0x8,0x8,0x8,0x8,0x3e,0x20,0x50,0x88,0x88,
};

static BitmapCharRec ch10 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch10data};

/* char: 9 */

static GLubyte ch9data[] = {
0x3e,0x20,0x20,0x20,0x88,0x98,0xa8,0xc8,0x88,
};

static BitmapCharRec ch9 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch9data};

/* char: 8 */

static GLubyte ch8data[] = {
0xfe,0x10,0x10,0xfe,0x10,0x10,
};

static BitmapCharRec ch8 = {7,6,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch8data};

/* char: 7 */

static GLubyte ch7data[] = {
0x70,0x88,0x88,0x70,
};

static BitmapCharRec ch7 = {5,4,(GLfloat)-1,(GLfloat)-5,(GLfloat)8,ch7data};

/* char: 6 */

static GLubyte ch6data[] = {
0x20,0x20,0x3c,0x20,0x3e,0xf8,0x80,0x80,0x80,
};

static BitmapCharRec ch6 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch6data};

/* char: 5 */

static GLubyte ch5data[] = {
0x22,0x22,0x3c,0x22,0x3c,0x78,0x80,0x80,0x78,
};

static BitmapCharRec ch5 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch5data};

/* char: 4 */

static GLubyte ch4data[] = {
0x10,0x10,0x1c,0x10,0x9e,0x80,0xe0,0x80,0xf0,
};

static BitmapCharRec ch4 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch4data};

/* char: 3 */

static GLubyte ch3data[] = {
0x8,0x8,0x8,0x3e,0x88,0x88,0xf8,0x88,0x88,
};

static BitmapCharRec ch3 = {7,9,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch3data};

/* char: 2 */

static GLubyte ch2data[] = {
0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
};

static BitmapCharRec ch2 = {8,12,(GLfloat)0,(GLfloat)2,(GLfloat)8,ch2data};

/* char: 1 */

static GLubyte ch1data[] = {
0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,
};

static BitmapCharRec ch1 = {7,7,(GLfloat)0,(GLfloat)-1,(GLfloat)8,ch1data};

static BitmapCharPtr chars[] = {
&ch0,
&ch1,
&ch2,
&ch3,
&ch4,
&ch5,
&ch6,
&ch7,
&ch8,
&ch9,
&ch10,
&ch11,
&ch12,
&ch13,
&ch14,
&ch15,
&ch16,
&ch17,
&ch18,
&ch19,
&ch20,
&ch21,
&ch22,
&ch23,
&ch24,
&ch25,
&ch26,
&ch27,
&ch28,
&ch29,
&ch30,
&ch31,
&ch32,
&ch33,
&ch34,
&ch35,
&ch36,
&ch37,
&ch38,
&ch39,
&ch40,
&ch41,
&ch42,
&ch43,
&ch44,
&ch45,
&ch46,
&ch47,
&ch48,
&ch49,
&ch50,
&ch51,
&ch52,
&ch53,
&ch54,
&ch55,
&ch56,
&ch57,
&ch58,
&ch59,
&ch60,
&ch61,
&ch62,
&ch63,
&ch64,
&ch65,
&ch66,
&ch67,
&ch68,
&ch69,
&ch70,
&ch71,
&ch72,
&ch73,
&ch74,
&ch75,
&ch76,
&ch77,
&ch78,
&ch79,
&ch80,
&ch81,
&ch82,
&ch83,
&ch84,
&ch85,
&ch86,
&ch87,
&ch88,
&ch89,
&ch90,
&ch91,
&ch92,
&ch93,
&ch94,
&ch95,
&ch96,
&ch97,
&ch98,
&ch99,
&ch100,
&ch101,
&ch102,
&ch103,
&ch104,
&ch105,
&ch106,
&ch107,
&ch108,
&ch109,
&ch110,
&ch111,
&ch112,
&ch113,
&ch114,
&ch115,
&ch116,
&ch117,
&ch118,
&ch119,
&ch120,
&ch121,
&ch122,
&ch123,
&ch124,
&ch125,
&ch126,
&ch127,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
&ch160,
&ch161,
&ch162,
&ch163,
&ch164,
&ch165,
&ch166,
&ch167,
&ch168,
&ch169,
&ch170,
&ch171,
&ch172,
&ch173,
&ch174,
&ch175,
&ch176,
&ch177,
&ch178,
&ch179,
&ch180,
&ch181,
&ch182,
&ch183,
&ch184,
&ch185,
&ch186,
&ch187,
&ch188,
&ch189,
&ch190,
&ch191,
&ch192,
&ch193,
&ch194,
&ch195,
&ch196,
&ch197,
&ch198,
&ch199,
&ch200,
&ch201,
&ch202,
&ch203,
&ch204,
&ch205,
&ch206,
&ch207,
&ch208,
&ch209,
&ch210,
&ch211,
&ch212,
&ch213,
&ch214,
&ch215,
&ch216,
&ch217,
&ch218,
&ch219,
&ch220,
&ch221,
&ch222,
&ch223,
&ch224,
&ch225,
&ch226,
&ch227,
&ch228,
&ch229,
&ch230,
&ch231,
&ch232,
&ch233,
&ch234,
&ch235,
&ch236,
&ch237,
&ch238,
&ch239,
&ch240,
&ch241,
&ch242,
&ch243,
&ch244,
&ch245,
&ch246,
&ch247,
&ch248,
&ch249,
&ch250,
&ch251,
&ch252,
&ch253,
&ch254,
&ch255,
};

BitmapFontRec glutBitmap8By13 = {
"-misc-fixed-medium-r-normal--13-120-75-75-C-80-iso8859-1",
256,
0,
chars
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltbitmp.h ===
#ifndef __glutbitmap_h__
#define __glutbitmap_h__

/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef GLUT_WIN32
#include <windows.h>
#endif

#include <GL/gl.h>

typedef struct {
  GLsizei width;
  GLsizei height;
  GLfloat xorig;
  GLfloat yorig;
  GLfloat advance;
  GLubyte *bitmap;
} BitmapCharRec, *BitmapCharPtr;

typedef struct {
  char *name;
  int num_chars;
  int first;
  BitmapCharPtr *ch;
} BitmapFontRec, *BitmapFontPtr;

typedef void *GLUTbitmapFont;

#endif /* __glutbitmap_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glt9x15.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltbitmp.h"

static BitmapCharRec ch0 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)9,0};

static BitmapCharRec ch32 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)9,0};

static BitmapCharRec ch127 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)9,0};

static BitmapCharRec ch160 = {0,0,(GLfloat)0,(GLfloat)0,(GLfloat)9,0};

/* char: 255 */

static GLubyte ch255data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x28,0x28,
};

static BitmapCharRec ch255 = {6,14,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch255data};

/* char: 254 */

static GLubyte ch254data[] = {
0x80,0x80,0x80,0xbc,0xc2,0x82,0x82,0x82,0xc2,0xbc,0x80,0x80,
};

static BitmapCharRec ch254 = {7,12,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch254data};

/* char: 253 */

static GLubyte ch253data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x30,0x8,
};

static BitmapCharRec ch253 = {6,14,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch253data};

/* char: 252 */

static GLubyte ch252data[] = {
0x7a,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x28,0x28,
};

static BitmapCharRec ch252 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch252data};

/* char: 251 */

static GLubyte ch251data[] = {
0x7a,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x44,0x38,
};

static BitmapCharRec ch251 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch251data};

/* char: 250 */

static GLubyte ch250data[] = {
0x7a,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x30,0x8,
};

static BitmapCharRec ch250 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch250data};

/* char: 249 */

static GLubyte ch249data[] = {
0x7a,0x84,0x84,0x84,0x84,0x84,0x84,0x0,0x0,0x18,0x20,
};

static BitmapCharRec ch249 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch249data};

/* char: 248 */

static GLubyte ch248data[] = {
0x80,0x7c,0xa2,0xa2,0x92,0x8a,0x8a,0x7c,0x2,
};

static BitmapCharRec ch248 = {7,9,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch248data};

/* char: 247 */

static GLubyte ch247data[] = {
0x10,0x38,0x10,0x0,0xfe,0x0,0x10,0x38,0x10,
};

static BitmapCharRec ch247 = {7,9,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch247data};

/* char: 246 */

static GLubyte ch246data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x0,0x28,0x28,
};

static BitmapCharRec ch246 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch246data};

/* char: 245 */

static GLubyte ch245data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch245 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch245data};

/* char: 244 */

static GLubyte ch244data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x0,0x44,0x38,
};

static BitmapCharRec ch244 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch244data};

/* char: 243 */

static GLubyte ch243data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x0,0x30,0x8,
};

static BitmapCharRec ch243 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch243data};

/* char: 242 */

static GLubyte ch242data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x0,0x18,0x20,
};

static BitmapCharRec ch242 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch242data};

/* char: 241 */

static GLubyte ch241data[] = {
0x82,0x82,0x82,0x82,0x82,0xc2,0xbc,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch241 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch241data};

/* char: 240 */

static GLubyte ch240data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,0x8,0x50,0x30,0x48,
};

static BitmapCharRec ch240 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch240data};

/* char: 239 */

static GLubyte ch239data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x50,0x50,
};

static BitmapCharRec ch239 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch239data};

/* char: 238 */

static GLubyte ch238data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x90,0x60,
};

static BitmapCharRec ch238 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch238data};

/* char: 237 */

static GLubyte ch237data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x60,0x10,
};

static BitmapCharRec ch237 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch237data};

/* char: 236 */

static GLubyte ch236data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x60,0x0,0x0,0x30,0x40,
};

static BitmapCharRec ch236 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch236data};

/* char: 235 */

static GLubyte ch235data[] = {
0x7c,0x80,0x80,0xfe,0x82,0x82,0x7c,0x0,0x0,0x28,0x28,
};

static BitmapCharRec ch235 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch235data};

/* char: 234 */

static GLubyte ch234data[] = {
0x7c,0x80,0x80,0xfe,0x82,0x82,0x7c,0x0,0x0,0x44,0x38,
};

static BitmapCharRec ch234 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch234data};

/* char: 233 */

static GLubyte ch233data[] = {
0x7c,0x80,0x80,0xfe,0x82,0x82,0x7c,0x0,0x0,0x30,0x8,
};

static BitmapCharRec ch233 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch233data};

/* char: 232 */

static GLubyte ch232data[] = {
0x7c,0x80,0x80,0xfe,0x82,0x82,0x7c,0x0,0x0,0x18,0x20,
};

static BitmapCharRec ch232 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch232data};

/* char: 231 */

static GLubyte ch231data[] = {
0x30,0x48,0x18,0x7c,0x82,0x80,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch231 = {7,10,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch231data};

/* char: 230 */

static GLubyte ch230data[] = {
0x6e,0x92,0x90,0x7c,0x12,0x92,0x6c,
};

static BitmapCharRec ch230 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch230data};

/* char: 229 */

static GLubyte ch229data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x18,0x24,0x18,
};

static BitmapCharRec ch229 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch229data};

/* char: 228 */

static GLubyte ch228data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x0,0x28,0x28,
};

static BitmapCharRec ch228 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch228data};

/* char: 227 */

static GLubyte ch227data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x0,0x50,0x28,
};

static BitmapCharRec ch227 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch227data};

/* char: 226 */

static GLubyte ch226data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x0,0x44,0x38,
};

static BitmapCharRec ch226 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch226data};

/* char: 225 */

static GLubyte ch225data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x0,0x30,0x8,
};

static BitmapCharRec ch225 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch225data};

/* char: 224 */

static GLubyte ch224data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,0x0,0x0,0x18,0x20,
};

static BitmapCharRec ch224 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch224data};

/* char: 223 */

static GLubyte ch223data[] = {
0x80,0xbc,0xc2,0x82,0x82,0xfc,0x82,0x82,0x7c,
};

static BitmapCharRec ch223 = {7,9,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch223data};

/* char: 222 */

static GLubyte ch222data[] = {
0x80,0x80,0x80,0xfc,0x82,0x82,0x82,0xfc,0x80,0x80,
};

static BitmapCharRec ch222 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch222data};

/* char: 221 */

static GLubyte ch221data[] = {
0x10,0x10,0x10,0x10,0x28,0x44,0x82,0x82,0x0,0x30,0x8,
};

static BitmapCharRec ch221 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch221data};

/* char: 220 */

static GLubyte ch220data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x0,0x28,0x28,
};

static BitmapCharRec ch220 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch220data};

/* char: 219 */

static GLubyte ch219data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x0,0x44,0x38,
};

static BitmapCharRec ch219 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch219data};

/* char: 218 */

static GLubyte ch218data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x0,0x30,0x8,
};

static BitmapCharRec ch218 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch218data};

/* char: 217 */

static GLubyte ch217data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x0,0x18,0x20,
};

static BitmapCharRec ch217 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch217data};

/* char: 216 */

static GLubyte ch216data[] = {
0x80,0x7c,0xc2,0xa2,0xa2,0x92,0x92,0x8a,0x8a,0x86,0x7c,0x2,
};

static BitmapCharRec ch216 = {7,12,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch216data};

/* char: 215 */

static GLubyte ch215data[] = {
0x82,0x44,0x28,0x10,0x28,0x44,0x82,
};

static BitmapCharRec ch215 = {7,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch215data};

/* char: 214 */

static GLubyte ch214data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x28,0x28,
};

static BitmapCharRec ch214 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch214data};

/* char: 213 */

static GLubyte ch213data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x50,0x28,
};

static BitmapCharRec ch213 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch213data};

/* char: 212 */

static GLubyte ch212data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x44,0x38,
};

static BitmapCharRec ch212 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch212data};

/* char: 211 */

static GLubyte ch211data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x30,0x8,
};

static BitmapCharRec ch211 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch211data};

/* char: 210 */

static GLubyte ch210data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,0x0,0x18,0x20,
};

static BitmapCharRec ch210 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch210data};

/* char: 209 */

static GLubyte ch209data[] = {
0x82,0x86,0x8a,0x92,0x92,0xa2,0xc2,0x82,0x0,0x50,0x28,
};

static BitmapCharRec ch209 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch209data};

/* char: 208 */

static GLubyte ch208data[] = {
0xfc,0x42,0x42,0x42,0x42,0xf2,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch208 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch208data};

/* char: 207 */

static GLubyte ch207data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x50,0x50,
};

static BitmapCharRec ch207 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch207data};

/* char: 206 */

static GLubyte ch206data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x88,0x70,
};

static BitmapCharRec ch206 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch206data};

/* char: 205 */

static GLubyte ch205data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x60,0x10,
};

static BitmapCharRec ch205 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch205data};

/* char: 204 */

static GLubyte ch204data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,0x0,0x30,0x40,
};

static BitmapCharRec ch204 = {5,11,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch204data};

/* char: 203 */

static GLubyte ch203data[] = {
0xfe,0x40,0x40,0x40,0x78,0x40,0x40,0xfe,0x0,0x28,0x28,
};

static BitmapCharRec ch203 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch203data};

/* char: 202 */

static GLubyte ch202data[] = {
0xfe,0x40,0x40,0x40,0x78,0x40,0x40,0xfe,0x0,0x44,0x38,
};

static BitmapCharRec ch202 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch202data};

/* char: 201 */

static GLubyte ch201data[] = {
0xfe,0x40,0x40,0x40,0x78,0x40,0x40,0xfe,0x0,0x30,0x8,
};

static BitmapCharRec ch201 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch201data};

/* char: 200 */

static GLubyte ch200data[] = {
0xfe,0x40,0x40,0x40,0x78,0x40,0x40,0xfe,0x0,0x18,0x20,
};

static BitmapCharRec ch200 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch200data};

/* char: 199 */

static GLubyte ch199data[] = {
0x30,0x48,0x18,0x7c,0x82,0x80,0x80,0x80,0x80,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch199 = {7,13,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch199data};

/* char: 198 */

static GLubyte ch198data[] = {
0x9e,0x90,0x90,0x90,0xfc,0x90,0x90,0x90,0x90,0x6e,
};

static BitmapCharRec ch198 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch198data};

/* char: 197 */

static GLubyte ch197data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x10,0x28,0x10,
};

static BitmapCharRec ch197 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch197data};

/* char: 196 */

static GLubyte ch196data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x0,0x28,0x28,
};

static BitmapCharRec ch196 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch196data};

/* char: 195 */

static GLubyte ch195data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x0,0x50,0x28,
};

static BitmapCharRec ch195 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch195data};

/* char: 194 */

static GLubyte ch194data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x0,0x44,0x38,
};

static BitmapCharRec ch194 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch194data};

/* char: 193 */

static GLubyte ch193data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x0,0x30,0x8,
};

static BitmapCharRec ch193 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch193data};

/* char: 192 */

static GLubyte ch192data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x44,0x38,0x0,0x18,0x20,
};

static BitmapCharRec ch192 = {7,11,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch192data};

/* char: 191 */

static GLubyte ch191data[] = {
0x7c,0x82,0x82,0x80,0x40,0x20,0x10,0x10,0x0,0x10,
};

static BitmapCharRec ch191 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch191data};

/* char: 190 */

static GLubyte ch190data[] = {
0x6,0x1a,0x12,0xa,0x66,0x92,0x10,0x20,0x90,0x60,
};

static BitmapCharRec ch190 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch190data};

/* char: 189 */

static GLubyte ch189data[] = {
0x1e,0x10,0xc,0x2,0xf2,0x4c,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch189 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch189data};

/* char: 188 */

static GLubyte ch188data[] = {
0x6,0x1a,0x12,0xa,0xe6,0x42,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch188 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch188data};

/* char: 187 */

static GLubyte ch187data[] = {
0x90,0x48,0x24,0x12,0x12,0x24,0x48,0x90,
};

static BitmapCharRec ch187 = {7,8,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch187data};

/* char: 186 */

static GLubyte ch186data[] = {
0xf8,0x0,0x70,0x88,0x88,0x70,
};

static BitmapCharRec ch186 = {5,6,(GLfloat)-1,(GLfloat)-5,(GLfloat)9,ch186data};

/* char: 185 */

static GLubyte ch185data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch185 = {3,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)9,ch185data};

/* char: 184 */

static GLubyte ch184data[] = {
0x60,0x90,0x30,
};

static BitmapCharRec ch184 = {4,3,(GLfloat)-2,(GLfloat)3,(GLfloat)9,ch184data};

/* char: 183 */

static GLubyte ch183data[] = {
0x40,0xe0,0x40,
};

static BitmapCharRec ch183 = {3,3,(GLfloat)-3,(GLfloat)-3,(GLfloat)9,ch183data};

/* char: 182 */

static GLubyte ch182data[] = {
0xa,0xa,0xa,0xa,0xa,0x7a,0x8a,0x8a,0x8a,0x7e,
};

static BitmapCharRec ch182 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch182data};

/* char: 181 */

static GLubyte ch181data[] = {
0x80,0x80,0xba,0xc6,0x82,0x82,0x82,0x82,0x82,
};

static BitmapCharRec ch181 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch181data};

/* char: 180 */

static GLubyte ch180data[] = {
0xc0,0x20,
};

static BitmapCharRec ch180 = {3,2,(GLfloat)-3,(GLfloat)-9,(GLfloat)9,ch180data};

/* char: 179 */

static GLubyte ch179data[] = {
0x60,0x90,0x10,0x20,0x90,0x60,
};

static BitmapCharRec ch179 = {4,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)9,ch179data};

/* char: 178 */

static GLubyte ch178data[] = {
0xf0,0x80,0x60,0x10,0x90,0x60,
};

static BitmapCharRec ch178 = {4,6,(GLfloat)-1,(GLfloat)-4,(GLfloat)9,ch178data};

/* char: 177 */

static GLubyte ch177data[] = {
0xfe,0x0,0x10,0x10,0x10,0xfe,0x10,0x10,0x10,
};

static BitmapCharRec ch177 = {7,9,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch177data};

/* char: 176 */

static GLubyte ch176data[] = {
0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch176 = {4,4,(GLfloat)-3,(GLfloat)-6,(GLfloat)9,ch176data};

/* char: 175 */

static GLubyte ch175data[] = {
0xfc,
};

static BitmapCharRec ch175 = {6,1,(GLfloat)-1,(GLfloat)-9,(GLfloat)9,ch175data};

/* char: 174 */

static GLubyte ch174data[] = {
0x3c,0x42,0xa5,0xa9,0xbd,0xa5,0xb9,0x42,0x3c,
};

static BitmapCharRec ch174 = {8,9,(GLfloat)0,(GLfloat)-1,(GLfloat)9,ch174data};

/* char: 173 */

static GLubyte ch173data[] = {
0xfc,
};

static BitmapCharRec ch173 = {6,1,(GLfloat)-1,(GLfloat)-4,(GLfloat)9,ch173data};

/* char: 172 */

static GLubyte ch172data[] = {
0x4,0x4,0x4,0xfc,
};

static BitmapCharRec ch172 = {6,4,(GLfloat)-1,(GLfloat)-2,(GLfloat)9,ch172data};

/* char: 171 */

static GLubyte ch171data[] = {
0x12,0x24,0x48,0x90,0x90,0x48,0x24,0x12,
};

static BitmapCharRec ch171 = {7,8,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch171data};

/* char: 170 */

static GLubyte ch170data[] = {
0xf8,0x0,0x78,0x90,0x70,0x90,0x60,
};

static BitmapCharRec ch170 = {5,7,(GLfloat)-3,(GLfloat)-3,(GLfloat)9,ch170data};

/* char: 169 */

static GLubyte ch169data[] = {
0x3c,0x42,0x99,0xa5,0xa1,0xa5,0x99,0x42,0x3c,
};

static BitmapCharRec ch169 = {8,9,(GLfloat)0,(GLfloat)-1,(GLfloat)9,ch169data};

/* char: 168 */

static GLubyte ch168data[] = {
0xa0,0xa0,
};

static BitmapCharRec ch168 = {3,2,(GLfloat)-3,(GLfloat)-9,(GLfloat)9,ch168data};

/* char: 167 */

static GLubyte ch167data[] = {
0x70,0x88,0x8,0x70,0x88,0x88,0x88,0x70,0x80,0x88,0x70,
};

static BitmapCharRec ch167 = {5,11,(GLfloat)-2,(GLfloat)1,(GLfloat)9,ch167data};

/* char: 166 */

static GLubyte ch166data[] = {
0x80,0x80,0x80,0x80,0x80,0x0,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch166 = {1,11,(GLfloat)-4,(GLfloat)1,(GLfloat)9,ch166data};

/* char: 165 */

static GLubyte ch165data[] = {
0x10,0x10,0x10,0x7c,0x10,0x7c,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch165 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch165data};

/* char: 164 */

static GLubyte ch164data[] = {
0x82,0x7c,0x44,0x44,0x7c,0x82,
};

static BitmapCharRec ch164 = {7,6,(GLfloat)-1,(GLfloat)-3,(GLfloat)9,ch164data};

/* char: 163 */

static GLubyte ch163data[] = {
0x5c,0xa2,0x60,0x20,0x20,0xf8,0x20,0x20,0x22,0x1c,
};

static BitmapCharRec ch163 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch163data};

/* char: 162 */

static GLubyte ch162data[] = {
0x40,0x78,0xa4,0xa0,0x90,0x94,0x78,0x8,
};

static BitmapCharRec ch162 = {6,8,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch162data};

/* char: 161 */

static GLubyte ch161data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x0,0x80,
};

static BitmapCharRec ch161 = {1,10,(GLfloat)-4,(GLfloat)0,(GLfloat)9,ch161data};

/* char: 126 '~' */

static GLubyte ch126data[] = {
0x8c,0x92,0x62,
};

static BitmapCharRec ch126 = {7,3,(GLfloat)-1,(GLfloat)-7,(GLfloat)9,ch126data};

/* char: 125 '}' */

static GLubyte ch125data[] = {
0xe0,0x10,0x10,0x20,0x18,0x18,0x20,0x10,0x10,0xe0,
};

static BitmapCharRec ch125 = {5,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch125data};

/* char: 124 '|' */

static GLubyte ch124data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch124 = {1,10,(GLfloat)-4,(GLfloat)0,(GLfloat)9,ch124data};

/* char: 123 '{' */

static GLubyte ch123data[] = {
0x38,0x40,0x40,0x20,0xc0,0xc0,0x20,0x40,0x40,0x38,
};

static BitmapCharRec ch123 = {5,10,(GLfloat)-3,(GLfloat)0,(GLfloat)9,ch123data};

/* char: 122 'z' */

static GLubyte ch122data[] = {
0xfe,0x40,0x20,0x10,0x8,0x4,0xfe,
};

static BitmapCharRec ch122 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch122data};

/* char: 121 'y' */

static GLubyte ch121data[] = {
0x78,0x84,0x4,0x74,0x8c,0x84,0x84,0x84,0x84,0x84,
};

static BitmapCharRec ch121 = {6,10,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch121data};

/* char: 120 'x' */

static GLubyte ch120data[] = {
0x82,0x44,0x28,0x10,0x28,0x44,0x82,
};

static BitmapCharRec ch120 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch120data};

/* char: 119 'w' */

static GLubyte ch119data[] = {
0x44,0xaa,0x92,0x92,0x92,0x82,0x82,
};

static BitmapCharRec ch119 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch119data};

/* char: 118 'v' */

static GLubyte ch118data[] = {
0x10,0x28,0x28,0x44,0x44,0x82,0x82,
};

static BitmapCharRec ch118 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch118data};

/* char: 117 'u' */

static GLubyte ch117data[] = {
0x7a,0x84,0x84,0x84,0x84,0x84,0x84,
};

static BitmapCharRec ch117 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch117data};

/* char: 116 't' */

static GLubyte ch116data[] = {
0x1c,0x22,0x20,0x20,0x20,0x20,0xfc,0x20,0x20,
};

static BitmapCharRec ch116 = {7,9,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch116data};

/* char: 115 's' */

static GLubyte ch115data[] = {
0x7c,0x82,0x2,0x7c,0x80,0x82,0x7c,
};

static BitmapCharRec ch115 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch115data};

/* char: 114 'r' */

static GLubyte ch114data[] = {
0x40,0x40,0x40,0x40,0x42,0x62,0x9c,
};

static BitmapCharRec ch114 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch114data};

/* char: 113 'q' */

static GLubyte ch113data[] = {
0x2,0x2,0x2,0x7a,0x86,0x82,0x82,0x82,0x86,0x7a,
};

static BitmapCharRec ch113 = {7,10,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch113data};

/* char: 112 'p' */

static GLubyte ch112data[] = {
0x80,0x80,0x80,0xbc,0xc2,0x82,0x82,0x82,0xc2,0xbc,
};

static BitmapCharRec ch112 = {7,10,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch112data};

/* char: 111 'o' */

static GLubyte ch111data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x7c,
};

static BitmapCharRec ch111 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch111data};

/* char: 110 'n' */

static GLubyte ch110data[] = {
0x82,0x82,0x82,0x82,0x82,0xc2,0xbc,
};

static BitmapCharRec ch110 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch110data};

/* char: 109 'm' */

static GLubyte ch109data[] = {
0x82,0x92,0x92,0x92,0x92,0x92,0xec,
};

static BitmapCharRec ch109 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch109data};

/* char: 108 'l' */

static GLubyte ch108data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x60,
};

static BitmapCharRec ch108 = {5,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch108data};

/* char: 107 'k' */

static GLubyte ch107data[] = {
0x82,0x8c,0xb0,0xc0,0xb0,0x8c,0x82,0x80,0x80,0x80,
};

static BitmapCharRec ch107 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch107data};

/* char: 106 'j' */

static GLubyte ch106data[] = {
0x78,0x84,0x84,0x84,0x4,0x4,0x4,0x4,0x4,0x1c,0x0,0x4,
};

static BitmapCharRec ch106 = {6,12,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch106data};

/* char: 105 'i' */

static GLubyte ch105data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x60,0x0,0x20,
};

static BitmapCharRec ch105 = {5,9,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch105data};

/* char: 104 'h' */

static GLubyte ch104data[] = {
0x82,0x82,0x82,0x82,0x82,0xc2,0xbc,0x80,0x80,0x80,
};

static BitmapCharRec ch104 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch104data};

/* char: 103 'g' */

static GLubyte ch103data[] = {
0x7c,0x82,0x82,0x7c,0x80,0x78,0x84,0x84,0x84,0x7a,
};

static BitmapCharRec ch103 = {7,10,(GLfloat)-1,(GLfloat)3,(GLfloat)9,ch103data};

/* char: 102 'f' */

static GLubyte ch102data[] = {
0x20,0x20,0x20,0x20,0xf8,0x20,0x20,0x22,0x22,0x1c,
};

static BitmapCharRec ch102 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch102data};

/* char: 101 'e' */

static GLubyte ch101data[] = {
0x7c,0x80,0x80,0xfe,0x82,0x82,0x7c,
};

static BitmapCharRec ch101 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch101data};

/* char: 100 'd' */

static GLubyte ch100data[] = {
0x7a,0x86,0x82,0x82,0x82,0x86,0x7a,0x2,0x2,0x2,
};

static BitmapCharRec ch100 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch100data};

/* char: 99 'c' */

static GLubyte ch99data[] = {
0x7c,0x82,0x80,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch99 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch99data};

/* char: 98 'b' */

static GLubyte ch98data[] = {
0xbc,0xc2,0x82,0x82,0x82,0xc2,0xbc,0x80,0x80,0x80,
};

static BitmapCharRec ch98 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch98data};

/* char: 97 'a' */

static GLubyte ch97data[] = {
0x7a,0x86,0x82,0x7e,0x2,0x2,0x7c,
};

static BitmapCharRec ch97 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch97data};

/* char: 96 '`' */

static GLubyte ch96data[] = {
0x10,0x60,0xe0,
};

static BitmapCharRec ch96 = {4,3,(GLfloat)-2,(GLfloat)-7,(GLfloat)9,ch96data};

/* char: 95 '_' */

static GLubyte ch95data[] = {
0xff,
};

static BitmapCharRec ch95 = {8,1,(GLfloat)0,(GLfloat)1,(GLfloat)9,ch95data};

/* char: 94 '^' */

static GLubyte ch94data[] = {
0x82,0x44,0x28,0x10,
};

static BitmapCharRec ch94 = {7,4,(GLfloat)-1,(GLfloat)-6,(GLfloat)9,ch94data};

/* char: 93 ']' */

static GLubyte ch93data[] = {
0xf0,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xf0,
};

static BitmapCharRec ch93 = {4,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch93data};

/* char: 92 '\' */

static GLubyte ch92data[] = {
0x2,0x4,0x4,0x8,0x10,0x10,0x20,0x40,0x40,0x80,
};

static BitmapCharRec ch92 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch92data};

/* char: 91 '[' */

static GLubyte ch91data[] = {
0xf0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xf0,
};

static BitmapCharRec ch91 = {4,10,(GLfloat)-3,(GLfloat)0,(GLfloat)9,ch91data};

/* char: 90 'Z' */

static GLubyte ch90data[] = {
0xfe,0x80,0x80,0x40,0x20,0x10,0x8,0x4,0x2,0xfe,
};

static BitmapCharRec ch90 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch90data};

/* char: 89 'Y' */

static GLubyte ch89data[] = {
0x10,0x10,0x10,0x10,0x10,0x10,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch89 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch89data};

/* char: 88 'X' */

static GLubyte ch88data[] = {
0x82,0x82,0x44,0x28,0x10,0x10,0x28,0x44,0x82,0x82,
};

static BitmapCharRec ch88 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch88data};

/* char: 87 'W' */

static GLubyte ch87data[] = {
0x44,0xaa,0x92,0x92,0x92,0x92,0x82,0x82,0x82,0x82,
};

static BitmapCharRec ch87 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch87data};

/* char: 86 'V' */

static GLubyte ch86data[] = {
0x10,0x28,0x28,0x28,0x44,0x44,0x44,0x82,0x82,0x82,
};

static BitmapCharRec ch86 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch86data};

/* char: 85 'U' */

static GLubyte ch85data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,
};

static BitmapCharRec ch85 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch85data};

/* char: 84 'T' */

static GLubyte ch84data[] = {
0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0x10,0xfe,
};

static BitmapCharRec ch84 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch84data};

/* char: 83 'S' */

static GLubyte ch83data[] = {
0x7c,0x82,0x2,0x2,0x2,0x7c,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch83 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch83data};

/* char: 82 'R' */

static GLubyte ch82data[] = {
0x82,0x82,0x84,0x88,0x90,0xfc,0x82,0x82,0x82,0xfc,
};

static BitmapCharRec ch82 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch82data};

/* char: 81 'Q' */

static GLubyte ch81data[] = {
0x2,0x7c,0x8a,0x92,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,
};

static BitmapCharRec ch81 = {7,11,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch81data};

/* char: 80 'P' */

static GLubyte ch80data[] = {
0x80,0x80,0x80,0x80,0x80,0xfc,0x82,0x82,0x82,0xfc,
};

static BitmapCharRec ch80 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch80data};

/* char: 79 'O' */

static GLubyte ch79data[] = {
0x7c,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0x7c,
};

static BitmapCharRec ch79 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch79data};

/* char: 78 'N' */

static GLubyte ch78data[] = {
0x82,0x82,0x82,0x86,0x8a,0x92,0xa2,0xc2,0x82,0x82,
};

static BitmapCharRec ch78 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch78data};

/* char: 77 'M' */

static GLubyte ch77data[] = {
0x82,0x82,0x82,0x92,0x92,0xaa,0xaa,0xc6,0x82,0x82,
};

static BitmapCharRec ch77 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch77data};

/* char: 76 'L' */

static GLubyte ch76data[] = {
0xfe,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch76 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch76data};

/* char: 75 'K' */

static GLubyte ch75data[] = {
0x82,0x84,0x88,0x90,0xa0,0xe0,0x90,0x88,0x84,0x82,
};

static BitmapCharRec ch75 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch75data};

/* char: 74 'J' */

static GLubyte ch74data[] = {
0x78,0x84,0x4,0x4,0x4,0x4,0x4,0x4,0x4,0x1e,
};

static BitmapCharRec ch74 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch74data};

/* char: 73 'I' */

static GLubyte ch73data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0x20,0xf8,
};

static BitmapCharRec ch73 = {5,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch73data};

/* char: 72 'H' */

static GLubyte ch72data[] = {
0x82,0x82,0x82,0x82,0x82,0xfe,0x82,0x82,0x82,0x82,
};

static BitmapCharRec ch72 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch72data};

/* char: 71 'G' */

static GLubyte ch71data[] = {
0x7c,0x82,0x82,0x82,0x8e,0x80,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch71 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch71data};

/* char: 70 'F' */

static GLubyte ch70data[] = {
0x40,0x40,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0xfe,
};

static BitmapCharRec ch70 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch70data};

/* char: 69 'E' */

static GLubyte ch69data[] = {
0xfe,0x40,0x40,0x40,0x40,0x78,0x40,0x40,0x40,0xfe,
};

static BitmapCharRec ch69 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch69data};

/* char: 68 'D' */

static GLubyte ch68data[] = {
0xfc,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch68 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch68data};

/* char: 67 'C' */

static GLubyte ch67data[] = {
0x7c,0x82,0x80,0x80,0x80,0x80,0x80,0x80,0x82,0x7c,
};

static BitmapCharRec ch67 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch67data};

/* char: 66 'B' */

static GLubyte ch66data[] = {
0xfc,0x42,0x42,0x42,0x42,0x7c,0x42,0x42,0x42,0xfc,
};

static BitmapCharRec ch66 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch66data};

/* char: 65 'A' */

static GLubyte ch65data[] = {
0x82,0x82,0x82,0xfe,0x82,0x82,0x82,0x44,0x28,0x10,
};

static BitmapCharRec ch65 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch65data};

/* char: 64 '@' */

static GLubyte ch64data[] = {
0x7c,0x80,0x80,0x9a,0xa6,0xa2,0x9e,0x82,0x82,0x7c,
};

static BitmapCharRec ch64 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch64data};

/* char: 63 '?' */

static GLubyte ch63data[] = {
0x10,0x0,0x10,0x10,0x8,0x4,0x2,0x82,0x82,0x7c,
};

static BitmapCharRec ch63 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch63data};

/* char: 62 '>' */

static GLubyte ch62data[] = {
0x80,0x40,0x20,0x10,0x8,0x8,0x10,0x20,0x40,0x80,
};

static BitmapCharRec ch62 = {5,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch62data};

/* char: 61 '=' */

static GLubyte ch61data[] = {
0xfe,0x0,0x0,0xfe,
};

static BitmapCharRec ch61 = {7,4,(GLfloat)-1,(GLfloat)-2,(GLfloat)9,ch61data};

/* char: 60 '<' */

static GLubyte ch60data[] = {
0x8,0x10,0x20,0x40,0x80,0x80,0x40,0x20,0x10,0x8,
};

static BitmapCharRec ch60 = {5,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch60data};

/* char: 59 ';' */

static GLubyte ch59data[] = {
0x80,0x60,0x70,0x0,0x0,0x20,0x70,0x20,
};

static BitmapCharRec ch59 = {4,8,(GLfloat)-2,(GLfloat)1,(GLfloat)9,ch59data};

/* char: 58 ':' */

static GLubyte ch58data[] = {
0x40,0xe0,0x40,0x0,0x0,0x40,0xe0,0x40,
};

static BitmapCharRec ch58 = {3,8,(GLfloat)-3,(GLfloat)1,(GLfloat)9,ch58data};

/* char: 57 '9' */

static GLubyte ch57data[] = {
0x78,0x4,0x2,0x2,0x7a,0x86,0x82,0x82,0x82,0x7c,
};

static BitmapCharRec ch57 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch57data};

/* char: 56 '8' */

static GLubyte ch56data[] = {
0x7c,0x82,0x82,0x82,0x82,0x7c,0x82,0x82,0x82,0x7c,
};

static BitmapCharRec ch56 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch56data};

/* char: 55 '7' */

static GLubyte ch55data[] = {
0x40,0x40,0x20,0x20,0x10,0x8,0x4,0x2,0x2,0xfe,
};

static BitmapCharRec ch55 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch55data};

/* char: 54 '6' */

static GLubyte ch54data[] = {
0x7c,0x82,0x82,0x82,0xc2,0xbc,0x80,0x80,0x40,0x3c,
};

static BitmapCharRec ch54 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch54data};

/* char: 53 '5' */

static GLubyte ch53data[] = {
0x7c,0x82,0x2,0x2,0x2,0xc2,0xbc,0x80,0x80,0xfe,
};

static BitmapCharRec ch53 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch53data};

/* char: 52 '4' */

static GLubyte ch52data[] = {
0x4,0x4,0x4,0xfe,0x84,0x44,0x24,0x14,0xc,0x4,
};

static BitmapCharRec ch52 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch52data};

/* char: 51 '3' */

static GLubyte ch51data[] = {
0x7c,0x82,0x2,0x2,0x2,0x1c,0x8,0x4,0x2,0xfe,
};

static BitmapCharRec ch51 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch51data};

/* char: 50 '2' */

static GLubyte ch50data[] = {
0xfe,0x80,0x40,0x30,0x8,0x4,0x2,0x82,0x82,0x7c,
};

static BitmapCharRec ch50 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch50data};

/* char: 49 '1' */

static GLubyte ch49data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xa0,0x60,0x20,
};

static BitmapCharRec ch49 = {5,10,(GLfloat)-2,(GLfloat)0,(GLfloat)9,ch49data};

/* char: 48 '0' */

static GLubyte ch48data[] = {
0x38,0x44,0x82,0x82,0x82,0x82,0x82,0x82,0x44,0x38,
};

static BitmapCharRec ch48 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch48data};

/* char: 47 '/' */

static GLubyte ch47data[] = {
0x80,0x40,0x40,0x20,0x10,0x10,0x8,0x4,0x4,0x2,
};

static BitmapCharRec ch47 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch47data};

/* char: 46 '.' */

static GLubyte ch46data[] = {
0x40,0xe0,0x40,
};

static BitmapCharRec ch46 = {3,3,(GLfloat)-3,(GLfloat)1,(GLfloat)9,ch46data};

/* char: 45 '-' */

static GLubyte ch45data[] = {
0xfe,
};

static BitmapCharRec ch45 = {7,1,(GLfloat)-1,(GLfloat)-4,(GLfloat)9,ch45data};

/* char: 44 ',' */

static GLubyte ch44data[] = {
0x80,0x60,0x70,
};

static BitmapCharRec ch44 = {4,3,(GLfloat)-2,(GLfloat)1,(GLfloat)9,ch44data};

/* char: 43 '+' */

static GLubyte ch43data[] = {
0x10,0x10,0x10,0xfe,0x10,0x10,0x10,
};

static BitmapCharRec ch43 = {7,7,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch43data};

/* char: 42 '*' */

static GLubyte ch42data[] = {
0x44,0x28,0xfe,0x28,0x44,
};

static BitmapCharRec ch42 = {7,5,(GLfloat)-1,(GLfloat)-2,(GLfloat)9,ch42data};

/* char: 41 ')' */

static GLubyte ch41data[] = {
0x80,0x40,0x40,0x20,0x20,0x20,0x20,0x40,0x40,0x80,
};

static BitmapCharRec ch41 = {3,10,(GLfloat)-3,(GLfloat)0,(GLfloat)9,ch41data};

/* char: 40 '(' */

static GLubyte ch40data[] = {
0x20,0x40,0x40,0x80,0x80,0x80,0x80,0x40,0x40,0x20,
};

static BitmapCharRec ch40 = {3,10,(GLfloat)-3,(GLfloat)0,(GLfloat)9,ch40data};

/* char: 39 ''' */

static GLubyte ch39data[] = {
0x80,0x60,0x70,
};

static BitmapCharRec ch39 = {4,3,(GLfloat)-3,(GLfloat)-7,(GLfloat)9,ch39data};

/* char: 38 '&' */

static GLubyte ch38data[] = {
0x72,0x8c,0x84,0x8a,0x88,0x70,0x88,0x88,0x88,0x70,
};

static BitmapCharRec ch38 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch38data};

/* char: 37 '%' */

static GLubyte ch37data[] = {
0x84,0x4a,0x4a,0x24,0x10,0x10,0x48,0xa4,0xa4,0x42,
};

static BitmapCharRec ch37 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch37data};

/* char: 36 '$' */

static GLubyte ch36data[] = {
0x10,0x7c,0x12,0x12,0x7c,0x90,0x90,0x7c,0x10,
};

static BitmapCharRec ch36 = {7,9,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch36data};

/* char: 35 '#' */

static GLubyte ch35data[] = {
0x48,0x48,0xfc,0x48,0x48,0xfc,0x48,0x48,
};

static BitmapCharRec ch35 = {6,8,(GLfloat)-1,(GLfloat)-1,(GLfloat)9,ch35data};

/* char: 34 '"' */

static GLubyte ch34data[] = {
0x90,0x90,0x90,
};

static BitmapCharRec ch34 = {4,3,(GLfloat)-3,(GLfloat)-7,(GLfloat)9,ch34data};

/* char: 33 '!' */

static GLubyte ch33data[] = {
0x80,0x0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch33 = {1,10,(GLfloat)-4,(GLfloat)0,(GLfloat)9,ch33data};

/* char: 31 */

static GLubyte ch31data[] = {
0x80,
};

static BitmapCharRec ch31 = {1,1,(GLfloat)-4,(GLfloat)-3,(GLfloat)9,ch31data};

/* char: 30 */

static GLubyte ch30data[] = {
0x5c,0xa2,0x60,0x20,0x20,0xf8,0x20,0x20,0x22,0x1c,
};

static BitmapCharRec ch30 = {7,10,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch30data};

/* char: 29 */

static GLubyte ch29data[] = {
0x80,0x40,0xfe,0x10,0xfe,0x4,0x2,
};

static BitmapCharRec ch29 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch29data};

/* char: 28 */

static GLubyte ch28data[] = {
0x44,0x24,0x24,0x24,0x24,0x24,0xfe,
};

static BitmapCharRec ch28 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch28data};

/* char: 27 */

static GLubyte ch27data[] = {
0xfe,0x80,0x20,0x8,0x2,0x8,0x20,0x80,
};

static BitmapCharRec ch27 = {7,8,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch27data};

/* char: 26 */

static GLubyte ch26data[] = {
0xfe,0x2,0x8,0x20,0x80,0x20,0x8,0x2,
};

static BitmapCharRec ch26 = {7,8,(GLfloat)-1,(GLfloat)1,(GLfloat)9,ch26data};

/* char: 25 */

static GLubyte ch25data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch25 = {1,15,(GLfloat)-4,(GLfloat)3,(GLfloat)9,ch25data};

/* char: 24 */

static GLubyte ch24data[] = {
0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0xff,0x80,
};

static BitmapCharRec ch24 = {9,7,(GLfloat)0,(GLfloat)3,(GLfloat)9,ch24data};

/* char: 23 */

static GLubyte ch23data[] = {
0xff,0x80,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,
0x8,0x0,
};

static BitmapCharRec ch23 = {9,9,(GLfloat)0,(GLfloat)-3,(GLfloat)9,ch23data};

/* char: 22 */

static GLubyte ch22data[] = {
0x8,0x8,0x8,0x8,0x8,0x8,0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,
};

static BitmapCharRec ch22 = {5,15,(GLfloat)0,(GLfloat)3,(GLfloat)9,ch22data};

/* char: 21 */

static GLubyte ch21data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0xf8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch21 = {5,15,(GLfloat)-4,(GLfloat)3,(GLfloat)9,ch21data};

/* char: 20 */

static GLubyte ch20data[] = {
0xff,0x80,
};

static BitmapCharRec ch20 = {9,1,(GLfloat)0,(GLfloat)1,(GLfloat)9,ch20data};

/* char: 19 */

static GLubyte ch19data[] = {
0xff,0x80,
};

static BitmapCharRec ch19 = {9,1,(GLfloat)0,(GLfloat)-1,(GLfloat)9,ch19data};

/* char: 18 */

static GLubyte ch18data[] = {
0xff,0x80,
};

static BitmapCharRec ch18 = {9,1,(GLfloat)0,(GLfloat)-3,(GLfloat)9,ch18data};

/* char: 17 */

static GLubyte ch17data[] = {
0xff,0x80,
};

static BitmapCharRec ch17 = {9,1,(GLfloat)0,(GLfloat)-5,(GLfloat)9,ch17data};

/* char: 16 */

static GLubyte ch16data[] = {
0xff,0x80,
};

static BitmapCharRec ch16 = {9,1,(GLfloat)0,(GLfloat)-7,(GLfloat)9,ch16data};

/* char: 15 */

static GLubyte ch15data[] = {
0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0xff,0x80,0x8,0x0,
0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,0x8,0x0,
};

static BitmapCharRec ch15 = {9,15,(GLfloat)0,(GLfloat)3,(GLfloat)9,ch15data};

/* char: 14 */

static GLubyte ch14data[] = {
0xf8,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch14 = {5,9,(GLfloat)-4,(GLfloat)-3,(GLfloat)9,ch14data};

/* char: 13 */

static GLubyte ch13data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0xf8,
};

static BitmapCharRec ch13 = {5,7,(GLfloat)-4,(GLfloat)3,(GLfloat)9,ch13data};

/* char: 12 */

static GLubyte ch12data[] = {
0x8,0x8,0x8,0x8,0x8,0x8,0xf8,
};

static BitmapCharRec ch12 = {5,7,(GLfloat)0,(GLfloat)3,(GLfloat)9,ch12data};

/* char: 11 */

static GLubyte ch11data[] = {
0xf8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,0x8,
};

static BitmapCharRec ch11 = {5,9,(GLfloat)0,(GLfloat)-3,(GLfloat)9,ch11data};

/* char: 10 */

static GLubyte ch10data[] = {
0x8,0x8,0x8,0x8,0x3e,0x20,0x50,0x88,0x88,
};

static BitmapCharRec ch10 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch10data};

/* char: 9 */

static GLubyte ch9data[] = {
0x3e,0x20,0x20,0x20,0x88,0x98,0xa8,0xc8,0x88,
};

static BitmapCharRec ch9 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch9data};

/* char: 8 */

static GLubyte ch8data[] = {
0xfe,0x10,0x10,0xfe,0x10,0x10,
};

static BitmapCharRec ch8 = {7,6,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch8data};

/* char: 7 */

static GLubyte ch7data[] = {
0x70,0x88,0x88,0x70,
};

static BitmapCharRec ch7 = {5,4,(GLfloat)-2,(GLfloat)-6,(GLfloat)9,ch7data};

/* char: 6 */

static GLubyte ch6data[] = {
0x20,0x20,0x3c,0x20,0x3e,0xf8,0x80,0x80,0x80,
};

static BitmapCharRec ch6 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch6data};

/* char: 5 */

static GLubyte ch5data[] = {
0x22,0x22,0x3c,0x22,0x3c,0x78,0x80,0x80,0x78,
};

static BitmapCharRec ch5 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch5data};

/* char: 4 */

static GLubyte ch4data[] = {
0x10,0x10,0x1c,0x10,0x9e,0x80,0xe0,0x80,0xf0,
};

static BitmapCharRec ch4 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch4data};

/* char: 3 */

static GLubyte ch3data[] = {
0x8,0x8,0x8,0x3e,0x88,0x88,0xf8,0x88,0x88,
};

static BitmapCharRec ch3 = {7,9,(GLfloat)-1,(GLfloat)2,(GLfloat)9,ch3data};

/* char: 2 */

static GLubyte ch2data[] = {
0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
};

static BitmapCharRec ch2 = {8,14,(GLfloat)0,(GLfloat)3,(GLfloat)9,ch2data};

/* char: 1 */

static GLubyte ch1data[] = {
0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,
};

static BitmapCharRec ch1 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch1data};

static BitmapCharPtr chars[] = {
&ch0,
&ch1,
&ch2,
&ch3,
&ch4,
&ch5,
&ch6,
&ch7,
&ch8,
&ch9,
&ch10,
&ch11,
&ch12,
&ch13,
&ch14,
&ch15,
&ch16,
&ch17,
&ch18,
&ch19,
&ch20,
&ch21,
&ch22,
&ch23,
&ch24,
&ch25,
&ch26,
&ch27,
&ch28,
&ch29,
&ch30,
&ch31,
&ch32,
&ch33,
&ch34,
&ch35,
&ch36,
&ch37,
&ch38,
&ch39,
&ch40,
&ch41,
&ch42,
&ch43,
&ch44,
&ch45,
&ch46,
&ch47,
&ch48,
&ch49,
&ch50,
&ch51,
&ch52,
&ch53,
&ch54,
&ch55,
&ch56,
&ch57,
&ch58,
&ch59,
&ch60,
&ch61,
&ch62,
&ch63,
&ch64,
&ch65,
&ch66,
&ch67,
&ch68,
&ch69,
&ch70,
&ch71,
&ch72,
&ch73,
&ch74,
&ch75,
&ch76,
&ch77,
&ch78,
&ch79,
&ch80,
&ch81,
&ch82,
&ch83,
&ch84,
&ch85,
&ch86,
&ch87,
&ch88,
&ch89,
&ch90,
&ch91,
&ch92,
&ch93,
&ch94,
&ch95,
&ch96,
&ch97,
&ch98,
&ch99,
&ch100,
&ch101,
&ch102,
&ch103,
&ch104,
&ch105,
&ch106,
&ch107,
&ch108,
&ch109,
&ch110,
&ch111,
&ch112,
&ch113,
&ch114,
&ch115,
&ch116,
&ch117,
&ch118,
&ch119,
&ch120,
&ch121,
&ch122,
&ch123,
&ch124,
&ch125,
&ch126,
&ch127,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
&ch160,
&ch161,
&ch162,
&ch163,
&ch164,
&ch165,
&ch166,
&ch167,
&ch168,
&ch169,
&ch170,
&ch171,
&ch172,
&ch173,
&ch174,
&ch175,
&ch176,
&ch177,
&ch178,
&ch179,
&ch180,
&ch181,
&ch182,
&ch183,
&ch184,
&ch185,
&ch186,
&ch187,
&ch188,
&ch189,
&ch190,
&ch191,
&ch192,
&ch193,
&ch194,
&ch195,
&ch196,
&ch197,
&ch198,
&ch199,
&ch200,
&ch201,
&ch202,
&ch203,
&ch204,
&ch205,
&ch206,
&ch207,
&ch208,
&ch209,
&ch210,
&ch211,
&ch212,
&ch213,
&ch214,
&ch215,
&ch216,
&ch217,
&ch218,
&ch219,
&ch220,
&ch221,
&ch222,
&ch223,
&ch224,
&ch225,
&ch226,
&ch227,
&ch228,
&ch229,
&ch230,
&ch231,
&ch232,
&ch233,
&ch234,
&ch235,
&ch236,
&ch237,
&ch238,
&ch239,
&ch240,
&ch241,
&ch242,
&ch243,
&ch244,
&ch245,
&ch246,
&ch247,
&ch248,
&ch249,
&ch250,
&ch251,
&ch252,
&ch253,
&ch254,
&ch255,
};

BitmapFontRec glutBitmap9By15 = {
"-misc-fixed-medium-r-normal--15-140-75-75-C-90-iso8859-1",
256,
0,
chars
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltcindx.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include "gltint.h"

GLUTcolormap *__glutColormapList = NULL;

static GLUTcolormap *
associateNewColormap(GLUTosSurface osurf)
{
  GLUTcolormap *cmap;
  int i;

  cmap = (GLUTcolormap *) malloc(sizeof(GLUTcolormap));
  if (!cmap)
    __glutFatalError("out of memory.");
  cmap->osurf = osurf;
  cmap->size = __glutOsColormapSize(osurf);
  cmap->refcnt = 1;
  cmap->cells = (GLUTcolorcell *)
    malloc(sizeof(GLUTcolorcell) * cmap->size);
  if (!cmap->cells)
    __glutFatalError("out of memory.");
  /* make all color cell entries be invalid */
  for (i = cmap->size - 1; i >= 0; i--) {
    cmap->cells[i].component[GLUT_RED] = (GLfloat) -1.0;
    cmap->cells[i].component[GLUT_GREEN] = (GLfloat) -1.0;
    cmap->cells[i].component[GLUT_BLUE] = (GLfloat) -1.0;
  }
  cmap->ocmap = __glutOsCreateEmptyColormap(osurf);
  if (cmap->ocmap == GLUT_OS_INVALID_COLORMAP)
  {
      __glutFatalError("Unable to create emtpy colormap.");
  }
  cmap->next = __glutColormapList;
  __glutColormapList = cmap;
  return cmap;
}

GLUTcolormap *
__glutAssociateColormap(GLUTosSurface osurf)
{
  GLUTcolormap *cmap = __glutColormapList;

  while (cmap != NULL) {
    if (__glutOsSurfaceEq(cmap->osurf, osurf)) {
      /* already have created colormap for the surface */
      cmap->refcnt++;
      return cmap;
    }
    cmap = cmap->next;
  }
  return associateNewColormap(osurf);
}

static void
copyColormapCells(GLUTcolormap *dest, GLUTcolormap *src, int n)
{
  int i;

  /* Only copy cells that are set */
  for (i = n - 1; i >= 0; i--) {
    if (src->cells[i].component[GLUT_RED] >= 0.0) {
      dest->cells[i].component[GLUT_RED] =
        src->cells[i].component[GLUT_RED];
      dest->cells[i].component[GLUT_GREEN] =
        src->cells[i].component[GLUT_GREEN];
      dest->cells[i].component[GLUT_BLUE] =
        src->cells[i].component[GLUT_BLUE];
      __glutOsSetColor(dest->ocmap, i,
                       src->cells[i].component[GLUT_RED],
                       src->cells[i].component[GLUT_GREEN],
                       src->cells[i].component[GLUT_BLUE]);
    }
  }
}

#define CLAMP(i) \
    ((i) > (GLfloat) 1.0 ? \
     (GLfloat) 1.0 : \
     ((i) < (GLfloat) 0.0 ? \
      (GLfloat) 0.0 : \
      (i)))

/* CENTRY */
void
glutSetColor(int ndx, GLfloat red, GLfloat green, GLfloat blue)
{
  GLUTcolormap *cmap;
  GLUTcolormap *newcmap;

  cmap = __glutCurrentWindow->colormap;
  if (!cmap) {
    __glutWarning("glutSetColor: current window is RGBA");
    return;
  }
  if (ndx >= __glutCurrentWindow->colormap->size ||
    ndx < 0) {
    __glutWarning("glutSetColor: index %d out of range", ndx);
    return;
  }
  if (cmap->refcnt > 1) {
    GLUTwindow *toplevel;

    newcmap = associateNewColormap(__glutCurrentWindow->osurf);
    cmap->refcnt--;
    copyColormapCells(newcmap, cmap, cmap->size);
    __glutCurrentWindow->colormap = newcmap;
    __glutCurrentWindow->ocmap = newcmap->ocmap;
    __glutOsSetWindowColormap(__glutCurrentWindow->owin,
      __glutCurrentWindow->ocmap);
    toplevel = __glutToplevelOf(__glutCurrentWindow);
    if (toplevel->ocmap != __glutCurrentWindow->ocmap) {
      __glutPutOnWorkList(toplevel, GLUT_COLORMAP_WORK);
    }
    cmap = newcmap;
  }
  
  red = CLAMP(red);
  cmap->cells[ndx].component[GLUT_RED] = red;
  green = CLAMP(green);
  cmap->cells[ndx].component[GLUT_GREEN] = green;
  blue = CLAMP(blue);
  cmap->cells[ndx].component[GLUT_BLUE] = blue;
  __glutOsSetColor(cmap->ocmap, ndx, red, green, blue);
}

GLfloat
glutGetColor(int ndx, int comp)
{
  if (!__glutCurrentWindow->colormap) {
    __glutWarning("glutGetColor: current window is RGBA");
    return (GLfloat) -1.0;
  }
  if (ndx >= __glutCurrentWindow->colormap->size ||
    ndx < 0) {
    __glutWarning("glutGetColor: index %d out of range", ndx);
    return (GLfloat) -1.0;
  }
  return
    __glutCurrentWindow->colormap->cells[ndx].component[comp];
}
/* ENDCENTRY */

void
__glutFreeColormap(GLUTcolormap * cmap)
{
  GLUTcolormap *cur, **prev;

  cmap->refcnt--;
  if (cmap->refcnt == 0) {
    /* remove from colormap list */
    cur = __glutColormapList;
    prev = &__glutColormapList;
    while (cur) {
      if (cur == cmap) {
        *prev = cmap->next;
        break;
      }
      prev = &(cur->next);
      cur = cur->next;
    }
    /* actually free colormap */
    __glutOsDestroyColormap(cmap->ocmap);
    free(cmap->cells);
    free(cmap);
  }
}

/* CENTRY */
void
glutCopyColormap(int winnum)
{
  GLUTwindow *window = __glutWindowList[winnum];
  GLUTcolormap *oldcmap, *newcmap, *copycmap;
  int last;

  if (!__glutCurrentWindow->colormap) {
    __glutWarning("glutCopyColormap: current window is RGBA");
    return;
  }
  if (!window->colormap) {
    __glutWarning("glutCopyColormap: window %d is RGBA", winnum);
    return;
  }
  oldcmap = __glutCurrentWindow->colormap;
  newcmap = window->colormap;

  if (newcmap == oldcmap)
    return;

  if (__glutOsSurfaceEq(newcmap->osurf, oldcmap->osurf)) {
    GLUTwindow *toplevel;

    /* Surfaces match!  "Copy" by reference...  */
    __glutFreeColormap(oldcmap);
    newcmap->refcnt++;
    __glutCurrentWindow->colormap = newcmap;
    __glutCurrentWindow->ocmap = newcmap->ocmap;
    __glutOsSetWindowColormap(__glutCurrentWindow->owin,
      __glutCurrentWindow->ocmap);
    toplevel = __glutToplevelOf(window);
    if (toplevel->ocmap != window->ocmap) {
      __glutPutOnWorkList(toplevel, GLUT_COLORMAP_WORK);
    }
  }
  else
  {
    /* Surfaces different - need a distinct colormap! */
    copycmap = associateNewColormap(__glutCurrentWindow->osurf);
    last = newcmap->size;
    if (last > copycmap->size) {
      last = copycmap->size;
    }
    copyColormapCells(copycmap, newcmap, last);
  }
}
/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltdials.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

void
glutButtonBoxFunc(GLUTbuttonBoxCB buttonBoxFunc)
{
  __glutCurrentWindow->buttonBox = buttonBoxFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

void
glutDialsFunc(GLUTdialsCB dialsFunc)
{
  __glutCurrentWindow->dials = dialsFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltbitmp.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"
#include "gltbitmp.h"

void
glutBitmapCharacter(GLUTbitmapFont font, int c)
{
  BitmapCharPtr ch;
  BitmapFontPtr fontinfo = (BitmapFontPtr) font;
  GLint swapbytes, lsbfirst, rowlength;
  GLint skiprows, skippixels, alignment;

  if (c < fontinfo->first ||
    c >= fontinfo->first + fontinfo->num_chars)
    return;
  ch = fontinfo->ch[c - fontinfo->first];
  if (ch) {
    /* save current modes */
    glGetIntegerv(GL_UNPACK_SWAP_BYTES, &swapbytes);
    glGetIntegerv(GL_UNPACK_LSB_FIRST, &lsbfirst);
    glGetIntegerv(GL_UNPACK_ROW_LENGTH, &rowlength);
    glGetIntegerv(GL_UNPACK_SKIP_ROWS, &skiprows);
    glGetIntegerv(GL_UNPACK_SKIP_PIXELS, &skippixels);
    glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
    /* Little endian machines (DEC Alpha for example) could
       benefit from setting GL_UNPACK_LSB_FIRST to GL_TRUE
       instead of GL_FALSE, but this would require changing the
       generated bitmaps too. */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
    glPixelStorei(GL_UNPACK_LSB_FIRST, GL_FALSE);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glBitmap(ch->width, ch->height, ch->xorig, ch->yorig,
      ch->advance, (GLfloat)0, ch->bitmap);
    /* restore saved modes */
    glPixelStorei(GL_UNPACK_SWAP_BYTES, swapbytes);
    glPixelStorei(GL_UNPACK_LSB_FIRST, lsbfirst);
    glPixelStorei(GL_UNPACK_ROW_LENGTH, rowlength);
    glPixelStorei(GL_UNPACK_SKIP_ROWS, skiprows);
    glPixelStorei(GL_UNPACK_SKIP_PIXELS, skippixels);
    glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltevent.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>

#include "gltint.h"

static GLUTtimer *freeTimerList = NULL;

GLUTidleCB __glutIdleFunc = NULL;
GLUTtimer *__glutTimerList = NULL;
#ifdef SUPPORT_FORTRAN
GLUTtimer *__glutNewTimer;
#endif
GLUTwindow *__glutWindowWorkList = NULL;
void (*__glutUpdateInputDeviceMaskFunc) (GLUTwindow *);

void
glutIdleFunc(GLUTidleCB idleFunc)
{
  __glutIdleFunc = idleFunc;
}

void
glutTimerFunc(unsigned long interval, GLUTtimerCB timerFunc, int value)
{
  GLUTtimer *timer, *other;
  GLUTtimer **prevptr;

  if (!timerFunc)
    return;

  if (freeTimerList) {
    timer = freeTimerList;
    freeTimerList = timer->next;
  } else {
    timer = (GLUTtimer *) malloc(sizeof(GLUTtimer));
    if (!timer)
      __glutFatalError("out of memory.");
  }

  timer->func = timerFunc;
  timer->timeout = interval + __glutOsElapsedTime();
  timer->value = value;
  timer->next = NULL;
  prevptr = &__glutTimerList;
  other = *prevptr;
  while (other && other->timeout < timer->timeout) {
    prevptr = &other->next;
    other = *prevptr;
  }
  timer->next = other;
#ifdef SUPPORT_FORTRAN
  __glutNewTimer = timer;  /* for Fortran binding! */
#endif
  *prevptr = timer;
}

static void
handleTimeouts(void)
{
  unsigned long now;
  GLUTtimer *timer;

  if (__glutTimerList) {
    now = __glutOsElapsedTime();
    while (__glutTimerList->timeout < now) {
      timer = __glutTimerList;
      (*timer->func) (timer->value);
      __glutTimerList = timer->next;
      timer->next = freeTimerList;
      freeTimerList = timer;
      if (!__glutTimerList)
        break;
    }
  }
}

void
__glutPutOnWorkList(GLUTwindow * window, int work_mask)
{
  if (window->work_mask) {
    /* already on list; just OR in new work_mask */
    window->work_mask |= work_mask;
  } else {
    /* update work mask and add to window work list */
    window->work_mask = work_mask;
    window->prev_work_win = __glutWindowWorkList;
    __glutWindowWorkList = window;
  }
}

void
__glutPostRedisplay(GLUTwindow * window)
{
  /**
   * Only really post a redisplay if:
   *     1) There is a display func registered;
   *     2) The window is known to be currently mapped;
   * and 3) The visibility is visible (or the visibility of
   *         the window is unknown,
   *         ie. window->vis_state == -1).
   */
  if (window->display && window->map_state &&
    window->vis_state != 0) {
    __glutPutOnWorkList(window, GLUT_REDISPLAY_WORK);
  }
}

/* CENTRY */
void
glutPostRedisplay(void)
{
  __glutPostRedisplay(__glutCurrentWindow);
}

/* ENDCENTRY */


static void
idleWait(void)
{
  if (__glutOsEventsPending()) {
    __glutOsProcessEvents();
  }
  if (__glutTimerList)
    handleTimeouts();
  /* make sure idle func still exists! */
  if (__glutIdleFunc)
    (*__glutIdleFunc) ();
}

static void
processWindowWorkList(GLUTwindow * window)
{
  if (window) {
    processWindowWorkList(window->prev_work_win);
    __glutOsProcessWindowWork(window);
    if (window->work_mask & GLUT_REDISPLAY_WORK) {
      __glutSetWindow(window);
      if (window->display) {
        (*window->display) ();
      }
    }
    window->work_mask = 0;
  }
}

/* CENTRY */
void
glutMainLoop(void)
{
  if (!__glutInitialized)
    __glutFatalError("main loop entered before initialization.");
  if (!__glutWindowListSize)
    __glutFatalError(
      "main loop entered with no windows created.");
  for (;;) {
    if (__glutWindowWorkList) {
      processWindowWorkList(__glutWindowWorkList);
      __glutWindowWorkList = NULL;
    }
    if (__glutIdleFunc) {
      idleWait();
    } else {
      if (__glutTimerList) {
        __glutOsWaitForEvents(__glutTimerList->timeout);
        /* Always check for pending events, even if the wait may have
           stopped because of a timeout; otherwise we risk starving event 
           processing by continous timeouts. */
        if (__glutOsEventsPending()) {
          __glutOsProcessEvents();
        }
        handleTimeouts();
      } else {
        __glutOsProcessEvents();
      }
    }
    /* We should be careful to force a finish between each
       iteration through the GLUT main loop if indirect OpenGL 
       contexts are in use; indirect contexts tend to have *
       much longer latency because lots of OpenGL extension  *
       requests can queue up in the X protocol stream. */
    if (__glutIndirectContexts)
      glFinish();
    /* If debugging is turned on, look for OpenGL errors every 
       main loop iteration and report errors. */
    if (__glutDebug) {
      GLenum error;

      while ((error = glGetError()) != GL_NO_ERROR)
        __glutWarning("GL error: %s", gluErrorString(error));
    }
  }
}
/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltext.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <string.h>

#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

/* CENTRY */
int
glutExtensionSupported(char *extension)
{
  static const GLubyte *extensions = NULL;
  const GLubyte *start;
  GLubyte *where, *terminator;

  if (!extensions)
    extensions = glGetString(GL_EXTENSIONS);
  /* It takes a bit of care to be fool-proof about parsing the
     OpenGL extensions string.  Don't be fooled by sub-strings, 
     etc. */
  start = extensions;
  while (1) {
    where = (GLubyte *) strstr((const char *)start, extension);
    if (!where)
      return 0;
    terminator = where + strlen(extension);
    if (where == start || *(where - 1) == ' ') {
      if (*terminator == ' ' || *terminator == '\0') {
        return 1;
      }
    }
    start = terminator;
  }
  return 0;
}

/* ENDCENTRY */

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltget.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"

/* CENTRY */
int
glutGet(GLenum param)
{
  switch (param) {
    /* OS-independent information */
  case GLUT_INIT_WINDOW_X:
    return __glutInitX;
  case GLUT_INIT_WINDOW_Y:
    return __glutInitY;
  case GLUT_INIT_WINDOW_WIDTH:
    return __glutInitWidth;
  case GLUT_INIT_WINDOW_HEIGHT:
    return __glutInitHeight;
  case GLUT_INIT_DISPLAY_MODE:
    return __glutDisplayMode;
  case GLUT_WINDOW_PARENT:
    return __glutCurrentWindow->parent ?
      __glutCurrentWindow->parent->num + 1 : 0;
  case GLUT_WINDOW_NUM_CHILDREN:
    {
      int num = 0;
      GLUTwindow *children = __glutCurrentWindow->children;

      while (children) {
        num++;
        children = children->siblings;
      }
      return num;
    }
  case GLUT_MENU_NUM_ITEMS:
    return __glutCurrentMenu->num;

    /* OS-dependent information */
  case GLUT_WINDOW_X:
  case GLUT_WINDOW_Y:
  case GLUT_WINDOW_WIDTH:
  case GLUT_WINDOW_HEIGHT:
  case GLUT_WINDOW_BUFFER_SIZE:
  case GLUT_WINDOW_STENCIL_SIZE:
  case GLUT_WINDOW_DEPTH_SIZE:
  case GLUT_WINDOW_RED_SIZE:
  case GLUT_WINDOW_GREEN_SIZE:
  case GLUT_WINDOW_BLUE_SIZE:
  case GLUT_WINDOW_ALPHA_SIZE:
  case GLUT_WINDOW_ACCUM_RED_SIZE:
  case GLUT_WINDOW_ACCUM_GREEN_SIZE:
  case GLUT_WINDOW_ACCUM_BLUE_SIZE:
  case GLUT_WINDOW_ACCUM_ALPHA_SIZE:
  case GLUT_WINDOW_DOUBLEBUFFER:
  case GLUT_WINDOW_RGBA:
  case GLUT_WINDOW_COLORMAP_SIZE:
  case GLUT_SCREEN_WIDTH:
  case GLUT_SCREEN_HEIGHT:
  case GLUT_SCREEN_WIDTH_MM:
  case GLUT_SCREEN_HEIGHT_MM:
  case GLUT_DISPLAY_MODE_POSSIBLE:
#if (GLUT_API_VERSION >= 2)
  case GLUT_WINDOW_NUM_SAMPLES:
  case GLUT_WINDOW_STEREO:
  case GLUT_ENTRY_CALLBACKS:
#endif
    return __glutOsGet(param);

#if (GLUT_API_VERSION >= 2)
  case GLUT_ELAPSED_TIME:
    return (int)__glutOsElapsedTime();
#endif

  default:
    __glutWarning("invalid glutGet parameter: %d", param);
    return -1;
  }
}

#if (GLUT_API_VERSION >= 2)

int
glutDeviceGet(GLenum param)
{
  switch (param) {
  case GLUT_HAS_KEYBOARD:
  case GLUT_HAS_MOUSE:
  case GLUT_HAS_SPACEBALL:
  case GLUT_HAS_DIAL_AND_BUTTON_BOX:
  case GLUT_HAS_TABLET:
  case GLUT_NUM_MOUSE_BUTTONS:
  case GLUT_NUM_SPACEBALL_BUTTONS:
  case GLUT_NUM_BUTTON_BOX_BUTTONS:
  case GLUT_NUM_DIALS:
  case GLUT_NUM_TABLET_BUTTONS:
      return __glutOsDeviceGet(param);
  default:
    __glutWarning("invalid glutDeviceGet parameter: %d", param);
    return -1;
  }
}

#endif /* GLUT_API_VERSION */

/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltinit.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "gltint.h"

/* GLUT inter-file variables */
/* *INDENT-OFF* */
char *__glutProgramName = NULL;
int __glutArgc = 0;
char **__glutArgv = NULL;
GLboolean __glutIconic = GL_FALSE;
GLboolean __glutDebug = GL_FALSE;
GLbitfield __glutDisplayMode =
  GLUT_RGB | GLUT_SINGLE | GLUT_DEPTH;
int __glutInitWidth = 300, __glutInitHeight = 300;
int __glutInitX = -1, __glutInitY = -1;
GLboolean __glutForceDirect = GL_FALSE;
GLboolean __glutTryDirect = GL_TRUE;
GLboolean __glutInitialized = GL_FALSE;
/* *INDENT-ON* */

static void
removeArgs(int *argcp, char **argv, int numToRemove)
{
  int i, j;

  for (i = 0, j = numToRemove; argv[j]; i++, j++) {
    argv[i] = argv[j];
  }
  argv[i] = NULL;
  *argcp -= numToRemove;
}

/*
  Performs minimum initialization required for GLUT to function
  This is called in critical routines if glutInit hasn't already
  been called
  */
void
__glutRequiredInit(void)
{
  __glutOsInitialize();
  __glutInitialized = GL_TRUE;
}

void
glutInit(int *argcp, char **argv)
{
  char *str;
  int i;
  int remove;

  if (__glutInitialized) {
    __glutWarning("glutInit being called a second time.");
    return;
  }
  /* determine temporary program name */
  str = strrchr(argv[0], '/');
  if (str == NULL) {
    __glutProgramName = argv[0];
  } else {
    __glutProgramName = str + 1;
  }

  /* make private copy of command line arguments */
  __glutArgc = *argcp;
  __glutArgv = (char **) malloc(__glutArgc * sizeof(char *));
  if (!__glutArgv)
    __glutFatalError("out of memory.");
  for (i = 0; i < __glutArgc; i++) {
    __glutArgv[i] = strdup(argv[i]);
    if (!__glutArgv[i])
      __glutFatalError("out of memory.");
  }

  /* determine permanent program name */
#ifndef GLUT_WIN32
  str = strrchr(__glutArgv[0], '/');
#else
  str = strrchr(__glutArgv[0], '\\');
#endif
  if (str == NULL) {
    __glutProgramName = __glutArgv[0];
  } else {
    __glutProgramName = str + 1;
  }

  /* parse arguments for standard options */
  for (i = 1; i < __glutArgc; i++) {
    if (!strcmp(__glutArgv[i], "-direct")) {
      if (!__glutTryDirect)
        __glutFatalError(
          "cannot force both direct and indirect rendering.");
      __glutForceDirect = GL_TRUE;
      removeArgs(argcp, &argv[1], 1);
    } else if (!strcmp(__glutArgv[i], "-indirect")) {
      if (__glutForceDirect)
        __glutFatalError(
          "cannot force both direct and indirect rendering.");
      __glutTryDirect = GL_FALSE;
      removeArgs(argcp, &argv[1], 1);
    } else if (!strcmp(__glutArgv[i], "-iconic")) {
      __glutIconic = GL_TRUE;
      removeArgs(argcp, &argv[1], 1);
    } else if (!strcmp(__glutArgv[i], "-gldebug")) {
      __glutDebug = GL_TRUE;
      removeArgs(argcp, &argv[1], 1);
    } else if ((remove = __glutOsParseArgument(&__glutArgv[i],
                                               __glutArgc-i-1)) >= 0) {
      if (remove > 0)
      {
        removeArgs(argcp, &argv[1], remove);
        i += remove-1;
      }
    } else {
      /* once unknown option encountered, stop command line
         processing */
      break;
    }
  }
  __glutRequiredInit();
}

/* CENTRY */
void
glutInitWindowPosition(int x, int y)
{
  __glutInitX = x;
  __glutInitY = y;
}

void
glutInitWindowSize(int width, int height)
{
  __glutInitWidth = width;
  __glutInitHeight = height;
}

void
glutInitDisplayMode(unsigned long mask)
{
  __glutDisplayMode = mask;
}

/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltmenu.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <assert.h>

#include "gltint.h"

GLUTmenu *__glutCurrentMenu = NULL;
void (*__glutMenuStateFunc) (int);
GLUTmenu *__glutMappedMenu;
GLUTwindow *__glutMenuWindow;

static GLUTmenu **menuList = NULL;
static int menuListSize = 0;

void
glutMenuStateFunc(GLUTmenuStateCB menuStateFunc)
{
  __glutMenuStateFunc = menuStateFunc;
}

void
__glutSetMenu(GLUTmenu * menu)
{
  __glutCurrentMenu = menu;
}

GLUTmenu *
__glutGetMenuByNum(int menunum)
{
  if (menunum < 1 || menunum > menuListSize) {
    __glutWarning("Invalid menu number %d requested.", menunum);
    return NULL;
  }
  return menuList[menunum - 1];
}

GLUTmenu *
__glutGetMenuByOsMenu(GLUTosMenu omenu)
{
    int menu;

    for (menu = 0; menu < menuListSize; menu++)
    {
        if (menuList[menu]->omenu == omenu)
        {
            return menuList[menu];
        }
    }

    __glutWarning("Invalid GLUTosMenu.");
    return 0;
}

static int
getUnusedMenuSlot(void)
{
  int i;

  /* look for allocated, unused slot */
  for (i = 0; i < menuListSize; i++) {
    if (!menuList[i]) {
      return i;
    }
  }
  /* allocate a new slot */
  menuListSize++;
  menuList = (GLUTmenu **)
    realloc(menuList, menuListSize * sizeof(GLUTmenu *));
  if (!menuList)
    __glutFatalError("out of memory.");
  menuList[menuListSize - 1] = NULL;
  return menuListSize - 1;
}

int
glutCreateMenu(GLUTselectCB selectFunc)
{
  GLUTmenu *menu;
  int menuid;

  if (!__glutInitialized)
    __glutRequiredInit();
  menuid = getUnusedMenuSlot();
  menu = (GLUTmenu *) malloc(sizeof(GLUTmenu));
  if (!menu)
    __glutFatalError("out of memory.");
  menu->id = menuid;
  menu->num = 0;
  menu->select = selectFunc;
  menu->omenu = __glutOsCreateMenu();
  if (menu->omenu == GLUT_OS_INVALID_MENU)
    __glutFatalError("Unable to create menu.");
  menuList[menuid] = menu;
  __glutSetMenu(menu);
  return menuid + 1;
}

/* CENTRY */
void
glutDestroyMenu(int menunum)
{
  GLUTmenu *menu = __glutGetMenuByNum(menunum);

  assert(menu->id == menunum - 1);
  __glutOsDestroyMenu(menu->omenu);
  menuList[menunum - 1] = NULL;
  if (__glutCurrentMenu == menu) {
    __glutCurrentMenu = NULL;
  }
  free(menu);
}

int
glutGetMenu(void)
{
  if (__glutCurrentMenu) {
    return __glutCurrentMenu->id + 1;
  } else {
    return 0;
  }
}

void
glutSetMenu(int menuid)
{
  GLUTmenu *menu;

  if (menuid < 1 || menuid > menuListSize) {
    __glutWarning("glutSetMenu attempted on bogus menu.");
    return;
  }
  menu = menuList[menuid - 1];
  if (!menu) {
    __glutWarning("glutSetMenu attempted on bogus menu.");
    return;
  }
  __glutSetMenu(menu);
}
/* ENDCENTRY */

/* CENTRY */
void
glutAddMenuEntry(char *label, int value)
{
    __glutOsAddMenuEntry(__glutCurrentMenu->omenu, label, value);
    __glutCurrentMenu->num++;
}

void
glutAddSubMenu(char *label, int menu)
{
    GLUTmenu *gmenu;

    gmenu = __glutGetMenuByNum(menu);
    if (gmenu == NULL)
    {
      __glutWarning("glutAddSubmenu with bogus submenu.");
      return;
    }
    __glutOsAddSubMenu(__glutCurrentMenu->omenu, label, gmenu->omenu);
    __glutCurrentMenu->num++;
}

void
glutChangeToMenuEntry(int num, char *label, int value)
{
    __glutOsChangeToMenuEntry(__glutCurrentMenu->omenu, num, label, value);
}

void
glutChangeToSubMenu(int num, char *label, int menu)
{
    GLUTmenu *gmenu;

    gmenu = __glutGetMenuByNum(menu);
    if (gmenu == NULL)
    {
      __glutWarning("glutChangeToSubmenu with bogus submenu.");
      return;
    }
    __glutOsChangeToSubMenu(__glutCurrentMenu->omenu, num, label,
                            gmenu->omenu);
}

void
glutRemoveMenuItem(int item)
{
    __glutOsRemoveMenuEntry(__glutCurrentMenu->omenu, item);
    __glutCurrentMenu->num--;
}

void
glutAttachMenu(int button)
{
  if (__glutCurrentWindow->menu[button] < 1) {
    __glutCurrentWindow->btn_uses++;
  }
  __glutChangeWindowEventMask(
    GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK, GL_TRUE);
  __glutCurrentWindow->menu[button] = __glutCurrentMenu->id + 1;
}

void
glutDetachMenu(int button)
{
  if (__glutCurrentWindow->menu[button] > 0) {
    __glutCurrentWindow->btn_uses--;
    __glutChangeWindowEventMask(
      GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK,
      (GLboolean)(__glutCurrentWindow->btn_uses > 0));
    __glutCurrentWindow->menu[button] = 0;
  }
}
/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltint.h ===
#ifndef __glutint_h__
#define __glutint_h__

/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#define SUPPORT_FORTRAN
#endif

/* Provide forward declarations of standard types for OS-specific routines
   to use */
typedef struct _GLUTcolorcell GLUTcolorcell;
typedef struct _GLUTcolormap GLUTcolormap;
typedef struct _GLUTwindow GLUTwindow;
typedef struct _GLUTmenu GLUTmenu;

#include "gltos.h"
#include <GL/glut.h>

#define GLUT_WIND_IS_RGB(x)         (((x) & GLUT_INDEX) == 0)
#define GLUT_WIND_IS_INDEX(x)       (((x) & GLUT_INDEX) != 0)
#define GLUT_WIND_IS_SINGLE(x)      (((x) & GLUT_DOUBLE) == 0)
#define GLUT_WIND_IS_DOUBLE(x)      (((x) & GLUT_DOUBLE) != 0)
#define GLUT_WIND_IS_INDIRECT(x)    (((x) & GLUT_INDIRECT) != 0)
#define GLUT_WIND_IS_DIRECT(x)      (((x) & GLUT_INDIRECT) == 0)
#define GLUT_WIND_HAS_ACCUM(x)      (((x) & GLUT_ACCUM) != 0)
#define GLUT_WIND_HAS_ALPHA(x)      (((x) & GLUT_ALPHA) != 0)
#define GLUT_WIND_HAS_DEPTH(x)      (((x) & GLUT_DEPTH) != 0)
#define GLUT_WIND_HAS_STENCIL(x)    (((x) & GLUT_STENCIL) != 0)
#if (GLUT_API_VERSION >= 2)
#define GLUT_WIND_IS_MULTISAMPLE(x) (((x) & GLUT_MULTISAMPLE) != 0)
#define GLUT_WIND_IS_STEREO(x)      (((x) & GLUT_STEREO) != 0)
#endif

#define GLUT_MAP_WORK               (1 << 0)
#define GLUT_EVENT_MASK_WORK        (1 << 1)
#define GLUT_REDISPLAY_WORK         (1 << 2)
#define GLUT_CONFIGURE_WORK         (1 << 3)
#define GLUT_COLORMAP_WORK          (1 << 4)
#define GLUT_DEVICE_MASK_WORK	    (1 << 5)

#define GLUT_MAX_MENUS              3

/* GLUT implementation supported callback calling conventions */
#define GLUT_ANSI_C                 0
#define GLUT_FORTRAN                1

/* GLUT callback function types */
typedef void (*GLUTdisplayCB) (void);
typedef void (*GLUTreshapeCB) (int, int);
typedef void (*GLUTkeyboardCB) (unsigned char, int, int);
typedef void (*GLUTmouseCB) (int, int, int, int);
typedef void (*GLUTmotionCB) (int, int);
typedef void (*GLUTpassiveCB) (int, int);
typedef void (*GLUTentryCB) (int);
typedef void (*GLUTvisibilityCB) (int);
typedef void (*GLUTidleCB) (void);
typedef void (*GLUTtimerCB) (int);
typedef void (*GLUTmenuStateCB) (int);
typedef void (*GLUTselectCB) (int);
#if (GLUT_API_VERSION >= 2)
typedef void (*GLUTspecialCB) (int, int, int);
typedef void (*GLUTspaceMotionCB) (int, int, int);
typedef void (*GLUTspaceRotateCB) (int, int, int);
typedef void (*GLUTspaceButtonCB) (int, int);
typedef void (*GLUTdialsCB) (int, int);
typedef void (*GLUTbuttonBoxCB) (int, int);
typedef void (*GLUTtabletMotionCB) (int, int);
typedef void (*GLUTtabletButtonCB) (int, int, int, int);
#endif

#ifdef SUPPORT_FORTRAN
typedef void (*GLUTdisplayFCB) (void);
typedef void (*GLUTreshapeFCB) (int *, int *);
/* NOTE the pressed key is int, not unsigned char for Fortran! */
typedef void (*GLUTkeyboardFCB) (int *, int *, int *);
typedef void (*GLUTmouseFCB) (int *, int *, int *, int *);
typedef void (*GLUTmotionFCB) (int *, int *);
typedef void (*GLUTpassiveFCB) (int *, int *);
typedef void (*GLUTentryFCB) (int *);
typedef void (*GLUTvisibilityFCB) (int *);
typedef void (*GLUTidleFCB) (void);
typedef void (*GLUTtimerFCB) (int *);
typedef void (*GLUTmenuStateFCB) (int *);
typedef void (*GLUTselectFCB) (int *);
#if (GLUT_API_VERSION >= 2)
typedef void (*GLUTspecialFCB) (int *, int *, int *);
typedef void (*GLUTspaceMotionFCB) (int *, int *, int *);
typedef void (*GLUTspaceRotateFCB) (int *, int *, int *);
typedef void (*GLUTspaceButtonFCB) (int *, int *);
typedef void (*GLUTdialsFCB) (int *, int *);
typedef void (*GLUTbuttonBoxFCB) (int *, int *);
typedef void (*GLUTtabletMotionFCB) (int *, int *);
typedef void (*GLUTtabletButtonFCB) (int *, int *, int *, int *);
#endif
#endif

struct _GLUTcolorcell {
  /* GLUT_RED, GLUT_GREEN, GLUT_BLUE */
  GLfloat component[3];
};

struct _GLUTcolormap {
  GLUTosColormap ocmap; /* Windowing system colormap */
  GLUTosSurface osurf;  /* Surface description */
  int refcnt;           /* number of windows using colormap */
  int size;             /* number of cells in colormap */
  GLUTcolorcell *cells; /* array of cells */
  GLUTcolormap *next;   /* next colormap in list */
};

struct _GLUTwindow {
  GLUTosWindow owin;    /* Windowing system window */
  GLUTosGlContext octx; /* GL rendering context */
  GLUTosColormap ocmap; /* TrueColor colormap for window; None
                           if CI */
  GLUTosSurface osurf;  /* Window surface description */
  int num;              /* small integer window id (0-based) */
  GLboolean fakeSingle; /* faking single buffer with double */
  GLUTwindow *parent;   /* parent window */
  GLUTwindow *children; /* list of children */
  GLUTwindow *siblings; /* list of siblings */
  GLsizei width;        /* window width in pixels */
  GLsizei height;       /* window height in pixels */
  GLUTdisplayCB display;  /* redraw callback */
  GLUTreshapeCB reshape;  /* resize callback (width,height) */
  GLUTmouseCB mouse;    /* mouse callback (button,state,x,y) */
  GLUTmotionCB motion;  /* motion callback (x,y) */
  GLUTpassiveCB passive;  /* passive motion callback (x,y) */
  GLUTentryCB entry;    /* window entry/exit callback (state) */
  GLUTkeyboardCB keyboard;  /* keyboard callback (ASCII,x,y) */
  GLUTvisibilityCB visibility;  /* visibility callback */
#if (GLUT_API_VERSION >= 2)
  GLUTspecialCB special;  /* special key callback */
  GLUTbuttonBoxCB buttonBox;  /* button box callback */
  GLUTdialsCB dials;    /* dials callback */
  GLUTspaceMotionCB spaceMotion;  /* Spaceball motion callback */
  GLUTspaceRotateCB spaceRotate;  /* Spaceball rotate callback */
  GLUTspaceButtonCB spaceButton;  /* Spaceball button callback */
  GLUTtabletMotionCB tabletMotion;  /* tablet motion callback */
  GLUTtabletButtonCB tabletButton;  /* tablet button callback */
  int tabletPos[2];     /* tablet position (-1 is invalid) */
#endif
  GLboolean map_state;  /* map state */
  int vis_state;        /* visibility state (-1 is unknown) */
  int btn_uses;         /* number of button uses, ref cnt */
  int work_mask;        /* mask of window work to be done */
  GLUTwindow *prev_work_win;  /* link list of windows to work 
                                 on */
  GLboolean desired_map_state;  /* how to mapped window if on map
                              work list */
  int desired_conf_mask;  /* mask of desired window
                             configuration */
  int desired_x;        /* desired X location */
  int desired_y;        /* desired Y location */
  int desired_width;    /* desired window width */
  int desired_height;   /* desired window height */
  int desired_stack;    /* desired window stack */
  int menu[GLUT_MAX_MENUS];  /* attatched menu nums */
  GLUTcolormap *colormap;  /* colormap; NULL if RGBA */
  long event_mask;      /* mask of event types selected for */
#ifdef SUPPORT_FORTRAN
  /* special Fortran display callback unneeded since no
     parameters! */
  GLUTreshapeFCB freshape;  /* Fortran reshape callback */
  GLUTmouseFCB fmouse;  /* Fortran mouse callback */
  GLUTmotionFCB fmotion;  /* Fortran motion callback */
  GLUTpassiveFCB fpassive;  /* Fortran passive callback */
  GLUTentryFCB fentry;  /* Fortran entry callback */
  GLUTkeyboardFCB fkeyboard;  /* Fortran keyboard callback */
  GLUTvisibilityFCB fvisibility;  /* Fortran visibility
                                     callback */
#if (GLUT_API_VERSION >= 2)
  GLUTspecialFCB fspecial;  /* special key callback */
  GLUTbuttonBoxFCB fbuttonBox;  /* button box callback */
  GLUTdialsFCB fdials;  /* dials callback */
  GLUTspaceMotionFCB fspaceMotion;  /* Spaceball motion
                                       callback */
  GLUTspaceRotateFCB fspaceRotate;  /* Spaceball rotate
                                       callback */
  GLUTspaceButtonFCB fspaceButton;  /* Spaceball button
                                       callback */
  GLUTtabletMotionFCB ftabletMotion;  /* tablet motion callback 
                                       */
  GLUTtabletButtonFCB ftabletButton;  /* tablet button callback 
                                       */
#endif
#endif
};

struct _GLUTmenu {
  GLUTosMenu omenu;     /* Windowing system resource for the menu */
  int id;               /* small integer menu id */
  int num;              /* number of entries */
  GLUTselectCB select;  /* callback function of menu */
#ifdef SUPPORT_FORTRAN
  GLUTselectFCB fselect;  /* callback function of menu */
#endif
};

typedef struct _GLUTtimer GLUTtimer;
struct _GLUTtimer {
  GLUTtimerCB func;     /* timer callback (value) */
  unsigned long timeout;/* time remaining */
  int value;            /* callback return value */
  GLUTtimer *next;      /* list of timers */
#ifdef SUPPORT_FORTRAN
  GLUTtimerFCB ffunc;   /* Fortran timer callback */
#endif
};

/* private variables from glut_event.c */
extern GLUTwindow *__glutWindowWorkList;
#ifdef SUPPORT_FORTRAN
extern GLUTtimer *__glutTimerList;
extern GLUTtimer *__glutNewTimer;
#endif

/* private variables from glut_init.c */
extern GLbitfield __glutDisplayMode;
extern GLboolean __glutDebug;
extern GLboolean __glutForceDirect;
extern GLboolean __glutIconic;
extern GLboolean __glutTryDirect;
extern GLboolean __glutInitialized;
extern char **__glutArgv;
extern char *__glutProgramName;
extern int __glutArgc;
extern int __glutInitHeight;
extern int __glutInitWidth;
extern int __glutInitX;
extern int __glutInitY;

/* private variables from glut_menu.c */
extern GLUTmenu *__glutCurrentMenu;
extern GLUTmenu *__glutMappedMenu;
extern GLUTwindow *__glutMenuWindow;
extern void (*__glutMenuStateFunc) (int);

/* private variables from glut_win.c */
extern GLUTwindow **__glutWindowList;
extern GLUTwindow *__glutCurrentWindow;
extern int __glutIndirectContexts;
extern int __glutWindowListSize;
extern GLUTreshapeCB __glutDefaultReshape;

/* private routines from glut_cindex.c */
extern GLUTcolormap *__glutAssociateColormap(GLUTosSurface osurf);
extern void __glutFreeColormap(GLUTcolormap *);

/* private routines from glut_event.c */
extern void (*__glutUpdateInputDeviceMaskFunc) (GLUTwindow *window);
extern void __glutPutOnWorkList(GLUTwindow * window,
  int work_mask);

/* private routines from glut_init.c */
extern void __glutRequiredInit(void);
extern void __glutPostRedisplay(GLUTwindow * window);

/* private routines for glut_menu.c */
extern GLUTmenu *__glutGetMenuByNum(int menunum);
extern void __glutSetMenu(GLUTmenu * menu);
extern GLUTmenu * __glutGetMenuByOsMenu(GLUTosMenu omenu);

/* private routines from glut_util.c */
extern void __glutFatalError(char *format,...);
extern void __glutWarning(char *format,...);

/* private routines from glut_win.c */
extern void __glutChangeWindowEventMask(long mask, GLboolean add);
extern GLUTwindow *__glutGetWindow(GLUTosWindow owin);
extern GLUTwindow *__glutToplevelOf(GLUTwindow * window);
extern void __glutSetWindow(GLUTwindow * window);
extern void __glutReshapeFunc(GLUTreshapeCB reshapeFunc,
  int callingConvention);

#endif /* __glutint_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltmromn.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltstrke.h"

/* char: 33 '!' */

static CoordRec char33_stroke0[] = {
    { (float)52.381, (float)100 },
    { (float)52.381, (float)33.3333 },
};

static CoordRec char33_stroke1[] = {
    { (float)52.381, (float)9.5238 },
    { (float)47.6191, (float)4.7619 },
    { (float)52.381, (float)0 },
    { (float)57.1429, (float)4.7619 },
    { (float)52.381, (float)9.5238 },
};

static StrokeRec char33[] = {
   { 2, char33_stroke0 },
   { 5, char33_stroke1 },
};

/* char: 34 '"' */

static CoordRec char34_stroke0[] = {
    { (float)33.3334, (float)100 },
    { (float)33.3334, (float)66.6667 },
};

static CoordRec char34_stroke1[] = {
    { (float)71.4286, (float)100 },
    { (float)71.4286, (float)66.6667 },
};

static StrokeRec char34[] = {
   { 2, char34_stroke0 },
   { 2, char34_stroke1 },
};

/* char: 35 '#' */

static CoordRec char35_stroke0[] = {
    { (float)54.7619, (float)119.048 },
    { (float)21.4286, (float)-33.3333 },
};

static CoordRec char35_stroke1[] = {
    { (float)83.3334, (float)119.048 },
    { (float)50, (float)-33.3333 },
};

static CoordRec char35_stroke2[] = {
    { (float)21.4286, (float)57.1429 },
    { (float)88.0952, (float)57.1429 },
};

static CoordRec char35_stroke3[] = {
    { (float)16.6667, (float)28.5714 },
    { (float)83.3334, (float)28.5714 },
};

static StrokeRec char35[] = {
   { 2, char35_stroke0 },
   { 2, char35_stroke1 },
   { 2, char35_stroke2 },
   { 2, char35_stroke3 },
};

/* char: 36 '$' */

static CoordRec char36_stroke0[] = {
    { (float)42.8571, (float)119.048 },
    { (float)42.8571, (float)-19.0476 },
};

static CoordRec char36_stroke1[] = {
    { (float)61.9047, (float)119.048 },
    { (float)61.9047, (float)-19.0476 },
};

static CoordRec char36_stroke2[] = {
    { (float)85.7143, (float)85.7143 },
    { (float)76.1905, (float)95.2381 },
    { (float)61.9047, (float)100 },
    { (float)42.8571, (float)100 },
    { (float)28.5714, (float)95.2381 },
    { (float)19.0476, (float)85.7143 },
    { (float)19.0476, (float)76.1905 },
    { (float)23.8095, (float)66.6667 },
    { (float)28.5714, (float)61.9048 },
    { (float)38.0952, (float)57.1429 },
    { (float)66.6666, (float)47.619 },
    { (float)76.1905, (float)42.8571 },
    { (float)80.9524, (float)38.0952 },
    { (float)85.7143, (float)28.5714 },
    { (float)85.7143, (float)14.2857 },
    { (float)76.1905, (float)4.7619 },
    { (float)61.9047, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)28.5714, (float)4.7619 },
    { (float)19.0476, (float)14.2857 },
};

static StrokeRec char36[] = {
   { 2, char36_stroke0 },
   { 2, char36_stroke1 },
   { 20, char36_stroke2 },
};

/* char: 37 '%' */

static CoordRec char37_stroke0[] = {
    { (float)95.2381, (float)100 },
    { (float)9.5238, (float)0 },
};

static CoordRec char37_stroke1[] = {
    { (float)33.3333, (float)100 },
    { (float)42.8571, (float)90.4762 },
    { (float)42.8571, (float)80.9524 },
    { (float)38.0952, (float)71.4286 },
    { (float)28.5714, (float)66.6667 },
    { (float)19.0476, (float)66.6667 },
    { (float)9.5238, (float)76.1905 },
    { (float)9.5238, (float)85.7143 },
    { (float)14.2857, (float)95.2381 },
    { (float)23.8095, (float)100 },
    { (float)33.3333, (float)100 },
    { (float)42.8571, (float)95.2381 },
    { (float)57.1428, (float)90.4762 },
    { (float)71.4286, (float)90.4762 },
    { (float)85.7143, (float)95.2381 },
    { (float)95.2381, (float)100 },
};

static CoordRec char37_stroke2[] = {
    { (float)76.1905, (float)33.3333 },
    { (float)66.6667, (float)28.5714 },
    { (float)61.9048, (float)19.0476 },
    { (float)61.9048, (float)9.5238 },
    { (float)71.4286, (float)0 },
    { (float)80.9524, (float)0 },
    { (float)90.4762, (float)4.7619 },
    { (float)95.2381, (float)14.2857 },
    { (float)95.2381, (float)23.8095 },
    { (float)85.7143, (float)33.3333 },
    { (float)76.1905, (float)33.3333 },
};

static StrokeRec char37[] = {
   { 2, char37_stroke0 },
   { 16, char37_stroke1 },
   { 11, char37_stroke2 },
};

/* char: 38 '&' */

static CoordRec char38_stroke0[] = {
    { (float)100, (float)57.1429 },
    { (float)100, (float)61.9048 },
    { (float)95.2381, (float)66.6667 },
    { (float)90.4762, (float)66.6667 },
    { (float)85.7143, (float)61.9048 },
    { (float)80.9524, (float)52.381 },
    { (float)71.4286, (float)28.5714 },
    { (float)61.9048, (float)14.2857 },
    { (float)52.3809, (float)4.7619 },
    { (float)42.8571, (float)0 },
    { (float)23.8095, (float)0 },
    { (float)14.2857, (float)4.7619 },
    { (float)9.5238, (float)9.5238 },
    { (float)4.7619, (float)19.0476 },
    { (float)4.7619, (float)28.5714 },
    { (float)9.5238, (float)38.0952 },
    { (float)14.2857, (float)42.8571 },
    { (float)47.619, (float)61.9048 },
    { (float)52.3809, (float)66.6667 },
    { (float)57.1429, (float)76.1905 },
    { (float)57.1429, (float)85.7143 },
    { (float)52.3809, (float)95.2381 },
    { (float)42.8571, (float)100 },
    { (float)33.3333, (float)95.2381 },
    { (float)28.5714, (float)85.7143 },
    { (float)28.5714, (float)76.1905 },
    { (float)33.3333, (float)61.9048 },
    { (float)42.8571, (float)47.619 },
    { (float)66.6667, (float)14.2857 },
    { (float)76.1905, (float)4.7619 },
    { (float)85.7143, (float)0 },
    { (float)95.2381, (float)0 },
    { (float)100, (float)4.7619 },
    { (float)100, (float)9.5238 },
};

static StrokeRec char38[] = {
   { 34, char38_stroke0 },
};

/* char: 39 ''' */

static CoordRec char39_stroke0[] = {
    { (float)52.381, (float)100 },
    { (float)52.381, (float)66.6667 },
};

static StrokeRec char39[] = {
   { 2, char39_stroke0 },
};

/* char: 40 '(' */

static CoordRec char40_stroke0[] = {
    { (float)69.0476, (float)119.048 },
    { (float)59.5238, (float)109.524 },
    { (float)50, (float)95.2381 },
    { (float)40.4762, (float)76.1905 },
    { (float)35.7143, (float)52.381 },
    { (float)35.7143, (float)33.3333 },
    { (float)40.4762, (float)9.5238 },
    { (float)50, (float)-9.5238 },
    { (float)59.5238, (float)-23.8095 },
    { (float)69.0476, (float)-33.3333 },
};

static StrokeRec char40[] = {
   { 10, char40_stroke0 },
};

/* char: 41 ')' */

static CoordRec char41_stroke0[] = {
    { (float)35.7143, (float)119.048 },
    { (float)45.2381, (float)109.524 },
    { (float)54.7619, (float)95.2381 },
    { (float)64.2857, (float)76.1905 },
    { (float)69.0476, (float)52.381 },
    { (float)69.0476, (float)33.3333 },
    { (float)64.2857, (float)9.5238 },
    { (float)54.7619, (float)-9.5238 },
    { (float)45.2381, (float)-23.8095 },
    { (float)35.7143, (float)-33.3333 },
};

static StrokeRec char41[] = {
   { 10, char41_stroke0 },
};

/* char: 42 '*' */

static CoordRec char42_stroke0[] = {
    { (float)52.381, (float)71.4286 },
    { (float)52.381, (float)14.2857 },
};

static CoordRec char42_stroke1[] = {
    { (float)28.5715, (float)57.1429 },
    { (float)76.1905, (float)28.5714 },
};

static CoordRec char42_stroke2[] = {
    { (float)76.1905, (float)57.1429 },
    { (float)28.5715, (float)28.5714 },
};

static StrokeRec char42[] = {
   { 2, char42_stroke0 },
   { 2, char42_stroke1 },
   { 2, char42_stroke2 },
};

/* char: 43 '+' */

static CoordRec char43_stroke0[] = {
    { (float)52.3809, (float)85.7143 },
    { (float)52.3809, (float)0 },
};

static CoordRec char43_stroke1[] = {
    { (float)9.5238, (float)42.8571 },
    { (float)95.2381, (float)42.8571 },
};

static StrokeRec char43[] = {
   { 2, char43_stroke0 },
   { 2, char43_stroke1 },
};

/* char: 44 ',' */

static CoordRec char44_stroke0[] = {
    { (float)57.1429, (float)4.7619 },
    { (float)52.381, (float)0 },
    { (float)47.6191, (float)4.7619 },
    { (float)52.381, (float)9.5238 },
    { (float)57.1429, (float)4.7619 },
    { (float)57.1429, (float)-4.7619 },
    { (float)52.381, (float)-14.2857 },
    { (float)47.6191, (float)-19.0476 },
};

static StrokeRec char44[] = {
   { 8, char44_stroke0 },
};

/* char: 45 '-' */

static CoordRec char45_stroke0[] = {
    { (float)9.5238, (float)42.8571 },
    { (float)95.2381, (float)42.8571 },
};

static StrokeRec char45[] = {
   { 2, char45_stroke0 },
};

/* char: 46 '.' */

static CoordRec char46_stroke0[] = {
    { (float)52.381, (float)9.5238 },
    { (float)47.6191, (float)4.7619 },
    { (float)52.381, (float)0 },
    { (float)57.1429, (float)4.7619 },
    { (float)52.381, (float)9.5238 },
};

static StrokeRec char46[] = {
   { 5, char46_stroke0 },
};

/* char: 47 '/' */

static CoordRec char47_stroke0[] = {
    { (float)19.0476, (float)-14.2857 },
    { (float)85.7143, (float)100 },
};

static StrokeRec char47[] = {
   { 2, char47_stroke0 },
};

/* char: 48 '0' */

static CoordRec char48_stroke0[] = {
    { (float)47.619, (float)100 },
    { (float)33.3333, (float)95.2381 },
    { (float)23.8095, (float)80.9524 },
    { (float)19.0476, (float)57.1429 },
    { (float)19.0476, (float)42.8571 },
    { (float)23.8095, (float)19.0476 },
    { (float)33.3333, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)57.1428, (float)0 },
    { (float)71.4286, (float)4.7619 },
    { (float)80.9524, (float)19.0476 },
    { (float)85.7143, (float)42.8571 },
    { (float)85.7143, (float)57.1429 },
    { (float)80.9524, (float)80.9524 },
    { (float)71.4286, (float)95.2381 },
    { (float)57.1428, (float)100 },
    { (float)47.619, (float)100 },
};

static StrokeRec char48[] = {
   { 17, char48_stroke0 },
};

/* char: 49 '1' */

static CoordRec char49_stroke0[] = {
    { (float)40.4762, (float)80.9524 },
    { (float)50, (float)85.7143 },
    { (float)64.2857, (float)100 },
    { (float)64.2857, (float)0 },
};

static StrokeRec char49[] = {
   { 4, char49_stroke0 },
};

/* char: 50 '2' */

static CoordRec char50_stroke0[] = {
    { (float)23.8095, (float)76.1905 },
    { (float)23.8095, (float)80.9524 },
    { (float)28.5714, (float)90.4762 },
    { (float)33.3333, (float)95.2381 },
    { (float)42.8571, (float)100 },
    { (float)61.9047, (float)100 },
    { (float)71.4286, (float)95.2381 },
    { (float)76.1905, (float)90.4762 },
    { (float)80.9524, (float)80.9524 },
    { (float)80.9524, (float)71.4286 },
    { (float)76.1905, (float)61.9048 },
    { (float)66.6666, (float)47.619 },
    { (float)19.0476, (float)0 },
    { (float)85.7143, (float)0 },
};

static StrokeRec char50[] = {
   { 14, char50_stroke0 },
};

/* char: 51 '3' */

static CoordRec char51_stroke0[] = {
    { (float)28.5714, (float)100 },
    { (float)80.9524, (float)100 },
    { (float)52.3809, (float)61.9048 },
    { (float)66.6666, (float)61.9048 },
    { (float)76.1905, (float)57.1429 },
    { (float)80.9524, (float)52.381 },
    { (float)85.7143, (float)38.0952 },
    { (float)85.7143, (float)28.5714 },
    { (float)80.9524, (float)14.2857 },
    { (float)71.4286, (float)4.7619 },
    { (float)57.1428, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)28.5714, (float)4.7619 },
    { (float)23.8095, (float)9.5238 },
    { (float)19.0476, (float)19.0476 },
};

static StrokeRec char51[] = {
   { 15, char51_stroke0 },
};

/* char: 52 '4' */

static CoordRec char52_stroke0[] = {
    { (float)64.2857, (float)100 },
    { (float)16.6667, (float)33.3333 },
    { (float)88.0952, (float)33.3333 },
};

static CoordRec char52_stroke1[] = {
    { (float)64.2857, (float)100 },
    { (float)64.2857, (float)0 },
};

static StrokeRec char52[] = {
   { 3, char52_stroke0 },
   { 2, char52_stroke1 },
};

/* char: 53 '5' */

static CoordRec char53_stroke0[] = {
    { (float)76.1905, (float)100 },
    { (float)28.5714, (float)100 },
    { (float)23.8095, (float)57.1429 },
    { (float)28.5714, (float)61.9048 },
    { (float)42.8571, (float)66.6667 },
    { (float)57.1428, (float)66.6667 },
    { (float)71.4286, (float)61.9048 },
    { (float)80.9524, (float)52.381 },
    { (float)85.7143, (float)38.0952 },
    { (float)85.7143, (float)28.5714 },
    { (float)80.9524, (float)14.2857 },
    { (float)71.4286, (float)4.7619 },
    { (float)57.1428, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)28.5714, (float)4.7619 },
    { (float)23.8095, (float)9.5238 },
    { (float)19.0476, (float)19.0476 },
};

static StrokeRec char53[] = {
   { 17, char53_stroke0 },
};

/* char: 54 '6' */

static CoordRec char54_stroke0[] = {
    { (float)78.5714, (float)85.7143 },
    { (float)73.8096, (float)95.2381 },
    { (float)59.5238, (float)100 },
    { (float)50, (float)100 },
    { (float)35.7143, (float)95.2381 },
    { (float)26.1905, (float)80.9524 },
    { (float)21.4286, (float)57.1429 },
    { (float)21.4286, (float)33.3333 },
    { (float)26.1905, (float)14.2857 },
    { (float)35.7143, (float)4.7619 },
    { (float)50, (float)0 },
    { (float)54.7619, (float)0 },
    { (float)69.0476, (float)4.7619 },
    { (float)78.5714, (float)14.2857 },
    { (float)83.3334, (float)28.5714 },
    { (float)83.3334, (float)33.3333 },
    { (float)78.5714, (float)47.619 },
    { (float)69.0476, (float)57.1429 },
    { (float)54.7619, (float)61.9048 },
    { (float)50, (float)61.9048 },
    { (float)35.7143, (float)57.1429 },
    { (float)26.1905, (float)47.619 },
    { (float)21.4286, (float)33.3333 },
};

static StrokeRec char54[] = {
   { 23, char54_stroke0 },
};

/* char: 55 '7' */

static CoordRec char55_stroke0[] = {
    { (float)85.7143, (float)100 },
    { (float)38.0952, (float)0 },
};

static CoordRec char55_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)100 },
};

static StrokeRec char55[] = {
   { 2, char55_stroke0 },
   { 2, char55_stroke1 },
};

/* char: 56 '8' */

static CoordRec char56_stroke0[] = {
    { (float)42.8571, (float)100 },
    { (float)28.5714, (float)95.2381 },
    { (float)23.8095, (float)85.7143 },
    { (float)23.8095, (float)76.1905 },
    { (float)28.5714, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)57.1428, (float)57.1429 },
    { (float)71.4286, (float)52.381 },
    { (float)80.9524, (float)42.8571 },
    { (float)85.7143, (float)33.3333 },
    { (float)85.7143, (float)19.0476 },
    { (float)80.9524, (float)9.5238 },
    { (float)76.1905, (float)4.7619 },
    { (float)61.9047, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)28.5714, (float)4.7619 },
    { (float)23.8095, (float)9.5238 },
    { (float)19.0476, (float)19.0476 },
    { (float)19.0476, (float)33.3333 },
    { (float)23.8095, (float)42.8571 },
    { (float)33.3333, (float)52.381 },
    { (float)47.619, (float)57.1429 },
    { (float)66.6666, (float)61.9048 },
    { (float)76.1905, (float)66.6667 },
    { (float)80.9524, (float)76.1905 },
    { (float)80.9524, (float)85.7143 },
    { (float)76.1905, (float)95.2381 },
    { (float)61.9047, (float)100 },
    { (float)42.8571, (float)100 },
};

static StrokeRec char56[] = {
   { 29, char56_stroke0 },
};

/* char: 57 '9' */

static CoordRec char57_stroke0[] = {
    { (float)83.3334, (float)66.6667 },
    { (float)78.5714, (float)52.381 },
    { (float)69.0476, (float)42.8571 },
    { (float)54.7619, (float)38.0952 },
    { (float)50, (float)38.0952 },
    { (float)35.7143, (float)42.8571 },
    { (float)26.1905, (float)52.381 },
    { (float)21.4286, (float)66.6667 },
    { (float)21.4286, (float)71.4286 },
    { (float)26.1905, (float)85.7143 },
    { (float)35.7143, (float)95.2381 },
    { (float)50, (float)100 },
    { (float)54.7619, (float)100 },
    { (float)69.0476, (float)95.2381 },
    { (float)78.5714, (float)85.7143 },
    { (float)83.3334, (float)66.6667 },
    { (float)83.3334, (float)42.8571 },
    { (float)78.5714, (float)19.0476 },
    { (float)69.0476, (float)4.7619 },
    { (float)54.7619, (float)0 },
    { (float)45.2381, (float)0 },
    { (float)30.9524, (float)4.7619 },
    { (float)26.1905, (float)14.2857 },
};

static StrokeRec char57[] = {
   { 23, char57_stroke0 },
};

/* char: 58 ':' */

static CoordRec char58_stroke0[] = {
    { (float)52.381, (float)66.6667 },
    { (float)47.6191, (float)61.9048 },
    { (float)52.381, (float)57.1429 },
    { (float)57.1429, (float)61.9048 },
    { (float)52.381, (float)66.6667 },
};

static CoordRec char58_stroke1[] = {
    { (float)52.381, (float)9.5238 },
    { (float)47.6191, (float)4.7619 },
    { (float)52.381, (float)0 },
    { (float)57.1429, (float)4.7619 },
    { (float)52.381, (float)9.5238 },
};

static StrokeRec char58[] = {
   { 5, char58_stroke0 },
   { 5, char58_stroke1 },
};

/* char: 59 ';' */

static CoordRec char59_stroke0[] = {
    { (float)52.381, (float)66.6667 },
    { (float)47.6191, (float)61.9048 },
    { (float)52.381, (float)57.1429 },
    { (float)57.1429, (float)61.9048 },
    { (float)52.381, (float)66.6667 },
};

static CoordRec char59_stroke1[] = {
    { (float)57.1429, (float)4.7619 },
    { (float)52.381, (float)0 },
    { (float)47.6191, (float)4.7619 },
    { (float)52.381, (float)9.5238 },
    { (float)57.1429, (float)4.7619 },
    { (float)57.1429, (float)-4.7619 },
    { (float)52.381, (float)-14.2857 },
    { (float)47.6191, (float)-19.0476 },
};

static StrokeRec char59[] = {
   { 5, char59_stroke0 },
   { 8, char59_stroke1 },
};

/* char: 60 '<' */

static CoordRec char60_stroke0[] = {
    { (float)90.4762, (float)85.7143 },
    { (float)14.2857, (float)42.8571 },
    { (float)90.4762, (float)0 },
};

static StrokeRec char60[] = {
   { 3, char60_stroke0 },
};

/* char: 61 '=' */

static CoordRec char61_stroke0[] = {
    { (float)9.5238, (float)57.1429 },
    { (float)95.2381, (float)57.1429 },
};

static CoordRec char61_stroke1[] = {
    { (float)9.5238, (float)28.5714 },
    { (float)95.2381, (float)28.5714 },
};

static StrokeRec char61[] = {
   { 2, char61_stroke0 },
   { 2, char61_stroke1 },
};

/* char: 62 '>' */

static CoordRec char62_stroke0[] = {
    { (float)14.2857, (float)85.7143 },
    { (float)90.4762, (float)42.8571 },
    { (float)14.2857, (float)0 },
};

static StrokeRec char62[] = {
   { 3, char62_stroke0 },
};

/* char: 63 '?' */

static CoordRec char63_stroke0[] = {
    { (float)23.8095, (float)76.1905 },
    { (float)23.8095, (float)80.9524 },
    { (float)28.5714, (float)90.4762 },
    { (float)33.3333, (float)95.2381 },
    { (float)42.8571, (float)100 },
    { (float)61.9047, (float)100 },
    { (float)71.4285, (float)95.2381 },
    { (float)76.1905, (float)90.4762 },
    { (float)80.9524, (float)80.9524 },
    { (float)80.9524, (float)71.4286 },
    { (float)76.1905, (float)61.9048 },
    { (float)71.4285, (float)57.1429 },
    { (float)52.3809, (float)47.619 },
    { (float)52.3809, (float)33.3333 },
};

static CoordRec char63_stroke1[] = {
    { (float)52.3809, (float)9.5238 },
    { (float)47.619, (float)4.7619 },
    { (float)52.3809, (float)0 },
    { (float)57.1428, (float)4.7619 },
    { (float)52.3809, (float)9.5238 },
};

static StrokeRec char63[] = {
   { 14, char63_stroke0 },
   { 5, char63_stroke1 },
};

/* char: 64 '@' */

static CoordRec char64_stroke0[] = {
    { (float)64.2857, (float)52.381 },
    { (float)54.7619, (float)57.1429 },
    { (float)45.2381, (float)57.1429 },
    { (float)40.4762, (float)47.619 },
    { (float)40.4762, (float)42.8571 },
    { (float)45.2381, (float)33.3333 },
    { (float)54.7619, (float)33.3333 },
    { (float)64.2857, (float)38.0952 },
};

static CoordRec char64_stroke1[] = {
    { (float)64.2857, (float)57.1429 },
    { (float)64.2857, (float)38.0952 },
    { (float)69.0476, (float)33.3333 },
    { (float)78.5714, (float)33.3333 },
    { (float)83.3334, (float)42.8571 },
    { (float)83.3334, (float)47.619 },
    { (float)78.5714, (float)61.9048 },
    { (float)69.0476, (float)71.4286 },
    { (float)54.7619, (float)76.1905 },
    { (float)50, (float)76.1905 },
    { (float)35.7143, (float)71.4286 },
    { (float)26.1905, (float)61.9048 },
    { (float)21.4286, (float)47.619 },
    { (float)21.4286, (float)42.8571 },
    { (float)26.1905, (float)28.5714 },
    { (float)35.7143, (float)19.0476 },
    { (float)50, (float)14.2857 },
    { (float)54.7619, (float)14.2857 },
    { (float)69.0476, (float)19.0476 },
};

static StrokeRec char64[] = {
   { 8, char64_stroke0 },
   { 19, char64_stroke1 },
};

/* char: 65 'A' */

static CoordRec char65_stroke0[] = {
    { (float)52.3809, (float)100 },
    { (float)14.2857, (float)0 },
};

static CoordRec char65_stroke1[] = {
    { (float)52.3809, (float)100 },
    { (float)90.4762, (float)0 },
};

static CoordRec char65_stroke2[] = {
    { (float)28.5714, (float)33.3333 },
    { (float)76.1905, (float)33.3333 },
};

static StrokeRec char65[] = {
   { 2, char65_stroke0 },
   { 2, char65_stroke1 },
   { 2, char65_stroke2 },
};

/* char: 66 'B' */

static CoordRec char66_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char66_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)61.9047, (float)100 },
    { (float)76.1905, (float)95.2381 },
    { (float)80.9524, (float)90.4762 },
    { (float)85.7143, (float)80.9524 },
    { (float)85.7143, (float)71.4286 },
    { (float)80.9524, (float)61.9048 },
    { (float)76.1905, (float)57.1429 },
    { (float)61.9047, (float)52.381 },
};

static CoordRec char66_stroke2[] = {
    { (float)19.0476, (float)52.381 },
    { (float)61.9047, (float)52.381 },
    { (float)76.1905, (float)47.619 },
    { (float)80.9524, (float)42.8571 },
    { (float)85.7143, (float)33.3333 },
    { (float)85.7143, (float)19.0476 },
    { (float)80.9524, (float)9.5238 },
    { (float)76.1905, (float)4.7619 },
    { (float)61.9047, (float)0 },
    { (float)19.0476, (float)0 },
};

static StrokeRec char66[] = {
   { 2, char66_stroke0 },
   { 9, char66_stroke1 },
   { 10, char66_stroke2 },
};

/* char: 67 'C' */

static CoordRec char67_stroke0[] = {
    { (float)88.0952, (float)76.1905 },
    { (float)83.3334, (float)85.7143 },
    { (float)73.8096, (float)95.2381 },
    { (float)64.2857, (float)100 },
    { (float)45.2381, (float)100 },
    { (float)35.7143, (float)95.2381 },
    { (float)26.1905, (float)85.7143 },
    { (float)21.4286, (float)76.1905 },
    { (float)16.6667, (float)61.9048 },
    { (float)16.6667, (float)38.0952 },
    { (float)21.4286, (float)23.8095 },
    { (float)26.1905, (float)14.2857 },
    { (float)35.7143, (float)4.7619 },
    { (float)45.2381, (float)0 },
    { (float)64.2857, (float)0 },
    { (float)73.8096, (float)4.7619 },
    { (float)83.3334, (float)14.2857 },
    { (float)88.0952, (float)23.8095 },
};

static StrokeRec char67[] = {
   { 18, char67_stroke0 },
};

/* char: 68 'D' */

static CoordRec char68_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char68_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)52.3809, (float)100 },
    { (float)66.6666, (float)95.2381 },
    { (float)76.1905, (float)85.7143 },
    { (float)80.9524, (float)76.1905 },
    { (float)85.7143, (float)61.9048 },
    { (float)85.7143, (float)38.0952 },
    { (float)80.9524, (float)23.8095 },
    { (float)76.1905, (float)14.2857 },
    { (float)66.6666, (float)4.7619 },
    { (float)52.3809, (float)0 },
    { (float)19.0476, (float)0 },
};

static StrokeRec char68[] = {
   { 2, char68_stroke0 },
   { 12, char68_stroke1 },
};

/* char: 69 'E' */

static CoordRec char69_stroke0[] = {
    { (float)21.4286, (float)100 },
    { (float)21.4286, (float)0 },
};

static CoordRec char69_stroke1[] = {
    { (float)21.4286, (float)100 },
    { (float)83.3334, (float)100 },
};

static CoordRec char69_stroke2[] = {
    { (float)21.4286, (float)52.381 },
    { (float)59.5238, (float)52.381 },
};

static CoordRec char69_stroke3[] = {
    { (float)21.4286, (float)0 },
    { (float)83.3334, (float)0 },
};

static StrokeRec char69[] = {
   { 2, char69_stroke0 },
   { 2, char69_stroke1 },
   { 2, char69_stroke2 },
   { 2, char69_stroke3 },
};

/* char: 70 'F' */

static CoordRec char70_stroke0[] = {
    { (float)21.4286, (float)100 },
    { (float)21.4286, (float)0 },
};

static CoordRec char70_stroke1[] = {
    { (float)21.4286, (float)100 },
    { (float)83.3334, (float)100 },
};

static CoordRec char70_stroke2[] = {
    { (float)21.4286, (float)52.381 },
    { (float)59.5238, (float)52.381 },
};

static StrokeRec char70[] = {
   { 2, char70_stroke0 },
   { 2, char70_stroke1 },
   { 2, char70_stroke2 },
};

/* char: 71 'G' */

static CoordRec char71_stroke0[] = {
    { (float)88.0952, (float)76.1905 },
    { (float)83.3334, (float)85.7143 },
    { (float)73.8096, (float)95.2381 },
    { (float)64.2857, (float)100 },
    { (float)45.2381, (float)100 },
    { (float)35.7143, (float)95.2381 },
    { (float)26.1905, (float)85.7143 },
    { (float)21.4286, (float)76.1905 },
    { (float)16.6667, (float)61.9048 },
    { (float)16.6667, (float)38.0952 },
    { (float)21.4286, (float)23.8095 },
    { (float)26.1905, (float)14.2857 },
    { (float)35.7143, (float)4.7619 },
    { (float)45.2381, (float)0 },
    { (float)64.2857, (float)0 },
    { (float)73.8096, (float)4.7619 },
    { (float)83.3334, (float)14.2857 },
    { (float)88.0952, (float)23.8095 },
    { (float)88.0952, (float)38.0952 },
};

static CoordRec char71_stroke1[] = {
    { (float)64.2857, (float)38.0952 },
    { (float)88.0952, (float)38.0952 },
};

static StrokeRec char71[] = {
   { 19, char71_stroke0 },
   { 2, char71_stroke1 },
};

/* char: 72 'H' */

static CoordRec char72_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char72_stroke1[] = {
    { (float)85.7143, (float)100 },
    { (float)85.7143, (float)0 },
};

static CoordRec char72_stroke2[] = {
    { (float)19.0476, (float)52.381 },
    { (float)85.7143, (float)52.381 },
};

static StrokeRec char72[] = {
   { 2, char72_stroke0 },
   { 2, char72_stroke1 },
   { 2, char72_stroke2 },
};

/* char: 73 'I' */

static CoordRec char73_stroke0[] = {
    { (float)52.381, (float)100 },
    { (float)52.381, (float)0 },
};

static StrokeRec char73[] = {
   { 2, char73_stroke0 },
};

/* char: 74 'J' */

static CoordRec char74_stroke0[] = {
    { (float)76.1905, (float)100 },
    { (float)76.1905, (float)23.8095 },
    { (float)71.4286, (float)9.5238 },
    { (float)66.6667, (float)4.7619 },
    { (float)57.1429, (float)0 },
    { (float)47.6191, (float)0 },
    { (float)38.0953, (float)4.7619 },
    { (float)33.3334, (float)9.5238 },
    { (float)28.5715, (float)23.8095 },
    { (float)28.5715, (float)33.3333 },
};

static StrokeRec char74[] = {
   { 10, char74_stroke0 },
};

/* char: 75 'K' */

static CoordRec char75_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char75_stroke1[] = {
    { (float)85.7143, (float)100 },
    { (float)19.0476, (float)33.3333 },
};

static CoordRec char75_stroke2[] = {
    { (float)42.8571, (float)57.1429 },
    { (float)85.7143, (float)0 },
};

static StrokeRec char75[] = {
   { 2, char75_stroke0 },
   { 2, char75_stroke1 },
   { 2, char75_stroke2 },
};

/* char: 76 'L' */

static CoordRec char76_stroke0[] = {
    { (float)23.8095, (float)100 },
    { (float)23.8095, (float)0 },
};

static CoordRec char76_stroke1[] = {
    { (float)23.8095, (float)0 },
    { (float)80.9524, (float)0 },
};

static StrokeRec char76[] = {
   { 2, char76_stroke0 },
   { 2, char76_stroke1 },
};

/* char: 77 'M' */

static CoordRec char77_stroke0[] = {
    { (float)14.2857, (float)100 },
    { (float)14.2857, (float)0 },
};

static CoordRec char77_stroke1[] = {
    { (float)14.2857, (float)100 },
    { (float)52.3809, (float)0 },
};

static CoordRec char77_stroke2[] = {
    { (float)90.4762, (float)100 },
    { (float)52.3809, (float)0 },
};

static CoordRec char77_stroke3[] = {
    { (float)90.4762, (float)100 },
    { (float)90.4762, (float)0 },
};

static StrokeRec char77[] = {
   { 2, char77_stroke0 },
   { 2, char77_stroke1 },
   { 2, char77_stroke2 },
   { 2, char77_stroke3 },
};

/* char: 78 'N' */

static CoordRec char78_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char78_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)0 },
};

static CoordRec char78_stroke2[] = {
    { (float)85.7143, (float)100 },
    { (float)85.7143, (float)0 },
};

static StrokeRec char78[] = {
   { 2, char78_stroke0 },
   { 2, char78_stroke1 },
   { 2, char78_stroke2 },
};

/* char: 79 'O' */

static CoordRec char79_stroke0[] = {
    { (float)42.8571, (float)100 },
    { (float)33.3333, (float)95.2381 },
    { (float)23.8095, (float)85.7143 },
    { (float)19.0476, (float)76.1905 },
    { (float)14.2857, (float)61.9048 },
    { (float)14.2857, (float)38.0952 },
    { (float)19.0476, (float)23.8095 },
    { (float)23.8095, (float)14.2857 },
    { (float)33.3333, (float)4.7619 },
    { (float)42.8571, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4286, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
    { (float)85.7143, (float)23.8095 },
    { (float)90.4762, (float)38.0952 },
    { (float)90.4762, (float)61.9048 },
    { (float)85.7143, (float)76.1905 },
    { (float)80.9524, (float)85.7143 },
    { (float)71.4286, (float)95.2381 },
    { (float)61.9047, (float)100 },
    { (float)42.8571, (float)100 },
};

static StrokeRec char79[] = {
   { 21, char79_stroke0 },
};

/* char: 80 'P' */

static CoordRec char80_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char80_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)61.9047, (float)100 },
    { (float)76.1905, (float)95.2381 },
    { (float)80.9524, (float)90.4762 },
    { (float)85.7143, (float)80.9524 },
    { (float)85.7143, (float)66.6667 },
    { (float)80.9524, (float)57.1429 },
    { (float)76.1905, (float)52.381 },
    { (float)61.9047, (float)47.619 },
    { (float)19.0476, (float)47.619 },
};

static StrokeRec char80[] = {
   { 2, char80_stroke0 },
   { 10, char80_stroke1 },
};

/* char: 81 'Q' */

static CoordRec char81_stroke0[] = {
    { (float)42.8571, (float)100 },
    { (float)33.3333, (float)95.2381 },
    { (float)23.8095, (float)85.7143 },
    { (float)19.0476, (float)76.1905 },
    { (float)14.2857, (float)61.9048 },
    { (float)14.2857, (float)38.0952 },
    { (float)19.0476, (float)23.8095 },
    { (float)23.8095, (float)14.2857 },
    { (float)33.3333, (float)4.7619 },
    { (float)42.8571, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4286, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
    { (float)85.7143, (float)23.8095 },
    { (float)90.4762, (float)38.0952 },
    { (float)90.4762, (float)61.9048 },
    { (float)85.7143, (float)76.1905 },
    { (float)80.9524, (float)85.7143 },
    { (float)71.4286, (float)95.2381 },
    { (float)61.9047, (float)100 },
    { (float)42.8571, (float)100 },
};

static CoordRec char81_stroke1[] = {
    { (float)57.1428, (float)19.0476 },
    { (float)85.7143, (float)-9.5238 },
};

static StrokeRec char81[] = {
   { 21, char81_stroke0 },
   { 2, char81_stroke1 },
};

/* char: 82 'R' */

static CoordRec char82_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char82_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)61.9047, (float)100 },
    { (float)76.1905, (float)95.2381 },
    { (float)80.9524, (float)90.4762 },
    { (float)85.7143, (float)80.9524 },
    { (float)85.7143, (float)71.4286 },
    { (float)80.9524, (float)61.9048 },
    { (float)76.1905, (float)57.1429 },
    { (float)61.9047, (float)52.381 },
    { (float)19.0476, (float)52.381 },
};

static CoordRec char82_stroke2[] = {
    { (float)52.3809, (float)52.381 },
    { (float)85.7143, (float)0 },
};

static StrokeRec char82[] = {
   { 2, char82_stroke0 },
   { 10, char82_stroke1 },
   { 2, char82_stroke2 },
};

/* char: 83 'S' */

static CoordRec char83_stroke0[] = {
    { (float)85.7143, (float)85.7143 },
    { (float)76.1905, (float)95.2381 },
    { (float)61.9047, (float)100 },
    { (float)42.8571, (float)100 },
    { (float)28.5714, (float)95.2381 },
    { (float)19.0476, (float)85.7143 },
    { (float)19.0476, (float)76.1905 },
    { (float)23.8095, (float)66.6667 },
    { (float)28.5714, (float)61.9048 },
    { (float)38.0952, (float)57.1429 },
    { (float)66.6666, (float)47.619 },
    { (float)76.1905, (float)42.8571 },
    { (float)80.9524, (float)38.0952 },
    { (float)85.7143, (float)28.5714 },
    { (float)85.7143, (float)14.2857 },
    { (float)76.1905, (float)4.7619 },
    { (float)61.9047, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)28.5714, (float)4.7619 },
    { (float)19.0476, (float)14.2857 },
};

static StrokeRec char83[] = {
   { 20, char83_stroke0 },
};

/* char: 84 'T' */

static CoordRec char84_stroke0[] = {
    { (float)52.3809, (float)100 },
    { (float)52.3809, (float)0 },
};

static CoordRec char84_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)100 },
};

static StrokeRec char84[] = {
   { 2, char84_stroke0 },
   { 2, char84_stroke1 },
};

/* char: 85 'U' */

static CoordRec char85_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)19.0476, (float)28.5714 },
    { (float)23.8095, (float)14.2857 },
    { (float)33.3333, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)57.1428, (float)0 },
    { (float)71.4286, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
    { (float)85.7143, (float)28.5714 },
    { (float)85.7143, (float)100 },
};

static StrokeRec char85[] = {
   { 10, char85_stroke0 },
};

/* char: 86 'V' */

static CoordRec char86_stroke0[] = {
    { (float)14.2857, (float)100 },
    { (float)52.3809, (float)0 },
};

static CoordRec char86_stroke1[] = {
    { (float)90.4762, (float)100 },
    { (float)52.3809, (float)0 },
};

static StrokeRec char86[] = {
   { 2, char86_stroke0 },
   { 2, char86_stroke1 },
};

/* char: 87 'W' */

static CoordRec char87_stroke0[] = {
    { (float)4.7619, (float)100 },
    { (float)28.5714, (float)0 },
};

static CoordRec char87_stroke1[] = {
    { (float)52.3809, (float)100 },
    { (float)28.5714, (float)0 },
};

static CoordRec char87_stroke2[] = {
    { (float)52.3809, (float)100 },
    { (float)76.1905, (float)0 },
};

static CoordRec char87_stroke3[] = {
    { (float)100, (float)100 },
    { (float)76.1905, (float)0 },
};

static StrokeRec char87[] = {
   { 2, char87_stroke0 },
   { 2, char87_stroke1 },
   { 2, char87_stroke2 },
   { 2, char87_stroke3 },
};

/* char: 88 'X' */

static CoordRec char88_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)0 },
};

static CoordRec char88_stroke1[] = {
    { (float)85.7143, (float)100 },
    { (float)19.0476, (float)0 },
};

static StrokeRec char88[] = {
   { 2, char88_stroke0 },
   { 2, char88_stroke1 },
};

/* char: 89 'Y' */

static CoordRec char89_stroke0[] = {
    { (float)14.2857, (float)100 },
    { (float)52.3809, (float)52.381 },
    { (float)52.3809, (float)0 },
};

static CoordRec char89_stroke1[] = {
    { (float)90.4762, (float)100 },
    { (float)52.3809, (float)52.381 },
};

static StrokeRec char89[] = {
   { 3, char89_stroke0 },
   { 2, char89_stroke1 },
};

/* char: 90 'Z' */

static CoordRec char90_stroke0[] = {
    { (float)85.7143, (float)100 },
    { (float)19.0476, (float)0 },
};

static CoordRec char90_stroke1[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)100 },
};

static CoordRec char90_stroke2[] = {
    { (float)19.0476, (float)0 },
    { (float)85.7143, (float)0 },
};

static StrokeRec char90[] = {
   { 2, char90_stroke0 },
   { 2, char90_stroke1 },
   { 2, char90_stroke2 },
};

/* char: 91 '[' */

static CoordRec char91_stroke0[] = {
    { (float)35.7143, (float)119.048 },
    { (float)35.7143, (float)-33.3333 },
};

static CoordRec char91_stroke1[] = {
    { (float)40.4762, (float)119.048 },
    { (float)40.4762, (float)-33.3333 },
};

static CoordRec char91_stroke2[] = {
    { (float)35.7143, (float)119.048 },
    { (float)69.0476, (float)119.048 },
};

static CoordRec char91_stroke3[] = {
    { (float)35.7143, (float)-33.3333 },
    { (float)69.0476, (float)-33.3333 },
};

static StrokeRec char91[] = {
   { 2, char91_stroke0 },
   { 2, char91_stroke1 },
   { 2, char91_stroke2 },
   { 2, char91_stroke3 },
};

/* char: 92 '\' */

static CoordRec char92_stroke0[] = {
    { (float)19.0476, (float)100 },
    { (float)85.7143, (float)-14.2857 },
};

static StrokeRec char92[] = {
   { 2, char92_stroke0 },
};

/* char: 93 ']' */

static CoordRec char93_stroke0[] = {
    { (float)64.2857, (float)119.048 },
    { (float)64.2857, (float)-33.3333 },
};

static CoordRec char93_stroke1[] = {
    { (float)69.0476, (float)119.048 },
    { (float)69.0476, (float)-33.3333 },
};

static CoordRec char93_stroke2[] = {
    { (float)35.7143, (float)119.048 },
    { (float)69.0476, (float)119.048 },
};

static CoordRec char93_stroke3[] = {
    { (float)35.7143, (float)-33.3333 },
    { (float)69.0476, (float)-33.3333 },
};

static StrokeRec char93[] = {
   { 2, char93_stroke0 },
   { 2, char93_stroke1 },
   { 2, char93_stroke2 },
   { 2, char93_stroke3 },
};

/* char: 94 '^' */

static CoordRec char94_stroke0[] = {
    { (float)52.3809, (float)109.524 },
    { (float)14.2857, (float)42.8571 },
};

static CoordRec char94_stroke1[] = {
    { (float)52.3809, (float)109.524 },
    { (float)90.4762, (float)42.8571 },
};

static StrokeRec char94[] = {
   { 2, char94_stroke0 },
   { 2, char94_stroke1 },
};

/* char: 95 '_' */

static CoordRec char95_stroke0[] = {
    { (float)0, (float)-33.3333 },
    { (float)104.762, (float)-33.3333 },
    { (float)104.762, (float)-28.5714 },
    { (float)0, (float)-28.5714 },
    { (float)0, (float)-33.3333 },
};

static StrokeRec char95[] = {
   { 5, char95_stroke0 },
};

/* char: 96 '`' */

static CoordRec char96_stroke0[] = {
    { (float)42.8572, (float)100 },
    { (float)66.6667, (float)71.4286 },
};

static CoordRec char96_stroke1[] = {
    { (float)42.8572, (float)100 },
    { (float)38.0953, (float)95.2381 },
    { (float)66.6667, (float)71.4286 },
};

static StrokeRec char96[] = {
   { 2, char96_stroke0 },
   { 3, char96_stroke1 },
};

/* char: 97 'a' */

static CoordRec char97_stroke0[] = {
    { (float)80.9524, (float)66.6667 },
    { (float)80.9524, (float)0 },
};

static CoordRec char97_stroke1[] = {
    { (float)80.9524, (float)52.381 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char97[] = {
   { 2, char97_stroke0 },
   { 14, char97_stroke1 },
};

/* char: 98 'b' */

static CoordRec char98_stroke0[] = {
    { (float)23.8095, (float)100 },
    { (float)23.8095, (float)0 },
};

static CoordRec char98_stroke1[] = {
    { (float)23.8095, (float)52.381 },
    { (float)33.3333, (float)61.9048 },
    { (float)42.8571, (float)66.6667 },
    { (float)57.1428, (float)66.6667 },
    { (float)66.6666, (float)61.9048 },
    { (float)76.1905, (float)52.381 },
    { (float)80.9524, (float)38.0952 },
    { (float)80.9524, (float)28.5714 },
    { (float)76.1905, (float)14.2857 },
    { (float)66.6666, (float)4.7619 },
    { (float)57.1428, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)33.3333, (float)4.7619 },
    { (float)23.8095, (float)14.2857 },
};

static StrokeRec char98[] = {
   { 2, char98_stroke0 },
   { 14, char98_stroke1 },
};

/* char: 99 'c' */

static CoordRec char99_stroke0[] = {
    { (float)80.9524, (float)52.381 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char99[] = {
   { 14, char99_stroke0 },
};

/* char: 100 'd' */

static CoordRec char100_stroke0[] = {
    { (float)80.9524, (float)100 },
    { (float)80.9524, (float)0 },
};

static CoordRec char100_stroke1[] = {
    { (float)80.9524, (float)52.381 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char100[] = {
   { 2, char100_stroke0 },
   { 14, char100_stroke1 },
};

/* char: 101 'e' */

static CoordRec char101_stroke0[] = {
    { (float)23.8095, (float)38.0952 },
    { (float)80.9524, (float)38.0952 },
    { (float)80.9524, (float)47.619 },
    { (float)76.1905, (float)57.1429 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char101[] = {
   { 17, char101_stroke0 },
};

/* char: 102 'f' */

static CoordRec char102_stroke0[] = {
    { (float)71.4286, (float)100 },
    { (float)61.9048, (float)100 },
    { (float)52.381, (float)95.2381 },
    { (float)47.6191, (float)80.9524 },
    { (float)47.6191, (float)0 },
};

static CoordRec char102_stroke1[] = {
    { (float)33.3334, (float)66.6667 },
    { (float)66.6667, (float)66.6667 },
};

static StrokeRec char102[] = {
   { 5, char102_stroke0 },
   { 2, char102_stroke1 },
};

/* char: 103 'g' */

static CoordRec char103_stroke0[] = {
    { (float)80.9524, (float)66.6667 },
    { (float)80.9524, (float)-9.5238 },
    { (float)76.1905, (float)-23.8095 },
    { (float)71.4285, (float)-28.5714 },
    { (float)61.9047, (float)-33.3333 },
    { (float)47.619, (float)-33.3333 },
    { (float)38.0952, (float)-28.5714 },
};

static CoordRec char103_stroke1[] = {
    { (float)80.9524, (float)52.381 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char103[] = {
   { 7, char103_stroke0 },
   { 14, char103_stroke1 },
};

/* char: 104 'h' */

static CoordRec char104_stroke0[] = {
    { (float)26.1905, (float)100 },
    { (float)26.1905, (float)0 },
};

static CoordRec char104_stroke1[] = {
    { (float)26.1905, (float)47.619 },
    { (float)40.4762, (float)61.9048 },
    { (float)50, (float)66.6667 },
    { (float)64.2857, (float)66.6667 },
    { (float)73.8095, (float)61.9048 },
    { (float)78.5715, (float)47.619 },
    { (float)78.5715, (float)0 },
};

static StrokeRec char104[] = {
   { 2, char104_stroke0 },
   { 7, char104_stroke1 },
};

/* char: 105 'i' */

static CoordRec char105_stroke0[] = {
    { (float)47.6191, (float)100 },
    { (float)52.381, (float)95.2381 },
    { (float)57.1429, (float)100 },
    { (float)52.381, (float)104.762 },
    { (float)47.6191, (float)100 },
};

static CoordRec char105_stroke1[] = {
    { (float)52.381, (float)66.6667 },
    { (float)52.381, (float)0 },
};

static StrokeRec char105[] = {
   { 5, char105_stroke0 },
   { 2, char105_stroke1 },
};

/* char: 106 'j' */

static CoordRec char106_stroke0[] = {
    { (float)57.1429, (float)100 },
    { (float)61.9048, (float)95.2381 },
    { (float)66.6667, (float)100 },
    { (float)61.9048, (float)104.762 },
    { (float)57.1429, (float)100 },
};

static CoordRec char106_stroke1[] = {
    { (float)61.9048, (float)66.6667 },
    { (float)61.9048, (float)-14.2857 },
    { (float)57.1429, (float)-28.5714 },
    { (float)47.6191, (float)-33.3333 },
    { (float)38.0953, (float)-33.3333 },
};

static StrokeRec char106[] = {
   { 5, char106_stroke0 },
   { 5, char106_stroke1 },
};

/* char: 107 'k' */

static CoordRec char107_stroke0[] = {
    { (float)26.1905, (float)100 },
    { (float)26.1905, (float)0 },
};

static CoordRec char107_stroke1[] = {
    { (float)73.8095, (float)66.6667 },
    { (float)26.1905, (float)19.0476 },
};

static CoordRec char107_stroke2[] = {
    { (float)45.2381, (float)38.0952 },
    { (float)78.5715, (float)0 },
};

static StrokeRec char107[] = {
   { 2, char107_stroke0 },
   { 2, char107_stroke1 },
   { 2, char107_stroke2 },
};

/* char: 108 'l' */

static CoordRec char108_stroke0[] = {
    { (float)52.381, (float)100 },
    { (float)52.381, (float)0 },
};

static StrokeRec char108[] = {
   { 2, char108_stroke0 },
};

/* char: 109 'm' */

static CoordRec char109_stroke0[] = {
    { (float)0, (float)66.6667 },
    { (float)0, (float)0 },
};

static CoordRec char109_stroke1[] = {
    { (float)0, (float)47.619 },
    { (float)14.2857, (float)61.9048 },
    { (float)23.8095, (float)66.6667 },
    { (float)38.0952, (float)66.6667 },
    { (float)47.619, (float)61.9048 },
    { (float)52.381, (float)47.619 },
    { (float)52.381, (float)0 },
};

static CoordRec char109_stroke2[] = {
    { (float)52.381, (float)47.619 },
    { (float)66.6667, (float)61.9048 },
    { (float)76.1905, (float)66.6667 },
    { (float)90.4762, (float)66.6667 },
    { (float)100, (float)61.9048 },
    { (float)104.762, (float)47.619 },
    { (float)104.762, (float)0 },
};

static StrokeRec char109[] = {
   { 2, char109_stroke0 },
   { 7, char109_stroke1 },
   { 7, char109_stroke2 },
};

/* char: 110 'n' */

static CoordRec char110_stroke0[] = {
    { (float)26.1905, (float)66.6667 },
    { (float)26.1905, (float)0 },
};

static CoordRec char110_stroke1[] = {
    { (float)26.1905, (float)47.619 },
    { (float)40.4762, (float)61.9048 },
    { (float)50, (float)66.6667 },
    { (float)64.2857, (float)66.6667 },
    { (float)73.8095, (float)61.9048 },
    { (float)78.5715, (float)47.619 },
    { (float)78.5715, (float)0 },
};

static StrokeRec char110[] = {
   { 2, char110_stroke0 },
   { 7, char110_stroke1 },
};

/* char: 111 'o' */

static CoordRec char111_stroke0[] = {
    { (float)45.2381, (float)66.6667 },
    { (float)35.7143, (float)61.9048 },
    { (float)26.1905, (float)52.381 },
    { (float)21.4286, (float)38.0952 },
    { (float)21.4286, (float)28.5714 },
    { (float)26.1905, (float)14.2857 },
    { (float)35.7143, (float)4.7619 },
    { (float)45.2381, (float)0 },
    { (float)59.5238, (float)0 },
    { (float)69.0476, (float)4.7619 },
    { (float)78.5714, (float)14.2857 },
    { (float)83.3334, (float)28.5714 },
    { (float)83.3334, (float)38.0952 },
    { (float)78.5714, (float)52.381 },
    { (float)69.0476, (float)61.9048 },
    { (float)59.5238, (float)66.6667 },
    { (float)45.2381, (float)66.6667 },
};

static StrokeRec char111[] = {
   { 17, char111_stroke0 },
};

/* char: 112 'p' */

static CoordRec char112_stroke0[] = {
    { (float)23.8095, (float)66.6667 },
    { (float)23.8095, (float)-33.3333 },
};

static CoordRec char112_stroke1[] = {
    { (float)23.8095, (float)52.381 },
    { (float)33.3333, (float)61.9048 },
    { (float)42.8571, (float)66.6667 },
    { (float)57.1428, (float)66.6667 },
    { (float)66.6666, (float)61.9048 },
    { (float)76.1905, (float)52.381 },
    { (float)80.9524, (float)38.0952 },
    { (float)80.9524, (float)28.5714 },
    { (float)76.1905, (float)14.2857 },
    { (float)66.6666, (float)4.7619 },
    { (float)57.1428, (float)0 },
    { (float)42.8571, (float)0 },
    { (float)33.3333, (float)4.7619 },
    { (float)23.8095, (float)14.2857 },
};

static StrokeRec char112[] = {
   { 2, char112_stroke0 },
   { 14, char112_stroke1 },
};

/* char: 113 'q' */

static CoordRec char113_stroke0[] = {
    { (float)80.9524, (float)66.6667 },
    { (float)80.9524, (float)-33.3333 },
};

static CoordRec char113_stroke1[] = {
    { (float)80.9524, (float)52.381 },
    { (float)71.4285, (float)61.9048 },
    { (float)61.9047, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
    { (float)38.0952, (float)61.9048 },
    { (float)28.5714, (float)52.381 },
    { (float)23.8095, (float)38.0952 },
    { (float)23.8095, (float)28.5714 },
    { (float)28.5714, (float)14.2857 },
    { (float)38.0952, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)61.9047, (float)0 },
    { (float)71.4285, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
};

static StrokeRec char113[] = {
   { 2, char113_stroke0 },
   { 14, char113_stroke1 },
};

/* char: 114 'r' */

static CoordRec char114_stroke0[] = {
    { (float)33.3334, (float)66.6667 },
    { (float)33.3334, (float)0 },
};

static CoordRec char114_stroke1[] = {
    { (float)33.3334, (float)38.0952 },
    { (float)38.0953, (float)52.381 },
    { (float)47.6191, (float)61.9048 },
    { (float)57.1429, (float)66.6667 },
    { (float)71.4286, (float)66.6667 },
};

static StrokeRec char114[] = {
   { 2, char114_stroke0 },
   { 5, char114_stroke1 },
};

/* char: 115 's' */

static CoordRec char115_stroke0[] = {
    { (float)78.5715, (float)52.381 },
    { (float)73.8095, (float)61.9048 },
    { (float)59.5238, (float)66.6667 },
    { (float)45.2381, (float)66.6667 },
    { (float)30.9524, (float)61.9048 },
    { (float)26.1905, (float)52.381 },
    { (float)30.9524, (float)42.8571 },
    { (float)40.4762, (float)38.0952 },
    { (float)64.2857, (float)33.3333 },
    { (float)73.8095, (float)28.5714 },
    { (float)78.5715, (float)19.0476 },
    { (float)78.5715, (float)14.2857 },
    { (float)73.8095, (float)4.7619 },
    { (float)59.5238, (float)0 },
    { (float)45.2381, (float)0 },
    { (float)30.9524, (float)4.7619 },
    { (float)26.1905, (float)14.2857 },
};

static StrokeRec char115[] = {
   { 17, char115_stroke0 },
};

/* char: 116 't' */

static CoordRec char116_stroke0[] = {
    { (float)47.6191, (float)100 },
    { (float)47.6191, (float)19.0476 },
    { (float)52.381, (float)4.7619 },
    { (float)61.9048, (float)0 },
    { (float)71.4286, (float)0 },
};

static CoordRec char116_stroke1[] = {
    { (float)33.3334, (float)66.6667 },
    { (float)66.6667, (float)66.6667 },
};

static StrokeRec char116[] = {
   { 5, char116_stroke0 },
   { 2, char116_stroke1 },
};

/* char: 117 'u' */

static CoordRec char117_stroke0[] = {
    { (float)26.1905, (float)66.6667 },
    { (float)26.1905, (float)19.0476 },
    { (float)30.9524, (float)4.7619 },
    { (float)40.4762, (float)0 },
    { (float)54.7619, (float)0 },
    { (float)64.2857, (float)4.7619 },
    { (float)78.5715, (float)19.0476 },
};

static CoordRec char117_stroke1[] = {
    { (float)78.5715, (float)66.6667 },
    { (float)78.5715, (float)0 },
};

static StrokeRec char117[] = {
   { 7, char117_stroke0 },
   { 2, char117_stroke1 },
};

/* char: 118 'v' */

static CoordRec char118_stroke0[] = {
    { (float)23.8095, (float)66.6667 },
    { (float)52.3809, (float)0 },
};

static CoordRec char118_stroke1[] = {
    { (float)80.9524, (float)66.6667 },
    { (float)52.3809, (float)0 },
};

static StrokeRec char118[] = {
   { 2, char118_stroke0 },
   { 2, char118_stroke1 },
};

/* char: 119 'w' */

static CoordRec char119_stroke0[] = {
    { (float)14.2857, (float)66.6667 },
    { (float)33.3333, (float)0 },
};

static CoordRec char119_stroke1[] = {
    { (float)52.3809, (float)66.6667 },
    { (float)33.3333, (float)0 },
};

static CoordRec char119_stroke2[] = {
    { (float)52.3809, (float)66.6667 },
    { (float)71.4286, (float)0 },
};

static CoordRec char119_stroke3[] = {
    { (float)90.4762, (float)66.6667 },
    { (float)71.4286, (float)0 },
};

static StrokeRec char119[] = {
   { 2, char119_stroke0 },
   { 2, char119_stroke1 },
   { 2, char119_stroke2 },
   { 2, char119_stroke3 },
};

/* char: 120 'x' */

static CoordRec char120_stroke0[] = {
    { (float)26.1905, (float)66.6667 },
    { (float)78.5715, (float)0 },
};

static CoordRec char120_stroke1[] = {
    { (float)78.5715, (float)66.6667 },
    { (float)26.1905, (float)0 },
};

static StrokeRec char120[] = {
   { 2, char120_stroke0 },
   { 2, char120_stroke1 },
};

/* char: 121 'y' */

static CoordRec char121_stroke0[] = {
    { (float)26.1905, (float)66.6667 },
    { (float)54.7619, (float)0 },
};

static CoordRec char121_stroke1[] = {
    { (float)83.3334, (float)66.6667 },
    { (float)54.7619, (float)0 },
    { (float)45.2381, (float)-19.0476 },
    { (float)35.7143, (float)-28.5714 },
    { (float)26.1905, (float)-33.3333 },
    { (float)21.4286, (float)-33.3333 },
};

static StrokeRec char121[] = {
   { 2, char121_stroke0 },
   { 6, char121_stroke1 },
};

/* char: 122 'z' */

static CoordRec char122_stroke0[] = {
    { (float)78.5715, (float)66.6667 },
    { (float)26.1905, (float)0 },
};

static CoordRec char122_stroke1[] = {
    { (float)26.1905, (float)66.6667 },
    { (float)78.5715, (float)66.6667 },
};

static CoordRec char122_stroke2[] = {
    { (float)26.1905, (float)0 },
    { (float)78.5715, (float)0 },
};

static StrokeRec char122[] = {
   { 2, char122_stroke0 },
   { 2, char122_stroke1 },
   { 2, char122_stroke2 },
};

/* char: 123 '{' */

static CoordRec char123_stroke0[] = {
    { (float)64.2857, (float)119.048 },
    { (float)54.7619, (float)114.286 },
    { (float)50, (float)109.524 },
    { (float)45.2381, (float)100 },
    { (float)45.2381, (float)90.4762 },
    { (float)50, (float)80.9524 },
    { (float)54.7619, (float)76.1905 },
    { (float)59.5238, (float)66.6667 },
    { (float)59.5238, (float)57.1429 },
    { (float)50, (float)47.619 },
};

static CoordRec char123_stroke1[] = {
    { (float)54.7619, (float)114.286 },
    { (float)50, (float)104.762 },
    { (float)50, (float)95.2381 },
    { (float)54.7619, (float)85.7143 },
    { (float)59.5238, (float)80.9524 },
    { (float)64.2857, (float)71.4286 },
    { (float)64.2857, (float)61.9048 },
    { (float)59.5238, (float)52.381 },
    { (float)40.4762, (float)42.8571 },
    { (float)59.5238, (float)33.3333 },
    { (float)64.2857, (float)23.8095 },
    { (float)64.2857, (float)14.2857 },
    { (float)59.5238, (float)4.7619 },
    { (float)54.7619, (float)0 },
    { (float)50, (float)-9.5238 },
    { (float)50, (float)-19.0476 },
    { (float)54.7619, (float)-28.5714 },
};

static CoordRec char123_stroke2[] = {
    { (float)50, (float)38.0952 },
    { (float)59.5238, (float)28.5714 },
    { (float)59.5238, (float)19.0476 },
    { (float)54.7619, (float)9.5238 },
    { (float)50, (float)4.7619 },
    { (float)45.2381, (float)-4.7619 },
    { (float)45.2381, (float)-14.2857 },
    { (float)50, (float)-23.8095 },
    { (float)54.7619, (float)-28.5714 },
    { (float)64.2857, (float)-33.3333 },
};

static StrokeRec char123[] = {
   { 10, char123_stroke0 },
   { 17, char123_stroke1 },
   { 10, char123_stroke2 },
};

/* char: 124 '|' */

static CoordRec char124_stroke0[] = {
    { (float)52.381, (float)119.048 },
    { (float)52.381, (float)-33.3333 },
};

static StrokeRec char124[] = {
   { 2, char124_stroke0 },
};

/* char: 125 '}' */

static CoordRec char125_stroke0[] = {
    { (float)40.4762, (float)119.048 },
    { (float)50, (float)114.286 },
    { (float)54.7619, (float)109.524 },
    { (float)59.5238, (float)100 },
    { (float)59.5238, (float)90.4762 },
    { (float)54.7619, (float)80.9524 },
    { (float)50, (float)76.1905 },
    { (float)45.2381, (float)66.6667 },
    { (float)45.2381, (float)57.1429 },
    { (float)54.7619, (float)47.619 },
};

static CoordRec char125_stroke1[] = {
    { (float)50, (float)114.286 },
    { (float)54.7619, (float)104.762 },
    { (float)54.7619, (float)95.2381 },
    { (float)50, (float)85.7143 },
    { (float)45.2381, (float)80.9524 },
    { (float)40.4762, (float)71.4286 },
    { (float)40.4762, (float)61.9048 },
    { (float)45.2381, (float)52.381 },
    { (float)64.2857, (float)42.8571 },
    { (float)45.2381, (float)33.3333 },
    { (float)40.4762, (float)23.8095 },
    { (float)40.4762, (float)14.2857 },
    { (float)45.2381, (float)4.7619 },
    { (float)50, (float)0 },
    { (float)54.7619, (float)-9.5238 },
    { (float)54.7619, (float)-19.0476 },
    { (float)50, (float)-28.5714 },
};

static CoordRec char125_stroke2[] = {
    { (float)54.7619, (float)38.0952 },
    { (float)45.2381, (float)28.5714 },
    { (float)45.2381, (float)19.0476 },
    { (float)50, (float)9.5238 },
    { (float)54.7619, (float)4.7619 },
    { (float)59.5238, (float)-4.7619 },
    { (float)59.5238, (float)-14.2857 },
    { (float)54.7619, (float)-23.8095 },
    { (float)50, (float)-28.5714 },
    { (float)40.4762, (float)-33.3333 },
};

static StrokeRec char125[] = {
   { 10, char125_stroke0 },
   { 17, char125_stroke1 },
   { 10, char125_stroke2 },
};

/* char: 126 '~' */

static CoordRec char126_stroke0[] = {
    { (float)9.5238, (float)28.5714 },
    { (float)9.5238, (float)38.0952 },
    { (float)14.2857, (float)52.381 },
    { (float)23.8095, (float)57.1429 },
    { (float)33.3333, (float)57.1429 },
    { (float)42.8571, (float)52.381 },
    { (float)61.9048, (float)38.0952 },
    { (float)71.4286, (float)33.3333 },
    { (float)80.9524, (float)33.3333 },
    { (float)90.4762, (float)38.0952 },
    { (float)95.2381, (float)47.619 },
};

static CoordRec char126_stroke1[] = {
    { (float)9.5238, (float)38.0952 },
    { (float)14.2857, (float)47.619 },
    { (float)23.8095, (float)52.381 },
    { (float)33.3333, (float)52.381 },
    { (float)42.8571, (float)47.619 },
    { (float)61.9048, (float)33.3333 },
    { (float)71.4286, (float)28.5714 },
    { (float)80.9524, (float)28.5714 },
    { (float)90.4762, (float)33.3333 },
    { (float)95.2381, (float)47.619 },
    { (float)95.2381, (float)57.1429 },
};

static StrokeRec char126[] = {
   { 11, char126_stroke0 },
   { 11, char126_stroke1 },
};

/* char: 127 */

static CoordRec char127_stroke0[] = {
    { (float)71.4286, (float)100 },
    { (float)33.3333, (float)-33.3333 },
};

static CoordRec char127_stroke1[] = {
    { (float)47.619, (float)66.6667 },
    { (float)33.3333, (float)61.9048 },
    { (float)23.8095, (float)52.381 },
    { (float)19.0476, (float)38.0952 },
    { (float)19.0476, (float)23.8095 },
    { (float)23.8095, (float)14.2857 },
    { (float)33.3333, (float)4.7619 },
    { (float)47.619, (float)0 },
    { (float)57.1428, (float)0 },
    { (float)71.4286, (float)4.7619 },
    { (float)80.9524, (float)14.2857 },
    { (float)85.7143, (float)28.5714 },
    { (float)85.7143, (float)42.8571 },
    { (float)80.9524, (float)52.381 },
    { (float)71.4286, (float)61.9048 },
    { (float)57.1428, (float)66.6667 },
    { (float)47.619, (float)66.6667 },
};

static StrokeRec char127[] = {
   { 2, char127_stroke0 },
   { 17, char127_stroke1 },
};

static StrokeCharRec chars[] = {
    { 0, /* char0 */ 0, (float)0, (float)0 },
    { 0, /* char1 */ 0, (float)0, (float)0 },
    { 0, /* char2 */ 0, (float)0, (float)0 },
    { 0, /* char3 */ 0, (float)0, (float)0 },
    { 0, /* char4 */ 0, (float)0, (float)0 },
    { 0, /* char5 */ 0, (float)0, (float)0 },
    { 0, /* char6 */ 0, (float)0, (float)0 },
    { 0, /* char7 */ 0, (float)0, (float)0 },
    { 0, /* char8 */ 0, (float)0, (float)0 },
    { 0, /* char9 */ 0, (float)0, (float)0 },
    { 0, /* char10 */ 0, (float)0, (float)0 },
    { 0, /* char11 */ 0, (float)0, (float)0 },
    { 0, /* char12 */ 0, (float)0, (float)0 },
    { 0, /* char13 */ 0, (float)0, (float)0 },
    { 0, /* char14 */ 0, (float)0, (float)0 },
    { 0, /* char15 */ 0, (float)0, (float)0 },
    { 0, /* char16 */ 0, (float)0, (float)0 },
    { 0, /* char17 */ 0, (float)0, (float)0 },
    { 0, /* char18 */ 0, (float)0, (float)0 },
    { 0, /* char19 */ 0, (float)0, (float)0 },
    { 0, /* char20 */ 0, (float)0, (float)0 },
    { 0, /* char21 */ 0, (float)0, (float)0 },
    { 0, /* char22 */ 0, (float)0, (float)0 },
    { 0, /* char23 */ 0, (float)0, (float)0 },
    { 0, /* char24 */ 0, (float)0, (float)0 },
    { 0, /* char25 */ 0, (float)0, (float)0 },
    { 0, /* char26 */ 0, (float)0, (float)0 },
    { 0, /* char27 */ 0, (float)0, (float)0 },
    { 0, /* char28 */ 0, (float)0, (float)0 },
    { 0, /* char29 */ 0, (float)0, (float)0 },
    { 0, /* char30 */ 0, (float)0, (float)0 },
    { 0, /* char31 */ 0, (float)0, (float)0 },
    { 0, /* char32 */ 0, (float)52.381, (float)104.762 },
    { 2, char33, (float)52.381, (float)104.762 },
    { 2, char34, (float)52.381, (float)104.762 },
    { 4, char35, (float)52.381, (float)104.762 },
    { 3, char36, (float)52.381, (float)104.762 },
    { 3, char37, (float)52.381, (float)104.762 },
    { 1, char38, (float)52.381, (float)104.762 },
    { 1, char39, (float)52.381, (float)104.762 },
    { 1, char40, (float)52.381, (float)104.762 },
    { 1, char41, (float)52.381, (float)104.762 },
    { 3, char42, (float)52.381, (float)104.762 },
    { 2, char43, (float)52.381, (float)104.762 },
    { 1, char44, (float)52.381, (float)104.762 },
    { 1, char45, (float)52.381, (float)104.762 },
    { 1, char46, (float)52.381, (float)104.762 },
    { 1, char47, (float)52.381, (float)104.762 },
    { 1, char48, (float)52.381, (float)104.762 },
    { 1, char49, (float)52.381, (float)104.762 },
    { 1, char50, (float)52.381, (float)104.762 },
    { 1, char51, (float)52.381, (float)104.762 },
    { 2, char52, (float)52.381, (float)104.762 },
    { 1, char53, (float)52.381, (float)104.762 },
    { 1, char54, (float)52.381, (float)104.762 },
    { 2, char55, (float)52.381, (float)104.762 },
    { 1, char56, (float)52.381, (float)104.762 },
    { 1, char57, (float)52.381, (float)104.762 },
    { 2, char58, (float)52.381, (float)104.762 },
    { 2, char59, (float)52.381, (float)104.762 },
    { 1, char60, (float)52.381, (float)104.762 },
    { 2, char61, (float)52.381, (float)104.762 },
    { 1, char62, (float)52.381, (float)104.762 },
    { 2, char63, (float)52.381, (float)104.762 },
    { 2, char64, (float)52.381, (float)104.762 },
    { 3, char65, (float)52.381, (float)104.762 },
    { 3, char66, (float)52.381, (float)104.762 },
    { 1, char67, (float)52.381, (float)104.762 },
    { 2, char68, (float)52.381, (float)104.762 },
    { 4, char69, (float)52.381, (float)104.762 },
    { 3, char70, (float)52.381, (float)104.762 },
    { 2, char71, (float)52.381, (float)104.762 },
    { 3, char72, (float)52.381, (float)104.762 },
    { 1, char73, (float)52.381, (float)104.762 },
    { 1, char74, (float)52.381, (float)104.762 },
    { 3, char75, (float)52.381, (float)104.762 },
    { 2, char76, (float)52.381, (float)104.762 },
    { 4, char77, (float)52.381, (float)104.762 },
    { 3, char78, (float)52.381, (float)104.762 },
    { 1, char79, (float)52.381, (float)104.762 },
    { 2, char80, (float)52.381, (float)104.762 },
    { 2, char81, (float)52.381, (float)104.762 },
    { 3, char82, (float)52.381, (float)104.762 },
    { 1, char83, (float)52.381, (float)104.762 },
    { 2, char84, (float)52.381, (float)104.762 },
    { 1, char85, (float)52.381, (float)104.762 },
    { 2, char86, (float)52.381, (float)104.762 },
    { 4, char87, (float)52.381, (float)104.762 },
    { 2, char88, (float)52.381, (float)104.762 },
    { 2, char89, (float)52.381, (float)104.762 },
    { 3, char90, (float)52.381, (float)104.762 },
    { 4, char91, (float)52.381, (float)104.762 },
    { 1, char92, (float)52.381, (float)104.762 },
    { 4, char93, (float)52.381, (float)104.762 },
    { 2, char94, (float)52.381, (float)104.762 },
    { 1, char95, (float)52.381, (float)104.762 },
    { 2, char96, (float)52.381, (float)104.762 },
    { 2, char97, (float)52.381, (float)104.762 },
    { 2, char98, (float)52.381, (float)104.762 },
    { 1, char99, (float)52.381, (float)104.762 },
    { 2, char100, (float)52.381, (float)104.762 },
    { 1, char101, (float)52.381, (float)104.762 },
    { 2, char102, (float)52.381, (float)104.762 },
    { 2, char103, (float)52.381, (float)104.762 },
    { 2, char104, (float)52.381, (float)104.762 },
    { 2, char105, (float)52.381, (float)104.762 },
    { 2, char106, (float)52.381, (float)104.762 },
    { 3, char107, (float)52.381, (float)104.762 },
    { 1, char108, (float)52.381, (float)104.762 },
    { 3, char109, (float)52.381, (float)104.762 },
    { 2, char110, (float)52.381, (float)104.762 },
    { 1, char111, (float)52.381, (float)104.762 },
    { 2, char112, (float)52.381, (float)104.762 },
    { 2, char113, (float)52.381, (float)104.762 },
    { 2, char114, (float)52.381, (float)104.762 },
    { 1, char115, (float)52.381, (float)104.762 },
    { 2, char116, (float)52.381, (float)104.762 },
    { 2, char117, (float)52.381, (float)104.762 },
    { 2, char118, (float)52.381, (float)104.762 },
    { 4, char119, (float)52.381, (float)104.762 },
    { 2, char120, (float)52.381, (float)104.762 },
    { 2, char121, (float)52.381, (float)104.762 },
    { 3, char122, (float)52.381, (float)104.762 },
    { 3, char123, (float)52.381, (float)104.762 },
    { 1, char124, (float)52.381, (float)104.762 },
    { 3, char125, (float)52.381, (float)104.762 },
    { 2, char126, (float)52.381, (float)104.762 },
    { 2, char127, (float)52.381, (float)104.762 },
};

StrokeFontRec glutStrokeMonoRoman = { "Roman", 128, chars, (float)119.048, (float)-33.3333 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltos.h ===
#ifndef __glutos_h__
#define __glutos_h__

/* Copyright (c) Mark J. Kilgard, Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef GLUT_WIN32

#include <windows.h>
#include <GL/gl.h>

typedef struct _GLUTwinColormap
{
    HPALETTE hpal;
    BOOL use_static;
} GLUTwinColormap;

typedef HWND                    GLUTosWindow;
typedef PIXELFORMATDESCRIPTOR  *GLUTosSurface;
typedef GLUTwinColormap        *GLUTosColormap;
typedef HGLRC                   GLUTosGlContext;
typedef HMENU                   GLUTosMenu;

#define GLUT_OS_INVALID_WINDOW          ((GLUTosWindow)0)
#define GLUT_OS_INVALID_SURFACE         ((GLUTosSurface)NULL)
#define GLUT_OS_INVALID_COLORMAP        ((GLUTosColormap)NULL)
#define GLUT_OS_INVALID_GL_CONTEXT      ((GLUTosGlContext)0)
#define GLUT_OS_INVALID_MENU            ((GLUTosMenu)0)

#define GLUT_OS_EXPOSURE_MASK           0x00000001L
#define GLUT_OS_KEY_PRESS_MASK          0x00000002L
#define GLUT_OS_BUTTON_PRESS_MASK       0x00000004L
#define GLUT_OS_BUTTON_RELEASE_MASK     0x00000008L
#define GLUT_OS_BUTTON1_MOTION_MASK     0x00000010L
#define GLUT_OS_BUTTON2_MOTION_MASK     0x00000020L
#define GLUT_OS_BUTTON3_MOTION_MASK     0x00000040L
#define GLUT_OS_POINTER_MOTION_MASK     0x00000080L
#define GLUT_OS_ENTER_WINDOW_MASK       0x00000100L
#define GLUT_OS_LEAVE_WINDOW_MASK       0x00000200L
#define GLUT_OS_VISIBILITY_CHANGE_MASK  0x00000400L
#define GLUT_OS_STRUCTURE_NOTIFY_MASK   0x00000800L

#define GLUT_OS_NORMAL_STATE            SW_SHOWDEFAULT
#define GLUT_OS_ICONIC_STATE            SW_SHOWMINIMIZED
#define GLUT_OS_HIDDEN_STATE            SW_HIDE

#define GLUT_OS_CONFIGURE_X             0x00000001
#define GLUT_OS_CONFIGURE_Y             0x00000002
#define GLUT_OS_CONFIGURE_WIDTH         0x00000004
#define GLUT_OS_CONFIGURE_HEIGHT        0x00000008
#define GLUT_OS_CONFIGURE_STACKING      0x00000010

#define GLUT_OS_STACK_ABOVE             0x00000001
#define GLUT_OS_STACK_BELOW             0x00000002

extern GLboolean __glutWinFindPixelFormat(HDC hdc, GLbitfield type,
                                          PIXELFORMATDESCRIPTOR *ppfd,
                                          GLboolean set);
extern void __glutWinPopupMenu(GLUTwindow *window, int but, int x, int y);
extern void __glutWinRealizeWindowPalette(GLUTosWindow win,
                                          GLUTosColormap cmap,
                                          GLboolean force_bg);
extern HDC __glutWinGetDc(GLUTosWindow win);
extern void __glutWinReleaseDc(GLUTosWindow win, HDC hdc);

#else

#include <X11/Xlib.h>
#include <GL/glx.h>
#include <sys/types.h>
#include <sys/time.h>
#include <GL/gl.h>

typedef Window                  GLUTosWindow;
typedef XVisualInfo            *GLUTosSurface;
typedef Colormap                GLUTosColormap;
typedef GLXContext              GLUTosGlContext;

typedef struct _GLUTxMenuItem GLUTxMenuItem;
typedef struct _GLUTxMenu GLUTxMenu;

struct _GLUTxMenu
{
  Window win;           /* X window of menu */
  int submenus;         /* number of submenu entries */
  int managed;          /* are the InputOnly windows size
                           validated? */
  int pixwidth;         /* width of menu in pixels */
  int pixheight;        /* height of menu in pixels */
  GLUTxMenuItem *list;  /* list of menu entries */
  GLUTxMenuItem *highlighted;  /* pointer to highlighted menu
                                  entry, NULL not highlighted */
  GLUTmenu *cascade;    /* currently cascading this menu  */
  GLUTxMenuItem *anchor;  /* currently anchored to this entry */
  int x;                /* current x origin relative to the
                           root window */
  int y;                /* current y origin relative to the
                           root window */
};
typedef struct _GLUTxMenu      *GLUTosMenu;

#define GLUT_OS_INVALID_WINDOW          ((GLUTosWindow)0)
#define GLUT_OS_INVALID_SURFACE         ((GLUTosSurface)NULL)
#define GLUT_OS_INVALID_COLORMAP        ((GLUTosColormap)0)
#define GLUT_OS_INVALID_GL_CONTEXT      ((GLUTosGlContext)0)
#define GLUT_OS_INVALID_MENU            ((GLUTosMenu)NULL)

#define GLUT_OS_EXPOSURE_MASK           ExposureMask
#define GLUT_OS_KEY_PRESS_MASK          KeyPressMask
#define GLUT_OS_BUTTON_PRESS_MASK       ButtonPressMask
#define GLUT_OS_BUTTON_RELEASE_MASK     ButtonReleaseMask
#define GLUT_OS_BUTTON1_MOTION_MASK     Button1MotionMask
#define GLUT_OS_BUTTON2_MOTION_MASK     Button2MotionMask
#define GLUT_OS_BUTTON3_MOTION_MASK     Button3MotionMask
#define GLUT_OS_POINTER_MOTION_MASK     PointerMotionMask
#define GLUT_OS_ENTER_WINDOW_MASK       EnterWindowMask
#define GLUT_OS_LEAVE_WINDOW_MASK       LeaveWindowMask
#define GLUT_OS_VISIBILITY_CHANGE_MASK  VisibilityChangeMask
#define GLUT_OS_STRUCTURE_NOTIFY_MASK   StructureNotifyMask

#define GLUT_OS_NORMAL_STATE            NormalState
#define GLUT_OS_ICONIC_STATE            IconicState
#define GLUT_OS_HIDDEN_STATE            WithdrawnState

#define GLUT_OS_CONFIGURE_X             CWX
#define GLUT_OS_CONFIGURE_Y             CWY
#define GLUT_OS_CONFIGURE_WIDTH         CWWidth
#define GLUT_OS_CONFIGURE_HEIGHT        CWHeight
#define GLUT_OS_CONFIGURE_STACKING      CWStackMode

#define GLUT_OS_STACK_ABOVE             Above
#define GLUT_OS_STACK_BELOW             Below

extern Display *__glutXDisplay;
extern int __glutXScreen;
extern Window __glutXRoot;
extern Atom __glutXWMDeleteWindow;
extern XSizeHints __glutXSizeHints;
extern int __glutXConnectionFD;

extern GLUTmenu *__glutXGetMenu(GLUTosWindow win);
extern GLUTxMenuItem *__glutXGetMenuItem(GLUTmenu * menu, Window win,
                                           int *which);
extern void __glutXStartMenu(GLUTmenu * menu, GLUTwindow * window,
                             int x, int y);
extern void __glutXFinishMenu(void);
extern void __glutXPaintMenu(GLUTmenu * menu);
extern void __glutXMenuItemEnterOrLeave(GLUTxMenuItem * entry, int num,
                                        int type);

typedef struct _GLUTxEventParser GLUTxEventParser;
struct _GLUTxEventParser {
  int (*func) (XEvent *);
  GLUTxEventParser *next;
};

extern void __glutXRegisterEventParser(GLUTxEventParser * parser);

#endif /* GLUT_WIN32 */

/* Macro to document parameters which are deliberately unused. 
   Creates a reference to the name to avoid compiler warnings.
   It's possible, though unlikely, that different platforms may
   want to do different things with this */
#define UNUSED_PARAMETER(v) (v)

extern int __glutOsColormapSize(GLUTosSurface surf);
extern GLUTosColormap __glutOsCreateEmptyColormap(GLUTosSurface surf);
extern void __glutOsSetColor(GLUTosColormap cmap, int ndx,
                             GLfloat red, GLfloat green, GLfloat blue);
extern void __glutOsDestroyColormap(GLUTosColormap cmap);

extern GLboolean __glutOsEventsPending(void);
extern void __glutOsProcessEvents(void);
extern void __glutOsProcessWindowWork(GLUTwindow *window);
extern void __glutOsWaitForEvents(unsigned long timeout);

extern void __glutOsInitialize(void);
extern void __glutOsUninitialize(void);

extern int __glutOsGet(GLenum param);

extern int __glutOsParseArgument(char **argv, int remaining);

extern unsigned long __glutOsElapsedTime(void);

extern GLUTosGlContext __glutOsCreateGlContext(GLUTosWindow win,
                                               GLUTosSurface surf,
                                               GLboolean direct);
extern void __glutOsDestroyGlContext(GLUTosGlContext ctx);
extern void __glutOsMakeCurrent(GLUTosWindow win, GLUTosGlContext ctx);

extern void __glutOsSwapBuffers(GLUTosWindow win);

extern GLUTosSurface __glutOsGetSurface(GLbitfield mode);
extern void __glutOsDestroySurface(GLUTosSurface surf);
extern GLboolean __glutOsSurfaceHasColormap(GLUTosSurface surf);
extern GLUTosColormap __glutOsGetSurfaceColormap(GLUTosSurface surf);
extern GLboolean __glutOsSurfaceEq(GLUTosSurface s1, GLUTosSurface s2);

extern GLUTosWindow __glutOsCreateWindow(GLUTosWindow parent, char *title,
                                         int x, int y, int width, int height,
                                         GLUTosSurface surf,
                                         GLUTosColormap cmap,
                                         long event_mask, int initial_state);
extern void __glutOsDestroyWindow(GLUTosWindow win);
extern void __glutOsSetWindowTitle(GLUTosWindow win, char *title);
extern void __glutOsSetIconTitle(GLUTosWindow win, char *title);
extern void __glutOsSetWindowColormap(GLUTosWindow win, GLUTosColormap cmap);

extern GLUTosMenu __glutOsCreateMenu(void);
extern void __glutOsDestroyMenu(GLUTosMenu menu);
extern void __glutOsAddMenuEntry(GLUTosMenu menu, char *label, int value);
extern void __glutOsAddSubMenu(GLUTosMenu menu, char *label,
                               GLUTosMenu submenu);
extern void __glutOsChangeToMenuEntry(GLUTosMenu menu, int num, char *label,
                                      int value);
extern void __glutOsChangeToSubMenu(GLUTosMenu menu, int num, char *label,
                                    GLUTosMenu submenu);
extern void __glutOsRemoveMenuEntry(GLUTosMenu menu, int item);

extern int __glutOsIsSupported(char *extension);
extern int __glutOsDeviceGet(GLenum param);

extern void __glutOsUpdateInputDeviceMask(GLUTwindow *window);

#endif /* __glutos_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltstrke.h ===
#ifndef __glutstroke_h__
#define __glutstroke_h__

/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

typedef struct {
  float x;
  float y;
} CoordRec, *CoordPtr;

typedef struct {
  int num_coords;
  CoordPtr coord;
} StrokeRec, *StrokePtr;

typedef struct {
  int num_strokes;
  StrokePtr stroke;
  float center;
  float right;
} StrokeCharRec, *StrokeCharPtr;

typedef struct {
  char *name;
  int num_chars;
  StrokeCharPtr ch;
  float top;
  float bottom;
} StrokeFontRec, *StrokeFontPtr;

typedef void *GLUTstrokeFont;

#endif /* __glutstroke_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltstrke.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"
#include "gltstrke.h"

void
glutStrokeCharacter(GLUTstrokeFont font, int c)
{
  StrokeCharPtr ch;
  StrokePtr stroke;
  CoordPtr coord;
  StrokeFontPtr fontinfo = (StrokeFontPtr) font;
  int i, j;

  if (c < 0 || c >= fontinfo->num_chars)
    return;
  ch = &(fontinfo->ch[c]);
  if (ch) {
    for (i = ch->num_strokes, stroke = ch->stroke;
      i > 0; i--, stroke++) {
      glBegin(GL_LINE_STRIP);
      for (j = stroke->num_coords, coord = stroke->coord;
        j > 0; j--, coord++) {
        glVertex2f(coord->x, coord->y);
      }
      glEnd();
    }
    glTranslatef(ch->right, (GLfloat)0.0, (GLfloat)0.0);
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltspace.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

void
glutSpaceballMotionFunc(GLUTspaceMotionCB spaceMotionFunc)
{
  __glutCurrentWindow->spaceMotion = spaceMotionFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

void
glutSpaceballRotateFunc(GLUTspaceRotateCB spaceRotateFunc)
{
  __glutCurrentWindow->spaceRotate = spaceRotateFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

void
glutSpaceballButtonFunc(GLUTspaceButtonCB spaceButtonFunc)
{
  __glutCurrentWindow->spaceButton = spaceButtonFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltromn.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltstrke.h"

/* char: 33 '!' */

static CoordRec char33_stroke0[] = {
    { (float)13.3819, (float)100 },
    { (float)13.3819, (float)33.3333 },
};

static CoordRec char33_stroke1[] = {
    { (float)13.3819, (float)9.5238 },
    { (float)8.62, (float)4.7619 },
    { (float)13.3819, (float)0 },
    { (float)18.1438, (float)4.7619 },
    { (float)13.3819, (float)9.5238 },
};

static StrokeRec char33[] = {
   { 2, char33_stroke0 },
   { 5, char33_stroke1 },
};

/* char: 34 '"' */

static CoordRec char34_stroke0[] = {
    { (float)4.02, (float)100 },
    { (float)4.02, (float)66.6667 },
};

static CoordRec char34_stroke1[] = {
    { (float)42.1152, (float)100 },
    { (float)42.1152, (float)66.6667 },
};

static StrokeRec char34[] = {
   { 2, char34_stroke0 },
   { 2, char34_stroke1 },
};

/* char: 35 '#' */

static CoordRec char35_stroke0[] = {
    { (float)41.2952, (float)119.048 },
    { (float)7.9619, (float)-33.3333 },
};

static CoordRec char35_stroke1[] = {
    { (float)69.8667, (float)119.048 },
    { (float)36.5333, (float)-33.3333 },
};

static CoordRec char35_stroke2[] = {
    { (float)7.9619, (float)57.1429 },
    { (float)74.6286, (float)57.1429 },
};

static CoordRec char35_stroke3[] = {
    { (float)3.2, (float)28.5714 },
    { (float)69.8667, (float)28.5714 },
};

static StrokeRec char35[] = {
   { 2, char35_stroke0 },
   { 2, char35_stroke1 },
   { 2, char35_stroke2 },
   { 2, char35_stroke3 },
};

/* char: 36 '$' */

static CoordRec char36_stroke0[] = {
    { (float)28.6295, (float)119.048 },
    { (float)28.6295, (float)-19.0476 },
};

static CoordRec char36_stroke1[] = {
    { (float)47.6771, (float)119.048 },
    { (float)47.6771, (float)-19.0476 },
};

static CoordRec char36_stroke2[] = {
    { (float)71.4867, (float)85.7143 },
    { (float)61.9629, (float)95.2381 },
    { (float)47.6771, (float)100 },
    { (float)28.6295, (float)100 },
    { (float)14.3438, (float)95.2381 },
    { (float)4.82, (float)85.7143 },
    { (float)4.82, (float)76.1905 },
    { (float)9.5819, (float)66.6667 },
    { (float)14.3438, (float)61.9048 },
    { (float)23.8676, (float)57.1429 },
    { (float)52.439, (float)47.619 },
    { (float)61.9629, (float)42.8571 },
    { (float)66.7248, (float)38.0952 },
    { (float)71.4867, (float)28.5714 },
    { (float)71.4867, (float)14.2857 },
    { (float)61.9629, (float)4.7619 },
    { (float)47.6771, (float)0 },
    { (float)28.6295, (float)0 },
    { (float)14.3438, (float)4.7619 },
    { (float)4.82, (float)14.2857 },
};

static StrokeRec char36[] = {
   { 2, char36_stroke0 },
   { 2, char36_stroke1 },
   { 20, char36_stroke2 },
};

/* char: 37 '%' */

static CoordRec char37_stroke0[] = {
    { (float)92.0743, (float)100 },
    { (float)6.36, (float)0 },
};

static CoordRec char37_stroke1[] = {
    { (float)30.1695, (float)100 },
    { (float)39.6933, (float)90.4762 },
    { (float)39.6933, (float)80.9524 },
    { (float)34.9314, (float)71.4286 },
    { (float)25.4076, (float)66.6667 },
    { (float)15.8838, (float)66.6667 },
    { (float)6.36, (float)76.1905 },
    { (float)6.36, (float)85.7143 },
    { (float)11.1219, (float)95.2381 },
    { (float)20.6457, (float)100 },
    { (float)30.1695, (float)100 },
    { (float)39.6933, (float)95.2381 },
    { (float)53.979, (float)90.4762 },
    { (float)68.2648, (float)90.4762 },
    { (float)82.5505, (float)95.2381 },
    { (float)92.0743, (float)100 },
};

static CoordRec char37_stroke2[] = {
    { (float)73.0267, (float)33.3333 },
    { (float)63.5029, (float)28.5714 },
    { (float)58.741, (float)19.0476 },
    { (float)58.741, (float)9.5238 },
    { (float)68.2648, (float)0 },
    { (float)77.7886, (float)0 },
    { (float)87.3124, (float)4.7619 },
    { (float)92.0743, (float)14.2857 },
    { (float)92.0743, (float)23.8095 },
    { (float)82.5505, (float)33.3333 },
    { (float)73.0267, (float)33.3333 },
};

static StrokeRec char37[] = {
   { 2, char37_stroke0 },
   { 16, char37_stroke1 },
   { 11, char37_stroke2 },
};

/* char: 38 '&' */

static CoordRec char38_stroke0[] = {
    { (float)101.218, (float)57.1429 },
    { (float)101.218, (float)61.9048 },
    { (float)96.4562, (float)66.6667 },
    { (float)91.6943, (float)66.6667 },
    { (float)86.9324, (float)61.9048 },
    { (float)82.1705, (float)52.381 },
    { (float)72.6467, (float)28.5714 },
    { (float)63.1229, (float)14.2857 },
    { (float)53.599, (float)4.7619 },
    { (float)44.0752, (float)0 },
    { (float)25.0276, (float)0 },
    { (float)15.5038, (float)4.7619 },
    { (float)10.7419, (float)9.5238 },
    { (float)5.98, (float)19.0476 },
    { (float)5.98, (float)28.5714 },
    { (float)10.7419, (float)38.0952 },
    { (float)15.5038, (float)42.8571 },
    { (float)48.8371, (float)61.9048 },
    { (float)53.599, (float)66.6667 },
    { (float)58.361, (float)76.1905 },
    { (float)58.361, (float)85.7143 },
    { (float)53.599, (float)95.2381 },
    { (float)44.0752, (float)100 },
    { (float)34.5514, (float)95.2381 },
    { (float)29.7895, (float)85.7143 },
    { (float)29.7895, (float)76.1905 },
    { (float)34.5514, (float)61.9048 },
    { (float)44.0752, (float)47.619 },
    { (float)67.8848, (float)14.2857 },
    { (float)77.4086, (float)4.7619 },
    { (float)86.9324, (float)0 },
    { (float)96.4562, (float)0 },
    { (float)101.218, (float)4.7619 },
    { (float)101.218, (float)9.5238 },
};

static StrokeRec char38[] = {
   { 34, char38_stroke0 },
};

/* char: 39 ''' */

static CoordRec char39_stroke0[] = {
    { (float)4.44, (float)100 },
    { (float)4.44, (float)66.6667 },
};

static StrokeRec char39[] = {
   { 2, char39_stroke0 },
};

/* char: 40 '(' */

static CoordRec char40_stroke0[] = {
    { (float)40.9133, (float)119.048 },
    { (float)31.3895, (float)109.524 },
    { (float)21.8657, (float)95.2381 },
    { (float)12.3419, (float)76.1905 },
    { (float)7.58, (float)52.381 },
    { (float)7.58, (float)33.3333 },
    { (float)12.3419, (float)9.5238 },
    { (float)21.8657, (float)-9.5238 },
    { (float)31.3895, (float)-23.8095 },
    { (float)40.9133, (float)-33.3333 },
};

static StrokeRec char40[] = {
   { 10, char40_stroke0 },
};

/* char: 41 ')' */

static CoordRec char41_stroke0[] = {
    { (float)5.28, (float)119.048 },
    { (float)14.8038, (float)109.524 },
    { (float)24.3276, (float)95.2381 },
    { (float)33.8514, (float)76.1905 },
    { (float)38.6133, (float)52.381 },
    { (float)38.6133, (float)33.3333 },
    { (float)33.8514, (float)9.5238 },
    { (float)24.3276, (float)-9.5238 },
    { (float)14.8038, (float)-23.8095 },
    { (float)5.28, (float)-33.3333 },
};

static StrokeRec char41[] = {
   { 10, char41_stroke0 },
};

/* char: 42 '*' */

static CoordRec char42_stroke0[] = {
    { (float)30.7695, (float)71.4286 },
    { (float)30.7695, (float)14.2857 },
};

static CoordRec char42_stroke1[] = {
    { (float)6.96, (float)57.1429 },
    { (float)54.579, (float)28.5714 },
};

static CoordRec char42_stroke2[] = {
    { (float)54.579, (float)57.1429 },
    { (float)6.96, (float)28.5714 },
};

static StrokeRec char42[] = {
   { 2, char42_stroke0 },
   { 2, char42_stroke1 },
   { 2, char42_stroke2 },
};

/* char: 43 '+' */

static CoordRec char43_stroke0[] = {
    { (float)48.8371, (float)85.7143 },
    { (float)48.8371, (float)0 },
};

static CoordRec char43_stroke1[] = {
    { (float)5.98, (float)42.8571 },
    { (float)91.6943, (float)42.8571 },
};

static StrokeRec char43[] = {
   { 2, char43_stroke0 },
   { 2, char43_stroke1 },
};

/* char: 44 ',' */

static CoordRec char44_stroke0[] = {
    { (float)18.2838, (float)4.7619 },
    { (float)13.5219, (float)0 },
    { (float)8.76, (float)4.7619 },
    { (float)13.5219, (float)9.5238 },
    { (float)18.2838, (float)4.7619 },
    { (float)18.2838, (float)-4.7619 },
    { (float)13.5219, (float)-14.2857 },
    { (float)8.76, (float)-19.0476 },
};

static StrokeRec char44[] = {
   { 8, char44_stroke0 },
};

/* char: 45 '-' */

static CoordRec char45_stroke0[] = {
    { (float)7.38, (float)42.8571 },
    { (float)93.0943, (float)42.8571 },
};

static StrokeRec char45[] = {
   { 2, char45_stroke0 },
};

/* char: 46 '.' */

static CoordRec char46_stroke0[] = {
    { (float)13.1019, (float)9.5238 },
    { (float)8.34, (float)4.7619 },
    { (float)13.1019, (float)0 },
    { (float)17.8638, (float)4.7619 },
    { (float)13.1019, (float)9.5238 },
};

static StrokeRec char46[] = {
   { 5, char46_stroke0 },
};

/* char: 47 '/' */

static CoordRec char47_stroke0[] = {
    { (float)7.24, (float)-14.2857 },
    { (float)73.9067, (float)100 },
};

static StrokeRec char47[] = {
   { 2, char47_stroke0 },
};

/* char: 48 '0' */

static CoordRec char48_stroke0[] = {
    { (float)33.5514, (float)100 },
    { (float)19.2657, (float)95.2381 },
    { (float)9.7419, (float)80.9524 },
    { (float)4.98, (float)57.1429 },
    { (float)4.98, (float)42.8571 },
    { (float)9.7419, (float)19.0476 },
    { (float)19.2657, (float)4.7619 },
    { (float)33.5514, (float)0 },
    { (float)43.0752, (float)0 },
    { (float)57.361, (float)4.7619 },
    { (float)66.8848, (float)19.0476 },
    { (float)71.6467, (float)42.8571 },
    { (float)71.6467, (float)57.1429 },
    { (float)66.8848, (float)80.9524 },
    { (float)57.361, (float)95.2381 },
    { (float)43.0752, (float)100 },
    { (float)33.5514, (float)100 },
};

static StrokeRec char48[] = {
   { 17, char48_stroke0 },
};

/* char: 49 '1' */

static CoordRec char49_stroke0[] = {
    { (float)11.82, (float)80.9524 },
    { (float)21.3438, (float)85.7143 },
    { (float)35.6295, (float)100 },
    { (float)35.6295, (float)0 },
};

static StrokeRec char49[] = {
   { 4, char49_stroke0 },
};

/* char: 50 '2' */

static CoordRec char50_stroke0[] = {
    { (float)10.1819, (float)76.1905 },
    { (float)10.1819, (float)80.9524 },
    { (float)14.9438, (float)90.4762 },
    { (float)19.7057, (float)95.2381 },
    { (float)29.2295, (float)100 },
    { (float)48.2771, (float)100 },
    { (float)57.801, (float)95.2381 },
    { (float)62.5629, (float)90.4762 },
    { (float)67.3248, (float)80.9524 },
    { (float)67.3248, (float)71.4286 },
    { (float)62.5629, (float)61.9048 },
    { (float)53.039, (float)47.619 },
    { (float)5.42, (float)0 },
    { (float)72.0867, (float)0 },
};

static StrokeRec char50[] = {
   { 14, char50_stroke0 },
};

/* char: 51 '3' */

static CoordRec char51_stroke0[] = {
    { (float)14.5238, (float)100 },
    { (float)66.9048, (float)100 },
    { (float)38.3333, (float)61.9048 },
    { (float)52.619, (float)61.9048 },
    { (float)62.1429, (float)57.1429 },
    { (float)66.9048, (float)52.381 },
    { (float)71.6667, (float)38.0952 },
    { (float)71.6667, (float)28.5714 },
    { (float)66.9048, (float)14.2857 },
    { (float)57.381, (float)4.7619 },
    { (float)43.0952, (float)0 },
    { (float)28.8095, (float)0 },
    { (float)14.5238, (float)4.7619 },
    { (float)9.7619, (float)9.5238 },
    { (float)5, (float)19.0476 },
};

static StrokeRec char51[] = {
   { 15, char51_stroke0 },
};

/* char: 52 '4' */

static CoordRec char52_stroke0[] = {
    { (float)51.499, (float)100 },
    { (float)3.88, (float)33.3333 },
    { (float)75.3086, (float)33.3333 },
};

static CoordRec char52_stroke1[] = {
    { (float)51.499, (float)100 },
    { (float)51.499, (float)0 },
};

static StrokeRec char52[] = {
   { 3, char52_stroke0 },
   { 2, char52_stroke1 },
};

/* char: 53 '5' */

static CoordRec char53_stroke0[] = {
    { (float)62.0029, (float)100 },
    { (float)14.3838, (float)100 },
    { (float)9.6219, (float)57.1429 },
    { (float)14.3838, (float)61.9048 },
    { (float)28.6695, (float)66.6667 },
    { (float)42.9552, (float)66.6667 },
    { (float)57.241, (float)61.9048 },
    { (float)66.7648, (float)52.381 },
    { (float)71.5267, (float)38.0952 },
    { (float)71.5267, (float)28.5714 },
    { (float)66.7648, (float)14.2857 },
    { (float)57.241, (float)4.7619 },
    { (float)42.9552, (float)0 },
    { (float)28.6695, (float)0 },
    { (float)14.3838, (float)4.7619 },
    { (float)9.6219, (float)9.5238 },
    { (float)4.86, (float)19.0476 },
};

static StrokeRec char53[] = {
   { 17, char53_stroke0 },
};

/* char: 54 '6' */

static CoordRec char54_stroke0[] = {
    { (float)62.7229, (float)85.7143 },
    { (float)57.961, (float)95.2381 },
    { (float)43.6752, (float)100 },
    { (float)34.1514, (float)100 },
    { (float)19.8657, (float)95.2381 },
    { (float)10.3419, (float)80.9524 },
    { (float)5.58, (float)57.1429 },
    { (float)5.58, (float)33.3333 },
    { (float)10.3419, (float)14.2857 },
    { (float)19.8657, (float)4.7619 },
    { (float)34.1514, (float)0 },
    { (float)38.9133, (float)0 },
    { (float)53.199, (float)4.7619 },
    { (float)62.7229, (float)14.2857 },
    { (float)67.4848, (float)28.5714 },
    { (float)67.4848, (float)33.3333 },
    { (float)62.7229, (float)47.619 },
    { (float)53.199, (float)57.1429 },
    { (float)38.9133, (float)61.9048 },
    { (float)34.1514, (float)61.9048 },
    { (float)19.8657, (float)57.1429 },
    { (float)10.3419, (float)47.619 },
    { (float)5.58, (float)33.3333 },
};

static StrokeRec char54[] = {
   { 23, char54_stroke0 },
};

/* char: 55 '7' */

static CoordRec char55_stroke0[] = {
    { (float)72.2267, (float)100 },
    { (float)24.6076, (float)0 },
};

static CoordRec char55_stroke1[] = {
    { (float)5.56, (float)100 },
    { (float)72.2267, (float)100 },
};

static StrokeRec char55[] = {
   { 2, char55_stroke0 },
   { 2, char55_stroke1 },
};

/* char: 56 '8' */

static CoordRec char56_stroke0[] = {
    { (float)29.4095, (float)100 },
    { (float)15.1238, (float)95.2381 },
    { (float)10.3619, (float)85.7143 },
    { (float)10.3619, (float)76.1905 },
    { (float)15.1238, (float)66.6667 },
    { (float)24.6476, (float)61.9048 },
    { (float)43.6952, (float)57.1429 },
    { (float)57.981, (float)52.381 },
    { (float)67.5048, (float)42.8571 },
    { (float)72.2667, (float)33.3333 },
    { (float)72.2667, (float)19.0476 },
    { (float)67.5048, (float)9.5238 },
    { (float)62.7429, (float)4.7619 },
    { (float)48.4571, (float)0 },
    { (float)29.4095, (float)0 },
    { (float)15.1238, (float)4.7619 },
    { (float)10.3619, (float)9.5238 },
    { (float)5.6, (float)19.0476 },
    { (float)5.6, (float)33.3333 },
    { (float)10.3619, (float)42.8571 },
    { (float)19.8857, (float)52.381 },
    { (float)34.1714, (float)57.1429 },
    { (float)53.219, (float)61.9048 },
    { (float)62.7429, (float)66.6667 },
    { (float)67.5048, (float)76.1905 },
    { (float)67.5048, (float)85.7143 },
    { (float)62.7429, (float)95.2381 },
    { (float)48.4571, (float)100 },
    { (float)29.4095, (float)100 },
};

static StrokeRec char56[] = {
   { 29, char56_stroke0 },
};

/* char: 57 '9' */

static CoordRec char57_stroke0[] = {
    { (float)68.5048, (float)66.6667 },
    { (float)63.7429, (float)52.381 },
    { (float)54.219, (float)42.8571 },
    { (float)39.9333, (float)38.0952 },
    { (float)35.1714, (float)38.0952 },
    { (float)20.8857, (float)42.8571 },
    { (float)11.3619, (float)52.381 },
    { (float)6.6, (float)66.6667 },
    { (float)6.6, (float)71.4286 },
    { (float)11.3619, (float)85.7143 },
    { (float)20.8857, (float)95.2381 },
    { (float)35.1714, (float)100 },
    { (float)39.9333, (float)100 },
    { (float)54.219, (float)95.2381 },
    { (float)63.7429, (float)85.7143 },
    { (float)68.5048, (float)66.6667 },
    { (float)68.5048, (float)42.8571 },
    { (float)63.7429, (float)19.0476 },
    { (float)54.219, (float)4.7619 },
    { (float)39.9333, (float)0 },
    { (float)30.4095, (float)0 },
    { (float)16.1238, (float)4.7619 },
    { (float)11.3619, (float)14.2857 },
};

static StrokeRec char57[] = {
   { 23, char57_stroke0 },
};

/* char: 58 ':' */

static CoordRec char58_stroke0[] = {
    { (float)14.0819, (float)66.6667 },
    { (float)9.32, (float)61.9048 },
    { (float)14.0819, (float)57.1429 },
    { (float)18.8438, (float)61.9048 },
    { (float)14.0819, (float)66.6667 },
};

static CoordRec char58_stroke1[] = {
    { (float)14.0819, (float)9.5238 },
    { (float)9.32, (float)4.7619 },
    { (float)14.0819, (float)0 },
    { (float)18.8438, (float)4.7619 },
    { (float)14.0819, (float)9.5238 },
};

static StrokeRec char58[] = {
   { 5, char58_stroke0 },
   { 5, char58_stroke1 },
};

/* char: 59 ';' */

static CoordRec char59_stroke0[] = {
    { (float)12.9619, (float)66.6667 },
    { (float)8.2, (float)61.9048 },
    { (float)12.9619, (float)57.1429 },
    { (float)17.7238, (float)61.9048 },
    { (float)12.9619, (float)66.6667 },
};

static CoordRec char59_stroke1[] = {
    { (float)17.7238, (float)4.7619 },
    { (float)12.9619, (float)0 },
    { (float)8.2, (float)4.7619 },
    { (float)12.9619, (float)9.5238 },
    { (float)17.7238, (float)4.7619 },
    { (float)17.7238, (float)-4.7619 },
    { (float)12.9619, (float)-14.2857 },
    { (float)8.2, (float)-19.0476 },
};

static StrokeRec char59[] = {
   { 5, char59_stroke0 },
   { 8, char59_stroke1 },
};

/* char: 60 '<' */

static CoordRec char60_stroke0[] = {
    { (float)79.2505, (float)85.7143 },
    { (float)3.06, (float)42.8571 },
    { (float)79.2505, (float)0 },
};

static StrokeRec char60[] = {
   { 3, char60_stroke0 },
};

/* char: 61 '=' */

static CoordRec char61_stroke0[] = {
    { (float)5.7, (float)57.1429 },
    { (float)91.4143, (float)57.1429 },
};

static CoordRec char61_stroke1[] = {
    { (float)5.7, (float)28.5714 },
    { (float)91.4143, (float)28.5714 },
};

static StrokeRec char61[] = {
   { 2, char61_stroke0 },
   { 2, char61_stroke1 },
};

/* char: 62 '>' */

static CoordRec char62_stroke0[] = {
    { (float)2.78, (float)85.7143 },
    { (float)78.9705, (float)42.8571 },
    { (float)2.78, (float)0 },
};

static StrokeRec char62[] = {
   { 3, char62_stroke0 },
};

/* char: 63 '?' */

static CoordRec char63_stroke0[] = {
    { (float)8.42, (float)76.1905 },
    { (float)8.42, (float)80.9524 },
    { (float)13.1819, (float)90.4762 },
    { (float)17.9438, (float)95.2381 },
    { (float)27.4676, (float)100 },
    { (float)46.5152, (float)100 },
    { (float)56.039, (float)95.2381 },
    { (float)60.801, (float)90.4762 },
    { (float)65.5629, (float)80.9524 },
    { (float)65.5629, (float)71.4286 },
    { (float)60.801, (float)61.9048 },
    { (float)56.039, (float)57.1429 },
    { (float)36.9914, (float)47.619 },
    { (float)36.9914, (float)33.3333 },
};

static CoordRec char63_stroke1[] = {
    { (float)36.9914, (float)9.5238 },
    { (float)32.2295, (float)4.7619 },
    { (float)36.9914, (float)0 },
    { (float)41.7533, (float)4.7619 },
    { (float)36.9914, (float)9.5238 },
};

static StrokeRec char63[] = {
   { 14, char63_stroke0 },
   { 5, char63_stroke1 },
};

/* char: 64 '@' */

static CoordRec char64_stroke0[] = {
    { (float)49.2171, (float)52.381 },
    { (float)39.6933, (float)57.1429 },
    { (float)30.1695, (float)57.1429 },
    { (float)25.4076, (float)47.619 },
    { (float)25.4076, (float)42.8571 },
    { (float)30.1695, (float)33.3333 },
    { (float)39.6933, (float)33.3333 },
    { (float)49.2171, (float)38.0952 },
};

static CoordRec char64_stroke1[] = {
    { (float)49.2171, (float)57.1429 },
    { (float)49.2171, (float)38.0952 },
    { (float)53.979, (float)33.3333 },
    { (float)63.5029, (float)33.3333 },
    { (float)68.2648, (float)42.8571 },
    { (float)68.2648, (float)47.619 },
    { (float)63.5029, (float)61.9048 },
    { (float)53.979, (float)71.4286 },
    { (float)39.6933, (float)76.1905 },
    { (float)34.9314, (float)76.1905 },
    { (float)20.6457, (float)71.4286 },
    { (float)11.1219, (float)61.9048 },
    { (float)6.36, (float)47.619 },
    { (float)6.36, (float)42.8571 },
    { (float)11.1219, (float)28.5714 },
    { (float)20.6457, (float)19.0476 },
    { (float)34.9314, (float)14.2857 },
    { (float)39.6933, (float)14.2857 },
    { (float)53.979, (float)19.0476 },
};

static StrokeRec char64[] = {
   { 8, char64_stroke0 },
   { 19, char64_stroke1 },
};

/* char: 65 'A' */

static CoordRec char65_stroke0[] = {
    { (float)40.5952, (float)100 },
    { (float)2.5, (float)0 },
};

static CoordRec char65_stroke1[] = {
    { (float)40.5952, (float)100 },
    { (float)78.6905, (float)0 },
};

static CoordRec char65_stroke2[] = {
    { (float)16.7857, (float)33.3333 },
    { (float)64.4048, (float)33.3333 },
};

static StrokeRec char65[] = {
   { 2, char65_stroke0 },
   { 2, char65_stroke1 },
   { 2, char65_stroke2 },
};

/* char: 66 'B' */

static CoordRec char66_stroke0[] = {
    { (float)11.42, (float)100 },
    { (float)11.42, (float)0 },
};

static CoordRec char66_stroke1[] = {
    { (float)11.42, (float)100 },
    { (float)54.2771, (float)100 },
    { (float)68.5629, (float)95.2381 },
    { (float)73.3248, (float)90.4762 },
    { (float)78.0867, (float)80.9524 },
    { (float)78.0867, (float)71.4286 },
    { (float)73.3248, (float)61.9048 },
    { (float)68.5629, (float)57.1429 },
    { (float)54.2771, (float)52.381 },
};

static CoordRec char66_stroke2[] = {
    { (float)11.42, (float)52.381 },
    { (float)54.2771, (float)52.381 },
    { (float)68.5629, (float)47.619 },
    { (float)73.3248, (float)42.8571 },
    { (float)78.0867, (float)33.3333 },
    { (float)78.0867, (float)19.0476 },
    { (float)73.3248, (float)9.5238 },
    { (float)68.5629, (float)4.7619 },
    { (float)54.2771, (float)0 },
    { (float)11.42, (float)0 },
};

static StrokeRec char66[] = {
   { 2, char66_stroke0 },
   { 9, char66_stroke1 },
   { 10, char66_stroke2 },
};

/* char: 67 'C' */

static CoordRec char67_stroke0[] = {
    { (float)78.0886, (float)76.1905 },
    { (float)73.3267, (float)85.7143 },
    { (float)63.8029, (float)95.2381 },
    { (float)54.279, (float)100 },
    { (float)35.2314, (float)100 },
    { (float)25.7076, (float)95.2381 },
    { (float)16.1838, (float)85.7143 },
    { (float)11.4219, (float)76.1905 },
    { (float)6.66, (float)61.9048 },
    { (float)6.66, (float)38.0952 },
    { (float)11.4219, (float)23.8095 },
    { (float)16.1838, (float)14.2857 },
    { (float)25.7076, (float)4.7619 },
    { (float)35.2314, (float)0 },
    { (float)54.279, (float)0 },
    { (float)63.8029, (float)4.7619 },
    { (float)73.3267, (float)14.2857 },
    { (float)78.0886, (float)23.8095 },
};

static StrokeRec char67[] = {
   { 18, char67_stroke0 },
};

/* char: 68 'D' */

static CoordRec char68_stroke0[] = {
    { (float)11.96, (float)100 },
    { (float)11.96, (float)0 },
};

static CoordRec char68_stroke1[] = {
    { (float)11.96, (float)100 },
    { (float)45.2933, (float)100 },
    { (float)59.579, (float)95.2381 },
    { (float)69.1029, (float)85.7143 },
    { (float)73.8648, (float)76.1905 },
    { (float)78.6267, (float)61.9048 },
    { (float)78.6267, (float)38.0952 },
    { (float)73.8648, (float)23.8095 },
    { (float)69.1029, (float)14.2857 },
    { (float)59.579, (float)4.7619 },
    { (float)45.2933, (float)0 },
    { (float)11.96, (float)0 },
};

static StrokeRec char68[] = {
   { 2, char68_stroke0 },
   { 12, char68_stroke1 },
};

/* char: 69 'E' */

static CoordRec char69_stroke0[] = {
    { (float)11.42, (float)100 },
    { (float)11.42, (float)0 },
};

static CoordRec char69_stroke1[] = {
    { (float)11.42, (float)100 },
    { (float)73.3248, (float)100 },
};

static CoordRec char69_stroke2[] = {
    { (float)11.42, (float)52.381 },
    { (float)49.5152, (float)52.381 },
};

static CoordRec char69_stroke3[] = {
    { (float)11.42, (float)0 },
    { (float)73.3248, (float)0 },
};

static StrokeRec char69[] = {
   { 2, char69_stroke0 },
   { 2, char69_stroke1 },
   { 2, char69_stroke2 },
   { 2, char69_stroke3 },
};

/* char: 70 'F' */

static CoordRec char70_stroke0[] = {
    { (float)11.42, (float)100 },
    { (float)11.42, (float)0 },
};

static CoordRec char70_stroke1[] = {
    { (float)11.42, (float)100 },
    { (float)73.3248, (float)100 },
};

static CoordRec char70_stroke2[] = {
    { (float)11.42, (float)52.381 },
    { (float)49.5152, (float)52.381 },
};

static StrokeRec char70[] = {
   { 2, char70_stroke0 },
   { 2, char70_stroke1 },
   { 2, char70_stroke2 },
};

/* char: 71 'G' */

static CoordRec char71_stroke0[] = {
    { (float)78.4886, (float)76.1905 },
    { (float)73.7267, (float)85.7143 },
    { (float)64.2029, (float)95.2381 },
    { (float)54.679, (float)100 },
    { (float)35.6314, (float)100 },
    { (float)26.1076, (float)95.2381 },
    { (float)16.5838, (float)85.7143 },
    { (float)11.8219, (float)76.1905 },
    { (float)7.06, (float)61.9048 },
    { (float)7.06, (float)38.0952 },
    { (float)11.8219, (float)23.8095 },
    { (float)16.5838, (float)14.2857 },
    { (float)26.1076, (float)4.7619 },
    { (float)35.6314, (float)0 },
    { (float)54.679, (float)0 },
    { (float)64.2029, (float)4.7619 },
    { (float)73.7267, (float)14.2857 },
    { (float)78.4886, (float)23.8095 },
    { (float)78.4886, (float)38.0952 },
};

static CoordRec char71_stroke1[] = {
    { (float)54.679, (float)38.0952 },
    { (float)78.4886, (float)38.0952 },
};

static StrokeRec char71[] = {
   { 19, char71_stroke0 },
   { 2, char71_stroke1 },
};

/* char: 72 'H' */

static CoordRec char72_stroke0[] = {
    { (float)11.42, (float)100 },
    { (float)11.42, (float)0 },
};

static CoordRec char72_stroke1[] = {
    { (float)78.0867, (float)100 },
    { (float)78.0867, (float)0 },
};

static CoordRec char72_stroke2[] = {
    { (float)11.42, (float)52.381 },
    { (float)78.0867, (float)52.381 },
};

static StrokeRec char72[] = {
   { 2, char72_stroke0 },
   { 2, char72_stroke1 },
   { 2, char72_stroke2 },
};

/* char: 73 'I' */

static CoordRec char73_stroke0[] = {
    { (float)10.86, (float)100 },
    { (float)10.86, (float)0 },
};

static StrokeRec char73[] = {
   { 2, char73_stroke0 },
};

/* char: 74 'J' */

static CoordRec char74_stroke0[] = {
    { (float)50.119, (float)100 },
    { (float)50.119, (float)23.8095 },
    { (float)45.3571, (float)9.5238 },
    { (float)40.5952, (float)4.7619 },
    { (float)31.0714, (float)0 },
    { (float)21.5476, (float)0 },
    { (float)12.0238, (float)4.7619 },
    { (float)7.2619, (float)9.5238 },
    { (float)2.5, (float)23.8095 },
    { (float)2.5, (float)33.3333 },
};

static StrokeRec char74[] = {
   { 10, char74_stroke0 },
};

/* char: 75 'K' */

static CoordRec char75_stroke0[] = {
    { (float)11.28, (float)100 },
    { (float)11.28, (float)0 },
};

static CoordRec char75_stroke1[] = {
    { (float)77.9467, (float)100 },
    { (float)11.28, (float)33.3333 },
};

static CoordRec char75_stroke2[] = {
    { (float)35.0895, (float)57.1429 },
    { (float)77.9467, (float)0 },
};

static StrokeRec char75[] = {
   { 2, char75_stroke0 },
   { 2, char75_stroke1 },
   { 2, char75_stroke2 },
};

/* char: 76 'L' */

static CoordRec char76_stroke0[] = {
    { (float)11.68, (float)100 },
    { (float)11.68, (float)0 },
};

static CoordRec char76_stroke1[] = {
    { (float)11.68, (float)0 },
    { (float)68.8229, (float)0 },
};

static StrokeRec char76[] = {
   { 2, char76_stroke0 },
   { 2, char76_stroke1 },
};

/* char: 77 'M' */

static CoordRec char77_stroke0[] = {
    { (float)10.86, (float)100 },
    { (float)10.86, (float)0 },
};

static CoordRec char77_stroke1[] = {
    { (float)10.86, (float)100 },
    { (float)48.9552, (float)0 },
};

static CoordRec char77_stroke2[] = {
    { (float)87.0505, (float)100 },
    { (float)48.9552, (float)0 },
};

static CoordRec char77_stroke3[] = {
    { (float)87.0505, (float)100 },
    { (float)87.0505, (float)0 },
};

static StrokeRec char77[] = {
   { 2, char77_stroke0 },
   { 2, char77_stroke1 },
   { 2, char77_stroke2 },
   { 2, char77_stroke3 },
};

/* char: 78 'N' */

static CoordRec char78_stroke0[] = {
    { (float)11.14, (float)100 },
    { (float)11.14, (float)0 },
};

static CoordRec char78_stroke1[] = {
    { (float)11.14, (float)100 },
    { (float)77.8067, (float)0 },
};

static CoordRec char78_stroke2[] = {
    { (float)77.8067, (float)100 },
    { (float)77.8067, (float)0 },
};

static StrokeRec char78[] = {
   { 2, char78_stroke0 },
   { 2, char78_stroke1 },
   { 2, char78_stroke2 },
};

/* char: 79 'O' */

static CoordRec char79_stroke0[] = {
    { (float)34.8114, (float)100 },
    { (float)25.2876, (float)95.2381 },
    { (float)15.7638, (float)85.7143 },
    { (float)11.0019, (float)76.1905 },
    { (float)6.24, (float)61.9048 },
    { (float)6.24, (float)38.0952 },
    { (float)11.0019, (float)23.8095 },
    { (float)15.7638, (float)14.2857 },
    { (float)25.2876, (float)4.7619 },
    { (float)34.8114, (float)0 },
    { (float)53.859, (float)0 },
    { (float)63.3829, (float)4.7619 },
    { (float)72.9067, (float)14.2857 },
    { (float)77.6686, (float)23.8095 },
    { (float)82.4305, (float)38.0952 },
    { (float)82.4305, (float)61.9048 },
    { (float)77.6686, (float)76.1905 },
    { (float)72.9067, (float)85.7143 },
    { (float)63.3829, (float)95.2381 },
    { (float)53.859, (float)100 },
    { (float)34.8114, (float)100 },
};

static StrokeRec char79[] = {
   { 21, char79_stroke0 },
};

/* char: 80 'P' */

static CoordRec char80_stroke0[] = {
    { (float)12.1, (float)100 },
    { (float)12.1, (float)0 },
};

static CoordRec char80_stroke1[] = {
    { (float)12.1, (float)100 },
    { (float)54.9571, (float)100 },
    { (float)69.2429, (float)95.2381 },
    { (float)74.0048, (float)90.4762 },
    { (float)78.7667, (float)80.9524 },
    { (float)78.7667, (float)66.6667 },
    { (float)74.0048, (float)57.1429 },
    { (float)69.2429, (float)52.381 },
    { (float)54.9571, (float)47.619 },
    { (float)12.1, (float)47.619 },
};

static StrokeRec char80[] = {
   { 2, char80_stroke0 },
   { 10, char80_stroke1 },
};

/* char: 81 'Q' */

static CoordRec char81_stroke0[] = {
    { (float)33.8714, (float)100 },
    { (float)24.3476, (float)95.2381 },
    { (float)14.8238, (float)85.7143 },
    { (float)10.0619, (float)76.1905 },
    { (float)5.3, (float)61.9048 },
    { (float)5.3, (float)38.0952 },
    { (float)10.0619, (float)23.8095 },
    { (float)14.8238, (float)14.2857 },
    { (float)24.3476, (float)4.7619 },
    { (float)33.8714, (float)0 },
    { (float)52.919, (float)0 },
    { (float)62.4429, (float)4.7619 },
    { (float)71.9667, (float)14.2857 },
    { (float)76.7286, (float)23.8095 },
    { (float)81.4905, (float)38.0952 },
    { (float)81.4905, (float)61.9048 },
    { (float)76.7286, (float)76.1905 },
    { (float)71.9667, (float)85.7143 },
    { (float)62.4429, (float)95.2381 },
    { (float)52.919, (float)100 },
    { (float)33.8714, (float)100 },
};

static CoordRec char81_stroke1[] = {
    { (float)48.1571, (float)19.0476 },
    { (float)76.7286, (float)-9.5238 },
};

static StrokeRec char81[] = {
   { 21, char81_stroke0 },
   { 2, char81_stroke1 },
};

/* char: 82 'R' */

static CoordRec char82_stroke0[] = {
    { (float)11.68, (float)100 },
    { (float)11.68, (float)0 },
};

static CoordRec char82_stroke1[] = {
    { (float)11.68, (float)100 },
    { (float)54.5371, (float)100 },
    { (float)68.8229, (float)95.2381 },
    { (float)73.5848, (float)90.4762 },
    { (float)78.3467, (float)80.9524 },
    { (float)78.3467, (float)71.4286 },
    { (float)73.5848, (float)61.9048 },
    { (float)68.8229, (float)57.1429 },
    { (float)54.5371, (float)52.381 },
    { (float)11.68, (float)52.381 },
};

static CoordRec char82_stroke2[] = {
    { (float)45.0133, (float)52.381 },
    { (float)78.3467, (float)0 },
};

static StrokeRec char82[] = {
   { 2, char82_stroke0 },
   { 10, char82_stroke1 },
   { 2, char82_stroke2 },
};

/* char: 83 'S' */

static CoordRec char83_stroke0[] = {
    { (float)74.6667, (float)85.7143 },
    { (float)65.1429, (float)95.2381 },
    { (float)50.8571, (float)100 },
    { (float)31.8095, (float)100 },
    { (float)17.5238, (float)95.2381 },
    { (float)8, (float)85.7143 },
    { (float)8, (float)76.1905 },
    { (float)12.7619, (float)66.6667 },
    { (float)17.5238, (float)61.9048 },
    { (float)27.0476, (float)57.1429 },
    { (float)55.619, (float)47.619 },
    { (float)65.1429, (float)42.8571 },
    { (float)69.9048, (float)38.0952 },
    { (float)74.6667, (float)28.5714 },
    { (float)74.6667, (float)14.2857 },
    { (float)65.1429, (float)4.7619 },
    { (float)50.8571, (float)0 },
    { (float)31.8095, (float)0 },
    { (float)17.5238, (float)4.7619 },
    { (float)8, (float)14.2857 },
};

static StrokeRec char83[] = {
   { 20, char83_stroke0 },
};

/* char: 84 'T' */

static CoordRec char84_stroke0[] = {
    { (float)35.6933, (float)100 },
    { (float)35.6933, (float)0 },
};

static CoordRec char84_stroke1[] = {
    { (float)2.36, (float)100 },
    { (float)69.0267, (float)100 },
};

static StrokeRec char84[] = {
   { 2, char84_stroke0 },
   { 2, char84_stroke1 },
};

/* char: 85 'U' */

static CoordRec char85_stroke0[] = {
    { (float)11.54, (float)100 },
    { (float)11.54, (float)28.5714 },
    { (float)16.3019, (float)14.2857 },
    { (float)25.8257, (float)4.7619 },
    { (float)40.1114, (float)0 },
    { (float)49.6352, (float)0 },
    { (float)63.921, (float)4.7619 },
    { (float)73.4448, (float)14.2857 },
    { (float)78.2067, (float)28.5714 },
    { (float)78.2067, (float)100 },
};

static StrokeRec char85[] = {
   { 10, char85_stroke0 },
};

/* char: 86 'V' */

static CoordRec char86_stroke0[] = {
    { (float)2.36, (float)100 },
    { (float)40.4552, (float)0 },
};

static CoordRec char86_stroke1[] = {
    { (float)78.5505, (float)100 },
    { (float)40.4552, (float)0 },
};

static StrokeRec char86[] = {
   { 2, char86_stroke0 },
   { 2, char86_stroke1 },
};

/* char: 87 'W' */

static CoordRec char87_stroke0[] = {
    { (float)2.22, (float)100 },
    { (float)26.0295, (float)0 },
};

static CoordRec char87_stroke1[] = {
    { (float)49.839, (float)100 },
    { (float)26.0295, (float)0 },
};

static CoordRec char87_stroke2[] = {
    { (float)49.839, (float)100 },
    { (float)73.6486, (float)0 },
};

static CoordRec char87_stroke3[] = {
    { (float)97.4581, (float)100 },
    { (float)73.6486, (float)0 },
};

static StrokeRec char87[] = {
   { 2, char87_stroke0 },
   { 2, char87_stroke1 },
   { 2, char87_stroke2 },
   { 2, char87_stroke3 },
};

/* char: 88 'X' */

static CoordRec char88_stroke0[] = {
    { (float)2.5, (float)100 },
    { (float)69.1667, (float)0 },
};

static CoordRec char88_stroke1[] = {
    { (float)69.1667, (float)100 },
    { (float)2.5, (float)0 },
};

static StrokeRec char88[] = {
   { 2, char88_stroke0 },
   { 2, char88_stroke1 },
};

/* char: 89 'Y' */

static CoordRec char89_stroke0[] = {
    { (float)1.52, (float)100 },
    { (float)39.6152, (float)52.381 },
    { (float)39.6152, (float)0 },
};

static CoordRec char89_stroke1[] = {
    { (float)77.7105, (float)100 },
    { (float)39.6152, (float)52.381 },
};

static StrokeRec char89[] = {
   { 3, char89_stroke0 },
   { 2, char89_stroke1 },
};

/* char: 90 'Z' */

static CoordRec char90_stroke0[] = {
    { (float)69.1667, (float)100 },
    { (float)2.5, (float)0 },
};

static CoordRec char90_stroke1[] = {
    { (float)2.5, (float)100 },
    { (float)69.1667, (float)100 },
};

static CoordRec char90_stroke2[] = {
    { (float)2.5, (float)0 },
    { (float)69.1667, (float)0 },
};

static StrokeRec char90[] = {
   { 2, char90_stroke0 },
   { 2, char90_stroke1 },
   { 2, char90_stroke2 },
};

/* char: 91 '[' */

static CoordRec char91_stroke0[] = {
    { (float)7.78, (float)119.048 },
    { (float)7.78, (float)-33.3333 },
};

static CoordRec char91_stroke1[] = {
    { (float)12.5419, (float)119.048 },
    { (float)12.5419, (float)-33.3333 },
};

static CoordRec char91_stroke2[] = {
    { (float)7.78, (float)119.048 },
    { (float)41.1133, (float)119.048 },
};

static CoordRec char91_stroke3[] = {
    { (float)7.78, (float)-33.3333 },
    { (float)41.1133, (float)-33.3333 },
};

static StrokeRec char91[] = {
   { 2, char91_stroke0 },
   { 2, char91_stroke1 },
   { 2, char91_stroke2 },
   { 2, char91_stroke3 },
};

/* char: 92 '\' */

static CoordRec char92_stroke0[] = {
    { (float)5.84, (float)100 },
    { (float)72.5067, (float)-14.2857 },
};

static StrokeRec char92[] = {
   { 2, char92_stroke0 },
};

/* char: 93 ']' */

static CoordRec char93_stroke0[] = {
    { (float)33.0114, (float)119.048 },
    { (float)33.0114, (float)-33.3333 },
};

static CoordRec char93_stroke1[] = {
    { (float)37.7733, (float)119.048 },
    { (float)37.7733, (float)-33.3333 },
};

static CoordRec char93_stroke2[] = {
    { (float)4.44, (float)119.048 },
    { (float)37.7733, (float)119.048 },
};

static CoordRec char93_stroke3[] = {
    { (float)4.44, (float)-33.3333 },
    { (float)37.7733, (float)-33.3333 },
};

static StrokeRec char93[] = {
   { 2, char93_stroke0 },
   { 2, char93_stroke1 },
   { 2, char93_stroke2 },
   { 2, char93_stroke3 },
};

/* char: 94 '^' */

static CoordRec char94_stroke0[] = {
    { (float)44.0752, (float)109.524 },
    { (float)5.98, (float)42.8571 },
};

static CoordRec char94_stroke1[] = {
    { (float)44.0752, (float)109.524 },
    { (float)82.1705, (float)42.8571 },
};

static StrokeRec char94[] = {
   { 2, char94_stroke0 },
   { 2, char94_stroke1 },
};

/* char: 95 '_' */

static CoordRec char95_stroke0[] = {
    { (float)-1.1, (float)-33.3333 },
    { (float)103.662, (float)-33.3333 },
    { (float)103.662, (float)-28.5714 },
    { (float)-1.1, (float)-28.5714 },
    { (float)-1.1, (float)-33.3333 },
};

static StrokeRec char95[] = {
   { 5, char95_stroke0 },
};

/* char: 96 '`' */

static CoordRec char96_stroke0[] = {
    { (float)33.0219, (float)100 },
    { (float)56.8314, (float)71.4286 },
};

static CoordRec char96_stroke1[] = {
    { (float)33.0219, (float)100 },
    { (float)28.26, (float)95.2381 },
    { (float)56.8314, (float)71.4286 },
};

static StrokeRec char96[] = {
   { 2, char96_stroke0 },
   { 3, char96_stroke1 },
};

/* char: 97 'a' */

static CoordRec char97_stroke0[] = {
    { (float)63.8229, (float)66.6667 },
    { (float)63.8229, (float)0 },
};

static CoordRec char97_stroke1[] = {
    { (float)63.8229, (float)52.381 },
    { (float)54.299, (float)61.9048 },
    { (float)44.7752, (float)66.6667 },
    { (float)30.4895, (float)66.6667 },
    { (float)20.9657, (float)61.9048 },
    { (float)11.4419, (float)52.381 },
    { (float)6.68, (float)38.0952 },
    { (float)6.68, (float)28.5714 },
    { (float)11.4419, (float)14.2857 },
    { (float)20.9657, (float)4.7619 },
    { (float)30.4895, (float)0 },
    { (float)44.7752, (float)0 },
    { (float)54.299, (float)4.7619 },
    { (float)63.8229, (float)14.2857 },
};

static StrokeRec char97[] = {
   { 2, char97_stroke0 },
   { 14, char97_stroke1 },
};

/* char: 98 'b' */

static CoordRec char98_stroke0[] = {
    { (float)8.76, (float)100 },
    { (float)8.76, (float)0 },
};

static CoordRec char98_stroke1[] = {
    { (float)8.76, (float)52.381 },
    { (float)18.2838, (float)61.9048 },
    { (float)27.8076, (float)66.6667 },
    { (float)42.0933, (float)66.6667 },
    { (float)51.6171, (float)61.9048 },
    { (float)61.141, (float)52.381 },
    { (float)65.9029, (float)38.0952 },
    { (float)65.9029, (float)28.5714 },
    { (float)61.141, (float)14.2857 },
    { (float)51.6171, (float)4.7619 },
    { (float)42.0933, (float)0 },
    { (float)27.8076, (float)0 },
    { (float)18.2838, (float)4.7619 },
    { (float)8.76, (float)14.2857 },
};

static StrokeRec char98[] = {
   { 2, char98_stroke0 },
   { 14, char98_stroke1 },
};

/* char: 99 'c' */

static CoordRec char99_stroke0[] = {
    { (float)62.6629, (float)52.381 },
    { (float)53.139, (float)61.9048 },
    { (float)43.6152, (float)66.6667 },
    { (float)29.3295, (float)66.6667 },
    { (float)19.8057, (float)61.9048 },
    { (float)10.2819, (float)52.381 },
    { (float)5.52, (float)38.0952 },
    { (float)5.52, (float)28.5714 },
    { (float)10.2819, (float)14.2857 },
    { (float)19.8057, (float)4.7619 },
    { (float)29.3295, (float)0 },
    { (float)43.6152, (float)0 },
    { (float)53.139, (float)4.7619 },
    { (float)62.6629, (float)14.2857 },
};

static StrokeRec char99[] = {
   { 14, char99_stroke0 },
};

/* char: 100 'd' */

static CoordRec char100_stroke0[] = {
    { (float)61.7829, (float)100 },
    { (float)61.7829, (float)0 },
};

static CoordRec char100_stroke1[] = {
    { (float)61.7829, (float)52.381 },
    { (float)52.259, (float)61.9048 },
    { (float)42.7352, (float)66.6667 },
    { (float)28.4495, (float)66.6667 },
    { (float)18.9257, (float)61.9048 },
    { (float)9.4019, (float)52.381 },
    { (float)4.64, (float)38.0952 },
    { (float)4.64, (float)28.5714 },
    { (float)9.4019, (float)14.2857 },
    { (float)18.9257, (float)4.7619 },
    { (float)28.4495, (float)0 },
    { (float)42.7352, (float)0 },
    { (float)52.259, (float)4.7619 },
    { (float)61.7829, (float)14.2857 },
};

static StrokeRec char100[] = {
   { 2, char100_stroke0 },
   { 14, char100_stroke1 },
};

/* char: 101 'e' */

static CoordRec char101_stroke0[] = {
    { (float)5.72, (float)38.0952 },
    { (float)62.8629, (float)38.0952 },
    { (float)62.8629, (float)47.619 },
    { (float)58.101, (float)57.1429 },
    { (float)53.339, (float)61.9048 },
    { (float)43.8152, (float)66.6667 },
    { (float)29.5295, (float)66.6667 },
    { (float)20.0057, (float)61.9048 },
    { (float)10.4819, (float)52.381 },
    { (float)5.72, (float)38.0952 },
    { (float)5.72, (float)28.5714 },
    { (float)10.4819, (float)14.2857 },
    { (float)20.0057, (float)4.7619 },
    { (float)29.5295, (float)0 },
    { (float)43.8152, (float)0 },
    { (float)53.339, (float)4.7619 },
    { (float)62.8629, (float)14.2857 },
};

static StrokeRec char101[] = {
   { 17, char101_stroke0 },
};

/* char: 102 'f' */

static CoordRec char102_stroke0[] = {
    { (float)38.7752, (float)100 },
    { (float)29.2514, (float)100 },
    { (float)19.7276, (float)95.2381 },
    { (float)14.9657, (float)80.9524 },
    { (float)14.9657, (float)0 },
};

static CoordRec char102_stroke1[] = {
    { (float)0.68, (float)66.6667 },
    { (float)34.0133, (float)66.6667 },
};

static StrokeRec char102[] = {
   { 5, char102_stroke0 },
   { 2, char102_stroke1 },
};

/* char: 103 'g' */

static CoordRec char103_stroke0[] = {
    { (float)62.5029, (float)66.6667 },
    { (float)62.5029, (float)-9.5238 },
    { (float)57.741, (float)-23.8095 },
    { (float)52.979, (float)-28.5714 },
    { (float)43.4552, (float)-33.3333 },
    { (float)29.1695, (float)-33.3333 },
    { (float)19.6457, (float)-28.5714 },
};

static CoordRec char103_stroke1[] = {
    { (float)62.5029, (float)52.381 },
    { (float)52.979, (float)61.9048 },
    { (float)43.4552, (float)66.6667 },
    { (float)29.1695, (float)66.6667 },
    { (float)19.6457, (float)61.9048 },
    { (float)10.1219, (float)52.381 },
    { (float)5.36, (float)38.0952 },
    { (float)5.36, (float)28.5714 },
    { (float)10.1219, (float)14.2857 },
    { (float)19.6457, (float)4.7619 },
    { (float)29.1695, (float)0 },
    { (float)43.4552, (float)0 },
    { (float)52.979, (float)4.7619 },
    { (float)62.5029, (float)14.2857 },
};

static StrokeRec char103[] = {
   { 7, char103_stroke0 },
   { 14, char103_stroke1 },
};

/* char: 104 'h' */

static CoordRec char104_stroke0[] = {
    { (float)9.6, (float)100 },
    { (float)9.6, (float)0 },
};

static CoordRec char104_stroke1[] = {
    { (float)9.6, (float)47.619 },
    { (float)23.8857, (float)61.9048 },
    { (float)33.4095, (float)66.6667 },
    { (float)47.6952, (float)66.6667 },
    { (float)57.219, (float)61.9048 },
    { (float)61.981, (float)47.619 },
    { (float)61.981, (float)0 },
};

static StrokeRec char104[] = {
   { 2, char104_stroke0 },
   { 7, char104_stroke1 },
};

/* char: 105 'i' */

static CoordRec char105_stroke0[] = {
    { (float)10.02, (float)100 },
    { (float)14.7819, (float)95.2381 },
    { (float)19.5438, (float)100 },
    { (float)14.7819, (float)104.762 },
    { (float)10.02, (float)100 },
};

static CoordRec char105_stroke1[] = {
    { (float)14.7819, (float)66.6667 },
    { (float)14.7819, (float)0 },
};

static StrokeRec char105[] = {
   { 5, char105_stroke0 },
   { 2, char105_stroke1 },
};

/* char: 106 'j' */

static CoordRec char106_stroke0[] = {
    { (float)17.3876, (float)100 },
    { (float)22.1495, (float)95.2381 },
    { (float)26.9114, (float)100 },
    { (float)22.1495, (float)104.762 },
    { (float)17.3876, (float)100 },
};

static CoordRec char106_stroke1[] = {
    { (float)22.1495, (float)66.6667 },
    { (float)22.1495, (float)-14.2857 },
    { (float)17.3876, (float)-28.5714 },
    { (float)7.8638, (float)-33.3333 },
    { (float)-1.66, (float)-33.3333 },
};

static StrokeRec char106[] = {
   { 5, char106_stroke0 },
   { 5, char106_stroke1 },
};

/* char: 107 'k' */

static CoordRec char107_stroke0[] = {
    { (float)9.6, (float)100 },
    { (float)9.6, (float)0 },
};

static CoordRec char107_stroke1[] = {
    { (float)57.219, (float)66.6667 },
    { (float)9.6, (float)19.0476 },
};

static CoordRec char107_stroke2[] = {
    { (float)28.6476, (float)38.0952 },
    { (float)61.981, (float)0 },
};

static StrokeRec char107[] = {
   { 2, char107_stroke0 },
   { 2, char107_stroke1 },
   { 2, char107_stroke2 },
};

/* char: 108 'l' */

static CoordRec char108_stroke0[] = {
    { (float)10.02, (float)100 },
    { (float)10.02, (float)0 },
};

static StrokeRec char108[] = {
   { 2, char108_stroke0 },
};

/* char: 109 'm' */

static CoordRec char109_stroke0[] = {
    { (float)9.6, (float)66.6667 },
    { (float)9.6, (float)0 },
};

static CoordRec char109_stroke1[] = {
    { (float)9.6, (float)47.619 },
    { (float)23.8857, (float)61.9048 },
    { (float)33.4095, (float)66.6667 },
    { (float)47.6952, (float)66.6667 },
    { (float)57.219, (float)61.9048 },
    { (float)61.981, (float)47.619 },
    { (float)61.981, (float)0 },
};

static CoordRec char109_stroke2[] = {
    { (float)61.981, (float)47.619 },
    { (float)76.2667, (float)61.9048 },
    { (float)85.7905, (float)66.6667 },
    { (float)100.076, (float)66.6667 },
    { (float)109.6, (float)61.9048 },
    { (float)114.362, (float)47.619 },
    { (float)114.362, (float)0 },
};

static StrokeRec char109[] = {
   { 2, char109_stroke0 },
   { 7, char109_stroke1 },
   { 7, char109_stroke2 },
};

/* char: 110 'n' */

static CoordRec char110_stroke0[] = {
    { (float)9.18, (float)66.6667 },
    { (float)9.18, (float)0 },
};

static CoordRec char110_stroke1[] = {
    { (float)9.18, (float)47.619 },
    { (float)23.4657, (float)61.9048 },
    { (float)32.9895, (float)66.6667 },
    { (float)47.2752, (float)66.6667 },
    { (float)56.799, (float)61.9048 },
    { (float)61.561, (float)47.619 },
    { (float)61.561, (float)0 },
};

static StrokeRec char110[] = {
   { 2, char110_stroke0 },
   { 7, char110_stroke1 },
};

/* char: 111 'o' */

static CoordRec char111_stroke0[] = {
    { (float)28.7895, (float)66.6667 },
    { (float)19.2657, (float)61.9048 },
    { (float)9.7419, (float)52.381 },
    { (float)4.98, (float)38.0952 },
    { (float)4.98, (float)28.5714 },
    { (float)9.7419, (float)14.2857 },
    { (float)19.2657, (float)4.7619 },
    { (float)28.7895, (float)0 },
    { (float)43.0752, (float)0 },
    { (float)52.599, (float)4.7619 },
    { (float)62.1229, (float)14.2857 },
    { (float)66.8848, (float)28.5714 },
    { (float)66.8848, (float)38.0952 },
    { (float)62.1229, (float)52.381 },
    { (float)52.599, (float)61.9048 },
    { (float)43.0752, (float)66.6667 },
    { (float)28.7895, (float)66.6667 },
};

static StrokeRec char111[] = {
   { 17, char111_stroke0 },
};

/* char: 112 'p' */

static CoordRec char112_stroke0[] = {
    { (float)9.46, (float)66.6667 },
    { (float)9.46, (float)-33.3333 },
};

static CoordRec char112_stroke1[] = {
    { (float)9.46, (float)52.381 },
    { (float)18.9838, (float)61.9048 },
    { (float)28.5076, (float)66.6667 },
    { (float)42.7933, (float)66.6667 },
    { (float)52.3171, (float)61.9048 },
    { (float)61.841, (float)52.381 },
    { (float)66.6029, (float)38.0952 },
    { (float)66.6029, (float)28.5714 },
    { (float)61.841, (float)14.2857 },
    { (float)52.3171, (float)4.7619 },
    { (float)42.7933, (float)0 },
    { (float)28.5076, (float)0 },
    { (float)18.9838, (float)4.7619 },
    { (float)9.46, (float)14.2857 },
};

static StrokeRec char112[] = {
   { 2, char112_stroke0 },
   { 14, char112_stroke1 },
};

/* char: 113 'q' */

static CoordRec char113_stroke0[] = {
    { (float)61.9829, (float)66.6667 },
    { (float)61.9829, (float)-33.3333 },
};

static CoordRec char113_stroke1[] = {
    { (float)61.9829, (float)52.381 },
    { (float)52.459, (float)61.9048 },
    { (float)42.9352, (float)66.6667 },
    { (float)28.6495, (float)66.6667 },
    { (float)19.1257, (float)61.9048 },
    { (float)9.6019, (float)52.381 },
    { (float)4.84, (float)38.0952 },
    { (float)4.84, (float)28.5714 },
    { (float)9.6019, (float)14.2857 },
    { (float)19.1257, (float)4.7619 },
    { (float)28.6495, (float)0 },
    { (float)42.9352, (float)0 },
    { (float)52.459, (float)4.7619 },
    { (float)61.9829, (float)14.2857 },
};

static StrokeRec char113[] = {
   { 2, char113_stroke0 },
   { 14, char113_stroke1 },
};

/* char: 114 'r' */

static CoordRec char114_stroke0[] = {
    { (float)9.46, (float)66.6667 },
    { (float)9.46, (float)0 },
};

static CoordRec char114_stroke1[] = {
    { (float)9.46, (float)38.0952 },
    { (float)14.2219, (float)52.381 },
    { (float)23.7457, (float)61.9048 },
    { (float)33.2695, (float)66.6667 },
    { (float)47.5552, (float)66.6667 },
};

static StrokeRec char114[] = {
   { 2, char114_stroke0 },
   { 5, char114_stroke1 },
};

/* char: 115 's' */

static CoordRec char115_stroke0[] = {
    { (float)57.081, (float)52.381 },
    { (float)52.319, (float)61.9048 },
    { (float)38.0333, (float)66.6667 },
    { (float)23.7476, (float)66.6667 },
    { (float)9.4619, (float)61.9048 },
    { (float)4.7, (float)52.381 },
    { (float)9.4619, (float)42.8571 },
    { (float)18.9857, (float)38.0952 },
    { (float)42.7952, (float)33.3333 },
    { (float)52.319, (float)28.5714 },
    { (float)57.081, (float)19.0476 },
    { (float)57.081, (float)14.2857 },
    { (float)52.319, (float)4.7619 },
    { (float)38.0333, (float)0 },
    { (float)23.7476, (float)0 },
    { (float)9.4619, (float)4.7619 },
    { (float)4.7, (float)14.2857 },
};

static StrokeRec char115[] = {
   { 17, char115_stroke0 },
};

/* char: 116 't' */

static CoordRec char116_stroke0[] = {
    { (float)14.8257, (float)100 },
    { (float)14.8257, (float)19.0476 },
    { (float)19.5876, (float)4.7619 },
    { (float)29.1114, (float)0 },
    { (float)38.6352, (float)0 },
};

static CoordRec char116_stroke1[] = {
    { (float)0.54, (float)66.6667 },
    { (float)33.8733, (float)66.6667 },
};

static StrokeRec char116[] = {
   { 5, char116_stroke0 },
   { 2, char116_stroke1 },
};

/* char: 117 'u' */

static CoordRec char117_stroke0[] = {
    { (float)9.46, (float)66.6667 },
    { (float)9.46, (float)19.0476 },
    { (float)14.2219, (float)4.7619 },
    { (float)23.7457, (float)0 },
    { (float)38.0314, (float)0 },
    { (float)47.5552, (float)4.7619 },
    { (float)61.841, (float)19.0476 },
};

static CoordRec char117_stroke1[] = {
    { (float)61.841, (float)66.6667 },
    { (float)61.841, (float)0 },
};

static StrokeRec char117[] = {
   { 7, char117_stroke0 },
   { 2, char117_stroke1 },
};

/* char: 118 'v' */

static CoordRec char118_stroke0[] = {
    { (float)1.8, (float)66.6667 },
    { (float)30.3714, (float)0 },
};

static CoordRec char118_stroke1[] = {
    { (float)58.9429, (float)66.6667 },
    { (float)30.3714, (float)0 },
};

static StrokeRec char118[] = {
   { 2, char118_stroke0 },
   { 2, char118_stroke1 },
};

/* char: 119 'w' */

static CoordRec char119_stroke0[] = {
    { (float)2.5, (float)66.6667 },
    { (float)21.5476, (float)0 },
};

static CoordRec char119_stroke1[] = {
    { (float)40.5952, (float)66.6667 },
    { (float)21.5476, (float)0 },
};

static CoordRec char119_stroke2[] = {
    { (float)40.5952, (float)66.6667 },
    { (float)59.6429, (float)0 },
};

static CoordRec char119_stroke3[] = {
    { (float)78.6905, (float)66.6667 },
    { (float)59.6429, (float)0 },
};

static StrokeRec char119[] = {
   { 2, char119_stroke0 },
   { 2, char119_stroke1 },
   { 2, char119_stroke2 },
   { 2, char119_stroke3 },
};

/* char: 120 'x' */

static CoordRec char120_stroke0[] = {
    { (float)1.66, (float)66.6667 },
    { (float)54.041, (float)0 },
};

static CoordRec char120_stroke1[] = {
    { (float)54.041, (float)66.6667 },
    { (float)1.66, (float)0 },
};

static StrokeRec char120[] = {
   { 2, char120_stroke0 },
   { 2, char120_stroke1 },
};

/* char: 121 'y' */

static CoordRec char121_stroke0[] = {
    { (float)6.5619, (float)66.6667 },
    { (float)35.1333, (float)0 },
};

static CoordRec char121_stroke1[] = {
    { (float)63.7048, (float)66.6667 },
    { (float)35.1333, (float)0 },
    { (float)25.6095, (float)-19.0476 },
    { (float)16.0857, (float)-28.5714 },
    { (float)6.5619, (float)-33.3333 },
    { (float)1.8, (float)-33.3333 },
};

static StrokeRec char121[] = {
   { 2, char121_stroke0 },
   { 6, char121_stroke1 },
};

/* char: 122 'z' */

static CoordRec char122_stroke0[] = {
    { (float)56.821, (float)66.6667 },
    { (float)4.44, (float)0 },
};

static CoordRec char122_stroke1[] = {
    { (float)4.44, (float)66.6667 },
    { (float)56.821, (float)66.6667 },
};

static CoordRec char122_stroke2[] = {
    { (float)4.44, (float)0 },
    { (float)56.821, (float)0 },
};

static StrokeRec char122[] = {
   { 2, char122_stroke0 },
   { 2, char122_stroke1 },
   { 2, char122_stroke2 },
};

/* char: 123 '{' */

static CoordRec char123_stroke0[] = {
    { (float)31.1895, (float)119.048 },
    { (float)21.6657, (float)114.286 },
    { (float)16.9038, (float)109.524 },
    { (float)12.1419, (float)100 },
    { (float)12.1419, (float)90.4762 },
    { (float)16.9038, (float)80.9524 },
    { (float)21.6657, (float)76.1905 },
    { (float)26.4276, (float)66.6667 },
    { (float)26.4276, (float)57.1429 },
    { (float)16.9038, (float)47.619 },
};

static CoordRec char123_stroke1[] = {
    { (float)21.6657, (float)114.286 },
    { (float)16.9038, (float)104.762 },
    { (float)16.9038, (float)95.2381 },
    { (float)21.6657, (float)85.7143 },
    { (float)26.4276, (float)80.9524 },
    { (float)31.1895, (float)71.4286 },
    { (float)31.1895, (float)61.9048 },
    { (float)26.4276, (float)52.381 },
    { (float)7.38, (float)42.8571 },
    { (float)26.4276, (float)33.3333 },
    { (float)31.1895, (float)23.8095 },
    { (float)31.1895, (float)14.2857 },
    { (float)26.4276, (float)4.7619 },
    { (float)21.6657, (float)0 },
    { (float)16.9038, (float)-9.5238 },
    { (float)16.9038, (float)-19.0476 },
    { (float)21.6657, (float)-28.5714 },
};

static CoordRec char123_stroke2[] = {
    { (float)16.9038, (float)38.0952 },
    { (float)26.4276, (float)28.5714 },
    { (float)26.4276, (float)19.0476 },
    { (float)21.6657, (float)9.5238 },
    { (float)16.9038, (float)4.7619 },
    { (float)12.1419, (float)-4.7619 },
    { (float)12.1419, (float)-14.2857 },
    { (float)16.9038, (float)-23.8095 },
    { (float)21.6657, (float)-28.5714 },
    { (float)31.1895, (float)-33.3333 },
};

static StrokeRec char123[] = {
   { 10, char123_stroke0 },
   { 17, char123_stroke1 },
   { 10, char123_stroke2 },
};

/* char: 124 '|' */

static CoordRec char124_stroke0[] = {
    { (float)11.54, (float)119.048 },
    { (float)11.54, (float)-33.3333 },
};

static StrokeRec char124[] = {
   { 2, char124_stroke0 },
};

/* char: 125 '}' */

static CoordRec char125_stroke0[] = {
    { (float)9.18, (float)119.048 },
    { (float)18.7038, (float)114.286 },
    { (float)23.4657, (float)109.524 },
    { (float)28.2276, (float)100 },
    { (float)28.2276, (float)90.4762 },
    { (float)23.4657, (float)80.9524 },
    { (float)18.7038, (float)76.1905 },
    { (float)13.9419, (float)66.6667 },
    { (float)13.9419, (float)57.1429 },
    { (float)23.4657, (float)47.619 },
};

static CoordRec char125_stroke1[] = {
    { (float)18.7038, (float)114.286 },
    { (float)23.4657, (float)104.762 },
    { (float)23.4657, (float)95.2381 },
    { (float)18.7038, (float)85.7143 },
    { (float)13.9419, (float)80.9524 },
    { (float)9.18, (float)71.4286 },
    { (float)9.18, (float)61.9048 },
    { (float)13.9419, (float)52.381 },
    { (float)32.9895, (float)42.8571 },
    { (float)13.9419, (float)33.3333 },
    { (float)9.18, (float)23.8095 },
    { (float)9.18, (float)14.2857 },
    { (float)13.9419, (float)4.7619 },
    { (float)18.7038, (float)0 },
    { (float)23.4657, (float)-9.5238 },
    { (float)23.4657, (float)-19.0476 },
    { (float)18.7038, (float)-28.5714 },
};

static CoordRec char125_stroke2[] = {
    { (float)23.4657, (float)38.0952 },
    { (float)13.9419, (float)28.5714 },
    { (float)13.9419, (float)19.0476 },
    { (float)18.7038, (float)9.5238 },
    { (float)23.4657, (float)4.7619 },
    { (float)28.2276, (float)-4.7619 },
    { (float)28.2276, (float)-14.2857 },
    { (float)23.4657, (float)-23.8095 },
    { (float)18.7038, (float)-28.5714 },
    { (float)9.18, (float)-33.3333 },
};

static StrokeRec char125[] = {
   { 10, char125_stroke0 },
   { 17, char125_stroke1 },
   { 10, char125_stroke2 },
};

/* char: 126 '~' */

static CoordRec char126_stroke0[] = {
    { (float)2.92, (float)28.5714 },
    { (float)2.92, (float)38.0952 },
    { (float)7.6819, (float)52.381 },
    { (float)17.2057, (float)57.1429 },
    { (float)26.7295, (float)57.1429 },
    { (float)36.2533, (float)52.381 },
    { (float)55.301, (float)38.0952 },
    { (float)64.8248, (float)33.3333 },
    { (float)74.3486, (float)33.3333 },
    { (float)83.8724, (float)38.0952 },
    { (float)88.6343, (float)47.619 },
};

static CoordRec char126_stroke1[] = {
    { (float)2.92, (float)38.0952 },
    { (float)7.6819, (float)47.619 },
    { (float)17.2057, (float)52.381 },
    { (float)26.7295, (float)52.381 },
    { (float)36.2533, (float)47.619 },
    { (float)55.301, (float)33.3333 },
    { (float)64.8248, (float)28.5714 },
    { (float)74.3486, (float)28.5714 },
    { (float)83.8724, (float)33.3333 },
    { (float)88.6343, (float)47.619 },
    { (float)88.6343, (float)57.1429 },
};

static StrokeRec char126[] = {
   { 11, char126_stroke0 },
   { 11, char126_stroke1 },
};

/* char: 127 */

static CoordRec char127_stroke0[] = {
    { (float)52.381, (float)100 },
    { (float)14.2857, (float)-33.3333 },
};

static CoordRec char127_stroke1[] = {
    { (float)28.5714, (float)66.6667 },
    { (float)14.2857, (float)61.9048 },
    { (float)4.7619, (float)52.381 },
    { (float)0, (float)38.0952 },
    { (float)0, (float)23.8095 },
    { (float)4.7619, (float)14.2857 },
    { (float)14.2857, (float)4.7619 },
    { (float)28.5714, (float)0 },
    { (float)38.0952, (float)0 },
    { (float)52.381, (float)4.7619 },
    { (float)61.9048, (float)14.2857 },
    { (float)66.6667, (float)28.5714 },
    { (float)66.6667, (float)42.8571 },
    { (float)61.9048, (float)52.381 },
    { (float)52.381, (float)61.9048 },
    { (float)38.0952, (float)66.6667 },
    { (float)28.5714, (float)66.6667 },
};

static StrokeRec char127[] = {
   { 2, char127_stroke0 },
   { 17, char127_stroke1 },
};

static StrokeCharRec chars[] = {
    { 0, /* char0 */ 0, (float)0, (float)0 },
    { 0, /* char1 */ 0, (float)0, (float)0 },
    { 0, /* char2 */ 0, (float)0, (float)0 },
    { 0, /* char3 */ 0, (float)0, (float)0 },
    { 0, /* char4 */ 0, (float)0, (float)0 },
    { 0, /* char5 */ 0, (float)0, (float)0 },
    { 0, /* char6 */ 0, (float)0, (float)0 },
    { 0, /* char7 */ 0, (float)0, (float)0 },
    { 0, /* char8 */ 0, (float)0, (float)0 },
    { 0, /* char9 */ 0, (float)0, (float)0 },
    { 0, /* char10 */ 0, (float)0, (float)0 },
    { 0, /* char11 */ 0, (float)0, (float)0 },
    { 0, /* char12 */ 0, (float)0, (float)0 },
    { 0, /* char13 */ 0, (float)0, (float)0 },
    { 0, /* char14 */ 0, (float)0, (float)0 },
    { 0, /* char15 */ 0, (float)0, (float)0 },
    { 0, /* char16 */ 0, (float)0, (float)0 },
    { 0, /* char17 */ 0, (float)0, (float)0 },
    { 0, /* char18 */ 0, (float)0, (float)0 },
    { 0, /* char19 */ 0, (float)0, (float)0 },
    { 0, /* char20 */ 0, (float)0, (float)0 },
    { 0, /* char21 */ 0, (float)0, (float)0 },
    { 0, /* char22 */ 0, (float)0, (float)0 },
    { 0, /* char23 */ 0, (float)0, (float)0 },
    { 0, /* char24 */ 0, (float)0, (float)0 },
    { 0, /* char25 */ 0, (float)0, (float)0 },
    { 0, /* char26 */ 0, (float)0, (float)0 },
    { 0, /* char27 */ 0, (float)0, (float)0 },
    { 0, /* char28 */ 0, (float)0, (float)0 },
    { 0, /* char29 */ 0, (float)0, (float)0 },
    { 0, /* char30 */ 0, (float)0, (float)0 },
    { 0, /* char31 */ 0, (float)0, (float)0 },
    { 0, /* char32 */ 0, (float)52.381, (float)104.762 },
    { 2, char33, (float)13.3819, (float)26.6238 },
    { 2, char34, (float)23.0676, (float)51.4352 },
    { 4, char35, (float)36.5333, (float)79.4886 },
    { 3, char36, (float)38.1533, (float)76.2067 },
    { 3, char37, (float)49.2171, (float)96.5743 },
    { 1, char38, (float)53.599, (float)101.758 },
    { 1, char39, (float)4.44, (float)13.62 },
    { 1, char40, (float)21.8657, (float)47.1733 },
    { 1, char41, (float)24.3276, (float)47.5333 },
    { 3, char42, (float)30.7695, (float)59.439 },
    { 2, char43, (float)48.8371, (float)97.2543 },
    { 1, char44, (float)13.5219, (float)26.0638 },
    { 1, char45, (float)50.2371, (float)100.754 },
    { 1, char46, (float)13.1019, (float)26.4838 },
    { 1, char47, (float)40.5733, (float)82.1067 },
    { 1, char48, (float)38.3133, (float)77.0667 },
    { 1, char49, (float)30.8676, (float)66.5295 },
    { 1, char50, (float)38.7533, (float)77.6467 },
    { 1, char51, (float)38.3333, (float)77.0467 },
    { 2, char52, (float)37.2133, (float)80.1686 },
    { 1, char53, (float)38.1933, (float)77.6867 },
    { 1, char54, (float)34.1514, (float)73.8048 },
    { 2, char55, (float)38.8933, (float)77.2267 },
    { 1, char56, (float)38.9333, (float)77.6667 },
    { 1, char57, (float)39.9333, (float)74.0648 },
    { 2, char58, (float)14.0819, (float)26.2238 },
    { 2, char59, (float)12.9619, (float)26.3038 },
    { 1, char60, (float)41.1552, (float)81.6105 },
    { 2, char61, (float)48.5571, (float)97.2543 },
    { 1, char62, (float)40.8752, (float)81.6105 },
    { 2, char63, (float)36.9914, (float)73.9029 },
    { 2, char64, (float)34.9314, (float)74.3648 },
    { 3, char65, (float)40.5952, (float)80.4905 },
    { 3, char66, (float)44.7533, (float)83.6267 },
    { 1, char67, (float)39.9933, (float)84.4886 },
    { 2, char68, (float)45.2933, (float)85.2867 },
    { 4, char69, (float)39.9914, (float)78.1848 },
    { 3, char70, (float)39.9914, (float)78.7448 },
    { 2, char71, (float)40.3933, (float)89.7686 },
    { 3, char72, (float)44.7533, (float)89.0867 },
    { 1, char73, (float)10.86, (float)21.3 },
    { 1, char74, (float)31.0714, (float)59.999 },
    { 3, char75, (float)44.6133, (float)79.3267 },
    { 2, char76, (float)40.2514, (float)71.3229 },
    { 4, char77, (float)48.9552, (float)97.2105 },
    { 3, char78, (float)44.4733, (float)88.8067 },
    { 1, char79, (float)44.3352, (float)88.8305 },
    { 2, char80, (float)45.4333, (float)85.6667 },
    { 2, char81, (float)43.3952, (float)88.0905 },
    { 3, char82, (float)45.0133, (float)82.3667 },
    { 1, char83, (float)41.3333, (float)80.8267 },
    { 2, char84, (float)35.6933, (float)71.9467 },
    { 1, char85, (float)44.8733, (float)89.4867 },
    { 2, char86, (float)40.4552, (float)81.6105 },
    { 4, char87, (float)49.839, (float)100.518 },
    { 2, char88, (float)35.8333, (float)72.3667 },
    { 2, char89, (float)39.6152, (float)79.6505 },
    { 3, char90, (float)35.8333, (float)73.7467 },
    { 4, char91, (float)22.0657, (float)46.1133 },
    { 1, char92, (float)39.1733, (float)78.2067 },
    { 4, char93, (float)23.4876, (float)46.3933 },
    { 2, char94, (float)44.0752, (float)90.2305 },
    { 1, char95, (float)51.281, (float)104.062 },
    { 2, char96, (float)42.5457, (float)83.5714 },
    { 2, char97, (float)35.2514, (float)66.6029 },
    { 2, char98, (float)37.3314, (float)70.4629 },
    { 1, char99, (float)34.0914, (float)68.9229 },
    { 2, char100, (float)33.2114, (float)70.2629 },
    { 1, char101, (float)34.2914, (float)68.5229 },
    { 2, char102, (float)14.9657, (float)38.6552 },
    { 2, char103, (float)33.9314, (float)70.9829 },
    { 2, char104, (float)33.4095, (float)71.021 },
    { 2, char105, (float)14.7819, (float)28.8638 },
    { 2, char106, (float)17.3876, (float)36.2314 },
    { 3, char107, (float)33.4095, (float)62.521 },
    { 1, char108, (float)10.02, (float)19.34 },
    { 3, char109, (float)61.981, (float)123.962 },
    { 2, char110, (float)32.9895, (float)70.881 },
    { 1, char111, (float)33.5514, (float)71.7448 },
    { 2, char112, (float)38.0314, (float)70.8029 },
    { 2, char113, (float)33.4114, (float)70.7429 },
    { 2, char114, (float)23.7457, (float)49.4952 },
    { 1, char115, (float)28.5095, (float)62.321 },
    { 2, char116, (float)14.8257, (float)39.3152 },
    { 2, char117, (float)33.2695, (float)71.161 },
    { 2, char118, (float)30.3714, (float)60.6029 },
    { 4, char119, (float)40.5952, (float)80.4905 },
    { 2, char120, (float)25.4695, (float)56.401 },
    { 2, char121, (float)35.1333, (float)66.0648 },
    { 3, char122, (float)28.2495, (float)61.821 },
    { 3, char123, (float)21.6657, (float)41.6295 },
    { 1, char124, (float)11.54, (float)23.78 },
    { 3, char125, (float)18.7038, (float)41.4695 },
    { 2, char126, (float)45.7771, (float)91.2743 },
    { 2, char127, (float)33.3333, (float)66.6667 },
};

StrokeFontRec glutStrokeRoman = { "Roman", 128, chars, (float)119.048, (float)-33.3333 };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltshape.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
(c) Copyright 1993, Silicon Graphics, Inc.

ALL RIGHTS RESERVED

Permission to use, copy, modify, and distribute this software
for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that
both the copyright notice and this permission notice appear in
supporting documentation, and that the name of Silicon
Graphics, Inc. not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU
"AS-IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR
OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL SILICON GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE
ELSE FOR ANY DIRECT, SPECIAL, INCIDENTAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER,
INCLUDING WITHOUT LIMITATION, LOSS OF PROFIT, LOSS OF USE,
SAVINGS OR REVENUE, OR THE CLAIMS OF THIRD PARTIES, WHETHER OR
NOT SILICON GRAPHICS, INC.  HAS BEEN ADVISED OF THE POSSIBILITY
OF SUCH LOSS, HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
ARISING OUT OF OR IN CONNECTION WITH THE POSSESSION, USE OR
PERFORMANCE OF THIS SOFTWARE.

US Government Users Restricted Rights

Use, duplication, or disclosure by the Government is subject to
restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
(c)(1)(ii) of the Rights in Technical Data and Computer
Software clause at DFARS 252.227-7013 and/or in similar or
successor clauses in the FAR or the DOD or NASA FAR
Supplement.  Unpublished-- rights reserved under the copyright
laws of the United States.  Contractor/manufacturer is Silicon
Graphics, Inc., 2011 N.  Shoreline Blvd., Mountain View, CA
94039-7311.

OpenGL(TM) is a trademark of Silicon Graphics, Inc.
*/

#include <math.h>
#include "gltint.h"
#include <GL/glu.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

static GLUquadricObj *quadObj;

#define QUAD_OBJ_INIT() { if(!quadObj) initQuadObj(); }

static void
initQuadObj(void)
{
  quadObj = gluNewQuadric();
  if (!quadObj)
    __glutFatalError("out of memory.");
}

/* CENTRY */
void
glutWireSphere(GLdouble radius, GLint slices, GLint stacks)
{
  QUAD_OBJ_INIT();
  gluQuadricDrawStyle(quadObj, GLU_LINE);
  gluQuadricNormals(quadObj, GLU_SMOOTH);
  /* If we ever changed/used the texture or orientation state
     of quadObj, we'd need to change it to the defaults here
     with gluQuadricTexture and/or gluQuadricOrientation. */
  gluSphere(quadObj, radius, slices, stacks);
}

void
glutSolidSphere(GLdouble radius, GLint slices, GLint stacks)
{
  QUAD_OBJ_INIT();
  gluQuadricDrawStyle(quadObj, GLU_FILL);
  gluQuadricNormals(quadObj, GLU_SMOOTH);
  /* If we ever changed/used the texture or orientation state
     of quadObj, we'd need to change it to the defaults here
     with gluQuadricTexture and/or gluQuadricOrientation. */
  gluSphere(quadObj, radius, slices, stacks);
}

void
glutWireCone(GLdouble base, GLdouble height,
  GLint slices, GLint stacks)
{
  QUAD_OBJ_INIT();
  gluQuadricDrawStyle(quadObj, GLU_LINE);
  gluQuadricNormals(quadObj, GLU_SMOOTH);
  /* If we ever changed/used the texture or orientation state
     of quadObj, we'd need to change it to the defaults here
     with gluQuadricTexture and/or gluQuadricOrientation. */
  gluCylinder(quadObj, base, 0.0, height, slices, stacks);
}

void
glutSolidCone(GLdouble base, GLdouble height,
  GLint slices, GLint stacks)
{
  QUAD_OBJ_INIT();
  gluQuadricDrawStyle(quadObj, GLU_FILL);
  gluQuadricNormals(quadObj, GLU_SMOOTH);
  /* If we ever changed/used the texture or orientation state
     of quadObj, we'd need to change it to the defaults here
     with gluQuadricTexture and/or gluQuadricOrientation. */
  gluCylinder(quadObj, base, 0.0, height, slices, stacks);
}
/* ENDCENTRY */

static void
drawBox(GLdouble x0, GLdouble x1, GLdouble y0, GLdouble y1,
  GLdouble z0, GLdouble z1, GLenum type)
{
  static GLdouble n[6][3] =
  {
    {-1.0, 0.0, 0.0},
    {0.0, 1.0, 0.0},
    {1.0, 0.0, 0.0},
    {0.0, -1.0, 0.0},
    {0.0, 0.0, 1.0},
    {0.0, 0.0, -1.0}
  };
  static GLint faces[6][4] =
  {
    {0, 1, 2, 3},
    {3, 2, 6, 7},
    {7, 6, 5, 4},
    {4, 5, 1, 0},
    {5, 6, 2, 1},
    {7, 4, 0, 3}
  };
  GLdouble v[8][3], tmp;
  GLint i;

  if (x0 > x1) {
    tmp = x0;
    x0 = x1;
    x1 = tmp;
  }
  if (y0 > y1) {
    tmp = y0;
    y0 = y1;
    y1 = tmp;
  }
  if (z0 > z1) {
    tmp = z0;
    z0 = z1;
    z1 = tmp;
  }
  v[0][0] = v[1][0] = v[2][0] = v[3][0] = x0;
  v[4][0] = v[5][0] = v[6][0] = v[7][0] = x1;
  v[0][1] = v[1][1] = v[4][1] = v[5][1] = y0;
  v[2][1] = v[3][1] = v[6][1] = v[7][1] = y1;
  v[0][2] = v[3][2] = v[4][2] = v[7][2] = z0;
  v[1][2] = v[2][2] = v[5][2] = v[6][2] = z1;

  for (i = 0; i < 6; i++) {
    glBegin(type);
    glNormal3dv(&n[i][0]);
    glVertex3dv(&v[faces[i][0]][0]);
    glNormal3dv(&n[i][0]);
    glVertex3dv(&v[faces[i][1]][0]);
    glNormal3dv(&n[i][0]);
    glVertex3dv(&v[faces[i][2]][0]);
    glNormal3dv(&n[i][0]);
    glVertex3dv(&v[faces[i][3]][0]);
    glEnd();
  }
}

/* CENTRY */
void
glutWireCube(GLdouble size)
{
  drawBox(-size / 2., size / 2.,
    -size / 2., size / 2.,
    -size / 2., size / 2.,
    GL_LINE_LOOP);
}

void
glutSolidCube(GLdouble size)
{
  drawBox(-size / 2., size / 2.,
    -size / 2., size / 2.,
    -size / 2., size / 2.,
    GL_QUADS);
}
/* ENDCENTRY */

static void
doughnut(GLdouble r, GLdouble R, GLint nsides,
  GLint rings, GLenum type)
{
  int i, j;
  GLdouble theta, phi, theta1, phi1;
  GLdouble p0[03], p1[3], p2[3], p3[3];
  GLdouble n0[3], n1[3], n2[3], n3[3];

  for (i = 0; i < rings; i++) {
    theta = (GLdouble) i *2.0 * M_PI / rings;
    theta1 = (GLdouble) (i + 1) * 2.0 * M_PI / rings;
    for (j = 0; j < nsides; j++) {
      phi = (GLdouble) j *2.0 * M_PI / nsides;
      phi1 = (GLdouble) (j + 1) * 2.0 * M_PI / nsides;

      p0[0] = cos(theta) * (R + r * cos(phi));
      p0[1] = -sin(theta) * (R + r * cos(phi));
      p0[2] = r * sin(phi);

      p1[0] = cos(theta1) * (R + r * cos(phi));
      p1[1] = -sin(theta1) * (R + r * cos(phi));
      p1[2] = r * sin(phi);

      p2[0] = cos(theta1) * (R + r * cos(phi1));
      p2[1] = -sin(theta1) * (R + r * cos(phi1));
      p2[2] = r * sin(phi1);

      p3[0] = cos(theta) * (R + r * cos(phi1));
      p3[1] = -sin(theta) * (R + r * cos(phi1));
      p3[2] = r * sin(phi1);

      n0[0] = cos(theta) * (cos(phi));
      n0[1] = -sin(theta) * (cos(phi));
      n0[2] = sin(phi);

      n1[0] = cos(theta1) * (cos(phi));
      n1[1] = -sin(theta1) * (cos(phi));
      n1[2] = sin(phi);

      n2[0] = cos(theta1) * (cos(phi1));
      n2[1] = -sin(theta1) * (cos(phi1));
      n2[2] = sin(phi1);

      n3[0] = cos(theta) * (cos(phi1));
      n3[1] = -sin(theta) * (cos(phi1));
      n3[2] = sin(phi1);

      glBegin(type);
      glNormal3dv(n3);
      glVertex3dv(p3);
      glNormal3dv(n2);
      glVertex3dv(p2);
      glNormal3dv(n1);
      glVertex3dv(p1);
      glNormal3dv(n0);
      glVertex3dv(p0);
      glEnd();
    }
  }
}

/* CENTRY */
void
glutWireTorus(GLdouble innerRadius, GLdouble outerRadius,
  GLint nsides, GLint rings)
{
  doughnut(innerRadius, outerRadius,
    nsides, rings, GL_LINE_LOOP);
}

void
glutSolidTorus(GLdouble innerRadius, GLdouble outerRadius,
  GLint nsides, GLint rings)
{
  doughnut(innerRadius, outerRadius, nsides, rings, GL_QUADS);
}
/* ENDCENTRY */

static GLdouble dodec[20][3];

static void
initDodecahedron(void)
{
  GLdouble alpha, beta;

  alpha = sqrt(2.0 / (3.0 + sqrt(5.0)));
  beta = 1.0 + sqrt(6.0 / (3.0 + sqrt(5.0)) -
    2.0 + 2.0 * sqrt(2.0 / (3.0 + sqrt(5.0))));
  /* *INDENT-OFF* */
  dodec[0][0] = -alpha; dodec[0][1] = 0; dodec[0][2] = beta;
  dodec[1][0] = alpha; dodec[1][1] = 0; dodec[1][2] = beta;
  dodec[2][0] = -1; dodec[2][1] = -1; dodec[2][2] = -1;
  dodec[3][0] = -1; dodec[3][1] = -1; dodec[3][2] = 1;
  dodec[4][0] = -1; dodec[4][1] = 1; dodec[4][2] = -1;
  dodec[5][0] = -1; dodec[5][1] = 1; dodec[5][2] = 1;
  dodec[6][0] = 1; dodec[6][1] = -1; dodec[6][2] = -1;
  dodec[7][0] = 1; dodec[7][1] = -1; dodec[7][2] = 1;
  dodec[8][0] = 1; dodec[8][1] = 1; dodec[8][2] = -1;
  dodec[9][0] = 1; dodec[9][1] = 1; dodec[9][2] = 1;
  dodec[10][0] = beta; dodec[10][1] = alpha; dodec[10][2] = 0;
  dodec[11][0] = beta; dodec[11][1] = -alpha; dodec[11][2] = 0;
  dodec[12][0] = -beta; dodec[12][1] = alpha; dodec[12][2] = 0;
  dodec[13][0] = -beta; dodec[13][1] = -alpha; dodec[13][2] = 0;
  dodec[14][0] = -alpha; dodec[14][1] = 0; dodec[14][2] = -beta;
  dodec[15][0] = alpha; dodec[15][1] = 0; dodec[15][2] = -beta;
  dodec[16][0] = 0; dodec[16][1] = beta; dodec[16][2] = alpha;
  dodec[17][0] = 0; dodec[17][1] = beta; dodec[17][2] = -alpha;
  dodec[18][0] = 0; dodec[18][1] = -beta; dodec[18][2] = alpha;
  dodec[19][0] = 0; dodec[19][1] = -beta; dodec[19][2] = -alpha;
  /* *INDENT-ON* */

}

#define DIFF3(_a,_b,_c) { \
    (_c)[0] = (_a)[0] - (_b)[0]; \
    (_c)[1] = (_a)[1] - (_b)[1]; \
    (_c)[2] = (_a)[2] - (_b)[2]; \
}

static void
crossprod(GLdouble v1[3], GLdouble v2[3], GLdouble prod[3])
{
  GLdouble p[3];                /* in case prod == v1 or v2 */

  p[0] = v1[1] * v2[2] - v2[1] * v1[2];
  p[1] = v1[2] * v2[0] - v2[2] * v1[0];
  p[2] = v1[0] * v2[1] - v2[0] * v1[1];
  prod[0] = p[0];
  prod[1] = p[1];
  prod[2] = p[2];
}

static void
normalize(GLdouble v[3])
{
  GLdouble d;

  d = sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
  if (d == 0.0) {
    __glutWarning("normalize: zero length vector");
    v[0] = d = 1.0;
  }
  d = 1 / d;
  v[0] *= d;
  v[1] *= d;
  v[2] *= d;
}

static void
pentagon(int a, int b, int c, int d, int e, GLenum shadeType)
{
  GLdouble n0[3], d1[3], d2[3];

  DIFF3(dodec[a], dodec[b], d1);
  DIFF3(dodec[b], dodec[c], d2);
  crossprod(d1, d2, n0);
  normalize(n0);

  glBegin(shadeType);
  glNormal3dv(n0);
  glVertex3dv(&dodec[a][0]);
  glVertex3dv(&dodec[b][0]);
  glVertex3dv(&dodec[c][0]);
  glVertex3dv(&dodec[d][0]);
  glVertex3dv(&dodec[e][0]);
  glEnd();
}

static void
dodecahedron(GLenum type)
{
  static int inited = 0;

  if (inited == 0) {
    inited = 1;
    initDodecahedron();
  }
  pentagon(0, 1, 9, 16, 5, type);
  pentagon(1, 0, 3, 18, 7, type);
  pentagon(1, 7, 11, 10, 9, type);
  pentagon(11, 7, 18, 19, 6, type);
  pentagon(8, 17, 16, 9, 10, type);
  pentagon(2, 14, 15, 6, 19, type);
  pentagon(2, 13, 12, 4, 14, type);
  pentagon(2, 19, 18, 3, 13, type);
  pentagon(3, 0, 5, 12, 13, type);
  pentagon(6, 15, 8, 10, 11, type);
  pentagon(4, 17, 8, 15, 14, type);
  pentagon(4, 12, 5, 16, 17, type);
}

/* CENTRY */
void
glutWireDodecahedron(void)
{
  dodecahedron(GL_LINE_LOOP);
}

void
glutSolidDodecahedron(void)
{
  dodecahedron(GL_TRIANGLE_FAN);
}
/* ENDCENTRY */

static void
recorditem(GLdouble * n1, GLdouble * n2, GLdouble * n3,
  GLenum shadeType)
{
  GLdouble q0[3], q1[3];

  DIFF3(n1, n2, q0);
  DIFF3(n2, n3, q1);
  crossprod(q0, q1, q1);
  normalize(q1);

  glBegin(shadeType);
  glNormal3dv(q1);
  glVertex3dv(n1);
  glVertex3dv(n2);
  glVertex3dv(n3);
  glEnd();
}

static void
subdivide(GLdouble * v0, GLdouble * v1, GLdouble * v2,
  GLenum shadeType)
{
  int depth;
  GLdouble w0[3], w1[3], w2[3];
  GLdouble l;
  int i, j, k, n;

  depth = 1;
  for (i = 0; i < depth; i++) {
    for (j = 0; i + j < depth; j++) {
      k = depth - i - j;
      for (n = 0; n < 3; n++) {
        w0[n] = (i * v0[n] + j * v1[n] + k * v2[n]) / depth;
        w1[n] = ((i + 1) * v0[n] + j * v1[n] + (k - 1) * v2[n])
          / depth;
        w2[n] = (i * v0[n] + (j + 1) * v1[n] + (k - 1) * v2[n])
          / depth;
      }
      l = sqrt(w0[0] * w0[0] + w0[1] * w0[1] + w0[2] * w0[2]);
      w0[0] /= l;
      w0[1] /= l;
      w0[2] /= l;
      l = sqrt(w1[0] * w1[0] + w1[1] * w1[1] + w1[2] * w1[2]);
      w1[0] /= l;
      w1[1] /= l;
      w1[2] /= l;
      l = sqrt(w2[0] * w2[0] + w2[1] * w2[1] + w2[2] * w2[2]);
      w2[0] /= l;
      w2[1] /= l;
      w2[2] /= l;
      recorditem(w1, w0, w2, shadeType);
    }
  }
}

static void
drawtriangle(int i, GLdouble data[][3], int ndx[][3],
  GLenum shadeType)
{
  GLdouble *x0, *x1, *x2;

  x0 = data[ndx[i][0]];
  x1 = data[ndx[i][1]];
  x2 = data[ndx[i][2]];
  subdivide(x0, x1, x2, shadeType);
}

/* octahedron data: The octahedron produced is centered
   at the origin and has radius 1.0 */
static GLdouble odata[6][3] =
{
  {1.0, 0.0, 0.0},
  {-1.0, 0.0, 0.0},
  {0.0, 1.0, 0.0},
  {0.0, -1.0, 0.0},
  {0.0, 0.0, 1.0},
  {0.0, 0.0, -1.0}
};

static int ondex[8][3] =
{
  {0, 4, 2},
  {1, 2, 4},
  {0, 3, 4},
  {1, 4, 3},
  {0, 2, 5},
  {1, 5, 2},
  {0, 5, 3},
  {1, 3, 5}
};

static void
octahedron(GLenum shadeType)
{
  int i;

  for (i = 0; i < 8; i++) {
    drawtriangle(i, odata, ondex, shadeType);
  }
}

/* CENTRY */
void
glutWireOctahedron(void)
{
  octahedron(GL_LINE_LOOP);
}

void
glutSolidOctahedron(void)
{
  octahedron(GL_TRIANGLES);
}
/* ENDCENTRY */

/* icosahedron data: These numbers are rigged to
   make an icosahedron of radius 1.0 */

#define X .525731112119133606
#define Z .850650808352039932

static GLdouble idata[12][3] =
{
  {-X, 0, Z},
  {X, 0, Z},
  {-X, 0, -Z},
  {X, 0, -Z},
  {0, Z, X},
  {0, Z, -X},
  {0, -Z, X},
  {0, -Z, -X},
  {Z, X, 0},
  {-Z, X, 0},
  {Z, -X, 0},
  {-Z, -X, 0}
};

static int index[20][3] =
{
  {0, 4, 1},
  {0, 9, 4},
  {9, 5, 4},
  {4, 5, 8},
  {4, 8, 1},
  {8, 10, 1},
  {8, 3, 10},
  {5, 3, 8},
  {5, 2, 3},
  {2, 7, 3},
  {7, 10, 3},
  {7, 6, 10},
  {7, 11, 6},
  {11, 0, 6},
  {0, 1, 6},
  {6, 1, 10},
  {9, 0, 11},
  {9, 11, 2},
  {9, 2, 5},
  {7, 2, 11},
};

static void
icosahedron(GLenum shadeType)
{
  int i;

  for (i = 0; i < 20; i++) {
    drawtriangle(i, idata, index, shadeType);
  }
}

/* CENTRY */
void
glutWireIcosahedron(void)
{
  icosahedron(GL_LINE_LOOP);
}

void
glutSolidIcosahedron(void)
{
  icosahedron(GL_TRIANGLES);
}
/* ENDCENTRY */

/* tetrahedron data: */

#define T       1.73205080756887729

static GLdouble tdata[4][3] =
{
  {T, T, T},
  {T, -T, -T},
  {-T, T, -T},
  {-T, -T, T}
};

static int tndex[4][3] =
{
  {0, 1, 3},
  {2, 1, 0},
  {3, 2, 0},
  {1, 2, 3}
};

static void
tetrahedron(GLenum shadeType)
{
  int i;

  for (i = 0; i < 4; i++)
    drawtriangle(i, tdata, tndex, shadeType);
}

/* CENTRY */
void
glutWireTetrahedron(void)
{
  tetrahedron(GL_LINE_LOOP);
}

void
glutSolidTetrahedron(void)
{
  tetrahedron(GL_TRIANGLES);
}
/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glttablt.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

void
glutTabletMotionFunc(GLUTtabletMotionCB tabletMotionFunc)
{
  __glutCurrentWindow->tabletMotion = tabletMotionFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
  /* If deinstalling callback, invalidate tablet position. */
  if (tabletMotionFunc == NULL) {
    __glutCurrentWindow->tabletPos[0] = -1;
    __glutCurrentWindow->tabletPos[1] = -1;
  }
}

void
glutTabletButtonFunc(GLUTtabletButtonCB tabletButtonFunc)
{
  __glutCurrentWindow->tabletButton = tabletButtonFunc;
  __glutUpdateInputDeviceMaskFunc = __glutOsUpdateInputDeviceMask;
  __glutPutOnWorkList(__glutCurrentWindow,
    GLUT_DEVICE_MASK_WORK);
}

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glttpot.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
(c) Copyright 1993, Silicon Graphics, Inc.

ALL RIGHTS RESERVED

Permission to use, copy, modify, and distribute this software
for any purpose and without fee is hereby granted, provided
that the above copyright notice appear in all copies and that
both the copyright notice and this permission notice appear in
supporting documentation, and that the name of Silicon
Graphics, Inc. not be used in advertising or publicity
pertaining to distribution of the software without specific,
written prior permission.

THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU
"AS-IS" AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR
OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  IN NO
EVENT SHALL SILICON GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE
ELSE FOR ANY DIRECT, SPECIAL, INCIDENTAL, INDIRECT OR
CONSEQUENTIAL DAMAGES OF ANY KIND, OR ANY DAMAGES WHATSOEVER,
INCLUDING WITHOUT LIMITATION, LOSS OF PROFIT, LOSS OF USE,
SAVINGS OR REVENUE, OR THE CLAIMS OF THIRD PARTIES, WHETHER OR
NOT SILICON GRAPHICS, INC.  HAS BEEN ADVISED OF THE POSSIBILITY
OF SUCH LOSS, HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
ARISING OUT OF OR IN CONNECTION WITH THE POSSESSION, USE OR
PERFORMANCE OF THIS SOFTWARE.

US Government Users Restricted Rights

Use, duplication, or disclosure by the Government is subject to
restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
(c)(1)(ii) of the Rights in Technical Data and Computer
Software clause at DFARS 252.227-7013 and/or in similar or
successor clauses in the FAR or the DOD or NASA FAR
Supplement.  Unpublished-- rights reserved under the copyright
laws of the United States.  Contractor/manufacturer is Silicon
Graphics, Inc., 2011 N.  Shoreline Blvd., Mountain View, CA
94039-7311.

OpenGL(TM) is a trademark of Silicon Graphics, Inc.
*/

#include "gltint.h"

/* Rim, body, lid, and bottom data must be reflected in x
   and y; handle and spout data across the y axis only.  */

long patchdata[][16] =
{
    /* rim */
  {102, 103, 104, 105, 4, 5, 6, 7, 8, 9, 10, 11,
    12, 13, 14, 15},
    /* body */
  {12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
    24, 25, 26, 27},
  {24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36,
    37, 38, 39, 40},
    /* lid */
  {96, 96, 96, 96, 97, 98, 99, 100, 101, 101, 101,
    101, 0, 1, 2, 3,},
  {0, 1, 2, 3, 106, 107, 108, 109, 110, 111, 112,
    113, 114, 115, 116, 117},
    /* bottom */
  {118, 118, 118, 118, 124, 122, 119, 121, 123, 126,
    125, 120, 40, 39, 38, 37},
    /* handle */
  {41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
    53, 54, 55, 56},
  {53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64,
    28, 65, 66, 67},
    /* spout */
  {68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
    80, 81, 82, 83},
  {80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
    92, 93, 94, 95}
};
/* *INDENT-OFF* */

float cpdata[][3] =
{
    {(float)0.2, (float)0.0, (float)2.7}, {(float)0.2, (float)-0.112, (float)2.7}, {(float)0.112, (float)-0.2, (float)2.7}, {(float)0.0,
(float)    -0.2, (float)2.7}, {(float)1.3375, (float)0.0, (float)2.53125}, {(float)1.3375, (float)-0.749, (float)2.53125},
    {(float)0.749, (float)-1.3375, (float)2.53125}, {(float)0.0, (float)-1.3375, (float)2.53125}, {(float)1.4375,
(float)    0.0, (float)2.53125}, {(float)1.4375, (float)-0.805, (float)2.53125}, {(float)0.805, (float)-1.4375,
(float)    2.53125}, {(float)0.0, (float)-1.4375, (float)2.53125}, {(float)1.5, (float)0.0, (float)2.4}, {(float)1.5, (float)-0.84,
(float)    2.4}, {(float)0.84, (float)-1.5, (float)2.4}, {(float)0.0, (float)-1.5, (float)2.4}, {(float)1.75, (float)0.0, (float)1.875},
    {(float)1.75, (float)-0.98, (float)1.875}, {(float)0.98, (float)-1.75, (float)1.875}, {(float)0.0, (float)-1.75,
(float)    1.875}, {(float)2, (float)0.0, (float)1.35}, {(float)2, (float)-1.12, (float)1.35}, {(float)1.12, (float)-2, (float)1.35},
    {(float)0.0, (float)-2, (float)1.35}, {(float)2, (float)0.0, (float)0.9}, {(float)2, (float)-1.12, (float)0.9}, {(float)1.12, (float)-2,
(float)    0.9}, {(float)0.0, (float)-2, (float)0.9}, {(float)-2, (float)0.0, (float)0.9}, {(float)2, (float)0.0, (float)0.45}, {(float)2, (float)-1.12,
(float)    0.45}, {(float)1.12, (float)-2, (float)0.45}, {(float)0.0, (float)-2, (float)0.45}, {(float)1.5, (float)0.0, (float)0.225},
    {(float)1.5, (float)-0.84, (float)0.225}, {(float)0.84, (float)-1.5, (float)0.225}, {(float)0.0, (float)-1.5, (float)0.225},
    {(float)1.5, (float)0.0, (float)0.15}, {(float)1.5, (float)-0.84, (float)0.15}, {(float)0.84, (float)-1.5, (float)0.15}, {(float)0.0,
(float)    -1.5, (float)0.15}, {(float)-1.6, (float)0.0, (float)2.025}, {(float)-1.6, (float)-0.3, (float)2.025}, {(float)-1.5,
(float)    -0.3, (float)2.25}, {(float)-1.5, (float)0.0, (float)2.25}, {(float)-2.3, (float)0.0, (float)2.025}, {(float)-2.3, (float)-0.3,
(float)    2.025}, {(float)-2.5, (float)-0.3, (float)2.25}, {(float)-2.5, (float)0.0, (float)2.25}, {(float)-2.7, (float)0.0,
(float)    2.025}, {(float)-2.7, (float)-0.3, (float)2.025}, {(float)-3, (float)-0.3, (float)2.25}, {(float)-3, (float)0.0,
(float)    2.25}, {(float)-2.7, (float)0.0, (float)1.8}, {(float)-2.7, (float)-0.3, (float)1.8}, {(float)-3, (float)-0.3, (float)1.8},
    {(float)-3, (float)0.0, (float)1.8}, {(float)-2.7, (float)0.0, (float)1.575}, {(float)-2.7, (float)-0.3, (float)1.575}, {(float)-3,
(float)    -0.3, (float)1.35}, {(float)-3, (float)0.0, (float)1.35}, {(float)-2.5, (float)0.0, (float)1.125}, {(float)-2.5, (float)-0.3,
(float)    1.125}, {(float)-2.65, (float)-0.3, (float)0.9375}, {(float)-2.65, (float)0.0, (float)0.9375}, {(float)-2,
(float)    -0.3, (float)0.9}, {(float)-1.9, (float)-0.3, (float)0.6}, {(float)-1.9, (float)0.0, (float)0.6}, {(float)1.7, (float)0.0,
(float)    1.425}, {(float)1.7, (float)-0.66, (float)1.425}, {(float)1.7, (float)-0.66, (float)0.6}, {(float)1.7, (float)0.0,
(float)    0.6}, {(float)2.6, (float)0.0, (float)1.425}, {(float)2.6, (float)-0.66, (float)1.425}, {(float)3.1, (float)-0.66,
(float)    0.825}, {(float)3.1, (float)0.0, (float)0.825}, {(float)2.3, (float)0.0, (float)2.1}, {(float)2.3, (float)-0.25, (float)2.1},
    {(float)2.4, (float)-0.25, (float)2.025}, {(float)2.4, (float)0.0, (float)2.025}, {(float)2.7, (float)0.0, (float)2.4}, {(float)2.7,
(float)    -0.25, (float)2.4}, {(float)3.3, (float)-0.25, (float)2.4}, {(float)3.3, (float)0.0, (float)2.4}, {(float)2.8, (float)0.0,
(float)    2.475}, {(float)2.8, (float)-0.25, (float)2.475}, {(float)3.525, (float)-0.25, (float)2.49375},
    {(float)3.525, (float)0.0, (float)2.49375}, {(float)2.9, (float)0.0, (float)2.475}, {(float)2.9, (float)-0.15, (float)2.475},
    {(float)3.45, (float)-0.15, (float)2.5125}, {(float)3.45, (float)0.0, (float)2.5125}, {(float)2.8, (float)0.0, (float)2.4},
    {(float)2.8, (float)-0.15, (float)2.4}, {(float)3.2, (float)-0.15, (float)2.4}, {(float)3.2, (float)0.0, (float)2.4}, {(float)0.0, (float)0.0,
(float)    3.15}, {(float)0.8, (float)0.0, (float)3.15}, {(float)0.8, (float)-0.45, (float)3.15}, {(float)0.45, (float)-0.8,
(float)    3.15}, {(float)0.0, (float)-0.8, (float)3.15}, {(float)0.0, (float)0.0, (float)2.85}, {(float)1.4, (float)0.0, (float)2.4}, {(float)1.4,
(float)    -0.784, (float)2.4}, {(float)0.784, (float)-1.4, (float)2.4}, {(float)0.0, (float)-1.4, (float)2.4}, {(float)0.4, (float)0.0,
(float)    2.55}, {(float)0.4, (float)-0.224, (float)2.55}, {(float)0.224, (float)-0.4, (float)2.55}, {(float)0.0, (float)-0.4,
(float)    2.55}, {(float)1.3, (float)0.0, (float)2.55}, {(float)1.3, (float)-0.728, (float)2.55}, {(float)0.728, (float)-1.3,
(float)    2.55}, {(float)0.0, (float)-1.3, (float)2.55}, {(float)1.3, (float)0.0, (float)2.4}, {(float)1.3, (float)-0.728, (float)2.4},
    {(float)0.728, (float)-1.3, (float)2.4}, {(float)0.0, (float)-1.3, (float)2.4}, {(float)0.0, (float)0.0, (float)0}, {(float)1.425,
(float)    -0.798, (float)0}, {(float)1.5, (float)0.0, (float)0.075}, {(float)1.425, (float)0.0, (float)0}, {(float)0.798, (float)-1.425,
(float)    0}, {(float)0.0, (float)-1.5, (float)0.075}, {(float)0.0, (float)-1.425, (float)0}, {(float)1.5, (float)-0.84, (float)0.075},
    {(float)0.84, (float)-1.5, (float)0.075}
};

static float tex[2][2][2] =
{
  { {(float)0.0, (float)0.0},
    {(float)1.0, (float)0.0}},
  { {(float)0.0, (float)1.0},
    {(float)1.0, (float)1.0}}
};

/* *INDENT-ON* */

static void
teapot(GLint grid, GLdouble scale, GLenum type)
{
  float p[4][4][3], q[4][4][3], r[4][4][3], s[4][4][3];
  long i, j, k, l;

  glPushAttrib(GL_ENABLE_BIT | GL_EVAL_BIT);
  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);
  glEnable(GL_MAP2_VERTEX_3);
  glEnable(GL_MAP2_TEXTURE_COORD_2);
  glPushMatrix();
  glRotatef((GLfloat)270.0, (GLfloat)1.0, (GLfloat)0.0, (GLfloat)0.0);
  glScalef((GLfloat)0.5 * (GLfloat)scale, (GLfloat)0.5 * (GLfloat)scale,
    (GLfloat)0.5 * (GLfloat)scale);
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.5);
  for (i = 0; i < 10; i++) {
    for (j = 0; j < 4; j++) {
      for (k = 0; k < 4; k++) {
        for (l = 0; l < 3; l++) {
          p[j][k][l] = cpdata[patchdata[i][j * 4 + k]][l];
          q[j][k][l] = cpdata[patchdata[i][j * 4 + (3 - k)]][l];
          if (l == 1)
            q[j][k][l] *= (GLfloat)-1.0;
          if (i < 6) {
            r[j][k][l] =
              cpdata[patchdata[i][j * 4 + (3 - k)]][l];
            if (l == 0)
              r[j][k][l] *= (GLfloat)-1.0;
            s[j][k][l] = cpdata[patchdata[i][j * 4 + k]][l];
            if (l == 0)
              s[j][k][l] *= (GLfloat)-1.0;
            if (l == 1)
              s[j][k][l] *= (GLfloat)-1.0;
          }
        }
      }
    }
    glMap2f(GL_MAP2_TEXTURE_COORD_2, (GLfloat)0, (GLfloat)1, 2, 2,
      (GLfloat)0, (GLfloat)1, 4, 2, &tex[0][0][0]);
    glMap2f(GL_MAP2_VERTEX_3, (GLfloat)0, (GLfloat)1, 3, 4,
      (GLfloat)0, (GLfloat)1, 12, 4, &p[0][0][0]);
    glMapGrid2f(grid, (GLfloat)0.0, (GLfloat)1.0, grid,
      (GLfloat)0.0, (GLfloat)1.0);
    glEvalMesh2(type, 0, grid, 0, grid);
    glMap2f(GL_MAP2_VERTEX_3, (GLfloat)0, (GLfloat)1, 3, 4,
      (GLfloat)0, (GLfloat)1, 12, 4, &q[0][0][0]);
    glEvalMesh2(type, 0, grid, 0, grid);
    if (i < 6) {
      glMap2f(GL_MAP2_VERTEX_3, (GLfloat)0, (GLfloat)1, 3, 4,
        (GLfloat)0, (GLfloat)1, 12, 4, &r[0][0][0]);
      glEvalMesh2(type, 0, grid, 0, grid);
      glMap2f(GL_MAP2_VERTEX_3, (GLfloat)0, (GLfloat)1, 3, 4,
        (GLfloat)0, (GLfloat)1, 12, 4, &s[0][0][0]);
      glEvalMesh2(type, 0, grid, 0, grid);
    }
  }
  glPopMatrix();
  glPopAttrib();
}

/* CENTRY */
void
glutSolidTeapot(GLdouble scale)
{
  teapot(14, scale, GL_FILL);
}

void
glutWireTeapot(GLdouble scale)
{
  teapot(10, scale, GL_LINE);
}
/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glttr10.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltbitmp.h"

/* char: 255 */

static GLubyte ch255data[] = {
0x80,0xc0,0x40,0x60,0xa0,0x90,0xb8,0x0,0xa0,
};

static BitmapCharRec ch255 = {5,9,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch255data};

/* char: 254 */

static GLubyte ch254data[] = {
0xc0,0x80,0xe0,0x90,0x90,0x90,0xe0,0x80,0x80,
};

static BitmapCharRec ch254 = {4,9,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch254data};

/* char: 253 */

static GLubyte ch253data[] = {
0x80,0xc0,0x40,0x60,0xa0,0x90,0xb8,0x0,0x20,0x10,
};

static BitmapCharRec ch253 = {5,10,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch253data};

/* char: 252 */

static GLubyte ch252data[] = {
0x68,0x90,0x90,0x90,0x90,0x0,0x50,
};

static BitmapCharRec ch252 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch252data};

/* char: 251 */

static GLubyte ch251data[] = {
0x68,0x90,0x90,0x90,0x90,0x0,0x50,0x20,
};

static BitmapCharRec ch251 = {5,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch251data};

/* char: 250 */

static GLubyte ch250data[] = {
0x68,0x90,0x90,0x90,0x90,0x0,0x40,0x20,
};

static BitmapCharRec ch250 = {5,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch250data};

/* char: 249 */

static GLubyte ch249data[] = {
0x68,0x90,0x90,0x90,0x90,0x0,0x20,0x40,
};

static BitmapCharRec ch249 = {5,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch249data};

/* char: 248 */

static GLubyte ch248data[] = {
0x80,0x70,0x48,0x48,0x48,0x38,0x4,
};

static BitmapCharRec ch248 = {6,7,(GLfloat)1,(GLfloat)1,(GLfloat)5,ch248data};

/* char: 247 */

static GLubyte ch247data[] = {
0x20,0x0,0xf8,0x0,0x20,
};

static BitmapCharRec ch247 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch247data};

/* char: 246 */

static GLubyte ch246data[] = {
0x60,0x90,0x90,0x90,0x60,0x0,0xa0,
};

static BitmapCharRec ch246 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch246data};

/* char: 245 */

static GLubyte ch245data[] = {
0x60,0x90,0x90,0x90,0x60,0x0,0xa0,0x50,
};

static BitmapCharRec ch245 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch245data};

/* char: 244 */

static GLubyte ch244data[] = {
0x60,0x90,0x90,0x90,0x60,0x0,0xa0,0x40,
};

static BitmapCharRec ch244 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch244data};

/* char: 243 */

static GLubyte ch243data[] = {
0x60,0x90,0x90,0x90,0x60,0x0,0x40,0x20,
};

static BitmapCharRec ch243 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch243data};

/* char: 242 */

static GLubyte ch242data[] = {
0x60,0x90,0x90,0x90,0x60,0x0,0x20,0x40,
};

static BitmapCharRec ch242 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch242data};

/* char: 241 */

static GLubyte ch241data[] = {
0xd8,0x90,0x90,0x90,0xe0,0x0,0xa0,0x50,
};

static BitmapCharRec ch241 = {5,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch241data};

/* char: 240 */

static GLubyte ch240data[] = {
0x60,0x90,0x90,0x90,0x70,0xa0,0x70,0x40,
};

static BitmapCharRec ch240 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch240data};

/* char: 239 */

static GLubyte ch239data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x0,0xa0,
};

static BitmapCharRec ch239 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch239data};

/* char: 238 */

static GLubyte ch238data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x0,0xa0,0x40,
};

static BitmapCharRec ch238 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch238data};

/* char: 237 */

static GLubyte ch237data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x0,0x40,0x20,
};

static BitmapCharRec ch237 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch237data};

/* char: 236 */

static GLubyte ch236data[] = {
0xe0,0x40,0x40,0x40,0xc0,0x0,0x40,0x80,
};

static BitmapCharRec ch236 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch236data};

/* char: 235 */

static GLubyte ch235data[] = {
0x60,0x80,0xc0,0xa0,0x60,0x0,0xa0,
};

static BitmapCharRec ch235 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch235data};

/* char: 234 */

static GLubyte ch234data[] = {
0x60,0x80,0xc0,0xa0,0x60,0x0,0xa0,0x40,
};

static BitmapCharRec ch234 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch234data};

/* char: 233 */

static GLubyte ch233data[] = {
0x60,0x80,0xc0,0xa0,0x60,0x0,0x40,0x20,
};

static BitmapCharRec ch233 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch233data};

/* char: 232 */

static GLubyte ch232data[] = {
0x60,0x80,0xc0,0xa0,0x60,0x0,0x40,0x80,
};

static BitmapCharRec ch232 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch232data};

/* char: 231 */

static GLubyte ch231data[] = {
0xc0,0x20,0x40,0x60,0x80,0x80,0x80,0x60,
};

static BitmapCharRec ch231 = {3,8,(GLfloat)0,(GLfloat)3,(GLfloat)4,ch231data};

/* char: 230 */

static GLubyte ch230data[] = {
0xd8,0xa0,0x70,0x28,0xd8,
};

static BitmapCharRec ch230 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch230data};

/* char: 229 */

static GLubyte ch229data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x40,0xa0,0x40,
};

static BitmapCharRec ch229 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch229data};

/* char: 228 */

static GLubyte ch228data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x0,0xa0,
};

static BitmapCharRec ch228 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch228data};

/* char: 227 */

static GLubyte ch227data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x0,0xa0,0x50,
};

static BitmapCharRec ch227 = {4,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch227data};

/* char: 226 */

static GLubyte ch226data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x0,0xa0,0x40,
};

static BitmapCharRec ch226 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch226data};

/* char: 225 */

static GLubyte ch225data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x0,0x40,0x20,
};

static BitmapCharRec ch225 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch225data};

/* char: 224 */

static GLubyte ch224data[] = {
0xe0,0xa0,0x60,0x20,0xc0,0x0,0x40,0x80,
};

static BitmapCharRec ch224 = {3,8,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch224data};

/* char: 223 */

static GLubyte ch223data[] = {
0xe0,0x50,0x50,0x60,0x50,0x50,0x20,
};

static BitmapCharRec ch223 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch223data};

/* char: 222 */

static GLubyte ch222data[] = {
0xe0,0x40,0x70,0x48,0x70,0x40,0xe0,
};

static BitmapCharRec ch222 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch222data};

/* char: 221 */

static GLubyte ch221data[] = {
0x38,0x10,0x10,0x28,0x28,0x44,0xee,0x0,0x10,0x8,
};

static BitmapCharRec ch221 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch221data};

/* char: 220 */

static GLubyte ch220data[] = {
0x38,0x6c,0x44,0x44,0x44,0x44,0xee,0x0,0x28,
};

static BitmapCharRec ch220 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch220data};

/* char: 219 */

static GLubyte ch219data[] = {
0x38,0x6c,0x44,0x44,0x44,0x44,0xee,0x0,0x28,0x10,
};

static BitmapCharRec ch219 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch219data};

/* char: 218 */

static GLubyte ch218data[] = {
0x38,0x6c,0x44,0x44,0x44,0x44,0xee,0x0,0x10,0x8,
};

static BitmapCharRec ch218 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch218data};

/* char: 217 */

static GLubyte ch217data[] = {
0x38,0x6c,0x44,0x44,0x44,0x44,0xee,0x0,0x10,0x20,
};

static BitmapCharRec ch217 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch217data};

/* char: 216 */

static GLubyte ch216data[] = {
0x80,0x7c,0x66,0x52,0x52,0x4a,0x66,0x3e,0x1,
};

static BitmapCharRec ch216 = {8,9,(GLfloat)0,(GLfloat)1,(GLfloat)8,ch216data};

/* char: 215 */

static GLubyte ch215data[] = {
0x88,0x50,0x20,0x50,0x88,
};

static BitmapCharRec ch215 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch215data};

/* char: 214 */

static GLubyte ch214data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,0x0,0x50,
};

static BitmapCharRec ch214 = {6,9,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch214data};

/* char: 213 */

static GLubyte ch213data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,0x0,0x50,0x28,
};

static BitmapCharRec ch213 = {6,10,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch213data};

/* char: 212 */

static GLubyte ch212data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,0x0,0x50,0x20,
};

static BitmapCharRec ch212 = {6,10,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch212data};

/* char: 211 */

static GLubyte ch211data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,0x0,0x10,0x8,
};

static BitmapCharRec ch211 = {6,10,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch211data};

/* char: 210 */

static GLubyte ch210data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,0x0,0x20,0x40,
};

static BitmapCharRec ch210 = {6,10,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch210data};

/* char: 209 */

static GLubyte ch209data[] = {
0xe4,0x4c,0x4c,0x54,0x54,0x64,0xee,0x0,0x50,0x28,
};

static BitmapCharRec ch209 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch209data};

/* char: 208 */

static GLubyte ch208data[] = {
0xf8,0x4c,0x44,0xe4,0x44,0x4c,0xf8,
};

static BitmapCharRec ch208 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch208data};

/* char: 207 */

static GLubyte ch207data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xe0,0x0,0xa0,
};

static BitmapCharRec ch207 = {3,9,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch207data};

/* char: 206 */

static GLubyte ch206data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xe0,0x0,0xa0,0x40,
};

static BitmapCharRec ch206 = {3,10,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch206data};

/* char: 205 */

static GLubyte ch205data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xe0,0x0,0x40,0x20,
};

static BitmapCharRec ch205 = {3,10,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch205data};

/* char: 204 */

static GLubyte ch204data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xe0,0x0,0x40,0x80,
};

static BitmapCharRec ch204 = {3,10,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch204data};

/* char: 203 */

static GLubyte ch203data[] = {
0xf8,0x48,0x40,0x70,0x40,0x48,0xf8,0x0,0x50,
};

static BitmapCharRec ch203 = {5,9,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch203data};

/* char: 202 */

static GLubyte ch202data[] = {
0xf8,0x48,0x40,0x70,0x40,0x48,0xf8,0x0,0x50,0x20,
};

static BitmapCharRec ch202 = {5,10,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch202data};

/* char: 201 */

static GLubyte ch201data[] = {
0xf8,0x48,0x40,0x70,0x40,0x48,0xf8,0x0,0x20,0x10,
};

static BitmapCharRec ch201 = {5,10,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch201data};

/* char: 200 */

static GLubyte ch200data[] = {
0xf8,0x48,0x40,0x70,0x40,0x48,0xf8,0x0,0x20,0x40,
};

static BitmapCharRec ch200 = {5,10,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch200data};

/* char: 199 */

static GLubyte ch199data[] = {
0x60,0x10,0x20,0x78,0xc4,0x80,0x80,0x80,0xc4,0x7c,
};

static BitmapCharRec ch199 = {6,10,(GLfloat)0,(GLfloat)3,(GLfloat)7,ch199data};

/* char: 198 */

static GLubyte ch198data[] = {
0xef,0x49,0x78,0x2e,0x28,0x39,0x1f,
};

static BitmapCharRec ch198 = {8,7,(GLfloat)0,(GLfloat)0,(GLfloat)9,ch198data};

/* char: 197 */

static GLubyte ch197data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x10,0x28,0x10,
};

static BitmapCharRec ch197 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch197data};

/* char: 196 */

static GLubyte ch196data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x0,0x28,
};

static BitmapCharRec ch196 = {7,9,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch196data};

/* char: 195 */

static GLubyte ch195data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x0,0x28,0x14,
};

static BitmapCharRec ch195 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch195data};

/* char: 194 */

static GLubyte ch194data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x0,0x28,0x10,
};

static BitmapCharRec ch194 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch194data};

/* char: 193 */

static GLubyte ch193data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x0,0x10,0x8,
};

static BitmapCharRec ch193 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch193data};

/* char: 192 */

static GLubyte ch192data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,0x0,0x10,0x20,
};

static BitmapCharRec ch192 = {7,10,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch192data};

/* char: 191 */

static GLubyte ch191data[] = {
0xe0,0xa0,0x80,0x40,0x40,0x0,0x40,
};

static BitmapCharRec ch191 = {3,7,(GLfloat)0,(GLfloat)2,(GLfloat)4,ch191data};

/* char: 190 */

static GLubyte ch190data[] = {
0x44,0x3e,0x2c,0xd4,0x28,0x48,0xe4,
};

static BitmapCharRec ch190 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch190data};

/* char: 189 */

static GLubyte ch189data[] = {
0x4e,0x24,0x2a,0xf6,0x48,0xc8,0x44,
};

static BitmapCharRec ch189 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch189data};

/* char: 188 */

static GLubyte ch188data[] = {
0x44,0x3e,0x2c,0xf4,0x48,0xc8,0x44,
};

static BitmapCharRec ch188 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch188data};

/* char: 187 */

static GLubyte ch187data[] = {
0xa0,0x50,0x50,0xa0,
};

static BitmapCharRec ch187 = {4,4,(GLfloat)0,(GLfloat)-1,(GLfloat)5,ch187data};

/* char: 186 */

static GLubyte ch186data[] = {
0xe0,0x0,0x40,0xa0,0x40,
};

static BitmapCharRec ch186 = {3,5,(GLfloat)0,(GLfloat)-2,(GLfloat)4,ch186data};

/* char: 185 */

static GLubyte ch185data[] = {
0xe0,0x40,0xc0,0x40,
};

static BitmapCharRec ch185 = {3,4,(GLfloat)0,(GLfloat)-3,(GLfloat)3,ch185data};

/* char: 184 */

static GLubyte ch184data[] = {
0xc0,0x20,0x40,
};

static BitmapCharRec ch184 = {3,3,(GLfloat)0,(GLfloat)3,(GLfloat)4,ch184data};

/* char: 183 */

static GLubyte ch183data[] = {
0x80,
};

static BitmapCharRec ch183 = {1,1,(GLfloat)0,(GLfloat)-2,(GLfloat)2,ch183data};

/* char: 182 */

static GLubyte ch182data[] = {
0x28,0x28,0x28,0x28,0x68,0xe8,0xe8,0xe8,0x7c,
};

static BitmapCharRec ch182 = {6,9,(GLfloat)0,(GLfloat)2,(GLfloat)6,ch182data};

/* char: 181 */

static GLubyte ch181data[] = {
0x80,0x80,0xe8,0x90,0x90,0x90,0x90,
};

static BitmapCharRec ch181 = {5,7,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch181data};

/* char: 180 */

static GLubyte ch180data[] = {
0x80,0x40,
};

static BitmapCharRec ch180 = {2,2,(GLfloat)0,(GLfloat)-5,(GLfloat)3,ch180data};

/* char: 179 */

static GLubyte ch179data[] = {
0xc0,0x20,0x40,0xe0,
};

static BitmapCharRec ch179 = {3,4,(GLfloat)0,(GLfloat)-3,(GLfloat)3,ch179data};

/* char: 178 */

static GLubyte ch178data[] = {
0xe0,0x40,0xa0,0x60,
};

static BitmapCharRec ch178 = {3,4,(GLfloat)0,(GLfloat)-3,(GLfloat)3,ch178data};

/* char: 177 */

static GLubyte ch177data[] = {
0xf8,0x0,0x20,0x20,0xf8,0x20,0x20,
};

static BitmapCharRec ch177 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch177data};

/* char: 176 */

static GLubyte ch176data[] = {
0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch176 = {4,4,(GLfloat)0,(GLfloat)-3,(GLfloat)4,ch176data};

/* char: 175 */

static GLubyte ch175data[] = {
0xe0,
};

static BitmapCharRec ch175 = {3,1,(GLfloat)0,(GLfloat)-6,(GLfloat)4,ch175data};

/* char: 174 */

static GLubyte ch174data[] = {
0x38,0x44,0xaa,0xb2,0xba,0x44,0x38,
};

static BitmapCharRec ch174 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch174data};

/* char: 173 */

static GLubyte ch173data[] = {
0xe0,
};

static BitmapCharRec ch173 = {3,1,(GLfloat)0,(GLfloat)-2,(GLfloat)4,ch173data};

/* char: 172 */

static GLubyte ch172data[] = {
0x8,0x8,0xf8,
};

static BitmapCharRec ch172 = {5,3,(GLfloat)-1,(GLfloat)-1,(GLfloat)7,ch172data};

/* char: 171 */

static GLubyte ch171data[] = {
0x50,0xa0,0xa0,0x50,
};

static BitmapCharRec ch171 = {4,4,(GLfloat)0,(GLfloat)-1,(GLfloat)5,ch171data};

/* char: 170 */

static GLubyte ch170data[] = {
0xe0,0x0,0xa0,0x20,0xc0,
};

static BitmapCharRec ch170 = {3,5,(GLfloat)0,(GLfloat)-2,(GLfloat)4,ch170data};

/* char: 169 */

static GLubyte ch169data[] = {
0x38,0x44,0x9a,0xa2,0x9a,0x44,0x38,
};

static BitmapCharRec ch169 = {7,7,(GLfloat)-1,(GLfloat)0,(GLfloat)9,ch169data};

/* char: 168 */

static GLubyte ch168data[] = {
0xa0,
};

static BitmapCharRec ch168 = {3,1,(GLfloat)-1,(GLfloat)-6,(GLfloat)5,ch168data};

/* char: 167 */

static GLubyte ch167data[] = {
0xe0,0x90,0x20,0x50,0x90,0xa0,0x40,0x90,0x70,
};

static BitmapCharRec ch167 = {4,9,(GLfloat)0,(GLfloat)1,(GLfloat)5,ch167data};

/* char: 166 */

static GLubyte ch166data[] = {
0x80,0x80,0x80,0x0,0x80,0x80,0x80,
};

static BitmapCharRec ch166 = {1,7,(GLfloat)0,(GLfloat)0,(GLfloat)2,ch166data};

/* char: 165 */

static GLubyte ch165data[] = {
0x70,0x20,0xf8,0x20,0xd8,0x50,0x88,
};

static BitmapCharRec ch165 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch165data};

/* char: 164 */

static GLubyte ch164data[] = {
0x88,0x70,0x50,0x50,0x70,0x88,
};

static BitmapCharRec ch164 = {5,6,(GLfloat)0,(GLfloat)-1,(GLfloat)5,ch164data};

/* char: 163 */

static GLubyte ch163data[] = {
0xf0,0xc8,0x40,0xe0,0x40,0x50,0x30,
};

static BitmapCharRec ch163 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch163data};

/* char: 162 */

static GLubyte ch162data[] = {
0x80,0xe0,0x90,0x80,0x90,0x70,0x10,
};

static BitmapCharRec ch162 = {4,7,(GLfloat)0,(GLfloat)1,(GLfloat)5,ch162data};

/* char: 161 */

static GLubyte ch161data[] = {
0x80,0x80,0x80,0x80,0x80,0x0,0x80,
};

static BitmapCharRec ch161 = {1,7,(GLfloat)-1,(GLfloat)2,(GLfloat)3,ch161data};

/* char: 126 '~' */

static GLubyte ch126data[] = {
0x98,0x64,
};

static BitmapCharRec ch126 = {6,2,(GLfloat)0,(GLfloat)-2,(GLfloat)7,ch126data};

/* char: 125 '}' */

static GLubyte ch125data[] = {
0x80,0x40,0x40,0x40,0x20,0x40,0x40,0x40,0x80,
};

static BitmapCharRec ch125 = {3,9,(GLfloat)0,(GLfloat)2,(GLfloat)4,ch125data};

/* char: 124 '|' */

static GLubyte ch124data[] = {
0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch124 = {1,9,(GLfloat)0,(GLfloat)2,(GLfloat)2,ch124data};

/* char: 123 '{' */

static GLubyte ch123data[] = {
0x20,0x40,0x40,0x40,0x80,0x40,0x40,0x40,0x20,
};

static BitmapCharRec ch123 = {3,9,(GLfloat)0,(GLfloat)2,(GLfloat)4,ch123data};

/* char: 122 'z' */

static GLubyte ch122data[] = {
0xf0,0x90,0x40,0x20,0xf0,
};

static BitmapCharRec ch122 = {4,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch122data};

/* char: 121 'y' */

static GLubyte ch121data[] = {
0x40,0x40,0x20,0x30,0x50,0x48,0xdc,
};

static BitmapCharRec ch121 = {6,7,(GLfloat)1,(GLfloat)2,(GLfloat)5,ch121data};

/* char: 120 'x' */

static GLubyte ch120data[] = {
0xd8,0x50,0x20,0x50,0xd8,
};

static BitmapCharRec ch120 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch120data};

/* char: 119 'w' */

static GLubyte ch119data[] = {
0x28,0x6c,0x54,0x92,0xdb,
};

static BitmapCharRec ch119 = {8,5,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch119data};

/* char: 118 'v' */

static GLubyte ch118data[] = {
0x20,0x60,0x50,0x90,0xd8,
};

static BitmapCharRec ch118 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch118data};

/* char: 117 'u' */

static GLubyte ch117data[] = {
0x68,0x90,0x90,0x90,0x90,
};

static BitmapCharRec ch117 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch117data};

/* char: 116 't' */

static GLubyte ch116data[] = {
0x30,0x40,0x40,0x40,0xe0,0x40,
};

static BitmapCharRec ch116 = {4,6,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch116data};

/* char: 115 's' */

static GLubyte ch115data[] = {
0xe0,0x20,0x60,0x80,0xe0,
};

static BitmapCharRec ch115 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch115data};

/* char: 114 'r' */

static GLubyte ch114data[] = {
0xe0,0x40,0x40,0x60,0xa0,
};

static BitmapCharRec ch114 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch114data};

/* char: 113 'q' */

static GLubyte ch113data[] = {
0x38,0x10,0x70,0x90,0x90,0x90,0x70,
};

static BitmapCharRec ch113 = {5,7,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch113data};

/* char: 112 'p' */

static GLubyte ch112data[] = {
0xc0,0x80,0xe0,0x90,0x90,0x90,0xe0,
};

static BitmapCharRec ch112 = {4,7,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch112data};

/* char: 111 'o' */

static GLubyte ch111data[] = {
0x60,0x90,0x90,0x90,0x60,
};

static BitmapCharRec ch111 = {4,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch111data};

/* char: 110 'n' */

static GLubyte ch110data[] = {
0xd8,0x90,0x90,0x90,0xe0,
};

static BitmapCharRec ch110 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch110data};

/* char: 109 'm' */

static GLubyte ch109data[] = {
0xdb,0x92,0x92,0x92,0xec,
};

static BitmapCharRec ch109 = {8,5,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch109data};

/* char: 108 'l' */

static GLubyte ch108data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xc0,
};

static BitmapCharRec ch108 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch108data};

/* char: 107 'k' */

static GLubyte ch107data[] = {
0x98,0x90,0xe0,0xa0,0x90,0x80,0x80,
};

static BitmapCharRec ch107 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch107data};

/* char: 106 'j' */

static GLubyte ch106data[] = {
0x80,0x40,0x40,0x40,0x40,0x40,0xc0,0x0,0x40,
};

static BitmapCharRec ch106 = {2,9,(GLfloat)0,(GLfloat)2,(GLfloat)3,ch106data};

/* char: 105 'i' */

static GLubyte ch105data[] = {
0x40,0x40,0x40,0x40,0xc0,0x0,0x40,
};

static BitmapCharRec ch105 = {2,7,(GLfloat)0,(GLfloat)0,(GLfloat)3,ch105data};

/* char: 104 'h' */

static GLubyte ch104data[] = {
0xd8,0x90,0x90,0x90,0xe0,0x80,0x80,
};

static BitmapCharRec ch104 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch104data};

/* char: 103 'g' */

static GLubyte ch103data[] = {
0xe0,0x90,0x60,0x40,0xa0,0xa0,0x70,
};

static BitmapCharRec ch103 = {4,7,(GLfloat)0,(GLfloat)2,(GLfloat)5,ch103data};

/* char: 102 'f' */

static GLubyte ch102data[] = {
0xe0,0x40,0x40,0x40,0xe0,0x40,0x30,
};

static BitmapCharRec ch102 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch102data};

/* char: 101 'e' */

static GLubyte ch101data[] = {
0x60,0x80,0xc0,0xa0,0x60,
};

static BitmapCharRec ch101 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch101data};

/* char: 100 'd' */

static GLubyte ch100data[] = {
0x68,0x90,0x90,0x90,0x70,0x10,0x30,
};

static BitmapCharRec ch100 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch100data};

/* char: 99 'c' */

static GLubyte ch99data[] = {
0x60,0x80,0x80,0x80,0x60,
};

static BitmapCharRec ch99 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch99data};

/* char: 98 'b' */

static GLubyte ch98data[] = {
0xe0,0x90,0x90,0x90,0xe0,0x80,0x80,
};

static BitmapCharRec ch98 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch98data};

/* char: 97 'a' */

static GLubyte ch97data[] = {
0xe0,0xa0,0x60,0x20,0xc0,
};

static BitmapCharRec ch97 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch97data};

/* char: 96 '`' */

static GLubyte ch96data[] = {
0xc0,0x80,
};

static BitmapCharRec ch96 = {2,2,(GLfloat)0,(GLfloat)-5,(GLfloat)3,ch96data};

/* char: 95 '_' */

static GLubyte ch95data[] = {
0xf8,
};

static BitmapCharRec ch95 = {5,1,(GLfloat)0,(GLfloat)3,(GLfloat)5,ch95data};

/* char: 94 '^' */

static GLubyte ch94data[] = {
0xa0,0xa0,0x40,
};

static BitmapCharRec ch94 = {3,3,(GLfloat)-1,(GLfloat)-4,(GLfloat)5,ch94data};

/* char: 93 ']' */

static GLubyte ch93data[] = {
0xc0,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0xc0,
};

static BitmapCharRec ch93 = {2,9,(GLfloat)0,(GLfloat)2,(GLfloat)3,ch93data};

/* char: 92 '\' */

static GLubyte ch92data[] = {
0x20,0x20,0x40,0x40,0x40,0x80,0x80,
};

static BitmapCharRec ch92 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)3,ch92data};

/* char: 91 '[' */

static GLubyte ch91data[] = {
0xc0,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0xc0,
};

static BitmapCharRec ch91 = {2,9,(GLfloat)0,(GLfloat)2,(GLfloat)3,ch91data};

/* char: 90 'Z' */

static GLubyte ch90data[] = {
0xf8,0x88,0x40,0x20,0x10,0x88,0xf8,
};

static BitmapCharRec ch90 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch90data};

/* char: 89 'Y' */

static GLubyte ch89data[] = {
0x38,0x10,0x10,0x28,0x28,0x44,0xee,
};

static BitmapCharRec ch89 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch89data};

/* char: 88 'X' */

static GLubyte ch88data[] = {
0xee,0x44,0x28,0x10,0x28,0x44,0xee,
};

static BitmapCharRec ch88 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch88data};

/* char: 87 'W' */

static GLubyte ch87data[] = {
0x22,0x0,0x22,0x0,0x55,0x0,0x55,0x0,0xc9,0x80,0x88,0x80,0xdd,0xc0,
};

static BitmapCharRec ch87 = {10,7,(GLfloat)0,(GLfloat)0,(GLfloat)10,ch87data};

/* char: 86 'V' */

static GLubyte ch86data[] = {
0x10,0x10,0x28,0x28,0x6c,0x44,0xee,
};

static BitmapCharRec ch86 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch86data};

/* char: 85 'U' */

static GLubyte ch85data[] = {
0x38,0x6c,0x44,0x44,0x44,0x44,0xee,
};

static BitmapCharRec ch85 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch85data};

/* char: 84 'T' */

static GLubyte ch84data[] = {
0x70,0x20,0x20,0x20,0x20,0xa8,0xf8,
};

static BitmapCharRec ch84 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch84data};

/* char: 83 'S' */

static GLubyte ch83data[] = {
0xe0,0x90,0x10,0x60,0xc0,0x90,0x70,
};

static BitmapCharRec ch83 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch83data};

/* char: 82 'R' */

static GLubyte ch82data[] = {
0xec,0x48,0x50,0x70,0x48,0x48,0xf0,
};

static BitmapCharRec ch82 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch82data};

/* char: 81 'Q' */

static GLubyte ch81data[] = {
0xc,0x18,0x70,0xcc,0x84,0x84,0x84,0xcc,0x78,
};

static BitmapCharRec ch81 = {6,9,(GLfloat)0,(GLfloat)2,(GLfloat)7,ch81data};

/* char: 80 'P' */

static GLubyte ch80data[] = {
0xe0,0x40,0x40,0x70,0x48,0x48,0xf0,
};

static BitmapCharRec ch80 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch80data};

/* char: 79 'O' */

static GLubyte ch79data[] = {
0x78,0xcc,0x84,0x84,0x84,0xcc,0x78,
};

static BitmapCharRec ch79 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch79data};

/* char: 78 'N' */

static GLubyte ch78data[] = {
0xe4,0x4c,0x4c,0x54,0x54,0x64,0xee,
};

static BitmapCharRec ch78 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch78data};

/* char: 77 'M' */

static GLubyte ch77data[] = {
0xeb,0x80,0x49,0x0,0x55,0x0,0x55,0x0,0x63,0x0,0x63,0x0,0xe3,0x80,
};

static BitmapCharRec ch77 = {9,7,(GLfloat)0,(GLfloat)0,(GLfloat)10,ch77data};

/* char: 76 'L' */

static GLubyte ch76data[] = {
0xf8,0x48,0x40,0x40,0x40,0x40,0xe0,
};

static BitmapCharRec ch76 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch76data};

/* char: 75 'K' */

static GLubyte ch75data[] = {
0xec,0x48,0x50,0x60,0x50,0x48,0xec,
};

static BitmapCharRec ch75 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch75data};

/* char: 74 'J' */

static GLubyte ch74data[] = {
0xc0,0xa0,0x20,0x20,0x20,0x20,0x70,
};

static BitmapCharRec ch74 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch74data};

/* char: 73 'I' */

static GLubyte ch73data[] = {
0xe0,0x40,0x40,0x40,0x40,0x40,0xe0,
};

static BitmapCharRec ch73 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch73data};

/* char: 72 'H' */

static GLubyte ch72data[] = {
0xee,0x44,0x44,0x7c,0x44,0x44,0xee,
};

static BitmapCharRec ch72 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch72data};

/* char: 71 'G' */

static GLubyte ch71data[] = {
0x78,0xc4,0x84,0x9c,0x80,0xc4,0x7c,
};

static BitmapCharRec ch71 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch71data};

/* char: 70 'F' */

static GLubyte ch70data[] = {
0xe0,0x40,0x40,0x70,0x40,0x48,0xf8,
};

static BitmapCharRec ch70 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch70data};

/* char: 69 'E' */

static GLubyte ch69data[] = {
0xf8,0x48,0x40,0x70,0x40,0x48,0xf8,
};

static BitmapCharRec ch69 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch69data};

/* char: 68 'D' */

static GLubyte ch68data[] = {
0xf8,0x4c,0x44,0x44,0x44,0x4c,0xf8,
};

static BitmapCharRec ch68 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch68data};

/* char: 67 'C' */

static GLubyte ch67data[] = {
0x78,0xc4,0x80,0x80,0x80,0xc4,0x7c,
};

static BitmapCharRec ch67 = {6,7,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch67data};

/* char: 66 'B' */

static GLubyte ch66data[] = {
0xf0,0x48,0x48,0x70,0x48,0x48,0xf0,
};

static BitmapCharRec ch66 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch66data};

/* char: 65 'A' */

static GLubyte ch65data[] = {
0xee,0x44,0x7c,0x28,0x28,0x38,0x10,
};

static BitmapCharRec ch65 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch65data};

/* char: 64 '@' */

static GLubyte ch64data[] = {
0x3e,0x40,0x92,0xad,0xa5,0xa5,0x9d,0x42,0x3c,
};

static BitmapCharRec ch64 = {8,9,(GLfloat)0,(GLfloat)2,(GLfloat)9,ch64data};

/* char: 63 '?' */

static GLubyte ch63data[] = {
0x40,0x0,0x40,0x40,0x20,0xa0,0xe0,
};

static BitmapCharRec ch63 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)4,ch63data};

/* char: 62 '>' */

static GLubyte ch62data[] = {
0x80,0x40,0x20,0x40,0x80,
};

static BitmapCharRec ch62 = {3,5,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch62data};

/* char: 61 '=' */

static GLubyte ch61data[] = {
0xf8,0x0,0xf8,
};

static BitmapCharRec ch61 = {5,3,(GLfloat)0,(GLfloat)-1,(GLfloat)6,ch61data};

/* char: 60 '<' */

static GLubyte ch60data[] = {
0x20,0x40,0x80,0x40,0x20,
};

static BitmapCharRec ch60 = {3,5,(GLfloat)-1,(GLfloat)0,(GLfloat)5,ch60data};

/* char: 59 ';' */

static GLubyte ch59data[] = {
0x80,0x80,0x80,0x0,0x0,0x0,0x80,
};

static BitmapCharRec ch59 = {1,7,(GLfloat)-1,(GLfloat)2,(GLfloat)3,ch59data};

/* char: 58 ':' */

static GLubyte ch58data[] = {
0x80,0x0,0x0,0x0,0x80,
};

static BitmapCharRec ch58 = {1,5,(GLfloat)-1,(GLfloat)0,(GLfloat)3,ch58data};

/* char: 57 '9' */

static GLubyte ch57data[] = {
0xc0,0x20,0x70,0x90,0x90,0x90,0x60,
};

static BitmapCharRec ch57 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch57data};

/* char: 56 '8' */

static GLubyte ch56data[] = {
0x60,0x90,0x90,0x60,0x90,0x90,0x60,
};

static BitmapCharRec ch56 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch56data};

/* char: 55 '7' */

static GLubyte ch55data[] = {
0x40,0x40,0x40,0x20,0x20,0x90,0xf0,
};

static BitmapCharRec ch55 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch55data};

/* char: 54 '6' */

static GLubyte ch54data[] = {
0x60,0x90,0x90,0x90,0xe0,0x40,0x30,
};

static BitmapCharRec ch54 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch54data};

/* char: 53 '5' */

static GLubyte ch53data[] = {
0xe0,0x90,0x10,0x10,0xe0,0x40,0x70,
};

static BitmapCharRec ch53 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch53data};

/* char: 52 '4' */

static GLubyte ch52data[] = {
0x10,0x10,0xf8,0x90,0x50,0x30,0x10,
};

static BitmapCharRec ch52 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch52data};

/* char: 51 '3' */

static GLubyte ch51data[] = {
0xe0,0x10,0x10,0x60,0x10,0x90,0x60,
};

static BitmapCharRec ch51 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch51data};

/* char: 50 '2' */

static GLubyte ch50data[] = {
0xf0,0x40,0x20,0x20,0x10,0x90,0x60,
};

static BitmapCharRec ch50 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch50data};

/* char: 49 '1' */

static GLubyte ch49data[] = {
0xe0,0x40,0x40,0x40,0x40,0xc0,0x40,
};

static BitmapCharRec ch49 = {3,7,(GLfloat)-1,(GLfloat)0,(GLfloat)5,ch49data};

/* char: 48 '0' */

static GLubyte ch48data[] = {
0x60,0x90,0x90,0x90,0x90,0x90,0x60,
};

static BitmapCharRec ch48 = {4,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch48data};

/* char: 47 '/' */

static GLubyte ch47data[] = {
0x80,0x80,0x40,0x40,0x40,0x20,0x20,
};

static BitmapCharRec ch47 = {3,7,(GLfloat)0,(GLfloat)0,(GLfloat)3,ch47data};

/* char: 46 '.' */

static GLubyte ch46data[] = {
0x80,
};

static BitmapCharRec ch46 = {1,1,(GLfloat)-1,(GLfloat)0,(GLfloat)3,ch46data};

/* char: 45 '-' */

static GLubyte ch45data[] = {
0xf0,
};

static BitmapCharRec ch45 = {4,1,(GLfloat)-1,(GLfloat)-2,(GLfloat)7,ch45data};

/* char: 44 ',' */

static GLubyte ch44data[] = {
0x80,0x80,0x80,
};

static BitmapCharRec ch44 = {1,3,(GLfloat)-1,(GLfloat)2,(GLfloat)3,ch44data};

/* char: 43 '+' */

static GLubyte ch43data[] = {
0x20,0x20,0xf8,0x20,0x20,
};

static BitmapCharRec ch43 = {5,5,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch43data};

/* char: 42 '*' */

static GLubyte ch42data[] = {
0xa0,0x40,0xa0,
};

static BitmapCharRec ch42 = {3,3,(GLfloat)0,(GLfloat)-4,(GLfloat)5,ch42data};

/* char: 41 ')' */

static GLubyte ch41data[] = {
0x80,0x40,0x40,0x20,0x20,0x20,0x40,0x40,0x80,
};

static BitmapCharRec ch41 = {3,9,(GLfloat)0,(GLfloat)2,(GLfloat)4,ch41data};

/* char: 40 '(' */

static GLubyte ch40data[] = {
0x20,0x40,0x40,0x80,0x80,0x80,0x40,0x40,0x20,
};

static BitmapCharRec ch40 = {3,9,(GLfloat)0,(GLfloat)2,(GLfloat)4,ch40data};

/* char: 39 ''' */

static GLubyte ch39data[] = {
0x40,0xc0,
};

static BitmapCharRec ch39 = {2,2,(GLfloat)0,(GLfloat)-5,(GLfloat)3,ch39data};

/* char: 38 '&' */

static GLubyte ch38data[] = {
0x76,0x8d,0x98,0x74,0x6e,0x50,0x30,
};

static BitmapCharRec ch38 = {8,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch38data};

/* char: 37 '%' */

static GLubyte ch37data[] = {
0x44,0x2a,0x2a,0x56,0xa8,0xa4,0x7e,
};

static BitmapCharRec ch37 = {7,7,(GLfloat)0,(GLfloat)0,(GLfloat)8,ch37data};

/* char: 36 '$' */

static GLubyte ch36data[] = {
0x20,0xe0,0x90,0x10,0x60,0x80,0x90,0x70,0x20,
};

static BitmapCharRec ch36 = {4,9,(GLfloat)0,(GLfloat)1,(GLfloat)5,ch36data};

/* char: 35 '#' */

static GLubyte ch35data[] = {
0x50,0x50,0xf8,0x50,0xf8,0x50,0x50,
};

static BitmapCharRec ch35 = {5,7,(GLfloat)0,(GLfloat)0,(GLfloat)5,ch35data};

/* char: 34 '"' */

static GLubyte ch34data[] = {
0xa0,0xa0,
};

static BitmapCharRec ch34 = {3,2,(GLfloat)0,(GLfloat)-5,(GLfloat)4,ch34data};

/* char: 33 '!' */

static GLubyte ch33data[] = {
0x80,0x0,0x80,0x80,0x80,0x80,0x80,
};

static BitmapCharRec ch33 = {1,7,(GLfloat)-1,(GLfloat)0,(GLfloat)3,ch33data};

/* char: 32 ' ' */

static GLubyte ch32data[] = {
0x0,
};

static BitmapCharRec ch32 = {1,1,(GLfloat)0,(GLfloat)0,(GLfloat)2,ch32data};

static BitmapCharPtr chars[] = {
&ch32,
&ch33,
&ch34,
&ch35,
&ch36,
&ch37,
&ch38,
&ch39,
&ch40,
&ch41,
&ch42,
&ch43,
&ch44,
&ch45,
&ch46,
&ch47,
&ch48,
&ch49,
&ch50,
&ch51,
&ch52,
&ch53,
&ch54,
&ch55,
&ch56,
&ch57,
&ch58,
&ch59,
&ch60,
&ch61,
&ch62,
&ch63,
&ch64,
&ch65,
&ch66,
&ch67,
&ch68,
&ch69,
&ch70,
&ch71,
&ch72,
&ch73,
&ch74,
&ch75,
&ch76,
&ch77,
&ch78,
&ch79,
&ch80,
&ch81,
&ch82,
&ch83,
&ch84,
&ch85,
&ch86,
&ch87,
&ch88,
&ch89,
&ch90,
&ch91,
&ch92,
&ch93,
&ch94,
&ch95,
&ch96,
&ch97,
&ch98,
&ch99,
&ch100,
&ch101,
&ch102,
&ch103,
&ch104,
&ch105,
&ch106,
&ch107,
&ch108,
&ch109,
&ch110,
&ch111,
&ch112,
&ch113,
&ch114,
&ch115,
&ch116,
&ch117,
&ch118,
&ch119,
&ch120,
&ch121,
&ch122,
&ch123,
&ch124,
&ch125,
&ch126,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
&ch161,
&ch162,
&ch163,
&ch164,
&ch165,
&ch166,
&ch167,
&ch168,
&ch169,
&ch170,
&ch171,
&ch172,
&ch173,
&ch174,
&ch175,
&ch176,
&ch177,
&ch178,
&ch179,
&ch180,
&ch181,
&ch182,
&ch183,
&ch184,
&ch185,
&ch186,
&ch187,
&ch188,
&ch189,
&ch190,
&ch191,
&ch192,
&ch193,
&ch194,
&ch195,
&ch196,
&ch197,
&ch198,
&ch199,
&ch200,
&ch201,
&ch202,
&ch203,
&ch204,
&ch205,
&ch206,
&ch207,
&ch208,
&ch209,
&ch210,
&ch211,
&ch212,
&ch213,
&ch214,
&ch215,
&ch216,
&ch217,
&ch218,
&ch219,
&ch220,
&ch221,
&ch222,
&ch223,
&ch224,
&ch225,
&ch226,
&ch227,
&ch228,
&ch229,
&ch230,
&ch231,
&ch232,
&ch233,
&ch234,
&ch235,
&ch236,
&ch237,
&ch238,
&ch239,
&ch240,
&ch241,
&ch242,
&ch243,
&ch244,
&ch245,
&ch246,
&ch247,
&ch248,
&ch249,
&ch250,
&ch251,
&ch252,
&ch253,
&ch254,
&ch255,
};

BitmapFontRec glutBitmapTimesRoman10 = {
"-adobe-times-medium-r-normal--10-100-75-75-p-54-iso8859-1",
224,
32,
chars
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltutil.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>

#include "gltint.h"

void
__glutWarning(char *format,...)
{
  va_list args;

  va_start(args, format);
  fprintf(stderr, "GLUT: Warning in %s: ",
    __glutProgramName ? __glutProgramName : "(unamed)");
  vfprintf(stderr, format, args);
  va_end(args);
  putc('\n', stderr);
}

void
__glutFatalError(char *format,...)
{
  va_list args;

  va_start(args, format);
  fprintf(stderr, "GLUT: Fatal Error in %s: ",
    __glutProgramName ? __glutProgramName : "(unamed)");
  vfprintf(stderr, format, args);
  va_end(args);
  putc('\n', stderr);
  exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltwmisc.c ===
/* Copyright (c) Mark J. Kilgard, 1994.  */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "gltint.h"

/* CENTRY */
void
glutSetWindowTitle(char *title)
{
  assert(!__glutCurrentWindow->parent);
  __glutOsSetWindowTitle(__glutCurrentWindow->owin, title);
}

void
glutSetIconTitle(char *title)
{
  assert(!__glutCurrentWindow->parent);
  __glutOsSetIconTitle(__glutCurrentWindow->owin, title);
}

void
glutPositionWindow(int x, int y)
{
  __glutCurrentWindow->desired_x = x;
  __glutCurrentWindow->desired_y = y;
  __glutCurrentWindow->desired_conf_mask |=
    GLUT_OS_CONFIGURE_X | GLUT_OS_CONFIGURE_Y;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_CONFIGURE_WORK);
}

void
glutReshapeWindow(int w, int h)
{
  __glutCurrentWindow->desired_width = w;
  __glutCurrentWindow->desired_height = h;
  __glutCurrentWindow->desired_conf_mask |=
    GLUT_OS_CONFIGURE_WIDTH | GLUT_OS_CONFIGURE_HEIGHT;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_CONFIGURE_WORK);
}

void
glutPopWindow(void)
{
  __glutCurrentWindow->desired_stack = GLUT_OS_STACK_ABOVE;
  __glutCurrentWindow->desired_conf_mask |= GLUT_OS_CONFIGURE_STACKING;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_CONFIGURE_WORK);
}

void
glutPushWindow(void)
{
  __glutCurrentWindow->desired_stack = GLUT_OS_STACK_BELOW;
  __glutCurrentWindow->desired_conf_mask |= GLUT_OS_CONFIGURE_STACKING;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_CONFIGURE_WORK);
}

void
glutIconifyWindow(void)
{
  assert(!__glutCurrentWindow->parent);
  __glutCurrentWindow->desired_map_state = GLUT_OS_ICONIC_STATE;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_MAP_WORK);
}

void
glutShowWindow(void)
{
  __glutCurrentWindow->desired_map_state = GLUT_OS_NORMAL_STATE;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_MAP_WORK);
}

void
glutHideWindow(void)
{
  __glutCurrentWindow->desired_map_state = GLUT_OS_HIDDEN_STATE;
  __glutPutOnWorkList(__glutCurrentWindow, GLUT_MAP_WORK);
}

/* ENDCENTRY */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\gltwin.c ===
/* Copyright (c) Mark J. Kilgard, 1994.  */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include "gltint.h"

GLUTwindow *__glutCurrentWindow = NULL;
GLUTwindow **__glutWindowList = NULL;
int __glutWindowListSize = 0;
int __glutIndirectContexts = 0;

/* CENTRY */
int
glutGetWindow(void)
{
  if (__glutCurrentWindow) {
    return __glutCurrentWindow->num + 1;
  } else {
    return 0;
  }
}
/* ENDCENTRY */

static GLUTwindow *__glutWindowCache = NULL;

GLUTwindow *
__glutGetWindow(GLUTosWindow owin)
{
  int i;

  if (__glutWindowCache && owin == __glutWindowCache->owin) {
    return __glutWindowCache;
  }
  for (i = 0; i < __glutWindowListSize; i++) {
    if (__glutWindowList[i]) {
      if (owin == __glutWindowList[i]->owin) {
        __glutWindowCache = __glutWindowList[i];
        return __glutWindowCache;
      }
    }
  }
  return NULL;
}

void
__glutSetWindow(GLUTwindow * window)
{
  if (window != __glutCurrentWindow) {
    __glutCurrentWindow = window;
    __glutOsMakeCurrent(__glutCurrentWindow->owin, __glutCurrentWindow->octx);
  }
}

/* CENTRY */
void
glutSetWindow(int win)
{
  GLUTwindow *window;

  if (win < 1 || win > __glutWindowListSize) {
    __glutWarning("glutWindowSet attempted on bogus window.");
    return;
  }
  window = __glutWindowList[win - 1];
  if (!window) {
    __glutWarning("glutWindowSet attempted on bogus window.");
    return;
  }
  __glutSetWindow(window);
}
/* ENDCENTRY */

static int
getUnusedWindowSlot(void)
{
  int i;

  /* look for allocated, unused slot */
  for (i = 0; i < __glutWindowListSize; i++) {
    if (!__glutWindowList[i]) {
      return i;
    }
  }
  /* allocate a new slot */
  __glutWindowListSize++;
  __glutWindowList = (GLUTwindow **)
    realloc(__glutWindowList,
    __glutWindowListSize * sizeof(GLUTwindow *));
  if (!__glutWindowList)
    __glutFatalError("out of memory.");
  __glutWindowList[__glutWindowListSize - 1] = NULL;
  return __glutWindowListSize - 1;
}

static void
defaultReshape(GLsizei width, GLsizei height)
{
  glViewport(0, 0, width, height);
}

GLUTreshapeCB __glutDefaultReshape = defaultReshape;

GLUTwindow *
__glutCreateWindow(GLUTwindow * parent,
  char *title, int x, int y, int width, int height,
  int initial_state)
{
  GLUTwindow *window;
  int winnum;
  int i;
  unsigned long displayMode;

  if (!__glutInitialized)
    __glutRequiredInit();
  winnum = getUnusedWindowSlot();
  window = (GLUTwindow *) malloc(sizeof(GLUTwindow));
  if (!window)
    __glutFatalError("out of memory.");
  window->num = winnum;
  window->fakeSingle = GL_FALSE;

  displayMode = __glutDisplayMode;
  window->osurf = __glutOsGetSurface(displayMode);
  
  /* Fallback cases when can't get exactly what was asked
     for... */
  if (window->osurf == GLUT_OS_INVALID_SURFACE &&
      GLUT_WIND_IS_SINGLE(displayMode)) {
    /* If we can't find a single buffered visual, try looking
       for a double buffered visual.  We can treat a double
       buffered visual as a single buffer visual by changing
       the draw buffer to GL_FRONT and treating any swap
       buffers as no-ops. */
    displayMode |= GLUT_DOUBLE;
    window->osurf = __glutOsGetSurface(displayMode);
    window->fakeSingle = GL_TRUE;
  }
#if (GLUT_API_VERSION >= 2)
  if (window->osurf == GLUT_OS_INVALID_SURFACE &&
      GLUT_WIND_IS_MULTISAMPLE(displayMode)) {
    /* If we can't seem to get multisampling (ie, not Reality 
       Engine class graphics!), go without multisampling.  It 
       is up to the application to query how many
       multisamples were allocated (0 equals no
       multisampling) if the application is going to use
       multisampling for more than just anti-aliasing. */
    displayMode &= ~GLUT_MULTISAMPLE;
    window->osurf = __glutOsGetSurface(displayMode);
  }
#endif
  
  if (window->osurf == GLUT_OS_INVALID_SURFACE) {
    __glutFatalError(
      "surface with necessary capabilities not found.");
  }
  
  window->event_mask = GLUT_OS_STRUCTURE_NOTIFY_MASK;
  
  if (__glutOsSurfaceHasColormap(window->osurf))
  {
      window->colormap = __glutAssociateColormap(window->osurf);
      window->ocmap = window->colormap->ocmap;
  }
  else
  {
      window->colormap = NULL;
      window->ocmap = __glutOsGetSurfaceColormap(window->osurf);
  }

  window->owin = __glutOsCreateWindow(parent == NULL ?
                                     GLUT_OS_INVALID_WINDOW : parent->owin,
                                     title, x, y, width, height, window->osurf,
                                     window->ocmap, window->event_mask,
                                     initial_state);
  if (window->owin == GLUT_OS_INVALID_WINDOW)
    __glutFatalError(
      "Unable to create window.");
  
  window->octx = __glutOsCreateGlContext(window->owin, window->osurf,
                                        __glutTryDirect);
  if (window->octx == GLUT_OS_INVALID_GL_CONTEXT)
    __glutFatalError(
      "Unable to create context.");

  /* force reshape by first size notification */
  window->width = 0;
  window->height = 0;

  window->parent = parent;
  if (parent) {
    window->siblings = parent->children;
    parent->children = window;
  } else {
    window->siblings = NULL;
  }
  window->children = NULL;
  window->display = NULL;
  window->reshape = __glutDefaultReshape;
  window->mouse = NULL;
  window->motion = NULL;
  window->visibility = NULL;
  window->passive = NULL;
  window->entry = NULL;
#if (GLUT_API_VERSION >= 2)
  window->special = NULL;
  window->buttonBox = NULL;
  window->dials = NULL;
  window->spaceMotion = NULL;
  window->spaceRotate = NULL;
  window->spaceButton = NULL;
  window->tabletMotion = NULL;
  window->tabletButton = NULL;
  window->tabletPos[0] = -1;
  window->tabletPos[1] = -1;
#endif
  window->keyboard = NULL;
  window->map_state = GL_FALSE;
  window->vis_state = -1;  /* not VisibilityUnobscured,
                              VisibilityPartiallyObscured, or
                              VisibilityFullyObscured */
  window->work_mask = GLUT_MAP_WORK;
  window->desired_map_state = GLUT_OS_NORMAL_STATE;
  window->desired_conf_mask = 0;
  window->btn_uses = 0;
  window->prev_work_win = __glutWindowWorkList;
  __glutWindowWorkList = window;
  for (i = 0; i < GLUT_MAX_MENUS; i++) {
    window->menu[i] = 0;
  }
  __glutWindowList[winnum] = window;
  __glutSetWindow(window);
  if (window->fakeSingle)
    glDrawBuffer(GL_FRONT);
  return window;
}

GLUTwindow *
__glutToplevelOf(GLUTwindow * window)
{
  while (window->parent) {
    window = window->parent;
  }
  return window;
}

/* CENTRY */
int
glutCreateSubWindow(int win, int x, int y, int width, int height)
{
  GLUTwindow *window, *toplevel;

  window = __glutCreateWindow(__glutWindowList[win - 1],
    NULL, x, y, width, height, GLUT_OS_NORMAL_STATE);
  toplevel = __glutToplevelOf(window);
  if (toplevel->ocmap != window->ocmap) {
    __glutPutOnWorkList(toplevel, GLUT_COLORMAP_WORK);
  }
  return window->num + 1;
}

int
glutCreateWindow(char *title)
{
  GLUTwindow *window;

  window = __glutCreateWindow(NULL, title,
    __glutInitX, __glutInitY,
    __glutInitWidth, __glutInitHeight,
    __glutIconic ? GLUT_OS_ICONIC_STATE : GLUT_OS_NORMAL_STATE);
  return window->num + 1;
}
/* ENDCENTRY */

void
__glutDestroyWindow(GLUTwindow * window,
  GLUTwindow * initialWindow)
{
  GLUTwindow **prev, *cur, *parent, *siblings;

  /* recursively destroy any children */
  cur = window->children;
  while (cur) {
    siblings = cur->siblings;
    __glutDestroyWindow(cur, initialWindow);
    cur = siblings;
  }
  /* remove from parent's children list (only necessary for
     non-initial windows and subwindows!) */
  parent = window->parent;
  if (parent && parent == initialWindow->parent) {
    prev = &parent->children;
    cur = parent->children;
    while (cur) {
      if (cur == window) {
        *prev = cur->siblings;
        break;
      }
      prev = &(cur->siblings);
      cur = cur->siblings;
    }
  }
  /* destroy window itself */
  if (window == __glutCurrentWindow) {
    __glutOsMakeCurrent(window->owin, GLUT_OS_INVALID_GL_CONTEXT);
    __glutCurrentWindow = NULL;
  }
  __glutOsDestroyWindow(window->owin);
  __glutOsDestroyGlContext(window->octx);
  if (window->colormap) {
    /* only color index windows have colormap data structure */
    __glutFreeColormap(window->colormap);
  }
  else if (window->ocmap != GLUT_OS_INVALID_COLORMAP) {
    __glutOsDestroyColormap(window->ocmap);
  }
  __glutOsDestroySurface(window->osurf);
  __glutWindowList[window->num] = NULL;
  /* Remove window from "window work list" if it is there.  */
  prev = &__glutWindowWorkList;
  cur = __glutWindowWorkList;
  while (cur) {
    if (cur == window) {
      *prev = cur->prev_work_win;
      break;
    }
    prev = &(cur->prev_work_win);
    cur = cur->prev_work_win;
  }
  /* Remove window from the "get window cache" if it is there. */
  if(__glutWindowCache == window)
    __glutWindowCache = NULL;
  free(window);
}

/* CENTRY */
void
glutDestroyWindow(int win)
{
  GLUTwindow *window = __glutWindowList[win - 1];

  /* if not a toplevel window... */
  if (window->parent) {
    /* destroying subwindows may change colormap requirements;
       recalculate toplevel window's WM_COLORMAP_WINDOWS
       property */
    __glutPutOnWorkList(__glutToplevelOf(window->parent),
      GLUT_COLORMAP_WORK);
  }
  __glutDestroyWindow(window, window);
}

void
glutSwapBuffers(void)
{
  if (__glutCurrentWindow->fakeSingle) {
    /* pretend the double buffered window is single buffered, 
       so treat glutSwapBuffers as a no-op */
  } else {
      __glutOsSwapBuffers(__glutCurrentWindow->owin);
  }
}
/* ENDCENTRY */

void
__glutChangeWindowEventMask(long event_mask, GLboolean add)
{
  if (add) {
    /* add event_mask to window's event mask */
    if ((__glutCurrentWindow->event_mask & event_mask) !=
      event_mask) {
      __glutCurrentWindow->event_mask |= event_mask;
      __glutPutOnWorkList(__glutCurrentWindow,
        GLUT_EVENT_MASK_WORK);
    }
  } else {
    /* remove event_mask from window's event mask */
    if (__glutCurrentWindow->event_mask & event_mask) {
      __glutCurrentWindow->event_mask &= ~event_mask;
      __glutPutOnWorkList(__glutCurrentWindow,
        GLUT_EVENT_MASK_WORK);
    }
  }
}

void
glutDisplayFunc(GLUTdisplayCB displayFunc)
{
  __glutChangeWindowEventMask(GLUT_OS_EXPOSURE_MASK,
    (GLboolean)(displayFunc != NULL));
  __glutCurrentWindow->display = displayFunc;
}

void
glutKeyboardFunc(GLUTkeyboardCB keyboardFunc)
{
#if (GLUT_API_VERSION >= 2)
  __glutChangeWindowEventMask(GLUT_OS_KEY_PRESS_MASK,
    (GLboolean)(keyboardFunc != NULL || __glutCurrentWindow->special != NULL));
#else
  __glutChangeWindowEventMask(GLUT_OS_KEY_PRESS_MASK,
    (GLboolean)(keyboardFunc != NULL));
#endif
  __glutCurrentWindow->keyboard = keyboardFunc;
}

#if (GLUT_API_VERSION >= 2)

void
glutSpecialFunc(GLUTspecialCB specialFunc)
{
  __glutChangeWindowEventMask(GLUT_OS_KEY_PRESS_MASK,
    (GLboolean)(specialFunc != NULL || __glutCurrentWindow->keyboard != NULL));
  __glutCurrentWindow->special = specialFunc;
}

#endif

void
glutMouseFunc(GLUTmouseCB mouseFunc)
{
  if (__glutCurrentWindow->mouse) {
    if (!mouseFunc) {
      /* previous mouseFunc being disabled */
      __glutCurrentWindow->btn_uses--;
      __glutChangeWindowEventMask(
        GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK,
        (GLboolean)(__glutCurrentWindow->btn_uses > 0));
    }
  } else {
    if (mouseFunc) {
      /* previously no mouseFunc, new one being installed */
      __glutCurrentWindow->btn_uses++;
      __glutChangeWindowEventMask(
        GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK, GL_TRUE);
    }
  }
  __glutCurrentWindow->mouse = mouseFunc;
}

void
glutMotionFunc(GLUTmotionCB motionFunc)
{
  /* Hack.  Some window managers (4Dwm by default) will mask
     motion events if the client is not selecting for button
     press and release events. So we select for press and
     release events too (being careful to use reference
     counting).  */
  if (__glutCurrentWindow->motion) {
    if (!motionFunc) {
      /* previous mouseFunc being disabled */
      __glutCurrentWindow->btn_uses--;
      __glutChangeWindowEventMask(
        GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK,
        (GLboolean)(__glutCurrentWindow->btn_uses > 0));
    }
  } else {
    if (motionFunc) {
      /* previously no mouseFunc, new one being installed */
      __glutCurrentWindow->btn_uses++;
      __glutChangeWindowEventMask(
        GLUT_OS_BUTTON_PRESS_MASK | GLUT_OS_BUTTON_RELEASE_MASK, GL_TRUE);
    }
  }
  /* Real work of selecting for passive mouse motion.  */
  __glutChangeWindowEventMask(
    GLUT_OS_BUTTON1_MOTION_MASK | GLUT_OS_BUTTON2_MOTION_MASK |
    GLUT_OS_BUTTON3_MOTION_MASK, (GLboolean)(motionFunc != NULL));
  __glutCurrentWindow->motion = motionFunc;
}

void
glutPassiveMotionFunc(GLUTpassiveCB passiveMotionFunc)
{
  __glutChangeWindowEventMask(GLUT_OS_POINTER_MOTION_MASK,
    (GLboolean)(passiveMotionFunc != NULL));
  __glutCurrentWindow->passive = passiveMotionFunc;
}

void
glutEntryFunc(GLUTentryCB entryFunc)
{
#ifdef GLUT_WIN32
  __glutWarning("GLUT for Win32 does not call glutEntryFunc.");
#endif
    
  __glutChangeWindowEventMask(GLUT_OS_ENTER_WINDOW_MASK |
    GLUT_OS_LEAVE_WINDOW_MASK, (GLboolean)(entryFunc != NULL));
  __glutCurrentWindow->entry = entryFunc;
}

void
glutVisibilityFunc(GLUTvisibilityCB visibilityFunc)
{
  __glutChangeWindowEventMask(GLUT_OS_VISIBILITY_CHANGE_MASK,
    (GLboolean)(visibilityFunc != NULL));
  __glutCurrentWindow->visibility = visibilityFunc;
  if (!visibilityFunc) {
    /* make state invalid */
    __glutCurrentWindow->vis_state = -1;
  }
}

void
glutReshapeFunc(GLUTreshapeCB reshapeFunc)
{
  if (reshapeFunc) {
    __glutCurrentWindow->reshape = reshapeFunc;
  } else {
    __glutCurrentWindow->reshape = __glutDefaultReshape;
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\layrutil.h ===
#ifndef __layerutil_h__
#define __layerutil_h__

/* Copyright (c) Mark J. Kilgard, 1993, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

/* Based on XLayerUtil.h: Revision: 1.3 */

#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xmd.h>

/* Transparent type values */
/*      None                  0 */
#define TransparentPixel      1
#define TransparentMask       2

/* layered visual info template flags */
#define VisualLayerMask		0x200
#define VisualTransparentType	0x400
#define VisualTransparentValue	0x800
#define VisualAllLayerMask	0xFFF

/* layered visual info structure */
typedef struct _XLayerVisualInfo {
  XVisualInfo vinfo;
  int layer;
  int type;
  unsigned long value;
} XLayerVisualInfo;

/* SERVER_OVERLAY_VISUALS property element */
typedef struct _OverlayInfo {
  CARD32 overlay_visual;
  CARD32 transparent_type;
  CARD32 value;
  CARD32 layer;
} OverlayInfo;

extern XLayerVisualInfo *__glutXGetLayerVisualInfo(Display *,
  long, XLayerVisualInfo *, int *);
extern Status __glutXMatchLayerVisualInfo(Display *,
  int, int, int, int, XLayerVisualInfo *);

#endif /* __layerutil_h__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\glttr24.c ===
/* GENERATED FILE -- DO NOT MODIFY */

#include "gltbitmp.h"

/* char: 255 */

static GLubyte ch255data[] = {
0xe0,0x0,0xf0,0x0,0x18,0x0,0x8,0x0,0xc,0x0,0x4,0x0,0xe,0x0,0xe,0x0,
0x1a,0x0,0x19,0x0,0x19,0x0,0x31,0x0,0x30,0x80,0x30,0x80,0x60,0x80,0x60,0xc0,
0xf1,0xe0,0x0,0x0,0x0,0x0,0x33,0x0,0x33,0x0,
};

static BitmapCharRec ch255 = {11,21,(GLfloat)0,(GLfloat)5,(GLfloat)11,ch255data};

/* char: 254 */

static GLubyte ch254data[] = {
0xf0,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x6e,0x0,0x73,0x80,0x61,0x80,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x61,0x80,0x73,0x80,
0x6e,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0xe0,0x0,
};

static BitmapCharRec ch254 = {10,22,(GLfloat)-1,(GLfloat)5,(GLfloat)12,ch254data};

/* char: 253 */

static GLubyte ch253data[] = {
0xe0,0x0,0xf0,0x0,0x18,0x0,0x8,0x0,0xc,0x0,0x4,0x0,0xe,0x0,0xe,0x0,
0x1a,0x0,0x19,0x0,0x19,0x0,0x31,0x0,0x30,0x80,0x30,0x80,0x60,0x80,0x60,0xc0,
0xf1,0xe0,0x0,0x0,0x8,0x0,0x6,0x0,0x3,0x80,0x1,0x80,
};

static BitmapCharRec ch253 = {11,22,(GLfloat)0,(GLfloat)5,(GLfloat)11,ch253data};

/* char: 252 */

static GLubyte ch252data[] = {
0x1c,0xe0,0x3e,0xc0,0x71,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0xe1,0xc0,0x0,0x0,0x0,0x0,0x33,0x0,0x33,0x0,
};

static BitmapCharRec ch252 = {11,16,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch252data};

/* char: 251 */

static GLubyte ch251data[] = {
0x1c,0xe0,0x3e,0xc0,0x71,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0xe1,0xc0,0x0,0x0,0x21,0x0,0x12,0x0,0x1e,0x0,
0xc,0x0,
};

static BitmapCharRec ch251 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch251data};

/* char: 250 */

static GLubyte ch250data[] = {
0x1c,0xe0,0x3e,0xc0,0x71,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0xe1,0xc0,0x0,0x0,0x8,0x0,0x6,0x0,0x3,0x80,
0x1,0x80,
};

static BitmapCharRec ch250 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch250data};

/* char: 249 */

static GLubyte ch249data[] = {
0x1c,0xe0,0x3e,0xc0,0x71,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0xe1,0xc0,0x0,0x0,0x2,0x0,0xc,0x0,0x38,0x0,
0x30,0x0,
};

static BitmapCharRec ch249 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch249data};

/* char: 248 */

static GLubyte ch248data[] = {
0xc0,0x0,0xde,0x0,0x73,0x80,0x71,0x80,0xd0,0xc0,0xd8,0xc0,0xc8,0xc0,0xcc,0xc0,
0xc4,0xc0,0xc6,0xc0,0x63,0x80,0x73,0x80,0x1e,0xc0,0x0,0xc0,
};

static BitmapCharRec ch248 = {10,14,(GLfloat)-1,(GLfloat)1,(GLfloat)12,ch248data};

/* char: 247 */

static GLubyte ch247data[] = {
0xc,0x0,0xc,0x0,0x0,0x0,0x0,0x0,0xff,0xc0,0x0,0x0,0x0,0x0,0xc,0x0,
0xc,0x0,
};

static BitmapCharRec ch247 = {10,9,(GLfloat)-1,(GLfloat)-2,(GLfloat)12,ch247data};

/* char: 246 */

static GLubyte ch246data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,0x0,0x0,0x0,0x0,0x33,0x0,0x33,0x0,
};

static BitmapCharRec ch246 = {10,16,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch246data};

/* char: 245 */

static GLubyte ch245data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,0x0,0x0,0x0,0x0,0x27,0x0,0x1c,0x80,
};

static BitmapCharRec ch245 = {10,16,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch245data};

/* char: 244 */

static GLubyte ch244data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,0x0,0x0,0x21,0x0,0x12,0x0,0x1e,0x0,
0xc,0x0,
};

static BitmapCharRec ch244 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch244data};

/* char: 243 */

static GLubyte ch243data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,0x0,0x0,0x8,0x0,0x6,0x0,0x3,0x80,
0x1,0x80,
};

static BitmapCharRec ch243 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch243data};

/* char: 242 */

static GLubyte ch242data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,0x0,0x0,0x2,0x0,0xc,0x0,0x38,0x0,
0x30,0x0,
};

static BitmapCharRec ch242 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch242data};

/* char: 241 */

static GLubyte ch241data[] = {
0xf1,0xe0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x71,0xc0,0x6f,0x80,0xe7,0x0,0x0,0x0,0x0,0x0,0x27,0x0,0x1c,0x80,
};

static BitmapCharRec ch241 = {11,16,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch241data};

/* char: 240 */

static GLubyte ch240data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1f,0x0,0xc6,0x0,0x3c,0x0,0x1e,0x0,0x71,0x80,
0xc0,0x0,
};

static BitmapCharRec ch240 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch240data};

/* char: 239 */

static GLubyte ch239data[] = {
0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x70,0x0,0x0,0xcc,0xcc,
};

static BitmapCharRec ch239 = {6,16,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch239data};

/* char: 238 */

static GLubyte ch238data[] = {
0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x70,0x0,0x84,0x48,0x78,
0x30,
};

static BitmapCharRec ch238 = {6,17,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch238data};

/* char: 237 */

static GLubyte ch237data[] = {
0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xe0,0x0,0x80,0x60,0x38,
0x18,
};

static BitmapCharRec ch237 = {5,17,(GLfloat)-1,(GLfloat)0,(GLfloat)6,ch237data};

/* char: 236 */

static GLubyte ch236data[] = {
0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x70,0x0,0x8,0x30,0xe0,
0xc0,
};

static BitmapCharRec ch236 = {5,17,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch236data};

/* char: 235 */

static GLubyte ch235data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xff,0x80,
0xc1,0x80,0x41,0x80,0x63,0x0,0x1e,0x0,0x0,0x0,0x0,0x0,0x33,0x0,0x33,0x0,
};

static BitmapCharRec ch235 = {9,16,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch235data};

/* char: 234 */

static GLubyte ch234data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xff,0x80,
0xc1,0x80,0x41,0x80,0x63,0x0,0x1e,0x0,0x0,0x0,0x21,0x0,0x12,0x0,0x1e,0x0,
0xc,0x0,
};

static BitmapCharRec ch234 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch234data};

/* char: 233 */

static GLubyte ch233data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xff,0x80,
0xc1,0x80,0x41,0x80,0x63,0x0,0x1e,0x0,0x0,0x0,0x10,0x0,0xc,0x0,0x7,0x0,
0x3,0x0,
};

static BitmapCharRec ch233 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch233data};

/* char: 232 */

static GLubyte ch232data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xff,0x80,
0xc1,0x80,0x41,0x80,0x63,0x0,0x1e,0x0,0x0,0x0,0x4,0x0,0x18,0x0,0x70,0x0,
0x60,0x0,
};

static BitmapCharRec ch232 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch232data};

/* char: 231 */

static GLubyte ch231data[] = {
0x3c,0x0,0x66,0x0,0x6,0x0,0x1e,0x0,0x18,0x0,0x8,0x0,0x1e,0x0,0x7f,0x0,
0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0x41,0x80,
0x63,0x80,0x1f,0x0,
};

static BitmapCharRec ch231 = {9,18,(GLfloat)-1,(GLfloat)6,(GLfloat)11,ch231data};

/* char: 230 */

static GLubyte ch230data[] = {
0x70,0xf0,0xfb,0xf8,0xc7,0x84,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0xfc,
0x3,0xc,0x63,0xc,0x67,0x98,0x3c,0xf0,
};

static BitmapCharRec ch230 = {14,12,(GLfloat)-1,(GLfloat)0,(GLfloat)16,ch230data};

/* char: 229 */

static GLubyte ch229data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x1c,0x0,0x22,0x0,0x22,0x0,
0x1c,0x0,
};

static BitmapCharRec ch229 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch229data};

/* char: 228 */

static GLubyte ch228data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x0,0x0,0x66,0x0,0x66,0x0,
};

static BitmapCharRec ch228 = {9,16,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch228data};

/* char: 227 */

static GLubyte ch227data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x0,0x0,0x5c,0x0,0x3a,0x0,
};

static BitmapCharRec ch227 = {9,16,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch227data};

/* char: 226 */

static GLubyte ch226data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x42,0x0,0x24,0x0,0x3c,0x0,
0x18,0x0,
};

static BitmapCharRec ch226 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch226data};

/* char: 225 */

static GLubyte ch225data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x10,0x0,0xc,0x0,0x7,0x0,
0x3,0x0,
};

static BitmapCharRec ch225 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch225data};

/* char: 224 */

static GLubyte ch224data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,0x0,0x0,0x4,0x0,0x18,0x0,0x70,0x0,
0x60,0x0,
};

static BitmapCharRec ch224 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch224data};

/* char: 223 */

static GLubyte ch223data[] = {
0xe7,0x0,0x6c,0x80,0x6c,0xc0,0x60,0xc0,0x60,0xc0,0x61,0xc0,0x61,0x80,0x63,0x80,
0x67,0x0,0x6c,0x0,0x63,0x0,0x61,0x80,0x61,0x80,0x61,0x80,0x61,0x80,0x33,0x0,
0x1e,0x0,
};

static BitmapCharRec ch223 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch223data};

/* char: 222 */

static GLubyte ch222data[] = {
0xfc,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x3f,0xc0,0x30,0x70,0x30,0x30,0x30,0x18,
0x30,0x18,0x30,0x18,0x30,0x30,0x30,0x70,0x3f,0xc0,0x30,0x0,0x30,0x0,0x30,0x0,
0xfc,0x0,
};

static BitmapCharRec ch222 = {13,17,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch222data};

/* char: 221 */

static GLubyte ch221data[] = {
0x7,0xe0,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x3,0xc0,
0x3,0x40,0x6,0x60,0x6,0x20,0xc,0x30,0x1c,0x10,0x18,0x18,0x38,0x8,0x30,0xc,
0xfc,0x3f,0x0,0x0,0x1,0x0,0x0,0xc0,0x0,0x70,0x0,0x30,
};

static BitmapCharRec ch221 = {16,22,(GLfloat)0,(GLfloat)0,(GLfloat)16,ch221data};

/* char: 220 */

static GLubyte ch220data[] = {
0x7,0xe0,0x1c,0x30,0x18,0x8,0x30,0x8,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0xfc,0x1f,0x0,0x0,0x0,0x0,0x6,0x30,0x6,0x30,
};

static BitmapCharRec ch220 = {16,21,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch220data};

/* char: 219 */

static GLubyte ch219data[] = {
0x7,0xe0,0x1c,0x30,0x18,0x8,0x30,0x8,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0xfc,0x1f,0x0,0x0,0x8,0x10,0x6,0x60,0x3,0xc0,0x1,0x80,
};

static BitmapCharRec ch219 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch219data};

/* char: 218 */

static GLubyte ch218data[] = {
0x7,0xe0,0x1c,0x30,0x18,0x8,0x30,0x8,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0xfc,0x1f,0x0,0x0,0x1,0x0,0x0,0xc0,0x0,0x70,0x0,0x30,
};

static BitmapCharRec ch218 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch218data};

/* char: 217 */

static GLubyte ch217data[] = {
0x7,0xe0,0x1c,0x30,0x18,0x8,0x30,0x8,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0xfc,0x1f,0x0,0x0,0x0,0x40,0x1,0x80,0x7,0x0,0x6,0x0,
};

static BitmapCharRec ch217 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch217data};

/* char: 216 */

static GLubyte ch216data[] = {
0x20,0x0,0x27,0xe0,0x1c,0x38,0x38,0x1c,0x68,0x6,0x64,0x6,0xc2,0x3,0xc2,0x3,
0xc1,0x3,0xc1,0x3,0xc0,0x83,0xc0,0x83,0xc0,0x43,0x60,0x46,0x60,0x26,0x38,0x1c,
0x1c,0x38,0x7,0xe4,0x0,0x4,
};

static BitmapCharRec ch216 = {16,19,(GLfloat)-1,(GLfloat)1,(GLfloat)18,ch216data};

/* char: 215 */

static GLubyte ch215data[] = {
0xc0,0xc0,0x61,0x80,0x33,0x0,0x1e,0x0,0xc,0x0,0x1e,0x0,0x33,0x0,0x61,0x80,
0xc0,0xc0,
};

static BitmapCharRec ch215 = {10,9,(GLfloat)-1,(GLfloat)-1,(GLfloat)12,ch215data};

/* char: 214 */

static GLubyte ch214data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,0x0,0x0,0x0,0x0,0x6,0x30,0x6,0x30,
};

static BitmapCharRec ch214 = {16,21,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch214data};

/* char: 213 */

static GLubyte ch213data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,0x0,0x0,0x0,0x0,0x4,0xe0,0x3,0x90,
};

static BitmapCharRec ch213 = {16,21,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch213data};

/* char: 212 */

static GLubyte ch212data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,0x0,0x0,0x8,0x10,0x6,0x60,0x3,0xc0,0x1,0x80,
};

static BitmapCharRec ch212 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch212data};

/* char: 211 */

static GLubyte ch211data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,0x0,0x0,0x1,0x0,0x0,0xc0,0x0,0x70,0x0,0x30,
};

static BitmapCharRec ch211 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch211data};

/* char: 210 */

static GLubyte ch210data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,0x0,0x0,0x0,0x40,0x1,0x80,0x7,0x0,0x6,0x0,
};

static BitmapCharRec ch210 = {16,22,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch210data};

/* char: 209 */

static GLubyte ch209data[] = {
0xf8,0xc,0x20,0x1c,0x20,0x1c,0x20,0x34,0x20,0x64,0x20,0x64,0x20,0xc4,0x21,0x84,
0x21,0x84,0x23,0x4,0x26,0x4,0x26,0x4,0x2c,0x4,0x38,0x4,0x38,0x4,0x30,0x4,
0xf0,0x1f,0x0,0x0,0x0,0x0,0x4,0xe0,0x3,0x90,
};

static BitmapCharRec ch209 = {16,21,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch209data};

/* char: 208 */

static GLubyte ch208data[] = {
0x7f,0xe0,0x18,0x38,0x18,0x1c,0x18,0x6,0x18,0x6,0x18,0x3,0x18,0x3,0x18,0x3,
0xff,0x3,0x18,0x3,0x18,0x3,0x18,0x3,0x18,0x6,0x18,0x6,0x18,0x1c,0x18,0x38,
0x7f,0xe0,
};

static BitmapCharRec ch208 = {16,17,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch208data};

/* char: 207 */

static GLubyte ch207data[] = {
0xfc,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0xfc,0x0,0x0,0xcc,0xcc,
};

static BitmapCharRec ch207 = {6,21,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch207data};

/* char: 206 */

static GLubyte ch206data[] = {
0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x7e,0x0,0x81,0x66,0x3c,0x18,
};

static BitmapCharRec ch206 = {8,22,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch206data};

/* char: 205 */

static GLubyte ch205data[] = {
0xfc,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0xfc,0x0,0x40,0x30,0x1c,0xc,
};

static BitmapCharRec ch205 = {6,22,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch205data};

/* char: 204 */

static GLubyte ch204data[] = {
0xfc,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0xfc,0x0,0x8,0x30,0xe0,0xc0,
};

static BitmapCharRec ch204 = {6,22,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch204data};

/* char: 203 */

static GLubyte ch203data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x40,0x30,0x40,
0x3f,0xc0,0x30,0x40,0x30,0x40,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,0x0,0x0,0x0,0x0,0x19,0x80,0x19,0x80,
};

static BitmapCharRec ch203 = {13,21,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch203data};

/* char: 202 */

static GLubyte ch202data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x40,0x30,0x40,
0x3f,0xc0,0x30,0x40,0x30,0x40,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,0x0,0x0,0x10,0x20,0xc,0xc0,0x7,0x80,0x3,0x0,
};

static BitmapCharRec ch202 = {13,22,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch202data};

/* char: 201 */

static GLubyte ch201data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x40,0x30,0x40,
0x3f,0xc0,0x30,0x40,0x30,0x40,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,0x0,0x0,0x4,0x0,0x3,0x0,0x1,0xc0,0x0,0xc0,
};

static BitmapCharRec ch201 = {13,22,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch201data};

/* char: 200 */

static GLubyte ch200data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x40,0x30,0x40,
0x3f,0xc0,0x30,0x40,0x30,0x40,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,0x0,0x0,0x1,0x0,0x6,0x0,0x1c,0x0,0x18,0x0,
};

static BitmapCharRec ch200 = {13,22,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch200data};

/* char: 199 */

static GLubyte ch199data[] = {
0x7,0x80,0xc,0xc0,0x0,0xc0,0x3,0xc0,0x3,0x0,0x1,0x0,0x7,0xe0,0x1e,0x38,
0x38,0x8,0x60,0x4,0x60,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,
0xc0,0x0,0xc0,0x0,0x60,0x4,0x60,0x4,0x38,0xc,0x1c,0x3c,0x7,0xe4,
};

static BitmapCharRec ch199 = {14,23,(GLfloat)-1,(GLfloat)6,(GLfloat)16,ch199data};

/* char: 198 */

static GLubyte ch198data[] = {
0xf9,0xff,0xf0,0x30,0x60,0x30,0x10,0x60,0x10,0x10,0x60,0x10,0x18,0x60,0x0,0x8,
0x60,0x0,0xf,0xe0,0x80,0xc,0x60,0x80,0x4,0x7f,0x80,0x4,0x60,0x80,0x6,0x60,
0x80,0x2,0x60,0x0,0x2,0x60,0x0,0x1,0x60,0x20,0x1,0x60,0x20,0x1,0xe0,0x60,
0x3,0xff,0xe0,
};

static BitmapCharRec ch198 = {20,17,(GLfloat)0,(GLfloat)0,(GLfloat)21,ch198data};

/* char: 197 */

static GLubyte ch197data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x1,0xc0,0x0,0x2,0x20,0x0,0x2,0x20,0x0,0x1,0xc0,0x0,
};

static BitmapCharRec ch197 = {17,21,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch197data};

/* char: 196 */

static GLubyte ch196data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x6,0x30,0x0,0x6,0x30,0x0,
};

static BitmapCharRec ch196 = {17,21,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch196data};

/* char: 195 */

static GLubyte ch195data[] = {
0xfc,0x1f,0x80,0x30,0x7,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0xe0,0x0,0x3,0x90,0x0,
};

static BitmapCharRec ch195 = {17,21,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch195data};

/* char: 194 */

static GLubyte ch194data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x8,0x10,0x0,0x6,0x60,0x0,0x3,0xc0,0x0,0x1,
0x80,0x0,
};

static BitmapCharRec ch194 = {17,22,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch194data};

/* char: 193 */

static GLubyte ch193data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0xc0,0x0,0x0,0x70,0x0,0x0,
0x30,0x0,
};

static BitmapCharRec ch193 = {17,22,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch193data};

/* char: 192 */

static GLubyte ch192data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0xc0,0x0,0x3,0x80,0x0,0x3,
0x0,0x0,
};

static BitmapCharRec ch192 = {17,22,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch192data};

/* char: 191 */

static GLubyte ch191data[] = {
0x3e,0x63,0xc1,0xc3,0xc3,0xe0,0x70,0x30,0x38,0x18,0x18,0x8,0x8,0x0,0x0,0xc,
0xc,
};

static BitmapCharRec ch191 = {8,17,(GLfloat)-1,(GLfloat)5,(GLfloat)11,ch191data};

/* char: 190 */

static GLubyte ch190data[] = {
0x18,0x2,0x0,0x8,0x2,0x0,0xc,0x7f,0x80,0x4,0x22,0x0,0x6,0x32,0x0,0x3,
0x12,0x0,0x1,0xa,0x0,0x71,0x8e,0x0,0x88,0x86,0x0,0x8c,0xc2,0x0,0xc,0x60,
0x0,0x8,0x20,0x0,0x30,0x30,0x0,0x8,0x10,0x0,0x8c,0x18,0x0,0x4c,0xc,0x0,
0x38,0x4,0x0,
};

static BitmapCharRec ch190 = {17,17,(GLfloat)0,(GLfloat)0,(GLfloat)18,ch190data};

/* char: 189 */

static GLubyte ch189data[] = {
0x30,0x7e,0x10,0x22,0x18,0x10,0x8,0x18,0xc,0x8,0x6,0x4,0x2,0x6,0xfb,0x46,
0x21,0x26,0x21,0x9c,0x20,0xc0,0x20,0x40,0x20,0x60,0x20,0x20,0xa0,0x30,0x60,0x18,
0x20,0x8,
};

static BitmapCharRec ch189 = {15,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch189data};

/* char: 188 */

static GLubyte ch188data[] = {
0x30,0x4,0x10,0x4,0x18,0xff,0x8,0x44,0xc,0x64,0x6,0x24,0x2,0x14,0xfb,0x1c,
0x21,0xc,0x21,0x84,0x20,0xc0,0x20,0x40,0x20,0x60,0x20,0x20,0xa0,0x30,0x60,0x18,
0x20,0x8,
};

static BitmapCharRec ch188 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch188data};

/* char: 187 */

static GLubyte ch187data[] = {
0x88,0x0,0xcc,0x0,0x66,0x0,0x33,0x0,0x19,0x80,0x19,0x80,0x33,0x0,0x66,0x0,
0xcc,0x0,0x88,0x0,
};

static BitmapCharRec ch187 = {9,10,(GLfloat)-2,(GLfloat)-1,(GLfloat)12,ch187data};

/* char: 186 */

static GLubyte ch186data[] = {
0xfc,0x0,0x78,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,
};

static BitmapCharRec ch186 = {6,9,(GLfloat)-1,(GLfloat)-8,(GLfloat)8,ch186data};

/* char: 185 */

static GLubyte ch185data[] = {
0xf8,0x20,0x20,0x20,0x20,0x20,0x20,0xa0,0x60,0x20,
};

static BitmapCharRec ch185 = {5,10,(GLfloat)-1,(GLfloat)-7,(GLfloat)7,ch185data};

/* char: 184 */

static GLubyte ch184data[] = {
0x78,0xcc,0xc,0x3c,0x30,0x10,
};

static BitmapCharRec ch184 = {6,6,(GLfloat)-1,(GLfloat)6,(GLfloat)8,ch184data};

/* char: 183 */

static GLubyte ch183data[] = {
0xc0,0xc0,
};

static BitmapCharRec ch183 = {2,2,(GLfloat)-1,(GLfloat)-6,(GLfloat)5,ch183data};

/* char: 182 */

static GLubyte ch182data[] = {
0x9,0x0,0x9,0x0,0x9,0x0,0x9,0x0,0x9,0x0,0x9,0x0,0x9,0x0,0x9,0x0,
0x9,0x0,0x9,0x0,0x9,0x0,0x19,0x0,0x39,0x0,0x79,0x0,0x79,0x0,0xf9,0x0,
0xf9,0x0,0xf9,0x0,0x79,0x0,0x79,0x0,0x39,0x0,0x1f,0x80,
};

static BitmapCharRec ch182 = {9,22,(GLfloat)-1,(GLfloat)5,(GLfloat)11,ch182data};

/* char: 181 */

static GLubyte ch181data[] = {
0x40,0x0,0xe0,0x0,0xc0,0x0,0x40,0x0,0x40,0x0,0x5c,0xe0,0x7e,0xc0,0x71,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0xe1,0xc0,
};

static BitmapCharRec ch181 = {11,17,(GLfloat)-1,(GLfloat)5,(GLfloat)13,ch181data};

/* char: 180 */

static GLubyte ch180data[] = {
0x80,0x60,0x38,0x18,
};

static BitmapCharRec ch180 = {5,4,(GLfloat)-2,(GLfloat)-13,(GLfloat)8,ch180data};

/* char: 179 */

static GLubyte ch179data[] = {
0x70,0x88,0x8c,0xc,0x8,0x30,0x8,0x8c,0x4c,0x38,
};

static BitmapCharRec ch179 = {6,10,(GLfloat)0,(GLfloat)-7,(GLfloat)7,ch179data};

/* char: 178 */

static GLubyte ch178data[] = {
0xfc,0x44,0x20,0x30,0x10,0x8,0xc,0x8c,0x4c,0x38,
};

static BitmapCharRec ch178 = {6,10,(GLfloat)0,(GLfloat)-7,(GLfloat)7,ch178data};

/* char: 177 */

static GLubyte ch177data[] = {
0xff,0xe0,0x0,0x0,0x4,0x0,0x4,0x0,0x4,0x0,0x4,0x0,0xff,0xe0,0x4,0x0,
0x4,0x0,0x4,0x0,0x4,0x0,
};

static BitmapCharRec ch177 = {11,11,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch177data};

/* char: 176 */

static GLubyte ch176data[] = {
0x38,0x44,0x82,0x82,0x82,0x44,0x38,
};

static BitmapCharRec ch176 = {7,7,(GLfloat)-1,(GLfloat)-10,(GLfloat)9,ch176data};

/* char: 175 */

static GLubyte ch175data[] = {
0xfc,0xfc,
};

static BitmapCharRec ch175 = {6,2,(GLfloat)-1,(GLfloat)-14,(GLfloat)8,ch175data};

/* char: 174 */

static GLubyte ch174data[] = {
0x7,0xf0,0x0,0x1c,0x1c,0x0,0x30,0x6,0x0,0x60,0x3,0x0,0x47,0x19,0x0,0xc2,
0x31,0x80,0x82,0x20,0x80,0x82,0x40,0x80,0x83,0xe0,0x80,0x82,0x30,0x80,0x82,0x10,
0x80,0xc2,0x11,0x80,0x42,0x31,0x0,0x67,0xe3,0x0,0x30,0x6,0x0,0x1c,0x1c,0x0,
0x7,0xf0,0x0,
};

static BitmapCharRec ch174 = {17,17,(GLfloat)-1,(GLfloat)0,(GLfloat)19,ch174data};

/* char: 173 */

static GLubyte ch173data[] = {
0xfe,
};

static BitmapCharRec ch173 = {7,1,(GLfloat)-1,(GLfloat)-6,(GLfloat)9,ch173data};

/* char: 172 */

static GLubyte ch172data[] = {
0x0,0x20,0x0,0x20,0x0,0x20,0x0,0x20,0x0,0x20,0x0,0x20,0xff,0xe0,
};

static BitmapCharRec ch172 = {11,7,(GLfloat)-2,(GLfloat)-2,(GLfloat)15,ch172data};

/* char: 171 */

static GLubyte ch171data[] = {
0x8,0x80,0x19,0x80,0x33,0x0,0x66,0x0,0xcc,0x0,0xcc,0x0,0x66,0x0,0x33,0x0,
0x19,0x80,0x8,0x80,
};

static BitmapCharRec ch171 = {9,10,(GLfloat)-2,(GLfloat)-1,(GLfloat)13,ch171data};

/* char: 170 */

static GLubyte ch170data[] = {
0x7e,0x0,0x76,0xcc,0xcc,0x7c,0xc,0xcc,0x78,
};

static BitmapCharRec ch170 = {7,9,(GLfloat)0,(GLfloat)-8,(GLfloat)8,ch170data};

/* char: 169 */

static GLubyte ch169data[] = {
0x7,0xf0,0x0,0x1c,0x1c,0x0,0x30,0x6,0x0,0x61,0xc3,0x0,0x47,0x71,0x0,0xc4,
0x19,0x80,0x8c,0x0,0x80,0x88,0x0,0x80,0x88,0x0,0x80,0x88,0x0,0x80,0x8c,0x0,
0x80,0xc4,0x19,0x80,0x47,0x31,0x0,0x61,0xe3,0x0,0x30,0x6,0x0,0x1c,0x1c,0x0,
0x7,0xf0,0x0,
};

static BitmapCharRec ch169 = {17,17,(GLfloat)-1,(GLfloat)0,(GLfloat)19,ch169data};

/* char: 168 */

static GLubyte ch168data[] = {
0xcc,0xcc,
};

static BitmapCharRec ch168 = {6,2,(GLfloat)-1,(GLfloat)-14,(GLfloat)8,ch168data};

/* char: 167 */

static GLubyte ch167data[] = {
0x38,0x64,0x62,0x6,0xe,0x1c,0x38,0x74,0xe2,0xc3,0x83,0x87,0x4e,0x3c,0x38,0x70,
0x60,0x46,0x26,0x1c,
};

static BitmapCharRec ch167 = {8,20,(GLfloat)-2,(GLfloat)2,(GLfloat)12,ch167data};

/* char: 166 */

static GLubyte ch166data[] = {
0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,
};

static BitmapCharRec ch166 = {2,17,(GLfloat)-2,(GLfloat)0,(GLfloat)6,ch166data};

/* char: 165 */

static GLubyte ch165data[] = {
0xf,0xc0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x1f,0xe0,0x3,0x0,0x1f,0xe0,
0x3,0x0,0x7,0x80,0xc,0x80,0xc,0xc0,0x18,0x40,0x18,0x60,0x30,0x20,0x70,0x30,
0xf8,0x7c,
};

static BitmapCharRec ch165 = {14,17,(GLfloat)0,(GLfloat)0,(GLfloat)14,ch165data};

/* char: 164 */

static GLubyte ch164data[] = {
0xc0,0x60,0xee,0xe0,0x7f,0xc0,0x31,0x80,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x31,0x80,0x7f,0xc0,0xee,0xe0,0xc0,0x60,
};

static BitmapCharRec ch164 = {11,12,(GLfloat)-1,(GLfloat)-3,(GLfloat)13,ch164data};

/* char: 163 */

static GLubyte ch163data[] = {
0xe7,0x80,0xbe,0xc0,0x78,0x40,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,
0x30,0x0,0xfc,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x31,0x80,0x19,0x80,
0xf,0x0,
};

static BitmapCharRec ch163 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch163data};

/* char: 162 */

static GLubyte ch162data[] = {
0x40,0x0,0x40,0x0,0x3e,0x0,0x7f,0x0,0x70,0x80,0xd0,0x0,0xc8,0x0,0xc8,0x0,
0xc8,0x0,0xc4,0x0,0xc4,0x0,0x43,0x80,0x63,0x80,0x1f,0x0,0x1,0x0,0x1,0x0,
};

static BitmapCharRec ch162 = {9,16,(GLfloat)-1,(GLfloat)2,(GLfloat)12,ch162data};

/* char: 161 */

static GLubyte ch161data[] = {
0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x0,0x0,0x0,0xc0,
0xc0,
};

static BitmapCharRec ch161 = {2,17,(GLfloat)-4,(GLfloat)5,(GLfloat)8,ch161data};

/* char: 126 '~' */

static GLubyte ch126data[] = {
0x83,0x80,0xc7,0xc0,0x7c,0x60,0x38,0x20,
};

static BitmapCharRec ch126 = {11,4,(GLfloat)-1,(GLfloat)-4,(GLfloat)13,ch126data};

/* char: 125 '}' */

static GLubyte ch125data[] = {
0xe0,0x30,0x18,0x18,0x18,0x18,0x18,0x18,0x8,0xc,0x4,0x3,0x4,0xc,0x8,0x18,
0x18,0x18,0x18,0x18,0x30,0xe0,
};

static BitmapCharRec ch125 = {8,22,(GLfloat)-1,(GLfloat)5,(GLfloat)10,ch125data};

/* char: 124 '|' */

static GLubyte ch124data[] = {
0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,
};

static BitmapCharRec ch124 = {2,17,(GLfloat)-2,(GLfloat)0,(GLfloat)6,ch124data};

/* char: 123 '{' */

static GLubyte ch123data[] = {
0x7,0xc,0x18,0x18,0x18,0x18,0x18,0x18,0x10,0x30,0x20,0xc0,0x20,0x30,0x10,0x18,
0x18,0x18,0x18,0x18,0xc,0x7,
};

static BitmapCharRec ch123 = {8,22,(GLfloat)-1,(GLfloat)5,(GLfloat)10,ch123data};

/* char: 122 'z' */

static GLubyte ch122data[] = {
0xff,0xc3,0x61,0x70,0x30,0x38,0x18,0x1c,0xe,0x86,0xc3,0xff,
};

static BitmapCharRec ch122 = {8,12,(GLfloat)-1,(GLfloat)0,(GLfloat)10,ch122data};

/* char: 121 'y' */

static GLubyte ch121data[] = {
0xe0,0x0,0xf0,0x0,0x18,0x0,0x8,0x0,0xc,0x0,0x4,0x0,0xe,0x0,0xe,0x0,
0x1a,0x0,0x19,0x0,0x19,0x0,0x31,0x0,0x30,0x80,0x30,0x80,0x60,0x80,0x60,0xc0,
0xf1,0xe0,
};

static BitmapCharRec ch121 = {11,17,(GLfloat)0,(GLfloat)5,(GLfloat)11,ch121data};

/* char: 120 'x' */

static GLubyte ch120data[] = {
0xf1,0xe0,0x60,0xc0,0x21,0x80,0x33,0x80,0x1b,0x0,0xe,0x0,0xc,0x0,0x1a,0x0,
0x39,0x0,0x31,0x80,0x60,0xc0,0xf1,0xe0,
};

static BitmapCharRec ch120 = {11,12,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch120data};

/* char: 119 'w' */

static GLubyte ch119data[] = {
0x4,0x10,0x0,0xe,0x38,0x0,0xe,0x38,0x0,0x1a,0x28,0x0,0x1a,0x64,0x0,0x19,
0x64,0x0,0x31,0x64,0x0,0x30,0xc2,0x0,0x30,0xc2,0x0,0x60,0xc2,0x0,0x60,0xc3,
0x0,0xf1,0xe7,0x80,
};

static BitmapCharRec ch119 = {17,12,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch119data};

/* char: 118 'v' */

static GLubyte ch118data[] = {
0x4,0x0,0xe,0x0,0xe,0x0,0x1a,0x0,0x19,0x0,0x19,0x0,0x31,0x0,0x30,0x80,
0x30,0x80,0x60,0x80,0x60,0xc0,0xf1,0xe0,
};

static BitmapCharRec ch118 = {11,12,(GLfloat)0,(GLfloat)0,(GLfloat)11,ch118data};

/* char: 117 'u' */

static GLubyte ch117data[] = {
0x1c,0xe0,0x3e,0xc0,0x71,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0xe1,0xc0,
};

static BitmapCharRec ch117 = {11,12,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch117data};

/* char: 116 't' */

static GLubyte ch116data[] = {
0x1c,0x32,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xfe,0x70,0x30,0x10,
};

static BitmapCharRec ch116 = {7,15,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch116data};

/* char: 115 's' */

static GLubyte ch115data[] = {
0xf8,0xc6,0x83,0x3,0x7,0x1e,0x7c,0x70,0xe0,0xc2,0x66,0x3e,
};

static BitmapCharRec ch115 = {8,12,(GLfloat)-1,(GLfloat)0,(GLfloat)10,ch115data};

/* char: 114 'r' */

static GLubyte ch114data[] = {
0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x76,0x6e,0xe6,
};

static BitmapCharRec ch114 = {7,12,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch114data};

/* char: 113 'q' */

static GLubyte ch113data[] = {
0x3,0xc0,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1d,0x80,0x73,0x80,0x61,0x80,
0xc1,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,0x61,0x80,0x73,0x80,
0x1d,0x80,
};

static BitmapCharRec ch113 = {10,17,(GLfloat)-1,(GLfloat)5,(GLfloat)12,ch113data};

/* char: 112 'p' */

static GLubyte ch112data[] = {
0xf0,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x6e,0x0,0x73,0x80,0x61,0x80,
0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x61,0x80,0x73,0x80,
0xee,0x0,
};

static BitmapCharRec ch112 = {10,17,(GLfloat)-1,(GLfloat)5,(GLfloat)12,ch112data};

/* char: 111 'o' */

static GLubyte ch111data[] = {
0x1e,0x0,0x73,0x80,0x61,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0x61,0x80,0x73,0x80,0x1e,0x0,
};

static BitmapCharRec ch111 = {10,12,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch111data};

/* char: 110 'n' */

static GLubyte ch110data[] = {
0xf1,0xe0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x71,0xc0,0x6f,0x80,0xe7,0x0,
};

static BitmapCharRec ch110 = {11,12,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch110data};

/* char: 109 'm' */

static GLubyte ch109data[] = {
0xf1,0xe3,0xc0,0x60,0xc1,0x80,0x60,0xc1,0x80,0x60,0xc1,0x80,0x60,0xc1,0x80,0x60,
0xc1,0x80,0x60,0xc1,0x80,0x60,0xc1,0x80,0x60,0xc1,0x80,0x71,0xe3,0x80,0x6f,0x9f,
0x0,0xe7,0xe,0x0,
};

static BitmapCharRec ch109 = {18,12,(GLfloat)-1,(GLfloat)0,(GLfloat)20,ch109data};

/* char: 108 'l' */

static GLubyte ch108data[] = {
0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,
0xe0,
};

static BitmapCharRec ch108 = {4,17,(GLfloat)-1,(GLfloat)0,(GLfloat)6,ch108data};

/* char: 107 'k' */

static GLubyte ch107data[] = {
0xf3,0xe0,0x61,0xc0,0x63,0x80,0x67,0x0,0x6e,0x0,0x6c,0x0,0x78,0x0,0x68,0x0,
0x64,0x0,0x66,0x0,0x63,0x0,0x67,0xc0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,
0xe0,0x0,
};

static BitmapCharRec ch107 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch107data};

/* char: 106 'j' */

static GLubyte ch106data[] = {
0xc0,0xe0,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0x70,0x0,0x0,0x0,0x30,0x30,
};

static BitmapCharRec ch106 = {4,22,(GLfloat)0,(GLfloat)5,(GLfloat)6,ch106data};

/* char: 105 'i' */

static GLubyte ch105data[] = {
0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0xe0,0x0,0x0,0x0,0x60,
0x60,
};

static BitmapCharRec ch105 = {4,17,(GLfloat)-1,(GLfloat)0,(GLfloat)6,ch105data};

/* char: 104 'h' */

static GLubyte ch104data[] = {
0xf1,0xe0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x71,0xc0,0x6f,0x80,0x67,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,
0xe0,0x0,
};

static BitmapCharRec ch104 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch104data};

/* char: 103 'g' */

static GLubyte ch103data[] = {
0x3f,0x0,0xf1,0xc0,0xc0,0x60,0xc0,0x20,0x60,0x60,0x3f,0xc0,0x7f,0x0,0x60,0x0,
0x30,0x0,0x3e,0x0,0x33,0x0,0x61,0x80,0x61,0x80,0x61,0x80,0x61,0x80,0x33,0x0,
0x1f,0xc0,
};

static BitmapCharRec ch103 = {11,17,(GLfloat)-1,(GLfloat)5,(GLfloat)12,ch103data};

/* char: 102 'f' */

static GLubyte ch102data[] = {
0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0xfe,0x30,0x30,0x30,0x16,
0xe,
};

static BitmapCharRec ch102 = {7,17,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch102data};

/* char: 101 'e' */

static GLubyte ch101data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xff,0x80,
0xc1,0x80,0x41,0x80,0x63,0x0,0x1e,0x0,
};

static BitmapCharRec ch101 = {9,12,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch101data};

/* char: 100 'd' */

static GLubyte ch100data[] = {
0x1e,0xc0,0x73,0x80,0x61,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,0xc1,0x80,
0xc1,0x80,0x61,0x80,0x73,0x80,0x1d,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,
0x3,0x80,
};

static BitmapCharRec ch100 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch100data};

/* char: 99 'c' */

static GLubyte ch99data[] = {
0x1e,0x0,0x7f,0x0,0x70,0x80,0xe0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,
0xc0,0x0,0x41,0x80,0x63,0x80,0x1f,0x0,
};

static BitmapCharRec ch99 = {9,12,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch99data};

/* char: 98 'b' */

static GLubyte ch98data[] = {
0x5e,0x0,0x73,0x80,0x61,0x80,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,0x60,0xc0,
0x60,0xc0,0x61,0x80,0x73,0x80,0x6e,0x0,0x60,0x0,0x60,0x0,0x60,0x0,0x60,0x0,
0xe0,0x0,
};

static BitmapCharRec ch98 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch98data};

/* char: 97 'a' */

static GLubyte ch97data[] = {
0x71,0x80,0xfb,0x0,0xc7,0x0,0xc3,0x0,0xc3,0x0,0x63,0x0,0x3b,0x0,0xf,0x0,
0x3,0x0,0x63,0x0,0x67,0x0,0x3e,0x0,
};

static BitmapCharRec ch97 = {9,12,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch97data};

/* char: 96 '`' */

static GLubyte ch96data[] = {
0x60,0xe0,0x80,0xc0,0x60,
};

static BitmapCharRec ch96 = {3,5,(GLfloat)-2,(GLfloat)-12,(GLfloat)7,ch96data};

/* char: 95 '_' */

static GLubyte ch95data[] = {
0xff,0xf8,
};

static BitmapCharRec ch95 = {13,1,(GLfloat)0,(GLfloat)5,(GLfloat)13,ch95data};

/* char: 94 '^' */

static GLubyte ch94data[] = {
0x80,0x80,0xc1,0x80,0x41,0x0,0x63,0x0,0x22,0x0,0x36,0x0,0x14,0x0,0x1c,0x0,
0x8,0x0,
};

static BitmapCharRec ch94 = {9,9,(GLfloat)-1,(GLfloat)-8,(GLfloat)11,ch94data};

/* char: 93 ']' */

static GLubyte ch93data[] = {
0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
0x18,0x18,0x18,0x18,0xf8,
};

static BitmapCharRec ch93 = {5,21,(GLfloat)-1,(GLfloat)4,(GLfloat)8,ch93data};

/* char: 92 '\' */

static GLubyte ch92data[] = {
0x6,0x6,0x4,0xc,0xc,0x8,0x18,0x18,0x10,0x30,0x30,0x20,0x60,0x60,0x40,0xc0,
0xc0,
};

static BitmapCharRec ch92 = {7,17,(GLfloat)0,(GLfloat)0,(GLfloat)7,ch92data};

/* char: 91 '[' */

static GLubyte ch91data[] = {
0xf8,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0xc0,0xc0,0xf8,
};

static BitmapCharRec ch91 = {5,21,(GLfloat)-2,(GLfloat)4,(GLfloat)8,ch91data};

/* char: 90 'Z' */

static GLubyte ch90data[] = {
0xff,0xf8,0xe0,0x18,0x70,0x8,0x30,0x8,0x38,0x0,0x18,0x0,0x1c,0x0,0xe,0x0,
0x6,0x0,0x7,0x0,0x3,0x0,0x3,0x80,0x1,0xc0,0x80,0xc0,0x80,0xe0,0xc0,0x70,
0xff,0xf0,
};

static BitmapCharRec ch90 = {13,17,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch90data};

/* char: 89 'Y' */

static GLubyte ch89data[] = {
0x7,0xe0,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x1,0x80,0x3,0xc0,
0x3,0x40,0x6,0x60,0x6,0x20,0xc,0x30,0x1c,0x10,0x18,0x18,0x38,0x8,0x30,0xc,
0xfc,0x3f,
};

static BitmapCharRec ch89 = {16,17,(GLfloat)0,(GLfloat)0,(GLfloat)16,ch89data};

/* char: 88 'X' */

static GLubyte ch88data[] = {
0xfc,0xf,0xc0,0x30,0x3,0x80,0x18,0x7,0x0,0x8,0xe,0x0,0x4,0xc,0x0,0x6,
0x18,0x0,0x2,0x38,0x0,0x1,0x70,0x0,0x0,0xe0,0x0,0x0,0xc0,0x0,0x1,0xc0,
0x0,0x3,0xa0,0x0,0x3,0x10,0x0,0x6,0x8,0x0,0xe,0xc,0x0,0x1c,0x6,0x0,
0x7e,0xf,0x80,
};

static BitmapCharRec ch88 = {18,17,(GLfloat)0,(GLfloat)0,(GLfloat)18,ch88data};

/* char: 87 'W' */

static GLubyte ch87data[] = {
0x1,0x83,0x0,0x1,0x83,0x0,0x1,0x83,0x80,0x3,0x87,0x80,0x3,0x46,0x80,0x3,
0x46,0xc0,0x6,0x46,0x40,0x6,0x4c,0x40,0x6,0x4c,0x60,0xc,0x2c,0x60,0xc,0x2c,
0x20,0x18,0x2c,0x20,0x18,0x18,0x30,0x18,0x18,0x10,0x30,0x18,0x10,0x30,0x18,0x18,
0xfc,0x7e,0x7e,
};

static BitmapCharRec ch87 = {23,17,(GLfloat)0,(GLfloat)0,(GLfloat)23,ch87data};

/* char: 86 'V' */

static GLubyte ch86data[] = {
0x1,0x80,0x0,0x1,0x80,0x0,0x1,0x80,0x0,0x3,0xc0,0x0,0x3,0x40,0x0,0x3,
0x60,0x0,0x6,0x20,0x0,0x6,0x20,0x0,0x6,0x30,0x0,0xc,0x10,0x0,0xc,0x18,
0x0,0x18,0x8,0x0,0x18,0x8,0x0,0x18,0xc,0x0,0x30,0x4,0x0,0x30,0x6,0x0,
0xfc,0x1f,0x80,
};

static BitmapCharRec ch86 = {17,17,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch86data};

/* char: 85 'U' */

static GLubyte ch85data[] = {
0x7,0xe0,0x1c,0x30,0x18,0x8,0x30,0x8,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,0x30,0x4,
0xfc,0x1f,
};

static BitmapCharRec ch85 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch85data};

/* char: 84 'T' */

static GLubyte ch84data[] = {
0xf,0xc0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,
0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0x83,0x4,0x83,0x4,0xc3,0xc,
0xff,0xfc,
};

static BitmapCharRec ch84 = {14,17,(GLfloat)-1,(GLfloat)0,(GLfloat)16,ch84data};

/* char: 83 'S' */

static GLubyte ch83data[] = {
0x9e,0x0,0xf1,0x80,0xc0,0xc0,0x80,0x60,0x80,0x60,0x0,0x60,0x0,0xe0,0x3,0xc0,
0xf,0x80,0x1e,0x0,0x78,0x0,0xe0,0x0,0xc0,0x40,0xc0,0x40,0xc0,0xc0,0x63,0xc0,
0x1e,0x40,
};

static BitmapCharRec ch83 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch83data};

/* char: 82 'R' */

static GLubyte ch82data[] = {
0xfc,0x1e,0x30,0x1c,0x30,0x38,0x30,0x70,0x30,0x60,0x30,0xc0,0x31,0xc0,0x33,0x80,
0x3f,0xc0,0x30,0x70,0x30,0x30,0x30,0x38,0x30,0x18,0x30,0x38,0x30,0x30,0x30,0x70,
0xff,0xc0,
};

static BitmapCharRec ch82 = {15,17,(GLfloat)-1,(GLfloat)0,(GLfloat)16,ch82data};

/* char: 81 'Q' */

static GLubyte ch81data[] = {
0x0,0xf,0x0,0x38,0x0,0x70,0x0,0xe0,0x1,0xc0,0x7,0xe0,0x1c,0x38,0x38,0x1c,
0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,0x7,0xe0,
};

static BitmapCharRec ch81 = {16,22,(GLfloat)-1,(GLfloat)5,(GLfloat)18,ch81data};

/* char: 80 'P' */

static GLubyte ch80data[] = {
0xfc,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,
0x3f,0xc0,0x30,0x70,0x30,0x30,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x30,0x30,0x70,
0xff,0xc0,
};

static BitmapCharRec ch80 = {13,17,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch80data};

/* char: 79 'O' */

static GLubyte ch79data[] = {
0x7,0xe0,0x1c,0x38,0x38,0x1c,0x60,0x6,0x60,0x6,0xc0,0x3,0xc0,0x3,0xc0,0x3,
0xc0,0x3,0xc0,0x3,0xc0,0x3,0xc0,0x3,0x60,0x6,0x60,0x6,0x38,0x1c,0x1c,0x38,
0x7,0xe0,
};

static BitmapCharRec ch79 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch79data};

/* char: 78 'N' */

static GLubyte ch78data[] = {
0xf8,0xc,0x20,0x1c,0x20,0x1c,0x20,0x34,0x20,0x64,0x20,0x64,0x20,0xc4,0x21,0x84,
0x21,0x84,0x23,0x4,0x26,0x4,0x26,0x4,0x2c,0x4,0x38,0x4,0x38,0x4,0x30,0x4,
0xf0,0x1f,
};

static BitmapCharRec ch78 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch78data};

/* char: 77 'M' */

static GLubyte ch77data[] = {
0xf8,0x21,0xf8,0x20,0x60,0x60,0x20,0x60,0x60,0x20,0xd0,0x60,0x20,0xd0,0x60,0x21,
0x88,0x60,0x21,0x88,0x60,0x23,0x8,0x60,0x23,0x4,0x60,0x26,0x4,0x60,0x26,0x2,
0x60,0x2c,0x2,0x60,0x2c,0x2,0x60,0x38,0x1,0x60,0x38,0x1,0x60,0x30,0x0,0xe0,
0xf0,0x0,0xf8,
};

static BitmapCharRec ch77 = {21,17,(GLfloat)-1,(GLfloat)0,(GLfloat)22,ch77data};

/* char: 76 'L' */

static GLubyte ch76data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,
0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,
0xfc,0x0,
};

static BitmapCharRec ch76 = {13,17,(GLfloat)-1,(GLfloat)0,(GLfloat)14,ch76data};

/* char: 75 'K' */

static GLubyte ch75data[] = {
0xfc,0x1f,0x30,0xe,0x30,0x1c,0x30,0x38,0x30,0x70,0x30,0xe0,0x31,0xc0,0x33,0x80,
0x3f,0x0,0x3e,0x0,0x33,0x0,0x31,0x80,0x30,0xc0,0x30,0x60,0x30,0x30,0x30,0x18,
0xfc,0x7e,
};

static BitmapCharRec ch75 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)17,ch75data};

/* char: 74 'J' */

static GLubyte ch74data[] = {
0x78,0x0,0xcc,0x0,0xc6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,
0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,0x6,0x0,
0x1f,0x80,
};

static BitmapCharRec ch74 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)11,ch74data};

/* char: 73 'I' */

static GLubyte ch73data[] = {
0xfc,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,
0xfc,
};

static BitmapCharRec ch73 = {6,17,(GLfloat)-1,(GLfloat)0,(GLfloat)8,ch73data};

/* char: 72 'H' */

static GLubyte ch72data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x30,
0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x3f,0xfe,0x0,0x30,0x6,0x0,0x30,0x6,
0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,0x30,0x6,0x0,
0xfc,0x1f,0x80,
};

static BitmapCharRec ch72 = {17,17,(GLfloat)-1,(GLfloat)0,(GLfloat)19,ch72data};

/* char: 71 'G' */

static GLubyte ch71data[] = {
0x7,0xe0,0x1e,0x38,0x38,0x1c,0x60,0xc,0x60,0xc,0xc0,0xc,0xc0,0xc,0xc0,0x3f,
0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0x60,0x4,0x60,0x4,0x38,0xc,0x1c,0x3c,
0x7,0xe4,
};

static BitmapCharRec ch71 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch71data};

/* char: 70 'F' */

static GLubyte ch70data[] = {
0xfc,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x0,0x30,0x20,0x30,0x20,
0x3f,0xe0,0x30,0x20,0x30,0x20,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,
};

static BitmapCharRec ch70 = {12,17,(GLfloat)-1,(GLfloat)0,(GLfloat)14,ch70data};

/* char: 69 'E' */

static GLubyte ch69data[] = {
0xff,0xf8,0x30,0x18,0x30,0x8,0x30,0x8,0x30,0x0,0x30,0x0,0x30,0x40,0x30,0x40,
0x3f,0xc0,0x30,0x40,0x30,0x40,0x30,0x0,0x30,0x0,0x30,0x10,0x30,0x10,0x30,0x30,
0xff,0xf0,
};

static BitmapCharRec ch69 = {13,17,(GLfloat)-1,(GLfloat)0,(GLfloat)15,ch69data};

/* char: 68 'D' */

static GLubyte ch68data[] = {
0xff,0xc0,0x30,0x70,0x30,0x38,0x30,0xc,0x30,0xc,0x30,0x6,0x30,0x6,0x30,0x6,
0x30,0x6,0x30,0x6,0x30,0x6,0x30,0x6,0x30,0xc,0x30,0xc,0x30,0x38,0x30,0x70,
0xff,0xc0,
};

static BitmapCharRec ch68 = {15,17,(GLfloat)-1,(GLfloat)0,(GLfloat)17,ch68data};

/* char: 67 'C' */

static GLubyte ch67data[] = {
0x7,0xe0,0x1e,0x38,0x38,0x8,0x60,0x4,0x60,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,
0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0x60,0x4,0x60,0x4,0x38,0xc,0x1c,0x3c,
0x7,0xe4,
};

static BitmapCharRec ch67 = {14,17,(GLfloat)-1,(GLfloat)0,(GLfloat)16,ch67data};

/* char: 66 'B' */

static GLubyte ch66data[] = {
0xff,0xe0,0x30,0x78,0x30,0x18,0x30,0xc,0x30,0xc,0x30,0xc,0x30,0x18,0x30,0x38,
0x3f,0xe0,0x30,0x40,0x30,0x30,0x30,0x18,0x30,0x18,0x30,0x18,0x30,0x30,0x30,0x70,
0xff,0xc0,
};

static BitmapCharRec ch66 = {14,17,(GLfloat)-1,(GLfloat)0,(GLfloat)16,ch66data};

/* char: 65 'A' */

static GLubyte ch65data[] = {
0xfc,0x1f,0x80,0x30,0x6,0x0,0x10,0x6,0x0,0x10,0xc,0x0,0x18,0xc,0x0,0x8,
0xc,0x0,0xf,0xf8,0x0,0xc,0x18,0x0,0x4,0x18,0x0,0x4,0x30,0x0,0x6,0x30,
0x0,0x2,0x30,0x0,0x2,0x60,0x0,0x1,0x60,0x0,0x1,0xc0,0x0,0x1,0xc0,0x0,
0x0,0x80,0x0,
};

static BitmapCharRec ch65 = {17,17,(GLfloat)0,(GLfloat)0,(GLfloat)17,ch65data};

/* char: 64 '@' */

static GLubyte ch64data[] = {
0x3,0xf0,0x0,0xe,0xc,0x0,0x18,0x0,0x0,0x30,0x0,0x0,0x61,0xde,0x0,0x63,
0x7b,0x0,0xc6,0x39,0x80,0xc6,0x18,0x80,0xc6,0x18,0xc0,0xc6,0x18,0x40,0xc6,0xc,
0x40,0xc3,0xc,0x40,0xc3,0x8c,0x40,0xe1,0xfc,0x40,0x60,0xec,0xc0,0x70,0x0,0x80,
0x38,0x1,0x80,0x1c,0x3,0x0,0xf,0xe,0x0,0x3,0xf8,0x0,
};

static BitmapCharRec ch64 = {18,20,(GLfloat)-2,(GLfloat)3,(GLfloat)22,ch64data};

/* char: 63 '?' */

static GLubyte ch63data[] = {
0x30,0x30,0x0,0x0,0x10,0x10,0x10,0x18,0x18,0xc,0xe,0x7,0xc3,0xc3,0x83,0xc6,
0x7c,
};

static BitmapCharRec ch63 = {8,17,(GLfloat)-2,(GLfloat)0,(GLfloat)11,ch63data};

/* char: 62 '>' */

static GLubyte ch62data[] = {
0xc0,0x0,0x70,0x0,0x1c,0x0,0x7,0x0,0x1,0xc0,0x0,0x60,0x1,0xc0,0x7,0x0,
0x1c,0x0,0x70,0x0,0xc0,0x0,
};

static BitmapCharRec ch62 = {11,11,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch62data};

/* char: 61 '=' */

static GLubyte ch61data[] = {
0xff,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0xff,0x80,
};

static BitmapCharRec ch61 = {9,5,(GLfloat)-2,(GLfloat)-4,(GLfloat)13,ch61data};

/* char: 60 '<' */

static GLubyte ch60data[] = {
0x0,0x60,0x1,0xc0,0x7,0x0,0x1c,0x0,0x70,0x0,0xc0,0x0,0x70,0x0,0x1c,0x0,
0x7,0x0,0x1,0xc0,0x0,0x60,
};

static BitmapCharRec ch60 = {11,11,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch60data};

/* char: 59 ';' */

static GLubyte ch59data[] = {
0xc0,0x60,0x20,0xe0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0xc0,
};

static BitmapCharRec ch59 = {3,14,(GLfloat)-2,(GLfloat)3,(GLfloat)7,ch59data};

/* char: 58 ':' */

static GLubyte ch58data[] = {
0xc0,0xc0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc0,0xc0,
};

static BitmapCharRec ch58 = {2,11,(GLfloat)-2,(GLfloat)0,(GLfloat)6,ch58data};

/* char: 57 '9' */

static GLubyte ch57data[] = {
0xf0,0x0,0x1c,0x0,0x6,0x0,0x3,0x0,0x3,0x80,0x1,0x80,0x1d,0x80,0x73,0xc0,
0x61,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc1,0xc0,0x61,0x80,0x77,0x80,
0x1e,0x0,
};

static BitmapCharRec ch57 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch57data};

/* char: 56 '8' */

static GLubyte ch56data[] = {
0x1e,0x0,0x73,0x80,0xe1,0x80,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x41,0xc0,0x61,0x80,
0x37,0x0,0x1e,0x0,0x1e,0x0,0x33,0x0,0x61,0x80,0x61,0x80,0x61,0x80,0x33,0x0,
0x1e,0x0,
};

static BitmapCharRec ch56 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch56data};

/* char: 55 '7' */

static GLubyte ch55data[] = {
0x18,0x0,0x18,0x0,0xc,0x0,0xc,0x0,0xc,0x0,0x4,0x0,0x6,0x0,0x6,0x0,
0x2,0x0,0x3,0x0,0x3,0x0,0x1,0x0,0x1,0x80,0x81,0x80,0xc0,0xc0,0xff,0xc0,
0x7f,0xc0,
};

static BitmapCharRec ch55 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch55data};

/* char: 54 '6' */

static GLubyte ch54data[] = {
0x1e,0x0,0x7b,0x80,0x61,0x80,0xe0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc1,0x80,0xf3,0x80,0xee,0x0,0x60,0x0,0x70,0x0,0x30,0x0,0x18,0x0,0xe,0x0,
0x3,0xc0,
};

static BitmapCharRec ch54 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch54data};

/* char: 53 '5' */

static GLubyte ch53data[] = {
0x7e,0x0,0xe3,0x80,0xc1,0x80,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x0,0xc0,0x1,0xc0,
0x3,0x80,0xf,0x80,0x7e,0x0,0x78,0x0,0x60,0x0,0x20,0x0,0x20,0x0,0x1f,0x80,
0x1f,0xc0,
};

static BitmapCharRec ch53 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch53data};

/* char: 52 '4' */

static GLubyte ch52data[] = {
0x3,0x0,0x3,0x0,0x3,0x0,0x3,0x0,0xff,0xc0,0xff,0xc0,0xc3,0x0,0x43,0x0,
0x63,0x0,0x23,0x0,0x33,0x0,0x13,0x0,0x1b,0x0,0xb,0x0,0x7,0x0,0x7,0x0,
0x3,0x0,
};

static BitmapCharRec ch52 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch52data};

/* char: 51 '3' */

static GLubyte ch51data[] = {
0x78,0x0,0xe6,0x0,0xc3,0x0,0x1,0x0,0x1,0x80,0x1,0x80,0x1,0x80,0x3,0x80,
0x7,0x0,0x1e,0x0,0xc,0x0,0x6,0x0,0x83,0x0,0x83,0x0,0x47,0x0,0x7e,0x0,
0x1c,0x0,
};

static BitmapCharRec ch51 = {9,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch51data};

/* char: 50 '2' */

static GLubyte ch50data[] = {
0xff,0x80,0xff,0xc0,0x60,0x40,0x30,0x0,0x18,0x0,0xc,0x0,0x4,0x0,0x6,0x0,
0x3,0x0,0x3,0x0,0x1,0x80,0x1,0x80,0x81,0x80,0x81,0x80,0x43,0x80,0x7f,0x0,
0x1c,0x0,
};

static BitmapCharRec ch50 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch50data};

/* char: 49 '1' */

static GLubyte ch49data[] = {
0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x78,0x18,
0x8,
};

static BitmapCharRec ch49 = {8,17,(GLfloat)-2,(GLfloat)0,(GLfloat)12,ch49data};

/* char: 48 '0' */

static GLubyte ch48data[] = {
0x1e,0x0,0x33,0x0,0x61,0x80,0x61,0x80,0xe1,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x61,0x80,0x61,0x80,0x33,0x0,
0x1e,0x0,
};

static BitmapCharRec ch48 = {10,17,(GLfloat)-1,(GLfloat)0,(GLfloat)12,ch48data};

/* char: 47 '/' */

static GLubyte ch47data[] = {
0xc0,0xc0,0xc0,0x60,0x60,0x20,0x30,0x30,0x10,0x18,0x18,0x8,0xc,0xc,0x4,0x6,
0x6,0x3,0x3,0x3,
};

static BitmapCharRec ch47 = {8,20,(GLfloat)1,(GLfloat)3,(GLfloat)7,ch47data};

/* char: 46 '.' */

static GLubyte ch46data[] = {
0xc0,0xc0,
};

static BitmapCharRec ch46 = {2,2,(GLfloat)-2,(GLfloat)0,(GLfloat)6,ch46data};

/* char: 45 '-' */

static GLubyte ch45data[] = {
0xff,0xe0,
};

static BitmapCharRec ch45 = {11,1,(GLfloat)-2,(GLfloat)-6,(GLfloat)15,ch45data};

/* char: 44 ',' */

static GLubyte ch44data[] = {
0xc0,0x60,0x20,0xe0,0xc0,
};

static BitmapCharRec ch44 = {3,5,(GLfloat)-2,(GLfloat)3,(GLfloat)7,ch44data};

/* char: 43 '+' */

static GLubyte ch43data[] = {
0x4,0x0,0x4,0x0,0x4,0x0,0x4,0x0,0x4,0x0,0xff,0xe0,0x4,0x0,0x4,0x0,
0x4,0x0,0x4,0x0,0x4,0x0,
};

static BitmapCharRec ch43 = {11,11,(GLfloat)-1,(GLfloat)-1,(GLfloat)12,ch43data};

/* char: 42 '*' */

static GLubyte ch42data[] = {
0x8,0x0,0x1c,0x0,0xc9,0x80,0xeb,0x80,0x1c,0x0,0xeb,0x80,0xc9,0x80,0x1c,0x0,
0x8,0x0,
};

static BitmapCharRec ch42 = {9,9,(GLfloat)-2,(GLfloat)-8,(GLfloat)12,ch42data};

/* char: 41 ')' */

static GLubyte ch41data[] = {
0x80,0x40,0x20,0x30,0x10,0x18,0x18,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0xc,0x18,
0x18,0x10,0x30,0x20,0x40,0x80,
};

static BitmapCharRec ch41 = {6,22,(GLfloat)-1,(GLfloat)5,(GLfloat)8,ch41data};

/* char: 40 '(' */

static GLubyte ch40data[] = {
0x4,0x8,0x10,0x30,0x20,0x60,0x60,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0x60,
0x60,0x20,0x30,0x10,0x8,0x4,
};

static BitmapCharRec ch40 = {6,22,(GLfloat)-1,(GLfloat)5,(GLfloat)8,ch40data};

/* char: 39 ''' */

static GLubyte ch39data[] = {
0xc0,0x60,0x20,0xe0,0xc0,
};

static BitmapCharRec ch39 = {3,5,(GLfloat)-3,(GLfloat)-12,(GLfloat)8,ch39data};

/* char: 38 '&' */

static GLubyte ch38data[] = {
0x3c,0x3c,0x7f,0x7e,0xe1,0xe1,0xc0,0xc0,0xc1,0xc0,0xc1,0xa0,0x63,0x20,0x37,0x10,
0x1e,0x18,0xe,0x3e,0xf,0x0,0x1d,0x80,0x18,0xc0,0x18,0x40,0x18,0x40,0xc,0xc0,
0x7,0x80,
};

static BitmapCharRec ch38 = {16,17,(GLfloat)-1,(GLfloat)0,(GLfloat)18,ch38data};

/* char: 37 '%' */

static GLubyte ch37data[] = {
0x30,0x3c,0x0,0x18,0x72,0x0,0xc,0x61,0x0,0x4,0x60,0x80,0x6,0x60,0x80,0x3,
0x30,0x80,0x1,0x19,0x80,0x1,0x8f,0x0,0x78,0xc0,0x0,0xe4,0x40,0x0,0xc2,0x60,
0x0,0xc1,0x30,0x0,0xc1,0x10,0x0,0x61,0x18,0x0,0x33,0xfc,0x0,0x1e,0xc,0x0,
};

static BitmapCharRec ch37 = {17,16,(GLfloat)-1,(GLfloat)0,(GLfloat)19,ch37data};

/* char: 36 '$' */

static GLubyte ch36data[] = {
0x4,0x0,0x4,0x0,0x3f,0x0,0xe5,0xc0,0xc4,0xc0,0x84,0x60,0x84,0x60,0x4,0x60,
0x4,0xe0,0x7,0xc0,0x7,0x80,0x1e,0x0,0x3c,0x0,0x74,0x0,0x64,0x0,0x64,0x20,
0x64,0x60,0x34,0xe0,0x1f,0x80,0x4,0x0,0x4,0x0,
};

static BitmapCharRec ch36 = {11,21,(GLfloat)0,(GLfloat)2,(GLfloat)12,ch36data};

/* char: 35 '#' */

static GLubyte ch35data[] = {
0x22,0x0,0x22,0x0,0x22,0x0,0x22,0x0,0x22,0x0,0xff,0xc0,0xff,0xc0,0x11,0x0,
0x11,0x0,0x11,0x0,0x7f,0xe0,0x7f,0xe0,0x8,0x80,0x8,0x80,0x8,0x80,0x8,0x80,
0x8,0x80,
};

static BitmapCharRec ch35 = {11,17,(GLfloat)-1,(GLfloat)0,(GLfloat)13,ch35data};

/* char: 34 '"' */

static GLubyte ch34data[] = {
0x88,0xcc,0xcc,0xcc,0xcc,
};

static BitmapCharRec ch34 = {6,5,(GLfloat)-1,(GLfloat)-12,(GLfloat)10,ch34data};

/* char: 33 '!' */

static GLubyte ch33data[] = {
0xc0,0xc0,0x0,0x0,0x0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,0xc0,
0xc0,
};

static BitmapCharRec ch33 = {2,17,(GLfloat)-3,(GLfloat)0,(GLfloat)8,ch33data};

/* char: 32 ' ' */

static GLubyte ch32data[] = {
0x0,
};

static BitmapCharRec ch32 = {1,1,(GLfloat)0,(GLfloat)0,(GLfloat)6,ch32data};

static BitmapCharPtr chars[] = {
&ch32,
&ch33,
&ch34,
&ch35,
&ch36,
&ch37,
&ch38,
&ch39,
&ch40,
&ch41,
&ch42,
&ch43,
&ch44,
&ch45,
&ch46,
&ch47,
&ch48,
&ch49,
&ch50,
&ch51,
&ch52,
&ch53,
&ch54,
&ch55,
&ch56,
&ch57,
&ch58,
&ch59,
&ch60,
&ch61,
&ch62,
&ch63,
&ch64,
&ch65,
&ch66,
&ch67,
&ch68,
&ch69,
&ch70,
&ch71,
&ch72,
&ch73,
&ch74,
&ch75,
&ch76,
&ch77,
&ch78,
&ch79,
&ch80,
&ch81,
&ch82,
&ch83,
&ch84,
&ch85,
&ch86,
&ch87,
&ch88,
&ch89,
&ch90,
&ch91,
&ch92,
&ch93,
&ch94,
&ch95,
&ch96,
&ch97,
&ch98,
&ch99,
&ch100,
&ch101,
&ch102,
&ch103,
&ch104,
&ch105,
&ch106,
&ch107,
&ch108,
&ch109,
&ch110,
&ch111,
&ch112,
&ch113,
&ch114,
&ch115,
&ch116,
&ch117,
&ch118,
&ch119,
&ch120,
&ch121,
&ch122,
&ch123,
&ch124,
&ch125,
&ch126,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
&ch161,
&ch162,
&ch163,
&ch164,
&ch165,
&ch166,
&ch167,
&ch168,
&ch169,
&ch170,
&ch171,
&ch172,
&ch173,
&ch174,
&ch175,
&ch176,
&ch177,
&ch178,
&ch179,
&ch180,
&ch181,
&ch182,
&ch183,
&ch184,
&ch185,
&ch186,
&ch187,
&ch188,
&ch189,
&ch190,
&ch191,
&ch192,
&ch193,
&ch194,
&ch195,
&ch196,
&ch197,
&ch198,
&ch199,
&ch200,
&ch201,
&ch202,
&ch203,
&ch204,
&ch205,
&ch206,
&ch207,
&ch208,
&ch209,
&ch210,
&ch211,
&ch212,
&ch213,
&ch214,
&ch215,
&ch216,
&ch217,
&ch218,
&ch219,
&ch220,
&ch221,
&ch222,
&ch223,
&ch224,
&ch225,
&ch226,
&ch227,
&ch228,
&ch229,
&ch230,
&ch231,
&ch232,
&ch233,
&ch234,
&ch235,
&ch236,
&ch237,
&ch238,
&ch239,
&ch240,
&ch241,
&ch242,
&ch243,
&ch244,
&ch245,
&ch246,
&ch247,
&ch248,
&ch249,
&ch250,
&ch251,
&ch252,
&ch253,
&ch254,
&ch255,
};

BitmapFontRec glutBitmapTimesRoman24 = {
"-adobe-times-medium-r-normal--24-240-75-75-p-124-iso8859-1",
224,
32,
chars
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\stroke.h ===
/* $XConsortium: wfont.h,v 5.1 91/02/16 09:46:37 rws Exp $ */

/*****************************************************************
Copyright (c) 1989,1990, 1991 by Sun Microsystems, Inc. and the X Consortium.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its 
documentation for any purpose and without fee is hereby granted, 
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in 
supporting documentation, and that the names of Sun Microsystems,
the X Consortium, and MIT not be used in advertising or publicity 
pertaining to distribution of the software without specific, written 
prior permission.  

SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, 
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT 
SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL 
DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef WFONT_INCLUDED
#define WFONT_INCLUDED

#define WFONT_MAGIC	0x813
#define WFONT_MAGIC_PLUS 0x715
#define WFONT_MAGIC_PEX 0x70686e74
#define START_PROPS 0x100
#define START_DISPATCH(_num_props)  (START_PROPS + 160 * _num_props)
#define START_PATH(_num_ch_, _num_props)  (START_DISPATCH(_num_props) + sizeof(Dispatch) * _num_ch_)
#define NUM_DISPATCH	128

typedef struct {
  unsigned short x;
  unsigned short y;
} Path_point2dpx;

typedef struct {
  float x;
  float y;
} Path_point2df;

typedef struct {
  int x;
  int y;
  int z;
} Path_point3di;

typedef struct {
  float x;
  float y;
  float z;
} Path_point3df;

typedef struct {
  float x;
  float y;
  float z;
  float w;
} Path_point4df;

typedef union {
  Path_point2dpx *pt2dpx;
  Path_point2df *pt2df;
  Path_point3di *pt3di;
  Path_point3df *pt3df;
  Path_point4df *pt4df;
} Path_pt_ptr;

typedef enum {
  PATH_2DF,
  PATH_2DPX,
  PATH_3DF,
  PATH_3DI,
  PATH_4DF
} Path_type;

typedef struct {
  int n_pts;                    /* number of points in the subpath */
  Path_pt_ptr pts;              /* pointer to them */
  int closed;                   /* true if the subpath is closed */
  int dcmp_flag;                /* flag for pgon dcmp, pgon type 
                                 * and dcmped triangle type */
} Path_subpath;

typedef struct {
  Path_type type;               /* type of vertices in this path */
  int n_subpaths;               /* number of subpaths */
  int n_vertices;               /* total number of vertices */
  Path_subpath *subpaths;       /* array of subpaths */
} Path;

typedef Path *Path_handle;

typedef struct {
  char propname[80];            /* font property name */
  char propvalue[80];           /* font property value */
} Property;

typedef struct {
  int magic;                    /* magic number */
  char name[80];                /* name of this font */
  float top,                    /* extreme values */
    bottom, max_width;
  int num_ch;                   /* no. of fonts in the set */
  int num_props;                /* no. of font properties */
  Property *properties;         /* array of properties */
} Font_header;

typedef struct {
  float center,                 /* center of the character */
    right;                      /* right edge */
  long offset;                  /* offset in the file of the character
                                 * * description */
} Dispatch;

typedef struct {
  float center, right;
  Path strokes;
} Ch_font;

typedef struct {
  char name[80];
  float top, bottom, max_width;
  int num_ch;                   /* # characters in the font */
  Ch_font **ch_data;
} Phg_font;

#endif /*WFONT_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\layrutil.c ===
/* Copyright (c) Mark J. Kilgard, 1993, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

/* Based on XLayerUtil.c: Revision: 1.5 */

#include <stdio.h>
#include <stdlib.h>
#include "layrutil.h"

static Bool layersRead;
static Atom overlayVisualsAtom;
static OverlayInfo **overlayInfoPerScreen;
static int *numOverlaysPerScreen;

XLayerVisualInfo *
__glutXGetLayerVisualInfo(Display * display, long lvinfo_mask,
  XLayerVisualInfo * lvinfo_template, int *nitems_return)
{
  XVisualInfo *vinfo;
  XLayerVisualInfo *layerInfo;
  Window root;
  Status status;
  Atom actualType;
  unsigned long sizeData, bytesLeft;
  int actualFormat, numVisuals, numScreens, count, i, j;

  vinfo = XGetVisualInfo(display, lvinfo_mask & VisualAllMask,
    &lvinfo_template->vinfo, nitems_return);
  if (vinfo == NULL)
    return NULL;
  numVisuals = *nitems_return;
  if (layersRead == False) {
    overlayVisualsAtom = XInternAtom(display,
      "SERVER_OVERLAY_VISUALS", True);
    if (overlayVisualsAtom != None) {
      numScreens = ScreenCount(display);
      overlayInfoPerScreen = (OverlayInfo **)
        malloc(numScreens * sizeof(OverlayInfo *));
      numOverlaysPerScreen = (int *)
        malloc(numScreens * sizeof(int));
      if (overlayInfoPerScreen != NULL &&
        numOverlaysPerScreen != NULL) {
        for (i = 0; i < numScreens; i++) {
          root = RootWindow(display, i);
          status = XGetWindowProperty(display, root,
            overlayVisualsAtom, 0L, (long) 10000, False,
            overlayVisualsAtom, &actualType, &actualFormat,
            &sizeData, &bytesLeft,
            (unsigned char **) &overlayInfoPerScreen[i]);
          if (status != Success ||
            actualType != overlayVisualsAtom ||
            actualFormat != 32 || sizeData < 4)
            numOverlaysPerScreen[i] = 0;
          else
            numOverlaysPerScreen[i] = sizeData /
              (sizeof(OverlayInfo) / 4);
        }
        layersRead = True;
      } else {
        if (overlayInfoPerScreen != NULL)
          free(overlayInfoPerScreen);
        if (numOverlaysPerScreen != NULL)
          free(numOverlaysPerScreen);
      }
    }
  }
  layerInfo = (XLayerVisualInfo *)
    malloc(numVisuals * sizeof(XLayerVisualInfo));
  if (layerInfo == NULL) {
    XFree(vinfo);
    return NULL;
  }
  count = 0;
  for (i = 0; i < numVisuals; i++) {
    XVisualInfo *pVinfo;
    int screen;
    OverlayInfo *overlayInfo;

    pVinfo = &vinfo[i];
    screen = pVinfo->screen;
    overlayInfo = NULL;
    if (layersRead) {
      for (j = 0; j < numOverlaysPerScreen[screen]; j++)
        if (pVinfo->visualid ==
          overlayInfoPerScreen[screen][j].overlay_visual) {
          overlayInfo = &overlayInfoPerScreen[screen][j];
          break;
        }
    }
    if (lvinfo_mask & VisualLayerMask)
      if (overlayInfo == NULL) {
        if (lvinfo_template->layer != 0)
          continue;
      } else if (lvinfo_template->layer != overlayInfo->layer)
        continue;
    if (lvinfo_mask & VisualTransparentType)
      if (overlayInfo == NULL) {
        if (lvinfo_template->type != None)
          continue;
      } else if (lvinfo_template->type !=
        overlayInfo->transparent_type)
        continue;
    if (lvinfo_mask & VisualTransparentValue)
      if (overlayInfo == NULL)
        /* non-overlay visuals have no sense of
           TransparentValue */
        continue;
      else if (lvinfo_template->value != overlayInfo->value)
        continue;
    layerInfo[count].vinfo = *pVinfo;
    if (overlayInfo == NULL) {
      layerInfo[count].layer = 0;
      layerInfo[count].type = None;
      layerInfo[count].value = 0;  /* meaningless */
    } else {
      layerInfo[count].layer = overlayInfo->layer;
      layerInfo[count].type = overlayInfo->transparent_type;
      layerInfo[count].value = overlayInfo->value;
    }
    count++;
  }
  XFree(vinfo);
  *nitems_return = count;
  if (count == 0) {
    XFree(layerInfo);
    return NULL;
  } else
    return layerInfo;
}

#if 0                   /* unused */
Status
__glutXMatchLayerVisualInfo(Display * display, int screen,
  int depth, int class, int layer,
  XLayerVisualInfo * lvinfo_return)
{
  XLayerVisualInfo *lvinfo;
  XLayerVisualInfo lvinfoTemplate;
  int nitems;

  lvinfoTemplate.vinfo.screen = screen;
  lvinfoTemplate.vinfo.depth = depth;
  lvinfoTemplate.vinfo.class = class;
  lvinfoTemplate.layer = layer;
  lvinfo = __glutXGetLayerVisualInfo(display,
    VisualScreenMask | VisualDepthMask |
    VisualClassMask | VisualLayerMask,
    &lvinfoTemplate, &nitems);
  if (lvinfo != NULL && nitems > 0) {
    *lvinfo_return = *lvinfo;
    return 1;
  } else
    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\wgltget.c ===
/* Copyright (c) Mark J. Kilgard and Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include "gltint.h"

/*
  Retrieve OS-specific information
  */
int __glutOsGet(GLenum param)
{
    RECT rect;
    PIXELFORMATDESCRIPTOR pfd;
    HDC hdc;
    int ipfd;
    int val;

    switch(param)
    {
    case GLUT_WINDOW_X:
        GetWindowRect(__glutCurrentWindow->owin, &rect);
        return rect.left;
  case GLUT_WINDOW_Y:
        GetWindowRect(__glutCurrentWindow->owin, &rect);
        return rect.top;

    case GLUT_WINDOW_WIDTH:
        if (!__glutCurrentWindow->reshape)
        {
            GetClientRect(__glutCurrentWindow->owin, &rect);
            return rect.right;
        }
        return __glutCurrentWindow->width;
    case GLUT_WINDOW_HEIGHT:
        if (!__glutCurrentWindow->reshape)
        {
            GetClientRect(__glutCurrentWindow->owin, &rect);
            return rect.bottom;
        }
        return __glutCurrentWindow->height;
    }

    hdc = GetDC(__glutCurrentWindow->owin);
    ipfd = GetPixelFormat(hdc);
    DescribePixelFormat(hdc, ipfd, sizeof(pfd), &pfd);
    ReleaseDC(__glutCurrentWindow->owin, hdc);

    switch(param)
    {
    case GLUT_WINDOW_BUFFER_SIZE:
        return pfd.cColorBits+pfd.cAlphaBits;
    case GLUT_WINDOW_STENCIL_SIZE:
        return pfd.cStencilBits;
    case GLUT_WINDOW_DEPTH_SIZE:
        return pfd.cDepthBits;
    case GLUT_WINDOW_RED_SIZE:
        return pfd.cRedBits;
    case GLUT_WINDOW_GREEN_SIZE:
        return pfd.cGreenBits;
    case GLUT_WINDOW_BLUE_SIZE:
        return pfd.cBlueBits;
    case GLUT_WINDOW_ALPHA_SIZE:
        return pfd.cAlphaBits;
    case GLUT_WINDOW_ACCUM_RED_SIZE:
        return pfd.cAccumRedBits;
    case GLUT_WINDOW_ACCUM_GREEN_SIZE:
        return pfd.cAccumGreenBits;
    case GLUT_WINDOW_ACCUM_BLUE_SIZE:
        return pfd.cAccumBlueBits;
    case GLUT_WINDOW_ACCUM_ALPHA_SIZE:
        return pfd.cAccumAlphaBits;
    case GLUT_WINDOW_DOUBLEBUFFER:
        return (pfd.dwFlags & PFD_DOUBLEBUFFER) ? 1 : 0;
    case GLUT_WINDOW_RGBA:
        return pfd.iPixelType == PFD_TYPE_RGBA ? 1 : 0;
    case GLUT_WINDOW_COLORMAP_SIZE:
        if (pfd.iPixelType == PFD_TYPE_RGBA ||
            __glutCurrentWindow->colormap == NULL)
        {
            return 0;
        }
        else
        {
            return __glutCurrentWindow->colormap->size;
        }
    case GLUT_SCREEN_WIDTH:
        return GetSystemMetrics(SM_CXSCREEN);
    case GLUT_SCREEN_HEIGHT:
        return GetSystemMetrics(SM_CYSCREEN);
    case GLUT_SCREEN_WIDTH_MM:
        hdc = GetDC(__glutCurrentWindow->owin);
        val = GetDeviceCaps(hdc, HORZSIZE);
        ReleaseDC(__glutCurrentWindow->owin, hdc);
        return val;
    case GLUT_SCREEN_HEIGHT_MM:
        hdc = GetDC(__glutCurrentWindow->owin);
        val = GetDeviceCaps(hdc, VERTSIZE);
        ReleaseDC(__glutCurrentWindow->owin, hdc);
        return val;
    case GLUT_DISPLAY_MODE_POSSIBLE:
        hdc = GetDC(__glutCurrentWindow->owin);
        if (__glutWinFindPixelFormat(hdc, __glutDisplayMode, &pfd, GL_FALSE))
        {
            ReleaseDC(__glutCurrentWindow->owin, hdc);
            return 1;
        }
        if (__glutWinFindPixelFormat(hdc, __glutDisplayMode | GLUT_DOUBLE,
                                     &pfd, GL_FALSE))
        {
            ReleaseDC(__glutCurrentWindow->owin, hdc);
            return 1;
        }
        ReleaseDC(__glutCurrentWindow->owin, hdc);
        return 0;
    
#if (GLUT_API_VERSION >= 2)
    case GLUT_WINDOW_NUM_SAMPLES:
        return 0;

    case GLUT_WINDOW_STEREO:
        return (pfd.dwFlags & PFD_STEREO) ? 1 : 0;

    case GLUT_ENTRY_CALLBACKS:
        return 0;
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\wgltmenu.c ===
/* Copyright (c) Mark J. Kilgard and Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include "gltint.h"

/*
  Every GLUT menu has its own callback function.  This means that
  selecting an item from a submenu may call a different selection function
  than selecting an item from the parent menu.  TrackPopupMenu doesn't
  tell us what menu an item was selected from so we have to determine
  it entirely from the item ID.

  The solution adopted here is to assign every menu item a unique
  ID and then remember the mapping from ID to menu and item.  This
  constrains the total number of menu entries to 64K but that's
  probably not a problem.
  */
typedef struct _MapMenuId
{
    int gid;
    GLUTmenu *menu;
} MapMenuId;

#define ID_MAP_BLOCK 16
static MapMenuId *id_map = NULL;
static UINT id_map_size = 0, id_map_free = 0;

static UINT GetIdMapping(int gid, GLUTosMenu osmenu)
{
    UINT wid;
    GLUTmenu *menu;

    menu = __glutGetMenuByOsMenu(osmenu);
    if (menu == NULL)
    {
        __glutFatalError("No menu for osmenu.");
    }
    
    if (id_map_free == 0)
    {
        /* Extend the mapping array */
        id_map_size += ID_MAP_BLOCK;
        id_map_free += ID_MAP_BLOCK;
        
        id_map = (MapMenuId *)realloc(id_map, sizeof(MapMenuId)*id_map_size);
        if (id_map == NULL)
        {
            __glutFatalError("Unable to allocate space for menu ID mapping.");
        }

        /* Mark as unused */
        for (wid = id_map_size-ID_MAP_BLOCK; wid < id_map_size; wid++)
        {
            id_map[wid].menu = NULL;
        }
    }

    /* Locate an unused entry, looking from the end first because free
       entries are added there */
    wid = id_map_size-1;
    do
    {
        if (id_map[wid].menu == NULL)
        {
            id_map[wid].gid = gid;
            id_map[wid].menu = menu;
            id_map_free--;
            return wid;
        }
    }
    while (wid-- > 0);

    __glutFatalError("GetIdMapping end reached.");
}

static void EndIdMapping(UINT wid)
{
    id_map[wid].menu = NULL;
    id_map_free++;
}

static MapMenuId *FindIdMapping(UINT wid)
{
    if (wid >= id_map_size ||
        id_map[wid].menu == NULL)
    {
        return NULL;
    }
    
    return id_map+wid;
}

/*
  Create an empty menu
  */
GLUTosMenu __glutOsCreateMenu(void)
{
    return CreatePopupMenu();
}

static void UnmapMenu(HMENU menu)
{
    int i, n;
    UINT wid;

    n = GetMenuItemCount(menu);
    for (i = 0; i < n; i++)
    {
        wid = GetMenuItemID(menu, i);
        /* GLUT does not destroy menus recursively, so change
           submenu entries into separators to unhook child menus */
        if (wid == 0xffffffff)
        {
            ModifyMenu(menu, i, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        }
        else
        {
            EndIdMapping(wid);
        }
    }
}

/*
  Clean up a menu
  */
void __glutOsDestroyMenu(GLUTosMenu menu)
{
    UnmapMenu(menu);
    /* UnmapMenu unhooked any child menus */
    DestroyMenu(menu);
}

/*
  Add a text item
  */
void __glutOsAddMenuEntry(GLUTosMenu menu, char *label, int value)
{
    UINT wid;

    wid = GetIdMapping(value, menu);
    if (!AppendMenu(menu, MF_STRING, wid, label))
    {
        __glutFatalError("Unable to append menu item, %d.",
                         GetLastError());
        EndIdMapping(wid);
    }
}

/*
  Add a submenu item
  */
void __glutOsAddSubMenu(GLUTosMenu menu, char *label, GLUTosMenu submenu)
{
    if (!AppendMenu(menu, MF_POPUP, (UINT)submenu, label))
    {
        __glutFatalError("Unable to append menu item, %d.",
                         GetLastError());
    }
}

/*
  Change an item to a text item
  */
void __glutOsChangeToMenuEntry(GLUTosMenu menu, int num, char *label,
                               int value)
{
    UINT wid;
    
    num--;
    
    /* Don't use ModifyMenu since the item may not exist yet */

    wid = 0xffffffff;
    
    if (GetMenuState(menu, num, MF_BYPOSITION) != 0xffffffff)
    {
        /* If the item being replaced is not a menu we already have
           an ID mapping for it */
        wid = GetMenuItemID(menu, num);
        
        DeleteMenu(menu, num, MF_BYPOSITION);
    }

    if (wid == 0xffffffff)
    {
        wid = GetIdMapping(value, menu);
    }
    
    if (!InsertMenu(menu, num, MF_BYPOSITION | MF_STRING, wid, label))
    {
        __glutFatalError("Unable to append menu item, %d.",
                         GetLastError());
    }
}

/*
  Change an item to a submenu item
  */
void __glutOsChangeToSubMenu(GLUTosMenu menu, int num, char *label,
                             GLUTosMenu submenu)
{
    UINT wid;
    
    num--;
    
    /* Don't use ModifyMenu since the item may not exist yet */
    
    if (GetMenuState(menu, num, MF_BYPOSITION) != 0xffffffff)
    {
        /* If the item has a wid, unmap it */
        wid = GetMenuItemID(menu, num);
        if (wid != 0xffffffff)
        {
            EndIdMapping(wid);
        }
        
        DeleteMenu(menu, num, MF_BYPOSITION);
    }
    
    if (!InsertMenu(menu, num, MF_BYPOSITION | MF_POPUP, (UINT)submenu,
                    label))
    {
        __glutFatalError("Unable to append menu item, %d.",
                         GetLastError());
    }
}

/*
  Remove an item
  */
void __glutOsRemoveMenuEntry(GLUTosMenu menu, int item)
{
    UINT wid;

    item--;
    
    if (GetMenuState(menu, item, MF_BYPOSITION) != 0xffffffff)
    {
        /* If the item has a wid, unmap it */
        wid = GetMenuItemID(menu, item);
        if (wid != 0xffffffff)
        {
            EndIdMapping(wid);
        }
        
        if (!DeleteMenu(menu, item, MF_BYPOSITION))
        {
            __glutWarning("Unable to remove menu item %d, %d.",
                          item+1, GetLastError());
        }
    }
}

void __glutWinPopupMenu(GLUTwindow *window, int but, int x, int y)
{
    GLUTmenu *menu;
    MSG cmd;

    menu = __glutGetMenuByNum(window->menu[but]);
    if (menu)
    {
        __glutMappedMenu = menu;
        __glutMenuWindow = window;
        if (__glutMenuStateFunc)
        {
            __glutSetMenu(menu);
            __glutSetWindow(window);
            (*__glutMenuStateFunc)(GLUT_MENU_IN_USE);
        }
                    
        if (!TrackPopupMenu(menu->omenu, TPM_LEFTALIGN |
                            (but == GLUT_RIGHT_BUTTON ?
                             TPM_RIGHTBUTTON :
                             TPM_LEFTBUTTON), x, y,
                            0, window->owin, NULL))
        {
            __glutWarning("TrackPopupMenu failed, %d.",
                          GetLastError());
        }

        /* Force retrieval of the WM_COMMAND that
           TrackPopupMenu might have put on the queue so
           that we can call the menu callback now before
           we clean up */
        if (PeekMessage(&cmd, window->owin, WM_COMMAND, WM_COMMAND,
                        PM_REMOVE))
        {
            MapMenuId *map;
            
            map = FindIdMapping(LOWORD(cmd.wParam));
            if (map && map->menu->select != NULL)
            {
                __glutSetWindow(window);
                __glutSetMenu(map->menu);
                (*map->menu->select)(map->gid);
            }
        }
                    
        if (__glutMenuStateFunc)
        {
            __glutSetWindow(window);
            __glutSetMenu(menu);
            (*__glutMenuStateFunc)(GLUT_MENU_NOT_IN_USE);
        }

        __glutMappedMenu = NULL;
        __glutMenuWindow = NULL;
                    
    }
    else
    {
        __glutWarning("Invalid menu attached to button %d.", but);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\wgltinpt.c ===
/* Copyright (c) Mark J. Kilgard and Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

/*
  Update the mask of devices to check for input from
  */
void __glutOsUpdateInputDeviceMask(GLUTwindow * window)
{
    /* Ignored */
}

/*
  Retrieve OS-specific device information
  */
int __glutOsDeviceGet(GLenum param)
{
    switch(param)
    {
    case GLUT_HAS_KEYBOARD:
        /* Assume keyboard present */
        /* ATTENTION - Is there a way to check this? */
        return 1;
        
    case GLUT_HAS_MOUSE:
        return GetSystemMetrics(SM_MOUSEPRESENT);
        
    case GLUT_HAS_SPACEBALL:
    case GLUT_HAS_DIAL_AND_BUTTON_BOX:
    case GLUT_HAS_TABLET:
        return 0;
        
    case GLUT_NUM_MOUSE_BUTTONS:
        return GetSystemMetrics(SM_CMOUSEBUTTONS);
        
    case GLUT_NUM_SPACEBALL_BUTTONS:
    case GLUT_NUM_BUTTON_BOX_BUTTONS:
    case GLUT_NUM_DIALS:
    case GLUT_NUM_TABLET_BUTTONS:
        return 0;
    }
}

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\wgltos.c ===
/* Copyright (c) Mark J. Kilgard and Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include "gltint.h"

static char *window_class = "GLUTWindow";
static ATOM class_atom = 0;
static unsigned long initial_tick_count = 0;

/*
  The same DC needs to be used for everything to ensure that colormaps
  are properly selected and realized during drawing.
  Each window gets a DC when it is created and releases it when it is
  destroyed.  The DC is stored in the user data for the window and
  retrieved through these routines

  Keeping the DC alive is also important since a DC that has a current
  RC must stay alive or no drawing occurs

  The same effect could be achieved through CS_OWNDC but that seems less
  self-documenting
  */
HDC __glutWinGetDc(GLUTosWindow win)
{
    return (HDC)GetWindowLong(win, GWL_USERDATA);
}

void __glutWinReleaseDc(GLUTosWindow win, HDC hdc)
{
}

LRESULT WindowProc(HWND win, UINT msg, WPARAM wpm, LPARAM lpm);

/*
  Initialize OS-dependent information
  */
void __glutOsInitialize(void)
{
    WNDCLASS wndclass;

    /* Register the window class */
    wndclass.style = CS_HREDRAW | CS_VREDRAW;
    wndclass.lpfnWndProc = WindowProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = GetModuleHandle(NULL);
    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION);
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    /* Use BLACK_BRUSH since graphics programs are most likely
       to use a black background color */
    wndclass.hbrBackground = GetStockObject(BLACK_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = window_class;

    class_atom = RegisterClass(&wndclass);
    if (class_atom == 0)
    {
        __glutFatalError("Unable to register window class, %d.",
                         GetLastError());
    }

    initial_tick_count = GetTickCount();
}

/*
  Clean up OS-dependent information
  */
void __glutOsUninitialize(void)
{
    UnregisterClass(window_class, GetModuleHandle(NULL));
}

/*
  Check whether the given OS-specific extension is supported
  */
int __glutOsIsSupported(char *extension)
{
    return 0;
}

/*
  Operate on any OS-specific arguments
  */
int __glutOsParseArgument(char **argv, int remaining)
{
    return -1;
}

/*
  Retrieve the number of milliseconds since glutOsInitialize was called
  */
unsigned long __glutOsElapsedTime(void)
{
    /* Because of the unsigned values, this subtraction works even
       when the current time has wrapped around */
    return GetTickCount()-initial_tick_count;
}

/*
  Check and see if there are any pending events
  */
GLboolean __glutOsEventsPending(void)
{
    MSG msg;
    
    return PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);
}

static LRESULT WindowProc(HWND win, UINT msg, WPARAM wpm, LPARAM lpm)
{
    GLUTwindow *window;
    int width, height;
    PAINTSTRUCT ps;
    int but, trav;
    LRESULT rc;
    int vis_state;
    HDC hdc;
    static HWND click_active = 0;
    static HWND window_closing = 0;
    static BOOL click_down;

#if 0
    printf("WindowProc(%p, %X, %p, %p)\n", win, msg, wpm, lpm);
#endif
    
    switch(msg)
    {
        /* ATTENTION - Enter and leave?  Would probably require a hook */

    case WM_CREATE:
        SetWindowLong(win, GWL_USERDATA, (LONG)GetDC(win));
        break;

    case WM_CLOSE:
        window_closing = win;
        DestroyWindow(win);
        break;
        
    case WM_DESTROY:
        if (win == click_active)
        {
            click_active = 0;
        }

        /* If we're the active window, stop.  For normal shutdown this
           is handled by GLUT, but for shutdown from the system menu
           we need to do this here */
        if (__glutCurrentWindow && __glutCurrentWindow->owin == win)
        {
            __glutCurrentWindow = NULL;
        }
        
        /* If this window has an active context, remove it */
        if (__glutWinGetDc(win) == wglGetCurrentDC())
        {
            __glutOsMakeCurrent(win, GLUT_OS_INVALID_GL_CONTEXT);
        }

        ReleaseDC(win, __glutWinGetDc(win));

        if (window_closing == win)
        {
            PostQuitMessage(0);
        }
        break;

    case WM_QUERYNEWPALETTE:
        /* We're going to become the focus window, so realize our
           colormap */
        if (win != GetFocus())
        {
            window = __glutGetWindow(win);
            if (window)
            {
                __glutWinRealizeWindowPalette(window->owin, window->ocmap,
                                              GL_FALSE);
                __glutPostRedisplay(window);
                return TRUE;
            }
        }
        break;
        
    case WM_PALETTECHANGED:
        if (win != (HWND)wpm)
        {
            /* We're going into the background, so realize our palette as
               a background palette */
            window = __glutGetWindow(win);
            if (window)
            {
                /* Don't use __glutWinRealizeWindowPalette because we
                   don't want to do static color manipulations */
                hdc = __glutWinGetDc(win);
                SelectPalette(hdc, window->ocmap->hpal, TRUE);
                RealizePalette(hdc);
                __glutWinReleaseDc(win, hdc);
            }
        }
        break;
        
    case WM_SIZE:
        window = __glutGetWindow(win);
        if (window)
        {
            switch(wpm)
            {
            case SIZE_MAXHIDE:
            case SIZE_MINIMIZED:
            case SIZE_MAXSHOW:
                /* Visibility changes */
                vis_state = wpm == SIZE_MAXSHOW;
                if (vis_state != window->vis_state)
                {
                    window->vis_state = vis_state;
                    if (window->visibility)
                    {
                        __glutSetWindow(window);
                        (*window->visibility) (vis_state ?
                                               GLUT_VISIBLE :
                                               GLUT_NOT_VISIBLE);
                    }
                }
                break;

            case SIZE_RESTORED:
            case SIZE_MAXIMIZED:
                /* Possible visibility change */
                if (window->vis_state != GL_TRUE)
                {
                    window->vis_state = GL_TRUE;
                    if (window->visibility)
                    {
                        __glutSetWindow(window);
                        (*window->visibility)(GLUT_VISIBLE);
                    }
                }
                
                /* Possible change to the size of the window */
                width = LOWORD(lpm);
                height = HIWORD(lpm);
                if (width != window->width || height != window->height)
                {
                    window->width = width;
                    window->height = height;
                    __glutSetWindow(window);
                    (*window->reshape) (width, height);
                }
                break;
            }
        }
        break;

    case WM_SHOWWINDOW:
        rc = DefWindowProc(win, msg, wpm, lpm);
        window = __glutGetWindow(win);
        if (window)
        {
            window->map_state = (GLboolean)wpm;
            if (window->visibility)
            {
                if (window->map_state != window->vis_state)
                {
                    window->vis_state = window->map_state;
                    __glutSetWindow(window);
                    (*window->visibility)(window->vis_state ?
                                          GLUT_VISIBLE : GLUT_NOT_VISIBLE);
                }
            }
        }
        return rc;
        
    case WM_PAINT:
        BeginPaint(win, &ps);
        EndPaint(win, &ps);
        window = __glutGetWindow(win);
        if (window)
        {
            __glutPostRedisplay(window);
        }
        break;

    case WM_COMMAND:
        if (HIWORD(wpm) == 0)
        {
            /* Menu command */
            /* We should have already eaten any menu commands so
               this should never happen */
            __glutWarning("Received an unexpected menu command.");
        }
        break;
        
    case WM_LBUTTONDOWN:
        but = GLUT_LEFT_BUTTON;
        trav = GLUT_DOWN;
        goto MouseButton;
    case WM_LBUTTONUP:
        but = GLUT_LEFT_BUTTON;
        trav = GLUT_UP;
        goto MouseButton;
    case WM_MBUTTONDOWN:
        but = GLUT_MIDDLE_BUTTON;
        trav = GLUT_DOWN;
        goto MouseButton;
    case WM_MBUTTONUP:
        but = GLUT_MIDDLE_BUTTON;
        trav = GLUT_UP;
        goto MouseButton;
    case WM_RBUTTONDOWN:
        but = GLUT_RIGHT_BUTTON;
        trav = GLUT_DOWN;
        goto MouseButton;
    case WM_RBUTTONUP:
        but = GLUT_RIGHT_BUTTON;
        trav = GLUT_UP;

    MouseButton:
        /* If we've been activated by a mouse click, eat the mouse up/down
           events to avoid having events happen when you only want to
           change window order.
           This is a pretty ugly hack since we may destroy mouse events
           that are waiting in the queue */
        if (win == click_active)
        {
            if (trav == GLUT_UP)
            {
                click_active = 0;
            }
            else
            {
                click_down = TRUE;
            }

            break;
        }
        
        window = __glutGetWindow(win);
        
        if (trav == GLUT_DOWN)
        {
            if (window && window->menu[but])
            {
                POINT pt;
                
                pt.x = LOWORD(lpm);
                pt.y = HIWORD(lpm);
                ClientToScreen(win, &pt);
                __glutWinPopupMenu(window, but, pt.x, pt.y);
                
                /* Don't fall into mouse button processing */
                break;
            }
            else if (GetCapture() != win)
            {
                SetCapture(win);
            }
        }
        
        if (window)
        {
            if (window->mouse)
            {
                __glutSetWindow(window);
                (*window->mouse)(but, trav, LOWORD(lpm), HIWORD(lpm));
            }
        }
        
        if (trav == GLUT_UP && GetCapture() == win)
        {
            ReleaseCapture();
        }
        break;

    case WM_ACTIVATE:
        if (LOWORD(wpm) == WA_CLICKACTIVE)
        {
            /* Mark this window as click-activated */
            click_active = win;
            click_down = FALSE;
            
            /* Post ourselves a message to check the click activation state.
               If we haven't seen a mouse-down when this message arrives,
               we were click activated by mousing outside the client area
               and so we don't need to be click active */
            PostMessage(win, WM_USER, 0, 0);
        }
        else if (LOWORD(wpm) == WA_INACTIVE)
        {
            /* If the window is going inactive, the palette must be
               realized to the background.  Cannot depend on
               WM_PALETTECHANGED to be sent since the window that comes
               to the foreground may or may not be palette managed */
            window = __glutGetWindow(win);
            if (window)
            {
                __glutWinRealizeWindowPalette(window->owin, window->ocmap,
                                              GL_TRUE);
                __glutPostRedisplay(window);
            }
        }
        
        /* Let the default processing occur */
        return DefWindowProc(win, msg, wpm, lpm);

    case WM_USER:
        if (click_active == win)
        {
            if (!click_down)
            {
                click_active = 0;
            }
        }
        break;
        
    case WM_MOUSEMOVE:
        if (win == click_active)
        {
            break;
        }
        
        window = __glutGetWindow(win);
        if (window)
        {
            /* If motion function registered _and_ buttons held *
               down, call motion function...  */
            if (window->motion &&
                (wpm & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)))
            {
                __glutSetWindow(window);
                (*window->motion)(LOWORD(lpm), HIWORD(lpm));
            }
            /* If passive motion function registered _and_
               buttons not held down, call passive motion
               function...  */
            else if (window->passive &&
                     (wpm & (MK_LBUTTON | MK_MBUTTON | MK_RBUTTON)) == 0)
            {
                __glutSetWindow(window);
                (*window->passive)(LOWORD(lpm), HIWORD(lpm));
            }
        }
        break;

    case WM_CHAR:
        window = __glutGetWindow(win);
        if (window && window->keyboard)
        {
            POINT pt;
            
            __glutSetWindow(window);
            GetCursorPos(&pt);
            ScreenToClient(win, &pt);
            (*window->keyboard)((char)wpm, pt.x, pt.y);
        }
        break;

#if (GLUT_API_VERSION >= 2)
    case WM_KEYDOWN:
        window = __glutGetWindow(win);
        if (window->special == NULL)
        {
            return DefWindowProc(win, msg, wpm, lpm);
        }
        
        switch(wpm)
        {
            /* function keys */
        case VK_F1:
            wpm = GLUT_KEY_F1;
            break;
        case VK_F2:
            wpm = GLUT_KEY_F2;
            break;
        case VK_F3:
            wpm = GLUT_KEY_F3;
            break;
        case VK_F4:
            wpm = GLUT_KEY_F4;
            break;
        case VK_F5:
            wpm = GLUT_KEY_F5;
            break;
        case VK_F6:
            wpm = GLUT_KEY_F6;
            break;
        case VK_F7:
            wpm = GLUT_KEY_F7;
            break;
        case VK_F8:
            wpm = GLUT_KEY_F8;
            break;
        case VK_F9:
            wpm = GLUT_KEY_F9;
            break;
        case VK_F10:
            wpm = GLUT_KEY_F10;
            break;
        case VK_F11:
            wpm = GLUT_KEY_F11;
            break;
        case VK_F12:
            wpm = GLUT_KEY_F12;
            break;
            
            /* directional keys */
        case VK_LEFT:
            wpm = GLUT_KEY_LEFT;
            break;
        case VK_UP:
            wpm = GLUT_KEY_UP;
            break;
        case VK_RIGHT:
            wpm = GLUT_KEY_RIGHT;
            break;
        case VK_DOWN:
            wpm = GLUT_KEY_DOWN;
            break;
        case VK_PRIOR:
            wpm = GLUT_KEY_PAGE_UP;
            break;
        case VK_NEXT:
            wpm = GLUT_KEY_PAGE_DOWN;
            break;
        case VK_HOME:
            wpm = GLUT_KEY_HOME;
            break;
        case VK_END:
            wpm = GLUT_KEY_END;
            break;
        case VK_INSERT:
            wpm = GLUT_KEY_INSERT;
            break;
            
        default:
            wpm = 0;
            break;
        }

        if (wpm != 0)
        {
            POINT pt;
            
            __glutSetWindow(window);
            GetCursorPos(&pt);
            ScreenToClient(win, &pt);
            (*window->special)((int)wpm, pt.x, pt.y);
        }
        break;
#endif

    default:
        return DefWindowProc(win, msg, wpm, lpm);        
    }

    return 0;
}

/*
  Process all current pending events
  Initially waits on an event so if this is called when
  __glutOsEventsPending is GL_FALSE, it will block until an event comes in
  */
void __glutOsProcessEvents(void)
{
    MSG msg;
    
    do
    {
        if (!GetMessage(&msg, NULL, 0, 0))
        {
            if (GetLastError() != ERROR_SUCCESS)
            {
                __glutFatalError("GetMessage failed, %d.",
                                 GetLastError());
            }
            else
            {
                exit(0);
            }
        }

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
    while (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE));
}

/*
  Wait for an event to come in or the given time to arrive
  */
void __glutOsWaitForEvents(unsigned long timeout)
{
    int rc;
    unsigned long now;

    now = __glutOsElapsedTime();
    if (timeout > now)
    {
        timeout -= now;
    }
    else
    {
        timeout = 0;
    }

    rc = MsgWaitForMultipleObjects(0, NULL, FALSE, timeout, QS_ALLINPUT);
    if (rc == 0xffffffff)
    {
        __glutFatalError("Failed when waiting, %d.", GetLastError());
    }
}

/*
  Process any deferred work items
  */
void __glutOsProcessWindowWork(GLUTwindow *window)
{
    if (window->work_mask & GLUT_EVENT_MASK_WORK)
    {
        /* Ignored */
    }

#if (GLUT_API_VERSION >= 2)
    if (window->work_mask & GLUT_DEVICE_MASK_WORK)
    {
        (*__glutUpdateInputDeviceMaskFunc) (window);
    }
#endif
    
    if (window->work_mask & GLUT_CONFIGURE_WORK)
    {
        int swp;
        HWND after;

        swp = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER;
        after = NULL;
        if (window->desired_conf_mask & (GLUT_OS_CONFIGURE_X |
                                         GLUT_OS_CONFIGURE_Y))
        {
            swp &= ~SWP_NOMOVE;
        }
        if (window->desired_conf_mask & (GLUT_OS_CONFIGURE_WIDTH |
                                         GLUT_OS_CONFIGURE_HEIGHT))
        {
            swp &= ~SWP_NOSIZE;
        }
        if (window->desired_conf_mask & GLUT_OS_CONFIGURE_STACKING)
        {
            swp &= ~SWP_NOZORDER;
            if (window->desired_stack == GLUT_OS_STACK_ABOVE)
            {
                after = HWND_TOP;
            }
            else if (window->desired_stack == GLUT_OS_STACK_BELOW)
            {
                after = HWND_BOTTOM;
            }
        }
        SetWindowPos(window->owin, after, window->desired_x, window->desired_y,
                     window->desired_width, window->desired_height, swp);
        window->desired_conf_mask = 0;
    }
    
    if (window->work_mask & GLUT_COLORMAP_WORK)
    {
        __glutWinRealizeWindowPalette(window->owin, window->ocmap, GL_FALSE);
    }
    
    if (window->work_mask & GLUT_MAP_WORK)
    {
        int sw;
        
        switch (window->desired_map_state)
        {
        case GLUT_OS_HIDDEN_STATE:
            sw = SW_HIDE;
            break;
        case GLUT_OS_NORMAL_STATE:
            sw = SW_SHOW;
            break;
        case GLUT_OS_ICONIC_STATE:
            sw = SW_SHOWMINIMIZED;
            break;
        }
        ShowWindow(window->owin, sw);
    }
}

/*
  Attempt to create a pixel format from the given mode
  */
GLboolean __glutWinFindPixelFormat(HDC hdc, GLbitfield type,
                                   PIXELFORMATDESCRIPTOR *ppfd,
                                   GLboolean set)
{
    int ipfd;
    GLboolean rc = GL_FALSE;

    ppfd->nSize       = sizeof(*ppfd);
    ppfd->nVersion    = 1;
    ppfd->dwFlags     = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL;
    ppfd->dwLayerMask = PFD_MAIN_PLANE;

    if (GLUT_WIND_IS_DOUBLE(type))
    {
        ppfd->dwFlags |= PFD_DOUBLEBUFFER;
    }

#if (GLUT_API_VERSION >= 2)
    if (GLUT_WIND_IS_MULTISAMPLE(type))
    {
        /* ATTENTION - Should query to see if hardware supports multisampling,
           but how? */
        return GL_FALSE;
    }
    
    if (GLUT_WIND_IS_STEREO(type))
    {
        ppfd->dwFlags |= PFD_STEREO;
    }
#endif
    
    if (GLUT_WIND_IS_INDEX(type))
    {
        ppfd->iPixelType = PFD_TYPE_COLORINDEX;
        ppfd->cColorBits = 8;
    }

    if (GLUT_WIND_IS_RGB(type))
    {
        ppfd->iPixelType = PFD_TYPE_RGBA;
        ppfd->cColorBits = 24;
    }

    if (GLUT_WIND_HAS_ACCUM(type))
    {
        ppfd->cAccumBits = ppfd->cColorBits;
    }
    else
    {
        ppfd->cAccumBits = 0;
    }

    if (GLUT_WIND_HAS_DEPTH(type))
    {
        ppfd->cDepthBits = 24;
    }
    else
    {
        ppfd->cDepthBits = 0;
    }

    if (GLUT_WIND_HAS_STENCIL(type))
    {
        ppfd->cStencilBits = 8;
    }
    else
    {
        ppfd->cStencilBits = 0;
    }

    ipfd = ChoosePixelFormat(hdc, ppfd);
    if ( ipfd )
    {
        DescribePixelFormat(hdc, ipfd, sizeof(*ppfd), ppfd);
        
        if ( !set ||
             SetPixelFormat(hdc, ipfd, ppfd) )
        {
            rc = GL_TRUE;
        }
    }

    return rc;
}

/*
  Create a GL rendering context
  */
GLUTosGlContext __glutOsCreateGlContext(GLUTosWindow win, GLUTosSurface surf,
                                        GLboolean direct)
{
    HGLRC hrc;
    HDC hdc;

    hdc = __glutWinGetDc(win);
    
    if (!SetPixelFormat(hdc, ChoosePixelFormat(hdc, surf), surf))
    {
        return GLUT_OS_INVALID_GL_CONTEXT;
    }
    
    hrc = wglCreateContext(hdc);
    
    __glutWinReleaseDc(win, hdc);
    
    return hrc;
}

/*
  Clean up a GL rendering context
  */
void __glutOsDestroyGlContext(GLUTosGlContext ctx)
{
    wglDeleteContext(ctx);
}

/*
  Make a GL rendering context current
  */
void __glutOsMakeCurrent(GLUTosWindow win, GLUTosGlContext ctx)
{
    HDC hdc;
    
    hdc = __glutWinGetDc(win);
    if (!wglMakeCurrent(hdc, ctx))
    {
        __glutWarning("Unable to make context current, %d.",
                      GetLastError());
    }
    __glutWinReleaseDc(win, hdc);
}

/*
  Swap buffers for the given window
  */
void __glutOsSwapBuffers(GLUTosWindow win)
{
    HDC hdc;

    hdc = __glutWinGetDc(win);
    if (!SwapBuffers(hdc))
    {
        __glutWarning("SwapBuffers failed, %d.", GetLastError());
    }
    __glutWinReleaseDc(win, hdc);
}

/*
  Get a surface description for the given mode
  */
GLUTosSurface __glutOsGetSurface(GLbitfield mode)
{
    PIXELFORMATDESCRIPTOR *ppfd;
    HDC hdc;
    GLboolean rc;

    ppfd = (PIXELFORMATDESCRIPTOR *)malloc(sizeof(PIXELFORMATDESCRIPTOR));
    if (ppfd == NULL)
    {
        return GLUT_OS_INVALID_SURFACE;
    }

    hdc = GetDC(GetDesktopWindow());
    rc = __glutWinFindPixelFormat(hdc, mode, ppfd, GL_FALSE);
    ReleaseDC(GetDesktopWindow(), hdc);
    
    if (!rc)
    {
        free(ppfd);
        return NULL;
    }
    else
    {
        return ppfd;
    }
}

/*
  Clean up a surface description
  */
void __glutOsDestroySurface(GLUTosSurface surf)
{
    free(surf);
}

/*
  Compare two surfaces
  */
GLboolean
__glutOsSurfaceEq(GLUTosSurface s1, GLUTosSurface s2)
{
    return memcmp(s1, s2, sizeof(*s1)) == 0;
}

/*
  Create a window
  */
GLUTosWindow __glutOsCreateWindow(GLUTosWindow parent, char *title,
                                  int x, int y, int width, int height,
                                  GLUTosSurface surf, GLUTosColormap cmap,
                                  long event_mask, int initial_state)
{
    HWND win;
    RECT rect;
    DWORD style;

    if (parent == GLUT_OS_INVALID_WINDOW)
    {
        style = WS_OVERLAPPEDWINDOW;
        if (x < 0)
        {
            x = CW_USEDEFAULT;
        }
        if (y < 0)
        {
            y = CW_USEDEFAULT;
        }
    }
    else
    {
        style = WS_CHILDWINDOW;
    }
    style |= WS_CLIPSIBLINGS | WS_CLIPCHILDREN;
    
    rect.left = 0;
    rect.top = 0;
    rect.right = width;
    rect.bottom = height;
    AdjustWindowRect(&rect, style, FALSE);

    win = CreateWindow(window_class, title, style, x, y,
                       rect.right-rect.left, rect.bottom-rect.top,
                       parent, NULL, GetModuleHandle(NULL), NULL);
    if (win != 0)
    {
        /* The initial WM_SIZE was sent during CreateWindow and
           it was ignored because the GLUTwindow hasn't been fully
           created yet.  Post a WM_SIZE to ourselves so that
           we do a reshape as soon as event processing starts */
        PostMessage(win, WM_SIZE, SIZE_RESTORED, MAKELONG(width, height));

        if (initial_state != GLUT_OS_HIDDEN_STATE)
        {
            ShowWindow(win, initial_state);
            
            /* ShowWindow will send a message which will be ignored
               again, so post a SHOWWINDOW also */
            PostMessage(win, WM_SHOWWINDOW, (WPARAM)TRUE, 0);
        }

        __glutWinRealizeWindowPalette(win, cmap, GL_FALSE);
    }
    else
    {
        __glutWarning("CreateWindow failed, %d.", GetLastError());
    }

    return win;
}

/*
  Clean up a window
  */
void __glutOsDestroyWindow(GLUTosWindow win)
{
    __glutOsMakeCurrent(win, GLUT_OS_INVALID_GL_CONTEXT);
    DestroyWindow(win);
}

/*
  Set the window title
  */
void __glutOsSetWindowTitle(GLUTosWindow win, char *title)
{
    SetWindowText(win, title);
}

/*
  Set the icon title
  */
void __glutOsSetIconTitle(GLUTosWindow win, char *title)
{
    /* This could be implemented by watching for changes
       to and from iconic state */
}

/*
  Set a new colormap for a window
  */
void __glutOsSetWindowColormap(GLUTosWindow win, GLUTosColormap cmap)
{
    __glutWinRealizeWindowPalette(win, cmap, GL_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\xgltget.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include "gltint.h"

/*
  Retrieve OS-specific information
  */
int
__glutOsGet(GLenum param)
{
  Window win, root;
  int x, y, value;
  unsigned int width, height, border, depth;

  switch (param) {
  case GLUT_WINDOW_X:
    XTranslateCoordinates(__glutXDisplay, __glutXRoot,
      __glutCurrentWindow->owin, 0, 0, &x, &y, &win);
    return x;
  case GLUT_WINDOW_Y:
    XTranslateCoordinates(__glutXDisplay, __glutXRoot,
      __glutCurrentWindow->owin, 0, 0, &x, &y, &win);
    return y;
  case GLUT_WINDOW_WIDTH:
    if (!__glutCurrentWindow->reshape) {
      XGetGeometry(__glutXDisplay, __glutCurrentWindow->owin,
        &root, &x, &y,
        &width, &height, &border, &depth);
      return width;
    }
    return __glutCurrentWindow->width;
  case GLUT_WINDOW_HEIGHT:
    if (!__glutCurrentWindow->reshape) {
      XGetGeometry(__glutXDisplay, __glutCurrentWindow->owin,
        &root, &x, &y,
        &width, &height, &border, &depth);
      return height;
    }
    return __glutCurrentWindow->height;

#define GET_CONFIG(attrib) \
  glXGetConfig(__glutXDisplay, __glutCurrentWindow->osurf, \
    attrib, &value);

  case GLUT_WINDOW_BUFFER_SIZE:
    GET_CONFIG(GLX_BUFFER_SIZE);
    return value;
  case GLUT_WINDOW_STENCIL_SIZE:
    GET_CONFIG(GLX_STENCIL_SIZE);
    return value;
  case GLUT_WINDOW_DEPTH_SIZE:
    GET_CONFIG(GLX_DEPTH_SIZE);
    return value;
  case GLUT_WINDOW_RED_SIZE:
    GET_CONFIG(GLX_RED_SIZE);
    return value;
  case GLUT_WINDOW_GREEN_SIZE:
    GET_CONFIG(GLX_GREEN_SIZE);
    return value;
  case GLUT_WINDOW_BLUE_SIZE:
    GET_CONFIG(GLX_BLUE_SIZE);
    return value;
  case GLUT_WINDOW_ALPHA_SIZE:
    GET_CONFIG(GLX_ALPHA_SIZE);
    return value;
  case GLUT_WINDOW_ACCUM_RED_SIZE:
    GET_CONFIG(GLX_ACCUM_RED_SIZE);
    return value;
  case GLUT_WINDOW_ACCUM_GREEN_SIZE:
    GET_CONFIG(GLX_ACCUM_GREEN_SIZE);
    return value;
  case GLUT_WINDOW_ACCUM_BLUE_SIZE:
    GET_CONFIG(GLX_ACCUM_BLUE_SIZE);
    return value;
  case GLUT_WINDOW_ACCUM_ALPHA_SIZE:
    GET_CONFIG(GLX_ACCUM_ALPHA_SIZE);
    return value;
  case GLUT_WINDOW_DOUBLEBUFFER:
    GET_CONFIG(GLX_DOUBLEBUFFER);
    return value;
  case GLUT_WINDOW_RGBA:
    GET_CONFIG(GLX_RGBA);
    return value;
  case GLUT_WINDOW_COLORMAP_SIZE:
    GET_CONFIG(GLX_RGBA);
    if(value) {
      return 0;
    } else {
      return __glutCurrentWindow->osurf->visual->map_entries;
    }
  case GLUT_SCREEN_WIDTH:
    return DisplayWidth(__glutXDisplay, __glutXScreen);
  case GLUT_SCREEN_HEIGHT:
    return DisplayHeight(__glutXDisplay, __glutXScreen);
  case GLUT_SCREEN_WIDTH_MM:
    return DisplayWidthMM(__glutXDisplay, __glutXScreen);
  case GLUT_SCREEN_HEIGHT_MM:
    return DisplayHeightMM(__glutXDisplay, __glutXScreen);
  case GLUT_DISPLAY_MODE_POSSIBLE:
    {
       XVisualInfo *vi;

       vi = __glutOsGetSurface(__glutDisplayMode);
       if(vi) return 1;
       vi = __glutOsGetSurface(__glutDisplayMode | GLUT_DOUBLE);
       if(vi) return 1;
       return 0;
    }
    
#if (GLUT_API_VERSION >= 2)
  case GLUT_WINDOW_NUM_SAMPLES:
#if defined(GLX_VERSION_1_1)
    if(__glutOsIsSupported("GLX_SGIS_multisample")) {
      GET_CONFIG(GLX_SAMPLES_SGIS);
      return value;
    } else {
      return 0;
    }
#else
    return 0;
#endif
  case GLUT_WINDOW_STEREO:
    GET_CONFIG(GLX_STEREO);
    return value;
  case GLUT_ENTRY_CALLBACKS:
    return 1;
#endif
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\xgltinpt.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <X11/Xlib.h>
#include <X11/extensions/XInput.h>
#include <X11/Xutil.h>

#include "gltint.h"

#if (GLUT_API_VERSION >= 2)

int __glutNumDials = 0;
int __glutNumSpaceballButtons = 0;
int __glutNumButtonBoxButtons = 0;
int __glutNumTabletButtons = 0;
int __glutNumMouseButtons = 3; /* Good guess. */
XDevice *__glutTablet = NULL;
XDevice *__glutDials = NULL;
XDevice *__glutSpaceball = NULL;

typedef struct _Range {
  int min;
  int range;
} Range;

#define NUM_SPACEBALL_AXIS	6
#define NUM_TABLET_AXIS		2
#define NUM_DIALS_AXIS		8

Range __glutSpaceballRange[NUM_SPACEBALL_AXIS];
Range __glutTabletRange[NUM_TABLET_AXIS];
int *__glutDialsResolution;

/* Safely assumes 0 is an illegal event type for X Input
   extension events. */
int __glutDeviceMotionNotify = 0;
int __glutDeviceButtonPress = 0;
int __glutDeviceButtonRelease = 0;
int __glutDeviceStateNotify = 0;

static int
normalizeTabletPos(int axis, int rawValue)
{
  assert(rawValue >= __glutTabletRange[axis].min);
  assert(rawValue <= __glutTabletRange[axis].min + __glutTabletRange[axis].range);
  /* Normalize rawValue to between 0 and 4000. */
  return ((rawValue - __glutTabletRange[axis].min) * 4000) /
    __glutTabletRange[axis].range;
}

static int
normalizeDialAngle(int axis, int rawValue)
{
  /* XXX Assumption made that the resolution of the device is
     number of clicks for one complete dial revolution.  This
     is true for SGI's dial & button box. */
  return (rawValue * 360.0) / __glutDialsResolution[axis];
}

static int
normalizeSpaceballAngle(int axis, int rawValue)
{
  assert(rawValue >= __glutSpaceballRange[axis].min);
  assert(rawValue <= __glutSpaceballRange[axis].min +
    __glutSpaceballRange[axis].range);
  /* normalize rawValue to between -1800 and 1800 */
  return ((rawValue - __glutSpaceballRange[axis].min) * 3600) /
    __glutSpaceballRange[axis].range - 1800;
}

static int
normalizeSpaceballDelta(int axis, int rawValue)
{
  assert(rawValue >= __glutSpaceballRange[axis].min);
  assert(rawValue <= __glutSpaceballRange[axis].min +
    __glutSpaceballRange[axis].range);
  /* normalize rawValue to between -1000 and 1000 */
  return ((rawValue - __glutSpaceballRange[axis].min) * 2000) /
    __glutSpaceballRange[axis].range - 1000;
}

static void
queryTabletPos(GLUTwindow * window)
{
  XDeviceState *state;
  XInputClass *any;
  XValuatorState *v;
  int i;

  state = XQueryDeviceState(__glutXDisplay, __glutTablet);
  any = state->data;
  for (i = 0; i < state->num_classes; i++) {
    switch (any->class) {
    case ValuatorClass:
      v = (XValuatorState *) any;
      if (v->num_valuators < 2)
        goto end;
      if (window->tabletPos[0] == -1)
        window->tabletPos[0] = normalizeTabletPos(0, v->valuators[0]);
      if (window->tabletPos[1] == -1)
        window->tabletPos[1] = normalizeTabletPos(1, v->valuators[1]);
    }
    any = (XInputClass *) ((char *) any + any->length);
  }
end:
  XFreeDeviceState(state);
}

static void
tabletPosChange(GLUTwindow * window, int first, int count, int *data)
{
  int i, value, genEvent = 0;

  for (i = first; i < first + count; i++) {
    switch (i) {
    case 0:            /* X axis */
    case 1:            /* Y axis */
      value = normalizeTabletPos(i, data[i - first]);
      if (value != window->tabletPos[i]) {
        window->tabletPos[i] = value;
        genEvent = 1;
      }
      break;
    }
  }
  if (window->tabletPos[0] == -1 || window->tabletPos[1] == -1)
    queryTabletPos(window);
  if (genEvent)
    (*window->tabletMotion) (window->tabletPos[0], window->tabletPos[1]);
}

int
__glutProcessDeviceEvents(XEvent * event)
{
  GLUTwindow *window;

  /* XXX Ugly code fan out. */

  /* Can't use switch/case since X Input event types are
     dynamic. */

  if (__glutDeviceMotionNotify && event->type == __glutDeviceMotionNotify) {
    XDeviceMotionEvent *devmot = (XDeviceMotionEvent *) event;

    window = __glutGetWindow(devmot->window);
    if (window) {
      if (__glutTablet
        && devmot->deviceid == __glutTablet->device_id
        && window->tabletMotion) {
        tabletPosChange(window, devmot->first_axis, devmot->axes_count,
          devmot->axis_data);
      } else if (__glutDials
          && devmot->deviceid == __glutDials->device_id
        && window->dials) {
        int i, first = devmot->first_axis, count = devmot->axes_count;

        for (i = first; i < first + count; i++)
          (*window->dials) (i + 1, normalizeDialAngle(i, devmot->axis_data[i - first]));
      } else if (__glutSpaceball
        && devmot->deviceid == __glutSpaceball->device_id) {
        /* XXX Assume that space ball motion events come in as
           all the first 6 axes.  Assume first 3 axes are XYZ
           translations; second 3 axes are XYZ rotations. */
        if (devmot->first_axis == 0 && devmot->axes_count == 6) {
          if (window->spaceMotion)
            (*window->spaceMotion) (normalizeSpaceballDelta(0, devmot->axis_data[0]),
              normalizeSpaceballDelta(1, devmot->axis_data[1]),
              normalizeSpaceballDelta(2, devmot->axis_data[2]));
          if (window->spaceRotate)
            (*window->spaceRotate) (normalizeSpaceballAngle(3, devmot->axis_data[3]),
              normalizeSpaceballAngle(4, devmot->axis_data[4]),
              normalizeSpaceballAngle(5, devmot->axis_data[5]));
        }
      }
      return 1;
    }
  } else if (__glutDeviceButtonPress && event->type == __glutDeviceButtonPress) {
    XDeviceButtonEvent *devbtn = (XDeviceButtonEvent *) event;

    window = __glutGetWindow(devbtn->window);
    if (window) {
      if (__glutTablet
        && devbtn->deviceid == __glutTablet->device_id
        && window->tabletButton
        && devbtn->first_axis == 0
        && devbtn->axes_count == 2) {
        tabletPosChange(window, devbtn->first_axis, devbtn->axes_count,
          devbtn->axis_data);
        (*window->tabletButton) (devbtn->button, GLUT_DOWN,
          window->tabletPos[0], window->tabletPos[1]);
      } else if (__glutDials
          && devbtn->deviceid == __glutDials->device_id
        && window->buttonBox) {
        (*window->buttonBox) (devbtn->button, GLUT_DOWN);
      } else if (__glutSpaceball
          && devbtn->deviceid == __glutSpaceball->device_id
        && window->spaceButton) {
        (*window->spaceButton) (devbtn->button, GLUT_DOWN);
      }
      return 1;
    }
  } else if (__glutDeviceButtonRelease && event->type == __glutDeviceButtonRelease) {
    XDeviceButtonEvent *devbtn = (XDeviceButtonEvent *) event;

    window = __glutGetWindow(devbtn->window);
    if (window) {
      if (__glutTablet
        && devbtn->deviceid == __glutTablet->device_id
        && window->tabletButton
        && devbtn->first_axis == 0
        && devbtn->axes_count == 2) {
        tabletPosChange(window, devbtn->first_axis, devbtn->axes_count,
          devbtn->axis_data);
        (*window->tabletButton) (devbtn->button, GLUT_UP,
          window->tabletPos[0], window->tabletPos[1]);
      } else if (__glutDials
          && devbtn->deviceid == __glutDials->device_id
        && window->buttonBox) {
        (*window->buttonBox) (devbtn->button, GLUT_UP);
      } else if (__glutSpaceball
          && devbtn->deviceid == __glutSpaceball->device_id
        && window->spaceButton) {
        (*window->spaceButton) (devbtn->button, GLUT_UP);
      }
      return 1;
    }
  }
  return 0;
}

static GLUTxEventParser eventParser =
{__glutProcessDeviceEvents, NULL};

static void
addDeviceEventParser(void)
{
  static Bool been_here = False;

  if (been_here)
    return;
  been_here = True;
  __glutXRegisterEventParser(&eventParser);
}

static int
probeDevices(void)
{
  static Bool been_here = False;
  static int support;
  XExtensionVersion *version;
  XDeviceInfoPtr device_info, device;
  XAnyClassPtr any;
  XButtonInfoPtr b;
  XValuatorInfoPtr v;
  XAxisInfoPtr a;
  int num_dev, btns, dials;
  int i, j, k;

  if (been_here) {
    return support;
  }
  been_here = True;
  version = XGetExtensionVersion(__glutXDisplay, "XInputExtension");
  if (version == NULL || ((int) version) == NoSuchExtension) {
    support = 0;
    return support;
  }
  XFree(version);
  device_info = XListInputDevices(__glutXDisplay, &num_dev);
  if (device_info) {
    for (i = 0; i < num_dev; i++) {
      /* XXX These are SGI names for these devices;
         unfortunately, no good standard exists for standard
         types of X input extension devices. */

      device = &device_info[i];
      any = (XAnyClassPtr) device->inputclassinfo;

      if (!__glutSpaceball && !strcmp(device->name, "spaceball")) {
        v = NULL;
        b = NULL;
        for (j = 0; j < device->num_classes; j++) {
          switch (any->class) {
          case ButtonClass:
            b = (XButtonInfoPtr) any;
            btns = b->num_buttons;
            break;
          case ValuatorClass:
            v = (XValuatorInfoPtr) any;
            /* Sanity check: at least 6 valuators? */
            if (v->num_axes < NUM_SPACEBALL_AXIS)
              goto skip_device;
            a = (XAxisInfoPtr) ((char *) v + sizeof(XValuatorInfo));
            for (k = 0; k < NUM_SPACEBALL_AXIS; k++, a++) {
              __glutSpaceballRange[k].min = a->min_value;
              __glutSpaceballRange[k].range = a->max_value - a->min_value;
            }
            break;
          }
          any = (XAnyClassPtr) ((char *) any + any->length);
        }
        if (v) {
          __glutSpaceball = XOpenDevice(__glutXDisplay, device->id);
          if (__glutSpaceball) {
            __glutNumSpaceballButtons = btns;
            addDeviceEventParser();
          }
        }
      } else if (!__glutDials && !strcmp(device->name, "dial+buttons")) {
        v = NULL;
        b = NULL;
        for (j = 0; j < device->num_classes; j++) {
          switch (any->class) {
          case ButtonClass:
            b = (XButtonInfoPtr) any;
            btns = b->num_buttons;
            break;
          case ValuatorClass:
            v = (XValuatorInfoPtr) any;
            /* Sanity check: at least 8 valuators? */
            if (v->num_axes < NUM_DIALS_AXIS)
              goto skip_device;
            dials = v->num_axes;
	    __glutDialsResolution = (int *) malloc(sizeof(int) * dials);
            a = (XAxisInfoPtr) ((char *) v + sizeof(XValuatorInfo));
            for (k = 0; k < dials; k++, a++) {
              __glutDialsResolution[k] = a->resolution;
            }
            break;
          }
          any = (XAnyClassPtr) ((char *) any + any->length);
        }
        if (v) {
          __glutDials = XOpenDevice(__glutXDisplay, device->id);
          if (__glutDials) {
            __glutNumButtonBoxButtons = btns;
	    __glutNumDials = dials;
            addDeviceEventParser();
          }
        }
      } else if (!__glutTablet && !strcmp(device->name, "tablet")) {
        v = NULL;
        b = NULL;
        for (j = 0; j < device->num_classes; j++) {
          switch (any->class) {
          case ButtonClass:
            b = (XButtonInfoPtr) any;
            btns = b->num_buttons;
            break;
          case ValuatorClass:
            v = (XValuatorInfoPtr) any;
            /* Sanity check: exactly 2 valuators? */
            if (v->num_axes != NUM_TABLET_AXIS)
              goto skip_device;
            a = (XAxisInfoPtr) ((char *) v + sizeof(XValuatorInfo));
            for (k = 0; k < NUM_TABLET_AXIS; k++, a++) {
              __glutTabletRange[k].min = a->min_value;
              __glutTabletRange[k].range = a->max_value - a->min_value;
            }
            break;
          }
          any = (XAnyClassPtr) ((char *) any + any->length);
        }
        if (v) {
          __glutTablet = XOpenDevice(__glutXDisplay, device->id);
          if (__glutTablet) {
            __glutNumTabletButtons = btns;
            addDeviceEventParser();
          }
        }
      } else if (!strcmp(device->name, "mouse")) {
	for (j = 0; j < device->num_classes; j++) {
	  if (any->class == ButtonClass) {
	    b = (XButtonInfoPtr) any;
	    __glutNumMouseButtons = b->num_buttons;
	  }
	  any = (XAnyClassPtr) ((char *) any + any->length);
	}
      }
    skip_device:;
    }
    XFreeDeviceList(device_info);
  }
  /* X Input extension might be supported, but only if there is
     a tablet, dials, or spaceball do we claim devices are
     supported. */
  support = __glutTablet || __glutDials || __glutSpaceball;
  return support;
}

/*
  Update the mask of devices to check for input from
  */
void
__glutOsUpdateInputDeviceMask(GLUTwindow * window)
{
  /* 4 (dial and buttons) + 4 (tablet locator and buttons) + 4
     (Spaceball buttons and axis) = 12 */
  XEventClass event_list[12];
  int rc, num_events;

  rc = probeDevices();
  if (rc) {
    num_events = 0;
    if (__glutTablet) {
      if (window->tabletMotion) {
        DeviceMotionNotify(__glutTablet, __glutDeviceMotionNotify,
          event_list[num_events]);
        num_events++;
      }
      if (window->tabletButton) {
        DeviceButtonPress(__glutTablet, __glutDeviceButtonPress,
          event_list[num_events]);
        num_events++;
        DeviceButtonRelease(__glutTablet, __glutDeviceButtonRelease,
          event_list[num_events]);
        num_events++;
      }
      if (window->tabletMotion || window->tabletButton) {
        DeviceStateNotify(__glutTablet, __glutDeviceStateNotify,
          event_list[num_events]);
        num_events++;
      }
    }
    if (__glutDials) {
      if (window->dials) {
        DeviceMotionNotify(__glutDials, __glutDeviceMotionNotify,
          event_list[num_events]);
        num_events++;
      }
      if (window->buttonBox) {
        DeviceButtonPress(__glutDials, __glutDeviceButtonPress,
          event_list[num_events]);
        num_events++;
        DeviceButtonRelease(__glutDials, __glutDeviceButtonRelease,
          event_list[num_events]);
        num_events++;
      }
      if (window->dials || window->buttonBox) {
        DeviceStateNotify(__glutDials, __glutDeviceStateNotify,
          event_list[num_events]);
        num_events++;
      }
    }
    if (__glutSpaceball) {
      if (window->spaceMotion || window->spaceRotate) {
        DeviceMotionNotify(__glutSpaceball, __glutDeviceMotionNotify,
          event_list[num_events]);
        num_events++;
      }
      if (window->spaceButton) {
        DeviceButtonPress(__glutSpaceball, __glutDeviceButtonPress,
          event_list[num_events]);
        num_events++;
        DeviceButtonRelease(__glutSpaceball, __glutDeviceButtonRelease,
          event_list[num_events]);
        num_events++;
      }
      if (window->spaceMotion || window->spaceRotate || window->spaceButton) {
        DeviceStateNotify(__glutSpaceball, __glutDeviceStateNotify,
          event_list[num_events]);
        num_events++;
      }
    }
    XSelectExtensionEvent(__glutXDisplay, window->owin,
      event_list, num_events);
  } else {
    /* X Input extension not supported; no chance for exotic
       input devices. */
  }
}

/*
  Retrieve OS-specific device information
  */
int
__glutOsDeviceGet(GLenum param)
{
  probeDevices();
  switch (param) {
  case GLUT_HAS_KEYBOARD:
  case GLUT_HAS_MOUSE:
    /* Assume X always has mouse and keyboard. */
    return 1;
  case GLUT_HAS_SPACEBALL:
    return __glutSpaceball != NULL;
  case GLUT_HAS_DIAL_AND_BUTTON_BOX:
    return __glutDials != NULL;
  case GLUT_HAS_TABLET:
    return __glutTablet != NULL;
  case GLUT_NUM_MOUSE_BUTTONS:
    return __glutNumMouseButtons;
  case GLUT_NUM_SPACEBALL_BUTTONS:
    return __glutNumSpaceballButtons;
  case GLUT_NUM_BUTTON_BOX_BUTTONS:
    return __glutNumButtonBoxButtons;
  case GLUT_NUM_DIALS:
    return __glutNumDials;
  case GLUT_NUM_TABLET_BUTTONS:
    return __glutNumTabletButtons;
  }
}

#endif /* GLUT_API_VERSION */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\wgltpal.c ===
/* Copyright (c) Mark J. Kilgard and Andrew L. Bliss, 1994-1995. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "gltint.h"

/*
  Return the size of the colormap for the associated surface
  Only called for color indexed surfaces
  */
int __glutOsColormapSize(GLUTosSurface surf)
{
    /* Limit colormap size for deep screens */
    return surf->cColorBits > 8 ? 256 : (1 << surf->cColorBits);
}

/*
  Create an "empty" palette
  Only called for color indexed surfaces
  */
GLUTosColormap __glutOsCreateEmptyColormap(GLUTosSurface surf)
{
    LOGPALETTE *logpal;
    int i, n, resrv;
    HPALETTE stock;
    GLUTosColormap cmap;

    cmap = (GLUTosColormap)malloc(sizeof(GLUTwinColormap));
    if (cmap == NULL)
    {
        return GLUT_OS_INVALID_COLORMAP;
    }

    n = __glutOsColormapSize(surf);
    
    logpal = (LOGPALETTE *)malloc(sizeof(LOGPALETTE) +
                                  sizeof(PALETTEENTRY)*(n-1));
    if (logpal == NULL)
    {
        free(cmap);
        return GLUT_OS_INVALID_COLORMAP;
    }

    cmap->use_static = (BOOL)(surf->dwFlags & PFD_NEED_SYSTEM_PALETTE);
    
    logpal->palVersion = 0x300;
    logpal->palNumEntries = n;

    /* Fill in the stock palette entries so that this palette won't clash
       with the default palette */
    stock = GetStockObject(DEFAULT_PALETTE);
    resrv = GetPaletteEntries(stock, 0, 0, NULL);
    GetPaletteEntries(stock, 0, resrv, logpal->palPalEntry);

    /* Zero out everything else */
    if (resrv < n)
    {
        memset(logpal->palPalEntry+resrv, 0, sizeof(PALETTEENTRY)*(n-resrv));
    }

    if (cmap->use_static)
    {
        /* If we're taking over the static colors, ensure that the first
           entry is black and the last entry is white.  Also, force
           other whites to be ignored */
        for (i = 0; i < resrv; i++)
        {
            if (i != n-1 &&
                logpal->palPalEntry[i].peRed == 0xff &&
                logpal->palPalEntry[i].peGreen == 0xff &&
                logpal->palPalEntry[i].peBlue == 0xff)
            {
                logpal->palPalEntry[i].peFlags |= PC_RESERVED;
            }
        }
        
        logpal->palPalEntry[0].peRed = 0;
        logpal->palPalEntry[0].peGreen = 0;
        logpal->palPalEntry[0].peBlue = 0;
        logpal->palPalEntry[0].peFlags = 0;

        logpal->palPalEntry[n-1].peRed = 0xff;
        logpal->palPalEntry[n-1].peGreen = 0xff;
        logpal->palPalEntry[n-1].peBlue = 0xff;
        logpal->palPalEntry[n-1].peFlags = 0;

        /* Set other colors as remappable */
        for (i = 1; i < n-1; i++)
        {
            logpal->palPalEntry[i].peFlags |= PC_NOCOLLAPSE;
        }
    }
        
    cmap->hpal = CreatePalette(logpal);
    free(logpal);

    if (cmap->hpal == 0)
    {
        __glutWarning("Unable to create empty palette, %d.",
                      GetLastError());
        
        free(cmap);
        cmap = GLUT_OS_INVALID_COLORMAP;
    }
    
    return cmap;
}

/*
  Frees up a palette
  */
void __glutOsDestroyColormap(GLUTosColormap cmap)
{
    DeleteObject(cmap->hpal);
    free(cmap);
}

/*
  Set a color in the given colormap
  Values are already clamped
  */
void __glutOsSetColor(GLUTosColormap cmap, int ndx,
                      GLfloat red, GLfloat green, GLfloat blue)
{
    PALETTEENTRY pe;

    /* If we're using the static colors then black and white cannot
       be replaced */
    if (cmap->use_static &&
        (ndx == 0 ||
         (UINT)ndx == GetPaletteEntries(cmap->hpal, 0, 0, NULL)-1))
    {
        return;
    }
        
    pe.peRed = (BYTE)(red*(float)255.0 + (float)0.5);
    pe.peGreen = (BYTE)(green*(float)255.0 + (float)0.5);
    pe.peBlue = (BYTE)(blue*(float)255.0 + (float)0.5);

    if (cmap->use_static)
    {
        pe.peFlags = PC_NOCOLLAPSE;
        
        /* If we're using the static colors we don't want to allow another
           white to be mapped in a slot other than the last entry because
           it will disturb color translation.
           If this happens, force the color to be ignored */
        if (pe.peRed == 0xff && pe.peGreen == 0xff && pe.peBlue == 0xff)
        {
            pe.peFlags |= PC_RESERVED;
        }
    }
    else
    {
        pe.peFlags = 0;
    }

    SetPaletteEntries(cmap->hpal, ndx, 1, &pe);
}

/*
  Return whether the given surface is color indexed or not
  */
GLboolean __glutOsSurfaceHasColormap(GLUTosSurface surf)
{
    if (surf->iPixelType == PFD_TYPE_RGBA)
    {
        return GL_FALSE;
    }
    else
    {
        return GL_TRUE;
    }
}

#ifdef GAMMA_1_0
/* Color mappings with no gamma correction */
static unsigned char three_to_eight[8] =
{
    0, 0111 >> 1, 0222 >> 1, 0333 >> 1, 0444 >> 1, 0555 >> 1, 0666 >> 1, 0377
};

static unsigned char two_to_eight[4] =
{
    0, 0x55, 0xaa, 0xff
};

static int default_override[13] =
{
    0, 4, 32, 36, 128, 132, 160, 173, 181, 245, 247, 164, 156
};

#endif

/* The following tables use gamma 1.4 */
static unsigned char three_to_eight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};

static unsigned char two_to_eight[4] =
{
    0, 116, 191, 255
};

static unsigned char one_to_eight[2] =
{
    0, 255
};

static unsigned char *expansion_tables[3] =
{
    one_to_eight, two_to_eight, three_to_eight
};

/* Should be dynamically determined */
#define DEFAULT_COLORS 20

static int default_override[DEFAULT_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    254, 164, 91, 7, 56, 63, 192, 199, 248, 255
};

static unsigned char
ComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return one_to_eight[val & 1];
    case 2:
        return two_to_eight[val & 3];
    case 3:
        return three_to_eight[val & 7];
    }
}

static unsigned char
BestComponentMatch(unsigned char comp, int nbits)
{
    unsigned char best, bdiff, cur, diff;
    unsigned char *table;

    best = 0;
    bdiff = 255;
    table = expansion_tables[nbits-1];
    for (cur = 0; cur < (1 << nbits); cur++)
    {
        if (*table < comp)
        {
            diff = comp-*table;
        }
        else
        {
            diff = *table-comp;
        }
        if (diff < bdiff)
        {
            bdiff = diff;
            best = cur;
        }
        table++;
    }
    return best;
}

static PALETTEENTRY default_palette[DEFAULT_COLORS];
static GLboolean default_set = GL_FALSE;

static void
FillRgbPaletteEntries(PIXELFORMATDESCRIPTOR *pfd,
                      BOOL use_static,
                      PALETTEENTRY *pe,
                      int n)
{
    PALETTEENTRY *ent;
    int i;
    int idx;
    BYTE flags;

    if (!default_set)
    {
        HPALETTE stock;

        stock = GetStockObject(DEFAULT_PALETTE);
        GetPaletteEntries(stock, 0, DEFAULT_COLORS, default_palette);

        for (i = 0; i < DEFAULT_COLORS; i++)
        {
            idx =
                (BestComponentMatch(default_palette[i].peRed,
                                    pfd->cRedBits) << pfd->cRedShift) |
                (BestComponentMatch(default_palette[i].peGreen,
                                    pfd->cGreenBits) << pfd->cGreenShift) |
                (BestComponentMatch(default_palette[i].peBlue,
                                    pfd->cBlueBits) << pfd->cBlueShift);

            /* Avoid replacing black and white with colors other than
               black or white */
            if (idx == 0xff &&
                (default_palette[i].peRed != 0xff ||
                 default_palette[i].peGreen != 0xff ||
                 default_palette[i].peBlue != 0xff))
            {
                idx--;
            }
            if (idx == 0 &&
                (default_palette[i].peRed != 0 ||
                 default_palette[i].peGreen != 0 ||
                 default_palette[i].peBlue != 0))
            {
                idx++;
            }

            default_override[i] = idx;
        }
        
        default_set = GL_TRUE;
    }

    /* If we own the static colors then we can allow colors to remap */
    if (use_static)
    {
        flags = PC_NOCOLLAPSE;
    }
    else
    {
        flags = 0;
    }
    
    /* Compute palette entries using the bit counts and shifts
       in the pixel format */
    ent = pe;
    for (i = 0; i < n; i++)
    {
        ent->peRed = ComponentFromIndex(i, pfd->cRedBits,
                                        pfd->cRedShift);
        ent->peGreen = ComponentFromIndex(i, pfd->cGreenBits,
                                          pfd->cGreenShift);
        ent->peBlue = ComponentFromIndex(i, pfd->cBlueBits,
                                         pfd->cBlueShift);
        ent->peFlags = flags;
        ent++;
    }

    if (use_static)
    {
        /* Force black and white to be unmappable */
        pe[0].peFlags = 0;
        pe[n-1].peFlags = 0;
    }
    else
    {
        /* Replace key entries in the palette with default colors in
           an attempt to provide a good looking palette that still contains
           the system default colors */
        for (i = 0; i < DEFAULT_COLORS; i++)
        {
            pe[default_override[i]] = default_palette[i];
        }
    }
}

/*
  Create a colormap appropriate for the given surface
  Only called for non-color-indexed surfaces
  */
GLUTosColormap __glutOsGetSurfaceColormap(GLUTosSurface surf)
{
    LOGPALETTE *logpal;
    int n;
    GLUTosColormap cmap;

    cmap = GLUT_OS_INVALID_COLORMAP;
    
    if (surf->dwFlags & PFD_NEED_PALETTE)
    {
        cmap = (GLUTosColormap)malloc(sizeof(GLUTwinColormap));
        if (cmap == NULL)
        {
            return GLUT_OS_INVALID_COLORMAP;
        }
    
        n = __glutOsColormapSize(surf);
        logpal = (LOGPALETTE *)malloc(sizeof(LOGPALETTE) +
                                      (n-1) * sizeof(PALETTEENTRY));
        if (logpal == NULL)
        {
            free(cmap);
            return GLUT_OS_INVALID_COLORMAP;
        }

        cmap->use_static = (BOOL)(surf->dwFlags & PFD_NEED_SYSTEM_PALETTE);
        
        logpal->palVersion = 0x300;
        logpal->palNumEntries = n;
            
        FillRgbPaletteEntries(surf, cmap->use_static, logpal->palPalEntry, n);

        cmap->hpal = CreatePalette(logpal);
        free(logpal);
        
        if (cmap->hpal == 0)
        {
            free(cmap);
            cmap = NULL;
            __glutFatalError("Unable to create colormap for surface.");
        }
    }

    return cmap;
}

#if 0
static void DumpPal(HPALETTE cmap)
{
    PALETTEENTRY pe[256];
    int i, n;
    
    n = GetPaletteEntries(cmap, 0, 0, NULL);
    printf("%p - %d entries\n", cmap, n);
    GetPaletteEntries(cmap, 0, n, pe);
    for (i = 0; i < n; i++)
    {
        printf("%X,%X,%X,%X\n",
               pe[i].peRed, pe[i].peGreen, pe[i].peBlue,
               pe[i].peFlags);
    }
}
#endif
    
#define BLACK PALETTERGB(0, 0, 0)
#define WHITE PALETTERGB(255, 255, 255)
#define NUM_STATIC_COLORS (COLOR_BTNHIGHLIGHT - COLOR_SCROLLBAR + 1)

static COLORREF saved_static_colors[NUM_STATIC_COLORS];
static COLORREF bw_static_colors[NUM_STATIC_COLORS] =
{
    WHITE,  // COLOR_SCROLLBAR
    BLACK,  // COLOR_BACKGROUND
    BLACK,  // COLOR_ACTIVECAPTION
    WHITE,  // COLOR_INACTIVECAPTION
    WHITE,  // COLOR_MENU
    WHITE,  // COLOR_WINDOW
    BLACK,  // COLOR_WINDOWFRAME
    BLACK,  // COLOR_MENUTEXT
    BLACK,  // COLOR_WINDOWTEXT
    WHITE,  // COLOR_CAPTIONTEXT
    WHITE,  // COLOR_ACTIVEBORDER
    WHITE,  // COLOR_INACTIVEBORDER
    WHITE,  // COLOR_APPWORKSPACE
    BLACK,  // COLOR_HIGHLIGHT
    WHITE,  // COLOR_HIGHLIGHTTEXT
    WHITE,  // COLOR_BTNFACE
    BLACK,  // COLOR_BTNSHADOW
    BLACK,  // COLOR_GRAYTEXT
    BLACK,  // COLOR_BTNTEXT
    BLACK,  // COLOR_INACTIVECAPTIONTEXT
    BLACK   // COLOR_BTNHIGHLIGHT
};
static INT static_indices[NUM_STATIC_COLORS] =
{
    COLOR_SCROLLBAR          ,
    COLOR_BACKGROUND         ,
    COLOR_ACTIVECAPTION      ,
    COLOR_INACTIVECAPTION    ,
    COLOR_MENU               ,
    COLOR_WINDOW             ,
    COLOR_WINDOWFRAME        ,
    COLOR_MENUTEXT           ,
    COLOR_WINDOWTEXT         ,
    COLOR_CAPTIONTEXT        ,
    COLOR_ACTIVEBORDER       ,
    COLOR_INACTIVEBORDER     ,
    COLOR_APPWORKSPACE       ,
    COLOR_HIGHLIGHT          ,
    COLOR_HIGHLIGHTTEXT      ,
    COLOR_BTNFACE            ,
    COLOR_BTNSHADOW          ,
    COLOR_GRAYTEXT           ,
    COLOR_BTNTEXT            ,
    COLOR_INACTIVECAPTIONTEXT,
    COLOR_BTNHIGHLIGHT
};

static BOOL GrabStaticEntries(GLUTosWindow win, HDC hdc)
{
    int i;
    BOOL rc = FALSE;

    /* Only do work if there are static entries to grab */
    if (GetSystemPaletteUse(hdc) == SYSPAL_STATIC)
    {
        /* Take possession only if no other app has the static colors.
           How can we tell?  If the return from SetSystemPaletteUse is
           SYSPAL_STATIC, then no other app has the statics.  If it is
           SYSPAL_NOSTATIC, someone else has them and we must fail.

           SetSystemPaletteUse is properly synchronized internally
           so that it is atomic.

           Because we are relying on SetSystemPaletteUse to synchronize things,
           it is important to observe the following order for grabbing and
           releasing:

           Grab        call SetSystemPaletteUse and check for SYSPAL_STATIC
                       save sys color settings
                       set new sys color settings

           Release     restore sys color settings
                       call SetSystemPaletteUse */

        if ( SetSystemPaletteUse( hdc, SYSPAL_NOSTATIC ) == SYSPAL_STATIC )
        {
            /* Save old colors */
            for (i = COLOR_SCROLLBAR; i <= COLOR_BTNHIGHLIGHT; i++)
            {
                saved_static_colors[i - COLOR_SCROLLBAR] = GetSysColor(i);
            }
            
            /* Set up a black and white system color scheme */
            SetSysColors(NUM_STATIC_COLORS, static_indices,
                         bw_static_colors);

            /* Inform all other top-level windows of the system color change */
            SendMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

            rc = TRUE;
        }
        else
        {
            GLUTwindow *window;
            
            /* Try to realize things later */
            window = __glutGetWindow(win);
            if (window)
            {
                __glutPutOnWorkList(window, GLUT_COLORMAP_WORK);
            }
            else
            {
                __glutWarning("Unable to acquire static colors.");
            }
        }
    }

    return rc;
}

static BOOL ReleaseStaticEntries(HDC hdc)
{
    BOOL rc = FALSE;

    /* Only do work if we have taken over the static colors */
    if (GetSystemPaletteUse(hdc) == SYSPAL_NOSTATIC)
    {
        SetSysColors(NUM_STATIC_COLORS, static_indices, saved_static_colors);

        SetSystemPaletteUse( hdc, SYSPAL_STATIC );

        /* Inform all other top-level windows of the system color change */
        SendMessage(HWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0);

        rc = TRUE;
    }

    return rc;
}

void __glutWinRealizeWindowPalette(GLUTosWindow win, GLUTosColormap cmap,
                                   GLboolean force_bg)
{
    HDC hdc;
    BOOL realize;

    if (cmap == GLUT_OS_INVALID_COLORMAP)
    {
        return;
    }

    hdc = __glutWinGetDc(win);
    
    if (cmap->use_static)
    {
        if (!force_bg)
        {
            realize = GrabStaticEntries(win, hdc);
        }
        else
        {
            ReleaseStaticEntries(hdc);
            realize = TRUE;
        }

        if (force_bg || realize)
        {
            UnrealizeObject(cmap->hpal);
            if (SelectPalette(hdc, cmap->hpal, force_bg) == NULL)
            {
                __glutWarning("Unable to select palette, %d.",
                              GetLastError());
            }
            else
            {
                if (RealizePalette(hdc) == GDI_ERROR)
                {
                    __glutWarning("Unable to realize palette, %d.",
                                  GetLastError());
                }
            }
        }
    }
    else
    {
        if (SelectPalette(hdc, cmap->hpal, FALSE) == NULL)
        {
            __glutWarning("Unable to select palette, %d.",
                          GetLastError());
        }
        else
        {
            if (RealizePalette(hdc) == GDI_ERROR)
            {
                __glutWarning("Unable to realize palette, %d.",
                              GetLastError());
            }
        }
    }
        
    __glutWinReleaseDc(win, hdc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\xgltos.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <string.h>
#include <assert.h>
#ifdef __sgi
#include <bstring.h>    /* prototype for bzero used by FD_ZERO */
#endif
#ifdef AIXV3
#include <sys/select.h> /* select system call interface */
#endif
#include <sys/types.h>
#include <sys/time.h>
#include <sys/times.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>  /* for XA_STRING atom */
#include <X11/keysym.h>

#include "gltint.h"

Display *__glutXDisplay = NULL;
int __glutXScreen;
Window __glutXRoot;
Atom __glutXWMDeleteWindow;
XSizeHints __glutXSizeHints = {0};
int __glutXConnectionFD;

static char *display_name = NULL;
static GLboolean synchronize = GL_FALSE;
static unsigned long initial_tick_count = 0;
static double tick_multiplier = 10.0;

static void
OpenXConnection(char *display)
{
  int errorBase, eventBase;

  __glutXDisplay = XOpenDisplay(display);
  if (!__glutXDisplay)
    __glutFatalError("could not open display: %s",
      XDisplayName(display));
  if (synchronize)
    XSynchronize(__glutXDisplay, True);
  if (!glXQueryExtension(__glutXDisplay, &errorBase, &eventBase))
    __glutFatalError(
      "OpenGL GLX extension not supported by display: %s",
      XDisplayName(display));
  __glutXScreen = DefaultScreen(__glutXDisplay);
  __glutXRoot = RootWindow(__glutXDisplay, __glutXScreen);
  __glutXConnectionFD = ConnectionNumber(__glutXDisplay);
  __glutXWMDeleteWindow = XInternAtom(__glutXDisplay,
    "WM_DELETE_WINDOW", False);
}

/*
  Initialize OS-dependent information
  */
void
__glutOsInitialize(void)
{
    struct tms ignored;
    
    OpenXConnection(display_name);
    
    tick_multiplier = 1000.0/(double)sysconf(_SC_CLK_TCK);
    initial_tick_count = (unsigned long)(times(&ignored)*tick_multiplier);
}

/*
  Clean up OS-dependent information
  */
void
__glutOsUninitialize(void)
{
    /* ATTENTION - Cleanup */
}

/*
  Check whether the given OS-specific extension is supported
  */
int
__glutOsIsSupported(char *extension)
{
#if defined(GLX_VERSION_1_1)
  static const char *extensions = NULL;
  const char *start;
  char *where, *terminator;
  int major, minor;

  glXQueryVersion(__glutDisplay, &major, &minor);
  /* Be careful not to call glXQueryExtensionsString if it
     looks like the server doesn't support GLX 1.1.
     Unfortunately, the original GLX 1.0 didn't have the notion 

     of GLX extensions. */
  if ((major == 1 && minor >= 1) || (major > 1)) {
    if (!extensions)
      extensions = glXQueryExtensionsString(__glutDisplay, __glutScreen);
    /* It takes a bit of care to be fool-proof about parsing
       the GLX extensions string.  Don't be fooled by
       sub-strings,  etc. */
    start = extensions;
    while (1) {
      where = strstr(start, extension);
      if (!where)
        return 0;
      terminator = where + strlen(extension);
      if (where == start || *(where - 1) == ' ') {
        if (*terminator == ' ' || *terminator == '\0') {
          return 1;
        }
      }
      start = terminator;
    }
  }
#else
  /* No GLX extensions before GLX 1.1 */
  UNUSED_PARAMETER(extension);
#endif
  return 0;
}

/*
  Operate on any OS-specific arguments
  */
int
__glutOsParseArgument(char **argv, int remaining)
{
  if (!strcmp(argv[0], "-display")) {
    if (remaining < 1) {
      __glutFatalError(
        "follow -display option with X display name.");
    }
    display_name = argv[1];
    return 2;
  } else if (!strcmp(argv[0], "-geometry")) {
    int flags, x, y, width, height;
    if (remaining < 1) {
      __glutFatalError(
        "follow -geometry option with geometry parameter.");
    }
    /* Fix bogus "{width|height} may be used before set"
       warning */
    width = 0;
    height = 0;
    flags = XParseGeometry(argv[1], &x, &y,
      (unsigned int *) &width, (unsigned int *) &height);
    if (WidthValue & flags) {
      /* Careful because X does not allow zero or negative width windows */
      if(width > 0)
        __glutInitWidth = width;
    }
    if (HeightValue & flags) {
      /* Careful because X does not allow zero or negative height windows */
      if(height > 0)
        __glutInitHeight = height;
    }
    glutInitWindowSize(__glutInitWidth, __glutInitHeight);
    if (XValue & flags) {
      if (XNegative & flags)
        x = DisplayWidth(__glutXDisplay, __glutXScreen) +
          x - (__glutInitWidth > 0 ? __glutInitWidth : 0);
      /* Play safe: reject negative X locations */
      if(x >= 0) 
        __glutInitX = x;
    }
    if (YValue & flags) {
      if (YNegative & flags)
        y = DisplayHeight(__glutXDisplay, __glutXScreen) +
          y - (__glutInitHeight > 0 ? __glutInitHeight : 0);
      /* Play safe: reject negative Y locations */
      if(y >= 0) 
	__glutInitY = y;
    }
    glutInitWindowPosition(__glutInitX, __glutInitY);
    return 2;
  } else if (!strcmp(argv[0], "-sync")) {
    synchronize = GL_TRUE;
    return 1;
  }
  return -1;
}

/*
  Retrieve the number of milliseconds since __glutOsInitialize was called
  */
unsigned long
__glutOsElapsedTime(void)
{
    struct tms ignored;

    return (unsigned long)(times(&ignored)*tick_multiplier)-initial_tick_count;
}

/*
  Check and see if there are any pending events
  */
GLboolean
__glutOsEventsPending(void)
{
    return (GLboolean)XPending(__glutXDisplay);
}

#if (GLUT_API_VERSION >= 2)

static GLUTxEventParser *eventParserList = NULL;

/* __glutRegisterEventParser allows another module to register
   to intercept X events types not otherwise acted on by the
   GLUT processEvents routine.  The X Input extension support
   code uses an event parser for handling X Input extension
   events.  */

void
__glutXRegisterEventParser(GLUTxEventParser * parser)
{
  parser->next = eventParserList;
  eventParserList = parser;
}

#endif /* (GLUT_API_VERSION >= 2) */

/*
  Process all current pending events
  Initially waits on an event so if this is called when
  __glutOsEventsPending is GL_FALSE, it will block until an event comes in
  */
void
__glutOsProcessEvents(void)
{
  XEvent event, ahead;
  GLUTwindow *window;
  GLsizei width, height;
#if (GLUT_API_VERSION >= 2)
  GLUTxEventParser *parser;
#endif

  do {
    XNextEvent(__glutXDisplay, &event);
    switch (event.type) {
    case MappingNotify:
      XRefreshKeyboardMapping((XMappingEvent *) & event);
      break;
    case ConfigureNotify:
      window = __glutGetWindow(event.xconfigure.window);
      if (window) {
        width = event.xconfigure.width;
        height = event.xconfigure.height;
        if (width != window->width || height != window->height) {
          window->width = width;
          window->height = height;
          __glutSetWindow(window);
          (*window->reshape) (width, height);
        }
      }
      break;
    case Expose:
      /* compress expose events */
      while (XEventsQueued(__glutXDisplay, QueuedAfterReading)
        > 0) {
        XPeekEvent(__glutXDisplay, &ahead);
        if (ahead.type != Expose ||
          ahead.xexpose.window != event.xexpose.window)
          break;
        XNextEvent(__glutXDisplay, &event);
      }
      if (event.xexpose.count == 0) {
        GLUTmenu *menu;

        if (__glutMappedMenu &&
          (menu = __glutXGetMenu(event.xexpose.window))) {
          __glutXPaintMenu(menu);
        } else {
          window = __glutGetWindow(event.xexpose.window);
          if (window) {
            __glutPostRedisplay(window);
          }
        }
      } else {
        /* there are more exposes to read; wait to redisplay */
      }
      break;
    case ButtonPress:
    case ButtonRelease:
      if (__glutMappedMenu && event.type == ButtonRelease) {
        __glutXFinishMenu();
        if (__glutMenuStateFunc) {
          __glutSetWindow(__glutMenuWindow);
          __glutSetMenu(__glutMappedMenu);
          (*__glutMenuStateFunc) (GLUT_MENU_NOT_IN_USE);
        }
      } else {
        if (__glutMappedMenu &&
          __glutXGetMenu(event.xbutton.window)) {
          window = __glutMenuWindow;
        } else {
          window = __glutGetWindow(event.xbutton.window);
        }
        if (window) {
          GLUTmenu *menu;

          if (window->menu[event.xbutton.button - 1] != 0) {
            menu = __glutGetMenuByNum(
              window->menu[event.xbutton.button - 1]);
            if (menu) {
              if (event.type == ButtonPress) {
                __glutXStartMenu(menu, window,
                  event.xbutton.x_root, event.xbutton.y_root);
              }
            }
          }
            
          if (!__glutMappedMenu) {
            if (window->mouse) {
              __glutSetWindow(window);
              (*window->mouse) (event.xbutton.button - 1,
                event.type == ButtonRelease ?
                GLUT_UP : GLUT_DOWN,
                event.xbutton.x, event.xbutton.y);
            }
          } else {
            /* Discard button press and release events when
               menu is up that didn't affect the posted menu. */
          }
        }
      }
      break;
    case MotionNotify:
      if (!__glutMappedMenu) {
        window = __glutGetWindow(event.xmotion.window);
        if (window) {
          /* If motion function registered _and_ buttons held *
             down, call motion function...  */
          if (window->motion && event.xmotion.state &
            (Button1Mask | Button2Mask | Button3Mask)) {
            __glutSetWindow(window);
            (*window->motion) (event.xmotion.x, event.xmotion.y);
          }
          /* If passive motion function registered _and_
             buttons not held down, call passive motion
             function...  */
          else if (window->passive &&
              ((event.xmotion.state &
                  (Button1Mask | Button2Mask | Button3Mask)) ==
              0)) {
            __glutSetWindow(window);
            (*window->passive) (event.xmotion.x,
              event.xmotion.y);
          }
        }
      }
      break;
    case KeyPress:
      if (!__glutMappedMenu) {
        window = __glutGetWindow(event.xkey.window);
        if (window && window->keyboard) {
          char tmp[1];
          int rc;

          rc = XLookupString(&event.xkey, tmp, sizeof(tmp),
            NULL, NULL);
          if (rc) {
            __glutSetWindow(window);
            (*window->keyboard) (tmp[0],
              event.xkey.x, event.xkey.y);
          }
#if (GLUT_API_VERSION >= 2)
          else if (window->special) {
            KeySym ks;
            int key;

            ks = XLookupKeysym((XKeyEvent *) & event, 0);
            /* XXX Verbose, but makes no assumptions about
               keysym layout. */
            switch (ks) {
              /* function keys */
            case XK_F1:
              key = GLUT_KEY_F1;
              break;
            case XK_F2:
              key = GLUT_KEY_F2;
              break;
            case XK_F3:
              key = GLUT_KEY_F3;
              break;
            case XK_F4:
              key = GLUT_KEY_F4;
              break;
            case XK_F5:
              key = GLUT_KEY_F5;
              break;
            case XK_F6:
              key = GLUT_KEY_F6;
              break;
            case XK_F7:
              key = GLUT_KEY_F7;
              break;
            case XK_F8:
              key = GLUT_KEY_F8;
              break;
            case XK_F9:
              key = GLUT_KEY_F9;
              break;
            case XK_F10:
              key = GLUT_KEY_F10;
              break;
            case XK_F11:
              key = GLUT_KEY_F11;
              break;
            case XK_F12:
              key = GLUT_KEY_F12;
              break;
              /* directional keys */
            case XK_Left:
              key = GLUT_KEY_LEFT;
              break;
            case XK_Up:
              key = GLUT_KEY_UP;
              break;
            case XK_Right:
              key = GLUT_KEY_RIGHT;
              break;
            case XK_Down:
              key = GLUT_KEY_DOWN;
              break;
            case XK_Prior: /* same as X11R6's XK_Page_Up */
              key = GLUT_KEY_PAGE_UP;
              break;
            case XK_Next: /* same as X11R6's XK_Page_Down */
              key = GLUT_KEY_PAGE_DOWN;
              break;
            case XK_Home:
              key = GLUT_KEY_HOME;
              break;
            case XK_End:
              key = GLUT_KEY_END;
              break;
            case XK_Insert:
              key = GLUT_KEY_INSERT;
              break;
            default:
              goto skip;
            }
            __glutSetWindow(window);
            (*window->special) (key, event.xkey.x, event.xkey.y);
          skip:;
          }
#endif
        }
      } else {
        /* Discard key strokes while menu in use. */
      }
      break;
    case EnterNotify:
    case LeaveNotify:
      if (__glutMappedMenu) {
        GLUTxMenuItem *item;
        int num;

        item = __glutXGetMenuItem(__glutMappedMenu,
          event.xcrossing.window, &num);
        if (item) {
          __glutXMenuItemEnterOrLeave(item, num, event.type);
        }
      } else {
        window = __glutGetWindow(event.xcrossing.window);
        if (window && window->entry) {
          __glutSetWindow(window);
          (*window->entry) (event.type == EnterNotify ?
            GLUT_ENTERED : GLUT_LEFT);
        }
      }
      break;
    case MapNotify:
    case UnmapNotify:
      /* "event.xmap.window" is safely assumed to be the same
         element as "event.xunmap.window" */
      window = __glutGetWindow(event.xmap.window);
      if (window) {
        window->map_state = (event.type != UnmapNotify);
        if (window->visibility) {
          if (window->map_state != window->vis_state) {
            window->vis_state = window->map_state;
            __glutSetWindow(window);
            (*window->visibility) (window->vis_state ?
              GLUT_VISIBLE : GLUT_NOT_VISIBLE);
          }
        }
      }
      break;
    case VisibilityNotify:
      window = __glutGetWindow(event.xvisibility.window);
      if (window && window->visibility) {
        int vis_state =
        (event.xvisibility.state != VisibilityFullyObscured);

        if (vis_state != window->vis_state) {
          window->vis_state = vis_state;
          __glutSetWindow(window);
          (*window->visibility) (vis_state ?
            GLUT_VISIBLE : GLUT_NOT_VISIBLE);
        }
      }
      break;
    case ClientMessage:
      if (event.xclient.data.l[0] == __glutXWMDeleteWindow)
        exit(0);
      break;
#if (GLUT_API_VERSION >= 2)
    default:
      /* Pass events not directly handled by the GLUT main
         event loop to any event parsers that have been
         registered.  In this way, X Input extension events are 

         passed to the correct handler without forcing all GLUT 

         programs to support X Input event handling. */
      parser = eventParserList;
      while (parser) {
        if ((*parser->func) (&event))
          break;
        parser = parser->next;
      }
      break;
#endif
    }
  }
  while (XPending(__glutXDisplay));
}

/*
  Wait for an event to come in or the given time to arrive
  */
void
__glutOsWaitForEvents(unsigned long timeout_ms)
{
  static struct timeval zerotime =
  {0, 0};
  struct timeval waittime;
  unsigned long now;
  fd_set fds;
  int rc;

  /* flush X protocol since XPending does not do this
     implicitly */
  XFlush(__glutXDisplay);
  FD_ZERO(&fds);
  FD_SET(__glutXConnectionFD, &fds);
  now = __glutOsElapsedTime();
  if (now < timeout_ms) {
    timeout_ms -= now;
    waittime.tv_sec = (long)(timeout_ms / 1000);
    waittime.tv_usec = (long)((timeout_ms - waittime.tv_sec * 1000) * 1000);
  } else {
    waittime = zerotime;
  }
  rc = select(__glutXConnectionFD + 1, &fds,
    NULL, NULL, &waittime);
  if (rc < 0 && errno != EINTR)
    __glutFatalError("select error.");
}

static int
findColormaps(GLUTwindow * window,
  GLUTosWindow * winlist, GLUTosColormap * cmaplist, int num, int max)
{
  GLUTwindow *child;
  int i;

  /* do not allow more entries that maximum number of
     colormaps! */
  if (num >= max)
    return num;
  /* is cmap for this window already on the list? */
  for (i = 0; i < num; i++) {
    if (cmaplist[i] == window->ocmap)
      goto alreadyListed;
  }
  /* not found on the list; add colormap and window */
  winlist[num] = window->owin;
  cmaplist[num] = window->ocmap;
  num++;
  /* recursively search children */
alreadyListed:
  child = window->children;
  while (child) {
    num = findColormaps(child, winlist, cmaplist, num, max);
    child = child->siblings;
  }
  return num;
}

static void
__glutEstablishColormapsProperty(GLUTwindow * window)
{
  Window *winlist;
  Colormap *cmaplist;
  Atom atom;
  int maxcmaps, num;

  assert(!window->parent);
  maxcmaps = MaxCmapsOfScreen(ScreenOfDisplay(__glutXDisplay,
      __glutXScreen));
  /* For portability reasons we don't use alloca for winlist
     and cmaplist, but we could. */
  winlist = (Window *) malloc(maxcmaps * sizeof(Window));
  cmaplist = (Colormap *) malloc(maxcmaps * sizeof(Colormap));
  num = findColormaps(window, winlist, cmaplist, 0, maxcmaps);
  if (num < 2) {
    /* property no longer needed; remove it */
    atom = XInternAtom(__glutXDisplay,
      "WM_COLORMAP_WINDOWS", False);
    if (atom == None) {
      /* XXX warning? */
      return;
    }
    XDeleteProperty(__glutXDisplay, window->owin, atom);
  } else {
    XSetWMColormapWindows(__glutXDisplay, window->owin,
      winlist, num);
    /* XXX check XSetWMColormapWindows status? */
  }
  /* For portability reasons we don't use alloca for winlist
     and cmaplist, but we could. */
  free(winlist);
  free(cmaplist);
}

/*
  Process any deferred work items
  */
void
__glutOsProcessWindowWork(GLUTwindow *window)
{
  /* be sure to set event mask *BEFORE* map window is done */
  if (window->work_mask & GLUT_EVENT_MASK_WORK) {
    XSetWindowAttributes attrs;

    attrs.event_mask = window->event_mask;
    XChangeWindowAttributes(__glutXDisplay, window->owin,
      CWEventMask, &attrs);
  }
#if (GLUT_API_VERSION >= 2)
    /* be sure to set device mask *BEFORE* map window is done */
    if (window->work_mask & GLUT_DEVICE_MASK_WORK) {
      (*__glutUpdateInputDeviceMaskFunc) (window);
    }
#endif
  /* be sure to configure window *BEFORE* map window is
     done */
  if (window->work_mask & GLUT_CONFIGURE_WORK) {
    XWindowChanges changes;

    changes.x = window->desired_x;
    changes.y = window->desired_y;
    changes.width = window->desired_width;
    changes.height = window->desired_height;
    changes.stack_mode = window->desired_stack;
    XConfigureWindow(__glutXDisplay, window->owin,
      window->desired_conf_mask, &changes);
      window->desired_conf_mask = 0;
  }
  /* be sure to establish the colormaps  *BEFORE* map window
     is done */
  if (window->work_mask & GLUT_COLORMAP_WORK) {
    __glutEstablishColormapsProperty(window);
  }
  if (window->work_mask & GLUT_MAP_WORK) {
    switch (window->desired_map_state) {
    case WithdrawnState:
      if (window->parent) {
        XUnmapWindow(__glutXDisplay, window->owin);
      } else {
        XWithdrawWindow(__glutXDisplay, window->owin,
          __glutXScreen);
      }
      break;
    case NormalState:
      XMapWindow(__glutXDisplay, window->owin);
      break;
    case IconicState:
      XIconifyWindow(__glutXDisplay, window->owin, __glutXScreen);
      break;
    }
  }
}

/*
  Create a GL rendering context
  */
GLUTosGlContext
__glutOsCreateGlContext(GLUTosWindow win, GLUTosSurface surf,
                        GLboolean try_direct)
{
  Bool isDirect;
  GLUTosGlContext ctx;
  
  UNUSED_PARAMETER(win);
  ctx = glXCreateContext(__glutXDisplay, surf, None, try_direct);
  isDirect = glXIsDirect(__glutXDisplay, ctx);
  if (__glutForceDirect) {
    if (!isDirect)
      __glutFatalError("direct rendering not possible.");
  }
  if (!isDirect) {
    __glutIndirectContexts++;
  }
  return ctx;
}

/*
  Clean up a GL rendering context
  */
void
__glutOsDestroyGlContext(GLUTosGlContext ctx)
{
  glXDestroyContext(__glutXDisplay, ctx);
}

/*
  Make a GL rendering context current
  */
void
__glutOsMakeCurrent(GLUTosWindow win, GLUTosGlContext ctx)
{
    if (ctx == GLUT_OS_INVALID_GL_CONTEXT)
    {
        win = None;
    }
    glXMakeCurrent(__glutXDisplay, win, ctx);
}

/*
  Swap buffers for the given window
  */
void
__glutOsSwapBuffers(GLUTosWindow win)
{
    glXSwapBuffers(__glutXDisplay, win);
}

/*
  Get a surface description for the given mode
  */
GLUTosSurface
__glutOsGetSurface(GLbitfield mode)
{
  static XVisualInfo *lastVisual = NULL;
  static int lastMode = 0;
  int list[32];
  int i = 0;

  /* Maintain simple cache of last visual/mode mapping. */
  if (lastVisual && lastMode == mode)
    return lastVisual;
  
  if (GLUT_WIND_IS_DOUBLE(mode)) {
    list[i++] = GLX_DOUBLEBUFFER;
  }
#if (GLUT_API_VERSION >= 2) && defined(GLX_VERSION_1_1) && defined(GLX_SAMPLES_SGIS)
  if (GLUT_WIND_IS_MULTISAMPLE(mode)) {
    if (!__glutIsSupportedByGLX("GLX_SGIS_multisample"))
      return NULL;
    list[i++] = GLX_SAMPLES_SGIS;
    /* XXX Is 4 a reasonable minimum acceptable number of
       samples? */
    list[i++] = 4;
  }
  if (GLUT_WIND_IS_STEREO(mode)) {
    list[i++] = GLX_STEREO;
  }
#endif
  if (GLUT_WIND_IS_RGB(mode)) {
    list[i++] = GLX_RGBA;
    list[i++] = GLX_RED_SIZE;
    list[i++] = 1;
    list[i++] = GLX_GREEN_SIZE;
    list[i++] = 1;
    list[i++] = GLX_BLUE_SIZE;
    list[i++] = 1;
    if (GLUT_WIND_HAS_ALPHA(mode)) {
      list[i++] = GLX_ALPHA_SIZE;
      list[i++] = 1;
    }
    if (GLUT_WIND_HAS_ACCUM(mode)) {
      list[i++] = GLX_ACCUM_RED_SIZE;
      list[i++] = 1;
      list[i++] = GLX_ACCUM_GREEN_SIZE;
      list[i++] = 1;
      list[i++] = GLX_ACCUM_BLUE_SIZE;
      list[i++] = 1;
      if (GLUT_WIND_HAS_ALPHA(mode)) {
        list[i++] = GLX_ACCUM_ALPHA_SIZE;
        list[i++] = 1;
      }
    }
  } else if (GLUT_WIND_IS_INDEX(mode)) {
    list[i++] = GLX_BUFFER_SIZE;
    list[i++] = 1;
  }
  if (GLUT_WIND_HAS_DEPTH(mode)) {
    list[i++] = GLX_DEPTH_SIZE;
    list[i++] = 1;
  }
  if (GLUT_WIND_HAS_STENCIL(mode)) {
    list[i++] = GLX_STENCIL_SIZE;
    list[i++] = 1;
  }
  list[i] = (int) None; /* terminate list */

  if (lastVisual) XFree(lastVisual);
  lastMode = mode;
  lastVisual = glXChooseVisual(__glutXDisplay,
    __glutXScreen, list);
  return lastVisual;
}

/*
  Clean up a surface description
  */
void
__glutOsDestroySurface(GLUTosSurface surf)
{
    surf;
    /* Nothing to do */
}

/*
  Compare two surfaces
  */
GLboolean
__glutOsSurfaceEq(GLUTosSurface s1, GLUTosSurface s2)
{
    return s1->visual->visualid == s2->visual->visualid;
}

/*
  Create a window
  */
GLUTosWindow
__glutOsCreateWindow(GLUTosWindow parent, char *title,
                     int x, int y, int width, int height,
                     GLUTosSurface surf, GLUTosColormap cmap,
                     long event_mask, int initial_state)
{
  XSetWindowAttributes wa;
  XWMHints *wmHints;
  XTextProperty textprop;
  Window win;
  XSizeHints size_hints;
  static int firstWindow = 1;

  wa.colormap = cmap;
  wa.background_pixmap = None;
  wa.border_pixel = 0;
  wa.event_mask = event_mask;
  win = XCreateWindow(__glutXDisplay,
    parent == GLUT_OS_INVALID_WINDOW ? __glutXRoot : parent,
    x, y, width, height, 0,
    surf->depth, InputOutput, surf->visual,
    CWBackPixmap | CWBorderPixel | CWEventMask | CWColormap,
    &wa);
  if (win == GLUT_OS_INVALID_WINDOW)
  {
    return GLUT_OS_INVALID_WINDOW;
  }
  else if (parent != GLUT_OS_INVALID_WINDOW)
  {
    return win;
  }

  size_hints.flags = 0;
  if(x >= 0 && y >= 0) {
    size_hints.x = x;
    size_hints.y = y;
    size_hints.flags |= USPosition;
  }
  if(width > 0 && height > 0) {
    size_hints.width = width;
    size_hints.height = height;
    size_hints.flags |= USSize;
  }
  /* setup ICCCM properties */
  textprop.value = (unsigned char *) title;
  textprop.encoding = XA_STRING;
  textprop.format = 8;
  textprop.nitems = strlen(title);
  wmHints = XAllocWMHints();
  wmHints->initial_state = initial_state;
  wmHints->flags = StateHint;
  XSetWMProperties(__glutXDisplay, win, &textprop, &textprop,
  /* only put WM_COMMAND property on first window */
    firstWindow ? __glutArgv : NULL,
    firstWindow ? __glutArgc : 0,
    &size_hints, wmHints, NULL);
  firstWindow = 0;
  XFree(wmHints);
  XSetWMProtocols(__glutXDisplay, win, &__glutXWMDeleteWindow, 1);
  return win;
}

/*
  Clean up a window
  */
void
__glutOsDestroyWindow(GLUTosWindow win)
{
  glXMakeCurrent(__glutXDisplay, None, NULL);
  XDestroyWindow(__glutXDisplay, win);
}

/*
  Set the window title
  */
void
__glutOsSetWindowTitle(GLUTosWindow win, char *title)
{
  XTextProperty textprop;

  textprop.value = (unsigned char *) title;
  textprop.encoding = XA_STRING;
  textprop.format = 8;
  textprop.nitems = strlen(title);
  XSetWMName(__glutXDisplay, win, &textprop);
  XFlush(__glutXDisplay);
}

/*
  Set the icon title
  */
void
__glutOsSetIconTitle(GLUTosWindow win, char *title)
{
  XTextProperty textprop;

  textprop.value = (unsigned char *) title;
  textprop.encoding = XA_STRING;
  textprop.format = 8;
  textprop.nitems = strlen(title);
  XSetWMIconName(__glutXDisplay, win, &textprop);
  XFlush(__glutXDisplay);
}

/*
  Set a new colormap for a window
  */
void
__glutOsSetWindowColormap(GLUTosWindow win, GLUTosColormap cmap)
{
    XSetWindowColormap(__glutXDisplay, win, cmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\xgltpal.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>

#include "gltint.h"
#include <X11/Xatom.h> /* for XA_RGB_DEFAULT_MAP atom */
#include <X11/Xmu/StdCmap.h> /* for XmuLookupStandardColormap */

/*
  Return the size of the colormap for the associated surface
  Only called for color indexed surfaces
  */
int __glutOsColormapSize(GLUTosSurface surf)
{
    return surf->visual->map_entries;
}

/*
  Create an "empty" palette
  Only called for color indexed surfaces
  */
GLUTosColormap __glutOsCreateEmptyColormap(GLUTosSurface surf)
{
    return XCreateColormap(__glutXDisplay, __glutXRoot, surf->visual,
                           AllocAll);
}

/*
  Frees up a palette
  */
void __glutOsDestroyColormap(GLUTosColormap cmap)
{
    XFreeColormap(__glutXDisplay, cmap);
}

/*
  Set a color in the given colormap
  Values are already clamped
  */
void __glutOsSetColor(GLUTosColormap cmap, int ndx,
                              GLfloat red, GLfloat green, GLfloat blue)
{
  XColor color;
    
  color.pixel = ndx;
  color.red = (GLfloat) 0xffff *red;
  color.green = (GLfloat) 0xffff *green;
  color.blue = (GLfloat) 0xffff *blue;
  color.flags = DoRed | DoGreen | DoBlue;
  XStoreColor(__glutXDisplay, cmap, &color);
}

/*
  Return whether the given surface is color indexed or not
  */
GLboolean
__glutOsSurfaceHasColormap(GLUTosSurface surf)
{
    return surf->class == PseudoColor;
}

/*
  Create a colormap appropriate for the given surface
  Only called for non-color-indexed surfaces
  */
GLUTosColormap
__glutOsGetSurfaceColormap(GLUTosSurface surf)
{
  Status status;
  XStandardColormap *standardCmaps;
  int i, numCmaps;
  Colormap cmap = 0;

  status = XmuLookupStandardColormap(__glutXDisplay,
    surf->screen, surf->visualid, surf->depth, XA_RGB_DEFAULT_MAP,
      /* replace */ False, /* retain */ True);
  if (status == 1) {
    status = XGetRGBColormaps(__glutXDisplay, __glutXRoot,
      &standardCmaps, &numCmaps, XA_RGB_DEFAULT_MAP);
    if (status == 1)
      for (i = 0; i < numCmaps; i++)
        if (standardCmaps[i].visualid == surf->visualid) {
          cmap = standardCmaps[i].colormap;
          XFree(standardCmaps);
          break;
        }
  }

#if 0
  /* ATTENTION - Standard colormap never seems to be used
     I think the following line should be enabled, in which
     case the DestroyColormap logic needs to be improved to
     not destroy standard colormaps */
  if (cmap == 0)
#endif
  {
    /* If no standard colormap but TrueColor, just make a
       private one. */
    /* XXX Should do a better job of internal sharing for
       privately allocated TrueColor colormaps. */
    /* XXX DirectColor probably needs ramps hand initialized! */
    cmap = XCreateColormap(__glutXDisplay, __glutXRoot,
      surf->visual, AllocNone);
  }

  return cmap;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\src\xgltmenu.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees
   and is provided without guarantee or warrantee expressed or
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>

#include <X11/Xlib.h>
#include <X11/cursorfont.h>  /* for XC_arrow */

#include <GL/glut.h>
#include "gltint.h"
#include "layrutil.h"

struct _GLUTxMenuItem {
  GLUTosWindow win;     /* InputOnly X window for entry */
  char *label;          /* strdup'ed label string */
  int len;              /* length of label string */
  int value;            /* value to return for selecting this
                           entry; doubles as submenu id
                           (1-base) if submenu trigger */
  int pixwidth;         /* width of X window in pixels */
  int submenu;          /* is a submenu trigger? */
  GLUTmenu *menu;       /* menu entry belongs to */
  GLUTxMenuItem *next;  /* next menu entry on list for menu */
};

GLUTxMenuItem *__glutItemSelected;

static XFontStruct *menuFont = NULL;
static Cursor menuCursor;
static Colormap menuColormap;
static Visual *menuVisual;
static GC blackGC, grayGC, whiteGC;
static unsigned long menuBlack, menuWhite, menuGray;
static int fontHeight;
static int menuDepth;

static void
menuVisualSetup(void)
{
  XLayerVisualInfo template, *visual, *overlayVisuals;
  XColor color;
  Status status;
  int nVisuals, i;

  template.layer = 1;
  template.vinfo.screen = __glutXScreen;
  overlayVisuals = __glutXGetLayerVisualInfo(__glutXDisplay,
    VisualScreenMask | VisualLayerMask, &template, &nVisuals);
  if (overlayVisuals) {
    for (i = 0; i < nVisuals; i++) {
      visual = &overlayVisuals[i];
      if (visual->vinfo.colormap_size >= 3) {
        menuColormap = XCreateColormap(__glutXDisplay, __glutXRoot,
          visual->vinfo.visual, AllocNone);
        /* Allocate overlay colormap cells in defined order:
           gray, black, white to match the IRIS GL allocation
           scheme.  Increases likelihood of less overlay
           colormap flashing. */
        /* XXX nice if these 3 AllocColor's could be done in
           one protocol round-trip */
        color.red = color.green = color.blue = 0xaa00;
        status = XAllocColor(__glutXDisplay,
          menuColormap, &color);
        if (!status) {
          XFreeColormap(__glutXDisplay, menuColormap);
          continue;
        }
        menuGray = color.pixel;
        color.red = color.green = color.blue = 0x0000;
        status = XAllocColor(__glutXDisplay,
          menuColormap, &color);
        if (!status) {
          XFreeColormap(__glutXDisplay, menuColormap);
          continue;
        }
        menuBlack = color.pixel;
        color.red = color.green = color.blue = 0xffff;
        status = XAllocColor(__glutXDisplay,
          menuColormap, &color);
        if (!status) {
          XFreeColormap(__glutXDisplay, menuColormap);
          continue;
        }
        menuWhite = color.pixel;
        menuVisual = visual->vinfo.visual;
        menuDepth = visual->vinfo.depth;
        XFree(overlayVisuals);
        return;
      }
    }
  }
  /* settle for default visual */
  menuVisual = DefaultVisual(__glutXDisplay, __glutXScreen);
  menuDepth = DefaultDepth(__glutXDisplay, __glutXScreen);
  menuColormap = DefaultColormap(__glutXDisplay, __glutXScreen);
  menuBlack = BlackPixel(__glutXDisplay, __glutXScreen);
  menuWhite = WhitePixel(__glutXDisplay, __glutXScreen);
  color.red = color.green = color.blue = 0xaa00;
  status = XAllocColor(__glutXDisplay, menuColormap, &color);
  if (!status) {
    __glutFatalError(
      "could not allocate gray in default colormap");
  }
  menuGray = color.pixel;
  XFree(overlayVisuals);
}

static void
menuSetup(void)
{
  if (menuFont) {
    /* menuFont overload to indicate menu initalization */
    return;
  }
  menuFont = XLoadQueryFont(__glutXDisplay,
    "-*-helvetica-bold-o-normal--14-*-*-*-p-*-iso8859-1");
  if (!menuFont) {
    /* try back up font */
    menuFont = XLoadQueryFont(__glutXDisplay, "fixed");
  }
  if (!menuFont) {
    __glutFatalError("could not load font.");
  }
  menuVisualSetup();
  fontHeight = menuFont->ascent + menuFont->descent;
  menuCursor = XCreateFontCursor(__glutXDisplay, XC_arrow);
}

static void
menuGraphicsContextSetup(Window win)
{
  XGCValues gcvals;

  if (blackGC != None)
    return;
  gcvals.font = menuFont->fid;
  gcvals.foreground = menuBlack;
  blackGC = XCreateGC(__glutXDisplay, win,
    GCFont | GCForeground, &gcvals);
  gcvals.foreground = menuGray;
  grayGC = XCreateGC(__glutXDisplay, win, GCForeground, &gcvals);
  gcvals.foreground = menuWhite;
  whiteGC = XCreateGC(__glutXDisplay, win, GCForeground, &gcvals);
}

#define MENU_BORDER 1
#define MENU_GAP 2
#define MENU_ARROW_GAP 6
#define MENU_ARROW_WIDTH 8

static void
mapMenu(GLUTmenu * menu, int x, int y)
{
  XWindowChanges changes;
  unsigned int mask;
  int subMenuExtension;
  GLUTosMenu omenu = menu->omenu;

  /* If there are submenus, we need to provide extra space for
     the submenu pull arrow.  */
  if (omenu->submenus > 0) {
    subMenuExtension = MENU_ARROW_GAP + MENU_ARROW_WIDTH;
  } else {
    subMenuExtension = 0;
  }

  changes.stack_mode = Above;
  mask = CWStackMode | CWX | CWY;
  /* If the menu isn't managed (ie, validated so all the
     InputOnly subwindows are the right size), do so.  */
  if (!omenu->managed) {
    GLUTxMenuItem *item;

    item = omenu->list;
    while (item) {
      XWindowChanges widthchange;

      widthchange.width = item->pixwidth = omenu->pixwidth;
      widthchange.width += subMenuExtension;
      XConfigureWindow(__glutXDisplay, item->win,
        CWWidth, &widthchange);
      item = item->next;
    }
    omenu->pixheight = MENU_GAP +
      fontHeight * menu->num + MENU_GAP;
    changes.height = omenu->pixheight;
    changes.width = MENU_GAP +
      omenu->pixwidth + subMenuExtension + MENU_GAP;
    mask |= CWWidth | CWHeight;
    omenu->managed = 1;
  }
  /* make sure menu appears fully on screen */
  if (y + omenu->pixheight >= DisplayHeight(__glutXDisplay, __glutXScreen)) {
    changes.y = DisplayHeight(__glutXDisplay, __glutXScreen) - omenu->pixheight;
  } else {
    changes.y = y;
  }
  if (x + omenu->pixwidth + subMenuExtension >=
    DisplayWidth(__glutXDisplay, __glutXScreen)) {
    changes.x = DisplayWidth(__glutXDisplay, __glutXScreen) -
      omenu->pixwidth + subMenuExtension;
  } else {
    changes.x = x;
  }

  /* Rember where the menu is placed so submenus can be
     properly placed relative to it. */
  omenu->x = changes.x;
  omenu->y = changes.y;

  XConfigureWindow(__glutXDisplay, omenu->win, mask, &changes);
  XInstallColormap(__glutXDisplay, menuColormap);
  XMapWindow(__glutXDisplay, omenu->win);
}

void
__glutXStartMenu(GLUTmenu * menu, GLUTwindow * window,
  int x, int y)
{
  int grab;
  int notAlreadyInUse = 1;

  if (__glutMappedMenu) {
    /* force down previously current menu */
    __glutXFinishMenu();
    notAlreadyInUse = 0;
  }
  grab = XGrabPointer(__glutXDisplay, __glutXRoot, True,
    ButtonPressMask | ButtonReleaseMask,
    GrabModeAsync, GrabModeAsync,
    __glutXRoot, menuCursor, CurrentTime);
  if (grab != GrabSuccess) {
    /* Somebody else has pointer grabbed, ignore menu
       activation. */
    return;
  }
  if (notAlreadyInUse) {
    if (__glutMenuStateFunc) {
      __glutSetMenu(menu);
      __glutSetWindow(window);
      (*__glutMenuStateFunc) (GLUT_MENU_IN_USE);
    }
  }
  mapMenu(menu, x, y);
  __glutMappedMenu = menu;
  __glutMenuWindow = window;
  __glutItemSelected = NULL;
}

static void
paintSubMenuArrow(Window win, int x, int y)
{
  XPoint p[5];

  p[0].x = p[4].x = x;
  p[0].y = p[4].y = y - menuFont->ascent + 1;
  p[1].x = p[0].x + MENU_ARROW_WIDTH - 1;
  p[1].y = p[0].y + (menuFont->ascent / 2) - 1;
  p[2].x = p[1].x;
  p[2].y = p[1].y + 1;
  p[3].x = p[0].x;
  p[3].y = p[0].y + menuFont->ascent - 2;
  XFillPolygon(__glutXDisplay, win,
    whiteGC, p, 4, Convex, CoordModeOrigin);
  XDrawLines(__glutXDisplay, win, blackGC, p, 5, CoordModeOrigin);
}

static void
paintMenuItem(GLUTxMenuItem * item, int num)
{
  Window win = item->menu->omenu->win;
  GC gc;
  int y;
  int subMenuExtension;

  if (item->menu->omenu->submenus > 0) {
    subMenuExtension = MENU_ARROW_GAP + MENU_ARROW_WIDTH;
  } else {
    subMenuExtension = 0;
  }
  if (item->menu->omenu->highlighted == item) {
    gc = whiteGC;
  } else {
    gc = grayGC;
  }
  y = MENU_GAP + fontHeight * num - menuFont->descent;
  XFillRectangle(__glutXDisplay, win, gc,
    MENU_GAP, y - fontHeight + menuFont->descent,
    item->pixwidth + subMenuExtension, fontHeight);
  XDrawString(__glutXDisplay, win, blackGC,
    MENU_GAP, y, item->label, item->len);
  if (item->submenu) {
    paintSubMenuArrow(win,
      item->menu->omenu->pixwidth + MENU_ARROW_GAP + 1, y);
  }
}

void
__glutXPaintMenu(GLUTmenu * menu)
{
  GLUTxMenuItem *item;
  int i = menu->num;
  int y = MENU_GAP + fontHeight * i - menuFont->descent;

  item = menu->omenu->list;
  while (item) {
    if (item->menu->omenu->highlighted == item) {
      paintMenuItem(item, i);
    } else {
      /* quick render of the menu item; assume background
         already cleared to gray */
      XDrawString(__glutXDisplay, menu->omenu->win, blackGC,
        2, y, item->label, item->len);
      if (item->submenu) {
        paintSubMenuArrow(menu->omenu->win,
          menu->omenu->pixwidth + MENU_ARROW_GAP + 1, y);
      }
    }
    i--;
    y -= fontHeight;
    item = item->next;
  }
}

static int
getMenuItemIndex(GLUTxMenuItem * item)
{
  int count = 0;

  while (item) {
    count++;
    item = item->next;
  }
  return count;
}

static void
unmapMenu(GLUTosMenu omenu)
{
  if (omenu->cascade) {
    unmapMenu(omenu->cascade->omenu);
    omenu->cascade = NULL;
  }
  omenu->anchor = NULL;
  omenu->highlighted = NULL;
  XUnmapWindow(__glutXDisplay, omenu->win);
}

void
__glutXMenuItemEnterOrLeave(GLUTxMenuItem * item,
  int num, int type)
{
  int alreadyUp = 0;
  GLUTosMenu omenu = item->menu->omenu;

  if (type == EnterNotify) {
    GLUTxMenuItem *prevItem = omenu->highlighted;

    if (prevItem && prevItem != item) {
      /* If there's an already higlighted item in this menu
         that is different from this one (we could be
         re-entering an item with an already cascaded
         submenu!), unhighlight the previous item. */
      omenu->highlighted = NULL;
      paintMenuItem(prevItem, getMenuItemIndex(prevItem));
    }
    omenu->highlighted = item;
    __glutItemSelected = item;
    if (omenu->cascade) {
      if (!item->submenu) {
        /* Entered a menu item without a submenu, pop down the
           current submenu cascade of this menu.  */
        unmapMenu(omenu->cascade->omenu);
        omenu->cascade = NULL;
      } else {
        GLUTmenu *submenu = __glutGetMenuByNum(item->value);

        if (submenu->omenu->anchor == item) {
          /* We entered the submenu trigger for the submenu
             that is already up, so don't take down the
             submenu.  */
          alreadyUp = 1;
        } else {
          /* Submenu already popped up for some other submenu
             item of this menu; need to pop down that other
             submenu cascade.  */
          unmapMenu(omenu->cascade->omenu);
          omenu->cascade = NULL;
        }
      }
    }
    if (!alreadyUp) {
      /* Make sure the menu item gets painted with
         highlighting. */
      paintMenuItem(item, num);
    } else {
      /* If already up, should already be highlighted.  */
    }
  } else {
    /* LeaveNotify: Handle leaving a menu item...  */
    if (omenu->cascade &&
      omenu->cascade->omenu->anchor == item) {
      /* If there is a submenu casacaded from this item, do not
         change the highlighting on this item upon leaving. */
    } else {
      /* Unhighlight this menu item.  */
      omenu->highlighted = NULL;
      paintMenuItem(item, num);
    }
    __glutItemSelected = NULL;
  }
  if (item->submenu) {
    if (type == EnterNotify && !alreadyUp) {
      GLUTmenu *submenu = __glutGetMenuByNum(item->value);

      mapMenu(submenu,
        omenu->x + omenu->pixwidth +
        MENU_ARROW_GAP + MENU_ARROW_WIDTH +
        MENU_GAP + MENU_BORDER,
        omenu->y + fontHeight * (num - 1) + MENU_GAP);
      omenu->cascade = submenu;
      submenu->omenu->anchor = item;
    }
  }
}

/*
  Create an empty menu
  */
GLUTosMenu
__glutOsCreateMenu(void)
{
  XSetWindowAttributes wa;
  GLUTxMenu *menu;

  menu = (GLUTxMenu *)malloc(sizeof(GLUTxMenu));
  if (menu == NULL)
    __glutFatalError("unable to allocate menu.");
  menuSetup();
  wa.override_redirect = True;
  wa.background_pixel = menuGray;
  wa.border_pixel = menuBlack;
  wa.colormap = menuColormap;
  wa.event_mask = StructureNotifyMask | ExposureMask |
    ButtonPressMask | ButtonReleaseMask |
    EnterWindowMask | LeaveWindowMask;
  menu->win = XCreateWindow(__glutXDisplay, __glutXRoot,
  /* real position determined when mapped */
    0, 0,
  /* real size will be determined when menu is manged */
    1, 1,
    MENU_BORDER, menuDepth, InputOutput, menuVisual,
    CWOverrideRedirect | CWBackPixel |
    CWBorderPixel | CWEventMask | CWColormap,
    &wa);
  menuGraphicsContextSetup(menu->win);
  menu->submenus = 0;
  menu->managed = 0;
  menu->pixwidth = 0;
  menu->list = NULL;
  menu->cascade = NULL;
  menu->highlighted = NULL;
  menu->anchor = NULL;
  return menu;
}

/*
  Clean up a menu
  */
void
__glutOsDestroyMenu(GLUTosMenu menu)
{
  GLUTxMenuItem *item, *next;
  
  XDestroySubwindows(__glutXDisplay, menu->win);
  XDestroyWindow(__glutXDisplay, menu->win);
  /* free all menu entries */
  item = menu->list;
  while (item) {
    assert(item->menu->omenu == menu);
    next = item->next;
    free(item->label);
    free(item);
    item = next;
  }
}

GLUTmenu *
__glutXGetMenu(GLUTosWindow win)
{
  GLUTmenu *menu;

  menu = __glutMappedMenu;
  while (menu) {
    if (win == menu->omenu->win) {
      return menu;
    }
    menu = menu->omenu->cascade;
  }
  return NULL;
}

GLUTxMenuItem *
__glutXGetMenuItem(GLUTmenu * menu, Window win, int *which)
{
  GLUTxMenuItem *item;
  int i;

  i = menu->num;
  item = menu->omenu->list;
  while (item) {
    if (item->win == win) {
      *which = i;
      return item;
    }
    if (item->submenu) {
      GLUTxMenuItem *subitem;

      subitem = __glutXGetMenuItem(__glutGetMenuByNum(item->value),
        win, which);
      if (subitem) {
        return subitem;
      }
    }
    i--;
    item = item->next;
  }
  return NULL;
}

void
__glutXFinishMenu(void)
{
  unmapMenu(__glutMappedMenu->omenu);
  XUngrabPointer(__glutXDisplay, CurrentTime);
  /* If an item is selected and it is not a submenu, generate
     menu callback. */
  if (__glutItemSelected && !__glutItemSelected->submenu) {
    /* When menu callback is triggered, current menu should be
       set to the callback menu. */
    __glutSetWindow(__glutMenuWindow);
    __glutSetMenu(__glutItemSelected->menu);
    (*__glutItemSelected->menu->select) (
      __glutItemSelected->value);
  }
  __glutMappedMenu = NULL;
}

static void
setMenuItem(GLUTxMenuItem * item, char *label,
  int value, int submenu)
{
  GLUTmenu *menu;
  int pixwidth;

  menu = item->menu;
  item->label = strdup(label);
  if (!item->label)
    __glutFatalError("out of memory.");
  item->submenu = submenu;
  item->len = strlen(label);
  item->value = value;
  pixwidth = XTextWidth(menuFont, label, item->len) + 4;
  if (pixwidth > menu->omenu->pixwidth) {
    menu->omenu->pixwidth = pixwidth;
  }
  item->pixwidth = menu->omenu->pixwidth;
  menu->omenu->managed = 0;
}

/*
  Add a text item
  */
void
__glutOsAddMenuEntry(GLUTosMenu menu, char *label, int value)
{
  XSetWindowAttributes wa;
  GLUTxMenuItem *entry;

  entry = (GLUTxMenuItem *) malloc(sizeof(GLUTxMenuItem));
  if (!entry)
    __glutFatalError("out of memory.");
  entry->menu = __glutGetMenuByOsMenu(menu);
  setMenuItem(entry, label, value, 0);
  wa.event_mask = EnterWindowMask | LeaveWindowMask;
  entry->win = XCreateWindow(__glutXDisplay,
    menu->win, MENU_GAP,
    entry->menu->num * fontHeight + MENU_GAP,  /* x & y */
    entry->pixwidth, fontHeight,  /* width & height */
    0, CopyFromParent, InputOnly, CopyFromParent,
    CWEventMask, &wa);
  XMapWindow(__glutXDisplay, entry->win);
  entry->next = menu->list;
  menu->list = entry;
}

/*
  Add a submenu item
  */
void
__glutOsAddSubMenu(GLUTosMenu menu, char *label, GLUTosMenu submenu)
{
  XSetWindowAttributes wa;
  GLUTxMenuItem *item;

  item = (GLUTxMenuItem *) malloc(sizeof(GLUTxMenuItem));
  if (!item)
    __glutFatalError("out of memory.");
  menu->submenus++;
  item->menu = __glutGetMenuByOsMenu(menu);
  setMenuItem(item, label,
               __glutGetMenuByOsMenu(submenu)->id+1, 1);
  wa.event_mask = EnterWindowMask | LeaveWindowMask;
  item->win = XCreateWindow(__glutXDisplay,
    menu->win, MENU_GAP,
    item->menu->num * fontHeight + MENU_GAP,  /* x & y */
    item->pixwidth, fontHeight,  /* width & height */
    0, CopyFromParent, InputOnly, CopyFromParent,
    CWEventMask, &wa);
  XMapWindow(__glutXDisplay, item->win);
  item->next = menu->list;
  menu->list = item;
}

/*
  Change an item to a text item
  */
void
__glutOsChangeToMenuEntry(GLUTosMenu menu, int num, char *label, int value)
{
  GLUTxMenuItem *item;
  int i;

  i = __glutGetMenuByOsMenu(menu)->num;
  item = menu->list;
  while (item) {
    if (i == num) {
      if (item->submenu) {
        /* If changing a submenu trigger to a menu item, we
           need to account for submenus.  */
        item->menu->omenu->submenus--;
      }
      free(item->label);
      setMenuItem(item, label, value, 0);
      return;
    }
    i--;
    item = item->next;
  }
  __glutWarning("Current menu has no %d item.", num);
}

/*
  Change an item to a submenu item
  */
void
__glutOsChangeToSubMenu(GLUTosMenu menu, int num, char *label,
                        GLUTosMenu submenu)
{
  GLUTxMenuItem *item;
  int i;

  i = __glutGetMenuByOsMenu(menu)->num;
  item = menu->list;
  while (item) {
    if (i == num) {
      if (!item->submenu) {
        /* If changing a submenu trigger to a menu item, we
           need to account for submenus.  */
        item->menu->omenu->submenus++;
      }
      setMenuItem(item, label,
                   __glutGetMenuByOsMenu(submenu)->id+1, 1);
      return;
    }
    i--;
    item = item->next;
  }
  __glutWarning("Current menu has no %d item.", num);
}

/*
  Remove an item
  */
void __glutOsRemoveMenuEntry(GLUTosMenu menu, int num)
{
  GLUTxMenuItem *item, **prev;
  int i;

  i = __glutGetMenuByOsMenu(menu)->num;
  prev = &menu->list;
  item = menu->list;
  while (item) {
    if (i == num) {
      *prev = item->next;
      free(item->label);
      free(item);
      return;
    }
    i--;
    prev = &item->next;
    item = item->next;
  }
  __glutWarning("Current menu has no %d item.", num);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\bitfont.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <string.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

void *font = GLUT_BITMAP_TIMES_ROMAN_24;
void *fonts[] =
{
  GLUT_BITMAP_9_BY_15,
  GLUT_BITMAP_TIMES_ROMAN_10,
  GLUT_BITMAP_TIMES_ROMAN_24
};
char defaultMessage[] = "GLUT means OpenGL.";
char *message = defaultMessage;

void
selectFont(int newfont)
{
  font = fonts[newfont];
  glutPostRedisplay();
}

void
selectMessage(int msg)
{
  switch (msg) {
  case 1:
    message = "abcdefghijklmnop";
    break;
  case 2:
    message = "ABCDEFGHIJKLMNOP";
    break;
  }
}

void
tick(void)
{
  glutPostRedisplay();
}

void
output(int x, int y, char *string)
{
  int len, i;

  glRasterPos2f(x, y);
  len = strlen(string);
  for (i = 0; i < len; i++) {
    glutBitmapCharacter(font, string[i]);
  }
}

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  output(0, 24, "This is written in a GLUT bitmap font.");
  output(100, 100, message);
  output(50, 145, "(positioned in pixels with upper-left origin)");
  glutSwapBuffers();
}

void
reshape(int w, int h)
{
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluOrtho2D(0, w, 0, h);
  glScalef(1, -1, 1);
  glTranslatef(0, -h, 0);
  glMatrixMode(GL_MODELVIEW);
}

void
main(int argc, char **argv)
{
  int i, submenu;

  glutInit(&argc, argv);
  for (i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "-mono")) {
      font = GLUT_BITMAP_9_BY_15;
    }
  }
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(500, 150);
  glutCreateWindow("GLUT bitmap font example");
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glutIdleFunc(tick);
  submenu = glutCreateMenu(selectMessage);
  glutAddMenuEntry("abc", 1);
  glutAddMenuEntry("ABC", 2);
  glutCreateMenu(selectFont);
  glutAddMenuEntry("9 by 15", 0);
  glutAddMenuEntry("Times Roman 10", 1);
  glutAddMenuEntry("Times Roman 24", 2);
  glutAddSubMenu("Messages", submenu);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\bezmesh.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  bezsurf.c
 *  This program renders a lighted, filled Bezier surface,
 *  using two-dimensional evaluators.
 */
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <GL/glut.h>

GLfloat ctrlpoints[4][4][3] =
{
    {
        {-1.5, -1.5, 4.0},
        {-0.5, -1.5, 2.0},
        {0.5, -1.5, -1.0},
        {1.5, -1.5, 2.0}},
    {
        {-1.5, -0.5, 1.0},
        {-0.5, -0.5, 3.0},
        {0.5, -0.5, 0.0},
        {1.5, -0.5, -1.0}},
    {
        {-1.5, 0.5, 4.0},
        {-0.5, 0.5, 0.0},
        {0.5, 0.5, 3.0},
        {1.5, 0.5, 4.0}},
    {
        {-1.5, 1.5, -2.0},
        {-0.5, 1.5, -2.0},
        {0.5, 1.5, 0.0},
        {1.5, 1.5, -1.0}}
};

void 
initlights(void)
{
    GLfloat ambient[] =
    {0.2, 0.2, 0.2, 1.0};
    GLfloat position[] =
    {0.0, 0.0, 2.0, 1.0};
    GLfloat mat_diffuse[] =
    {0.6, 0.6, 0.6, 1.0};
    GLfloat mat_specular[] =
    {1.0, 1.0, 1.0, 1.0};
    GLfloat mat_shininess[] =
    {50.0};

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_POSITION, position);

    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

void 
display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glRotatef(85.0, 1.0, 1.0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
    glPopMatrix();
    glFlush();
}

void 
myinit(void)
{
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
        0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glEnable(GL_MAP2_VERTEX_3);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
    initlights();       /* for lighted version only */
}

void 
myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-4.0, 4.0, -4.0 * (GLfloat) h / (GLfloat) w,
            4.0 * (GLfloat) h / (GLfloat) w, -4.0, 4.0);
    else
        glOrtho(-4.0 * (GLfloat) w / (GLfloat) h,
            4.0 * (GLfloat) w / (GLfloat) h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void 
main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutCreateWindow(argv[0]);
    myinit();
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\dinospin.c ===
/* Copyright (c) Mark J. Kilgard, 1994.  */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>       /* for cos(), sin(), and sqrt() */
#ifdef GLUT_WIN32
#include <windows.h>
#endif

#include <GL/glu.h>
#include <GL/glut.h>
#include "trackball.h"

typedef enum {
  RESERVED, BODY_SIDE, BODY_EDGE, BODY_WHOLE, ARM_SIDE, ARM_EDGE, ARM_WHOLE,
  LEG_SIDE, LEG_EDGE, LEG_WHOLE, EYE_SIDE, EYE_EDGE, EYE_WHOLE, DINOSAUR
} displayLists;

GLfloat angle = (GLfloat)-150;   /* in degrees */
GLboolean doubleBuffer = GL_TRUE, iconic = GL_FALSE, keepAspect = GL_FALSE;
int spinning = 0, moving = 0;
int beginx, beginy;
int W = 300, H = 300;
float curquat[4];
float lastquat[4];
GLdouble bodyWidth = 2.0;
int newModel = 1;
/* *INDENT-OFF* */
GLfloat body[][2] = { {(GLfloat)0, (GLfloat)3}, {(GLfloat)1, (GLfloat)1}, {(GLfloat)5, (GLfloat)1}, {(GLfloat)8, (GLfloat)4}, {(GLfloat)10, (GLfloat)4}, {(GLfloat)11, (GLfloat)5},
  {(GLfloat)11, (GLfloat)11.5}, {(GLfloat)13, (GLfloat)12}, {(GLfloat)13, (GLfloat)13}, {(GLfloat)10, (GLfloat)13.5}, {(GLfloat)13, (GLfloat)14}, {(GLfloat)13, (GLfloat)15}, {(GLfloat)11, (GLfloat)16},
  {(GLfloat)8, (GLfloat)16}, {(GLfloat)7, (GLfloat)15}, {(GLfloat)7, (GLfloat)13}, {(GLfloat)8, (GLfloat)12}, {(GLfloat)7, (GLfloat)11}, {(GLfloat)6, (GLfloat)6}, {(GLfloat)4, (GLfloat)3}, {(GLfloat)3, (GLfloat)2},
  {(GLfloat)1, (GLfloat)2} };
GLfloat arm[][2] = { {(GLfloat)8, (GLfloat)10}, {(GLfloat)9, (GLfloat)9}, {(GLfloat)10, (GLfloat)9}, {(GLfloat)13, (GLfloat)8}, {(GLfloat)14, (GLfloat)9}, {(GLfloat)16, (GLfloat)9},
  {(GLfloat)15, (GLfloat)9.5}, {(GLfloat)16, (GLfloat)10}, {(GLfloat)15, (GLfloat)10}, {(GLfloat)15.5, (GLfloat)11}, {(GLfloat)14.5, (GLfloat)10}, {(GLfloat)14, (GLfloat)11}, {(GLfloat)14, (GLfloat)10},
  {(GLfloat)13, (GLfloat)9}, {(GLfloat)11, (GLfloat)11}, {(GLfloat)9, (GLfloat)11} };
GLfloat leg[][2] = { {(GLfloat)8, (GLfloat)6}, {(GLfloat)8, (GLfloat)4}, {(GLfloat)9, (GLfloat)3}, {(GLfloat)9, (GLfloat)2}, {(GLfloat)8, (GLfloat)1}, {(GLfloat)8, (GLfloat)0.5}, {(GLfloat)9, (GLfloat)0},
  {(GLfloat)12, (GLfloat)0}, {(GLfloat)10, (GLfloat)1}, {(GLfloat)10, (GLfloat)2}, {(GLfloat)12, (GLfloat)4}, {(GLfloat)11, (GLfloat)6}, {(GLfloat)10, (GLfloat)7}, {(GLfloat)9, (GLfloat)7} };
GLfloat eye[][2] = { {(GLfloat)8.75, (GLfloat)15}, {(GLfloat)9, (GLfloat)14.7}, {(GLfloat)9.6, (GLfloat)14.7}, {(GLfloat)10.1, (GLfloat)15},
  {(GLfloat)9.6, (GLfloat)15.25}, {(GLfloat)9, (GLfloat)15.25} };
GLfloat lightZeroPosition[] = {(GLfloat)10.0, (GLfloat)4.0, (GLfloat)10.0, (GLfloat)1.0};
GLfloat lightZeroColor[] = {(GLfloat)0.8, (GLfloat)1.0, (GLfloat)0.8, (GLfloat)1.0}; /* green-tinted */
GLfloat lightOnePosition[] = {(GLfloat)-1.0, (GLfloat)-2.0, (GLfloat)1.0, (GLfloat)0.0};
GLfloat lightOneColor[] = {(GLfloat)0.6, (GLfloat)0.3, (GLfloat)0.2, (GLfloat)1.0}; /* red-tinted */
GLfloat skinColor[] = {(GLfloat)0.1, (GLfloat)1.0, (GLfloat)0.1, (GLfloat)1.0}, eyeColor[] = {(GLfloat)1.0, (GLfloat)0.2, (GLfloat)0.2, (GLfloat)1.0};
/* *INDENT-ON* */

void
extrudeSolidFromPolygon(GLfloat data[][2], unsigned int dataSize,
  GLdouble thickness, GLuint side, GLuint edge, GLuint whole)
{
  static GLUtriangulatorObj *tobj = NULL;
  GLdouble vertex[3], dx, dy, len;
  int i;
  int count = dataSize / (2 * sizeof(GLfloat));

  if (tobj == NULL) {
    tobj = gluNewTess();  /* create and initialize a GLU
                             polygon * * tesselation object */
    gluTessCallback(tobj, GLU_BEGIN, glBegin);
    gluTessCallback(tobj, GLU_VERTEX, glVertex2fv);  /* semi-tricky 
                                                      */
    gluTessCallback(tobj, GLU_END, glEnd);
  }
  glNewList(side, GL_COMPILE);
  glShadeModel(GL_SMOOTH);  /* smooth minimizes seeing
                               tessellation */
  gluBeginPolygon(tobj);
  for (i = 0; i < count; i++) {
    vertex[0] = data[i][0];
    vertex[1] = data[i][1];
    vertex[2] = 0;
    gluTessVertex(tobj, vertex, data[i]);
  }
  gluEndPolygon(tobj);
  glEndList();
  glNewList(edge, GL_COMPILE);
  glShadeModel(GL_FLAT);  /* flat shade keeps angular hands
                             from being * * "smoothed" */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= count; i++) {
    /* mod function handles closing the edge */
    glVertex3f(data[i % count][0], data[i % count][1], (GLfloat)0.0);
    glVertex3f(data[i % count][0], data[i % count][1], (GLfloat)thickness);
    /* Calculate a unit normal by dividing by Euclidean
       distance. We * could be lazy and use
       glEnable(GL_NORMALIZE) so we could pass in * arbitrary
       normals for a very slight performance hit. */
    dx = data[(i + 1) % count][1] - data[i % count][1];
    dy = data[i % count][0] - data[(i + 1) % count][0];
    len = sqrt(dx * dx + dy * dy);
    glNormal3f((GLfloat)(dx / len), (GLfloat)(dy / len), (GLfloat)0.0);
  }
  glEnd();
  glEndList();
  glNewList(whole, GL_COMPILE);
  glFrontFace(GL_CW);
  glCallList(edge);
  glNormal3f((GLfloat)0.0, (GLfloat)0.0, (GLfloat)-1.0);  /* constant normal for side */
  glCallList(side);
  glPushMatrix();
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, (GLfloat)thickness);
  glFrontFace(GL_CCW);
  glNormal3f((GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0);  /* opposite normal for other side 
                               */
  glCallList(side);
  glPopMatrix();
  glEndList();
}

void
makeDinosaur(void)
{
  GLfloat bodyWidth = (GLfloat)3.0;

  extrudeSolidFromPolygon(body, sizeof(body), bodyWidth,
    BODY_SIDE, BODY_EDGE, BODY_WHOLE);
  extrudeSolidFromPolygon(arm, sizeof(arm), bodyWidth / 4,
    ARM_SIDE, ARM_EDGE, ARM_WHOLE);
  extrudeSolidFromPolygon(leg, sizeof(leg), bodyWidth / 2,
    LEG_SIDE, LEG_EDGE, LEG_WHOLE);
  extrudeSolidFromPolygon(eye, sizeof(eye), bodyWidth + 0.2,
    EYE_SIDE, EYE_EDGE, EYE_WHOLE);
  glNewList(DINOSAUR, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_DIFFUSE, skinColor);
  glCallList(BODY_WHOLE);
  glPushMatrix();
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, bodyWidth);
  glCallList(ARM_WHOLE);
  glCallList(LEG_WHOLE);
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, -bodyWidth - bodyWidth / 4);
  glCallList(ARM_WHOLE);
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, -bodyWidth / 4);
  glCallList(LEG_WHOLE);
  glTranslatef((GLfloat)0.0, (GLfloat)0.0, bodyWidth / 2 - (GLfloat)0.1);
  glMaterialfv(GL_FRONT, GL_DIFFUSE, eyeColor);
  glCallList(EYE_WHOLE);
  glPopMatrix();
  glEndList();
}

void
recalcModelView(void)
{
  GLfloat m[4][4];

  glPopMatrix();
  glPushMatrix();
  build_rotmatrix(m, curquat);
  glMultMatrixf(&m[0][0]);
  glTranslatef((GLfloat)-8, (GLfloat)-8, (GLfloat)(-bodyWidth / 2));
  newModel = 0;
}

void
showMessage(GLfloat x, GLfloat y, GLfloat z, char *message)
{
  glPushMatrix();
  glDisable(GL_LIGHTING);
  glTranslatef(x, y, z);
  glScalef((GLfloat).02, (GLfloat).02, (GLfloat).02);
  while (*message) {
    glutStrokeCharacter(GLUT_STROKE_ROMAN, *message);
    message++;
  }
  glEnable(GL_LIGHTING);
  glPopMatrix();
}

void
redraw(void)
{
  if (newModel)
    recalcModelView();
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glCallList(DINOSAUR);
  showMessage((GLfloat)2, (GLfloat)7.1, (GLfloat)4.1, "Spin me.");
  glutSwapBuffers();
}

void
mouse(int button, int state, int x, int y)
{
  if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
    spinning = 0;
    glutIdleFunc(NULL);
    moving = 1;
    beginx = x;
    beginy = y;
  }
  if (button == GLUT_LEFT_BUTTON && state == GLUT_UP) {
    moving = 0;
  }
}

void
animate(void)
{
  add_quats(lastquat, curquat, curquat);
  newModel = 1;
  glutPostRedisplay();
}

void
motion(int x, int y)
{
  if (moving) {
    trackball(lastquat,
              (GLfloat)(2.0 * (W - x) / W - 1.0),
              (GLfloat)(2.0 * y / H - 1.0),
              (GLfloat)(2.0 * (W - beginx) / W - 1.0),
              (GLfloat)(2.0 * beginy / H - 1.0)
      );
    beginx = x;
    beginy = y;
    spinning = 1;
    glutIdleFunc(animate);
  }
}

GLboolean lightZeroSwitch = GL_TRUE, lightOneSwitch = GL_TRUE;

void
controlLights(int value)
{
  switch (value) {
  case 1:
    lightZeroSwitch = !lightZeroSwitch;
    if (lightZeroSwitch) {
      glEnable(GL_LIGHT0);
    } else {
      glDisable(GL_LIGHT0);
    }
    break;
  case 2:
    lightOneSwitch = !lightOneSwitch;
    if (lightOneSwitch) {
      glEnable(GL_LIGHT1);
    } else {
      glDisable(GL_LIGHT1);
    }
    break;
  }
  glutPostRedisplay();
}

void
vis(int visible)
{
  if (visible == GLUT_VISIBLE) {
    if (spinning)
      glutIdleFunc(animate);
  } else {
    if (spinning)
      glutIdleFunc(NULL);
  }
}

void
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
  trackball(curquat, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0, (GLfloat)0.0);
  glutCreateWindow("dinospin");
  glutDisplayFunc(redraw);
  glutVisibilityFunc(vis);
  glutMouseFunc(mouse);
  glutMotionFunc(motion);
  glutCreateMenu(controlLights);
  glutAddMenuEntry("Toggle right light", 1);
  glutAddMenuEntry("Toggle left light", 2);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  makeDinosaur();
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);
  glMatrixMode(GL_PROJECTION);
  gluPerspective( /* field of view in degree */ 40.0,  /* aspect 
                                                          ratio 
                                                        */ 1.0,
    /* Z near */ 1.0, /* Z far */ 40.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0.0, 0.0, 30.0,  /* eye is at (0,0,30) */
    0.0, 0.0, 0.0,      /* center is at (0,0,0) */
    0.0, 1.0, 0.);      /* up is in postivie Y direction */
  glPushMatrix();       /* dummy push so we can pop on model
                           recalc */
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, 1);
  glLightfv(GL_LIGHT0, GL_POSITION, lightZeroPosition);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, lightZeroColor);
  glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, (GLfloat)0.1);
  glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, (GLfloat)0.05);
  glLightfv(GL_LIGHT1, GL_POSITION, lightOnePosition);
  glLightfv(GL_LIGHT1, GL_DIFFUSE, lightOneColor);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);
  glLineWidth((GLfloat)2.0);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\lightlab.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

enum {
  BRASS, RED_PLASTIC, EMERALD, SLATE
} MaterialType;
enum {
  TORUS_MATERIAL = 1, TEAPOT_MATERIAL = 2, ICO_MATERIAL = 3
} MaterialDisplayList;
enum {
  LIGHT_OFF, LIGHT_RED, LIGHT_WHITE, LIGHT_GREEN
} LightValues;

GLfloat red_light[] =
{1.0, 0.0, 0.0, 1.0}, green_light[] =
{0.0, 1.0, 0.0, 1.0}, white_light[] =
{1.0, 1.0, 1.0, 1.0};
GLfloat left_light_position[] =
{-1.0, 0.0, 1.0, 0.0}, right_light_position[] =
{1.0, 0.0, 1.0, 0.0};
GLfloat brass_ambient[] =
{0.33, 0.22, 0.03, 1.0}, brass_diffuse[] =
{0.78, 0.57, 0.11, 1.0}, brass_specular[] =
{0.99, 0.91, 0.81, 1.0}, brass_shininess = 27.8;
GLfloat red_plastic_ambient[] =
{0.0, 0.0, 0.0}, red_plastic_diffuse[] =
{0.5, 0.0, 0.0}, red_plastic_specular[] =
{0.7, 0.6, 0.6}, red_plastic_shininess = 32.0;
GLfloat emerald_ambient[] =
{0.0215, 0.1745, 0.0215}, emerald_diffuse[] =
{0.07568, 0.61424, 0.07568}, emerald_specular[] =
{0.633, 0.727811, 0.633}, emerald_shininess = 76.8;
GLfloat slate_ambient[] =
{0.02, 0.02, 0.02}, slate_diffuse[] =
{0.02, 0.01, 0.01}, slate_specular[] =
{0.4, 0.4, 0.4}, slate_shininess = .78125;
int shade_model = GL_SMOOTH;
char *left_light, *right_light;
char *ico_material, *teapot_material, *torus_material;

void 
output(GLfloat x, GLfloat y, char *format,...)
{
  va_list args;
  char buffer[200], *p;

  va_start(args, format);
  vsprintf(buffer, format, args);
  va_end(args);
  glPushMatrix();
  glTranslatef(x, y, 0);
  for (p = buffer; *p; p++)
    glutStrokeCharacter(GLUT_STROKE_ROMAN, *p);
  glPopMatrix();
}

void 
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glScalef(1.3, 1.3, 1.3);
  glRotatef(20.0, 1.0, 0.0, 0.0);
  glPushMatrix();
  glTranslatef(-0.65, 0.7, 0.0);
  glRotatef(90.0, 1.0, 0.0, 0.0);
  glCallList(TORUS_MATERIAL);
  glutSolidTorus(0.275, 0.85, 10, 15);
  glPopMatrix();
  glPushMatrix();
  glTranslatef(-0.75, -0.8, 0.0);
  glCallList(TEAPOT_MATERIAL);
  glutSolidTeapot(0.7);
  glPopMatrix();
  glPushMatrix();
  glTranslatef(1.0, 0.0, -1.0);
  glCallList(ICO_MATERIAL);
  glutSolidIcosahedron();
  glPopMatrix();
  glPopMatrix();
  glPushAttrib(GL_ENABLE_BIT);
  glDisable(GL_DEPTH_TEST);
  glDisable(GL_LIGHTING);
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  gluOrtho2D(0, 3000, 0, 3000);
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  glLoadIdentity();
  output(80, 2800, "Torus: %s", torus_material);
  output(80, 2650, "Icosahedron: %s", ico_material);
  output(80, 2500, "Teapot: %s", teapot_material);
  output(80, 250, "Left light: %s", left_light);
  output(1700, 250, "Right light: %s", right_light);
  output(850, 100, "Shade model: %s",
    shade_model == GL_SMOOTH ? "smooth" : "flat");
  glPopMatrix();
  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
  glPopAttrib();
  glutSwapBuffers();
}

void 
light_select(GLenum which, int value, char **label)
{
  glEnable(which);
  switch (value) {
  case LIGHT_OFF:
    *label = "off";
    glDisable(which);
    break;
  case LIGHT_RED:
    *label = "red";
    glLightfv(which, GL_DIFFUSE, red_light);
    break;
  case LIGHT_WHITE:
    *label = "white";
    glLightfv(which, GL_DIFFUSE, white_light);
    break;
  case LIGHT_GREEN:
    *label = "green";
    glLightfv(which, GL_DIFFUSE, green_light);
    break;
  }
  glutPostRedisplay();
}

void 
left_light_select(int value)
{
  light_select(GL_LIGHT0, value, &left_light);
}

void 
right_light_select(int value)
{
  light_select(GL_LIGHT1, value, &right_light);
}

void 
material(int dlist, GLfloat * ambient, GLfloat * diffuse,
  GLfloat * specular, GLfloat shininess)
{
  glNewList(dlist, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_AMBIENT, ambient);
  glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuse);
  glMaterialfv(GL_FRONT, GL_SPECULAR, specular);
  glMaterialf(GL_FRONT, GL_SHININESS, shininess);
  glEndList();
}

char *
material_select(int object, int value)
{
  glutPostRedisplay();
  switch (value) {
  case BRASS:
    material(object, brass_ambient,
      brass_diffuse, brass_specular, brass_shininess);
    return "brass";
  case RED_PLASTIC:
    material(object, red_plastic_ambient, red_plastic_diffuse,
      red_plastic_specular, red_plastic_shininess);
    return "red plastic";
  case EMERALD:
    material(object, emerald_ambient, emerald_diffuse,
      emerald_specular, emerald_shininess);
    return "emerald";
  case SLATE:
    material(object, slate_ambient, slate_diffuse,
      slate_specular, slate_shininess);
    return "slate";
  }
  return NULL; /* avoid bogus warning! */
}

void 
torus_select(int value)
{
  torus_material = material_select(TORUS_MATERIAL, value);
}

void 
teapot_select(int value)
{
  teapot_material = material_select(TEAPOT_MATERIAL, value);
}

void 
ico_select(int value)
{
  ico_material = material_select(ICO_MATERIAL, value);
}

void 
main_menu_select(int value)
{
  if (value == 666)
    exit(0);
  glShadeModel(shade_model = value);
  glutPostRedisplay();
}

void 
main(int argc, char **argv)
{
  int left_light_m, right_light_m, torus_m, teapot_m, ico_m;

  glutInitWindowSize(400, 400);
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutCreateWindow("Lighting Laboratory");
  glutDisplayFunc(display);

#define LIGHT_MENU_ENTRIES() \
    glutAddMenuEntry("Disable", LIGHT_OFF); \
    glutAddMenuEntry("Red", LIGHT_RED); \
    glutAddMenuEntry("White", LIGHT_WHITE); \
    glutAddMenuEntry("Green", LIGHT_GREEN);
#define MATERIAL_MENU_ENTRIES() \
    glutAddMenuEntry("Brass", BRASS); \
    glutAddMenuEntry("Red plastic", RED_PLASTIC); \
    glutAddMenuEntry("Emerald", EMERALD); \
    glutAddMenuEntry("Slate", SLATE);

  left_light_m = glutCreateMenu(left_light_select);
  LIGHT_MENU_ENTRIES();
  right_light_m = glutCreateMenu(right_light_select);
  LIGHT_MENU_ENTRIES();
  torus_m = glutCreateMenu(torus_select);
  MATERIAL_MENU_ENTRIES();
  teapot_m = glutCreateMenu(teapot_select);
  MATERIAL_MENU_ENTRIES();
  ico_m = glutCreateMenu(ico_select);
  MATERIAL_MENU_ENTRIES();

  glutCreateMenu(main_menu_select);
  glutAddMenuEntry("Smooth shading", GL_SMOOTH);
  glutAddMenuEntry("Flat shading", GL_FLAT);
  glutAddSubMenu("Left light", left_light_m);
  glutAddSubMenu("Right light", right_light_m);
  glutAddSubMenu("Torus", torus_m);
  glutAddSubMenu("Teapot", teapot_m);
  glutAddSubMenu("Icosahedron", ico_m);
  glutAddMenuEntry("Quit", 666);
  glutAttachMenu(GLUT_RIGHT_BUTTON);

  glLightfv(GL_LIGHT0, GL_POSITION, left_light_position);
  glLightfv(GL_LIGHT0, GL_SPECULAR, white_light);
  glLightfv(GL_LIGHT1, GL_POSITION, right_light_position);
  glLightfv(GL_LIGHT1, GL_SPECULAR, white_light);
  left_light_select(LIGHT_RED);
  right_light_select(LIGHT_GREEN);
  torus_select(RED_PLASTIC);
  teapot_select(BRASS);
  ico_select(EMERALD);
  glEnable(GL_LIGHTING);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_NORMALIZE);
  glLineWidth(1.0);
  glMatrixMode(GL_PROJECTION);
  gluPerspective( /* degrees field of view */ 50.0,
    /* aspect ratio */ 1.0, /* Z near */ 1.0, /* Z far */ 10.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0.0, 0.0, 5.0,  /* eye is at (0,0,5) */
    0.0, 0.0, 0.0,      /* center is at (0,0,0) */
    0.0, 1.0, 0.);      /* up is in positive Y direction */
  glTranslatef(0.0, 0.0, -1.0);

  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\checker.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  checker.c
 *  This program texture maps a checkerboard image onto
 *  two rectangles.  This program clamps the texture, if
 *  the texture coordinates fall outside 0.0 and 1.0.
 */
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glut.h>

/*	Create checkerboard texture	*/
#define	checkImageWidth 64
#define	checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makeCheckImage(void)
{
    int i, j, c;
    
    for (i = 0; i < checkImageWidth; i++) {
	for (j = 0; j < checkImageHeight; j++) {
	    c = ((((i&0x8)==0)^((j&0x8))==0))*255;
	    checkImage[i][j][0] = (GLubyte) c;
	    checkImage[i][j][1] = (GLubyte) c;
	    checkImage[i][j][2] = (GLubyte) c;
	}
    }
}

void myinit(void)
{    
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    makeCheckImage();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, checkImageWidth, 
	checkImageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, 
	&checkImage[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 1.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(1.0, 1.0); glVertex3f(0.0, 1.0, 0.0);
    glTexCoord2f(1.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

    glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(0.0, 1.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(1.0, 1.0); glVertex3f(2.41421, 1.0, -1.41421);
    glTexCoord2f(1.0, 0.0); glVertex3f(2.41421, -1.0, -1.41421);
    glEnd();
    glutSwapBuffers();
}

void myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -3.6);
}

void
main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutCreateWindow("checker");
    myinit();
    glutReshapeFunc (myReshape);
    glutDisplayFunc(display);
    glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\glutdino.c ===
/* Copyright (c) Mark J. Kilgard, 1994.  */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>       /* for cos(), sin(), and sqrt() */
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glu.h>
#include <GL/glut.h>

typedef enum {
  RESERVED, BODY_SIDE, BODY_EDGE, BODY_WHOLE, ARM_SIDE, ARM_EDGE, ARM_WHOLE,
  LEG_SIDE, LEG_EDGE, LEG_WHOLE, EYE_SIDE, EYE_EDGE, EYE_WHOLE, DINOSAUR
} displayLists;

GLfloat angle = -150;   /* in degrees */
GLboolean doubleBuffer = GL_TRUE, iconic = GL_FALSE, keepAspect = GL_FALSE;
int moving, begin;
int W = 300, H = 300;
GLdouble bodyWidth = 2.0;
int newModel = 1;
/* *INDENT-OFF* */
GLfloat body[][2] = { {0, 3}, {1, 1}, {5, 1}, {8, 4}, {10, 4}, {11, 5},
  {11, 11.5}, {13, 12}, {13, 13}, {10, 13.5}, {13, 14}, {13, 15}, {11, 16},
  {8, 16}, {7, 15}, {7, 13}, {8, 12}, {7, 11}, {6, 6}, {4, 3}, {3, 2},
  {1, 2} };
GLfloat arm[][2] = { {8, 10}, {9, 9}, {10, 9}, {13, 8}, {14, 9}, {16, 9},
  {15, 9.5}, {16, 10}, {15, 10}, {15.5, 11}, {14.5, 10}, {14, 11}, {14, 10},
  {13, 9}, {11, 11}, {9, 11} };
GLfloat leg[][2] = { {8, 6}, {8, 4}, {9, 3}, {9, 2}, {8, 1}, {8, 0.5}, {9, 0},
  {12, 0}, {10, 1}, {10, 2}, {12, 4}, {11, 6}, {10, 7}, {9, 7} };
GLfloat eye[][2] = { {8.75, 15}, {9, 14.7}, {9.6, 14.7}, {10.1, 15},
  {9.6, 15.25}, {9, 15.25} };
GLfloat lightZeroPosition[] = {10.0, 4.0, 10.0, 1.0};
GLfloat lightZeroColor[] = {0.8, 1.0, 0.8, 1.0}; /* green-tinted */
GLfloat lightOnePosition[] = {-1.0, -2.0, 1.0, 0.0};
GLfloat lightOneColor[] = {0.6, 0.3, 0.2, 1.0}; /* red-tinted */
GLfloat skinColor[] = {0.1, 1.0, 0.1, 1.0}, eyeColor[] = {1.0, 0.2, 0.2, 1.0};
/* *INDENT-ON* */

void
extrudeSolidFromPolygon(GLfloat data[][2], unsigned int dataSize,
  GLdouble thickness, GLuint side, GLuint edge, GLuint whole)
{
  static GLUtriangulatorObj *tobj = NULL;
  GLdouble vertex[3], dx, dy, len;
  int i;
  int count = dataSize / (2 * sizeof(GLfloat));

  if (tobj == NULL) {
    tobj = gluNewTess();  /* create and initialize a GLU
                             polygon * * tesselation object */
    gluTessCallback(tobj, GLU_BEGIN, glBegin);
    gluTessCallback(tobj, GLU_VERTEX, glVertex2fv);  /* semi-tricky 
                                                      */
    gluTessCallback(tobj, GLU_END, glEnd);
  }
  glNewList(side, GL_COMPILE);
  glShadeModel(GL_SMOOTH);  /* smooth minimizes seeing
                               tessellation */
  gluBeginPolygon(tobj);
  for (i = 0; i < count; i++) {
    vertex[0] = data[i][0];
    vertex[1] = data[i][1];
    vertex[2] = 0;
    gluTessVertex(tobj, vertex, data[i]);
  }
  gluEndPolygon(tobj);
  glEndList();
  glNewList(edge, GL_COMPILE);
  glShadeModel(GL_FLAT);  /* flat shade keeps angular hands
                             from being * * "smoothed" */
  glBegin(GL_QUAD_STRIP);
  for (i = 0; i <= count; i++) {
    /* mod function handles closing the edge */
    glVertex3f(data[i % count][0], data[i % count][1], 0.0);
    glVertex3f(data[i % count][0], data[i % count][1], thickness);
    /* Calculate a unit normal by dividing by Euclidean
       distance. We * could be lazy and use
       glEnable(GL_NORMALIZE) so we could pass in * arbitrary
       normals for a very slight performance hit. */
    dx = data[(i + 1) % count][1] - data[i % count][1];
    dy = data[i % count][0] - data[(i + 1) % count][0];
    len = sqrt(dx * dx + dy * dy);
    glNormal3f(dx / len, dy / len, 0.0);
  }
  glEnd();
  glEndList();
  glNewList(whole, GL_COMPILE);
  glFrontFace(GL_CW);
  glCallList(edge);
  glNormal3f(0.0, 0.0, -1.0);  /* constant normal for side */
  glCallList(side);
  glPushMatrix();
  glTranslatef(0.0, 0.0, thickness);
  glFrontFace(GL_CCW);
  glNormal3f(0.0, 0.0, 1.0);  /* opposite normal for other side 
                               */
  glCallList(side);
  glPopMatrix();
  glEndList();
}

void
makeDinosaur(void)
{
  GLfloat bodyWidth = 3.0;

  extrudeSolidFromPolygon(body, sizeof(body), bodyWidth,
    BODY_SIDE, BODY_EDGE, BODY_WHOLE);
  extrudeSolidFromPolygon(arm, sizeof(arm), bodyWidth / 4,
    ARM_SIDE, ARM_EDGE, ARM_WHOLE);
  extrudeSolidFromPolygon(leg, sizeof(leg), bodyWidth / 2,
    LEG_SIDE, LEG_EDGE, LEG_WHOLE);
  extrudeSolidFromPolygon(eye, sizeof(eye), bodyWidth + 0.2,
    EYE_SIDE, EYE_EDGE, EYE_WHOLE);
  glNewList(DINOSAUR, GL_COMPILE);
  glMaterialfv(GL_FRONT, GL_DIFFUSE, skinColor);
  glCallList(BODY_WHOLE);
  glPushMatrix();
  glTranslatef(0.0, 0.0, bodyWidth);
  glCallList(ARM_WHOLE);
  glCallList(LEG_WHOLE);
  glTranslatef(0.0, 0.0, -bodyWidth - bodyWidth / 4);
  glCallList(ARM_WHOLE);
  glTranslatef(0.0, 0.0, -bodyWidth / 4);
  glCallList(LEG_WHOLE);
  glTranslatef(0.0, 0.0, bodyWidth / 2 - 0.1);
  glMaterialfv(GL_FRONT, GL_DIFFUSE, eyeColor);
  glCallList(EYE_WHOLE);
  glPopMatrix();
  glEndList();
}

void
recalcModelView(void)
{
  glPopMatrix();
  glPushMatrix();
  glRotatef(angle, 0.0, 1.0, 0.0);
  glTranslatef(-8, -8, -bodyWidth / 2);
  newModel = 0;
}

void
redraw(void)
{
  if (newModel)
    recalcModelView();
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glCallList(DINOSAUR);
  glutSwapBuffers();
}

void
mouse(int button, int state, int x, int y)
{
  if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
    moving = 1;
    begin = x;
  }
  if (button == GLUT_LEFT_BUTTON && state == GLUT_UP) {
    moving = 0;
  }
}

void
motion(int x, int y)
{
  if (moving) {
    angle = angle + (x - begin);
    begin = x;
    newModel = 1;
    glutPostRedisplay();
  }
}

GLboolean lightZeroSwitch = GL_TRUE, lightOneSwitch = GL_TRUE;

void
controlLights(int value)
{
  switch (value) {
  case 1:
    lightZeroSwitch = !lightZeroSwitch;
    if (lightZeroSwitch) {
      glEnable(GL_LIGHT0);
    } else {
      glDisable(GL_LIGHT0);
    }
    break;
  case 2:
    lightOneSwitch = !lightOneSwitch;
    if (lightOneSwitch) {
      glEnable(GL_LIGHT1);
    } else {
      glDisable(GL_LIGHT1);
    }
    break;
  }
  glutPostRedisplay();
}

void
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
  glutCreateWindow("glutdino");
  glutDisplayFunc(redraw);
  glutMouseFunc(mouse);
  glutMotionFunc(motion);
  glutCreateMenu(controlLights);
  glutAddMenuEntry("Toggle right light", 1);
  glutAddMenuEntry("Toggle left light", 2);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  makeDinosaur();
  glEnable(GL_CULL_FACE);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);
  glMatrixMode(GL_PROJECTION);
  gluPerspective( /* field of view in degree */ 40.0,  /* aspect 
                                                          ratio 
                                                        */ 1.0,
    /* Z near */ 1.0, /* Z far */ 40.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0.0, 0.0, 30.0,  /* eye is at (0,0,30) */
    0.0, 0.0, 0.0,      /* center is at (0,0,0) */
    0.0, 1.0, 0.);      /* up is in postivie Y direction */
  glPushMatrix();       /* dummy push so we can pop on model
                           recalc */
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, 1);
  glLightfv(GL_LIGHT0, GL_POSITION, lightZeroPosition);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, lightZeroColor);
  glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 0.1);
  glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.05);
  glLightfv(GL_LIGHT1, GL_POSITION, lightOnePosition);
  glLightfv(GL_LIGHT1, GL_DIFFUSE, lightOneColor);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\olympic.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
 * (c) Copyright 1993, 1994, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

#ifndef M_PI
#define M_PI 3.14159265358979323846
#define M_PI_2 (M_PI/2.0)
#endif

#ifndef GLUT_WIN32
extern double drand48(void);
extern void srand48(long seedval);
#else
double drand48(void)
{
    return (double)rand() / RAND_MAX;
}
void srand48(long seedval)
{
    srand(seedval);
}
#endif

#define XSIZE   100
#define YSIZE   75

#define RINGS 5
#define BLUERING 0
#define BLACKRING 1
#define REDRING 2
#define YELLOWRING 3
#define GREENRING 4

#define BACKGROUND 8

enum {
    BLACK = 0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE
};

typedef short Point[2];

GLenum rgb, doubleBuffer, directRender;

unsigned char rgb_colors[RINGS][3];
int mapped_colors[RINGS];
float dests[RINGS][3];
float offsets[RINGS][3];
float angs[RINGS];
float rotAxis[RINGS][3];
int iters[RINGS];
GLuint theTorus;

void 
FillTorus(float rc, int numc, float rt, int numt)
{
    int i, j, k;
    double s, t;
    double x, y, z;
    double pi, twopi;

    pi = M_PI;
    twopi = 2 * pi;

    for (i = 0; i < numc; i++) {
        glBegin(GL_QUAD_STRIP);
        for (j = 0; j <= numt; j++) {
            for (k = 1; k >= 0; k--) {
                s = (i + k) % numc + 0.5;
                t = j % numt;

                x = cos(t * twopi / numt) * cos(s * twopi / numc);
                y = sin(t * twopi / numt) * cos(s * twopi / numc);
                z = sin(s * twopi / numc);
                glNormal3f(x, y, z);

                x = (rt + rc * cos(s * twopi / numc)) * cos(t * twopi / numt);
                y = (rt + rc * cos(s * twopi / numc)) * sin(t * twopi / numt);
                z = rc * sin(s * twopi / numc);
                glVertex3f(x, y, z);
            }
        }
        glEnd();
    }
}

float 
Clamp(int iters_left, float t)
{

    if (iters_left < 3) {
        return 0.0;
    }
    return (iters_left - 2) * t / iters_left;
}

void 
Idle(void)
{
    int i, j;
    int more = GL_FALSE;

    for (i = 0; i < RINGS; i++) {
        if (iters[i]) {
            for (j = 0; j < 3; j++) {
                offsets[i][j] = Clamp(iters[i], offsets[i][j]);
            }
            angs[i] = Clamp(iters[i], angs[i]);
            iters[i]--;
	    more = GL_TRUE;
        }
    }
    if(more) {
        glutPostRedisplay();
    } else {
	glutIdleFunc(NULL);
    }
}

void 
DrawScene(void)
{
    int i;

    glPushMatrix();

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0);

    for (i = 0; i < RINGS; i++) {
        if (rgb) {
            glColor3ubv(rgb_colors[i]);
        } else {
            glIndexi(mapped_colors[i]);
        }
        glPushMatrix();
        glTranslatef(dests[i][0] + offsets[i][0], dests[i][1] + offsets[i][1],
            dests[i][2] + offsets[i][2]);
        glRotatef(angs[i], rotAxis[i][0], rotAxis[i][1], rotAxis[i][2]);
        glCallList(theTorus);
        glPopMatrix();
    }

    glPopMatrix();
    if (doubleBuffer) {
        glutSwapBuffers();
    }
}

float 
MyRand(void)
{

    return 10.0 * (drand48() - 0.5);
}

void 
ReInit(void)
{
    int i;
    float deviation;

    deviation = MyRand() / 2;
    deviation = deviation * deviation;
    for (i = 0; i < RINGS; i++) {
        offsets[i][0] = MyRand();
        offsets[i][1] = MyRand();
        offsets[i][2] = MyRand();
        angs[i] = 260.0 * MyRand();
        rotAxis[i][0] = MyRand();
        rotAxis[i][1] = MyRand();
        rotAxis[i][2] = MyRand();
        iters[i] = (deviation * MyRand() + 60.0);
    }
}

void 
Init(void)
{
    int i;
    float top_y = 1.0;
    float bottom_y = 0.0;
    float top_z = 0.15;
    float bottom_z = 0.69;
    float spacing = 2.5;
    static float lmodel_ambient[] =
    {0.0, 0.0, 0.0, 0.0};
    static float lmodel_twoside[] =
    {GL_FALSE};
    static float lmodel_local[] =
    {GL_FALSE};
    static float light0_ambient[] =
    {0.1, 0.1, 0.1, 1.0};
    static float light0_diffuse[] =
    {1.0, 1.0, 1.0, 0.0};
    static float light0_position[] =
    {0.8660254, 0.5, 1, 0};
    static float light0_specular[] =
    {1.0, 1.0, 1.0, 0.0};
    static float bevel_mat_ambient[] =
    {0.0, 0.0, 0.0, 1.0};
    static float bevel_mat_shininess[] =
    {40.0};
    static float bevel_mat_specular[] =
    {1.0, 1.0, 1.0, 0.0};
    static float bevel_mat_diffuse[] =
    {1.0, 0.0, 0.0, 0.0};

    srand48(glutGet(GLUT_ELAPSED_TIME)*10);
    ReInit();
    for (i = 0; i < RINGS; i++) {
        rgb_colors[i][0] = rgb_colors[i][1] = rgb_colors[i][2] = 0;
    }
    rgb_colors[BLUERING][2] = 255;
    rgb_colors[REDRING][0] = 255;
    rgb_colors[GREENRING][1] = 255;
    rgb_colors[YELLOWRING][0] = 255;
    rgb_colors[YELLOWRING][1] = 255;
    mapped_colors[BLUERING] = BLUE;
    mapped_colors[REDRING] = RED;
    mapped_colors[GREENRING] = GREEN;
    mapped_colors[YELLOWRING] = YELLOW;
    mapped_colors[BLACKRING] = BLACK;

    dests[BLUERING][0] = -spacing;
    dests[BLUERING][1] = top_y;
    dests[BLUERING][2] = top_z;

    dests[BLACKRING][0] = 0.0;
    dests[BLACKRING][1] = top_y;
    dests[BLACKRING][2] = top_z;

    dests[REDRING][0] = spacing;
    dests[REDRING][1] = top_y;
    dests[REDRING][2] = top_z;

    dests[YELLOWRING][0] = -spacing / 2.0;
    dests[YELLOWRING][1] = bottom_y;
    dests[YELLOWRING][2] = bottom_z;

    dests[GREENRING][0] = spacing / 2.0;
    dests[GREENRING][1] = bottom_y;
    dests[GREENRING][2] = bottom_z;

    theTorus = glGenLists(1);
    glNewList(theTorus, GL_COMPILE);
    FillTorus(0.1, 8, 1.0, 25);
    glEndList();

    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glEnable(GL_DEPTH_TEST);
    glClearDepth(1.0);

    if (rgb) {
        glClearColor(0.5, 0.5, 0.5, 0.0);
        glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
        glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
        glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
        glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
        glEnable(GL_LIGHT0);

        glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_local);
        glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
        glEnable(GL_LIGHTING);

        glMaterialfv(GL_FRONT, GL_AMBIENT, bevel_mat_ambient);
        glMaterialfv(GL_FRONT, GL_SHININESS, bevel_mat_shininess);
        glMaterialfv(GL_FRONT, GL_SPECULAR, bevel_mat_specular);
        glMaterialfv(GL_FRONT, GL_DIFFUSE, bevel_mat_diffuse);

        glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
        glEnable(GL_COLOR_MATERIAL);
        glShadeModel(GL_SMOOTH);
    } else {
        glClearIndex(BACKGROUND);
        glShadeModel(GL_FLAT);
    }

    glMatrixMode(GL_PROJECTION);
    gluPerspective(45, 1.33, 0.1, 100.0);
    glMatrixMode(GL_MODELVIEW);
}

void 
Reshape(int width, int height)
{
    glViewport(0, 0, width, height);
}

void 
Key(unsigned char key, int x, int y)
{

    switch (key) {
    case 27:
        exit(0);
        break;
    case ' ':
        ReInit();
	glutIdleFunc(Idle);
        break;
    }
}

GLenum 
Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;

    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-ci") == 0) {
            rgb = GL_FALSE;
        } else if (strcmp(argv[i], "-rgb") == 0) {
            rgb = GL_TRUE;
        } else if (strcmp(argv[i], "-sb") == 0) {
            doubleBuffer = GL_FALSE;
        } else if (strcmp(argv[i], "-db") == 0) {
            doubleBuffer = GL_TRUE;
        } else {
            printf("%s (Bad option).\n", argv[i]);
            return GL_FALSE;
        }
    }
    return GL_TRUE;
}

void
visible(int vis)
{
    if(vis == GLUT_VISIBLE) {
	glutIdleFunc(Idle);
    } else {
	glutIdleFunc(NULL);
    }
}

void 
main(int argc, char **argv)
{
    GLenum type;

    glutInitWindowSize(400, 300);
    glutInit(&argc, argv);
    if (Args(argc, argv) == GL_FALSE) {
        exit(1);
    }
    type = (rgb) ? GLUT_RGB : GLUT_INDEX;
    type |= (doubleBuffer) ? GLUT_DOUBLE : GLUT_SINGLE;
    glutInitDisplayMode(type);

    glutCreateWindow("Olympic");

    Init();

    glutReshapeFunc(Reshape);
    glutKeyboardFunc(Key);
    glutDisplayFunc(DrawScene);

    glutVisibilityFunc(visible);

    glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\origami.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

enum {
  S_FLAT,                 /* completely flat sheet of paper */
  FLAP1,                /* left flap being folded in */
  FLAP2,                /* right flap being folded int */
  CENTER2,              /* right side folded up at center */
  WING2,                /* right wing folded down */
  CENTER1,              /* left side folded up at center */
  WING1,                /* left wing folded down */
  FOLDED                /* fully folded paper airplane */
} States;

int motion = 1;
int spinning = 1;
int state = S_FLAT;
int click = 0;
int delay = 0;
int direction;
float flap1_angle = 0;
float flap2_angle = 0;
float center1_angle = 0;
float center2_angle = 0;
float wing1_angle = 0;
float wing2_angle = 0;

/**

These correspond to the polygons for the paper sections:

  +----------+----------+
  |         /|\         |
  |  2     / | \    3   |
  |       /  |  \       |
  +------/   |   \------+
  |     /|   |   |\     |
  | 1  / |   |   | \ 4  |
  |   /  |   |   |  \   |
  |  /   |   |   |   \  |
  | /    | 5 | 6 |    \ |
  |/     |   |   |     \|
  +      |   |   |      +
  |  7   |   |   |  8   |
  |      |   |   |      |
  |      |   |   |      |
  |      |   |   |      |
  |      |   |   |      |
  |      |   |   |      |
  |      |   |   |      |
  +------+---+---+------+

*/

typedef GLfloat Point[2];

Point poly1[] =
{
  {-1, 0},
  {-1 / 3.0, 2 / 3.0},
  {-1, 2 / 3.0}
};

Point poly2[] =
{
  {-1, 1},
  {-1, 2 / 3.0},
  {-1 / 3.0, 2 / 3.0},
  {0, 1}
};

Point poly3[] =
{
  {0, 1},
  {1, 1},
  {1, 2 / 3.0},
  {1 / 3.0, 2 / 3.0}
};

Point poly4[] =
{
  {1 / 3.0, 2 / 3.0},
  {1, 2 / 3.0},
  {1, 0}
};

Point poly5[] =
{
  {-1 / 3.0, 2 / 3.0},
  {0, 1},
  {0, -1.5},
  {-1 / 3.0, -1.5}
};

Point poly6[] =
{
  {0, 1},
  {1 / 3.0, 2 / 3.0},
  {1 / 3.0, -1.5},
  {0, -1.5}
};

Point poly7[] =
{
  {-1, 0},
  {-1 / 3.0, 2 / 3.0},
  {-1 / 3.0, -1.5},
  {-1, -1.5}
};

Point poly8[] =
{
  {1, 0},
  {1 / 3.0, 2 / 3.0},
  {1 / 3.0, -1.5},
  {1, -1.5}
};

void
polydlist(int dlist, int num, Point points[])
{
  int i;

  glNewList(dlist, GL_COMPILE);
  glBegin(GL_POLYGON);
  for (i = 0; i < num; i++) {
    glVertex2fv(&points[i][0]);
  }
  glEnd();
  glEndList();
}

void
idle(void)
{
  if (spinning)
    click++;
  switch (state) {
  case S_FLAT:
    delay++;
    if (delay >= 80) {
      delay = 0;
      state = FLAP1;
      glutSetWindowTitle("origami (folding)");
      direction = 1;
    }
    break;
  case FLAP1:
    flap1_angle += 2 * direction;
    if (flap1_angle >= 180) {
      state = FLAP2;
    } else if (flap1_angle <= 0) {
      state = S_FLAT;
    }
    break;
  case FLAP2:
    flap2_angle += 2 * direction;
    if (flap2_angle >= 180) {
      state = CENTER2;
    } else if (flap2_angle <= 0) {
      state = FLAP1;
    }
    break;
  case CENTER2:
    center2_angle += 2 * direction;
    if (center2_angle >= 84) {
      state = WING2;
    } else if (center2_angle <= 0) {
      state = FLAP2;
    }
    break;
  case WING2:
    wing2_angle += 2 * direction;
    if (wing2_angle >= 84) {
      state = CENTER1;
    } else if (wing2_angle <= 0) {
      state = CENTER2;
    }
    break;
  case CENTER1:
    center1_angle += 2 * direction;
    if (center1_angle >= 84) {
      state = WING1;
    } else if (center1_angle <= 0) {
      state = WING2;
    }
    break;
  case WING1:
    wing1_angle += 2 * direction;
    if (wing1_angle >= 84) {
      state = FOLDED;
    } else if (wing1_angle <= 0) {
      state = CENTER1;
    }
    break;
  case FOLDED:
    delay++;
    if (delay >= 80) {
      delay = 0;
      glutSetWindowTitle("origami (unfolding)");
      direction = -1;
      state = WING1;
    }
    break;
  }
  glutPostRedisplay();
}

void
draw_folded_plane(void)
{
  /* *INDENT-OFF* */
  glPushMatrix();
    glRotatef(click, 0, 0, 1);
    glRotatef(click / 5.0, 0, 1, 0);
    glTranslatef(0, .25, 0);
    glPushMatrix();
      glRotatef(center1_angle, 0, 1, 0);
      glPushMatrix();
        glTranslatef(-.5, .5, 0);
        glRotatef(flap1_angle, 1, 1, 0);
        glTranslatef(.5, -.5, 0);
        glCallList(2);
      glPopMatrix();
      glCallList(5);

      glPushMatrix();
        glTranslatef(-1 / 3.0, 0, 0);
        glRotatef(-wing1_angle, 0, 1, 0);
        glTranslatef(1 / 3.0, 0, 0);

        glCallList(7);
        glPushMatrix();
          glTranslatef(-.5, .5, 0);
          glRotatef(flap1_angle, 1, 1, 0);
          glTranslatef(.5, -.5, 0);
          glCallList(1);
        glPopMatrix();
      glPopMatrix();
    glPopMatrix();

    glPushMatrix();
      glRotatef(-center2_angle, 0, 1, 0);
      glPushMatrix();
        glTranslatef(.5, .5, 0);
        glRotatef(-flap2_angle, -1, 1, 0);
        glTranslatef(-.5, -.5, 0);
        glCallList(3);
      glPopMatrix();
      glCallList(6);

      glPushMatrix();
        glTranslatef(1 / 3.0, 0, 0);
        glRotatef(wing2_angle, 0, 1, 0);
        glTranslatef(-1 / 3.0, 0, 0);

        glCallList(8);
        glPushMatrix();
          glTranslatef(.5, .5, 0);
          glRotatef(-flap2_angle, -1, 1, 0);
          glTranslatef(-.5, -.5, 0);
          glCallList(4);
        glPopMatrix();
      glPopMatrix();
    glPopMatrix();
  glPopMatrix();
  /* *INDENT-ON* */

}

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
  glColor3ub(67, 205, 128);
  draw_folded_plane();
  glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
  glColor3ub(255, 255, 255);
  glPushMatrix();
  glTranslatef(0, 0, .05);
  draw_folded_plane();
  glPopMatrix();
  glutSwapBuffers();
}

void
visible(int state)
{
  if (state == GLUT_VISIBLE) {
    if (motion)
      glutIdleFunc(idle);
  } else {
    glutIdleFunc(NULL);
  }
}

void
menu(int value)
{
  switch (value) {
  case 1:
    direction = -direction;
    if (direction > 0) {
      glutSetWindowTitle("origami (folding)");
    } else {
      glutSetWindowTitle("origami (unfolding)");
    }
    break;
  case 2:
    motion = 1 - motion;
    if (motion) {
      glutIdleFunc(idle);
    } else {
      glutIdleFunc(NULL);
    }
    break;
  case 3:
    spinning = 1 - spinning;
    break;
  case 666:
    exit(0);
  }
}

void
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB | GLUT_DEPTH | GLUT_DOUBLE);
  glutCreateWindow("origami");
  glutDisplayFunc(display);
  glutVisibilityFunc(visible);
  glClearColor(.488, .617, .75, 1.0);
  glMatrixMode(GL_PROJECTION);
  gluPerspective(40.0, 1.0, 0.1, 10.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0, 0, 5.5,
    0, 0, 0,
    0, 1, 0);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LEQUAL);
  glLineWidth(2.0);
  polydlist(1, sizeof(poly1) / sizeof(Point), poly1);
  polydlist(2, sizeof(poly2) / sizeof(Point), poly2);
  polydlist(3, sizeof(poly3) / sizeof(Point), poly3);
  polydlist(4, sizeof(poly4) / sizeof(Point), poly4);
  polydlist(5, sizeof(poly5) / sizeof(Point), poly5);
  polydlist(6, sizeof(poly6) / sizeof(Point), poly6);
  polydlist(7, sizeof(poly7) / sizeof(Point), poly7);
  polydlist(8, sizeof(poly8) / sizeof(Point), poly8);
  glutCreateMenu(menu);
  glutAddMenuEntry("Reverse direction", 1);
  glutAddMenuEntry("Toggle motion", 2);
  glutAddMenuEntry("Toggle spinning", 3);
  glutAddMenuEntry("Quit", 666);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\fog.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  fog.c
 *  This program draws 5 red teapots, each at a different 
 *  z distance from the eye, in different types of fog.  
 *  Pressing the left mouse button chooses between 3 types of 
 *  fog:  exponential, exponential squared, and linear.  
 *  In this program, there is a fixed density value, as well 
 *  as fixed start and end values for the linear fog.
 */
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <math.h>
#include <GL/glut.h>

GLint fogMode;

void 
selectFog(int mode)
{
    switch(mode) {
    case GL_LINEAR:
        glFogf(GL_FOG_START, 1.0);
        glFogf(GL_FOG_END, 5.0);
	/* falls through */
    case GL_EXP2:
    case GL_EXP:
        glFogi(GL_FOG_MODE, mode);
	glutPostRedisplay();
	break;
    case 0:
	exit(0);
    }
}

/*  Initialize z-buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
void 
myinit(void)
{
    GLfloat position[] =
    {0.0, 3.0, 3.0, 0.0};
    GLfloat local_view[] =
    {0.0};

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace(GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glEnable(GL_FOG);
    {
        GLfloat fogColor[4] =
        {0.5, 0.5, 0.5, 1.0};

        fogMode = GL_EXP;
        glFogi(GL_FOG_MODE, fogMode);
        glFogfv(GL_FOG_COLOR, fogColor);
        glFogf(GL_FOG_DENSITY, 0.35);
        glHint(GL_FOG_HINT, GL_DONT_CARE);
        glClearColor(0.5, 0.5, 0.5, 1.0);
    }
}

void 
renderRedTeapot(GLfloat x, GLfloat y, GLfloat z)
{
    float mat[4];

    glPushMatrix();
    glTranslatef(x, y, z);
    mat[0] = 0.1745;
    mat[1] = 0.01175;
    mat[2] = 0.01175;
    mat[3] = 1.0;
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat);
    mat[0] = 0.61424;
    mat[1] = 0.04136;
    mat[2] = 0.04136;
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = 0.727811;
    mat[1] = 0.626959;
    mat[2] = 0.626959;
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat);
    glMaterialf(GL_FRONT, GL_SHININESS, 0.6 * 128.0);
    glutSolidTeapot(1.0);
    glPopMatrix();
}

/*  display() draws 5 teapots at different z positions.
 */
void 
display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    renderRedTeapot(-4.0, -0.5, -1.0);
    renderRedTeapot(-2.0, -0.5, -2.0);
    renderRedTeapot(0.0, -0.5, -3.0);
    renderRedTeapot(2.0, -0.5, -4.0);
    renderRedTeapot(4.0, -0.5, -5.0);
    glFlush();
}

void 
myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= (h * 3))
        glOrtho(-6.0, 6.0, -2.0 * ((GLfloat) h * 3) / (GLfloat) w,
            2.0 * ((GLfloat) h * 3) / (GLfloat) w, 0.0, 10.0);
    else
        glOrtho(-6.0 * (GLfloat) w / ((GLfloat) h * 3),
            6.0 * (GLfloat) w / ((GLfloat) h * 3), -2.0, 2.0, 0.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
void 
main(int argc, char **argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(450, 150);
    glutCreateWindow(argv[0]);
    myinit();
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    glutCreateMenu(selectFog);
    glutAddMenuEntry("Fog EXP", GL_EXP);
    glutAddMenuEntry("Fog EXP2", GL_EXP2);
    glutAddMenuEntry("Fog LINEAR", GL_LINEAR);
    glutAddMenuEntry("Quit", 0);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\sphere.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

GLfloat light_diffuse[] =
{1.0, 0.0, 0.0, 1.0};
GLfloat light_position[] =
{1.0, 1.0, 1.0, 0.0};
GLUquadricObj *qobj;

int win1, win2, submenu1, submenu2;

int list = 1;

float thetime = 0.0;

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  if (glutGetWindow() == win1) {
    glCallList(list);   /* render sphere display list */
  } else {
    glCallList(1);      /* render sphere display list */
  }
  glutSwapBuffers();
}

void
display_win1(void)
{
  glPushMatrix();
  glTranslatef(0.0, 0.0, -1 - 2 * sin(thetime));
  display();
  glPopMatrix();
}

void
idle(void)
{
  GLfloat light_position[] =
  {1.0, 1.0, 1.0, 0.0};

  glutSetWindow(win1);
  thetime += 0.05;
  light_position[1] = 1 + sin(thetime);
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
  display_win1();
}

void
delayed_stop(int value)
{
  glutIdleFunc(NULL);
}

void
it(int value)
{
    static idling = 0;
    
  printf("menu selection: win=%d, menu=%d\n", glutGetWindow(), glutGetMenu());
  switch (value) {
  case 1:
    if (list == 1) {
      list = 2;
    } else {
      list = 1;
    }
    glutPostRedisplay();
    break;
  case 2:
    exit(0);
    break;
  case 3:
    glutAddMenuEntry("new entry", value + 9);
    break;
  case 4:
    glutChangeToMenuEntry(1, "toggle it for drawing", 1);
    if (!idling)
    {
        glutChangeToMenuEntry(4, "motion done", 4);
        glutIdleFunc(idle);
        idling = 1;
    }
    else
    {
        glutChangeToMenuEntry(4, "motion", 4);
        glutIdleFunc(NULL);
        idling = 0;
    }
    break;
  case 5:
    glutIdleFunc(NULL);
    break;
  case 6:
    glutTimerFunc(2000, delayed_stop, 0);
    break;
  default:
    printf("value = %d\n", value);
  }
}

void
init(void)
{
  gluQuadricDrawStyle(qobj, GLU_FILL);
  glNewList(1, GL_COMPILE);  /* create sphere display list */
  gluSphere(qobj, /* radius */ 1.0, /* slices */ 20,  /* stacks 
                                                       */ 20);
  glEndList();
  gluQuadricDrawStyle(qobj, GLU_LINE);
  glNewList(2, GL_COMPILE);  /* create sphere display list */
  gluSphere(qobj, /* radius */ 1.0, /* slices */ 20,  /* stacks 
                                                       */ 20);
  glEndList();
  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);
  glMatrixMode(GL_PROJECTION);
  gluPerspective( /* field of view in degree */ 40.0,  /* aspect 
                                                          ratio 
                                                        */ 1.0,
    /* Z near */ 1.0, /* Z far */ 10.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0.0, 0.0, 5.0,  /* eye is at (0,0,5) */
    0.0, 0.0, 0.0,      /* center is at (0,0,0) */
    0.0, 1.0, 0.);      /* up is in postivie Y direction */
  glTranslatef(0.0, 0.0, -1.0);
}

void
menustate(int inuse)
{
  printf("menu is %s\n", inuse ? "INUSE" : "not in use");
}

void
keyboard(unsigned char key, int x, int y)
{
  printf("key: `%c' %d,%d\n", key, x, y);
}

void
mouse(int button, int state, int x, int y)
{
  printf("button: %d %s %d,%d\n", button, state == GLUT_UP ? "UP" : "down", x, y);
}

void
motion(int x, int y)
{
  printf("motion: %d,%d\n", x, y);
}

void
visible(int status)
{
  printf("visible: %s\n", status == GLUT_VISIBLE ? "YES" : "no");
}

void
main(int argc, char **argv)
{
  qobj = gluNewQuadric();
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  win1 = glutCreateWindow("sphere");
  init();
  glutDisplayFunc(display_win1);
  glutCreateMenu(it);
  glutAddMenuEntry("toggle draw mode", 1);
  glutAddMenuEntry("exit", 2);
  glutAddMenuEntry("new menu entry", 3);
  glutAddMenuEntry("motion", 4);
  glutAttachMenu(GLUT_LEFT_BUTTON);
  glutCreateMenu(it);
  glutAddMenuEntry("yes", 1);
  glutAddMenuEntry("no", 2);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  win2 = glutCreateWindow("second window");
  glutKeyboardFunc(keyboard);
  glutMouseFunc(mouse);
  glutMotionFunc(motion);
  glutVisibilityFunc(visible);
  init();
  light_diffuse[1] = 0;
  light_diffuse[2] = 1;
  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
  glutDisplayFunc(display);
  submenu1 = glutCreateMenu(it);
  glutAddMenuEntry("submenu a", 666);
  glutAddMenuEntry("submenu b", 777);
  submenu2 = glutCreateMenu(it);
  glutAddMenuEntry("submenu 1", 25);
  glutAddMenuEntry("submenu 2", 26);
  glutAddSubMenu("submenuXXX", submenu1);
  glutCreateMenu(it);
  glutAddSubMenu("submenu", submenu2);
  glutAddMenuEntry("stop motion", 5);
  glutAddMenuEntry("delayed stop motion", 6);
  glutAddSubMenu("submenu", submenu2);
  glutAttachMenu(GLUT_LEFT_BUTTON);
  glutMenuStateFunc(menustate);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\scene.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  scene.c
 *  This program demonstrates the use of the GL lighting model.
 *  Objects are drawn using a grey material characteristic. 
 *  A single light source illuminates the objects.
 */
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <GL/glut.h>

/*  Initialize material property and light source.
 */
void 
myinit(void)
{
    GLfloat light_ambient[] =
    {0.0, 0.0, 0.0, 1.0};
    GLfloat light_diffuse[] =
    {1.0, 0.0, 0.0, 1.0};
    GLfloat light_specular[] =
    {1.0, 1.0, 1.0, 1.0};
/* light_position is NOT default value */
    GLfloat light_position[] =
    {1.0, 1.0, 1.0, 0.0};

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_LIGHTING);
}

void 
display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    glScalef(1.3, 1.3, 1.3);
    glRotatef(20.0, 1.0, 0.0, 0.0);

    glPushMatrix();
    glTranslatef(-0.75, 0.5, 0.0);
    glRotatef(90.0, 1.0, 0.0, 0.0);
    glutSolidTorus(0.275, 0.85, 10, 15);
    glPopMatrix();

    glPushMatrix();
    glTranslatef(-0.75, -0.5, 0.0);
    glRotatef(270.0, 1.0, 0.0, 0.0);
    glutSolidTetrahedron();
    glPopMatrix();

    glPushMatrix();
    glTranslatef(0.75, 0.0, -1.0);
    glutSolidIcosahedron();
    glPopMatrix();

    glPopMatrix();
    glFlush();
}

void 
myReshape(int w, int h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-2.5, 2.5, -2.5 * (GLfloat) h / (GLfloat) w,
            2.5 * (GLfloat) h / (GLfloat) w, -10.0, 10.0);
    else
        glOrtho(-2.5 * (GLfloat) w / (GLfloat) h,
            2.5 * (GLfloat) w / (GLfloat) h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

void 
polygon_mode(int value)
{
    switch (value) {
    case 1:
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_LIGHTING);
        glDisable(GL_BLEND);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        break;
    case 2:
        glDisable(GL_DEPTH_TEST);
        glDisable(GL_LIGHTING);
        glColor3f(1.0, 1.0, 1.0);
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        glEnable(GL_LINE_SMOOTH);
        glEnable(GL_BLEND);
        glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
        break;
    }
    glutPostRedisplay();
}

void 
main_menu(int value)
{
    if (value == 666)
        exit(0);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
void 
main(int argc, char **argv)
{
    int submenu;

    glutInit(&argc, argv);
    glutInitWindowPosition(500, 500);
    glutInitWindowSize(500, 500);
    glutCreateWindow(argv[0]);
    myinit();
    glutReshapeFunc(myReshape);
    glutDisplayFunc(display);
    submenu = glutCreateMenu(polygon_mode);
    glutAddMenuEntry("Filled", 1);
    glutAddMenuEntry("Outline", 2);
    glutCreateMenu(main_menu);
    glutAddMenuEntry("Quit", 666);
    glutAddSubMenu("Polygon mode", submenu);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
    glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\stroke.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <string.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

void *font = GLUT_STROKE_ROMAN;
void *fonts[] =
{GLUT_STROKE_ROMAN, GLUT_STROKE_MONO_ROMAN};
char defaultMessage[] = "GLUT means OpenGL.";
char *message = defaultMessage;

int angle = 0;

void
selectFont(int newfont)
{
  font = fonts[newfont];
  glutPostRedisplay();
}

void
selectMessage(int msg)
{
  switch (msg) {
  case 1:
    message = "abcdefghijklmnop";
    break;
  case 2:
    message = "ABCDEFGHIJKLMNOP";
    break;
  }
}

void
tick(void)
{
  angle -= 2;
  glutPostRedisplay();
}

void
display(void)
{
  int len, i;

  glClear(GL_COLOR_BUFFER_BIT);
  glPushMatrix();
  glRotatef(angle, 0.0, 0.0, 1.0);
  glTranslatef(-750, 0, 0);
  len = strlen(message);
  for (i = 0; i < len; i++) {
    glutStrokeCharacter(font, message[i]);
  }
  glPopMatrix();
  glutSwapBuffers();
}

void
main(int argc, char **argv)
{
  int i, submenu;

  glutInit(&argc, argv);
  for (i = 1; i < argc; i++) {
    if (!strcmp(argv[i], "-mono")) {
      font = GLUT_STROKE_MONO_ROMAN;
    }
  }
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(600, 600);
  glutCreateWindow("anti-aliased stroke font");
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluOrtho2D(0, 2000, 0, 2000);
  glMatrixMode(GL_MODELVIEW);
  glEnable(GL_LINE_SMOOTH);
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
  glLineWidth(3.0);
  glTranslatef(1000, 1000, 0);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glColor3f(1.0, 1.0, 1.0);
  glutDisplayFunc(display);
  glutIdleFunc(tick);
  submenu = glutCreateMenu(selectMessage);
  glutAddMenuEntry("abc", 1);
  glutAddMenuEntry("ABC", 2);
  glutCreateMenu(selectFont);
  glutAddMenuEntry("Roman", 0);
  glutAddMenuEntry("Mono Roman", 1);
  glutAddSubMenu("Messages", submenu);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test1.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

#define PROGNAME "program"
#define ARG0 "arg0"
#define ARG1 "arg1"
#define ARG2 "-arg2"

char *fake_argv[] =
{
  PROGNAME,
#ifndef GLUT_WIN32
  "-display",
  ":0",
  "-geometry",
  "500x400+34+23",
#endif
  "-indirect",
  "-iconic",
  ARG0,
  ARG1,
  ARG2,
  NULL};

char *keep_argv[] =
{
  ARG0,
  ARG1,
  ARG2
};
int fake_argc = sizeof(fake_argv) / sizeof(char *) - 1;
int keep_argc = sizeof(keep_argv) / sizeof(char *);

void
main(int argc, char **argv)
{
  int i;

#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&fake_argc, fake_argv);
  if (fake_argc != keep_argc+1) {
    __glutFatalError("FAIL: %d: wrong number of arguments", fake_argc);
  }
  if (strcmp(fake_argv[0], PROGNAME))
  {
    __glutFatalError("FAIL: '%s': wrong program name", argv[0]);
  }
  for (i = 1; i < fake_argc; i++)
  {
    if (strcmp(fake_argv[i], keep_argv[i-1]))
    {
      __glutFatalError("FAIL: arg %d '%s': wrong argument", i, argv[0]);
    }
  }
  if (fake_argv[i] != NULL)
  {
    __glutFatalError("FAIL: args not NULL terminated");
  }
#ifdef GLUT_WIN32
  /* Windows will place the window randomly unless a position is given */
  glutInitWindowPosition(34, 23);
  glutInitWindowSize(500, 400);
#endif
  if(glutGet(GLUT_INIT_WINDOW_WIDTH) != 500) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_HEIGHT) != 400) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_X) != 34) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_Y) != 23) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_DISPLAY_MODE) !=
    (GLUT_RGBA | GLUT_SINGLE | GLUT_DEPTH)) {
    __glutFatalError("FAIL: width wrong");
  }
  glutInitWindowPosition(10, 10);
  glutInitWindowSize(200, 200);
  glutInitDisplayMode(
    GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_STENCIL);
  if(glutGet(GLUT_INIT_WINDOW_WIDTH) != 200) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_HEIGHT) != 200) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_X) != 10) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_WINDOW_Y) != 10) {
    __glutFatalError("FAIL: width wrong");
  }
  if(glutGet(GLUT_INIT_DISPLAY_MODE) !=
    (GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH | GLUT_STENCIL)) {
    __glutFatalError("FAIL: width wrong");
  }
  printf("PASS: test1\n");
  exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\sphere2.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef GLUT_WIN32
#include <windows.h>
#endif

#include <GL/glut.h>

GLfloat light_diffuse[] =
{1.0, 0.0, 0.0, 1.0};
GLfloat light_position[] =
{1.0, 1.0, 1.0, 0.0};
GLUquadricObj *qobj;

void 
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  glCallList(1);        /* render sphere display list */
  glutSwapBuffers();
}

void 
gfxinit(void)
{
  qobj = gluNewQuadric();
  gluQuadricDrawStyle(qobj, GLU_FILL);
  glNewList(1, GL_COMPILE);  /* create sphere display list */
  gluSphere(qobj, /* radius */ 1.0, /* slices */ 20,  /* stacks 
                                                       */ 20);
  glEndList();
  glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
  glLightfv(GL_LIGHT0, GL_POSITION, light_position);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_DEPTH_TEST);
  glMatrixMode(GL_PROJECTION);
  gluPerspective( /* field of view in degree */ 40.0,  /* aspect 
                                                          ratio 
                                                        */ 1.0,
    /* Z near */ 1.0, /* Z far */ 10.0);
  glMatrixMode(GL_MODELVIEW);
  gluLookAt(0.0, 0.0, 5.0,  /* eye is at (0,0,5) */
    0.0, 0.0, 0.0,      /* center is at (0,0,0) */
    0.0, 1.0, 0.);      /* up is in positive Y direction */
  glTranslatef(0.0, 0.0, -1.0);
}

void 
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
  glutCreateWindow("sphere");
  glutDisplayFunc(display);
  gfxinit();
  glutCreateWindow("a second window");
  glutDisplayFunc(display);
  gfxinit();
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\teapots.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/**
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/**
 *  teapots.c
 *  This program demonstrates lots of material properties.
 *  A single light source illuminates the objects.
 */
#ifdef GLUT_WIN32
#include <windows.h>
#endif

#include <GL/gl.h>
#include <GL/glu.h>
#include <stdlib.h>
#include <GL/glut.h>

/*
 * Initialize depth buffer, projection matrix, light source, and lighting
 * model.  Do not specify a material property here.
 */
void
myinit(void)
{
  GLfloat ambient[] =
  {0.0, 0.0, 0.0, 1.0};
  GLfloat diffuse[] =
  {1.0, 1.0, 1.0, 1.0};
  GLfloat specular[] =
  {1.0, 1.0, 1.0, 1.0};
  GLfloat position[] =
  {0.0, 3.0, 3.0, 0.0};

  GLfloat lmodel_ambient[] =
  {0.2, 0.2, 0.2, 1.0};
  GLfloat local_view[] =
  {0.0};

  glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
  glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
  glLightfv(GL_LIGHT0, GL_POSITION, position);
  glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
  glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

  glFrontFace(GL_CW);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_AUTO_NORMAL);
  glEnable(GL_NORMALIZE);
  glEnable(GL_DEPTH_TEST);
  glDepthFunc(GL_LESS);
}

/*
 * Move object into position.  Use 3rd through 12th parameters to specify the
 * material property.  Draw a teapot.
 */
void
renderTeapot(GLfloat x, GLfloat y,
  GLfloat ambr, GLfloat ambg, GLfloat ambb,
  GLfloat difr, GLfloat difg, GLfloat difb,
  GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
  float mat[4];

  glPushMatrix();
  glTranslatef(x, y, 0.0);
  mat[0] = ambr;
  mat[1] = ambg;
  mat[2] = ambb;
  mat[3] = 1.0;
  glMaterialfv(GL_FRONT, GL_AMBIENT, mat);
  mat[0] = difr;
  mat[1] = difg;
  mat[2] = difb;
  glMaterialfv(GL_FRONT, GL_DIFFUSE, mat);
  mat[0] = specr;
  mat[1] = specg;
  mat[2] = specb;
  glMaterialfv(GL_FRONT, GL_SPECULAR, mat);
  glMaterialf(GL_FRONT, GL_SHININESS, shine * 128.0);
  glutSolidTeapot(1.0);
  glPopMatrix();
}

/**
 *  First column:  emerald, jade, obsidian, pearl, ruby, turquoise
 *  2nd column:  brass, bronze, chrome, copper, gold, silver
 *  3rd column:  black, cyan, green, red, white, yellow plastic
 *  4th column:  black, cyan, green, red, white, yellow rubber
 */
void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
  renderTeapot(2.0, 17.0, 0.0215, 0.1745, 0.0215,
    0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
  renderTeapot(2.0, 14.0, 0.135, 0.2225, 0.1575,
    0.54, 0.89, 0.63, 0.316228, 0.316228, 0.316228, 0.1);
  renderTeapot(2.0, 11.0, 0.05375, 0.05, 0.06625,
    0.18275, 0.17, 0.22525, 0.332741, 0.328634, 0.346435, 0.3);
  renderTeapot(2.0, 8.0, 0.25, 0.20725, 0.20725,
    1, 0.829, 0.829, 0.296648, 0.296648, 0.296648, 0.088);
  renderTeapot(2.0, 5.0, 0.1745, 0.01175, 0.01175,
    0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
  renderTeapot(2.0, 2.0, 0.1, 0.18725, 0.1745,
    0.396, 0.74151, 0.69102, 0.297254, 0.30829, 0.306678, 0.1);
  renderTeapot(6.0, 17.0, 0.329412, 0.223529, 0.027451,
    0.780392, 0.568627, 0.113725, 0.992157, 0.941176, 0.807843,
    0.21794872);
  renderTeapot(6.0, 14.0, 0.2125, 0.1275, 0.054,
    0.714, 0.4284, 0.18144, 0.393548, 0.271906, 0.166721, 0.2);
  renderTeapot(6.0, 11.0, 0.25, 0.25, 0.25,
    0.4, 0.4, 0.4, 0.774597, 0.774597, 0.774597, 0.6);
  renderTeapot(6.0, 8.0, 0.19125, 0.0735, 0.0225,
    0.7038, 0.27048, 0.0828, 0.256777, 0.137622, 0.086014, 0.1);
  renderTeapot(6.0, 5.0, 0.24725, 0.1995, 0.0745,
    0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
  renderTeapot(6.0, 2.0, 0.19225, 0.19225, 0.19225,
    0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
  renderTeapot(10.0, 17.0, 0.0, 0.0, 0.0, 0.01, 0.01, 0.01,
    0.50, 0.50, 0.50, .25);
  renderTeapot(10.0, 14.0, 0.0, 0.1, 0.06, 0.0, 0.50980392, 0.50980392,
    0.50196078, 0.50196078, 0.50196078, .25);
  renderTeapot(10.0, 11.0, 0.0, 0.0, 0.0,
    0.1, 0.35, 0.1, 0.45, 0.55, 0.45, .25);
  renderTeapot(10.0, 8.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
    0.7, 0.6, 0.6, .25);
  renderTeapot(10.0, 5.0, 0.0, 0.0, 0.0, 0.55, 0.55, 0.55,
    0.70, 0.70, 0.70, .25);
  renderTeapot(10.0, 2.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0,
    0.60, 0.60, 0.50, .25);
  renderTeapot(14.0, 17.0, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01,
    0.4, 0.4, 0.4, .078125);
  renderTeapot(14.0, 14.0, 0.0, 0.05, 0.05, 0.4, 0.5, 0.5,
    0.04, 0.7, 0.7, .078125);
  renderTeapot(14.0, 11.0, 0.0, 0.05, 0.0, 0.4, 0.5, 0.4,
    0.04, 0.7, 0.04, .078125);
  renderTeapot(14.0, 8.0, 0.05, 0.0, 0.0, 0.5, 0.4, 0.4,
    0.7, 0.04, 0.04, .078125);
  renderTeapot(14.0, 5.0, 0.05, 0.05, 0.05, 0.5, 0.5, 0.5,
    0.7, 0.7, 0.7, .078125);
  renderTeapot(14.0, 2.0, 0.05, 0.05, 0.0, 0.5, 0.5, 0.4,
    0.7, 0.7, 0.04, .078125);
  glFlush();
}

void
myReshape(int w, int h)
{
  glViewport(0, 0, w, h);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  if (w <= h)
    glOrtho(0.0, 16.0, 0.0, 16.0 * (GLfloat) h / (GLfloat) w,
      -10.0, 10.0);
  else
    glOrtho(0.0, 16.0 * (GLfloat) w / (GLfloat) h, 0.0, 16.0,
      -10.0, 10.0);
  glMatrixMode(GL_MODELVIEW);
}

/*
 * Main Loop Open window with initial window size, title bar, RGBA display
 * mode, and handle input events.
 */
void
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
  glutCreateWindow(argv[0]);
  myinit();
  glutReshapeFunc(myReshape);
  glutDisplayFunc(display);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\subwin.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef GLUT_WIN32
#include <windows.h>
#endif

#include <GL/glut.h>

#define GAP 10

int main_w, w1, w2, w3, w4;

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
}

void
reshape(int w, int h)
{
  int width = 50;
  int height = 50;

  glViewport(0, 0, w, h);
  if (w > 50) {
    width = (w - 3 * GAP) / 2;
  } else {
    width = 10;
  }
  if (h > 50) {
    height = (h - 3 * GAP) / 2;
  } else {
    height = 10;
  }
  glutSetWindow(w1);
  glutPositionWindow(GAP, GAP);
  glutReshapeWindow(width, height);
  glutSetWindow(w2);
  glutPositionWindow(GAP + width + GAP, GAP);
  glutReshapeWindow(width, height);
  glutSetWindow(w3);
  glutPositionWindow(GAP, GAP + height + GAP);
  glutReshapeWindow(width, height);
  glutSetWindow(w4);
  glutPositionWindow(GAP + width + GAP, GAP + height + GAP);
  glutReshapeWindow(width, height);
}

void
main(int argc, char **argv)
{
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_RGB);
  glutInitWindowSize(210, 210);
  main_w = glutCreateWindow("4 subwindows");
  glutDisplayFunc(display);
  glutReshapeFunc(reshape);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  w1 = glutCreateSubWindow(main_w, 10, 10, 90, 90);
  glutDisplayFunc(display);
  glClearColor(1.0, 0.0, 0.0, 1.0);
  w2 = glutCreateSubWindow(main_w, 110, 10, 90, 90);
  glutDisplayFunc(display);
  glClearColor(0.0, 1.0, 0.0, 1.0);
  w3 = glutCreateSubWindow(main_w, 10, 110, 90, 90);
  glutDisplayFunc(display);
  glClearColor(0.0, 0.0, 1.0, 1.0);
  w4 = glutCreateSubWindow(main_w, 110, 110, 90, 90);
  glutDisplayFunc(display);
  glClearColor(1.0, 1.0, 0.0, 1.0);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test10.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

/* XXX As a test of 16-bit font support in capturexfont, I made
   a font out of the 16-bit Japanese font named
   '-jis-fixed-medium-r-normal--24-230-75-75-c-240-jisx0208.1'
   and tried it out.  Defining JIS_FONT uses it in this test. */
/* #define JIS_FONT */

#ifdef JIS_FONT
extern void *glutBitmapJis;
#endif

int ch = -2;
void *fonts[] =
{
  GLUT_BITMAP_TIMES_ROMAN_24,
  GLUT_BITMAP_TIMES_ROMAN_10,
  GLUT_BITMAP_9_BY_15,
  GLUT_BITMAP_8_BY_13,
#ifdef JIS_FONT
  &glutBitmapJis
#endif
};
void *names[] =
{
  "Times Roman 24",
  " Times Roman 10",
  "  9 by 15",
  "   8 by 13",
#ifdef JIS_FONT
  "    Mincho JIS"
#endif
};
#define NUM_FONTS (sizeof(fonts)/sizeof(void *))
int font = 0;

void
tick(void)
{
  static int limit = 270;

  ch += 5;
  if (ch > limit) {
    ch = -2;
    font++;
#ifdef JIS_FONT
    if (font == 4) {
      limit = 0x747e;
      ch = 0x2121;
    }
#endif
    if (font == NUM_FONTS) {
      printf("PASS: test10\n");
      exit(0);
    }
  }
  glutPostRedisplay();
}

void
output(int x, int y, char *msg)
{
  glRasterPos2f(x, y);
  while (*msg) {
    glutBitmapCharacter(GLUT_BITMAP_9_BY_15, *msg);
    msg++;
  }
}

void
display(void)
{
  glutIdleFunc(tick);
  glClear(GL_COLOR_BUFFER_BIT);
  glRasterPos2f(0, 0);
  glutBitmapCharacter(fonts[font], ch);
  glRasterPos2f(30, 30);
  glutBitmapCharacter(fonts[font], ch + 1);
  glRasterPos2f(-30, -30);
  glutBitmapCharacter(fonts[font], ch + 2);
  glRasterPos2f(30, -30);
  glutBitmapCharacter(fonts[font], ch + 3);
  glRasterPos2f(-30, 30);
  glutBitmapCharacter(fonts[font], ch + 4);
  glRasterPos2f(0, 30);
  glutBitmapCharacter(fonts[font], ch + 5);
  glRasterPos2f(0, -30);
  glutBitmapCharacter(fonts[font], ch + 6);
  glRasterPos2f(-30, 0);
  glutBitmapCharacter(fonts[font], ch + 7);
  glRasterPos2f(30, 0);
  glutBitmapCharacter(fonts[font], ch + 8);
  output(-48, -48, names[font]);
  glutSwapBuffers();
}

void
main(int argc, char **argv)
{
#if defined(__sgi)  && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(200, 200);
  glutCreateWindow("Test bitmap fonts");
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluOrtho2D(-50, 50, -50, 50);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glColor3f(1.0, 1.0, 1.0);
  glutDisplayFunc(display);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test11.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

void
main(int argc, char **argv)
{
#if defined(__sgi)  && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
#if (GLUT_API_VERSION >= 2)
  printf("Keyboard:  %s\n", glutDeviceGet(GLUT_HAS_KEYBOARD) ? "YES" : "no");
  printf("Mouse:     %s\n", glutDeviceGet(GLUT_HAS_MOUSE) ? "YES" : "no");
  printf("Spaceball: %s\n", glutDeviceGet(GLUT_HAS_SPACEBALL) ? "YES" : "no");
  printf("Dials:     %s\n", glutDeviceGet(GLUT_HAS_DIAL_AND_BUTTON_BOX) ? "YES" : "no");
  printf("Tablet:    %s\n\n", glutDeviceGet(GLUT_HAS_TABLET) ? "YES" : "no");
  printf("Mouse buttons:      %d\n", glutDeviceGet(GLUT_NUM_MOUSE_BUTTONS));
  printf("Spaceball buttons:  %d\n", glutDeviceGet(GLUT_NUM_SPACEBALL_BUTTONS));
  printf("Button box buttons: %d\n", glutDeviceGet(GLUT_NUM_BUTTON_BOX_BUTTONS));
  printf("Dials:              %d\n", glutDeviceGet(GLUT_NUM_DIALS));
  printf("Tablet buttons:     %d\n\n", glutDeviceGet(GLUT_NUM_TABLET_BUTTONS));
#endif
  printf("PASS: test11\n");
  exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test12.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif
#include <GL/glut.h>

void
main(int argc, char **argv)
{
  int a, b, d;
  int val;

#if defined(__sgi)  && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
#if (GLUT_API_VERSION >= 2)
  a = glutGet(GLUT_ELAPSED_TIME);
#ifdef GLUT_WIN32
  Sleep(1000);
#else
  sleep(1);
#endif
  b = glutGet(GLUT_ELAPSED_TIME);
  d = b - a;
  if(d < 1000 || d > 1200) {
     printf("FAIL: test12\n");
     exit(1);
  }
#endif
  glutCreateWindow("dummy");
  /* try all GLUT_WINDOW_* glutGet's */
  val = glutGet(GLUT_WINDOW_X);
  val = glutGet(GLUT_WINDOW_Y);
  val = glutGet(GLUT_WINDOW_WIDTH);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_HEIGHT);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_BUFFER_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_STENCIL_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_DEPTH_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_RED_SIZE);
  if(val < 1) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_GREEN_SIZE);
  if(val < 1) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_BLUE_SIZE);
  if(val < 1) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_ALPHA_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_ACCUM_RED_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_ACCUM_GREEN_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_ACCUM_BLUE_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_ACCUM_ALPHA_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_DOUBLEBUFFER);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_RGBA);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_COLORMAP_SIZE);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_PARENT);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
#if (GLUT_API_VERSION >= 2)
  val = glutGet(GLUT_WINDOW_NUM_SAMPLES);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_WINDOW_STEREO);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
#endif
  /* touch GLUT_SCREEN_* glutGet's supported */
  val = glutGet(GLUT_SCREEN_WIDTH);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_SCREEN_HEIGHT);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_SCREEN_WIDTH_MM);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  val = glutGet(GLUT_SCREEN_HEIGHT_MM);
  if(val < 0) {
     printf("FAIL: test12\n");
     exit(1);
  }
  printf("PASS: test12\n");
  exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test3.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

#define N 6
#define M 6

int exposed[M * N];
int ecount = 0;
int viewable[M * N];
int vcount = 0;

void
display(void)
{
  int win;

  win = glutGetWindow() - 1;
  if (!exposed[win]) {
    exposed[win] = 1;
    ecount++;
  }
  glClear(GL_COLOR_BUFFER_BIT);
  if ((ecount == (M * N)) && (vcount == (M * N))) {
    printf("PASS: test3\n");
    exit(0);
  }
}

void
view(int state)
{
  int win;

  win = glutGetWindow() - 1;
  if (!viewable[win]) {
    viewable[win] = 1;
    vcount++;
  }
  if ((ecount == (M * N)) && (vcount == (M * N))) {
    printf("PASS: test3\n");
    exit(0);
  }
}

void
timer(int value)
{
  if (value != 23)
    __glutFatalError("FAIL: bad timer value");
  __glutFatalError("FAIL: didn't get all expose and viewable calls in 10 seconds");
}

void
main(int argc, char **argv)
{
  char buf[100];
  int i, j;

#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutInitWindowSize(10, 10);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
  for (i = 0; i < M; i++) {
    for (j = 0; j < N; j++) {
      exposed[i * N + j] = 0;
      viewable[i * N + j] = 0;
      glutInitWindowPosition(100 * i, 100 * j);
      sprintf(buf, "%d\n", i * N + j + 1);
      glutCreateWindow(buf);
      glutDisplayFunc(display);
      glutVisibilityFunc(view);
      glClearColor(1.0, 0.0, 0.0, 1.0);
    }
  }
  /* XXX Hopefully in 45 seconds, all the windows should
     appear, or they probably won't ever appear! */
  glutTimerFunc(45 * 1000, timer, 23);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test2.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

int count = 0, save_count;

#define WAIT_TIME 1000
int start, end, diff;

void
idle(void)
{
  count++;
}

void
timer2(int value)
{
  if (value != 36)
    __glutFatalError("FAIL: timer value wrong");
  if (count != save_count)
    __glutFatalError("FAIL: counter still counting");
  printf("PASS: test2\n");
  exit(0);
}

void
timer(int value)
{
  if (value != 42)
    __glutFatalError("FAIL: timer value wrong");
  if (count <= 0)
    __glutFatalError("FAIL: idle func not running");
  glutIdleFunc(NULL);
  save_count = count;
  end = glutGet(GLUT_ELAPSED_TIME);
  diff = end-start;
  printf("start %d, end %d, diff %d\n", start, end, diff);
  if (diff > WAIT_TIME + 200) {
    __glutFatalError("FAIL: timer too late");
  }
  if (diff < WAIT_TIME) {
    __glutFatalError("FAIL: timer too soon");
  }
  glutTimerFunc(100, timer2, 36);
}

void
Select(int value)
{
}

void
NeverVoid(void)
{
  __glutFatalError("FAIL: NeverVoid should never be called");
}

void
NeverValue(int value)
{
  __glutFatalError("FAIL: NeverValue should never be called");
}

#define NUM 15

void
main(int argc, char **argv)
{
  int win, menu;
  int marray[NUM];
  int warray[NUM];
  int i, j;

#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutInitWindowPosition(10, 10);
  glutInitWindowSize(200, 200);
  glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
  win = glutCreateWindow("test2");
  glutSetWindow(win);
  menu = glutCreateMenu(Select);
  glutSetMenu(menu);
  glutDisplayFunc(NULL);
  glutDisplayFunc(NULL);
  glutReshapeFunc(NULL);
  glutReshapeFunc(NULL);
  glutKeyboardFunc(NULL);
  glutKeyboardFunc(NULL);
  glutMouseFunc(NULL);
  glutMouseFunc(NULL);
  glutMotionFunc(NULL);
  glutMotionFunc(NULL);
  glutVisibilityFunc(NULL);
  glutVisibilityFunc(NULL);
  glutMenuStateFunc(NULL);
  for (i = 0; i < NUM; i++) {
    marray[i] = glutCreateMenu(Select);
    warray[i] = glutCreateWindow("test");
    for (j = 0; j < i; j++) {
      glutAddMenuEntry("Hello", 1);
      glutAddSubMenu("Submenu", menu);
    }
    if (marray[i] != glutGetMenu()) {
      __glutFatalError("FAIL: current menu not %d", marray[i]);
    }
    if (warray[i] != glutGetWindow()) {
      __glutFatalError("FAIL: current window not %d", warray[i]);
    }
    glutDisplayFunc(NeverVoid);
    glutVisibilityFunc(NeverValue);
  }
  for (i = 0; i < NUM; i++) {
    glutDestroyMenu(marray[i]);
    glutDestroyWindow(warray[i]);
  }
  glutTimerFunc(WAIT_TIME, timer, 42);
  start = glutGet(GLUT_ELAPSED_TIME);
  glutIdleFunc(idle);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test5.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>

GLfloat comp;
int mask = 0;

void
display(void)
{
  mask |= 1 << glutGetWindow();
}

void
timeout(int value)
{
  if (value != 1) {
    printf("FAIL: test5, value is %d\n", value);
    exit(1);
  }
  if (mask != 0x6) {
    printf("FAIL: test5, mask is %X\n", mask);
    exit(1);
  }
  printf("PASS: test5\n");
  exit(0);
}

void
main(int argc, char **argv)
{
  int win1, win2, size;

#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_INDEX);
  glutInitWindowPosition(45, 45);
  win1 = glutCreateWindow("CI test 1");
  size = glutGet(GLUT_WINDOW_COLORMAP_SIZE);
  if(size <= 1 || size > (1<<glutGet(GLUT_WINDOW_BUFFER_SIZE))) {
    printf("FAIL: test5, bad colormap size\n");
    exit(1);
  }
  glutSetColor(2, 1.0, 3.4, 0.5);
  comp = glutGetColor(2, GLUT_RED);
  if (comp != 1.0) {
    printf("FAIL: test5, wrong red\n");
    exit(1);
  }
  comp = glutGetColor(2, GLUT_GREEN);
  if (comp != 1.0) {
    printf("FAIL: test5, wrong green\n");
    exit(1);
  }
  comp = glutGetColor(2, GLUT_BLUE);
  if (comp != 0.5) {
    printf("FAIL: test5, wrong blue\n");
    exit(1);
  }
  glutInitWindowPosition(450, 450);
  win2 = glutCreateWindow("CI test 2");
  glutCopyColormap(win1);
  if (glutGetColor(2, GLUT_RED) != 1.0) {
    printf("FAIL: test5, wrong red\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_GREEN) != 1.0) {
    printf("FAIL: test5, wrong green\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_BLUE) != 0.5) {
    printf("FAIL: test5, wrong blue\n");
    exit(1);
  }
  glutSetColor(2, -1.0, 0.25, 0.75);
  glutSetWindow(win1);
  if (win1 != glutGetWindow()) {
    printf("FAIL: test5, bad SetWindow\n");
    exit(1);
  }
  glutDisplayFunc(display);
  if (glutGetColor(2, GLUT_RED) != 1.0) {
    printf("FAIL: test5, wrong red\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_GREEN) != 1.0) {
    printf("FAIL: test5, wrong green\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_BLUE) != 0.5) {
    printf("FAIL: test5, wrong blue\n");
    exit(1);
  }
  glutSetWindow(win2);
  if (win2 != glutGetWindow()) {
    printf("FAIL: test5, bad SetWindow\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_RED) != 0.0) {
    printf("FAIL: test5, wrong red\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_GREEN) != 0.25) {
    printf("FAIL: test5, wrong green\n");
    exit(1);
  }
  if (glutGetColor(2, GLUT_BLUE) != 0.75) {
    printf("FAIL: test5, wrong blue\n");
    exit(1);
  }
  glutTimerFunc(1500, timeout, 1);
  glutDisplayFunc(display);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test6.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <gltint.h>
#include <GL/glut.h>

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
}

void
time6(int value)
{
  if (value != 6)
    __glutFatalError("FAIL: time6 expected 6\n");
  printf("PASS: test6\n");
  exit(0);
}

int estate = 0;

void
entry(int state)
{
  printf("entry: %s\n", state == GLUT_LEFT ? "left" : "entered");
  switch (estate) {
  case 0:
    if (state == GLUT_LEFT)
      estate++;
    break;
  case 1:
    if (state == GLUT_ENTERED)
      estate++;
    glutTimerFunc(1000, time6, 6);
    glutEntryFunc(NULL);
    break;
  }
}

void
time5(int value)
{
  if (value != 5)
    __glutFatalError("FAIL: time5 expected 5\n");
  if (glutGet(GLUT_ENTRY_CALLBACKS))
  {
    glutEntryFunc(entry);
    printf("In the black window, leave it, then enter it\n");
  }
  else
  {
    glutTimerFunc(1000, time6, 6);
  }
}

void
motion(int x, int y)
{
  printf("motion x=%d, y=%d\n", x, y);
  glutMotionFunc(NULL);
  glutTimerFunc(1000, time5, 5);
}

void
time4(int value)
{
  if (value != 4)
    __glutFatalError("FAIL: time4 expected 4\n");
  glutMotionFunc(motion);
  printf("In the black window, move mouse with some button held down\n");
}

void
passive(int x, int y)
{
  printf("passive x=%d, y=%d\n", x, y);
  glutTimerFunc(1000, time4, 4);
  glutPassiveMotionFunc(NULL);
}

void
time3(int value)
{
  if (value != 3)
    __glutFatalError("FAIL: time3 expected 3\n");
  glutPassiveMotionFunc(passive);
  printf("In the black window, mouse the mouse around with NO buttons down\n");
}

int mode = 0;

void
mouse(int button, int state, int x, int y)
{
  printf("but=%d, state=%d, x=%d, y=%d\n", button, state, x, y);
  switch (mode) {
  case 0:
    if (button != GLUT_LEFT_BUTTON && state == GLUT_DOWN)
      __glutFatalError("FAIL: mouse left down not found");
    break;
  case 1:
    if (button != GLUT_LEFT_BUTTON && state == GLUT_UP)
      __glutFatalError("FAIL: mouse left up not found");
    if (glutDeviceGet(GLUT_NUM_MOUSE_BUTTONS) == 2)
    {
      mode += 2;
    }
    break;
  case 2:
    if (button != GLUT_MIDDLE_BUTTON && state == GLUT_DOWN)
      __glutFatalError("FAIL: mouse center down not found");
    break;
  case 3:
    if (button != GLUT_MIDDLE_BUTTON && state == GLUT_UP)
      __glutFatalError("FAIL: mouse center up not found");
    break;
  case 4:
    if (button != GLUT_RIGHT_BUTTON && state == GLUT_DOWN)
      __glutFatalError("FAIL: mouse right down not found");
    break;
  case 5:
    if (button != GLUT_RIGHT_BUTTON && state == GLUT_UP)
      __glutFatalError("FAIL: mouse right up not found");
    glutTimerFunc(1000, time3, 3);
    glutMouseFunc(NULL);
    break;
  default:
    __glutFatalError("FAIL: mouse called with bad mode: %d", mode);
  }
  mode++;
}

void
menu(int selection)
{
  __glutFatalError("FAIL: menu callback should never be called");
}

void
time2(int value)
{
  if (value != 2)
    __glutFatalError("FAIL: time2 expected 2");
  glutMouseFunc(mouse);

  /* by attaching and detaching a menu to each button, make
     sure button usage for menus does not mess up normal button
     callback. */
  glutCreateMenu(menu);
  glutAttachMenu(GLUT_RIGHT_BUTTON);
  glutAttachMenu(GLUT_MIDDLE_BUTTON);
  glutAttachMenu(GLUT_LEFT_BUTTON);
  glutDetachMenu(GLUT_RIGHT_BUTTON);
  glutDetachMenu(GLUT_MIDDLE_BUTTON);
  glutDetachMenu(GLUT_LEFT_BUTTON);
  glutDestroyMenu(glutGetMenu());

  if (glutDeviceGet(GLUT_NUM_MOUSE_BUTTONS) == 2)
  {
    printf("In the black window, please click left, then right\n");
  }
  else
  {
    printf("In the black window, please click left, then middle, then right\n");
  }
}

void
keyboard(unsigned char c, int x, int y)
{
  printf("char=%d, x=%d, y=%d\n", c, x, y);
  if (c != 'g')
    __glutFatalError("FAIL: keyboard expected g");
  glutKeyboardFunc(NULL);
  glutTimerFunc(1000, time2, 2);
}

void
time1(int value)
{
  if (value != 1)
    __glutFatalError("FAIL: time1 expected 1");
  glutKeyboardFunc(keyboard);
  printf("In the black window, please press: g\n");
}

void
main(int argc, char **argv)
{
#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutCreateWindow("test");
  glutDisplayFunc(display);
  glutTimerFunc(1000, time1, 1);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test8.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#include <stdio.h>
#include <stdlib.h>
#ifdef __sgi
#include <malloc.h>
#endif
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

int main_w, w[4], win;
int num;

void
time2(int value)
{
  printf("PASS: test8\n");
  exit(0);
}

void
time1(int value)
{
  glutDestroyWindow(w[1]);
  glutDestroyWindow(w[0]);
  glutDestroyWindow(main_w);
  glutTimerFunc(500, time2, 0);
}

void
main(int argc, char **argv)
{
#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  if(glutGet(GLUT_INIT_WINDOW_WIDTH) != 300) {
    __glutFatalError("FAIL: width wrong\n");
  }
  if(glutGet(GLUT_INIT_WINDOW_HEIGHT) != 300) {
    __glutFatalError("FAIL: width wrong\n");
  }
  if(glutGet(GLUT_INIT_WINDOW_X) != -1) {
    __glutFatalError("FAIL: width wrong\n");
  }
  if(glutGet(GLUT_INIT_WINDOW_Y) != -1) {
    __glutFatalError("FAIL: width wrong\n");
  }
  if(glutGet(GLUT_INIT_DISPLAY_MODE) != (GLUT_RGBA|GLUT_SINGLE|GLUT_DEPTH)) {
    __glutFatalError("FAIL: width wrong\n");
  }
  glutInitDisplayMode(GLUT_RGB);
  main_w = glutCreateWindow("main");
  num = glutGet(GLUT_DISPLAY_MODE_POSSIBLE);
  if (num != 1)
    __glutFatalError("FAIL: glutGet returned display mode not possible: %d\n", num);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (0 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  w[0] = glutCreateSubWindow(main_w, 10, 10, 20, 20);
  num = glutGet(GLUT_WINDOW_PARENT);
  if (main_w != num)
    __glutFatalError("FAIL: glutGet returned bad parent: %d\n", num);
  glutSetWindow(main_w);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (1 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  w[1] = glutCreateSubWindow(main_w, 40, 10, 20, 20);
  num = glutGet(GLUT_WINDOW_PARENT);
  if (main_w != num)
    __glutFatalError("FAIL: glutGet returned bad parent: %d\n", num);
  glutSetWindow(main_w);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (2 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  w[2] = glutCreateSubWindow(main_w, 10, 40, 20, 20);
  num = glutGet(GLUT_WINDOW_PARENT);
  if (main_w != num)
    __glutFatalError("FAIL: glutGet returned bad parent: %d\n", num);
  glutSetWindow(main_w);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (3 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  w[3] = glutCreateSubWindow(main_w, 40, 40, 20, 20);
  num = glutGet(GLUT_WINDOW_PARENT);
  if (main_w != num)
    __glutFatalError("FAIL: glutGet returned bad parent: %d\n", num);
  glutSetWindow(main_w);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (4 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  glutDestroyWindow(w[3]);
  num = glutGet(GLUT_WINDOW_NUM_CHILDREN);
  if (3 != num)
    __glutFatalError("FAIL: glutGet returned wrong # children: %d\n", num);

  w[3] = glutCreateSubWindow(main_w, 40, 40, 20, 20);
  glutCreateSubWindow(w[3], 40, 40, 20, 20);
  glutCreateSubWindow(w[3], 40, 40, 20, 20);
  win = glutCreateSubWindow(w[3], 40, 40, 20, 20);
  glutCreateSubWindow(win, 40, 40, 20, 20);
  win = glutCreateSubWindow(w[3], 40, 40, 20, 20);
  glutCreateSubWindow(win, 40, 40, 20, 20);
  glutDestroyWindow(w[3]);

  w[3] = glutCreateSubWindow(main_w, 40, 40, 20, 20);

  glutTimerFunc(500, time1, 0);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test4.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

int ch = -2;
void *font = GLUT_STROKE_ROMAN;

void
tick(void)
{
  ch += 1;
  if (ch > 180) {
    if (font == GLUT_STROKE_MONO_ROMAN) {
      printf("PASS: test4\n");
      exit(0);
    }
    ch = -2;
    font = GLUT_STROKE_MONO_ROMAN;
  }
  glutPostRedisplay();
}

void
display(void)
{
  glutIdleFunc(tick);
  glClear(GL_COLOR_BUFFER_BIT);
  glPushMatrix();
  glutStrokeCharacter(font, ch);
  glPopMatrix();
  glutSwapBuffers();
}

void
main(int argc, char **argv)
{
#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
  glutInitWindowSize(200, 200);
  glutCreateWindow("Test stroke fonts");
  if(glutGet(GLUT_WINDOW_COLORMAP_SIZE) != 0) {
    __glutFatalError("FAIL: bad RGBA colormap size");
  }
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluOrtho2D(-50, 150, -50, 150);
  glClearColor(0.0, 0.0, 0.0, 1.0);
  glColor3f(1.0, 1.0, 1.0);
  glutDisplayFunc(display);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test7.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <gltint.h>
#include <GL/glut.h>

int w1, w2;

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
}

void
time6(int value)
{
  if (value != 6)
    __glutFatalError("FAIL: time6 expected 6");
  printf("change icon tile for both windows\n");
  glutSetWindow(w1);
  glutSetIconTitle("icon1");
  glutSetWindow(w2);
  glutSetIconTitle("icon2");
  printf("PASS: test7\n");
  exit(0);
}

void
time5(int value)
{
  if (value != 5)
    __glutFatalError("FAIL: time5 expected 5");
  printf("iconify both windows\n");
  glutSetWindow(w1);
  glutIconifyWindow();
  glutSetWindow(w2);
  glutIconifyWindow();
  glutTimerFunc(1000, time6, 6);
}

void
time4(int value)
{
  if (value != 4)
    __glutFatalError("FAIL: time4 expected 4");
  printf("reshape and reposition window\n");
  glutSetWindow(w1);
  glutReshapeWindow(250, 250);
  glutPositionWindow(20, 20);
  glutSetWindow(w2);
  glutReshapeWindow(150, 150);
  glutPositionWindow(250, 250);
  glutTimerFunc(1000, time5, 5);
}

void
time3(int value)
{
  if (value != 3)
    __glutFatalError("FAIL: time3 expected 3");
  printf("show both windows again\n");
  glutSetWindow(w1);
  glutShowWindow();
  glutSetWindow(w2);
  glutShowWindow();
  glutTimerFunc(1000, time4, 4);
}

void
time2(int value)
{
  if (value != 2)
    __glutFatalError("FAIL: time2 expected 2");
  printf("hiding w1; iconify w2\n");
  glutSetWindow(w1);
  glutHideWindow();
  glutSetWindow(w2);
  glutIconifyWindow();
  glutTimerFunc(1000, time3, 3);
}

void
time1(int value)
{
  if (value != 1)
    __glutFatalError("FAIL: time1 expected 1");
  printf("changing window titles\n");
  glutSetWindow(w1);
  glutSetWindowTitle("changed title");
  glutSetWindow(w2);
  glutSetWindowTitle("changed other title");
  glutTimerFunc(2000, time2, 2);
}

void
main(int argc, char **argv)
{
#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);
  w1 = glutCreateWindow("test 1");
  glutDisplayFunc(display);
  w2 = glutCreateWindow("test 2");
  glutDisplayFunc(display);
  glutTimerFunc(1000, time1, 1);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glwin\lib\glwin.c ===
#include "precomp.h"
#pragma hdrstop

#include <stdio.h>

#include "glwinint.h"

// Window class
static char *pszClass = "glWindow";

// Structure to pass window creation data
#pragma pack(1)
typedef struct _GLWINCREATESTRUCT
{
    WORD wSize;
    GLWINDOW gw;
} GLWINCREATESTRUCT;
#pragma pack()

/******************************Public*Routine******************************\
*
* glwinWndProc
*
* Window procedure for glwin windows
*
* History:
*  Fri Aug 30 13:00:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

LRESULT glwinWndProc(HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm)
{
    PAINTSTRUCT ps;
    LRESULT lr;
    GLWINDOW gw;
    GLWINCREATESTRUCT *pgcs;

    // Set up the window-related data immediately on WM_CREATE so that
    // a callback can be made for it as well as after it
    if (uiMsg == WM_CREATE)
    {
        pgcs = (GLWINCREATESTRUCT *)((CREATESTRUCT *)lpm)->lpCreateParams;
        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pgcs->gw);
    }
    
    gw = (GLWINDOW)GetWindowLong(hwnd, GWL_USERDATA);

    // Pass off window messages if requested
    if (gw != NULL && gw->cbMessage != NULL)
    {
        if (gw->cbMessage(gw, hwnd, uiMsg, wpm, lpm, &lr))
        {
            return lr;
        }
    }
    
    switch(uiMsg)
    {
    case WM_PAINT:
        // Validate paint region.  The assumption is that the app will either
        // interpose and catch the WM_PAINT itself or it's dynamic so
        // the screen will be repainted shortly anyway.  Either way,
        // there's nothing for the library to do.
        BeginPaint(hwnd, &ps);
        EndPaint(hwnd, &ps);
        break;
        
    case WM_CLOSE:
        gw->bClosing = TRUE;
        DestroyWindow(hwnd);
        break;

    case WM_DESTROY:
        if (gw->bClosing)
        {
            PostQuitMessage(1);
        }
        break;
        
    default:
        return DefWindowProc(hwnd, uiMsg, wpm, lpm);
    }

    return 0;
}

// Default palette entry flags
#define PALETTE_FLAGS PC_NOCOLLAPSE

// Maximum color distance with 8-bit components
#define MAX_COL_DIST (3*256*256L)

// Number of static colors
#define STATIC_COLORS 20

// Flags used when matching colors
#define EXACT_MATCH 1
#define COLOR_USED 1

// Tables to convert color components between bit sizes
// These tables are corrected for a gamma of 1.4
static unsigned char abThreeToEight[8] =
{
    0, 63, 104, 139, 171, 200, 229, 255
};
static unsigned char abTwoToEight[4] =
{
    0, 116, 191, 255
};
static unsigned char abOneToEight[2] =
{
    0, 255
};

// Table which indicates which colors in a 3-3-2 palette should be
// replaced with the system default colors
static int aiDefaultOverride[STATIC_COLORS] =
{
    0, 3, 24, 27, 64, 67, 88, 173, 181, 236,
    247, 164, 91, 7, 56, 63, 192, 199, 248, 255
};

/******************************Public*Routine******************************\
*
* glwinComponentFromIndex
*
* Converts a color index to a color component
*
* History:
*  Fri Aug 30 14:04:45 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

unsigned char glwinComponentFromIndex(int i, int nbits, int shift)
{
    unsigned char val;

    val = i >> shift;
    switch (nbits)
    {
    case 1:
        return abOneToEight[val & 1];

    case 2:
        return abTwoToEight[val & 3];

    case 3:
        return abThreeToEight[val & 7];
    }

    return 0;
}

// System default colors
static PALETTEENTRY apeDefaultPalEntry[STATIC_COLORS] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },

    { 192, 220, 192,  0 },
    { 166, 202, 240,  0 },
    { 255, 251, 240,  0 },
    { 160, 160, 164,  0 },

    { 0x80,0x80,0x80, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

/******************************Public*Routine******************************\
*
* glwinUpdateStaticMapping
*
* Computes the best match between the current system static colors
* and a 3-3-2 palette
*
* History:
*  Tue Aug 01 18:18:12 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinUpdateStaticMapping(PALETTEENTRY *pe332Palette)
{
    HPALETTE hpalStock;
    int iStatic, i332;
    int iMinDist, iDist;
    int iDelta;
    int iMinEntry;
    PALETTEENTRY *peStatic, *pe332;

    hpalStock = (HPALETTE)GetStockObject(DEFAULT_PALETTE);

    // Get the current static colors
    GetPaletteEntries(hpalStock, 0, STATIC_COLORS, apeDefaultPalEntry);

    // Zero the flags in the static colors because they are used later
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Zero the flags in the incoming palette because they are used later
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = 0;
        pe332++;
    }

    // Try to match each static color exactly
    // This saves time by avoiding the least-squares match for each
    // exact match
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            if (peStatic->peRed == pe332->peRed &&
                peStatic->peGreen == pe332->peGreen &&
                peStatic->peBlue == pe332->peBlue)
            {
                peStatic->peFlags = EXACT_MATCH;
                pe332->peFlags = COLOR_USED;
                aiDefaultOverride[iStatic] = i332;
                
                break;
            }

            pe332++;
        }

        peStatic++;
    }
    
    // Match each static color as closely as possible to an entry
    // in the 332 palette by minimized the square of the distance
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        // Skip colors already matched exactly
        if (peStatic->peFlags == EXACT_MATCH)
        {
            peStatic++;
            continue;
        }
        
        iMinDist = MAX_COL_DIST+1;
#if DBG
        iMinEntry = -1;
#endif

        pe332 = pe332Palette;
        for (i332 = 0; i332 < 256; i332++)
        {
            // Skip colors already used
            if (pe332->peFlags == COLOR_USED)
            {
                pe332++;
                continue;
            }
            
            // Compute Euclidean distance squared
            iDelta = pe332->peRed-peStatic->peRed;
            iDist = iDelta*iDelta;
            iDelta = pe332->peGreen-peStatic->peGreen;
            iDist += iDelta*iDelta;
            iDelta = pe332->peBlue-peStatic->peBlue;
            iDist += iDelta*iDelta;

            if (iDist < iMinDist)
            {
                iMinDist = iDist;
                iMinEntry = i332;
            }

            pe332++;
        }

        // Remember the best match
        aiDefaultOverride[iStatic] = iMinEntry;
        pe332Palette[iMinEntry].peFlags = COLOR_USED;
        
        peStatic++;
    }

    // Zero the flags in the static colors because they may have been
    // set.  We want them to be zero so the colors can be remapped
    peStatic = apeDefaultPalEntry;
    for (iStatic = 0; iStatic < STATIC_COLORS; iStatic++)
    {
        peStatic->peFlags = 0;
        peStatic++;
    }

    // Reset the 332 flags because we may have set them
    pe332 = pe332Palette;
    for (i332 = 0; i332 < 256; i332++)
    {
        pe332->peFlags = PALETTE_FLAGS;
        pe332++;
    }
}

PALETTEENTRY *glwinFillRgbPaletteEntries(PIXELFORMATDESCRIPTOR *ppfd,
                                         PALETTEENTRY *ppeEntries,
                                         UINT cColors)
{
    PALETTEENTRY *ppeEntry;
    UINT i;

    for (i = 0, ppeEntry = ppeEntries ; i < cColors ; i++, ppeEntry++)
    {
        ppeEntry->peRed = glwinComponentFromIndex(i, ppfd->cRedBits,
                                                  ppfd->cRedShift);
        ppeEntry->peGreen = glwinComponentFromIndex(i, ppfd->cGreenBits,
                                                    ppfd->cGreenShift);
        ppeEntry->peBlue = glwinComponentFromIndex(i, ppfd->cBlueBits,
                                                   ppfd->cBlueShift);
        ppeEntry->peFlags = PALETTE_FLAGS;
    }

    if (cColors == 256)
    {
        // If app set static system color usage for fixed palette support,
        // setup to take over the static colors.  Otherwise, fixup the
        // static system colors.

        // The defaultOverride array is computed assuming a 332
        // palette where red has zero shift, etc.

        if ( (3 == ppfd->cRedBits)   && (0 == ppfd->cRedShift)   &&
             (3 == ppfd->cGreenBits) && (3 == ppfd->cGreenShift) &&
             (2 == ppfd->cBlueBits)  && (6 == ppfd->cBlueShift) )
        {
            glwinUpdateStaticMapping(ppeEntries);
                    
            for ( i = 0 ; i < STATIC_COLORS ; i++)
            {
                ppeEntries[aiDefaultOverride[i]] = apeDefaultPalEntry[i];
            }
        }
    }
    
    return ppeEntries;
}

void glwinFlushPalette(HDC hdc, int cColors)
{
    LOGPALETTE *plpal;
    HPALETTE hpal, hpalOld;
    int i;

    if (cColors == 256)
    {
        plpal = (LOGPALETTE *)calloc(1, sizeof(LOGPALETTE)+
                                     cColors*sizeof(PALETTEENTRY));
        if (plpal != NULL)
        {
	    plpal->palVersion = 0x300;
	    plpal->palNumEntries = cColors;

            // Mark everything PC_NOCOLLAPSE and PC_RESERVED to force
            // every thing into the palette.  Colors are already black
            // because we zero initialized during memory allocation.

            for (i = 0; i < cColors; i++)
            {
                plpal->palPalEntry[i].peFlags = PC_NOCOLLAPSE | PC_RESERVED;
            }

            hpal = CreatePalette(plpal);
            free(plpal);

            hpalOld = SelectPalette(hdc, hpal, FALSE);
            RealizePalette(hdc);

            SelectPalette(hdc, hpalOld, FALSE);
            DeleteObject(hpal);
        }
    }
}

LONG glwinRealizePaletteNow(HDC hdc, HPALETTE hpal, BOOL bForceBackground)
{
    LONG lRet = -1;
    BOOL bHaveSysPal = TRUE;

    if (SelectPalette(hdc, hpal, FALSE) != NULL)
    {
        lRet = RealizePalette(hdc);
    }

    return lRet;
}

BOOL glwinCreateRgbPalette(HDC hdc, PIXELFORMATDESCRIPTOR *ppfd,
                           HPALETTE *phpal)
{
    LOGPALETTE *plpal;
    UINT cColors;
    HPALETTE hpal = NULL;
    BOOL bRet = TRUE;

    if (ppfd->iPixelType == PFD_TYPE_RGBA &&
        (ppfd->dwFlags & PFD_NEED_PALETTE))
    {
        cColors = 1 << ppfd->cColorBits;
        plpal = (LOGPALETTE *)malloc(sizeof(LOGPALETTE)+
                                     cColors*sizeof(PALETTEENTRY));
        if (plpal != NULL)
        {
            plpal->palVersion = 0x300;
            plpal->palNumEntries = cColors;

            glwinFillRgbPaletteEntries(ppfd, &plpal->palPalEntry[0], cColors);
            hpal = CreatePalette(plpal);
            free(plpal);

            glwinFlushPalette(hdc, cColors);
            glwinRealizePaletteNow(hdc, hpal, FALSE);
        }
        else
        {
            bRet = FALSE;
        }
    }

    *phpal = hpal;
    
    return bRet;
}

/******************************Public*Routine******************************\
*
* glwinRegisterClass
*
* Register a window class if necessary
*
* History:
*  Fri Aug 30 14:37:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glwinRegisterClass(void)
{
    static ATOM aClass = 0;
    WNDCLASS wc;

    if (aClass == 0)
    {
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = glwinWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = pszClass;
        aClass = RegisterClass(&wc);
        if (aClass == 0)
        {
            return FALSE;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* glwinCreateWindow
*
* Create a new rendering window
*
* History:
*  Fri Aug 30 14:38:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLWINDOW glwinCreateWindow(HWND hwndParent,
                           char *pszTitle, int x, int y,
                           int iWidth, int iHeight,
                           DWORD dwFlags)
{
    GLWINDOW gw;
    RECT rct;
    PIXELFORMATDESCRIPTOR pfd;
    GLWINCREATESTRUCT gcs;
    int ipfd;
    DWORD dwStyle;

    if (!glwinRegisterClass())
    {
        return NULL;
    }

    gw = (GLWINDOW)malloc(sizeof(_GLWINDOW));
    if (gw == NULL)
    {
        return NULL;
    }
    memset(gw, 0, sizeof(*gw));
        
    if (hwndParent != NULL)
    {
        dwStyle = WS_CHILDWINDOW;
    }
    else
    {
        dwStyle = WS_OVERLAPPEDWINDOW;
    }
    dwStyle |= WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
        
    // Create base window
    rct.left = x;
    rct.top = y;
    rct.right = x+iWidth;
    rct.bottom = y+iHeight;
    AdjustWindowRect(&rct, dwStyle, FALSE);

    gcs.wSize = sizeof(gcs);
    gcs.gw = gw;
    gw->hwnd = CreateWindow(pszClass, pszTitle, dwStyle,
                            rct.left, rct.top,
                            rct.right-rct.left, rct.bottom-rct.top,
                            hwndParent, NULL, GetModuleHandle(NULL), &gcs);
    if (gw->hwnd == NULL)
    {
        return NULL;
    }
    
    ShowWindow(gw->hwnd, SW_SHOWDEFAULT);
    UpdateWindow(gw->hwnd);

    gw->hdc = GetDC(gw->hwnd);
    if (gw->hdc == NULL)
    {
        goto DestroyWin;
    }
    
    // Create an OpenGL rendering context
    memset(&pfd, 0, sizeof(pfd));
    pfd.nSize = sizeof(pfd);
    pfd.nVersion = 1;
    pfd.dwFlags = PFD_GENERIC_FORMAT;
    if (dwFlags & GLWIN_GENERIC_ACCELERATED)
    {
	pfd.dwFlags |= PFD_GENERIC_ACCELERATED;
    }
    if (dwFlags & GLWIN_BACK_BUFFER)
    {
        pfd.dwFlags |= PFD_DOUBLEBUFFER;
    }
    pfd.iPixelType = PFD_TYPE_RGBA;
    if (dwFlags & GLWIN_ACCUM_BUFFER)
    {
        pfd.cAccumBits = 64;
    }
    if (dwFlags & GLWIN_STENCIL_BUFFER)
    {
        pfd.cStencilBits = 8;
    }
    if (dwFlags & GLWIN_Z_BUFFER_16)
    {
        pfd.cDepthBits = 16;
    }
    else if (dwFlags & GLWIN_Z_BUFFER_32)
    {
        pfd.cDepthBits = 32;
    }
    ipfd = ChoosePixelFormat(gw->hdc, &pfd);
    if (ipfd <= 0)
    {
        goto DestroyWin;
    }
    if (DescribePixelFormat(gw->hdc, ipfd, sizeof(pfd), &pfd) <= 0)
    {
        goto DestroyWin;
    }
    if (!SetPixelFormat(gw->hdc, ipfd, &pfd))
    {
        goto DestroyWin;
    }

    if (!glwinCreateRgbPalette(gw->hdc, &pfd, &gw->hpal))
    {
        goto DestroyWin;
    }
    
    gw->hrc = wglCreateContext(gw->hdc);
    if (gw->hrc == NULL)
    {
        goto DestroyWin;
    }
    
    gw->iWidth = iWidth;
    gw->iHeight = iHeight;
    gw->dwFlags = dwFlags;

    return gw;

 DestroyWin:
    glwinDestroyWindow(gw);
    return NULL;
}

/******************************Public*Routine******************************\
*
* glwinDestroyWindow
*
* Clean up a rendering window
*
* History:
*  Fri Aug 30 14:39:20 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinDestroyWindow(GLWINDOW gw)
{
    if (gw->hrc != NULL)
    {
        if (wglGetCurrentContext() == gw->hrc)
        {
            wglMakeCurrent(NULL, NULL);
        }
        wglDeleteContext(gw->hrc);
    }

    if (gw->hdc != NULL)
    {
        ReleaseDC(gw->hwnd, gw->hdc);
    }

    if (gw->hpal != NULL)
    {
        DeleteObject(gw->hpal);
    }
        
    if (gw->hwnd != NULL)
    {
        DestroyWindow(gw->hwnd);
    }
}

/******************************Public*Routine******************************\
*
* glwinGetGlrc
*
* Return a rendering window's OpenGL rendering context
*
* History:
*  Fri Aug 30 14:39:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HGLRC glwinGetGlrc(GLWINDOW gw)
{
    return gw->hrc;
}

/******************************Public*Routine******************************\
*
* glwinGetHwnd
*
* Returns a rendering window's window system window
*
* History:
*  Mon Oct 21 18:10:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HWND glwinGetHwnd(GLWINDOW gw)
{
    return gw->hwnd;
}

/******************************Public*Routine******************************\
*
* glwinGetHdc
*
* Returns a renderin window's HDC
*
* History:
*  Tue Oct 22 11:01:35 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HDC glwinGetHdc(GLWINDOW gw)
{
    return gw->hdc;
}

/******************************Public*Routine******************************\
*
* glwinGetFlags
*
* Returns creation flags
*
* History:
*  Mon Oct 21 18:28:24 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD glwinGetFlags(GLWINDOW gw)
{
    return gw->dwFlags;
}

/******************************Public*Routine******************************\
*
* glwinGetLastError
*
* Returns the last error recorded by the library
*
* History:
*  Fri Aug 30 14:39:39 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

LONG glwinGetLastError(void)
{
#if DBG
    char pszMsg[80];

    if (GetLastError() != ERROR_SUCCESS)
    {
        sprintf(pszMsg, "glwinGetLastError returning %d (0x%08lX)\n",
                GetLastError(), GetLastError());
        OutputDebugString(pszMsg);
    }
#endif
    return GetLastError();
}

/******************************Public*Routine******************************\
*
* glwinMakeCurrent
*
* Makes the given rendering window's OpenGL rendering context current
*
* History:
*  Fri Aug 30 14:39:47 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glwinMakeCurrent(GLWINDOW gw)
{
    return wglMakeCurrent(gw->hdc, gw->hrc);
}

/******************************Public*Routine******************************\
*
* glwinSwapBuffers
*
* Performs double-buffer swapping through blt or flip
*
* History:
*  Fri Aug 30 14:40:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL glwinSwapBuffers(GLWINDOW gw)
{
    return SwapBuffers(gw->hdc);
}

/******************************Public*Routine******************************\
*
* glwinIdleCallback
*
* Set the idle-time callback
*
* History:
*  Fri Aug 30 14:41:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinIdleCallback(GLWINDOW gw, GLWINIDLECALLBACK cb)
{
    gw->cbIdle = cb;
}

/******************************Public*Routine******************************\
*
* glwinMessageCallback
*
* Set the message interposition callback
*
* History:
*  Fri Aug 30 14:41:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinMessageCallback(GLWINDOW gw, GLWINMESSAGECALLBACK cb)
{
    gw->cbMessage = cb;
}

/******************************Public*Routine******************************\
*
* glwinRunWindow
*
* Run the message loop for a single window
*
* History:
*  Fri Aug 30 14:41:58 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinRunWindow(GLWINDOW gw)
{
    MSG msg;
    BOOL bQuit;

    bQuit = FALSE;
    while (!bQuit)
    {
        while (!bQuit && PeekMessage(&msg, gw->hwnd, 0, 0, PM_NOREMOVE))
        {
            if (GetMessage(&msg, gw->hwnd, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                bQuit = TRUE;
            }
        }

        // Call the idle callback if one exists
        if (gw->cbIdle != NULL)
        {
            gw->cbIdle(gw);
        }
    }
}

/******************************Public*Routine******************************\
*
* glwinRun
*
* Run a message loop for all windows
*
* History:
*  Tue Oct 22 11:13:48 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void glwinRun(GLWINIDLECALLBACK cb)
{
    MSG msg;
    BOOL bQuit;

    bQuit = FALSE;
    while (!bQuit)
    {
        while (!bQuit && PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
        {
            if (GetMessage(&msg, NULL, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                bQuit = TRUE;
            }
        }

        // Call the idle callback if one exists
        if (cb != NULL)
        {
            cb(NULL);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glut\test\test9.c ===
/* Copyright (c) Mark J. Kilgard, 1994. */

/* This program is freely distributable without licensing fees 
   and is provided without guarantee or warrantee expressed or 
   implied. This program is -not- in the public domain. */

#ifdef __sgi
#include <malloc.h>
#endif
#include <stdlib.h>
#include <stdio.h>
#ifdef GLUT_WIN32
#include <windows.h>
#endif
#include <GL/glut.h>
#include <gltint.h>

int main_w, w1, w2, w3, w4;

void
display(void)
{
  glClear(GL_COLOR_BUFFER_BIT);
  glutSwapBuffers();
}

void
time8(int value)
{
  printf("PASS: test9\n");
  exit(0);
}

void
time7(int value)
{
  glutDestroyWindow(main_w);
  glutTimerFunc(500, time8, 0);
}

void
time6(int value)
{
  glutDestroyWindow(w1);
  glutTimerFunc(500, time7, 0);
  glutInitDisplayMode(GLUT_INDEX);
  w1 = glutCreateSubWindow(main_w, 10, 10, 10, 10);
  w2 = glutCreateSubWindow(w1, 10, 10, 30, 30);
  w3 = glutCreateSubWindow(w2, 10, 10, 50, 50);
  glutInitDisplayMode(GLUT_RGB);
  w4 = glutCreateSubWindow(w3, 10, 10, 70, 70);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glutDisplayFunc(display);
}

void
time5(int value)
{
  w1 = glutCreateSubWindow(main_w, 10, 10, 10, 10);
  w2 = glutCreateSubWindow(w1, 10, 10, 30, 30);
  w3 = glutCreateSubWindow(w2, 10, 10, 50, 50);
  glutInitDisplayMode(GLUT_RGB);
  w4 = glutCreateSubWindow(w3, 10, 10, 70, 70);
  glClearColor(1.0, 1.0, 1.0, 1.0);
  glutDisplayFunc(display);
  glutTimerFunc(500, time6, 0);
}

void
time4(int value)
{
  glutDestroyWindow(w4);
  glutTimerFunc(500, time5, 0);
}

void
time3(int value)
{
  glutDestroyWindow(w3);
  glutTimerFunc(500, time4, 0);
}

void
time2(int value)
{
  glutDestroyWindow(w2);
  glutTimerFunc(500, time3, 0);
}

void
time1(int value)
{
  glutDestroyWindow(w1);
  glutTimerFunc(500, time2, 0);
}

void
main(int argc, char **argv)
{
#if defined(__sgi) && !defined(REDWOOD)
  /* XXX IRIX 6.0.1 mallopt(M_DEBUG, 1) busted. */
  mallopt(M_DEBUG, 1);
#endif
  glutInit(&argc, argv);

  glutInitDisplayMode(GLUT_RGB);
  main_w = glutCreateWindow("test9");
  glClearColor(0.0, 0.0, 0.0, 0.0);  /* black */
  glutDisplayFunc(display);
  glutInitDisplayMode(GLUT_INDEX);
  w1 = glutCreateSubWindow(main_w, 10, 10, 10, 10);
  glutSetColor(1, 1.0, 0.0, 0.0);  /* red */
  glutSetColor(2, 0.0, 1.0, 0.0);  /* green */
  glutSetColor(3, 0.0, 0.0, 1.0);  /* blue */
  glClearIndex(1);
  glutDisplayFunc(display);
  w2 = glutCreateSubWindow(main_w, 30, 30, 10, 10);
  glutCopyColormap(w1);
  glClearIndex(2);
  glutDisplayFunc(display);
  w3 = glutCreateSubWindow(main_w, 50, 50, 10, 10);
  glutCopyColormap(w1);
  glClearIndex(3);
  glutDisplayFunc(display);
  w4 = glutCreateSubWindow(main_w, 70, 70, 10, 10);
  glutCopyColormap(w1);
  glutSetColor(3, 1.0, 1.0, 1.0);  /* white */
  glClearIndex(3);
  glutDisplayFunc(display);
  glutTimerFunc(750, time1, 0);
  glutMainLoop();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glwin\lib\glwinint.h ===
#ifndef __GLWININT_H__
#define __GLWININT_H__

typedef struct _GLWINDOW *GLWINDOW;

#define __GLWIN_INTERNAL__
#include <glwin.h>

typedef struct _GLWINDOW
{
    HWND hwnd;
    HDC hdc;
    HPALETTE hpal;
    HGLRC hrc;
    DWORD dwFlags;
    int iWidth;
    int iHeight;
    GLWINIDLECALLBACK cbIdle;
    GLWINMESSAGECALLBACK cbMessage;
    BOOL bClosing;
} _GLWINDOW;

#endif // __GLWININT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glwin\lib\precomp.h ===
#include <stdlib.h>

#include <windows.h>
#include <ddraw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glwin\lib\glwin.h ===
#ifndef __GLWIN_H__
#define __GLWIN_H__

#include <windows.h>
#include <gl/gl.h>

#ifndef __GLWIN_INTERNAL__
typedef void *GLWINDOW;
#endif

typedef void (CALLBACK *GLWINIDLECALLBACK)(GLWINDOW gw);
typedef BOOL (CALLBACK *GLWINMESSAGECALLBACK)
    (GLWINDOW gw, HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm,
     LRESULT *plr);

#define GLWIN_BACK_BUFFER        	0x00000001
#define GLWIN_Z_BUFFER_16        	0x00000002
#define GLWIN_Z_BUFFER_32        	0x00000004
#define GLWIN_ACCUM_BUFFER       	0x00000008
#define GLWIN_STENCIL_BUFFER     	0x00000010
#define GLWIN_GENERIC_ACCELERATED	0x00000020

#ifdef __cplusplus
extern "C" {
#endif
    
GLWINDOW glwinCreateWindow(HWND hwndParent,
                           char *pszTitle, int x, int y,
                           int iWidth, int iHeight,
                           DWORD dwFlags);
void     glwinDestroyWindow(GLWINDOW gw);

HGLRC glwinGetGlrc(GLWINDOW gw);
HWND  glwinGetHwnd(GLWINDOW gw);
HDC   glwinGetHdc(GLWINDOW gw);
DWORD glwinGetFlags(GLWINDOW gw);
LONG  glwinGetLastError(void);

BOOL glwinMakeCurrent(GLWINDOW gw);
BOOL glwinSwapBuffers(GLWINDOW gw);
void glwinRunWindow(GLWINDOW gw);
void glwinRun(GLWINIDLECALLBACK cb);

void glwinIdleCallback(GLWINDOW gw, GLWINIDLECALLBACK cb);
void glwinMessageCallback(GLWINDOW gw, GLWINMESSAGECALLBACK cb);

#ifdef __cplusplus
}
#endif
    
#endif // __GLWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\glwin\single\glw.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>
#include <sys\types.h>
#include <sys\timeb.h>

#include <glwin.h>
#include <gl/glu.h>


#pragma warning(disable:4244)

#define PI 3.14159265358979323846

#define GETCOORD(frame, x, y) (&(theMesh.coords[frame*theMesh.numCoords+(x)+(y)*(theMesh.widthX+1)]))
#define GETFACET(frame, x, y) (&(theMesh.facets[frame*theMesh.numFacets+(x)+(y)*theMesh.widthX]))


GLenum rgb, doubleBuffer, directRender;
GLenum noSwap, noClear, useMcd;

GLint colorIndexes1[3];
GLint colorIndexes2[3];
GLenum clearMask = GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT;

GLenum smooth = GL_TRUE;
GLenum lighting = GL_TRUE;
GLenum depth = GL_TRUE;
GLenum stepMode = GL_FALSE;
GLenum spinMode = GL_FALSE;
GLint contouring = 0;

GLint widthX, widthY;
GLint checkerSize;
float height;

GLint frames, curFrame = 0, nextFrame = 0;
GLboolean displayFrameRate = GL_FALSE;
static GLint frameCount = 0;

struct facet {
    float color[3];
    float normal[3];
};
struct coord {
    float vertex[3];
    float normal[3];
};
struct mesh {
    GLint widthX, widthY;
    GLint numFacets;
    GLint numCoords;
    GLint frames;
    struct coord *coords;
    struct facet *facets;
} theMesh;

GLubyte contourTexture1[] = {
    255, 255, 255, 255,
    255, 255, 255, 255,
    255, 255, 255, 255,
    127, 127, 127, 127,
};
GLubyte contourTexture2[] = {
    255, 255, 255, 255,
    255, 127, 127, 127,
    255, 127, 127, 127,
    255, 127, 127, 127,
};

#define ANIMATE_ALL
#define STAGGER_WINDOWS
#define SWAP_MULTIPLE
// #define HIDE_UNDER

#define NWIN 4
int nWin;

GLWINDOW gwWin[NWIN];
int iFront;

WGLSWAP wswaps[NWIN];

DWORD adwFlags[NWIN] =
{
    GLWIN_Z_BUFFER_16,
    GLWIN_Z_BUFFER_16 | GLWIN_BACK_BUFFER,
#if NWIN > 2
    GLWIN_Z_BUFFER_32,
#endif
#if NWIN > 3
    GLWIN_Z_BUFFER_32 | GLWIN_BACK_BUFFER
#endif
};

void Quit(void)
{
    int i;

    for (i = 0; i < nWin; i++)
    {
        if (gwWin[i] != NULL)
        {
            glwinDestroyWindow(gwWin[i]);
        }
    }
    exit(1);
}

static void Animate(GLWINDOW gw)
{
    struct coord *coord;
    struct facet *facet;
    float *lastColor;
    float *thisColor;
    GLint i, j;
    static struct _timeb thisTime, baseTime;
    double elapsed, frameRate, deltat;

    if (stepMode)
    {
        return;
    }
       
    glwinMakeCurrent(gw);
    
    if (!noClear)
    {
        glClear(clearMask);
    }

    if (nextFrame || !stepMode) {
	curFrame++;
    }

    if (curFrame >= theMesh.frames) {
	// mf: do frame rate calcs here
    	if( !frameCount ) {
 	    _ftime( &baseTime );
	}
	else {
	    if( displayFrameRate ) {
 	        _ftime( &thisTime );
	        elapsed = thisTime.time + thisTime.millitm/1000.0 -
		          (baseTime.time + baseTime.millitm/1000.0);
	        if( elapsed == 0.0 )
	            printf( "Frame rate = unknown\n" );
	        else {
	            frameRate = frameCount / elapsed;
	            printf( "Frame rate = %5.2f fps\n", frameRate );
	        }
	    }
	}
	frameCount += theMesh.frames;

	curFrame = 0;
    }

    if ((nextFrame || !stepMode) && spinMode) {
	glRotatef(5.0, 0.0, 0.0, 1.0);
    }
    nextFrame = 0;

    for (i = 0; i < theMesh.widthX; i++) {
	glBegin(GL_QUAD_STRIP);
	lastColor = NULL;
	for (j = 0; j < theMesh.widthY; j++) {
	    facet = GETFACET(curFrame, i, j);
	    if (!smooth && lighting) {
		glNormal3fv(facet->normal);
	    }
	    if (lighting) {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, 
				 facet->color);
		}
	    } else {
		if (rgb) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
		} else {
		    thisColor = facet->color;
		    glIndexf(facet->color[1]);
		}
	    }

	    if (!lastColor || (thisColor[0] != lastColor[0] && smooth)) {
		if (lastColor) {
		    glEnd();
		    glBegin(GL_QUAD_STRIP);
		}
		coord = GETCOORD(curFrame, i, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);

		coord = GETCOORD(curFrame, i+1, j);
		if (smooth && lighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);
	    }

	    coord = GETCOORD(curFrame, i, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    coord = GETCOORD(curFrame, i+1, j+1);
	    if (smooth && lighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    lastColor = thisColor;
	}
	glEnd();
    }

    glFlush();
#ifndef SWAP_MULTIPLE
    if ((glwinGetFlags(gw) & GLWIN_BACK_BUFFER) && !noSwap) {
	glwinSwapBuffers(gw);
    }
#endif
}

void AnimateN(GLWINDOW gw)
{
#ifdef ANIMATE_ALL
    int i;

    for (i = 0; i < nWin; i++)
    {
        Animate(gwWin[i]);
    }
#ifdef SWAP_MULTIPLE
    wglSwapMultipleBuffers(nWin, wswaps);
#endif
#else
    Animate(gwWin[iFront]);
#ifdef SWAP_MULTIPLE
    wglSwapMultipleBuffers(1, &wswaps[iFront]);
#endif
#endif
}

static void InitMesh(void)
{
    struct coord *coord;
    struct facet *facet;
    float dp1[3], dp2[3];
    float *pt1, *pt2, *pt3;
    float angle, d, x, y;
    GLint numFacets, numCoords, frameNum, i, j;

    theMesh.widthX = widthX;
    theMesh.widthY = widthY;
    theMesh.frames = frames;

    numFacets = widthX * widthY;
    numCoords = (widthX + 1) * (widthY + 1);

    theMesh.numCoords = numCoords;
    theMesh.numFacets = numFacets;

    theMesh.coords = (struct coord *)malloc(frames*numCoords*
					    sizeof(struct coord));
    theMesh.facets = (struct facet *)malloc(frames*numFacets*
					    sizeof(struct facet));
    if (theMesh.coords == NULL || theMesh.facets == NULL) {
	printf("Out of memory.\n");
	exit(1);
    }

    for (frameNum = 0; frameNum < frames; frameNum++) {
	for (i = 0; i <= widthX; i++) {
	    x = i / (float)widthX;
	    for (j = 0; j <= widthY; j++) {
		y = j / (float)widthY;

		d = sqrt(x*x+y*y);
		if (d == 0.0) {
		    d = 0.0001;
		}
		angle = 2 * PI * d + (2 * PI / frames * frameNum);

		coord = GETCOORD(frameNum, i, j);

		coord->vertex[0] = x - 0.5;
		coord->vertex[1] = y - 0.5;
		coord->vertex[2] = (height - height * d) * cos(angle);

		coord->normal[0] = -(height / d) * x * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[1] = -(height / d) * y * ((1 - d) * 2 * PI *
				   sin(angle) + cos(angle));
		coord->normal[2] = -1;

		d = 1.0 / sqrt(coord->normal[0]*coord->normal[0]+
			       coord->normal[1]*coord->normal[1]+1);
		coord->normal[0] *= d;
		coord->normal[1] *= d;
		coord->normal[2] *= d;
	    }
	}
	for (i = 0; i < widthX; i++) {
	    for (j = 0; j < widthY; j++) {
		facet = GETFACET(frameNum, i, j);
		if (((i/checkerSize)%2)^(j/checkerSize)%2) {
		    if (rgb) {
			facet->color[0] = 1.0;
			facet->color[1] = 0.2;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes1[0];
			facet->color[1] = colorIndexes1[1];
			facet->color[2] = colorIndexes1[2];
		    }
		} else {
		    if (rgb) {
			facet->color[0] = 0.2;
			facet->color[1] = 1.0;
			facet->color[2] = 0.2;
		    } else {
			facet->color[0] = colorIndexes2[0];
			facet->color[1] = colorIndexes2[1];
			facet->color[2] = colorIndexes2[2];
		    }
		}
		pt1 = GETCOORD(frameNum, i, j)->vertex;
		pt2 = GETCOORD(frameNum, i, j+1)->vertex;
		pt3 = GETCOORD(frameNum, i+1, j+1)->vertex;

		dp1[0] = pt2[0] - pt1[0];
		dp1[1] = pt2[1] - pt1[1];
		dp1[2] = pt2[2] - pt1[2];

		dp2[0] = pt3[0] - pt2[0];
		dp2[1] = pt3[1] - pt2[1];
		dp2[2] = pt3[2] - pt2[2];

		facet->normal[0] = dp1[1] * dp2[2] - dp1[2] * dp2[1];
		facet->normal[1] = dp1[2] * dp2[0] - dp1[0] * dp2[2];
		facet->normal[2] = dp1[0] * dp2[1] - dp1[1] * dp2[0];

		d = 1.0 / sqrt(facet->normal[0]*facet->normal[0]+
			       facet->normal[1]*facet->normal[1]+
			       facet->normal[2]*facet->normal[2]);

		facet->normal[0] *= d;
		facet->normal[1] *= d;
		facet->normal[2] *= d;
	    }
	}
    }
}

static void InitMaterials(void)
{
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float front_mat_shininess[] = {60.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {60.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};

    glMatrixMode(GL_PROJECTION);
    gluPerspective(450, 1.0, 0.5, 10.0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    
    glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
    glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
    glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    if (rgb) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    }

    if (rgb) {
	glEnable(GL_COLOR_MATERIAL);
    } else {
        Quit();
    }
}

static void InitTexture(void)
{

    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
}

static void Init(void)
{

    glClearColor(0.0, 0.0, 0.0, 0.0);

    if (smooth) {
        glShadeModel(GL_SMOOTH);
    } else {
        glShadeModel(GL_FLAT);
    }
    
    glFrontFace(GL_CW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    InitMaterials();
    InitTexture();

    glMatrixMode(GL_MODELVIEW);
    glTranslatef(0.0, 0.4, -1.8);
    glScalef(2.0, 2.0, 2.0);
    glRotatef(-35.0, 1.0, 0.0, 0.0);
    glRotatef(35.0, 0.0, 0.0, 1.0);
}

static GLenum Key(UINT key)
{
#ifdef HIDE_UNDER
    int iOldFront;
#endif
    
    switch (key) {
      case VK_ESCAPE:
	Quit();
      case 'C':
	contouring++;
	if (contouring == 1) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexImage2D(GL_TEXTURE_2D, 0, 3, 4, 4, 0, GL_LUMINANCE,
			 GL_UNSIGNED_BYTE, (GLvoid *)contourTexture1);
	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
	    glTexGenfv(GL_S, GL_OBJECT_PLANE, map);
	    glTexGenfv(GL_T, GL_OBJECT_PLANE, map);
	    glEnable(GL_TEXTURE_2D);
	    glEnable(GL_TEXTURE_GEN_S);
	    glEnable(GL_TEXTURE_GEN_T);
	} else if (contouring == 2) {
	    static GLfloat map[4] = {0, 0, 20, 0};

	    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	    glPushMatrix();
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	    glTexGenfv(GL_S, GL_EYE_PLANE, map);
	    glTexGenfv(GL_T, GL_EYE_PLANE, map);
	    glPopMatrix();
	} else {
	    contouring = 0;
	    glDisable(GL_TEXTURE_GEN_S);
	    glDisable(GL_TEXTURE_GEN_T);
	    glDisable(GL_TEXTURE_2D);
	}
	break;
      case 'S':
	smooth = !smooth;
	if (smooth) {
	    glShadeModel(GL_SMOOTH);
	} else {
	    glShadeModel(GL_FLAT);
	}
	break;
      case 'L':
	lighting = !lighting;
	if (lighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
	    if (rgb) {
		glEnable(GL_COLOR_MATERIAL);
	    }
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
	    if (rgb) {
		glDisable(GL_COLOR_MATERIAL);
	    }
	}
	break;
      case 'D':
	depth = !depth;
	if (depth) {
	    glEnable(GL_DEPTH_TEST);
	    clearMask |= GL_DEPTH_BUFFER_BIT;
	} else {
	    glDisable(GL_DEPTH_TEST);
	    clearMask &= ~GL_DEPTH_BUFFER_BIT;
	}
	break;
      case VK_SPACE:
	stepMode = !stepMode;
	break;
      case 'N':
	if (stepMode) {
	    nextFrame = 1;
	}
	break;
      case 'F':
	displayFrameRate = !displayFrameRate;
	frameCount = 0;
	break;
      case 'A':
	spinMode = !spinMode;
	break;
      case 'Z':
#ifdef HIDE_UNDER
        iOldFront = iFront;
#endif
        iFront = (iFront+1) % nWin;
#ifdef HIDE_UNDER
        ShowWindow(glwinGetHwnd(gwWin[iFront]), SW_SHOW);
        ShowWindow(glwinGetHwnd(gwWin[iOldFront]), SW_HIDE);
#else
        SetWindowPos(glwinGetHwnd(gwWin[iFront]), HWND_TOP, 0, 0, 0, 0,
                     SWP_NOMOVE | SWP_NOSIZE);
#endif
        break;
      default:
	return GL_FALSE;
    }
    return GL_TRUE;
}

BOOL Message(GLWINDOW gw, HWND hwnd, UINT uiMsg, WPARAM wpm, LPARAM lpm,
             LRESULT *plr)
{
    switch(uiMsg)
    {
    case WM_KEYDOWN:
        Key((UINT)wpm);
        break;

    default:
        return FALSE;
    }

    *plr = 0;
    return TRUE;
}

static GLenum Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;
    directRender = GL_FALSE;
    noSwap = GL_FALSE;
    noClear = GL_FALSE;
    useMcd = GL_FALSE;
    nWin = NWIN;

    frames = 10;
    widthX = 10;
    widthY = 10;
    checkerSize = 2;
    height = 0.2;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-ci") == 0) {
	    rgb = GL_FALSE;
	} else if (strcmp(argv[i], "-rgb") == 0) {
	    rgb = GL_TRUE;
	} else if (strcmp(argv[i], "-sb") == 0) {
	    doubleBuffer = GL_FALSE;
	} else if (strcmp(argv[i], "-db") == 0) {
	    doubleBuffer = GL_TRUE;
	} else if (strcmp(argv[i], "-dr") == 0) {
	    directRender = GL_TRUE;
	} else if (strcmp(argv[i], "-ir") == 0) {
	    directRender = GL_FALSE;
	} else if (strcmp(argv[i], "-noswap") == 0) {
	    noSwap = GL_TRUE;
	} else if (strcmp(argv[i], "-noclear") == 0) {
	    noClear = GL_TRUE;
	} else if (strcmp(argv[i], "-mcd") == 0) {
	    useMcd = GL_TRUE;
        } else if (strcmp(argv[i], "-nwin") == 0) {
            if (i+1 >= argc || argv[i+1][0] == '-') {
                printf("-nwin (No numbers).\n");
                return GL_FALSE;
            } else {
                nWin = atoi(argv[++i]);
            }
	} else if (strcmp(argv[i], "-grid") == 0) {
	    if (i+2 >= argc || argv[i+1][0] == '-' || argv[i+2][0] == '-') {
		printf("-grid (No numbers).\n");
		return GL_FALSE;
	    } else {
		widthX = atoi(argv[++i]);
		widthY = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-size") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-checker (No number).\n");
		return GL_FALSE;
	    } else {
		checkerSize = atoi(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-wave") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-wave (No number).\n");
		return GL_FALSE;
	    } else {
		height = atof(argv[++i]);
	    }
	} else if (strcmp(argv[i], "-frames") == 0) {
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		printf("-frames (No number).\n");
		return GL_FALSE;
	    } else {
		frames = atoi(argv[++i]);
	    }
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	    return GL_FALSE;
	}
    }
    return GL_TRUE;
}

void __cdecl main(int argc, char **argv)
{
    DWORD dwBaseFlags;
    DWORD dwFlags;
    GLWINDOW gw;
    int iWidth, iHeight;
    int x, y;
    int i;
    char achName[80];

    if (Args(argc, argv) == GL_FALSE) {
	exit(1);
    }

    InitMesh();

    dwBaseFlags = useMcd ? GLWIN_GENERIC_ACCELERATED : 0;
    
    x = 10;
    y = 30;
    iWidth = 320;
    iHeight = 320;

    for (i = 0; i < nWin; i++)
    {
        dwFlags = (adwFlags[i] | dwBaseFlags) ^
            (doubleBuffer ? GLWIN_BACK_BUFFER : 0);
        sprintf(achName, "Wave Demo Window %d Flags 0x%lX", i, dwFlags);
        gw = glwinCreateWindow(NULL, achName, x, y, iWidth, iHeight, dwFlags);
        if (gw == NULL)
        {
            printf("glwinCreateWindow failed with 0x%08lX\n",
                   glwinGetLastError());
            Quit();
        }
        gwWin[i] = gw;
        wswaps[i].hdc = glwinGetHdc(gw);
        wswaps[i].uiFlags = WGL_SWAP_MAIN_PLANE;
        glwinMakeCurrent(gw);
        Init();
        glwinMessageCallback(gw, Message);

#ifdef HIDE_UNDER
        if (i < nWin-1)
        {
            ShowWindow(glwinGetHwnd(gw), SW_HIDE);
        }
#endif
#ifdef STAGGER_WINDOWS
        x += iWidth/3;
        y += iHeight/3;
#endif
    }

    iFront = i-1;
    glwinRun(AnimateN);

    Quit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\common\trackbal\trackbal.h ===
/*
 * trackball.h
 * A virtual trackball implementation
 * Written by Gavin Bell for Silicon Graphics, November 1988.
 */

/*
 * Initialize trackball in win32 environment
 */
extern void
trackball_Init( GLint width, GLint height );

extern void
trackball_Resize( GLint width, GLint height );

extern GLenum 
trackball_MouseDown( int mouseX, int mouseY, GLenum button );

extern GLenum 
trackball_MouseUp( int mouseX, int mouseY, GLenum button );

/* These next Mouse fns are required if both the trackbal and user
 * need mouse events.  Otherwise, can just supply above two functions
 * to tk to call
 */

/*
 * Mouse functions called directly on events
 */
extern void
trackball_MouseDownEvent( int mouseX, int mouseY, GLenum button );

extern void
trackball_MouseUpEvent( int mouseX, int mouseY, GLenum button );

/*
 * Functions to register mouse event callbacks
 */
extern void 
trackball_MouseDownFunc(GLenum (*)(int, int, GLenum));

extern void 
trackball_MouseUpFunc(GLenum (*)(int, int, GLenum));

/*
 * Calculate rotation matrix based on mouse movement
 */
void
trackball_CalcRotMatrix( GLfloat matRot[4][4] );

/*
 * Pass the x and y coordinates of the last and current positions of
 * the mouse, scaled so they are from (-1.0 ... 1.0).
 *
 * if ox,oy is the window's center and sizex,sizey is its size, then
 * the proper transformation from screen coordinates (sc) to world
 * coordinates (wc) is:
 * wcx = (2.0 * (scx-ox)) / (float)sizex - 1.0
 * wcy = (2.0 * (scy-oy)) / (float)sizey - 1.0
 *
 * The resulting rotation is returned as a quaternion rotation in the
 * first paramater.
 */
void
trackball_calc_quat(float q[4], float p1x, float p1y, float p2x, float p2y);

/*
 * Given two quaternions, add them together to get a third quaternion.
 * Adding quaternions to get a compound rotation is analagous to adding
 * translations to get a compound translation.  When incrementally
 * adding rotations, the first argument here should be the new
 * rotation, the second and third the total rotation (which will be
 * over-written with the resulting new total rotation).
 */
void
trackball_add_quats(float *q1, float *q2, float *dest);

/*
 * A useful function, builds a rotation matrix in Matrix based on
 * given quaternion.
 */
void
trackball_build_rotmatrix(float m[4][4], float q[4]);

/*
 * This function computes a quaternion based on an axis (defined by
 * the given vector) and an angle about which to rotate.  The angle is
 * expressed in radians.  The result is put into the third argument.
 */
void
trackball_axis_to_quat(float a[3], float phi, float q[4]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\font\charspin\charspin.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <ptypes32.h>
#include <pwin32.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>
#include <sys\types.h>
#include <sys\timeb.h>

#include <GL/glaux.h>
#include "tk.h"

#include "sscommon.h"
#include "trackbal.h"

static void Draw(void);
static void DrawAuto(void);
static BOOL Init(void);
static void InitLighting(void);
static void Reshape(int, int);
static void SetModelView( void );
static GLenum Key(int key, GLenum mask);

static int GetStringExtent( char *string, POINTFLOAT *extent );
static void CalcStringMetrics( char *string );

VOID Arg( LPSTR );

// Global variables
GLuint  dlFont, dpFont;
GLint firstGlyph;
GLint Width = 300, Height = 300;
POINTFLOAT strSize;
int strLen;
GLfloat xRot = 0.0f, yRot = 0.0f, zRot = 0.0f;
GLdouble zTrans = -200.0;
GLfloat extrusion;
GLenum doubleBuffer = GL_TRUE;
GLenum bLighting = GL_TRUE;
GLenum fontStyle = WGL_FONT_POLYGONS;
LPGLYPHMETRICSFLOAT lpgmf;

// output from tesselator always ccw
GLenum orientation = GL_CCW;

char *texFileName = 0;
GLint matIndex = 1;
BOOL bAutoRotate = TRUE;
BOOL bCullBack   = TRUE;
BOOL bTwoSidedLighting = FALSE;

BOOL    bInitTexture = TRUE;
BOOL    bTexture = FALSE;
BOOL    bAntialias = FALSE;

char singleChar[] = "A";
char string[] = "OpenGL!";
char *drawString = singleChar;

#if defined( TIME )
#undef TIME
#endif
typedef struct _timeb TIME;

enum {
    TIMER_START = 0,
    TIMER_STOP,
    TIMER_TIMING,
    TIMER_RESET
};
static int gTimerStatus = TIMER_RESET;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    GLenum type;

    Arg( lpCmdLine );

    tkInitPosition( 0, 0, Width, Height );

    type = TK_DEPTH16;
    type |= TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    tkInitDisplayMode(type);

    if (tkInitWindow("Fontal assault") == GL_FALSE) {
	    tkQuit();
    }

    if( !Init() )
        tkQuit();

    tkExposeFunc( Reshape );
    tkReshapeFunc( Reshape );
    tkKeyDownFunc( Key );
    tkMouseDownFunc( trackball_MouseDown );
    tkMouseUpFunc( trackball_MouseUp );

    trackball_Init( Width, Height );

    if( bAutoRotate ) {
        tkIdleFunc( DrawAuto );
        tkDisplayFunc(0);
    } else {
        tkDisplayFunc(Draw);
    }

    tkExec();
    return 1;
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	    tkQuit();

      case TK_LEFT:
	    yRot -= 5;
	    break;
      case TK_RIGHT:
	    yRot += 5;
	    break;
      case TK_UP:
	    xRot -= 5;
	    break;
      case TK_DOWN:
	    xRot += 5;
	    break;
      case TK_X:
	    zRot += 5;
	    break;
      case TK_x:
	    zRot -= 5;
	    break;
      case TK_Z:
	    zTrans -= strSize.y/10.0;
        SetModelView();
	    break;
      case TK_z:
	    zTrans += strSize.y/10.0;
        SetModelView();
	    break;
      case TK_l:
	    if( bLighting = !bLighting ) {
            glEnable(GL_LIGHTING);
            glEnable(GL_LIGHT0);
        }
        else
        {
            glDisable(GL_LIGHTING);
            glDisable(GL_LIGHT0);
        }
	    break;
      case TK_m:
        if( !bTexture ) {
            if( ++matIndex > NUM_TEA_MATERIALS )
                matIndex =0;
            ss_SetMaterialIndex( matIndex );
        }
	    break;
      case TK_n:
            singleChar[0] += 1;
	    break;
      case TK_N:
            singleChar[0] -= 1;
	    break;
      
#if 1
      case TK_o:
	    orientation = (orientation == GL_CCW) ? GL_CW : GL_CCW;
        glFrontFace( orientation );
	    break;
#else
      case TK_o:
            if( bAntialias = !bAntialias ) {
                if( fontStyle == WGL_FONT_LINES ) {
                    glEnable( GL_LINE_SMOOTH );
                    glEnable( GL_BLEND );
                } else {
                    glDisable( GL_DEPTH_TEST );
                    glEnable( GL_POLYGON_SMOOTH );
                    glEnable( GL_BLEND );
                }
            } else  {
                glDisable( GL_POLYGON_SMOOTH );
                glDisable( GL_LINE_SMOOTH );
                glDisable( GL_BLEND );
                glEnable( GL_DEPTH_TEST );
            }
            break;
#endif
      case TK_t:
        bTexture = !bTexture;
        if( bTexture ) {
            ss_SetMaterialIndex( WHITE );
            glEnable( GL_TEXTURE_2D );
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
        } else {
            ss_SetMaterialIndex( matIndex );
            glDisable( GL_TEXTURE_2D );
            glDisable(GL_TEXTURE_GEN_S);
            glDisable(GL_TEXTURE_GEN_T);
        }
        break;
      case TK_s:
        // switch between wireframe and solid polygons
	    fontStyle = (fontStyle == WGL_FONT_LINES) ? WGL_FONT_POLYGONS :
                    WGL_FONT_LINES;
	    break;

      case TK_c:
        drawString = (drawString == singleChar) ? string : singleChar;
        CalcStringMetrics( drawString );
        // change viewing matrix based on string extent
        Reshape( Width, Height );
        //SetModelView();
        break;

      case TK_u:
        // cUllface stuff
        bCullBack = !bCullBack;
        if( bCullBack ) {
            glCullFace( GL_BACK );
            glEnable( GL_CULL_FACE );
        } else {
            glDisable( GL_CULL_FACE );
        }
        break;

      case TK_2:
        bTwoSidedLighting = !bTwoSidedLighting;
        if( bTwoSidedLighting ) {
            glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 1 );
        } else {
            glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 0 );
        }
        break;

      case TK_a:
        // animate or not
        bAutoRotate= !bAutoRotate;
        if( bAutoRotate ) {
            tkIdleFunc(DrawAuto);
            tkDisplayFunc(0);
        } else {
            tkIdleFunc(0);
            tkDisplayFunc(Draw);
        }
        break;

        case TK_f :
            switch( gTimerStatus ) {
                case TIMER_START:
                    break;
                case TIMER_STOP:
                case TIMER_RESET:
                    gTimerStatus = TIMER_START;
                    break;
                case TIMER_TIMING:
                    gTimerStatus = TIMER_STOP;
                    break;
                default:
                    break;
            }
        break;

      default:
	    return GL_FALSE;
    }
    return GL_TRUE;
}

static void InitLighting(void)
{
    static float ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};
    static float diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float position[] = {0.0f, 0.0f, 150.0f, 0.0f};

    static float back_mat_shininess[] = {50.0f};
    static float back_mat_specular[] = {0.5f, 0.5f, 0.2f, 1.0f};
    static float back_mat_diffuse[] = {1.0f, 0.0f, 0.0f, 1.0f};
    static float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float decal[] = {(GLfloat) GL_DECAL}; 
    static float modulate[] = {(GLfloat) GL_MODULATE};
    static float repeat[] = {(GLfloat) GL_REPEAT}; 
    static float nearest[] = {(GLfloat) GL_NEAREST};
    TK_RGBImageRec *image;

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glFrontFace( orientation );

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    if( bLighting ) {
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
    }

    // override back material
    glMaterialfv( GL_BACK, GL_AMBIENT, ambient );
    glMaterialfv( GL_BACK, GL_DIFFUSE, back_mat_diffuse );
    glMaterialfv( GL_BACK, GL_SPECULAR, back_mat_specular );
    glMaterialfv( GL_BACK, GL_SHININESS, back_mat_shininess );

    if( bTwoSidedLighting ) {
        glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 1 );
    } else {
        glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 0 );
    }

    // set back face culling mode

    if( bCullBack ) {
        glCullFace( GL_BACK );
        glEnable( GL_CULL_FACE );
    } else {
        glDisable( GL_CULL_FACE );
    }

    // Initialize materials from screen saver common lib
    ss_InitMaterials();
    matIndex = JADE;
    ss_SetMaterialIndex( matIndex );

    // do texturing preparations

    if( bInitTexture ) {
        //glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
        glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, modulate);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
        if (texFileName) {
	        image = tkRGBImageLoad(texFileName);
	        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	        gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
			              GL_RGB, GL_UNSIGNED_BYTE, image->data);
        }
        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
        if( bTexture ) {
            glEnable( GL_TEXTURE_2D );
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            ss_SetMaterialIndex( WHITE );
        }
    }
}

BOOL Init(void)
{
    OUTLINETEXTMETRIC otm;
    CHOOSEFONT cf;
    LOGFONT    lf;
    HFONT      hfont, hfontOld;
    GLfloat     chordal_deviation;
    int numGlyphs=224;
    HWND  hwnd;
    HDC   hdc;
    TIME baseTime;
    TIME thisTime;
    double elapsed;
    char buf[100];

    hdc = tkGetHDC();
    hwnd = tkGetHWND();

    // Create and select a font.

    cf.lStructSize = sizeof(CHOOSEFONT);
    cf.hwndOwner = hwnd;
    cf.hDC = hdc;
    cf.lpLogFont = &lf;
    cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_TTONLY;

    memset(&lf, 0, sizeof(LOGFONT));
    lstrcpy(lf.lfFaceName, "Arial");
    lf.lfHeight = 50;

    ChooseFont(&cf);

    // !!! Bug ?  In some cases, like small sizes of Symbol font, the
    // lfOutPrecision value is set to OUT_STROKE_PRECIS, which won't work.
    // So if this happens, force the right value.

    if( lf.lfOutPrecision != OUT_TT_ONLY_PRECIS )
        lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;


    // lf reflects user's final choices

    if( !(hfont = CreateFontIndirect(&lf)) ) {
        DbgPrint( "CreateFontIndirect failed.\n" );
        return FALSE;
    }

    hfontOld = SelectObject(hdc, hfont);

    // Test we can get truetype metrics (this is called by wglUseFontOutlines)
    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 ) {
        // cmd failed, or buffer size=0
        DbgPrint( "GetOutlineTextMetrics failed.\n" );
        return FALSE;
    }

    // Generate a display list for font

    dlFont = glGenLists(numGlyphs);
    dpFont = glGenLists(numGlyphs);

    chordal_deviation = 0.005f;
    extrusion = 0.25f;

    firstGlyph = 32;

    lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED, numGlyphs *
                                    sizeof(GLYPHMETRICSFLOAT) );
    if( !wglUseFontOutlinesA(hdc, firstGlyph, numGlyphs, dlFont, chordal_deviation, 
                       extrusion, WGL_FONT_LINES, lpgmf ) )
        return FALSE;

    _ftime( &baseTime );
    if( ! wglUseFontOutlinesA(hdc, firstGlyph, numGlyphs, dpFont, 
            chordal_deviation, extrusion, WGL_FONT_POLYGONS, NULL ) )
        return FALSE;
    glFinish();
    _ftime( &thisTime );
    elapsed = thisTime.time + thisTime.millitm/1000.0 -
       (baseTime.time + baseTime.millitm/1000.0);
    sprintf( buf, "Setup time = %5.2f seconds", elapsed );
    SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)buf);

    CalcStringMetrics( drawString );

    /* Set the clear color */

    glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );

    // Initialize lighting
    InitLighting();

    // Blend func for AA
    glBlendFunc( GL_SRC_ALPHA, GL_ONE );

    return TRUE; // success
}

static void Reshape( int width, int height )
{
    static GLdouble zNear = 0.1, zFar = 1000.0, fovy = 90.0;
    float aspect;

    trackball_Resize( width, height );

    /* Set up the projection matrix */

    Width = width;
    Height = height;
    aspect = Height == 0 ? 1.0f : Width/(float)Height;

    glViewport(0, 0, Width, Height );
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    zFar = 10.0f * strSize.x;
    gluPerspective(fovy, aspect, zNear, zFar );
    glMatrixMode(GL_MODELVIEW);

    SetModelView();
}

static void SetModelView( void )
{
    glLoadIdentity();
#if 1
    glTranslated( 0, 0, zTrans );
#else
    /* this has side effect of flipping around viewpoint when pass through
       origin
    */
    gluLookAt( 0, 0, -zTrans,
               0, 0, 0,
               0, 1, 0 );
#endif
}

void CalcFrameRate( char *buf, struct _timeb baseTime, int frameCount ) {
    static struct _timeb thisTime;
    double elapsed, frameRate;

    _ftime( &thisTime );
    elapsed = thisTime.time + thisTime.millitm/1000.0 -
       (baseTime.time + baseTime.millitm/1000.0);
    if( elapsed == 0.0 )
        sprintf( buf, "Frame rate = unknown" );
    else {
        frameRate = frameCount / elapsed;
        sprintf( buf, "Frame rate = %4.1f fps", frameRate );
    }
}
static void DrawAuto(void)
{
    POINT pt;
    float  matRot[4][4];
    static int frameCount = 0;
    static struct _timeb baseTime;
    char buf[1024];
    HWND  hwnd;
    BOOL bTiming = TRUE;

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    if( fontStyle == WGL_FONT_LINES )
        glListBase(dlFont-32);
    else
        glListBase(dpFont-32);

    glPushMatrix();

    trackball_CalcRotMatrix( matRot );
    glMultMatrixf(&(matRot[0][0]));

    // now draw text, centered in window

    glTranslated( -strSize.x/2.0, -strSize.y/2.0, extrusion/2.0 );

    glCallLists(strLen, GL_UNSIGNED_BYTE, (GLubyte *) drawString);

    glPopMatrix();

    glFlush();
    if( doubleBuffer )
        tkSwapBuffers();

    hwnd = tkGetHWND();

    switch( gTimerStatus ) {
        case TIMER_START:
            gTimerStatus = TIMER_TIMING;
            frameCount = 0;
            sprintf( buf, "Timing..." );
            SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)buf);
 	        _ftime( &baseTime );
            break;
        case TIMER_STOP:
            gTimerStatus = TIMER_RESET;
            frameCount++;
            CalcFrameRate( buf, baseTime, frameCount );
            SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)buf);
            break;
        case TIMER_TIMING:
            frameCount++;
            break;
        case TIMER_RESET:
        default:
            break;
    }
}

static void Draw(void)
{

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    if( fontStyle == WGL_FONT_LINES )
        glListBase(dlFont-32);
    else
        glListBase(dpFont-32);

    glPushMatrix();

    glRotatef( xRot, 1.0f, 0.0f, 0.0f );
    glRotatef( yRot, 0.0f, 1.0f, 0.0f );
    glRotatef( zRot, 0.0f, 0.0f, 1.0f );

    // center the string in window
    glTranslated( -strSize.x/2.0, -strSize.y/2.0, extrusion/2.0 );
    glCallLists(strLen, GL_UNSIGNED_BYTE, (GLubyte *) drawString);

    glPopMatrix();

    glFlush();
    if( doubleBuffer )
        tkSwapBuffers();
}

static int GetStringExtent( char *string, POINTFLOAT *extent )
{
    int len, strLen;
    unsigned char *c;
    GLYPHMETRICSFLOAT *pgmf;

    extent->x = extent->y = 0.0f;
    len = strLen = lstrlenA( string );
    c = string;

    for( ; strLen; strLen--, c++ ) {
        if( *c < firstGlyph )
            continue;
        pgmf = &lpgmf[ *c - firstGlyph ];
        extent->x += pgmf->gmfCellIncX;
        if( pgmf->gmfBlackBoxY > extent->y )
            extent->y = pgmf->gmfBlackBoxY;
    }
    return len;
}

static void CalcStringMetrics( char *string )
{
    // get string size for window reshape
    strLen = GetStringExtent( string, &strSize );

    // set zTrans based on glyph extent
    zTrans = - 3.0 * (strSize.y / 2.0f);
}

VOID Arg(LPSTR lpstr)
{
    while (*lpstr && *lpstr != '-') lpstr++;
    // only one arg for now (e.g.: -f 3.rgb)
    lpstr++;
    if( *lpstr++ == 'f' ) {
        texFileName = ++lpstr; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\common\trackbal\trackbal.c ===
/*
 * Trackball code:
 *
 * Implementation of a virtual trackball.
 * Implemented by Gavin Bell, lots of ideas from Thant Tessman and
 *   the August '88 issue of Siggraph's "Computer Graphics," pp. 121-129.
 *
 * Vector manip code:
 *
 * Original code from:
 * David M. Ciemiewicz, Mark Grossman, Henry Moreton, and Paul Haeberli
 *
 * Much mucking with by:
 * Gavin Bell
 *
 * Shell hacking courtesy of:
 * Reptilian Inhaleware
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <math.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "tk.h"
#include "trackbal.h"

/* 
 * globals
 */
static GLenum (*MouseDownFunc)(int, int, GLenum) = NULL;
static GLenum (*MouseUpFunc)(int, int, GLenum)   = NULL;
static HWND ghwnd;
GLint giWidth, giHeight;
LONG    glMouseDownX, glMouseDownY;
BOOL    gbLeftMouse = FALSE;
BOOL    gbSpinning = FALSE;
float   curquat[4], lastquat[4];

/*
 * This size should really be based on the distance from the center of
 * rotation to the point on the object underneath the mouse.  That
 * point would then track the mouse as closely as possible.  This is a
 * simple example, though, so that is left as an Exercise for the
 * Programmer.
 */
#define TRACKBALLSIZE  (0.8f)

/*
 * Local function prototypes (not defined in trackball.h)
 */
static float tb_project_to_sphere(float, float, float);
static void normalize_quat(float [4]);

void 
trackball_Init( GLint width, GLint height )
{
    ghwnd = tkGetHWND();
    giWidth = width;
    giHeight = height;

    trackball_calc_quat( curquat, 0.0f, 0.0f, 0.0f, 0.0f );
}

void
trackball_Resize( GLint width, GLint height )
{
    giWidth = width;
    giHeight = height;
}

GLenum
trackball_MouseDown( int mouseX, int mouseY, GLenum button ) 
{
    SetCapture(ghwnd);
    glMouseDownX = mouseX;
    glMouseDownY = mouseY;
    gbLeftMouse = TRUE;
    return GL_TRUE;
}

GLenum
trackball_MouseUp( int mouseX, int mouseY, GLenum button ) 
{
    ReleaseCapture();
    gbLeftMouse = FALSE;
    return GL_TRUE;
}

/* these 4 not used yet */
void
trackball_MouseDownEvent( int mouseX, int mouseY, GLenum button )
{
}

void
trackball_MouseUpEvent( int mouseX, int mouseY, GLenum button )
{
}

void 
trackball_MouseDownFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseDownFunc = Func;
}

void 
trackball_MouseUpFunc(GLenum (*Func)(int, int, GLenum))
{
    MouseUpFunc = Func;
}

void
trackball_CalcRotMatrix( GLfloat matRot[4][4] )
{
    POINT pt;

    if (gbLeftMouse)
    {
        tkGetMouseLoc( &pt.x, &pt.y );

        // If mouse has moved since button was pressed, change quaternion.

            if (pt.x != glMouseDownX || pt.y != glMouseDownY)
            {
#if 1
    /* negate all params for proper operation with glTranslate(-z)
     */
                trackball_calc_quat(lastquat,
                          -(2.0f * ( giWidth - glMouseDownX ) / giWidth - 1.0f),
                          -(2.0f * glMouseDownY / giHeight - 1.0f),
                          -(2.0f * ( giWidth - pt.x ) / giWidth - 1.0f),
                          -(2.0f * pt.y / giHeight - 1.0f)
                         );
#else
// now out-of-date
                trackball_calc_quat(lastquat,
                          2.0f * ( Width - glMouseDownX ) / Width - 1.0f,
                          2.0f * glMouseDownY / Height - 1.0f,
                          2.0f * ( Width - pt.x ) / Width - 1.0f,
                          2.0f * pt.y / Height - 1.0f );
#endif

                gbSpinning = TRUE;
            }
            else
                gbSpinning = FALSE;

            glMouseDownX = pt.x;
            glMouseDownY = pt.y;
    }

    if (gbSpinning)
        trackball_add_quats(lastquat, curquat, curquat);

    trackball_build_rotmatrix(matRot, curquat);
}

void
vzero(float *v)
{
    v[0] = 0.0f;
    v[1] = 0.0f;
    v[2] = 0.0f;
}

void
vset(float *v, float x, float y, float z)
{
    v[0] = x;
    v[1] = y;
    v[2] = z;
}

void
vsub(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] - src2[0];
    dst[1] = src1[1] - src2[1];
    dst[2] = src1[2] - src2[2];
}

void
vcopy(const float *v1, float *v2)
{
    register int i;
    for (i = 0 ; i < 3 ; i++)
        v2[i] = v1[i];
}

void
vcross(const float *v1, const float *v2, float *cross)
{
    float temp[3];

    temp[0] = (v1[1] * v2[2]) - (v1[2] * v2[1]);
    temp[1] = (v1[2] * v2[0]) - (v1[0] * v2[2]);
    temp[2] = (v1[0] * v2[1]) - (v1[1] * v2[0]);
    vcopy(temp, cross);
}

float
vlength(const float *v)
{
    return (float) sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

void
vscale(float *v, float div)
{
    v[0] *= div;
    v[1] *= div;
    v[2] *= div;
}

void
vnormal(float *v)
{
    vscale(v,1.0f/vlength(v));
}

float
vdot(const float *v1, const float *v2)
{
    return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2];
}

void
vadd(const float *src1, const float *src2, float *dst)
{
    dst[0] = src1[0] + src2[0];
    dst[1] = src1[1] + src2[1];
    dst[2] = src1[2] + src2[2];
}

/*
 * Ok, simulate a track-ball.  Project the points onto the virtual
 * trackball, then figure out the axis of rotation, which is the cross
 * product of P1 P2 and O P1 (O is the center of the ball, 0,0,0)
 * Note:  This is a deformed trackball-- is a trackball in the center,
 * but is deformed into a hyperbolic sheet of rotation away from the
 * center.  This particular function was chosen after trying out
 * several variations.
 * 
 * It is assumed that the arguments to this routine are in the range
 * (-1.0 ... 1.0)
 */
void
trackball_calc_quat(float q[4], float p1x, float p1y, float p2x, float p2y)
{
    float a[3]; /* Axis of rotation */
    float phi;  /* how much to rotate about axis */
    float p1[3], p2[3], d[3];
    float t;

    if (p1x == p2x && p1y == p2y) {
	/* Zero rotation */
        vzero(q); 
	q[3] = 1.0f; 
        return;
    }

    /*
     * First, figure out z-coordinates for projection of P1 and P2 to
     * deformed sphere
     */
    vset(p1,p1x,p1y,tb_project_to_sphere(TRACKBALLSIZE,p1x,p1y));
    vset(p2,p2x,p2y,tb_project_to_sphere(TRACKBALLSIZE,p2x,p2y));

    /*
     *  Now, we want the cross product of P1 and P2
     */
    vcross(p2,p1,a);

    /*
     *  Figure out how much to rotate around that axis.
     */
    vsub(p1,p2,d);
    t = vlength(d) / (2.0f*TRACKBALLSIZE);

    /*
     * Avoid problems with out-of-control values...
     */
    if (t > 1.0f) t = 1.0f;
    if (t < -1.0f) t = -1.0f;
    phi = 2.0f * (float) asin(t);

    trackball_axis_to_quat(a,phi,q);
}

/*
 *  Given an axis and angle, compute quaternion.
 */
void
trackball_axis_to_quat(float a[3], float phi, float q[4])
{
    vnormal(a);
    vcopy(a,q);
    vscale(q,(float) sin(phi/2.0f));
    q[3] = (float) cos(phi/2.0f);
}

/*
 * Project an x,y pair onto a sphere of radius r OR a hyperbolic sheet
 * if we are away from the center of the sphere.
 */
static float
tb_project_to_sphere(float r, float x, float y)
{
    float d, t, z;

    d = (float) sqrt(x*x + y*y);
    if (d < r * 0.70710678118654752440f) {    /* Inside sphere */
	z = (float) sqrt(r*r - d*d);
    } else {           /* On hyperbola */
        t = r / 1.41421356237309504880f;
        z = t*t / d;
    }
    return z;
}

/*
 * Given two rotations, e1 and e2, expressed as quaternion rotations,
 * figure out the equivalent single rotation and stuff it into dest.
 * 
 * This routine also normalizes the result every RENORMCOUNT times it is
 * called, to keep error from creeping in.
 *
 * NOTE: This routine is written so that q1 or q2 may be the same
 * as dest (or each other).
 */

#define RENORMCOUNT 97

void
trackball_add_quats(float q1[4], float q2[4], float dest[4])
{
    static int count=0;
    int i;
    float t1[4], t2[4], t3[4];
    float tf[4];

    vcopy(q1,t1); 
    vscale(t1,q2[3]);

    vcopy(q2,t2); 
    vscale(t2,q1[3]);

    vcross(q2,q1,t3);
    vadd(t1,t2,tf);
    vadd(t3,tf,tf);
    tf[3] = q1[3] * q2[3] - vdot(q1,q2);

    dest[0] = tf[0];
    dest[1] = tf[1];
    dest[2] = tf[2];
    dest[3] = tf[3];

    if (++count > RENORMCOUNT) {
        count = 0;
        normalize_quat(dest);
    }
}

/*
 * Quaternions always obey:  a^2 + b^2 + c^2 + d^2 = 1.0
 * If they don't add up to 1.0, dividing by their magnitued will
 * renormalize them.
 *
 * Note: See the following for more information on quaternions:
 * 
 * - Shoemake, K., Animating rotation with quaternion curves, Computer
 *   Graphics 19, No 3 (Proc. SIGGRAPH'85), 245-254, 1985.
 * - Pletinckx, D., Quaternion calculus as a basic tool in computer
 *   graphics, The Visual Computer 5, 2-13, 1989.
 */
static void
normalize_quat(float q[4])
{
    int i;
    float mag;

    mag = (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);
    for (i = 0; i < 4; i++) q[i] /= mag;
}

/*
 * Build a rotation matrix, given a quaternion rotation.
 *
 */
void
trackball_build_rotmatrix(float m[4][4], float q[4])
{
    m[0][0] = 1.0f - 2.0f * (q[1] * q[1] + q[2] * q[2]);
    m[0][1] = 2.0f * (q[0] * q[1] - q[2] * q[3]);
    m[0][2] = 2.0f * (q[2] * q[0] + q[1] * q[3]);
    m[0][3] = 0.0f;

    m[1][0] = 2.0f * (q[0] * q[1] + q[2] * q[3]);
    m[1][1]= 1.0f - 2.0f * (q[2] * q[2] + q[0] * q[0]);
    m[1][2] = 2.0f * (q[1] * q[2] - q[0] * q[3]);
    m[1][3] = 0.0f;

    m[2][0] = 2.0f * (q[2] * q[0] - q[1] * q[3]);
    m[2][1] = 2.0f * (q[1] * q[2] + q[0] * q[3]);
    m[2][2] = 1.0f - 2.0f * (q[1] * q[1] + q[0] * q[0]);
    m[2][3] = 0.0f;

    m[3][0] = 0.0f;
    m[3][1] = 0.0f;
    m[3][2] = 0.0f;
    m[3][3] = 1.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\font\stress\fontstrs.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <ptypes32.h>
#include <pwin32.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <math.h>

#include <GL/glaux.h>
#include "tk.h"

#include "sscommon.h"

static void Draw(void);
static void DrawAuto(void);
static void Init(void);
static void InitLighting(void);
static void Reshape(int, int);
static void SetModelView( void );
static GLenum Key(int key, GLenum mask);

static int GetStringExtent( char *string, POINTFLOAT *extent );
static void CalcStringMetrics( char *string );

static void InitFont();
static void KillFont();
VOID Arg( LPSTR );

// Global variables
HDC   hdc;
GLuint  dlFont, dpFont;
GLint firstGlyph = 32;

int numGlyphs=224;
GLint Width = 300, Height = 300;
POINTFLOAT strSize;
int strLen;
GLfloat xRot = 0.0f, yRot = 0.0f, zRot = 0.0f;
GLdouble zTrans = -1.5;
GLfloat extrusion = 0.5f;
GLenum doubleBuffer = GL_TRUE;
GLenum bLighting = GL_TRUE;
GLenum fontStyle = WGL_FONT_POLYGONS;
LPGLYPHMETRICSFLOAT lpgmf;

// output from tesselator always ccw
GLenum orientation = GL_CCW;

char *texFileName = 0;
GLint matIndex = 1;
BOOL bCullBack   = FALSE;
BOOL bTwoSidedLighting = FALSE;

BOOL    bInitTexture = TRUE;
BOOL    bTexture = FALSE;

char singleChar[] = "A";
char *drawString = singleChar;

int WINAPI
WinMain(    HINSTANCE   hInstance,
            HINSTANCE   hPrevInstance,
            LPSTR       lpCmdLine,
            int         nCmdShow
        )
{
    GLenum type;

    Arg( lpCmdLine );

    tkInitPosition( 0, 0, Width, Height );

    //type = TK_DEPTH16; // looks bad
    type = TK_DEPTH24;
    type |= TK_RGB;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;
    tkInitDisplayMode(type);

    if (tkInitWindow("Fontal assault") == GL_FALSE) {
	    tkQuit();
    }

    Init();

    tkExposeFunc( Reshape );
    tkReshapeFunc( Reshape );
    tkKeyDownFunc( Key );

    tkIdleFunc( DrawAuto );
    tkDisplayFunc(0);

    tkExec();
    return 1;
}


static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	    tkQuit();
    }
    return GL_TRUE;
}

static void InitLighting(void)
{
    static float ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};
    static float diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float position[] = {0.0f, 0.0f, 150.0f, 0.0f};

    static float back_mat_shininess[] = {50.0f};
    static float back_mat_specular[] = {0.5f, 0.5f, 0.2f, 1.0f};
    static float back_mat_diffuse[] = {1.0f, 0.0f, 0.0f, 1.0f};
    static float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float decal[] = {(GLfloat) GL_DECAL}; 
    static float modulate[] = {(GLfloat) GL_MODULATE};
    static float repeat[] = {(GLfloat) GL_REPEAT}; 
    static float nearest[] = {(GLfloat) GL_NEAREST};
    TK_RGBImageRec *image;

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);
    glFrontFace( orientation );

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    if( bLighting ) {
        glEnable(GL_LIGHTING);
        glEnable(GL_LIGHT0);
    }

    // override back material
    glMaterialfv( GL_BACK, GL_AMBIENT, ambient );
    glMaterialfv( GL_BACK, GL_DIFFUSE, back_mat_diffuse );
    glMaterialfv( GL_BACK, GL_SPECULAR, back_mat_specular );
    glMaterialfv( GL_BACK, GL_SHININESS, back_mat_shininess );

    if( bTwoSidedLighting ) {
        glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 1 );
    } else {
        glLightModeli( GL_LIGHT_MODEL_TWO_SIDE, 0 );
    }

    // set back face culling mode

    if( bCullBack ) {
        glCullFace( GL_BACK );
        glEnable( GL_CULL_FACE );
    } else {
        glDisable( GL_CULL_FACE );
    }

    // Initialize materials from screen saver common lib
    ss_InitMaterials();
    matIndex = JADE;
    ss_SetMaterialIndex( matIndex );

    // do texturing preparations

    if( bInitTexture ) {
        //glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
        glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, modulate);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
        glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
        if (texFileName) {
	        image = tkRGBImageLoad(texFileName);
	        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
	        gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
			              GL_RGB, GL_UNSIGNED_BYTE, image->data);
        }
        glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
        glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR );
        if( bTexture ) {
            glEnable( GL_TEXTURE_2D );
            glEnable(GL_TEXTURE_GEN_S);
            glEnable(GL_TEXTURE_GEN_T);
            ss_SetMaterialIndex( WHITE );
        }
    }
}

void Init(void)
{
    CHOOSEFONT cf;
    LOGFONT    lf;
    HFONT      hfont, hfontOld;
    HWND  hwnd;

    hdc = tkGetHDC();
    hwnd = tkGetHWND();

    // Create and select a font.

    memset(&lf, 0, sizeof(LOGFONT));
    lstrcpy(lf.lfFaceName, "Arial");
    lf.lfHeight = 50;

#define FS_CHOOSE_FONT 1
#ifdef FS_CHOOSE_FONT
    // Call ChooseFont dialog
//mf: ideally, should vary the font while test is running (EnumerateFonts)

    cf.lStructSize = sizeof(CHOOSEFONT);
    cf.hwndOwner = hwnd;
    cf.hDC = hdc;
    cf.lpLogFont = &lf;
    cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_TTONLY;


    ChooseFont(&cf);

    // !!! Bug ?  In some cases, like small sizes of Symbol font, the
    // lfOutPrecision value is set to OUT_STROKE_PRECIS, which won't work.
    // So if this happens, force the right value.

    if( lf.lfOutPrecision != OUT_TT_ONLY_PRECIS )
        lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;
#endif

    // lf reflects user's final choices

    hfont = CreateFontIndirect(&lf);

    hfontOld = SelectObject(hdc, hfont);

    /* Set the clear color */

    glClearColor( 0.0f, 0.0f, 0.0f, 1.0f );

    // Initialize lighting
    InitLighting();
}

static void Reshape( int width, int height )
{
    static GLdouble zNear = 0.1, zFar = 1000.0, fovy = 90.0;
    float aspect;

    /* Set up the projection matrix */

    Width = width;
    Height = height;
    aspect = Height == 0 ? 1.0f : Width/(float)Height;

    glViewport(0, 0, Width, Height );
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    zFar = 10.0f;
    gluPerspective(fovy, aspect, zNear, zFar );
    glMatrixMode(GL_MODELVIEW);

    SetModelView();
}

static void SetModelView( void )
{
    glLoadIdentity();
#if 1
    glTranslated( 0, 0, zTrans );
#else
    /* this has side effect of flipping around viewpoint when pass through
       origin
    */
    gluLookAt( 0, 0, -zTrans,
               0, 0, 0,
               0, 1, 0 );
#endif
}

static void InitFont()
{
    static GLfloat     chordal_deviation = 0.0f;

    // Generate a display list for font

    dlFont = glGenLists(numGlyphs);
    dpFont = glGenLists(numGlyphs);

    lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED, numGlyphs *
                                    sizeof(GLYPHMETRICSFLOAT) );
    if( (chordal_deviation += 0.001f) > .01f )
        chordal_deviation = 0.0f;

    if( (extrusion += 0.1f) > 1.0f )
        extrusion = 0.0f;

    wglUseFontOutlinesA(hdc, firstGlyph, numGlyphs, dpFont, 
                   chordal_deviation, extrusion, 
                   WGL_FONT_POLYGONS, lpgmf );

    CalcStringMetrics( drawString );
    LocalFree( lpgmf );
}

static void DrawAuto(void)
{
    POINT pt;

    InitFont();

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
    if( fontStyle == WGL_FONT_LINES )
        glListBase(dlFont-firstGlyph);
    else
        glListBase(dpFont-firstGlyph);

    glPushMatrix();

    glRotatef( yRot+= 5.0f, 0.0f, 1.0f, 0.0f );

    // now draw text, centered in window

    glTranslated( -strSize.x/2.0, -strSize.y/2.0, extrusion/2.0 );

    glCallLists(strLen, GL_UNSIGNED_BYTE, (GLubyte *) drawString);

    glPopMatrix();

    glFlush();
    if( doubleBuffer )
        tkSwapBuffers();

    KillFont();

    // increment character drawn
    if( singleChar[0] < (firstGlyph+numGlyphs-1) )
        singleChar[0] += 1;
    else
        singleChar[0] = (char) firstGlyph;
}

static void KillFont()
{

    // delete the display lists
    glDeleteLists( dlFont, numGlyphs );
    glDeleteLists( dpFont, numGlyphs );
}

static int GetStringExtent( char *string, POINTFLOAT *extent )
{
    int len, strLen;
    unsigned char *c;
    GLYPHMETRICSFLOAT *pgmf;

    extent->x = extent->y = 0.0f;
    len = strLen = lstrlenA( string );
    c = string;

    for( ; strLen; strLen--, c++ ) {
        if( *c < firstGlyph )
            continue;
        pgmf = &lpgmf[ *c - firstGlyph ];
        extent->x += pgmf->gmfCellIncX;
        if( pgmf->gmfBlackBoxY > extent->y )
            extent->y = pgmf->gmfBlackBoxY;
    }
    return len;
}

static void CalcStringMetrics( char *string )
{
    // get string size for window reshape
    strLen = GetStringExtent( string, &strSize );

    // set zTrans based on glyph extent
    zTrans = -5.0 * (strSize.x / 2.0f);
}

VOID Arg(LPSTR lpstr)
{
    while (*lpstr && *lpstr != '-') lpstr++;
    // only one arg for now (e.g.: -f 3.rgb)
    lpstr++;
    if( *lpstr++ == 'f' ) {
        texFileName = ++lpstr; 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\membrane\membrane.cxx ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <assert.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#include "mtk.hxx"
#include "objects.hxx"
#include "wave.hxx"

#define WIDTH 256
#define HEIGHT 256

float fViewDist = 10.0f;
float fTrans = 0.0f;
//#define FTRANSINC 0.05f
#define FTRANSINC 0.02f
float fTransInc = -FTRANSINC;

BOOL bDestAlpha;


#define TESS_MIN 5
#define TESS_MAX 100
//int tessLevel = TESS_MAX / 2; // corresponds to # of rings/sections in object
int tessLevel = 30; // corresponds to # of rings/sections in object
int tessInc = 5;

class DRAW_CONTROLLER {
public:
    DRAW_CONTROLLER::DRAW_CONTROLLER();
    DRAW_CONTROLLER::~DRAW_CONTROLLER() {};
    void        InitGL();
    void        ToggleLighting() {bLighting = !bLighting; SetLighting(); }
    void        SetLighting();
    void        SetDrawObject( OBJECT *pObj, int objectType );
    void        DrawObject(); 
    void        NextRotation();

//mf : this may move
    // Object rotation
    GLfloat fXr, fYr, fZr;
    GLfloat fDXr, fDYr, fDZr;

private:
    void        DrawVertexArray();

    BOOL        bLighting;
    OBJECT      *pObject;  // Draw object
    int         iObjectType;
};

class SCENE {
public:
    SCENE();
    ~SCENE();
    void        Draw();
    void        DrawMembrane();
    void        NewObject( int tessLevel );
    DRAW_CONTROLLER drawController;
private:
    void        DrawUsingAlphaBuffer();
    void        DrawNormally();
    // Scene rotation
    GLfloat fXr, fYr, fZr;
    GLfloat fDXr, fDYr, fDZr;
};

// Global objects
SCENE *scene;
SPHERE *sphere;
AVG_UPDATE_TIMER timer( 2.0f, 4 );

#define RGB_COLOR(red, green, blue) \
    (((DWORD)(BYTE)(red) << 0) | \
     ((DWORD)(BYTE)(green) << 8) | \
     ((DWORD)(BYTE)(blue) << 16))
    
#define RGBA_COLOR(red, green, blue, alpha) \
    (((DWORD)(BYTE)(red) << 0) | \
     ((DWORD)(BYTE)(green) << 8) | \
     ((DWORD)(BYTE)(blue) << 16) | \
     ((DWORD)(BYTE)(alpha) << 24))
    
#define FRANDOM(x) (((float)rand() / RAND_MAX) * (x))

#define DROT 10.0f

BOOL fSingleBuf = FALSE;

// forwards
static void SetGLState(); // volatile state


/****** DRAW_CONTROLLER *********************************************/

DRAW_CONTROLLER::DRAW_CONTROLLER( )
{
    bLighting = TRUE;

    // Init GL state
    InitGL();

    // Init object rotation and motion
    fXr = 0.0f;
    fYr = 0.0f;
    fZr = 0.0f;
    fDXr = DROT - FRANDOM(2 * DROT);
    fDYr = DROT - FRANDOM(2 * DROT);
    fDZr = DROT - FRANDOM(2 * DROT);
}

void
DRAW_CONTROLLER::SetDrawObject( OBJECT *pObj, int objectType )
{
    iObjectType = objectType;
    pObject = pObj;
}


void
DRAW_CONTROLLER::DrawObject()
{
    // Set object position, rotation, and draw it

    glPushMatrix();

#if 0
    glTranslatef( 0.0f, 0.0f, -0.8f );
#else
    glTranslatef( 0.0f, 0.0f, fTrans );
#endif

    glRotatef(fXr, 1.0f, 0.0f, 0.0f);
    glRotatef(fYr, 0.0f, 1.0f, 0.0f);
    glRotatef(fZr, 0.0f, 0.0f, 1.0f);

    DrawVertexArray();

    glPopMatrix();
}

void
DRAW_CONTROLLER::DrawVertexArray()
{
    glDrawElements(GL_TRIANGLES, 
                   pObject->TriangleCount()*3, 
                   GL_UNSIGNED_INT, 
                   pObject->TriangleData() );
}

void
DRAW_CONTROLLER::NextRotation()
{
    // increment object rotation
    fXr += fDXr;
    fYr += fDYr;
    fZr += fDZr;
}

void
DRAW_CONTROLLER::InitGL(void)
{
    float fv4[4];
    int iv1[1];
    int i;
    
    fv4[0] = 0.05f;
    fv4[1] = 0.05f;
    fv4[2] = 0.05f;
    fv4[3] = 1.0f;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, fv4);
    
    fv4[0] = 0.0f;
    fv4[1] = 1.0f;
    fv4[2] = 1.0f;
    fv4[3] = 0.0f;
    glLightfv(GL_LIGHT0, GL_POSITION, fv4);
    fv4[0] = 0.9f;
    fv4[1] = 0.9f;
    fv4[2] = 0.9f;
    fv4[3] = 1.0f;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, fv4);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    
    fv4[0] = 0.6f;
    fv4[1] = 0.6f;
    fv4[2] = 0.6f;
    fv4[3] = 1.0f;
    glMaterialfv(GL_FRONT, GL_SPECULAR, fv4);
    iv1[0] = 40;
    glMaterialiv(GL_FRONT, GL_SHININESS, iv1);
    
    glEnable(GL_CULL_FACE);

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
    glEnable(GL_COLOR_MATERIAL);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, .01, 15);
    gluLookAt(0, 0, fViewDist, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

    SetLighting();
}

void
DRAW_CONTROLLER::SetLighting(void)
{
    if( bLighting ) {
        glEnable( GL_LIGHTING );
    } else {
        glDisable( GL_LIGHTING );
    }
}


/****** SCENE *******************************************************/


SCENE::SCENE()
{
    srand(time(NULL));

    // Create sphere draw object for the scene
    NewObject( tessLevel );
}

void
SCENE::NewObject( int tessLevel )
{
    // Only one object allowed for now - delete any previous object
    if( sphere )
        delete sphere;

    // Create new sphere for the scene
    float fAlpha = 0.5f;
    sphere = new SPHERE( tessLevel, tessLevel, fAlpha );
    assert( sphere != NULL );

    // Inform DRAW_CONTROLLER about new object
    drawController.SetDrawObject( sphere, OBJECT_TYPE_SPHERE );

    // Initialize array pointer data
    SetGLState();

    VERTEX *pVertData = sphere->VertexData();
    glVertexPointer(3, GL_FLOAT, sizeof(VERTEX), &pVertData->fX);
    glNormalPointer(GL_FLOAT, sizeof(VERTEX), &pVertData->fNx);
    // Color pointer data is dependent on state...
    SetGLState();

    // Init scene rotation and motion
    fXr = 0.0f;
    fYr = 0.0f;
    fZr = 0.0f;
    fDXr = DROT - FRANDOM(2 * DROT);
    fDYr = DROT - FRANDOM(2 * DROT);
    fDZr = DROT - FRANDOM(2 * DROT);
}

SCENE::~SCENE()
{
    // Delete any scene objects
    if( sphere )
        delete sphere;
}

/******************************Public*Routine******************************\
* Draw
*
* Draw the scene using src or dst alpha blending.
*
\**************************************************************************/

void
SCENE::Draw()
{
    if( bDestAlpha )
        DrawUsingAlphaBuffer();
    else
        DrawNormally();

    // Inrement object rotation
    drawController.NextRotation();

    if( fTrans < -1.2f ) {
        fTransInc = FTRANSINC;
    } else if( fTrans > 0.5f ) {
        fTransInc = -FTRANSINC;
    }

    fTrans += fTransInc;
}

/**************************************************************************\
* DrawUsingAlphaBuffer
*
* The destination alpha buffer is used to optimize drawing.  The optimization
* is based on the fact that the objects cover a small area compared to the
* entire window.  Blending, which is slow, only occurs over the area occupied
* by the object.  Without the alpha buffer, blending must occur over the entire
* window.
\**************************************************************************/

void
SCENE::DrawUsingAlphaBuffer()
{
    glClear( GL_DEPTH_BUFFER_BIT );

    glLoadIdentity();

    glEnable( GL_DEPTH_TEST );
    glDepthFunc( GL_ALWAYS );

    DrawMembrane();

    // Draw object's alpha values only on first pass

    glDepthFunc( GL_LEQUAL );

//#define TURN_OFF_LIGHTING 1
#if TURN_OFF_LIGHTING
//mf: this makes it slower.. not sure why
    glDisable( GL_LIGHTING );
#endif

    glColorMask( GL_FALSE, GL_FALSE, GL_FALSE, GL_TRUE );

    drawController.DrawObject();

    glColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );

#if TURN_OFF_LIGHTING
    glEnable( GL_LIGHTING );
#endif

    // set up dst alpha blending for next pass
    glBlendFunc( GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA );
    glEnable( GL_BLEND );
    glDisable( GL_DEPTH_TEST );

    // Draw object normally on second pass

    drawController.DrawObject();

    glDisable( GL_BLEND );
}

/**************************************************************************\
* DrawNormally
*
* The scene is drawn without using destination alpha buffer.  The objects are
* drawn first, then the membrane is blended in afterwards.
\**************************************************************************/

void
SCENE::DrawNormally()
{
    glClear( GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT );

    glLoadIdentity();

    drawController.DrawObject();

    // Blend the membrane with the objects already drawn
    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
    glEnable( GL_BLEND );
    DrawMembrane();
    glDisable( GL_BLEND );
}

void
SCENE::DrawMembrane()
{
    float fSize = fViewDist;

    glDisable( GL_LIGHTING );

    glColor4f( 0.0f, 0.5f, 0.9f, 0.5f );

    glBegin( GL_QUADS );
        glVertex3f(  fSize,  fSize, 0.0f );
        glVertex3f( -fSize,  fSize, 0.0f );
        glVertex3f( -fSize, -fSize, 0.0f );
        glVertex3f(  fSize, -fSize, 0.0f );
    glEnd();

    // Reinstate the current lighting model
    drawController.SetLighting();
}

/********************************************************************/

void Reset()
{
    // Called when display changes

    // Remove any timing info from title bar, and reset the timer
    SetWindowText(auxGetHWND(), "" );
    timer.Reset();
    timer.Start();
}

void NewTessLevel( int tessLevel )
{
    static int oldTessLevel = 0; // to avoid unnecessary work

    // retesselate scene's object
    if( tessLevel == oldTessLevel )
        return;
    scene->NewObject( tessLevel );

    Reset();

    oldTessLevel = tessLevel;
}

void Draw(void)
{
    DRAW_CONTROLLER *pDrawControl = &scene->drawController;
    float updatesPerSecond;
    
    // Draw the scene

    scene->Draw();

    if (fSingleBuf)
        glFlush();
    else
        auxSwapBuffers();
    
    // Print timing information if Stop returns TRUE

    if( timer.Update( 1, &updatesPerSecond ) ) {
        char szMsg[80];
        sprintf(szMsg, "%s: %.2lf frames/sec",
                "",
                updatesPerSecond );

        // Print timing info in title bar
        SetWindowText(auxGetHWND(), szMsg);
    }
}

static void
SetGLState()
{
    VERTEX *pVertData = sphere->VertexData();

    // Set vertex array pointers

    glVertexPointer(3, GL_FLOAT, sizeof(VERTEX), &pVertData->fX);
    glNormalPointer(GL_FLOAT, sizeof(VERTEX), &pVertData->fNx);
    // If using destination alpha blending, the object is drawn with alpha=1.0,
    // so specify 3-valued rgb colors (a defaults to 1.0).  Otherwise,
    // the object is drawn using 4-valued rgba colors
    int colorDataSize = bDestAlpha ? 3 : 4;
    glColorPointer( colorDataSize, GL_UNSIGNED_BYTE, sizeof(VERTEX), 
                    &pVertData->dwColor);

    // Set other GL state

    if( bDestAlpha ) {
        glColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE );
    } else {
        glColorMask( GL_TRUE, GL_TRUE, GL_TRUE, GL_FALSE );
        glClearColor( 0.0f, 0.5f, 0.9f, 0.0f );
        glEnable( GL_DEPTH_TEST );
        glDepthFunc( GL_LEQUAL );
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    Reset();
}

void Keya(void)
{
    bDestAlpha = !bDestAlpha;
    SetGLState();
    Reset();
}

void Keyd(void)
{
}

void Keyl(void)
{
    scene->drawController.ToggleLighting();
    Reset();
}

void KeySPACE(void)
{
}
    
void KeyUp(void)
{
    // increase tesselation
    tessLevel += tessInc;
    if( tessLevel > TESS_MAX )
        tessLevel = TESS_MAX;
    NewTessLevel( tessLevel );
}

void KeyDown(void)
{
    // decrease tesselation
    tessLevel -= tessInc;
    if( tessLevel < TESS_MIN )
        tessLevel = TESS_MIN;
    NewTessLevel( tessLevel );
}

void __cdecl main(int argc, char **argv)
{
    GLenum eMode;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
            fSingleBuf = TRUE;
    }
    
    auxInitPosition(10, 10, WIDTH, HEIGHT);
//    eMode = AUX_RGB | AUX_DEPTH16 | AUX_ALPHA;
//mf: ??!! had to choose 32-bitz - don't know why, z-planes seem tight enough
    eMode = AUX_RGB | AUX_DEPTH24 | AUX_ALPHA;
    if (!fSingleBuf)
    {
        eMode |= AUX_DOUBLE;
    }

    auxInitDisplayMode(eMode);
    auxInitWindow("Insane in the Membrane");

    auxReshapeFunc(Reshape);
    auxIdleFunc(Draw);

    auxKeyFunc(AUX_a, Keya);
    auxKeyFunc(AUX_l, Keyl);
    auxKeyFunc(AUX_d, Keyd);
    auxKeyFunc(AUX_SPACE, KeySPACE);
    auxKeyFunc(AUX_UP, KeyUp);
    auxKeyFunc(AUX_DOWN, KeyDown);

    bDestAlpha = TRUE;

    // Create scene, with object(s)
    scene = new SCENE;

    // Start drawing
    timer.Start();
    auxMainLoop(Draw);

    // Party's over
    delete scene;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\membrane\objects.cxx ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <assert.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#include "mtk.hxx"
#include "objects.hxx"

#define RGB_COLOR(red, green, blue) \
    (((DWORD)(BYTE)(red) << 0) | \
     ((DWORD)(BYTE)(green) << 8) | \
     ((DWORD)(BYTE)(blue) << 16))
    
#define RGBA_COLOR(red, green, blue, alpha) \
    (((DWORD)(BYTE)(red) << 0) | \
     ((DWORD)(BYTE)(green) << 8) | \
     ((DWORD)(BYTE)(blue) << 16) | \
     ((DWORD)(BYTE)(alpha) << 24))
    
#define FRANDOM(x) (((float)rand() / RAND_MAX) * (x))


/****** OBJECT *******************************************************/


OBJECT::OBJECT( int rings, int sections )
: nRings( rings ), nSections( sections )
{
    pTriData = NULL;
    pVertData = NULL;
    alphaVal = 255;
}

OBJECT::~OBJECT()
{
    // These ptrs alloc'd in inheriting classes...
    if( pVertData )
        free( pVertData );
    if( pTriData )
        free( pTriData );
}

/****** SPHERE *******************************************************/

SPHERE::SPHERE( 
    int rings, int sections, float fOpacity )
    : OBJECT( rings, sections )
{
    iType = OBJECT_TYPE_SPHERE;
    
    alphaVal = (int) (fOpacity * 255.0f);
    SS_CLAMP_TO_RANGE2( alphaVal, 0, 255 );

    nVerts = CalcNVertices();
    nTris = CalcNTriangles();

    // Allocate memory for the sphere data (freed by the base OBJECT class)

    // Vertex data
    pVertData = (VERTEX *) malloc( nVerts * sizeof(VERTEX) );
    assert( pVertData != NULL );

    // Triangle indices
    pTriData = (TRIANGLE *) malloc( nTris * sizeof(TRIANGLE) );
    assert( pTriData != NULL );

    GenerateData(1.0f);
}

int
SPHERE::CalcNVertices()
{
    return (((nRings)+1)*(nSections)+2);
}

int
SPHERE::CalcNTriangles()
{
    return (((nRings)+1)*(nSections)*2);
}


void 
SPHERE::GenerateData( float fRadius )
{
    float fTheta, fPhi;             /* Angles used to sweep around sphere */
    float fDTheta, fDPhi;           /* Angle between each section and ring */
    float fX, fY, fZ, fV, fRSinTheta;  /* Temporary variables */
    int   i, j, n, m;               /* counters */
    VERTEX *pvtx = pVertData;
    TRIANGLE *ptri = pTriData;
//mf: ! give these different alpha values !
    DWORD color0 = RGBA_COLOR( 255, 0, 0, alphaVal );
    DWORD color1 = RGBA_COLOR( 255, 255, 0, alphaVal ); // yellow

    /*
     * Generate vertices at the top and bottom points.
     */
    pvtx[0].fX = 0.0f;
    pvtx[0].fY = fRadius;
    pvtx[0].fZ = 0.0f;
    pvtx[0].fNx = 0.0f;
    pvtx[0].fNy = 1.0f;
    pvtx[0].fNz = 0.0f;
    pvtx[0].dwColor = color0;
    pvtx[nVerts - 1].fX = 0.0f;
    pvtx[nVerts - 1].fY = -fRadius;
    pvtx[nVerts - 1].fZ = 0.0f;
    pvtx[nVerts - 1].fNx = 0.0f;
    pvtx[nVerts - 1].fNy = -1.0f;
    pvtx[nVerts - 1].fNz = 0.0f;
    pvtx[nVerts - 1].dwColor = color1;

    /*
     * Generate vertex points for rings
     */
    fDTheta = PI / (float) (nRings + 2);
    fDPhi = 2.0f * PI / (float) nSections;
    n = 1; /* vertex being generated, begins at 1 to skip top point */
    fTheta = fDTheta;

    for (i = 0; i <= nRings; i++)
    {
        fY = (float)(fRadius * cos(fTheta)); /* y is the same for each ring */
        fV = fTheta / PI; /* v is the same for each ring */
        fRSinTheta = (float)(fRadius * sin(fTheta));
        fPhi = 0.0f;
	
        for (j = 0; j < nSections; j++)
        {
            fX = (float)(fRSinTheta * sin(fPhi));
            fZ = (float)(fRSinTheta * cos(fPhi));
            pvtx[n].fX = fX;
            pvtx[n].fZ = fZ;
            pvtx[n].fY = fY;
            pvtx[n].fNx = fX / fRadius;
            pvtx[n].fNy = fY / fRadius;
            pvtx[n].fNz = fZ / fRadius;
            if (n & 1)
            {
                pvtx[n].dwColor = color0;
            }
            else
            {
                pvtx[n].dwColor = color1;
            }
            fPhi += fDPhi;
            n++;
        }
	
        fTheta += fDTheta;
    }

    /*
     * Generate triangles for top and bottom caps.
     */
    for (i = 0; i < nSections; i++)
    {
        ptri[i].iV1 = 0;
        ptri[i].iV2 = i + 1;
        ptri[i].iV3 = 1 + ((i + 1) % nSections);
        ptri[nTris - nSections + i].iV1 = nVerts - 1;
        ptri[nTris - nSections + i].iV2 = nVerts - 2 - i;
        ptri[nTris - nSections + i].iV3 = nVerts - 2 - ((1 + i) % nSections);
    }

    /*
     * Generate triangles for the rings
     */
    m = 1; /* first vertex in current ring, begins at 1 to skip top point*/
    n = nSections; /* triangle being generated, skip the top cap */
	
    for (i = 0; i < nRings; i++)
    {
        for (j = 0; j < nSections; j++)
        {
            ptri[n].iV1 = m + j;
            ptri[n].iV2 = m + nSections + j;
            ptri[n].iV3 = m + nSections + ((j + 1) % nSections);
            ptri[n + 1].iV1 = ptri[n].iV1;
            ptri[n + 1].iV2 = ptri[n].iV3;
            ptri[n + 1].iV3 = m + ((j + 1) % nSections);
            n += 2;
        }
	
        m += nSections;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\membrane\wave.cxx ===
/*
 * (c) copyright 1993, silicon graphics, inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

#include "wave.hxx"


#define PI 3.14159265358979323846f

#define GETWCOORD(frame, x, y) (&(mesh.coords[frame*mesh.numCoords+(x)+(y)*(iWidthX+1)]))
#define GETFACET(frame, x, y) (&(mesh.facets[frame*mesh.numFacets+(x)+(y)*iWidthX]))

#ifndef cosf
#define cosf( x ) \
    ( (float) cos( (x) ) )
#define sinf( x ) \
    ( (float) sin( (x) ) )
#endif

#ifndef sqrtf
#define sqrtf( x ) \
    ( (float) sqrt( (x) ) )
#endif

/******************** WAVE *************************************************
* 
* Creates a moving wave in the x-y plane, with varying height along the z-axis.
*
* The x,y ranges are confined to (-.5, .5).  Height can be any positive number.
* A number of frames are generated, which are drawn sequentially on Draw calls.
* It can run in either smooth or flat shaded modes.  In smooth mode, the
* materials are generated with glMaterialColor.

* Two of the opposite corners of the wave are pinned down, while the wave moves
* diagonally between the other corners.
*
* It looks like there is only one period of the wave visible at any one time,
* and no way to adjust this. (mf: we need more periods)
*
* In the standard GL reference axis scheme, the normals for wave all have
* normals pointing in the -z direction.  Looking at wave from that direction,
* the quad orientation is CW.  So need to rotate by 180 around y if viewing
* down the -z axis.  Alternatively, could construct the wave differently
***************************************************************************/

WAVE::WAVE()
{
    nFrames = 10;
    iWidthX = 10;
    iWidthY = 10;
    iCheckerSize = 2;
    fHeight = 0.2f;

    iCurFrame = 0;

    InitMaterials();
    InitMesh();
}

WAVE::~WAVE()
{
    if( mesh.coords )
        free( mesh.coords );
    if( mesh.facets )
        free( mesh.facets );
}

void
WAVE::Draw()
{
//mf: could be a candidate for vertex array ??
    WCOORD *coord;
    FACET *facet;
    float *lastColor;
    float *thisColor;
    GLint i, j;

    // Set any state required (caller will have to 'push' this state), or ? 
    // should do it here ?
//mf: need to set front face, etc.  Caller can probably do this, since it's
// going to need to know how the wave is constructed anyways.

    if (bSmooth) {
        glShadeModel(GL_SMOOTH);
    } else {
        glShadeModel(GL_FLAT);
    }
    glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
    glEnable(GL_COLOR_MATERIAL);
    
    iCurFrame++;

    // Draw the wave frame

    if (iCurFrame >= nFrames) {
        iCurFrame = 0;
    }

    for (i = 0; i < iWidthX; i++) {
	glBegin(GL_QUAD_STRIP);
	lastColor = NULL;
	for (j = 0; j < iWidthY; j++) {
	    facet = GETFACET(iCurFrame, i, j);
	    if (!bSmooth && bLighting) {
        	glNormal3fv(facet->normal);
	    }
	    if (bLighting) {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
	    } else {
		    thisColor = facet->color;
		    glColor3fv(facet->color);
	    }

	    if (!lastColor || (thisColor[0] != lastColor[0] && bSmooth)) {
		if (lastColor) {
		    glEnd();
		    glBegin(GL_QUAD_STRIP);
		}
		coord = GETWCOORD(iCurFrame, i, j);
		if (bSmooth && bLighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);

		coord = GETWCOORD(iCurFrame, i+1, j);
		if (bSmooth && bLighting) {
		    glNormal3fv(coord->normal);
		}
		glVertex3fv(coord->vertex);
	    }

	    coord = GETWCOORD(iCurFrame, i, j+1);
	    if (bSmooth && bLighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    coord = GETWCOORD(iCurFrame, i+1, j+1);
	    if (bSmooth && bLighting) {
		glNormal3fv(coord->normal);
	    }
	    glVertex3fv(coord->vertex);

	    lastColor = thisColor;
	}
	glEnd();
    }
}

void 
WAVE::InitMesh()
{
    WCOORD *coord;
    FACET *facet;
    float dp1[3], dp2[3];
    float *pt1, *pt2, *pt3;
    float angle, d, x, y;
    GLint numFacets, numCoords, frameNum, i, j;

    numFacets = iWidthX * iWidthY;
    numCoords = (iWidthX + 1) * (iWidthY + 1);

    mesh.numCoords = numCoords;
    mesh.numFacets = numFacets;

    mesh.coords = (WCOORD *)malloc(nFrames*numCoords*
					    sizeof(WCOORD));
    mesh.facets = (FACET *)malloc(nFrames*numFacets*
					    sizeof(FACET));

    assert( mesh.coords != NULL || mesh.facets != NULL);

    for (frameNum = 0; frameNum < nFrames; frameNum++) {
	for (i = 0; i <= iWidthX; i++) {
	    x = i / (float)iWidthX;
	    for (j = 0; j <= iWidthY; j++) {
		y = j / (float)iWidthY;

		d = (float) sqrtf(x*x+y*y);
		if (d == 0.0f) {
		    d = 0.0001f;
		}
		angle = 2 * PI * d + (2 * PI / nFrames * frameNum);

		coord = GETWCOORD(frameNum, i, j);

		coord->vertex[0] = x - 0.5f;
		coord->vertex[1] = y - 0.5f;
		coord->vertex[2] = (fHeight - fHeight * d) * cosf(angle);

		coord->normal[0] = -(fHeight / d) * x * ((1 - d) * 2 * PI *
				   sinf(angle) + cosf(angle));
		coord->normal[1] = -(fHeight / d) * y * ((1 - d) * 2 * PI *
				   sinf(angle) + cosf(angle));
		coord->normal[2] = -1.0f;

		d = 1.0f / sqrtf(coord->normal[0]*coord->normal[0]+
			       coord->normal[1]*coord->normal[1]+1);
		coord->normal[0] *= d;
		coord->normal[1] *= d;
		coord->normal[2] *= d;
	    }
	}
	for (i = 0; i < iWidthX; i++) {
	    for (j = 0; j < iWidthY; j++) {
		facet = GETFACET(frameNum, i, j);
		if (((i/iCheckerSize)%2)^(j/iCheckerSize)%2) {
			facet->color[0] = 1.0f;
			facet->color[1] = 0.2f;
			facet->color[2] = 0.2f;
		} else {
			facet->color[0] = 0.2f;
			facet->color[1] = 1.0f;
			facet->color[2] = 0.2f;
		}
		pt1 = GETWCOORD(frameNum, i, j)->vertex;
		pt2 = GETWCOORD(frameNum, i, j+1)->vertex;
		pt3 = GETWCOORD(frameNum, i+1, j+1)->vertex;

		dp1[0] = pt2[0] - pt1[0];
		dp1[1] = pt2[1] - pt1[1];
		dp1[2] = pt2[2] - pt1[2];

		dp2[0] = pt3[0] - pt2[0];
		dp2[1] = pt3[1] - pt2[1];
		dp2[2] = pt3[2] - pt2[2];

		facet->normal[0] = dp1[1] * dp2[2] - dp1[2] * dp2[1];
		facet->normal[1] = dp1[2] * dp2[0] - dp1[0] * dp2[2];
		facet->normal[2] = dp1[0] * dp2[1] - dp1[1] * dp2[0];

		d = 1.0f / sqrtf(facet->normal[0]*facet->normal[0]+
			       facet->normal[1]*facet->normal[1]+
			       facet->normal[2]*facet->normal[2]);

		facet->normal[0] *= d;
		facet->normal[1] *= d;
		facet->normal[2] *= d;
	    }
	}
    }
}

#if 0
	if (bLighting) {
	    glEnable(GL_LIGHTING);
	    glEnable(GL_LIGHT0);
		glEnable(GL_COLOR_MATERIAL);
	} else {
	    glDisable(GL_LIGHTING);
	    glDisable(GL_LIGHT0);
		glDisable(GL_COLOR_MATERIAL);
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\context.cxx ===
/******************************Module*Header*******************************\
* Module Name: loginit.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "uidemo.hxx"
#include "context.hxx"

static MTKWIN *mtkWin;

/******************** MAIN       SEQUENCE *********************************\
*
\**************************************************************************/

#if 0
static MTKWIN *CreateMainWindow()
{
    MTKWIN *win;

    // Set window size and position

    bResSwitch = FALSE;

    UINT winConfig = 0;

//mf: !!! mtk takes FULLSCREEN as meaning it can take over palette, so need
// palette flags for Config().  Oh, and think it also means ON_TOP, so need
// another flag for that.

    winConfig |= MTK_FULLSCREEN | MTK_NOBORDER;

    win = new MTKWIN();
    if( !win )
        return NULL;

    // Configure and create the window (mf: this 2 step process of constructor
    // and create will allow creating 'NULL' windows

    // Create the window
    if( ! win->Create( "Demo", &winSize, &winPos, winConfig, NULL ) ) {
        delete win;
        return NULL;
    }

    win->SetReshapeFunc(Reshape);

    return win;
}
#endif

BOOL RunContextMenuSequence( ENV *pEnv )
{
    SS_DBGPRINT( "RunContextMenuSequence()\n" );

    // Create a window to run the menus in.  This is so during testing, I can
    // click anywhere on the screen and do context there.  But not sure if can
    // do this yet, so just hardcode position for now.

#if 0

    //mf: using this and other externs from logon.cxx...
    mtkWin = CreateLogonWindow();

    if( !mtkWin )
        return FALSE; 
#endif

    IPOINT2D pos = { 50, 50 };
//    ISIZE size = { 100, 200 };
    ISIZE size = { 200, 400 };
    Draw3DContextMenu( &pos, &size, "menu.bmp" );

    return TRUE; // mf: change to point to the selected user...
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\pgonoffs\glos.h ===
// GLOS.H
//
// This is an OS specific header file

#include <windows.h>

// disable data conversion warnings

#pragma warning(disable : 4305)     // MIPS
#pragma warning(disable : 4244)     // MIPS
#pragma warning(disable : 4136)     // X86
#pragma warning(disable : 4309)     // X86
#pragma warning(disable : 4051)     // ALPHA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\ctxmenu.cxx ===
/******************************Module*Header*******************************\
* Module Name: ctxmenu.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>

#include "uidemo.hxx"
#include "util.hxx"
#include "context.hxx"

static MTKWIN *mtkMenuWin; 
static TEXTURE *pMenuTex;
static ISIZE winSize; // main window cached size and position
static IPOINT2D winPos;
static GLIRECT glRect;

static float bgColor[4] = {0.0f, 0.3f, 0.9f, 0.0f};

static BOOL bLighting, bDepth;
static VIEW view;

// Forwards
static void CleanUp();
static MTKWIN *CreateMenuWindow();

/**************************************************************************\
*
\**************************************************************************/


static void Clear()
{
#if 1
    int clearMask = GL_COLOR_BUFFER_BIT;
#else
    int clearMask = 0;
#endif
    if( bDepth )
        clearMask |= GL_DEPTH_BUFFER_BIT;

    glClear( clearMask );
}

static void DrawMenu()
{
    static FSIZE fSize = { 1.0f, 2.0f }; 
    // Draw next iteration of menu

    Clear();
//mf: while testin'
    AddSwapHintRect( &glRect );
    DrawRect( &fSize );
    mtkMenuWin->Flush();
}
static void
CalcWindowSquareRect( float radius, GLIRECT *pRect )
{
    float       ctr[3] = {0.0f, 0.0f, 0.0f};
    POINT3D     blObj, trObj, blWin, trWin;
    float       fCurSize = radius;

    blObj.x = ctr[0] - fCurSize;
    blObj.y = ctr[1] - fCurSize;
    blObj.z = ctr[2];
    TransformObjectToWindow( &blObj, &blWin, 1 );

    trObj.x = ctr[0] + fCurSize;
    trObj.y = ctr[1] + fCurSize;
    trObj.z = ctr[2];
    TransformObjectToWindow( &trObj, &trWin, 1 );

//mf: this bloats the rect for the line case...
    CalcRect( &blWin, &trWin, pRect );
// mf: so I'll reduce it :
    pRect->x ++;
    pRect->y ++;
    pRect->width -= 2;
    pRect->height -= 2;
//mf: When compare pixels drawn with what clear draws, the squares aren't
// exact - clear 0 or 1 pixels bigger around each edge.  Or maybe swap rect
// problem, who knows...
}

static void 
SetView( ISIZE *pWinSize )
{
    glViewport(0, 0, pWinSize->width, pWinSize->height);

    view.fViewDist = 10.0f; // viewing distance
    view.fovy = 45.0f;     // field of view in y direction (degrees)
    view.fAspect = (float) pWinSize->width / (float) pWinSize->height;

    // We'll assume width >= height

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(view.fovy, view.fAspect, 0.1, 100.0);
//    glOrtho( -5.0, 5.0, -5.0, 5.0, 0.0, 100.0 ); no look as good
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0,0,view.fViewDist, 0,0,0, 0,1,0); // from, to, up...
}

static void Reshape(int width, int height)
{
// Need to update main window info
    ISIZE *pSize = &winSize;

    pSize->width = width;
    pSize->height = height;

    if( !width || !height )
        return;
    SetView( pSize );

//mf: test
    UpdateLocalTransforms( UPDATE_ALL );
    CalcWindowSquareRect( QUAD_SIZE, &glRect );
    GLIRECT *pRect = &glRect;
    glScissor( pRect->x, pRect->y, pRect->width, pRect->height );

    Clear();
}

static BOOL EscKey(int key, GLenum mask)
{
    if( key == TK_ESCAPE ) {
        mtkMenuWin->Return();
    }
    return FALSE;
}

/******************** MAIN LOGON SEQUENCE *********************************\
*
\**************************************************************************/

static MTKWIN *CreateMenuWindow()
{
    MTKWIN *win;

    // Set window size and position

    UINT winConfig = 0;

#if 0
    winConfig |= MTK_NOBORDER | MTK_TRANSPARENT;
#else
//mf: for testin'
//    winConfig |= MTK_TRANSPARENT;
//mf: when specify just TRANSPARENT here, resizing screws everything up - draws
// all over the place, even over borders,etc...
#endif

    win = new MTKWIN();
    if( !win )
        return NULL;

    // Create the window

//    if( ! win->Create( "Demo", &winSize, &winPos, winConfig, menuWndProc ) ) {
    if( ! win->Create( "Demo", &winSize, &winPos, winConfig, NULL) ) {
        delete win;
        return NULL;
    }

    // Configure the window for OpenGL, setting ReshapeFunc to catch the
    // resize (can't set it before in this case, since we do various gl
    // calculations in the Reshape func.

    UINT glConfig = MTK_RGB | MTK_DOUBLE | MTK_DEPTH16;

    win->SetReshapeFunc(Reshape);
    if( ! win->Config( glConfig ) ) 
    {
        delete win;
        return NULL;
    }

    return win;
}

static void InitGL(void)
{
    static float lmodel_ambient[] = {0.2f, 0.2f, 0.2f, 0.0f};
    static float lmodel_twoside[] = {(float)GL_TRUE};
    static float lmodel_local[] = {(float)GL_FALSE};
    static float light0_ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};
    static float light0_diffuse[] = {1.0f, 1.0f, 1.0f, 0.0f};
#if 1
//    static float light0_position[] = {-1.0f, 1.0f,  1.0f, 0.0f};
    static float light0_position[] = {-1.0f, 0.8f,  4.0f, 0.0f};
#else
    static float light0_position[] = {-1.0f, 1.0f,  1.0f, 0.0f};
#endif
    static float light0_specular[] = {1.0f, 1.0f, 1.0f, 0.0f};

    static float bevel_mat_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};
    static float bevel_mat_shininess[] = {40.0f};
    static float bevel_mat_specular[] = {1.0f, 1.0f, 1.0f, 0.0f};
    static float bevel_mat_diffuse[] = {1.0f, 1.0f, 1.0f, 0.0f};

    // Set GL attributes

//    glEnable( GL_SCISSOR_TEST );

//    glClearDepth(1.0f);

	glClearColor( bgColor[0], bgColor[1], bgColor[2], bgColor[3] );
	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
	glEnable(GL_LIGHT0);

	glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_local);
	glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
	glEnable(GL_LIGHTING);

	glMaterialfv(GL_FRONT, GL_AMBIENT, bevel_mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, bevel_mat_shininess);
	glMaterialfv(GL_FRONT, GL_SPECULAR, bevel_mat_specular);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, bevel_mat_diffuse);

	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);

	glEnable(GL_COLOR_MATERIAL);

    glEnable( GL_TEXTURE_2D );

    // Setup viewing parameters

    SetView( &winSize );

    // Rendering attributes

#if 1
    bDepth = TRUE;
    glDepthFunc( GL_LEQUAL );
    glEnable( GL_DEPTH_TEST );
#endif

    bLighting = TRUE;
    glEnable( GL_LIGHTING );

	glShadeModel(GL_FLAT);
}

static TEXTURE *LoadTexture( LPTSTR bmpFile )
{
    TEXTURE *pTex;

    pTex = new TEXTURE( (char *) bmpFile );

    return pTex;
}

/******************** RunLogonSequence ************************************\
*
\**************************************************************************/

BOOL Draw3DContextMenu( IPOINT2D *pPos, ISIZE *pSize, LPTSTR bmpFile )
{
    // Update local copies of window position and size
    winPos = *pPos;
    winSize = *pSize;

    // Create context menu window

    mtkMenuWin = CreateMenuWindow();

    if( !mtkMenuWin )
        return FALSE; 

    // Do any GL init for the window

    InitGL();

    pMenuTex = LoadTexture( bmpFile );
    if( !pMenuTex ) {
        delete mtkMenuWin;
        return FALSE;
    }
    pMenuTex->MakeCurrent();

//mf: temp
    UpdateLocalTransforms( UPDATE_ALL );
    CalcWindowSquareRect( QUAD_SIZE, &glRect );
    glEnable( GL_SCISSOR_TEST );
    GLIRECT *pRect = &glRect;
    glScissor( pRect->x, pRect->y, pRect->width, pRect->height );

    // Set mtk callbacks

    mtkMenuWin->SetKeyDownFunc( EscKey );
    mtkMenuWin->SetDisplayFunc( DrawMenu );
    mtkMenuWin->SetAnimateFunc( DrawMenu );

    // Start the message loop
    mtkMenuWin->Exec();

    CleanUp();
    return TRUE;
}

static void CleanUp()
{
#if 0
//mf: this won't work yet
    if( mtkMenuWin )
        delete mtkMenuWin;
#else
    mtkMenuWin->Close(); // this will call destructor for mtkWin
#endif
}

//mf: this can be called during debug mode, to terminate prematurely
static void Quit()
{
    CleanUp();
    ExitProcess( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\logend.cxx ===
/******************************Module*Header*******************************\
* Module Name: logend.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "logon.hxx"

static LOG_OBJECT *pHotObj;
//#define FADING_CLEAR 1
#define REDUCE_SIZE 1

/******************** NEXT SEQUENCE ***************************************\
*
\**************************************************************************/

static void ResetObjects()
{
    ClearAll();

    // Move all objects to rest position
#ifdef REDUCE_SIZE
    FSIZE imageSize;
    imageSize.width = imageSize.height = OBJECT_WIDTH / 2.0f;
    pHotObj->SetImageSize( &imageSize );
#endif
    pHotObj->ResetMotion();
    SetObjectRestPositions();
    CalcObjectWindowRects();

#ifdef FADING_CLEAR
    // Set clear color back to bg
    glClearColor( bgColor.r, bgColor.g, bgColor.b, bgColor.a );
    ClearAll();
#endif
    Flush();
}

static BOOL
LastKey(int key, GLenum mask)
{
    switch( key ) {
        case TK_ESCAPE :
            mtkWin->Return();
            break;
        case TK_SPACE :
            if( bDebugMode ) {
                // Have to restore objects to centered state...
                ResetObjects();
                bRunAgain = TRUE;
                mtkWin->Return();
            }
            break;
        default :
            if( bDebugMode )
                return AttributeKey( key, mask );
    }
    return GL_FALSE;
}


static BOOL RunHoldSequence()
{
    mtkWin->SetAnimateFunc( NULL );
    mtkWin->SetDisplayFunc( NULL );
    mtkWin->SetKeyDownFunc( LastKey );
    return mtkWin->Exec();
}


/******************** END FLY SEQUENCE ************************************\
*
* The 3 unselected objects move away, while selected one stays where it is.
* Partway throught the move away, the selected one starts moving towards the
* lower right corner, shrinking in size.
*
\**************************************************************************/

static int  iStartHotMotion, iDrawCounter;
static BOOL bHotObjMoving;
#ifdef REDUCE_SIZE
// The image is reduced to its 32x32 icon size as it flies
#define SMALL_BITMAP_SIZE   32
static  float   deltaSize;
static  float   curSize;
#endif

#ifdef FADING_CLEAR
static  RGBA    curClearColor;
static  RGBA    deltaClearColor;
#endif


static void
ClearEndFly()
{
#ifdef FADING_CLEAR
    ClearAll();
#else
    ClearWindow();
#endif
}

static void
InitHotFlyMotion( LOG_OBJECT *pObj )
{
    // Calc destination (lower right corner of window)
    POINT3D destWin, dest;

#define FMAGIC_WINZ  0.990991f  // mf: by inspection...
//mf: if used 1.0f above, bad things happened

    UpdateLocalTransforms( UPDATE_MODELVIEW_MATRIX_BIT );

#ifdef REDUCE_SIZE
    // Figure out the final size of the object
    FSIZE   finalSize;
    finalSize.height = (float) SMALL_BITMAP_SIZE;
    if( bFlyWithContext )
        finalSize.width = 2.0f * (float) SMALL_BITMAP_SIZE;
    else
        finalSize.width = (float) SMALL_BITMAP_SIZE;

    POINT3D blWin = { 0.0f, 0.0f, FMAGIC_WINZ };
    POINT3D trWin = { finalSize.width, finalSize.height, FMAGIC_WINZ };
    POINT3D bl, tr;
    TransformWindowToObject( &blWin, &bl );
    TransformWindowToObject( &trWin, &tr );
    float endSize = (float) fabs( tr.y - bl.y );  // y delta should be same
                                                // with or without context

    curSize = pObj->fImageSize.height;
    deltaSize = curSize - endSize; // divide by iter later...

    // Figure out destination in window coords
    destWin.x = (float) winSize.width - finalSize.width / 2.0f;
    destWin.y = (float) finalSize.height / 2.0f;
    destWin.z = FMAGIC_WINZ;
    TransformWindowToObject( &destWin, &dest );
#else
    // Figure out destination in window coords
    GLIRECT rect;
    pObj->GetRect( &rect );
    destWin.x = (float) winSize.width - ((float) rect.width) / 2.0f;
    destWin.y = ((float) rect.height) / 2.0f;
    destWin.z = FMAGIC_WINZ;

    // Calc corresponding model-view coords (mf: function misnomer)
    TransformWindowToObject( &destWin, &dest );
#endif

    
    POINT3D curDest, offset;
    pObj->GetDest( &curDest );
    offset.x = curDest.x - dest.x;
    offset.y = curDest.y - dest.y;
    offset.z = 0.0f;

    dest.z = 0.0f;
    pObj->SetDest( &dest );

    float deviation;
    deviation = MyRand() / 2;
    deviation = deviation * deviation;

    pObj->SetDampedFlyMotion( deviation, &offset );

    float fEndFlyIter = (float) pHotObj->GetIter();
#ifdef FADING_CLEAR
    // Fade clear color to black
    curClearColor = bgColor;
    deltaClearColor.r = bgColor.r / fEndFlyIter;
    deltaClearColor.g = bgColor.g / fEndFlyIter;
    deltaClearColor.b = bgColor.b / fEndFlyIter;
#endif

#ifdef REDUCE_SIZE
    deltaSize /= fEndFlyIter;
#endif
}

static void
DrawLogonEndFlySequence()
{
    BOOL bTransitionOver = TRUE;
    LOG_OBJECT *pObj;

    ClearEndFly();

    for( int i = 0; i < nLogObj; i ++ ) {
        pObj = pLogObj[i];
        if( pObj->NextFlyIteration() ) {
            // This object is moving
            bTransitionOver = FALSE; // 1 or more objects still moving
            pObj->Draw( bSwapHints );
        } else {
            // This object has stopped moving - if it's one of the unselected
            // objects that has moved offscreen, no need to draw it, but if it's
            // the selected object, draw it (since it won't be moving at the
            // beginning and we need to redraw it).
            if( pObj == pHotObj )
                pObj->Draw( bSwapHints );
        }
    }
    Flush();

    // Check if its time to start the hot object moving
    iDrawCounter++;
    if( iDrawCounter == iStartHotMotion ) {
        // Start moving the selected object
        InitHotFlyMotion( pHotObj );
        bHotObjMoving = TRUE;
    }

    if( bHotObjMoving ) {
#ifdef FADING_CLEAR
        curClearColor.r -= deltaClearColor.r;
        curClearColor.g -= deltaClearColor.g;
        curClearColor.b -= deltaClearColor.b;
        glClearColor( curClearColor.r, curClearColor.g, curClearColor.b, 0.0f );
#endif
#ifdef REDUCE_SIZE
        FSIZE imageSize;
        curSize -= deltaSize;
        imageSize.width = imageSize.height = curSize;
        pHotObj->SetImageSize( &imageSize );
#endif
    }

    if( bTransitionOver )
        mtkWin->Return();
}

static void
CalcFlyAwayMotion( LOG_OBJECT *pObj, float deviation )
{
    // Set destination
    POINT3D dest;

    // Pick random z destination value
#if 0
    // z is in same range as in beginning of init sequence
    dest.z = MyRand();  // (-5 to 5)
#else
    // Set z so objects are small
    dest.z = ss_fRand(  -15.0f, 0.0f );
#endif

    // Now set x and y so the object is out of the field of view

    // Pick random quadrant for object to end up in
    // 0 = right, 1 = top, 2 = left, 3 = bottom
    int quadrant = ss_iRand( 4 );

    // Find x and y boundaries at the z value
    float dist, xSize, ySize;
    dist = view.fViewDist - dest.z;
    ySize = (float) tan( SS_DEG_TO_RAD( view.fovy / 2.0f ) ) * dist;
    xSize = view.fAspect * ySize;

    // !!! This makes assumptions about object size...
    FSIZE max;
    max.height = ySize + OBJECT_WIDTH / 4.0f;
    if( bFlyWithContext ) {
        max.width = xSize + OBJECT_WIDTH / 2.0f; 
    } else {
        max.width = xSize + OBJECT_WIDTH / 4.0f; 
    }

    if( ss_iRand( 2 ) ) {
        // set x first
        dest.x = ss_fRand( -max.width, max.width );
        // adjust y
        if( ss_iRand( 2 ) )
            dest.y = max.height;
        else
            dest.y = -max.height;
    } else {
        // set y first
        dest.y = ss_fRand( -max.height, max.height);
        // adjust x
        if( ss_iRand( 2 ) )
            dest.x = max.width;
        else
            dest.x = -max.width;
    }
    
    // Calc offset values... (subtract new dest from current dest)

    POINT3D curDest, offset;
    pObj->GetDest( &curDest );
    offset.x = curDest.x - dest.x;
    offset.y = curDest.y - dest.y;
    offset.z = curDest.z - dest.z;

    pObj->SetDest( &dest );

    // Set rotation parameters

    pObj->SetDampedFlyMotion( deviation, &offset );
}

static void
InitEndFlyMotion()
{ 
    // The 3 unselected objects fly away, selected one stays where it is

    LOG_OBJECT *pObj;
    float deviation;
    deviation = MyRand() / 2;
    deviation = deviation * deviation;

    // Clear the screen, to get rid of banner, and context (if !bFlyWithContext)
    ClearAll();

    int iAverageIter = 0;
    for( int i = 0; i < nLogObj; i ++ ) {
        pObj = pLogObj[i];

        if( ! bFlyWithContext ) {
            // Redraw the object without its context
            pObj->ShowContext( FALSE );
        // again, have to offset. ? maybe ShowContext should do it ?
            pObj->OffsetDest( OBJECT_WIDTH / 4.0f, 0.0f, 0.0f );
            pObj->Draw();
        }

        if( pObj == pHotObj ) {
            pObj->ResetMotion();
        } else {
            CalcFlyAwayMotion( pObj, deviation );
            iAverageIter += pObj->GetIter();
        }
    }
    // Don't Flush here, since it will generate noticeable flash...

    iAverageIter /= 3;
#if 0
    // Start hot obj moving halfway through the cycle
    iStartHotMotion = iAverageIter / 2;
#else
    iStartHotMotion = (int) ( 0.75f * (float)iAverageIter );
#endif
    iDrawCounter = 0;
    bHotObjMoving = FALSE;
}

static BOOL
RunLogonEndFlySequence()
{
    UpdateLocalTransforms( UPDATE_MODELVIEW_MATRIX_BIT );

    InitEndFlyMotion();

    // Set any gl attributes
    glDisable(GL_CULL_FACE);

    bSwapHints = FALSE;
#ifdef SWAP_HINTS_ON_FLYS
#ifndef FADING_CLEAR
    bSwapHints = bSwapHintsEnabled;
#endif
#endif

    // mtk callbacks

    mtkWin->SetAnimateFunc( DrawLogonEndFlySequence );
    mtkWin->SetDisplayFunc( DrawLogonEndFlySequence );
    return mtkWin->Exec();
}


/******************** FADE SEQUENCE ***************************************\
*
\**************************************************************************/

static float alphaCol[4];
static int iFadeIters;
static float alphaDelta;

static void InitFade()
{
    alphaCol[0] = alphaCol[1] = alphaCol[2] = 0.0f;
#if 1
    alphaCol[3] = 1.0f;
#else
// mf: To show alpha clamping problem...
    alphaCol[3] = 0.1f;
#endif

    iFadeIters = 20;
    alphaDelta = 1.0f / (float) (iFadeIters-1);
}

static void DrawEndFadeSequence(void)
{
    int i, j;
    BOOL bTransitionOver = FALSE;
    float updatesPerSecond;
    LOG_OBJECT *pObj;

    ClearWindow();

    for( i = 0; i < nLogObj; i++ ) {
        pObj = pLogObj[i];

        if( (pObj == pHotObj) ) {
            if( bSwapHints ) {
                // Don't need to redraw this one
                continue;
            }
            glDisable( GL_BLEND );
        } else {
            glColor4fv( alphaCol );
            glEnable( GL_BLEND );
        }
    
        pObj->Draw( FALSE );
    }

    Flush();

    // Decrement counter, setup next alpha color

    if( --iFadeIters <= 0 )
        bTransitionOver = TRUE;

    alphaCol[3] -= alphaDelta;

    // Print timing information if required

    if( bDebugMode ) {
        char szMsg[80];
        if( bTransitionOver ) {
            sprintf(szMsg, "%s: %.2lf sec",
                    "Transition time ",
                    transitionTimer.Stop() );

            // Print transition timing info in title bar
            SetWindowText( mtkWin->GetHWND(), szMsg );
        } else if( frameRateTimer.Update( 1, &updatesPerSecond ) ) {
            sprintf(szMsg, "%s: %.2lf frames/sec",
                    "",
                    updatesPerSecond );

            // Print frame timing info in title bar
            SetWindowText( mtkWin->GetHWND(), szMsg );
        }
    }

    if( bTransitionOver ) {
        glDisable( GL_BLEND );
        mtkWin->Return();
    }
}


static BOOL
RunLogonEndFadeSequence()
{
    // Set any gl attributes
    glEnable(GL_CULL_FACE);

    bSwapHints = bSwapHintsEnabled;

    // The fadeout will be done with blending to the background color
    InitFade();
    glBlendFunc( GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA );
    mtkWin->SetDisplayFunc( DrawEndFadeSequence );
    mtkWin->SetAnimateFunc( DrawEndFadeSequence );

    if( bDebugMode ) {
        frameRateTimer.Reset();
        frameRateTimer.Start();

        transitionTimer.Reset();
        transitionTimer.Start();
    }
    return mtkWin->Exec();
}

/******************** END SEQUENCE ************************************\
*
* Previously the end sequence had 2 steps: Transition away the unselected
* objects, then fly the selected one to lower right corner.  These 2 steps
* have now been combined into one sequence.
\**************************************************************************/

//#define FADE_AWAY 1

BOOL
RunLogonUnselectSequence()
{
#ifdef FADE_AWAY
//mf: this is no longer valid
    RunLogonEndFadeSequence();
#else
    RunLogonEndFlySequence();
#endif
    return TRUE;
}

BOOL
RunLogonEndSequence( LOG_OBJECT *pObj )
{
    BOOL bRet;

    SS_DBGPRINT( "RunLogonEndSequence()\n" );

    if( !pObj )
        SS_DBGPRINT( "RunLogonEndSequence : pObj arg is NULL\n" );
        
    if( bDebugMode )
        bRunAgain = FALSE;

    pHotObj = pObj;

    // The selected object is pHotObj

    // Phase 1 : fade out or fly away non-selected quads
    // Phase 2 : fly selected one to lower right

    mtkWin->SetMouseMoveFunc( NULL );
    mtkWin->SetMouseDownFunc( NULL );
    mtkWin->SetKeyDownFunc(EscKey);

    if( ! RunLogonUnselectSequence() )
        return FALSE;

    // in debug mode hold it here, instead of exiting
    if( bDebugMode )
        return RunHoldSequence();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\pgonoffs\toffset.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 *               1993, 1994 Microsoft Corporation
 *
 * ALL RIGHTS RESERVED
 *
 * Please refer to OpenGL/readme.txt for additional information
 *
 */

#include "glos.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <gl\glaux.h>
#include "tk.h"
#include "trackbal.h"


#define PI 3.141592654
#define BLACK 0
#define GRAY 128
#define WHITE 255
#define RD 0xA40000FF
#define WT 0xFFFFFFFF
#define brickImageWidth 16
#define brickImageHeight 16

//static void CALLBACK ErrorHandler(unsigned long which);
static void Init(void );
static void CALLBACK Reshape(int width,int height);
static void CALLBACK Draw( void ); 
static unsigned long Args(int argc,char **argv );

GLenum rgb, doubleBuffer;

GLint wWidth = 300, wHeight = 300;

GLenum doDither = GL_TRUE;
GLenum shade = GL_TRUE;
GLenum texture = GL_TRUE;

BOOL bPolyOffset = TRUE;
#if 1
float factor=0.0f, units=0.0f;
#else
float factor=-1.0f, units=0.0f;
#endif
float inc = 1.0f;
int polygonMode = GL_LINE;
GLenum polyFace = GL_FRONT;
float zTrans = -2.7;
BOOL bCullFace = FALSE;
BOOL bHiddenLine;

GLint radius1, radius2;
GLdouble angle1, angle2;
GLint slices, stacks;
GLint height;
GLint whichQuadric;
GLUquadricObj *quadObj;

GLubyte brickImage[brickImageWidth*brickImageHeight] = {
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    RD, RD, RD, RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD,
    WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT, WT,
    RD, RD, RD, RD, WT, RD, RD, RD, RD, RD, RD, RD, RD, RD, WT, RD
};
char *texFileName = 0;


#if 0
static void CALLBACK ErrorHandler(GLenum which)
{

    fprintf(stderr, "Quad Error: %s\n", gluErrorString(which));
}
#endif

static void UpdateInfo()
{
    HWND hwnd = tkGetHWND();
    char buf[100];

    sprintf( buf, "Factor = %4.1f, Units = %4.1f", factor, units );
    SendMessage( hwnd, WM_SETTEXT, 0, (LPARAM)buf );
}

static void SetMaterial( bBlack )
{
    static float front_mat_shininess[] = {30.0};
    static float front_mat_specular[] = {0.2, 0.2, 0.2, 1.0};
    static float front_mat_diffuse[] = {0.5, 0.28, 0.38, 1.0};
    static float back_mat_shininess[] = {50.0};
    static float back_mat_specular[] = {0.5, 0.5, 0.2, 1.0};
    static float back_mat_diffuse[] = {1.0, 1.0, 0.2, 1.0};
    static float black_mat_shininess[] = {0.0};
    static float black_mat_specular[] = {0.0, 0.0, 0.0, 0.0};
    static float black_mat_diffuse[] = {0.0, 0.0, 0.0, 0.0};
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float no_ambient[] = {0.0, 0.0, 0.0, 0.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_no_ambient[] = {0.0, 0.0, 0.0, 0.0};

    if( !bBlack ) {
        glMaterialfv(GL_FRONT, GL_SHININESS, front_mat_shininess);
        glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
        glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
        glMaterialfv(GL_BACK, GL_SHININESS, back_mat_shininess);
        glMaterialfv(GL_BACK, GL_SPECULAR, back_mat_specular);
        glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
        glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    } else {
        glMaterialfv(GL_FRONT, GL_SHININESS, black_mat_shininess);
        glMaterialfv(GL_FRONT, GL_SPECULAR, black_mat_specular);
        glMaterialfv(GL_FRONT, GL_DIFFUSE, black_mat_diffuse);
        glMaterialfv(GL_BACK, GL_SHININESS, black_mat_shininess);
        glMaterialfv(GL_BACK, GL_SPECULAR, black_mat_specular);
        glMaterialfv(GL_BACK, GL_DIFFUSE, black_mat_diffuse);
        glLightfv(GL_LIGHT0, GL_AMBIENT, no_ambient);
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_no_ambient);
    }
}

static void Init(void)
{
    static GLint colorIndexes[3] = {0, 200, 255};
    static float ambient[] = {0.1, 0.1, 0.1, 1.0};
    static float diffuse[] = {0.5, 1.0, 1.0, 1.0};
    static float position[] = {90.0, 90.0, 150.0, 0.0};
    static float lmodel_ambient[] = {1.0, 1.0, 1.0, 1.0};
    static float lmodel_twoside[] = {GL_TRUE};
    static float decal[] = {GL_DECAL};
    static float modulate[] = {GL_MODULATE};
    static float repeat[] = {GL_REPEAT};
    static float nearest[] = {GL_NEAREST};
    AUX_RGBImageRec *image;

    if (!rgb) {
        auxSetGreyRamp();
    }
    glClearColor(0.0, 0.0, 0.0, 0.0);
    
    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    bHiddenLine = FALSE;
    SetMaterial( bHiddenLine );

    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, decal);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, repeat);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, nearest);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, nearest);
    if (texFileName) {
        image = auxRGBImageLoad(texFileName);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image->sizeX, image->sizeY,
              GL_RGB, GL_UNSIGNED_BYTE, image->data);
    } else {
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexImage2D(GL_TEXTURE_2D, 0, 4, brickImageWidth, brickImageHeight,
             0, GL_RGBA, GL_UNSIGNED_BYTE, (GLvoid *)brickImage);
    }

    quadObj = gluNewQuadric();

    radius1 = 10;
    radius2 = 5;
    angle1 = 90;
    angle2 = 180;
    slices = 16;
    stacks = 10;
    height = 20;

    glCullFace( GL_BACK );

    UpdateInfo();
}


static void SetDistance( void )
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1, 1, -1, 1, 1, 10);
    // This defines how far away we're looking from
    glTranslated( 0, 0, zTrans );
}

static void CALLBACK Reshape(int width, int height)
{
    trackball_Resize( width, height );

    glViewport(0, 0, (GLint)width, (GLint)height);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1, 1, -1, 1, 1, 10);
    // This defines how far away we're looking from
    glTranslated( 0, 0, zTrans );
}

static GLenum Key(int key, GLenum mask)
{

    switch (key) {
      case TK_ESCAPE:
	    tkQuit();

      case TK_LEFT:
            units -= inc;
	    break;
      case TK_RIGHT:
            units += inc;
	    break;
      case TK_UP:
            factor += inc;
	    break;
      case TK_DOWN:
            factor -= inc;
	    break;
      case TK_v:
        break;

      case TK_X:
	    break;
      case TK_x:
	    break;
      case TK_a:
        if (stacks > 1)
            stacks--;
	    break;
      case TK_A:
        stacks++;
	    break;

      case TK_b:
            bHiddenLine = !bHiddenLine;
            SetMaterial( bHiddenLine );
	    break;

      case TK_c:
        bCullFace = !bCullFace;
        if( bCullFace )
            glEnable( GL_CULL_FACE );
        else
            glDisable( GL_CULL_FACE );
        break;

      case TK_f:
	whichQuadric = whichQuadric >= 3 ? 0 : whichQuadric + 1;
	break;

      case TK_G:
        radius1 += 1;
        break;
      case TK_g:
        if (radius1 > 0)
            radius1 -= 1;
        break;
      case TK_H:
        height += 2;
        break;
      case TK_h:
        if (height > 0)
            height -= 2;
        break;
      case TK_i:
        factor = 0.0f;
        units = 0.0f;
        break;
      case TK_J:
        radius2 += 1;
        break;
      case TK_j:
        if (radius2 > 0)
            radius2 -= 1;
        break;

      case TK_K:
	angle1 += 5;
	break;
      case TK_k:
	angle1 -= 5;
	break;

      case TK_L:
	angle2 += 5;
	break;
      case TK_l:
	angle2 -= 5;
	break;

      case TK_M:
	    break;
      case TK_m:
	    break;
      case TK_n:
	    break;
      case TK_N:
	    break;

      case TK_o:
            bPolyOffset = !bPolyOffset;
	    break;

      case TK_p:
	switch (polyFace) {
	  case GL_BACK:
	    polyFace = GL_FRONT;
	    break;
	  case GL_FRONT:
	    polyFace = GL_FRONT_AND_BACK;
	    break;
	  case GL_FRONT_AND_BACK:
	    polyFace = GL_BACK;
	    break;
	}
	break;
      case TK_s:
        if (slices > 3)
            slices--;
        break;
      case TK_S:
        slices++;
        break;

      case TK_t:
        texture = !texture;
        if (texture) {
            gluQuadricTexture(quadObj, GL_TRUE);
            glEnable(GL_TEXTURE_2D);
        } else {
            gluQuadricTexture(quadObj, GL_FALSE);
            glDisable(GL_TEXTURE_2D);
        }
        break;

      case TK_z:
        zTrans += 0.1f;
        SetDistance();
        break;

      case TK_Z:
        zTrans -= 0.1f;
        SetDistance();
        break;

      case TK_0:
        shade = !shade;
        if (shade) {
            glShadeModel(GL_SMOOTH);
            gluQuadricNormals(quadObj, GLU_SMOOTH);
        } else {
            glShadeModel(GL_FLAT);
            gluQuadricNormals(quadObj, GLU_FLAT);
        }
        break;
      case TK_1:
        polygonMode = GL_FILL;
        break;

      case TK_2:
        polygonMode = GL_LINE;
        break;

      case TK_3:
        polygonMode = GL_POINT;
        break;
      case TK_4:
        break;

      default:
	    return GL_FALSE;
    }
    UpdateInfo();
    return GL_TRUE;
}

static void DrawRect( void ) 
{
    glBegin( GL_QUADS );
    glVertex2f(  1.0f,  1.0f );
    glVertex2f( -1.0f,  1.0f );
    glVertex2f( -1.0f, -1.0f );
    glVertex2f(  1.0f, -1.0f );
    glEnd();
}

static void DrawTri( void ) 
{
    glBegin( GL_TRIANGLES );
    glVertex2f(  1.0f,  1.0f );
    glVertex2f( -1.0f,  1.0f );
    glVertex2f( -1.0f, -1.0f );
    glEnd();
}

static void DrawObject( void ) 
{
#if 1
    switch (whichQuadric) {
      case 0:
	gluCylinder(quadObj, radius1/10.0, radius2/10.0, height/10.0, 
		    slices, stacks);
	break;
      case 1:
	gluSphere(quadObj, radius1/10.0, slices, stacks);
	break;
      case 2:
	gluPartialDisk(quadObj, radius2/10.0, radius1/10.0, slices, 
		       stacks, angle1, angle2);
	break;
      case 3:
	gluDisk(quadObj, radius2/10.0, radius1/10.0, slices, stacks);
	break;
    }
#else
    // simple debugging ojbects
//mf: ? these aren't centered when rotating
#if 0
    DrawRect();
#else
    DrawTri();
#endif
#endif
}

static void CALLBACK Draw( void ) 
{
    float matRot[4][4];

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glMatrixMode( GL_MODELVIEW );
    glLoadIdentity();
    trackball_CalcRotMatrix( matRot );
    glMultMatrixf( &(matRot[0][0]) );

#if 0
    glColor3f(1.0, 1.0, 1.0);
#endif

    if( whichQuadric == 0 ) // cylinder
	glTranslatef(0, 0, -height/20.0);

    // Draw object normally

    DrawObject();

    // Draw object again with polygon offset

    // Set polygon mode for offset faces
    glPolygonMode( GL_FRONT_AND_BACK, polygonMode );

    if( bPolyOffset ) {
        switch( polygonMode ) {
            case GL_FILL:
                glEnable( GL_POLYGON_OFFSET_FILL );
                break;
            case GL_LINE:
                glEnable( GL_POLYGON_OFFSET_LINE );
                break;
            case GL_POINT:
                glEnable( GL_POLYGON_OFFSET_POINT );
                break;
        }
    }

    glPolygonOffset( factor, units );
    glColor3f(1.0, 0.0, 0.0);
    glDisable( GL_LIGHTING );
    DrawObject();
    glEnable( GL_LIGHTING );
    // restore modes
    glPolygonMode( GL_FRONT_AND_BACK, GL_FILL );

    if( bPolyOffset ) {
        glDisable( GL_POLYGON_OFFSET_FILL );
        glDisable( GL_POLYGON_OFFSET_LINE );
        glDisable( GL_POLYGON_OFFSET_POINT );
    }

    glFlush();

    if (doubleBuffer) {
	tkSwapBuffers();
    }
}

static unsigned long Args(int argc, char **argv)
{
    GLint i;

    rgb = GL_TRUE;
    doubleBuffer = GL_TRUE;


    for (i = 1; i < argc; i++) {
        if (strcmp(argv[i], "-ci") == 0) {
            rgb = GL_FALSE;
        } else if (strcmp(argv[i], "-rgb") == 0) {
            rgb = GL_TRUE;
        } else if (strcmp(argv[i], "-sb") == 0) {
            doubleBuffer = GL_FALSE;
        } else if (strcmp(argv[i], "-db") == 0) {
            doubleBuffer = GL_TRUE;
        } else if (strcmp(argv[i], "-f") == 0) {
            if (i+1 >= argc || argv[i+1][0] == '-') {
            //printf("-f (No file name).\n");
            return GL_FALSE;
        } else {
            texFileName = argv[++i];
        }
        } else {
            //printf("%s (Bad option).\n", argv[i]);
            return GL_FALSE;
        }
    }
    return GL_TRUE;
}

void main(int argc, char **argv)
{
    GLenum type;

    if (Args(argc, argv) == GL_FALSE) {
        auxQuit();
    }

    tkInitPosition(0, 0, wWidth, wHeight);

#if 0
    type = TK_DEPTH24;
#else
    type = TK_DEPTH16;
#endif
    type |= (rgb) ? TK_RGB : TK_INDEX;
    type |= (doubleBuffer) ? TK_DOUBLE : TK_SINGLE;

    tkInitDisplayMode(type);

    if (tkInitWindow("Quad Test") == GL_FALSE) {
        tkQuit();
    }

    Init();

    tkExposeFunc(Reshape);
    tkReshapeFunc(Reshape);

    tkKeyDownFunc( Key );
    tkMouseDownFunc( trackball_MouseDown );
    tkMouseUpFunc( trackball_MouseUp );
    
    trackball_Init( wWidth, wHeight );

    tkIdleFunc( Draw );
    tkDisplayFunc( 0 );
    tkExec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\loghot.cxx ===
/******************************Module*Header*******************************\
* Module Name: loghot.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "logon.hxx"
#include "resource.h"

static LOG_OBJECT *pHotObj;
static void DrawBanner();
static BOOL    bFrameObjects; // whether to frame the objects or not


static float    colorHot[3] = { 0.0f, 1.0f, 0.0f };
static float    colorWhite[3] =    { 1.0f, 1.0f, 1.0f };

#define HOT_CURSOR  1

/******************** HOT SEQUENCE ****************************************\
*
\**************************************************************************/

static LOG_OBJECT*
CheckForHit( int mouseX, int mouseY )
{
    // Check mouse coords against rect of each object.  Return ptr to object
    // if within.

    mouseY = InvertY( mouseY, winSize.height );

    LOG_OBJECT *pObj;
    GLIRECT rect, *pRect;
    pRect = &rect;

    for( int i = 0; i < nLogObj; i++ ) {
        pObj = pLogObj[i];
        pObj->GetRect( pRect );
        if( ( mouseX >= pRect->x ) &&
            ( mouseX < (pRect->x + pRect->width) ) &&
            ( mouseY >= pRect->y ) &&
            ( mouseY < (pRect->y + pRect->height) ) )
        {
//            SS_DBGPRINT( "CheckForHit() recording a hit\n" );
            return pObj;
        }
    }
    return NULL;
}

static void
DrawObject( LOG_OBJECT *pObj, BOOL bHot )
{
    if( !pObj )
        return;

    // Set ColorMaterial color, in case lighting is on for the frame
    if( bHot ) {
        glColor3fv( colorHot );
    } else {
        glColor3fv( colorWhite );
    }

    pObj->Draw();
}

// This redraws everything

static void DrawHotSequence(void)
{
    ClearWindow();

    LOG_OBJECT *pObj;

    for( int i = 0; i < nLogObj; i++ ) {
        pObj = pLogObj[i];        
        DrawObject( pObj, (pObj == pHotObj) );            
    }

    Flush();
    DrawBanner();
}

static void
FinishLogonHotSequence()
{
#ifndef HOT_CURSOR
    // User has selected an object.
    // Turn off hilite on current selection and return
    DrawObject( pHotObj, FALSE );
    Flush();
#endif

    mtkWin->Return();
}


static BOOL
HotKey(int key, GLenum mask)
{
    switch (key) {
      case TK_RETURN:
        if( pHotObj )
            FinishLogonHotSequence();
        break;
      case TK_ESCAPE:
        if( bDebugMode )
        	Quit();
        break;
      case TK_SPACE:
        if( bDebugMode ) {
            bRunAgain = TRUE;
            FinishLogonHotSequence();
        }
        break;
      default:
        if( bDebugMode )
            return AttributeKey( key, mask );
	    return FALSE;
    }
    return FALSE;
}

static BOOL 
MouseButton(int mouseX, int mouseY, GLenum button)
{
    // If left button click on an object, run end of logon sequence

	if( !(button & TK_LEFTBUTTON) )
        return GL_FALSE;

    LOG_OBJECT *pObj;

    if( pObj = CheckForHit( mouseX, mouseY ) ) {
        pHotObj = pObj;
        FinishLogonHotSequence();
    }

    return FALSE;
}

static BOOL 
MouseMove(int mouseX, int mouseY, GLenum button)
{
    // Handle a mouse move.  Redraw only when necessary

    LOG_OBJECT *pObj;

    LOG_OBJECT *pLastHotObj = pHotObj;

    if( pObj = CheckForHit( mouseX, mouseY ) ) {
        if( pObj == pHotObj ) {
            // State has not changed
            return FALSE;
        }
        // New hot object
        pHotObj = pObj;
        SetCursor( hHotCursor );
    } else {
        SetCursor( hNormalCursor );
        if( !pHotObj ) {
            // State has not changed
            return FALSE;
        }
        // No hot object
        pHotObj = NULL;
    }

#ifndef HOT_CURSOR
    if( ! bSwapHints )
        // Need to do complete redraw
        return TRUE;

    // Redraw only the objects that changed

    if( pLastHotObj ) {
        // remove hot indicator from old hot object
        DrawObject( pLastHotObj, FALSE );
    }

    if( pHotObj ) {
        // add hot indicator to new hot object
        DrawObject( pHotObj, TRUE );
    }

    // Flush the changes

    Flush();
#endif

    return FALSE;
}

static void DrawBanner()
{
    BitBlt( mtkWin->GetHdc(), 0, 0, bannerSize.width, bannerSize.height,
            hdcMem, 0, 0, SRCCOPY );
    GdiFlush();
}

LOG_OBJECT *
RunLogonHotSequence()
{
    if( bDebugMode )
        bRunAgain = FALSE;
    // Stop animation, make quads 'hot'

    SS_DBGPRINT( "RunLogonHotSequence()\n" );

    // If the objects were flown in without context their origins would have
    // been in centre of the image part.  Since we want to add context now,
    // have to offset the destination values.  This is done inside next loop

    // Calc window rects of the quads

    bSwapHints = bSwapHintsEnabled;
    UpdateLocalTransforms( UPDATE_ALL );

    bFrameObjects = FALSE; // no framing currently

    LOG_OBJECT *pObj;

    for( int i = 0; i < nLogObj; i++ ) {
        pObj = pLogObj[i];
        pObj->ShowContext( TRUE );
        if( !bFlyWithContext ) {
            // offset x dest value to the left (again, size assumption)
            pObj->OffsetDest( - OBJECT_WIDTH / 4.0f, 0.0f, 0.0f );
        }
        if( bFrameObjects )
            pObj->ShowFrame( TRUE );
        pObj->CalcWinRect();
    }

    pHotObj = NULL;

    // Set any gl attributes
    if( bFrameObjects ) {
        glEnable(GL_CULL_FACE);
        glEnable(GL_DEPTH_TEST);
        bDepth = TRUE;
    }

    // Go to slower but nicer texture drawing while in this mode
    for( i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->pTex->MakeCurrent();        
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
    }

    // Set up mtk functions for this sequence

    mtkWin->SetAnimateFunc( NULL );
    mtkWin->SetKeyDownFunc(HotKey);
    mtkWin->SetMouseMoveFunc( MouseMove );
    mtkWin->SetMouseDownFunc( MouseButton );
    mtkWin->SetDisplayFunc( DrawHotSequence );

    // Now get the current pointer position and simulate a mouse move with it,
    // in case it's over one of the objects. 

    IPOINT2D ptMouse;

    mtkWin->GetMouseLoc( &ptMouse.x, &ptMouse.y );
    // Need to check that mouse is inside window
    if( (ptMouse.x >= 0) &&
        (ptMouse.x < winSize.width) &&
        (ptMouse.y >= 0) &&
        (ptMouse.y < winSize.height) )
    {
        MouseMove( ptMouse.x, ptMouse.y, 0 );
    }

    // Draw everything (so nicer textures show up)
    DrawHotSequence();
    
    if( !mtkWin->Exec() )
        return NULL;

    // Restore gl attributes
    for( i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->pTex->MakeCurrent();        
        glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
    }
    glDisable(GL_DEPTH_TEST);
    glDisable(GL_CULL_FACE);
    bDepth = FALSE;

    // Turn frames off for the objects
    for( i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->ShowFrame( FALSE );
    }

    // Dump the cursor
    SetCursor( NULL );
    return pHotObj;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\loginit.cxx ===
/******************************Module*Header*******************************\
* Module Name: loginit.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "uidemo.hxx"
#include "logon.hxx"
#include "logobj.hxx"

static void DrawInitSequence(void)
{
    int i, j;
    BOOL bTransitionOver = TRUE;
    float updatesPerSecond;
    LOG_OBJECT *pObj;

    // Calculate next position for each object

    for (i = 0; i < nLogObj; i++) {
        pObj = pLogObj[i];

        // NextIteration returns TRUE if object still moving, else FALSE
        if( pObj->NextFlyIteration() )
            bTransitionOver = FALSE;
    }

    ClearWindow();

    DrawObjects( bSwapHints );

    Flush();

    // Print timing information if required

    if( bDebugMode ) {
        char szMsg[80];
        if( bTransitionOver ) {
            sprintf(szMsg, "%s: %.2lf sec, %s",
                    "Transition time ",
                    transitionTimer.Stop(), "Press <space> to restart" );

            // Print transition timing info in title bar
            mtkWin->SetTitle( szMsg );
        } else if( frameRateTimer.Update( 1, &updatesPerSecond ) ) {
            sprintf(szMsg, "%s: %.2lf frames/sec",
                    "",
                    updatesPerSecond );

            // Print frame timing info in title bar
            mtkWin->SetTitle( szMsg );
        }
    }

    if( bTransitionOver ) {
        mtkWin->Return(); // return to Exec call
    }
}

void SetObjectRestPositions()
{
    // This assumes that the objects will display context when at rest

    float spacing = OBJECT_WIDTH / 3.0f; // space between objects

    //  *** This assumes we have 4 objects !!! ***
    SS_ASSERT( nLogObj == 4, "SetObjectRestPositions() : object count not 4\n" );

    // Assumption is made here that all objects are same size, that their
    // height is half their width, and that image and context are each half
    // the width.  Otherwise this scenario will get mucho complicated.

    spacing /= 2.0f;  // half space (axis to edge of object)
    float x = OBJECT_WIDTH / 2.0f + spacing;
    float y = OBJECT_WIDTH / 4.0f + spacing;
    float z = 0.0f;

    pLogObj[0]->SetDest( -x,  y, z );
    pLogObj[1]->SetDest(  x,  y, z );
    pLogObj[2]->SetDest( -x, -y, z );
    pLogObj[3]->SetDest(  x, -y, z );

    if( ! bFlyWithContext ) {
        // The objects are flying in without context, but will gain it
        // after they come to rest.  Have to offset things to make room for
        // the context.  Since context goes on left hand side, offset the
        // objects in +x
        float offset = OBJECT_WIDTH / 4.0f;
        pLogObj[0]->OffsetDest( offset, 0.0f, 0.0f );
        pLogObj[1]->OffsetDest( offset, 0.0f, 0.0f );
        pLogObj[2]->OffsetDest( offset, 0.0f, 0.0f );
        pLogObj[3]->OffsetDest( offset, 0.0f, 0.0f );
    }
}

static void
InitMotion()
{
    float deviation;

    deviation = MyRand() / 2;
    deviation = deviation * deviation;

    LOG_OBJECT *pObj;
#if 1
    for (int i = 0; i < nLogObj; i++) {
        pObj = pLogObj[i];
        if( bFlyWithContext )
            pObj->ShowContext( TRUE );
        else
            pObj->ShowContext( FALSE );
        pObj->SetDampedFlyMotion( deviation );
    }
#else
//mf: test
    glEnable( GL_DEPTH_TEST );
    bDepth = TRUE;
    for (int i = 0; i < nLogObj; i++) {
        pLogObj[i]->ShowFrame( TRUE );
        pLogObj[i]->SetDampedFlyMotion( deviation );
    }
#endif

    SetObjectRestPositions();
}

BOOL RunLogonInitSequence()
{
    SS_DBGPRINT( "RunLogonInitSequence()\n" );

#if SWAP_HINTS_ON_FLYS
    bSwapHints = bSwapHintsEnabled;
#else
    // Disable swap hints for rotations - no performance advantage usually
    bSwapHints = FALSE;
#endif

    UpdateLocalTransforms( UPDATE_ALL );

    // Set GL attributes

    glDisable( GL_CULL_FACE );

    InitMotion();

    // Timers

    if( bDebugMode ) {
        frameRateTimer.Reset();
        frameRateTimer.Start();

        transitionTimer.Reset();
        transitionTimer.Start();
    }

    // Clear window
    ClearAll();

    // Set mtk callbacks

    mtkWin->SetKeyDownFunc( Key );
//mf: have DisplayFunc clear then call AnimateFunc... (but if timer already
//     running, then don't need to call..)
    mtkWin->SetDisplayFunc( DrawInitSequence );
    mtkWin->SetAnimateFunc( DrawInitSequence );

    // Start the message loop
    return mtkWin->Exec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\logon.cxx ===
/******************************Module*Header*******************************\
* Module Name: logon.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "uidemo.hxx"
#include "logon.hxx"
#include "logobj.hxx"

//#define TEST_BITMAP 1

//#define UIDEMO_SWITCH_RES 1

MTKWIN *mtkWin;  // the main window
ISIZE winSize; // main window cached size and position
IPOINT2D winPos;
BOOL bSwapHintsEnabled; // global swap hints
BOOL bSwapHints;        // local use
HCURSOR  hNormalCursor, hHotCursor;
HINSTANCE hLogonInstance;
BOOL bDebugMode;
BOOL bRunAgain;
#if 0
BOOL bFlyWithContext = TRUE;
#else
BOOL bFlyWithContext = FALSE;
#endif

// Stuff for the banner
HDC     hdcMem;
HBITMAP hBanner;
ISIZE   bannerSize = { 0, 0 };

RGBA bgColor = {0.16f, 0.234f, 0.32f, 0.0f}; // ok

int nLogObj;
LOG_OBJECT **pLogObj;

static LOG_OBJECT *pHotObj;  // currently hot object

BOOL bLighting, bDepth;
VIEW view;
static BOOL bResSwitch;

// Timing stuff
AVG_UPDATE_TIMER frameRateTimer( 1.0f, 4 );
TIMER     transitionTimer;

// Forwards
static void CleanUp();
static void GLFinish();

/**************************************************************************\
*
\**************************************************************************/


float Clamp(int iters_left, float t)
{

    if (iters_left < 3) {
    	return 0.0f;
    }
    return (float) (iters_left-2)*t/iters_left;
}

void ClearWindow()
{
    int clearMask = GL_COLOR_BUFFER_BIT;
    if( bDepth )
        clearMask |= GL_DEPTH_BUFFER_BIT;

    if( !bSwapHints ) {
        glClear( clearMask );
        return;
    }

    GLIRECT rect, *pRect;
    pRect = &rect;

    for( int i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->GetRect( pRect );
        glScissor( pRect->x, pRect->y, pRect->width, pRect->height );
        glClear( clearMask );
        AddSwapHintRect( pRect );
    }
    // restore full scissor (mf : ? or just disable,since this only place used ?
    glScissor( 0, 0, winSize.width, winSize.height );
}

void ClearAll()
{
    static GLIRECT rect = {0};
    int clearMask = GL_COLOR_BUFFER_BIT;
    if( bDepth )
        clearMask |= GL_DEPTH_BUFFER_BIT;

    glScissor( 0, 0, winSize.width, winSize.height );
    glClear( clearMask );
    if( bSwapHints ) {
        rect.width = winSize.width;
        rect.height = winSize.height;
        AddSwapHintRect( &rect );
    }
}

void ClearRect( GLIRECT *pRect, BOOL bResetScissor )
{
    int clearMask = GL_COLOR_BUFFER_BIT;
    if( bDepth )
        clearMask |= GL_DEPTH_BUFFER_BIT;

    glScissor( pRect->x, pRect->y, pRect->width, pRect->height );
    glClear( clearMask );

    if( bResetScissor )
        glScissor( 0, 0, winSize.width, winSize.height );
}

void DrawObjects( BOOL bCalcUpdateRect )
{
    // Draws objects in their current positions

    for( int i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->Draw( bCalcUpdateRect );
    }
}

void Flush()
{
    // glFlush, SwapBuffers (if doubleBuf)
   	mtkWin->Flush();
}

float MyRand(void)
{
    return 10.0f * ( ((float) rand())/((float) RAND_MAX) - 0.5f);
}

static void
SetDepthMode()
{
    if( bDepth )
        glEnable(GL_DEPTH_TEST);
    else
        glDisable(GL_DEPTH_TEST);
}

static void
SetTextureMode()
{
    int mode;
    
    if( bLighting )
        mode = GL_MODULATE;
    else
        mode = GL_DECAL;

    glTexEnvi( GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, mode );
}

static void
SetLightingMode()
{
    if( bLighting )
        glEnable( GL_LIGHTING );
    else
        glDisable( GL_LIGHTING );
    SetTextureMode();
}

void 
CalcObjectWindowRects()
{
    for( int i = 0; i < nLogObj; i++ ) {
        pLogObj[i]->CalcWinRect();
    }
}

//mf: VIEW class member
static void 
SetView( ISIZE *pWinSize )
{
    glViewport(0, 0, pWinSize->width, pWinSize->height);

    view.fViewDist = 10.0f; // viewing distance
    view.fovy = 45.0f;     // field of view in y direction (degrees)
    view.fAspect = (float) pWinSize->width / (float) pWinSize->height;

    // We'll assume width >= height

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(view.fovy, view.fAspect, 0.1, 100.0);
//    glOrtho( -5.0, 5.0, -5.0, 5.0, 0.0, 100.0 ); no look as good
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    gluLookAt(0,0,view.fViewDist, 0,0,0, 0,1,0); // from, to, up...
}


void Reshape(int width, int height)
{
// Need to update main window info
    ISIZE *pSize = &winSize;

    pSize->width = width;
    pSize->height = height;

    if( !width || !height )
        return;

    SetView( pSize );

    UpdateLocalTransforms( UPDATE_ALL );
    CalcObjectWindowRects();

// mf: this is kind of a hack, need a different mechanism, since get repaints
// from resizes and window expose (an argument for msg loops even in mtk
// programs.  Of course, there's also tkDisplayFunc, which is called on PAINT,
// as opposed to IdleFunc...

    ClearAll();
}

BOOL EscKey(int key, GLenum mask)
{
    if( bDebugMode && (key == TK_ESCAPE) )
        Quit();
    return FALSE;
}

BOOL Key(int key, GLenum mask)
{
    if( !bDebugMode )
        return FALSE;

    switch (key) {
      case TK_ESCAPE:
    	Quit();
    	break;
      default:
	    return AttributeKey( key, mask );
    }
    return TRUE;
}

BOOL AttributeKey(int key, GLenum mask)
{
    switch (key) {
      case TK_c :
        bFlyWithContext = !bFlyWithContext;
        break;
      case TK_d :
        bDepth = !bDepth;
        SetDepthMode();
        break;
      case TK_l :
        bLighting = !bLighting;
        // This affects texturing mode
        SetLightingMode();
        break;
      case TK_s :
        if( mtk_bAddSwapHintRect() )
            bSwapHintsEnabled = !bSwapHintsEnabled;
        break;
      default:
	    return FALSE;
    }
    return TRUE;
}

static void LoadCursors()
{
    hNormalCursor = LoadCursor( NULL, IDC_ARROW );
    hHotCursor = LoadCursor( hLogonInstance, MAKEINTRESOURCE( IDC_HOT_CURSOR ) );
}

/******************** MAIN LOGON SEQUENCE *********************************\
*
\**************************************************************************/

static MTKWIN *CreateLogonWindow()
{
    MTKWIN *win;

    // Set window size and position

    bResSwitch = FALSE;

    UINT winConfig = 0;
    // Have to intially create window without cursor, so can change it later
    winConfig |= MTK_NOCURSOR;

    if( bDebugMode ) {
        winPos.x = 10;
        winPos.y = 30;
#if 0
        winSize.width = 400;
        winSize.height = 300;
#else
        winSize.width = 800;
        winSize.height = 600;
#endif
    } else {
#if UIDEMO_SWITCH_RES
        if( mtk_ChangeDisplaySettings( 800, 600, NULL ) ) {
            bResSwitch = TRUE;
        }
#endif
        winConfig |= MTK_FULLSCREEN | MTK_NOBORDER;
        winPos.x = 0;
        winPos.y = 0;
        winSize.width = GetSystemMetrics( SM_CXSCREEN );
        winSize.height = GetSystemMetrics( SM_CYSCREEN );
#if 0
// debugging full screen ...
        winSize.width /= 4;
        winSize.height /= 4;
#endif
    }

    win = new MTKWIN();
    if( !win )
        return NULL;

    // Configure and create the window (mf: this 2 step process of constructor
    // and create will allow creating 'NULL' windows

#ifdef TEST_BITMAP
    UINT glConfig = MTK_RGB | MTK_DOUBLE | MTK_BITMAP | MTK_DEPTH16;
#else
    UINT glConfig = MTK_RGB | MTK_DOUBLE | MTK_DEPTH16;
#endif
    if( !bDebugMode )
        glConfig |= MTK_NOBORDER;

    // Create the window
    if( ! win->Create( "Demo", &winSize, &winPos, winConfig, NULL ) ) {
        delete win;
        return NULL;
    }

    // Configure the window for OpenGL, setting ReshapeFunc to catch the
    // resize (can't set it before in this case, since we do various gl
    // calculations in the Reshape func.

    win->SetReshapeFunc(Reshape);
    win->SetFinishFunc(GLFinish);
    if( ! win->Config( glConfig ) ) 
    {
        delete win;
        return NULL;
    }

    return win;
}

static void InitGL(void)
{
#if 0
    static float lmodel_ambient[] = {0.0f, 0.0f, 0.0f, 0.0f};
#else
    static float lmodel_ambient[] = {0.2f, 0.2f, 0.2f, 0.0f};
#endif
//mf: change to one sided lighting if object is closed
    static float lmodel_twoside[] = {(float)GL_TRUE};
    static float lmodel_local[] = {(float)GL_FALSE};
    static float light0_ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};
    static float light0_diffuse[] = {1.0f, 1.0f, 1.0f, 0.0f};
#if 1
//    static float light0_position[] = {-1.0f, 1.0f,  1.0f, 0.0f};
    static float light0_position[] = {-1.0f, 0.8f,  4.0f, 0.0f};
#else
    static float light0_position[] = {-1.0f, 1.0f,  1.0f, 0.0f};
#endif
    static float light0_specular[] = {1.0f, 1.0f, 1.0f, 0.0f};

    static float bevel_mat_ambient[] = {0.0f, 0.0f, 0.0f, 1.0f};
    static float bevel_mat_shininess[] = {40.0f};
    static float bevel_mat_specular[] = {1.0f, 1.0f, 1.0f, 0.0f};
    static float bevel_mat_diffuse[] = {1.0f, 1.0f, 1.0f, 0.0f};

    // Set GL attributes

//    glEnable(GL_CULL_FACE);
    glEnable( GL_SCISSOR_TEST );
    glCullFace(GL_BACK);
    glClearDepth(1.0f);

	glClearColor( bgColor.r, bgColor.g, bgColor.b, bgColor.a );
	glLightfv(GL_LIGHT0, GL_AMBIENT, light0_ambient);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, light0_diffuse);
	glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
	glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
	glEnable(GL_LIGHT0);

	glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lmodel_local);
	glLightModelfv(GL_LIGHT_MODEL_TWO_SIDE, lmodel_twoside);
	glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
	glEnable(GL_LIGHTING);

	glMaterialfv(GL_FRONT, GL_AMBIENT, bevel_mat_ambient);
	glMaterialfv(GL_FRONT, GL_SHININESS, bevel_mat_shininess);
	glMaterialfv(GL_FRONT, GL_SPECULAR, bevel_mat_specular);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, bevel_mat_diffuse);

	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);

	glEnable(GL_COLOR_MATERIAL);

    glEnable( GL_TEXTURE_2D );

    // Setup viewing parameters

    SetView( &winSize );

    // Rendering attributes

    bDepth = FALSE;
    SetDepthMode();

    bLighting = FALSE;
    SetLightingMode();

#if 0
	glShadeModel(GL_SMOOTH);
#else
	glShadeModel(GL_FLAT);
#endif

#ifdef TEST_BITMAP
    bSwapHintsEnabled = FALSE;
#else
    bSwapHintsEnabled = mtk_bAddSwapHintRect();
#endif

    // Update local copies of transforms, so we can calc 2D update rects
//mf: ? protect with bSwapHints ?
    UpdateLocalTransforms( UPDATE_ALL );
}

static HBITMAP LoadBanner()
{
    hdcMem = CreateCompatibleDC( NULL );
    HBITMAP hBanner = LoadBitmap( hLogonInstance,
                                  MAKEINTRESOURCE( IDB_BANNER ) );
    BITMAPINFO bmi = {0};
    bmi.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );

    if( ! GetDIBits( hdcMem, hBanner, 0, 0, NULL, &bmi, DIB_RGB_COLORS ) ) {
        SS_WARNING( "Couldn't get banner bitmap dimensions\n" );
    } else {
        bannerSize.width = bmi.bmiHeader.biWidth;
        bannerSize.height = bmi.bmiHeader.biHeight;
    }
    if( !SelectObject( hdcMem, hBanner ) ) {
        SS_ERROR( "Couldn't select banner into DC\n" );
        return 0;
    }
    return hBanner;

//mf: make hdcMem global, so it and hBanner can be deleted
}

BOOL LoadUserTextures( TEX_RES *pUserTexRes )
{
    SetWindowText( mtkWin->GetHWND(), "Loading textures..." );

    for (int i = 0; i < nLogObj; i++) {
        pLogObj[i]->SetTexture( new TEXTURE( &pUserTexRes[i], 
                                             hLogonInstance ) );
//mf: also validate the textures...
    }

    glFinish();
    SetWindowText( mtkWin->GetHWND(), "" );

    return TRUE;
}

/******************** RunLogonSequence ************************************\
*
\**************************************************************************/

BOOL RunLogonSequence( ENV *pEnv )
{
    BOOL bRet;
    LOG_OBJECT *pSelectedLogObj;

    // Create table of ptrs to LOGOBJ's, which are wrappers around the list of
    // users.  The list of users and their bitmaps, etc, should eventually be
    // a parameter to this function.

    bDebugMode = pEnv->bDebugMode;
    nLogObj = pEnv->nUsers;
    hLogonInstance = pEnv->hInstance;

    pLogObj = (LOG_OBJECT **) malloc( nLogObj * sizeof(LOG_OBJECT *) );

    for( int i = 0; i < nLogObj; i ++ ) {
        pLogObj[i] = new LOG_OBJECT();
    }

    // Create a window to run the logon sequence in

    mtkWin = CreateLogonWindow();

    if( !mtkWin )
        return FALSE; 

    // Do any GL init for the window

    InitGL();
    LoadBanner();
    LoadUserTextures( pEnv->pUserTexRes );

    SetCursor( NULL );
    LoadCursors();

    mtkWin->SetReshapeFunc( Reshape );

    if( bDebugMode ) {
        // The sequences can repeat ad infinitum
        //mf: pretty crazy logic
        while( 1 ) {
            if( !RunLogonInitSequence() )
                // fatal
                break;
run_hot_sequence:
            bRunAgain = FALSE;
            pSelectedLogObj = RunLogonHotSequence();
            if( bRunAgain ) {
                continue;
            }
            if( pSelectedLogObj == NULL )
                // fatal, no obect selected or window was closed
                break;
            if( ! RunLogonEndSequence( pSelectedLogObj ) )
                // fatal
                break;
            if( bRunAgain ) {
                goto run_hot_sequence;
            }
            break;
        }
    } else
    {
        // Normal operation...

//mf: ? check for fatal errors ? or if !debugMode, call Quit whenever
// Exec returns false
        RunLogonInitSequence();
    
        // Run 'hot' sequence, where user selects object
    
        if( !(pSelectedLogObj = RunLogonHotSequence()) ) {
            // No user selected, fatal
            CleanUp();
            return FALSE;
        }

        // Set the selected user index
        for( i = 0; i < nLogObj; i ++ ) {
            if( pSelectedLogObj == pLogObj[i] )
                pEnv->iSelectedUser = i;
        }

        // Run final sequence

        RunLogonEndSequence( pSelectedLogObj );
    }

    // Do various clean-up

    CleanUp();
    return TRUE;
}

void CleanUp()
{
    if( mtkWin )
        mtkWin->Close(); // this will call destructor for mtkWin

    if( bResSwitch )
        mtk_RestoreDisplaySettings();
}

// This function is the FinishFunc callback, and should not be called directly
static void GLFinish()
{
    // Delete textures
//mf: may want to keep the selected one... , depending on what the caller wants
// returned.  Maybe could keep the image data around, and then create a new
// TEXTURE ctor that uses this data...

    for( int i = 0; i < nLogObj; i++ ) {
        if( pLogObj[i]->pTex ) {
            delete pLogObj[i]->pTex;
            pLogObj[i]->pTex = NULL;
        }
    }
}

//mf: this can be called during debug mode, to terminate prematurely
void Quit()
{
    CleanUp();
    mtkQuit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logon.rc
//
#define IDC_HOT_CURSOR                     101
#define IDB_USER0                       102
#define IDB_USER1                       103
#define IDB_USER2                       104
#define IDB_USER3                       105
#define IDB_BANNER                      106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\uidemo.h ===
/******************************Module*Header*******************************\
* Module Name: demo.hxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#ifndef __uidemo_h__
#define __uidemo_h__

extern int Run3DLogon( HINSTANCE hInst );

#endif // __uidemo_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\test.cxx ===
/******************************Module*Header*******************************\
* Module Name: loginit.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "uidemo.hxx"
#include "logon.hxx"
#include "logobj.hxx"

static void InitMotion();

static BOOL
SetNextPos( LOG_OBJECT *pObj )
{
    static float inc = 0.1f;
    static float max = 2.0f;

    pObj->dest[0] += inc;
    pObj->dest[1] += inc;
    if( (pObj->dest[0] > max) ||
        (pObj->dest[1] > max) )
        return FALSE;
    return TRUE;
}

static void DrawTestSequence(void)
{
    int i;
    BOOL bTransitionOver = TRUE;
    float updatesPerSecond;
    LOG_OBJECT *pObj;
    static BOOL bRed = TRUE;

    // Clear current rect of object
    ClearWindow();

    // Calculate next position for each object

    for (i = 0; i < nLogObj; i++) {
        if( bSwapHints )
            // Add current rect of object
            AddSwapHintRect( &pLogObj[i]->rect );

        // SetNextPos returns TRUE if object still moving, else FALSE
        if( SetNextPos( pLogObj[i] ) )
            bTransitionOver = FALSE;
        // Calc new rect for the object
        CalcObjectWindowRect( pLogObj[i] );

        if( bSwapHints )
            // Add new rect of object
            AddSwapHintRect( &pLogObj[i]->rect );
    }

    DrawObjects( FALSE );

#if 0
if( !bRed ) {
//mf: test to make sure swap rects working
    glPushMatrix();
        glColor3f( 0.0f, 1.0f, 0.0f );
        glTranslatef( -3.5f, 0.0f, 0.0f );
        DrawQuad( 0.5f );
    glPopMatrix();
}
#endif

    Flush();

    // Print timing information if required

    if( bDebugMode ) {
        char szMsg[80];
        if( bTransitionOver ) {
            sprintf(szMsg, "%s: %.2lf sec, %s",
                    "Transition time ",
                    transitionTimer.Stop(), "Press <space> to restart" );

            // Print transition timing info in title bar
            SetWindowText( mtkWin->GetHWND(), szMsg );
        } else if( frameRateTimer.Update( 1, &updatesPerSecond ) ) {
            sprintf(szMsg, "%s: %.2lf frames/sec",
                    "",
                    updatesPerSecond );

            // Print frame timing info in title bar
            SetWindowText( mtkWin->GetHWND(), szMsg );
        }
    }

    if( bTransitionOver ) {
        InitMotion(); // start over
    }
    
    bRed = !bRed;
    if( bRed )
        glColor3f( 1.0f, 0.0f, 0.0f ); 
    else
        glColor3f( 0.0f, 0.0f, 1.0f ); 
}

static void
InitMotion()
{
    for (int i = 0; i < nLogObj; i++) {
        pLogObj[i]->Reset();
    }
    MoveObjectsToRestPosition();
}

BOOL RunTestSequence()
{
    SS_DBGPRINT( "RunTestSequence()\n" );

    // Set GL attributes

    glDisable( GL_CULL_FACE );
    glColor3f( 1.0f, 0.0f, 0.0f );
    glDisable( GL_TEXTURE_2D );

    InitMotion();

    // Calc window rects of the quads
    UpdateLocalTransforms( UPDATE_ALL );
    CalcObjectWindowRects();

    // Timers

    if( bDebugMode ) {
        frameRateTimer.Reset();
        frameRateTimer.Start();

        transitionTimer.Reset();
        transitionTimer.Start();
    }

    // Clear window
    ClearAll();

    // Set mtk callbacks

    mtkWin->SetKeyDownFunc(Key);
    mtkWin->SetDisplayFunc( DrawTestSequence );
    mtkWin->SetAnimateFunc( DrawTestSequence );
    return mtkWin->Exec();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\logobj.cxx ===
/**************************************************************************\
*
* Module Name: logon.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <stdlib.h>

#include "logon.hxx"
#include "logobj.hxx"
#include "util.hxx"

static GLIRECT nullRect = {0};

/**************************************************************************\
* LOG_OBJECT
*
*
\**************************************************************************/

//#define DEEP_FRAME 1

LOG_OBJECT::LOG_OBJECT()
{
    pTex = NULL;

    // Set some default size values...

    fImageSize.width = fImageSize.height = OBJECT_WIDTH;
    bShowContext = FALSE; // Only show image to start
    fCurContextWidth = 0.0f;
    fMaxContextWidth = OBJECT_WIDTH / 2.0f;

#if DEEP_FRAME
    fFrameSize.width = fFrameSize.height = FRAME_SIZE;
#else
    fFrameSize.width = fFrameSize.height = 0.0f;
#endif
    bFramed = FALSE;
    // fFrameDepth is depth offset in z-direction.  Since the frame is usually
    // drawn further away from the viewer (down -z axis), it is negative.
#if DEEP_FRAME
    fFrameDepth = - 3.3f;
#else
    fFrameDepth = - FRAME_DEPTH;
#endif
    bSwapHints = FALSE;
    dest[0] = dest[1] = dest[2] = 0.0f;
    ResetMotion();

    rect = nullRect;

    // Calc initial coords

    CalcCoords();
}

LOG_OBJECT::~LOG_OBJECT()
{
}

void    
LOG_OBJECT::ShowFrame( BOOL bShow )
{
    if( bFramed == bShow )
        return;

    // new state
    bFramed = bShow;
    if( bFramed ) {
        // mf : could optimize by not redoing this if framesize constant...
        CalcFrameCoords();
    }
}

void    
LOG_OBJECT::ShowContext( BOOL bShow )
{
    if( bShowContext == bShow )
        return;

    // new state
    bShowContext = bShow;
    CalcCoords();
//mf: !!! readjust dest to reflect this ?
}

void    
LOG_OBJECT::SetDest( float x, float y, float z )
{
    dest[0] = x;
    dest[1] = y;
    dest[2] = z;
}

void    
LOG_OBJECT::SetDest( POINT3D *pDest )
{
    dest[0] = pDest->x;
    dest[1] = pDest->y;
    dest[2] = pDest->z;
}

void    
LOG_OBJECT::GetDest( POINT3D *pDest )
{
    pDest->x = dest[0];
    pDest->y = dest[1];
    pDest->z = dest[2];
}

void
LOG_OBJECT::OffsetDest( float x, float y, float z )
{
    dest[0] += x;
    dest[1] += y;
    dest[2] += z;
}

void    
LOG_OBJECT::SetTexture( TEXTURE *pTexture )
{
    pTex = pTexture;
    if( !pTex )
        return;

    // Set the size of the object based on the aspect ratio of the texture
    // The textures for all the objects should have the same dimensions.

    float aspectRatio = pTex->GetAspectRatio();  // width/height

    // The texture is assumed to have an image on the right, and context on
    // the left, of equal size

    // We'll keep the width consant, and vary height according to aspect

    fImageSize.width = OBJECT_WIDTH / 2.0f;
    fImageSize.height = OBJECT_WIDTH / aspectRatio;
    
    fMaxContextWidth = fImageSize.width;
    fCurContextWidth = fMaxContextWidth;

    CalcCoords();
}

void    
LOG_OBJECT::SetContextSize( float fPortion )
{
    // This sets the visible portion of the context ( 0.0 - 1.0 )

    fCurContextWidth = fPortion * fMaxContextWidth;

    // Recalc coords
    CalcCoords();
}

void    
LOG_OBJECT::SetImageSize( FSIZE *pSize )
{
    fImageSize = *pSize;
    float fPortion = fCurContextWidth / fMaxContextWidth;
    fMaxContextWidth = fImageSize.width;
    fCurContextWidth = fPortion * fMaxContextWidth;
    CalcCoords();
}

void    
LOG_OBJECT::Translate()
{
    glTranslatef(dest[0]+offset[0], dest[1]+offset[1], dest[2]+offset[2]);
}

void    
LOG_OBJECT::Rotate()
{
    if( ang != 0.0f )
    	glRotatef(ang, rotAxis[0], rotAxis[1], rotAxis[2]);
}

void    
LOG_OBJECT::Draw()
{
    Draw( FALSE );
}

void    
LOG_OBJECT::Draw( BOOL bUpdateWinRect )
{
    // Draws object in its current position

    // An object either has its context showing on the right or not.  If not,
    // then origin is the centre of the image, else origin is on border of
    // image and context

    pTex->MakeCurrent(); // Set the objects texture
    glPushMatrix();
        Translate();
        Rotate();
        if( bUpdateWinRect ) {
            UpdateLocalTransforms( UPDATE_MODELVIEW_MATRIX_BIT );
            CalcWinRect( FALSE );
        }
        DrawFace(); 
        if( bFramed )
            DrawFrame();
    glPopMatrix();
    if( bSwapHints )
        AddSwapHintRect( &rect );
}

void
LOG_OBJECT::DrawFace()
{
    glNormal3f( 0.0f, 0.0f, 1.0f );
    glBegin( GL_QUADS );
        glTexCoord2fv( (float *) &texPoint[0] );
        glVertex2fv(   (float *) &point[0] );
        glTexCoord2fv( (float *) &texPoint[1] );
        glVertex2fv(   (float *) &point[1] );
        glTexCoord2fv( (float *) &texPoint[2] );
        glVertex2fv(   (float *) &point[2] );
        glTexCoord2fv( (float *) &texPoint[3] );
        glVertex2fv(   (float *) &point[3] );
    glEnd();
}

void
LOG_OBJECT::DrawFrame()
{
    glDisable( GL_TEXTURE_2D );
    glEnable( GL_LIGHTING );

    glBegin( GL_QUADS );

        glNormal3fv( (float *) &frameNormal[0] );
        glVertex3fv( (float *) &point[0] );
        glVertex3fv( (float *) &point[4] );
        glVertex3fv( (float *) &point[7] );
        glVertex3fv( (float *) &point[3] );

        glNormal3fv( (float *) &frameNormal[1] );
        glVertex3fv( (float *) &point[1] );
        glVertex3fv( (float *) &point[5] );
        glVertex3fv( (float *) &point[4] );
        glVertex3fv( (float *) &point[0] );

        glNormal3fv( (float *) &frameNormal[2] );
        glVertex3fv( (float *) &point[2] );
        glVertex3fv( (float *) &point[6] );
        glVertex3fv( (float *) &point[5] );
        glVertex3fv( (float *) &point[1] );

        glNormal3fv( (float *) &frameNormal[3] );
        glVertex3fv( (float *) &point[3] );
        glVertex3fv( (float *) &point[7] );
        glVertex3fv( (float *) &point[6] );
        glVertex3fv( (float *) &point[2] );

    glEnd();

    glDisable( GL_LIGHTING );
    glEnable( GL_TEXTURE_2D );
}

void    
LOG_OBJECT::CalcWinRect()
{
    CalcWinRect( TRUE );
}

void    
LOG_OBJECT::CalcWinRect( BOOL bTransform )
{
    POINT3D ptOut[8];
    int nPts = bFramed ? 8 : 4;

    if( bTransform ) {
        // Need to transorm object according to current translation & rotation
        glPushMatrix();
            Translate();
            Rotate();
            UpdateLocalTransforms( UPDATE_MODELVIEW_MATRIX_BIT );
        glPopMatrix();
    }

    TransformObjectToWindow( point, ptOut, nPts );

    // Update the rect member
    CalcMinMaxRect( ptOut, &rect, nPts );
}

void    
LOG_OBJECT::CalcCoords()
{
    POINT3D *pt;

    // Calculate object coords based on current state of the object.  If
    // bShowContext, then origin is in centre of object, else it's in centre
    // of image part of object.
    // Also calculate frame coords if applicable.

    // Points are ordered CCW from top right for each face

    pt = point;
    pt[0].z = pt[1].z = pt[2].z = pt[3].z = 0.0f;

    // Calc front face points

    if( ! bShowContext ) {
        POINT2D image =  { fImageSize.width / 2.0f, fImageSize.height / 2.0f };

        pt[0].x =  image.x;
        pt[0].y =  image.y;
        pt[1].x = -image.x;
        pt[1].y =  image.y;
        pt[2].x = -image.x;
        pt[2].y = -image.y;
        pt[3].x =  image.x;
        pt[3].y = -image.y;
    } else {
        POINT2D image =  { fImageSize.width, fImageSize.height / 2.0f };

        pt[0].x =  image.x;
        pt[0].y =  image.y;
        pt[1].x = -fCurContextWidth;
        pt[1].y =  image.y;
        pt[2].x = -fCurContextWidth;
        pt[2].y = -image.y;
        pt[3].x =  image.x;
        pt[3].y = -image.y;
    }

    // Calc frame points

    if( bFramed ) {
        CalcFrameCoords();
    }

    // Always need the texture coords
//mf: optimize...
    CalcTexCoords();
}

void    
LOG_OBJECT::CalcFrameCoords()
{
    POINT3D *frontPt = point;
    POINT3D *pt = point + 4;

    pt[0].z = pt[1].z = pt[2].z = pt[3].z = fFrameDepth;

    pt[0].x =  frontPt[0].x + fFrameSize.width;
    pt[0].y =  frontPt[0].y + fFrameSize.height;
    pt[1].x =  frontPt[1].x - fFrameSize.width;
    pt[1].y =  frontPt[1].y + fFrameSize.height;
    pt[2].x =  frontPt[2].x - fFrameSize.width;
    pt[2].y =  frontPt[2].y - fFrameSize.height;
    pt[3].x =  frontPt[3].x + fFrameSize.width;
    pt[3].y =  frontPt[3].y - fFrameSize.height;

    // May as well do the normals too
    CalcFrameNormals();
}

void    
LOG_OBJECT::CalcFrameNormals()
{
    POINT3D *pNorm = frameNormal;

    float fDepth = fFrameDepth;
    float fFramex = fFrameSize.width;
    float fFramey = fFrameSize.height;

    // Calc the face normals for the sides of the frame.  The faces are
    // ordered CCW from the right face.

    float norm1 = (float) fabs( fDepth );

    pNorm[0].x = norm1;
    pNorm[0].y = 0.0f;
    pNorm[0].x = fFramex;

    pNorm[1].x = 0.0f;
    pNorm[1].y = norm1;
    pNorm[1].x = fFramey;

    pNorm[0].x = -norm1;
    pNorm[0].y = 0.0f;
    pNorm[0].x = fFramex;

    pNorm[1].x = 0.0f;
    pNorm[1].y = -norm1;
    pNorm[1].x = fFramey;

    mtk_NormalizePoints( pNorm, 4 );
}

void    
LOG_OBJECT::CalcTexCoords()
{
    // Calculate texture coords based on current state of the object.

    // The texture spans across the front face, and includes the image on right,
    // and context on left.  The 't' coords are constant, but the 's' coord
    // varies, depending on if or how much context is shown.

    // Again, points are ordered CCW from top right for each face

    // Calc ratio of image over total width of object
    float ratio = fImageSize.width / (fImageSize.width + fMaxContextWidth);

    float sStart = 1.0f - ratio;

    if( bShowContext ) {
        sStart -= (fCurContextWidth / fMaxContextWidth) * (1.0f - ratio);
    }

    texPoint[0].s = texPoint[3].s = 1.0f;
    texPoint[1].s = texPoint[2].s = sStart;

    texPoint[0].t = texPoint[1].t = 1.0f;
    texPoint[2].t = texPoint[3].t = 0.0f;
}

void    
LOG_OBJECT::GetRect( GLIRECT *pRect )
{
    *pRect = rect;
}

#if 0
void    
LOG_OBJECT::GetPos( POINT3D *curpos )
{
    float *fpos = (float *) curpos;

    for( int i = 0; i < 3; i ++ )
        fpos[i] = dest[i] + offset[i];
}
#endif

/**************************************************************************\
* NextFlyIteration
*
* Calcs next offset and angle for a 'fly'sequence
*
\**************************************************************************/

BOOL
LOG_OBJECT::NextFlyIteration()
{
    int i;

	if( !iter ) {
        // Done iterating
        return FALSE;
    }

    // Calculate new iterations
    for (i = 0; i < 3; i++) {
        offset[i] = Clamp( iter,  offset[i] );
    }
	ang = Clamp( iter,  ang);
	iter--;

    return TRUE;
}

/**************************************************************************\
* ResetMotion
*
* Resets all position and motion params to 0
*
\**************************************************************************/

void
LOG_OBJECT::ResetMotion()
{
    offset[0] = offset[1] = offset[2] = 0.0f;
    rotAxis[0] = rotAxis[1] = rotAxis[2] = 0.0f;
    ang = 0.0f;
    iter = 0;
}

/**************************************************************************\
*
* Ranomnly chooses motion params for a fly sequence
*
* The motion is 'damped', since near the end of the fly sequence the object
* is constrained to 0 rotation and the dest[] position
*
\**************************************************************************/


void
LOG_OBJECT::SetDampedFlyMotion( float deviation )
{
    SetDampedFlyMotion( deviation, NULL );
}

void
LOG_OBJECT::SetDampedFlyMotion( float deviation, POINT3D *pOffset )
{
    if( pOffset ) {
        // Use supplied offset
        offset[0] = pOffset->x;
       	offset[1] = pOffset->y;
       	offset[2] = pOffset->z;
    } else {
        // Calc a random offset
        offset[0] = MyRand();
       	offset[1] = MyRand();
       	offset[2] = MyRand();
    }

	ang = 260.0f * MyRand();

   	rotAxis[0] = MyRand();
   	rotAxis[1] = MyRand();
	rotAxis[2] = MyRand();
   	iter = (int) (deviation * MyRand() + 60.0f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\uidemo.cxx ===
/******************************Module*Header*******************************\
* Module Name: uidemo.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>
#include <time.h>

#include "uidemo.hxx"
#include "resource.h"

// global mocked up environment
ENV *pEnv;

BOOL    bContextMode = FALSE;

#define OBJECTS 4

TEX_RES texRes[OBJECTS] =
{
    {TEX_BMP, IDB_USER0},
    {TEX_BMP, IDB_USER1},
    {TEX_BMP, IDB_USER2},
    {TEX_BMP, IDB_USER3}
};

/**************************************************************************\
* ENV
*
\**************************************************************************/

ENV::ENV(int argc, char **argv)
{
    GLint i;

    // Process command line arguments

    bDebugMode = FALSE;

    for (i = 1; i < argc; i++) {
	if (strcmp(argv[i], "-d") == 0) {
	    bDebugMode = GL_TRUE;
	} else if (strcmp(argv[i], "-c") == 0) {
	    bContextMode = GL_TRUE;
	} else {
	    printf("%s (Bad option).\n", argv[i]);
	}
    }

    // Initial setup : load texture file, etc.

    nUsers = OBJECTS;
    SS_ASSERT( nUsers <= MAX_USERS, "Too many users\n" );

    iSelectedUser = -1;
    pUserTexRes   = texRes;
    hInstance = GetModuleHandle( NULL );
}

ENV::ENV()
{
    bDebugMode = FALSE;

    nUsers = OBJECTS;
    SS_ASSERT( nUsers <= MAX_USERS, "Too many users\n" );

    iSelectedUser = -1;
    pUserTexRes   = texRes;
}

ENV::~ENV()
{
}

//mf: since called by c file
extern "C"
int Run3DLogon( HINSTANCE hInst )
{
    pEnv = new ENV();
    if( !pEnv )
        return -1;

    pEnv->hInstance = hInst;
    RunLogonSequence( pEnv );
    return pEnv->iSelectedUser;
}

/**************************************************************************\
* main
*
\**************************************************************************/

void main(int argc, char **argv)
{

    // Create global environment, using cmd line arguments.
    // This is a mocked up environment, similar to what RunLogonSequence()
    // should really be called with

    pEnv = new ENV( argc, argv );
    if( !pEnv )
        return;

#if 1
#if 0
    if( bContextMode )
        // Do context menu
        RunContextMenuSequence( pEnv );
    else
#endif
    // This opens the window, runs logon sequence, and closes window
        //mf: This should return the chosen logon object...
        RunLogonSequence( pEnv );
#else
//mf: try running both !
        RunLogonSequence( pEnv );

        RunContextMenuSequence( pEnv );
#endif


    delete pEnv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\buffers.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <memory.h>
#include <gl/gl.h>

#include "buffers.h"
#include "hugetest.h"
#include "resource.h"
#include "ui_huge.h"
#include "macros.h"

void InitBD(BUFFERDATA *pbd)
{
   bzero(pbd,sizeof(BUFFERDATA));
   BEGINstring(pbd, "buffer");
   ENDstring(pbd,   "buffer");
   
   pbd->uiClear    =  0;
   
   pbd->cColorBits =  8;        // # of bits of color per pixel
   pbd->fClearColor[0] = 1.0;
   pbd->fClearColor[1] = 1.0;
   pbd->fClearColor[2] = 1.0;
   pbd->fClearColor[3] = 0.0;
   
   pbd->cDepthBits = 16;        // # of bits in z-buffer
   pbd->bDepthTestEnable = FALSE;
   pbd->iDepthFunction   = LESS;
   
   pbd->bStencilEnable   = FALSE;
   pbd->bAccumEnable     = FALSE;

   pbd->iShadeModel  = FLAT;
   pbd->bNormalize   = FALSE;
   pbd->bAutoNormal  = FALSE;
}

void buffers_init(const BUFFERDATA bd)
{
   switch (bd.iShadeModel) {
   case SMOOTH: glShadeModel(GL_SMOOTH); break; // 0
   case FLAT:   glShadeModel(GL_FLAT);   break; // 1
   }
   
   GL_EnableOrDisable(bd.bNormalize,  GL_NORMALIZE);
   GL_EnableOrDisable(bd.bAutoNormal, GL_AUTO_NORMAL);
   
   if (bd.bDepthTestEnable) {
      glEnable(GL_DEPTH_TEST);
      switch (bd.iDepthFunction) {
      case 0: glDepthFunc(GL_NEVER);    break;
      case 1: glDepthFunc(GL_ALWAYS);   break;
      case 2: glDepthFunc(GL_LESS);     break;
      case 3: glDepthFunc(GL_LEQUAL);   break;
      case 4: glDepthFunc(GL_EQUAL);    break;
      case 5: glDepthFunc(GL_GEQUAL);   break;
      case 6: glDepthFunc(GL_GREATER);  break;
      case 7: glDepthFunc(GL_NOTEQUAL); break;
      }
   } else {
      glDisable(GL_DEPTH_TEST);
   }
   
   if (bd.bStencilEnable) {
      glEnable(GL_STENCIL_TEST);
   } else {
      glDisable(GL_STENCIL_TEST);
   }
}

#ifndef NO_UI_IN_CNFG

void buffers_SetDisplayFromData(HWND hDlg, const BUFFERDATA *pbd)
{
   CheckDlgButton(hDlg,B_IDC_CLEAR_COLOR,
                  (pbd->uiClear&GL_COLOR_BUFFER_BIT)?1:0);
   CheckDlgButton(hDlg,B_IDC_CLEAR_DEPTH,
                  (pbd->uiClear&GL_DEPTH_BUFFER_BIT)?1:0);
   CheckDlgButton(hDlg,B_IDC_CLEAR_STENCIL,
                  (pbd->uiClear&GL_STENCIL_BUFFER_BIT)?1:0);
   CheckDlgButton(hDlg,B_IDC_CLEAR_ACCUM,
                  (pbd->uiClear&GL_ACCUM_BUFFER_BIT)?1:0);
   
   SetDlgItemInt(hDlg,B_IDC_COLORBITS,pbd->cColorBits,FALSE);
   SetDlgFloatString(hDlg, B_IDC_COLOR1, pbd->fClearColor[0]);
   SetDlgFloatString(hDlg, B_IDC_COLOR2, pbd->fClearColor[1]);
   SetDlgFloatString(hDlg, B_IDC_COLOR3, pbd->fClearColor[2]);
   SetDlgFloatString(hDlg, B_IDC_COLOR4, pbd->fClearColor[3]);
   
   SetDlgItemInt  (hDlg, B_IDC_DEPTHBITS,    pbd->cDepthBits,FALSE);
   CheckDlgButton (hDlg, B_IDC_ENABLE_DEPTH, pbd->bDepthTestEnable?1:0);
   CB_DlgSetSelect(hDlg, B_IDC_DEPTH_FUNC,   pbd->iDepthFunction);
   
   CheckDlgButton(hDlg,  B_IDC_ENABLE_STENCIL, pbd->bStencilEnable?1:0);
   
   CB_DlgSetSelect(hDlg, B_IDC_SHADE_MODEL,    pbd->iShadeModel);
   CheckDlgButton(hDlg,  B_IDC_NORMALIZE,      pbd->bNormalize?1:0);
   CheckDlgButton(hDlg,  B_IDC_AUTO_NORMAL,    pbd->bAutoNormal?1:0);
}

void buffers_GetDataFromDisplay(HWND hDlg, BUFFERDATA *pbd)
{
   pbd->uiClear     = 0;
   pbd->uiClear    |= (IsDlgButtonChecked(hDlg,B_IDC_CLEAR_COLOR)
                       ? GL_COLOR_BUFFER_BIT : 0);
   pbd->uiClear    |= (IsDlgButtonChecked(hDlg,B_IDC_CLEAR_DEPTH)
                       ? GL_DEPTH_BUFFER_BIT : 0);
   pbd->uiClear    |= (IsDlgButtonChecked(hDlg,B_IDC_CLEAR_STENCIL)
                       ? GL_STENCIL_BUFFER_BIT : 0);
   pbd->uiClear    |= (IsDlgButtonChecked(hDlg,B_IDC_CLEAR_ACCUM)
                       ? GL_ACCUM_BUFFER_BIT : 0);
   
   pbd->cColorBits     = GetDlgItemInt(hDlg, B_IDC_COLORBITS, NULL, FALSE);
   pbd->fClearColor[0] = GetDlgFloatString(hDlg, B_IDC_COLOR1);
   pbd->fClearColor[1] = GetDlgFloatString(hDlg, B_IDC_COLOR2);
   pbd->fClearColor[2] = GetDlgFloatString(hDlg, B_IDC_COLOR3);
   pbd->fClearColor[3] = GetDlgFloatString(hDlg, B_IDC_COLOR4);
   
   pbd->cDepthBits       = GetDlgItemInt(hDlg, B_IDC_DEPTHBITS, NULL, FALSE);
   pbd->bDepthTestEnable = (BOOL) IsDlgButtonChecked(hDlg,B_IDC_ENABLE_DEPTH);
   pbd->iDepthFunction   = CB_DlgGetSelect(hDlg, B_IDC_DEPTH_FUNC);
   
   pbd->bStencilEnable  = (BOOL) IsDlgButtonChecked(hDlg,B_IDC_ENABLE_STENCIL);
   
   pbd->iShadeModel  = CB_DlgGetSelect(hDlg,   B_IDC_SHADE_MODEL);
   pbd->bNormalize   = (BOOL) IsDlgButtonChecked(hDlg,B_IDC_NORMALIZE);
   pbd->bAutoNormal  = (BOOL) IsDlgButtonChecked(hDlg,B_IDC_AUTO_NORMAL);
}

BOOL CALLBACK hugeBufferDlgProc(HWND hDlg, UINT msg,
                               WPARAM wParam, LPARAM lParam)
{
   static BUFFERDATA *pbd = NULL;
   switch (msg)
      {
      case WM_INITDIALOG:
         pbd = (BUFFERDATA*) (((PROPSHEETPAGE*)lParam)->lParam);
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Never");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Always");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Less");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Less or Equal");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Equal");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Greater or Equal");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Greater");
         CB_DlgAddString(hDlg, B_IDC_DEPTH_FUNC, "Not Equal");
         CB_DlgAddString(hDlg, B_IDC_SHADE_MODEL, "Smooth");
         CB_DlgAddString(hDlg, B_IDC_SHADE_MODEL, "Flat");
         buffers_SetDisplayFromData(hDlg, pbd);
         return TRUE;

      case WM_COMMAND:
         {
            int iControl, iNote;
            iControl = LOWORD(wParam);
            iNote = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case B_IDC_COLORBITS:      // don't mess with display
               case B_IDC_DEPTHBITS:      // while editing text
               case B_IDC_COLOR1:
               case B_IDC_COLOR2:
               case B_IDC_COLOR3:
               case B_IDC_COLOR4:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  buffers_GetDataFromDisplay(hDlg, pbd);
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\misc\uidemo\util.cxx ===
/******************************Module*Header*******************************\
* Module Name: util.cxx
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <math.h>
#include <sys/types.h>
#include <stdlib.h>

#include "mtk.hxx"
#include "util.hxx"

GLuint defaultQuad; // display list for quad

// Local copies of tranf. matrices, for determing rect bounds
static  GLdouble    modelMatrix[16];
static  GLdouble    projMatrix[16];
static  GLint       viewport[4];

/**************************************************************************\
*
\**************************************************************************/


void
UpdateLocalTransforms( int bits )
{
    // Get current transformation info
    if( bits & UPDATE_MODELVIEW_MATRIX_BIT )
        glGetDoublev( GL_MODELVIEW_MATRIX, modelMatrix );
    if( bits & UPDATE_PROJECTION_MATRIX_BIT )
        glGetDoublev( GL_PROJECTION_MATRIX, projMatrix );
    if( bits & UPDATE_VIEWPORT_BIT )
        glGetIntegerv( GL_VIEWPORT, viewport );
}

void
TransformObjectToWindow( POINT3D *pIn, POINT3D *pOut, int nPts )
{
    DPOINT3D outD;

    for( ; nPts; nPts--, pIn++, pOut++ ) {
        gluProject( pIn->x, pIn->y, pIn->z,
                    modelMatrix, projMatrix, viewport,
                    &outD.x, &outD.y, &outD.z );
        pOut->x = (float) outD.x;
        pOut->y = (float) outD.y;
        pOut->z = (float) outD.z;
    }
}

void
TransformWindowToObject( POINT3D *pIn, POINT3D *pOut )
{
    DPOINT3D outD;

    gluUnProject( pIn->x, pIn->y, pIn->z,
                modelMatrix, projMatrix, viewport,
                &outD.x, &outD.y, &outD.z );
    pOut->x = (float) outD.x;
    pOut->y = (float) outD.y;
    pOut->z = (float) outD.z;
}

void
DrawRect( FSIZE *fSize )
{
    float w = fSize->width / 2.0f;
    float h = fSize->height / 2.0f;

    glNormal3f( 0.0f, 0.0f, 1.0f );
    glBegin( GL_QUADS );
        glTexCoord2f( 1.0f, 1.0f );
        glVertex3f(  w,  h, 0.0f );
        glTexCoord2f( 0.0f, 1.0f );
        glVertex3f( -w,  h, 0.0f );
        glTexCoord2f( 0.0f, 0.0f );
        glVertex3f( -w, -h, 0.0f );
        glTexCoord2f( 1.0f, 0.0f );
        glVertex3f(  w, -h, 0.0f );
    glEnd();
}

void
AddSwapHintRect( GLIRECT *pRect )
{
    glAddSwapHintRect( pRect->x, pRect->y, pRect->width, pRect->height );
}

#define BloatRect( pRect, n ) \
    pRect->x -= n;    \
    pRect->y -= n;    \
    pRect->width += (n << 2); \
    pRect->height+= (n << 2);

// Calculate the 2d view rect, using view parameters and window size.  The
// rect is in the z=0 plane.

// Calculate the 2d window rect for each log object

// !!! Assumes no rotation of the object !!!


void 
CalcRect( POINT3D *pbl, POINT3D *ptr, GLIRECT *pRect )
{
    //mf: check for inclusive/exclusive and rounding problems
// 1) truncate both
    pRect->x = (int) (pbl->x);
    pRect->y = (int) (pbl->y);
    pRect->width =  ((int) (ptr->x )) - pRect->x + 1;
    pRect->height = ((int) (ptr->y )) - pRect->y + 1;

    //mf: while this works for polygons, it does not work for lines, since
    // the rasterization rules are different for lines.  Lines can be off by
    // +1, so bloat the box by 1 on all sides.
    BloatRect( pRect, 1 );
}

// Calcs window rects for the objects at REST (pObj->dest)


void
CalcMinMaxRect( POINT3D *pts, GLIRECT *pRect, int nPts )
{
    POINT2D min, max;

    // Use first point to init min,max
    min.x = max.x = pts->x;
    min.y = max.y = pts->y;
    nPts--; 
    pts++;

    for( ; nPts; nPts--, pts++ ) {
        if( pts->x < min.x )
            min.x = pts->x;
        if( pts->x > max.x )
            max.x = pts->x;
        if( pts->y < min.y )
            min.y = pts->y;
        if( pts->y > max.y )
            max.y = pts->y;
    }

    pRect->x = (int) (min.x);
    pRect->y = (int) (min.y);
    pRect->width =  ((int) max.x) - pRect->x + 1;
    pRect->height = ((int) max.y) - pRect->y + 1;

    BloatRect( pRect, 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\buffers.h ===
#ifndef BUFFERS_H
#define BUFFERS_H

typedef unsigned char  uchar,  u_char, byte;
typedef unsigned short ushort, u_short;
typedef unsigned long  ulong,  u_long;
typedef unsigned int   uint,   u_int;

typedef enum { SMOOTH, FLAT } ShadeModelType;
typedef enum { NEVER, ALWAYS, LESS, LEQUAL, EQUAL, GEQUAL, GREATER, NOTEQUAL } DepthTestsType;


typedef struct {
   char    acDummy1[16];
   uint    uiClear;             // GL_COLOR_BUFFER_BIT   | GL_DEPTH_BUFFER_BIT
                                // GL_STENCIL_BUFFER_BIT | GL_ACCUM_BUFFER_BIT
   
   byte    cColorBits;          // # of bits of color per pixel
   GLfloat fClearColor[4];
   
   byte    cDepthBits;          // # of bits in z-buffer
   BOOL    bDepthTestEnable;
   int     iDepthFunction;
   
   BOOL    bStencilEnable;
   BOOL    bAccumEnable;
   
   int     iShadeModel;
   BOOL    bNormalize;
   BOOL    bAutoNormal;
   char    acDummy2[16];
} BUFFERDATA;

void InitBD(BUFFERDATA *pbd);
void buffers_init(BUFFERDATA bd);

#endif // BUFFERS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\fog.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include "hugetest.h"
#include "resource.h"
#include "ui_huge.h"
#include "macros.h"

void InitFD(FOGDATA *pfd)
{
   bzero(pfd,sizeof(FOGDATA));
   BEGINstring(pfd, "fog");
   ENDstring(pfd,   "fog");
   pfd->fColor[0]    = 0.0;
   pfd->fColor[1]    = 0.0;
   pfd->fColor[2]    = 0.0;
   pfd->fColor[3]    = 1.0;
   pfd->fDensity     = 0.5;
   pfd->fLinearStart = 1.0;
   pfd->fLinearEnd   = 0.0;
   pfd->bEnable      = FALSE;
   pfd->iMode        = FOG_EXP;   // == Exp
   pfd->iQuality     = DONT_CARE; // == Don't Care
}

void fog_init(const FOGDATA fd)
{
   if (!fd.bEnable) {
      glDisable(GL_FOG);
      return;
   }
   glEnable(GL_FOG);
   switch(fd.iMode) {
   case 0: glFogi (GL_FOG_MODE, GL_EXP);    break;
   case 1: glFogi (GL_FOG_MODE, GL_EXP2);   break;
   case 2: glFogi (GL_FOG_MODE, GL_LINEAR); break;
   }
   glFogf (GL_FOG_START,   fd.fLinearStart);
   glFogf (GL_FOG_END,     fd.fLinearEnd);
   glFogfv(GL_FOG_COLOR,   fd.fColor);
   glFogf (GL_FOG_DENSITY, fd.fDensity);
   switch (fd.iQuality) {
   case FASTEST:   glHint(GL_FOG_HINT, GL_FASTEST);   break;
   case DONT_CARE: glHint(GL_FOG_HINT, GL_DONT_CARE); break;
   case NICEST:    glHint(GL_FOG_HINT, GL_NICEST);    break;
   }
}

#ifndef NO_UI_IN_CNFG

void fog_SetDisplayFromData(HWND hDlg, const FOGDATA *pfd)
{
   SetDlgFloatString(hDlg, F_IDC_COLOR1,     pfd->fColor[0]);
   SetDlgFloatString(hDlg, F_IDC_COLOR2,     pfd->fColor[1]);
   SetDlgFloatString(hDlg, F_IDC_COLOR3,     pfd->fColor[2]);
   SetDlgFloatString(hDlg, F_IDC_COLOR4,     pfd->fColor[3]);
   SetDlgFloatString(hDlg, F_IDC_DENSITY,    pfd->fDensity);
   SetDlgFloatString(hDlg, F_IDC_LINEARSTART,pfd->fLinearStart);
   SetDlgFloatString(hDlg, F_IDC_LINEAREND,  pfd->fLinearEnd);
   CheckDlgButton(hDlg,    IDC_ENABLE,       pfd->bEnable?1:0);
   CB_DlgSetSelect(hDlg,   F_IDC_MODE,       pfd->iMode);
   CB_DlgSetSelect(hDlg,   F_IDC_QUALITY,    pfd->iQuality);
}

void fog_GetDataFromDisplay(HWND hDlg, FOGDATA *pfd)
{
   pfd->fColor[0]    = GetDlgFloatString(hDlg, F_IDC_COLOR1);
   pfd->fColor[1]    = GetDlgFloatString(hDlg, F_IDC_COLOR2);
   pfd->fColor[2]    = GetDlgFloatString(hDlg, F_IDC_COLOR3);
   pfd->fColor[3]    = GetDlgFloatString(hDlg, F_IDC_COLOR4);
   pfd->fDensity     = GetDlgFloatString(hDlg, F_IDC_DENSITY);
   pfd->fLinearStart = GetDlgFloatString(hDlg, F_IDC_LINEARSTART);
   pfd->fLinearEnd   = GetDlgFloatString(hDlg, F_IDC_LINEAREND);
   pfd->bEnable      = IsDlgButtonChecked(hDlg,IDC_ENABLE);
   pfd->iMode        = CB_DlgGetSelect(hDlg,   F_IDC_MODE);
   pfd->iQuality     = CB_DlgGetSelect(hDlg,   F_IDC_QUALITY);
}

void fog_EnableOrDisableWindows(HWND hDlg)
{
   static int aiCommands[] =
   { F_IDC_COLOR1,    F_IDC_COLOR2,     F_IDC_COLOR3,      F_IDC_COLOR4,
     F_IDC_DENSITY,   F_IDC_LINEAREND,  F_IDC_LINEARSTART, F_IDC_MODE,
     F_IDC_QUALITY };
   const int iNumCommands = 9;
   BOOL b;
   int i;
   
   b = (BOOL) IsDlgButtonChecked(hDlg, IDC_ENABLE);
   for (i = 0 ; i < iNumCommands ; i++) {
      EnableWindow(GetDlgItem(hDlg,aiCommands[i]),b);
   }
}

BOOL CALLBACK hugeFogDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   static FOGDATA *pfd = NULL;
   
   switch (msg)
      {
      case WM_INITDIALOG:
         pfd = (FOGDATA*) (((PROPSHEETPAGE*)lParam)->lParam);
         CB_DlgAddString(hDlg, F_IDC_MODE, "Exp");
         CB_DlgAddString(hDlg, F_IDC_MODE, "Exp2");
         CB_DlgAddString(hDlg, F_IDC_MODE, "Linear");
         CB_DlgAddString(hDlg, F_IDC_QUALITY, "Fastest");
         CB_DlgAddString(hDlg, F_IDC_QUALITY, "Don't Care");
         CB_DlgAddString(hDlg, F_IDC_QUALITY, "Nicest");
         fog_SetDisplayFromData(hDlg,pfd);
         fog_EnableOrDisableWindows(hDlg);
         return TRUE;

      case WM_COMMAND:
         {
            int iControl, iNote;
            iControl = LOWORD(wParam);
            iNote    = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case IDC_ENABLE:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  fog_EnableOrDisableWindows(hDlg);
                  break;

               case F_IDC_COLOR1:
               case F_IDC_COLOR2:
               case F_IDC_COLOR3:
               case F_IDC_COLOR4:
               case F_IDC_DENSITY:
               case F_IDC_LINEAREND:
               case F_IDC_LINEARSTART:
               case F_IDC_MODE:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  fog_GetDataFromDisplay(hDlg, pfd);
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\fog.h ===
#ifndef FOG_H
#define FOG_H

typedef enum { FOG_EXP, FOG_EXP2, FOG_LINEAR } FogModeType;

typedef struct {
   char    acDummy1[16];
   BOOL    bEnable;
   GLfloat fColor[4];
   GLfloat fDensity;
   GLfloat fLinearStart, fLinearEnd;
   int     iMode;
   int     iQuality;
   char    acDummy2[16];
} FOGDATA;

void InitFD(FOGDATA *pfd);
void fog_init(FOGDATA fd);

#endif // FOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\hugetest.h ===
#ifndef HUGETEST_H
#define HUGETEST_H

#include "skeltest.h"
#include "fog.h"
#include "raster.h"
#include "texture.h"
#include "lighting.h"

typedef enum { FASTEST, DONT_CARE, NICEST } QualityType;

class HugeTest : public SkeletonTest
{
private:
   typedef SkeletonTest parent;

public:
   HugeTest();
   ~HugeTest() {};
   
   virtual void INITFUNCTION();
   virtual void RENDFUNCTION();
   
   virtual int Save(HANDLE hFile);
   virtual int Load(HANDLE hFile);

protected:
   GLfloat afDrawColor[3];
   struct {
      GLfloat fxMin, fxMax, fyMin, fyMax, fzMin, fzMax;
   } range;
   
   FOGDATA      fd;
   RASTERDATA   rd;
   LIGHTINGDATA ld;
   TEXTUREDATA  xd;

private:
   void UI_init();
};

#endif // HUGETEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\large1.h ===
#ifndef LARGE_TRIANGLE_TEST_H
#define LARGE_TRIANGLE_TEST_H

class LargeTriangle : public SkeletonTest
{
private:
   typedef SkeletonTest parent;

public:
   LargeTriangle();
   
   virtual void INITFUNCTION();
   virtual void IDLEFUNCTION();
   virtual void RENDFUNCTION();

private:
   GLfloat fWindowWidth;
   GLfloat fWindowHeight;
   GLfloat fClr1, fClr2, fClr3, fClr4, fClr5, fClr6;
};

#endif // LARGE_TRIANGLE_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\hugetest.cpp ===
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>

#include "skeltest.h"
#include "hugetest.h"
#include "ui_huge.h"

HugeTest::HugeTest()
{
   SetThisType("Huge");
   SetThisVersion("1.0");
   
   td.swapbuffers = TRUE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName,"Huge");
   bd.uiClear = 0;
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;
   
   InitFD(&fd);
   InitRD(&rd);
   InitLD(&ld);
   InitXD(&xd);
   
   afDrawColor[0] = 0.0;
   afDrawColor[1] = 1.0;
   afDrawColor[2] = 0.0;
   
   range.fxMin =   0;
   range.fxMax = 640;
   range.fyMin =   0;
   range.fyMax = 480;
   range.fzMin =  -1;
   range.fzMax =   1;
   
   UI_init();
} // HugeTest::HugeTest();

int HugeTest::Save(HANDLE hFile)
{
   ulong ul,p;
   
   p = parent::Save(hFile);
   if (p < 0) return p;
   
   ul = 0;
   if (!WriteFile(hFile, (void*) &afDrawColor, sizeof(afDrawColor), &ul, NULL))
      return -2;
   if (ul != sizeof(afDrawColor)) return -2;
   if (!WriteFile(hFile, (void*) &range, sizeof(range), &ul, NULL))
      return -2;
   if (ul != sizeof(range)) return -2;
   if (!WriteFile(hFile, (void*) &fd, sizeof(fd), &ul, NULL))
      return -2;
   if (ul != sizeof(fd)) return -2;
   if (!WriteFile(hFile, (void*) &rd, sizeof(rd), &ul, NULL))
      return -2;
   if (ul != sizeof(rd)) return -2;
   if (!WriteFile(hFile, (void*) &ld, sizeof(ld), &ul, NULL))
      return -2;
   if (ul != sizeof(ld)) return -2;
   if (!WriteFile(hFile, (void*) &xd, sizeof(xd), &ul, NULL))
      return -2;
   if (ul != sizeof(xd)) return -2;
   FlushFileBuffers(hFile);
   return p + sizeof(afDrawColor) + sizeof(range) + sizeof(fd)
      + sizeof(rd) + sizeof(ld);
}

int HugeTest::Load(HANDLE hFile)
{
   ulong ul,p;
   
   p = parent::Load(hFile);
   if (p < 0) return p;
   
   ul = 0;
   if (!ReadFile(hFile, (void*) &afDrawColor, sizeof(afDrawColor), &ul, NULL))
      return -2;
   if (ul != sizeof(afDrawColor)) return -2;
   if (!ReadFile(hFile, (void*) &range, sizeof(range), &ul, NULL))
      return -2;
   if (ul != sizeof(range)) return -2;
   if (!ReadFile(hFile, (void*) &fd, sizeof(fd), &ul, NULL))
      return -2;
   if (ul != sizeof(fd)) return -2;
   if (!ReadFile(hFile, (void*) &rd, sizeof(rd), &ul, NULL))
      return -2;
   if (ul != sizeof(rd)) return -2;
   if (!ReadFile(hFile, (void*) &ld, sizeof(ld), &ul, NULL))
      return -2;
   if (ul != sizeof(ld)) return -2;
   if (!ReadFile(hFile, (void*) &xd, sizeof(xd), &ul, NULL))
      return -2;
   if (ul != sizeof(xd)) return -2;
   return  p + sizeof(afDrawColor) + sizeof(range) + sizeof(fd)
      + sizeof(rd) + sizeof(ld);
}

void HugeTest::INITFUNCTION()
{
   if(h == 0)  h = 1;
   glViewport(0, 0, w, h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   glOrtho(range.fxMin, range.fxMax,
           range.fyMin, range.fyMax,
           range.fzMin, range.fzMax);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   
   glClearColor(bd.fClearColor[0],bd.fClearColor[1],
                bd.fClearColor[2],bd.fClearColor[3]);
   
   buffers_init(bd);
   fog_init(fd);
   raster_init(rd);
   lighting_init(ld);
   texture_init(xd);
} // HugeTest::INITFUNCTION()

void HugeTest::RENDFUNCTION()
{
   glClearColor(bd.fClearColor[0],bd.fClearColor[1],
                bd.fClearColor[2],bd.fClearColor[3]);
   glClear(bd.uiClear);
   
   glFlush();
} // HugeTest::RENDFUNCTION()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\large1.cpp ===
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>

#include "skeltest.h"
#include "large1.h"

LargeTriangle::LargeTriangle()
{
   td.swapbuffers = FALSE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Large Triangles (demo only)");
   bd.cColorBits  = 8;
   bd.cDepthBits  = 8;
   
   fClr1 = 1.0f,
   fClr2 = 1.0f,
   fClr3 = 0.0f,
   fClr4 = 0.0f,
   fClr5 = 1.0f,
   fClr6 = 0.0f;
}

void LargeTriangle::INITFUNCTION()
{
   // Prevent a divide by zero, when window is too short
   // (you cant make a window of zero width).
   if(h == 0)  h = 1;
   
   // Set the viewport to be the entire window
   glViewport(0, 0, w, h);
   
   // Reset the coordinate system before modifying
   glLoadIdentity();
   
   fWindowWidth = (GLfloat) w;
   fWindowHeight = (GLfloat) h;
   
   // Set the clipping volume
   glOrtho(0.0f, fWindowWidth, 0.0f, fWindowHeight, 1.0f, -1.0f);
}

void LargeTriangle::IDLEFUNCTION()
{
   GLfloat fClr;
   fClr = fClr1;
   fClr1 = fClr2;
   fClr2 = fClr3;
   fClr3 = fClr4;
   fClr4 = fClr5;
   fClr5 = fClr6;
   fClr6 = fClr;
}

void LargeTriangle::RENDFUNCTION()
{
   // Set drawing colors, and draw (2) Large Triagles
   glBegin(GL_TRIANGLES);
      glColor3f(fClr1, fClr2, fClr3);
      glVertex2f(0.0f,0.0f);
      glVertex2f(0.0f,fWindowHeight);
      glVertex2f(fWindowWidth,fWindowHeight);
      
      glColor3f(fClr4, fClr5, fClr6);
      glVertex2f(0.0f,0.0f);
      glVertex2f(fWindowWidth,fWindowHeight);
      glVertex2f(fWindowWidth,0.0f);
   glEnd();
   
   glFlush();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\lighting.h ===
#ifndef LIGHTING_H
#define LIGHTING_H

#define NUMBEROFLIGHTS 8

typedef struct {
   BOOL    bEnable;
   GLfloat afAmbient[4];
   GLfloat afDiffuse[4];
   GLfloat afSpecular[4];
   GLfloat afPosition[4];
   GLfloat afSpotDirection[3];
   GLfloat fSpotCutoff, fSpotExponent;
   GLfloat afAttenuation[3];
} LIGHTTYPE;

typedef struct {
   char      acDummy1[16];
   BOOL      bEnable;
   BOOL      bLocalViewer;
   BOOL      bTwoSided;
   LIGHTTYPE aLights[NUMBEROFLIGHTS];
   char      acDummy2[16];
} LIGHTINGDATA;

void InitLD(LIGHTINGDATA *pld);
void lighting_init(LIGHTINGDATA ld);

#endif // LIGHTING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\large2.cpp ===
#include <windows.h>
#include <gl\gl.h>
#include <stdio.h>

#include "hugetest.h"
#include "large2.h"

LargeTriangle2::LargeTriangle2()
{
   td.swapbuffers = TRUE;
   td.iDuration   = 10000;
   td.iX = 0;
   td.iY = 0;
   td.iW = 640;
   td.iH = 480;
   sprintf(td.acName, "Large Triangles 2");
   sprintf(td.acTestStatName, "Pixels");
   bd.uiClear  = GL_COLOR_BUFFER_BIT;
   bd.cColorBits  = 8;
   bd.cDepthBits  = 16;
   
   range.fxMin =   0;
   range.fxMax = 300;
   range.fyMin =   0;
   range.fyMax = 200;

   aPntLst[3].AddPoint(range.fxMin, range.fyMin, 0);
   aPntLst[3].AddPoint(range.fxMax, range.fyMin, 0);
   aPntLst[3].AddPoint(range.fxMax, range.fyMax, 0);
   aPntLst[3].AddPoint(range.fxMin, range.fyMin, 0);
   aPntLst[3].AddPoint(range.fxMin, range.fyMax, 0);
   aPntLst[3].AddPoint(range.fxMax, range.fyMax, 0);
}

void LargeTriangle2::INITFUNCTION()
{
   td.dResult = w * h;
   parent::initfunct(w,h);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\large2.h ===
#ifndef LARGE_TRIANGLE2_TEST_H
#define LARGE_TRIANGLE2_TEST_H

#include "primtest.h"

class LargeTriangle2 : public PrimativeTest
{
private:
   typedef PrimativeTest parent;

public:
   LargeTriangle2();
   
   virtual void INITFUNCTION();
};

#endif // LARGE_TRIANGLE2_TEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\macros.h ===
#ifndef MACROS_H
#define MACROS_H

#define bzero(dest,size)        memset(dest,0,size)
#define bcopy(src,dest,size)    memcpy(dest,src,size)
#define strcasecmp(s1,s2)       _stricmp(s1,s2)
#define strncasecmp(s1,s2)      _strnicmp(s1,s2)
#define index(s,c)              strchr(s,c)

#define BEGINstring(d,s)        strncpy(d->acDummy1,s " BEGIN\n", 16)
#define ENDstring(d,s)          strncpy(d->acDummy2,s " END\n", 16)

#define CB_DlgAddString(hDlg, iControl, text) \
        SendDlgItemMessage(hDlg, iControl, CB_ADDSTRING, 0, (LPARAM) text)

#define CB_DlgSetSelect(hDlg, iControl, iIndex) \
        SendDlgItemMessage(hDlg, iControl, CB_SETCURSEL, iIndex, 0)

#define CB_DlgGetSelect(hDlg, iControl) \
        SendDlgItemMessage(hDlg, iControl, CB_GETCURSEL, 0, 0)

#define CB_DlgSetRedraw(hDlg, iControl, bDraw) \
        SendDlgItemMessage(hDlg, iControl, WM_SETREDRAW, bDraw, 0)

#define CB_DlgResetContent(hDlg, iControl) \
        SendDlgItemMessage(hDlg, iControl, CB_RESETCONTENT, 0, 0)

#define UD_DlgGetPos(hDlg, iControl) \
        SendDlgItemMessage(hDlg, iControl, UDM_GETPOS, 0, 0L)
           
#define UD_DlgGetRange(hDlg, iControl) \
        SendDlgItemMessage(hDlg, iControl, UDM_GETRANGE, 0, 0L)

#define UD_DlgSetPos(hDlg, iControl, nPos) \
    SendDlgItemMessage(hDlg, iControl, UDM_SETPOS, 0, (LPARAM) MAKELONG((short) nPos, 0))

#define UD_DlgSetRange(hDlg, iControl, nUpper, nLower) \
    SendDlgItemMessage(hDlg, iControl, UDM_SETRANGE, 0, (LPARAM) MAKELONG((short) nUpper, (short) nLower))

#define GL_EnableOrDisable(b, val) if (b) glEnable(val); else glDisable(val)

#endif // MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\pntlist.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>

#include "pntlist.h"
#include "macros.h"

typedef unsigned long ulong;

PointList::PointList()
{
   aPoints = NULL;
   iSize   = 0;
   iNum    = 0;
} // PointList::PointList()

// garuntees that at least enough memory for i points is allocated
void PointList::AllocatePoints(int i)
{
   if (iSize >= i)
      return;
   aPoints = (f3Point*) realloc(aPoints, i * sizeof(f3Point));
   iSize = i;
} // PointList::AllocatePoints(int i)

// frees memory
void PointList::ResetPoints()
{
   if (aPoints)
      free(aPoints);
   iSize = iNum = 0;
   aPoints = NULL;
} // PointList::ResetPoints()

void PointList::FreeExcess()
{
   if (iSize == iNum)
      return;
   aPoints = (f3Point*) realloc(aPoints, iNum * sizeof(f3Point));
   iSize = iNum;
} // void PointList::FreeExcess()

void PointList::AddPoint(GLfloat f1, GLfloat f2, GLfloat f3)
{
   if (iSize == iNum)
      AllocatePoints(iSize + 5);
   aPoints[iNum][0] = f1;
   aPoints[iNum][1] = f2;
   aPoints[iNum][2] = f3;
   iNum++;
} // void PointList::AddPoint(GLfloat f1, GLfloat f2, GLfloat f3)

void PointList::RemovePoint(int i)
{
   if (i < 0)  i += iNum;
   if ((i < 0) || (i >= iNum))  return;
   iNum--;
   memmove(aPoints + i, aPoints + i + 1, (iNum - i) * sizeof(f3Point));
} // PointList::RemovePoint(int i)

void PointList::SwapPoints(int i, int j)
{
   f3Point f3p;
   
   if (i < 0)  i += iNum;
   if (j < 0)  j += iNum;
   if ((i < 0) || (i >= iNum))  return;
   if ((j < 0) || (j >= iNum))  return;
   
   f3p[0]          = aPoints[i][0];
   f3p[1]          = aPoints[i][1];
   f3p[2]          = aPoints[i][2];
   aPoints[i][0] = aPoints[j][0];
   aPoints[i][1] = aPoints[j][1];
   aPoints[i][2] = aPoints[j][2];
   aPoints[j][0] = f3p[0];
   aPoints[j][1] = f3p[1];
   aPoints[j][2] = f3p[2];
} // PointList::SwapPoints(int i, int j)

void PointList::Duplicate(PointList *ppl)
{
   ResetPoints();
   iSize = ppl->iNum;
   iNum  = ppl->iNum;
   aPoints =  (f3Point*) malloc(iSize * sizeof(f3Point));
   memcpy(aPoints,ppl->aPoints,iSize*sizeof(f3Point));
} // void PointList::Duplicate(PointList *ppl)

void PointList::DisplayPointList(HWND hDlg, int iDlgItemID)
{
   char szBuffer[100];
   int i;
   
   SendDlgItemMessage(hDlg, iDlgItemID, LB_RESETCONTENT, 0, 0);
   SendDlgItemMessage(hDlg, iDlgItemID, WM_SETREDRAW, FALSE, 0);
   for (i = 0 ; i < iNum ; i++) {
      sprintf(szBuffer,"(%g, %g, %g)", aPoints[i][0],
              aPoints[i][1], aPoints[i][2]);
      SendDlgItemMessage(hDlg, iDlgItemID,LB_INSERTSTRING, i,(LPARAM)szBuffer);
   }
   SendDlgItemMessage(hDlg, iDlgItemID, WM_SETREDRAW, TRUE, 0);
} // void PointList::DisplayPointList(HWND hDlg, int iDlgItemID)

int PointList::Save(HANDLE hFile)
{
   char acDummy[16];
   ulong ul;
   
   bzero(acDummy, sizeof(acDummy));
   sprintf(acDummy,"PointList BEGIN");
   if (!WriteFile(hFile, (void*) acDummy, sizeof(acDummy), &ul, NULL))
      return -3;
   if (ul != sizeof(acDummy)) return -3;
   
   if (!WriteFile(hFile, (void*) &iNum, sizeof(iNum), &ul, NULL))
      return -3;
   if (ul != sizeof(iNum)) return -3;
   if (!WriteFile(hFile, (void*) aPoints, iNum * sizeof(f3Point), &ul, NULL))
      return -3;
   if (ul != iNum * sizeof(f3Point)) return -3;
   
   bzero(acDummy, sizeof(acDummy));
   sprintf(acDummy,"PointList END\n");
   if (!WriteFile(hFile, (void*) acDummy, sizeof(acDummy), &ul, NULL))
      return -3;
   if (ul != sizeof(acDummy)) return -3;
   FlushFileBuffers(hFile);
   return sizeof(iNum) + iNum * sizeof(f3Point) + 2 * sizeof(acDummy);
} // int PointList::Write(HANDLE hFile)

int PointList::Load(HANDLE hFile)
{
   char acDummy[16];
   ulong ul;
   
   if (!ReadFile(hFile, (void*) acDummy, sizeof(acDummy), &ul, NULL))
      return -3;
   if (ul != sizeof(acDummy)) return -3;
   
   if (!ReadFile(hFile, (void*) &iNum, sizeof(iNum), &ul, NULL))
      return -3;
   if (ul != sizeof(iNum)) return -3;
   AllocatePoints(iNum);
   FreeExcess();
   if (!ReadFile(hFile, (void*) aPoints, iNum * sizeof(f3Point), &ul, NULL))
      return -3;
   if (ul != iNum * sizeof(f3Point)) return -3;
   if (!ReadFile(hFile, (void*) acDummy, sizeof(acDummy), &ul, NULL))
      return -3;
   if (ul != sizeof(acDummy)) return -3;
   
   return sizeof(iNum) + iNum * sizeof(f3Point) + 2 * sizeof(acDummy);
} // int PointList::Read(HANDLE hFile)

// DEBUG
void PointList::PrintPoints()
{
   int i;
   fprintf(stderr,"%d of %d used\n", iNum, iSize);
   for (i = 0 ; i < iNum ; i++) {
      fprintf(stderr,"(%g, %g, %g)\n",
              aPoints[i][0],aPoints[i][1],aPoints[i][2]);
   }
} // PointList::PrintPoints()
// DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\pntlist.h ===
#ifndef POINTLIST_H
#define POINTLIST_H

typedef GLfloat f3Point[3];

class PointList
{
public:
   PointList();
   ~PointList() { ResetPoints(); };
   
   void AllocatePoints(int i);               // make room for i points in array
   void ResetPoints();                       // deletes points and frees memory
   void FreeExcess();                        // frees unused memory
   void RemovePoint(int i);                  // remove the ith point
   void SwapPoints(int i, int j);            // swap points i and j
   void AddPoint(GLfloat, GLfloat, GLfloat); // add a point to the array
                                             // allocate if needed
   void Duplicate(PointList *ppl);           // copies ppl into this
   void DisplayPointList(HWND hDlg, int iDlgItemID);
   
   int  Save(HANDLE hFile);
   int  Load(HANDLE hFile);
   
   int QueryNumber() { return iNum; };
   
   // DEBUG
   void PrintPoints();

protected:
   f3Point *aPoints;            // array of points
   int iSize, iNum;             // size of array, number of points

   friend class PrimativeTest;
};

#endif // POINTLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\lighting.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <commctrl.h>
#include <memory.h>
#include <assert.h>
#include <gl\gl.h>

#include "lighting.h"
#include "hugetest.h"
#include "resource.h"
#include "ui_huge.h"
#include "macros.h"

void InitLD(LIGHTINGDATA *pld)
{
   int i;
   bzero(pld,sizeof(LIGHTINGDATA));
   BEGINstring(pld, "lighting");
   ENDstring(pld,   "lighting");
   pld->bEnable      = FALSE;
   pld->bTwoSided    = TRUE;
   pld->bLocalViewer = TRUE;
   for (i = 0 ; i < NUMBEROFLIGHTS ; i++) {
      pld->aLights[i].bEnable           = FALSE;
      pld->aLights[i].afAmbient[0]       =  0.0;
      pld->aLights[i].afAmbient[1]       =  0.0;
      pld->aLights[i].afAmbient[2]       =  0.0;
      pld->aLights[i].afAmbient[3]       =  1.0;
      pld->aLights[i].afDiffuse[0]       =  1.0;
      pld->aLights[i].afDiffuse[1]       =  1.0;
      pld->aLights[i].afDiffuse[2]       =  1.0;
      pld->aLights[i].afDiffuse[3]       =  1.0;
      pld->aLights[i].afSpecular[0]      =  1.0;
      pld->aLights[i].afSpecular[1]      =  1.0;
      pld->aLights[i].afSpecular[2]      =  1.0;
      pld->aLights[i].afSpecular[3]      =  1.0;
      pld->aLights[i].afPosition[0]      =  0.0;
      pld->aLights[i].afPosition[1]      =  0.0;
      pld->aLights[i].afPosition[2]      =  1.0;
      pld->aLights[i].afPosition[3]      =  0.0;
      pld->aLights[i].afSpotDirection[0] =  0.0;
      pld->aLights[i].afSpotDirection[1] =  0.0;
      pld->aLights[i].afSpotDirection[2] = -1.0;
      pld->aLights[i].fSpotCutoff       = 180;
      pld->aLights[i].afAttenuation[0]   =  1.0;
      pld->aLights[i].afAttenuation[1]   =  0.0;
      pld->aLights[i].afAttenuation[2]   =  0.0;
   }
}

void lighting_init(const LIGHTINGDATA ld)
{
   static int aiIndexToID[] = {
      GL_LIGHT0, GL_LIGHT1, GL_LIGHT2, GL_LIGHT3,
      GL_LIGHT4, GL_LIGHT5, GL_LIGHT6, GL_LIGHT7 };
   const int iMaxLights = sizeof(aiIndexToID) / sizeof(aiIndexToID[0]);
   int i;
   
   assert(iMaxLights >= NUMBEROFLIGHTS);
   
   if (!ld.bEnable) {
      glDisable(GL_LIGHTING);
      return;
   }
   glEnable(GL_LIGHTING);
   for (i = 0 ; i < NUMBEROFLIGHTS ; i++) {
      if (!ld.aLights[i].bEnable) {
         glDisable(aiIndexToID[i]);
      } else {
         glLightfv(aiIndexToID[i], GL_AMBIENT,  ld.aLights[i].afAmbient);
         glLightfv(aiIndexToID[i], GL_DIFFUSE,  ld.aLights[i].afDiffuse);
         glLightfv(aiIndexToID[i], GL_SPECULAR, ld.aLights[i].afSpecular);
         glLightfv(aiIndexToID[i], GL_POSITION, ld.aLights[i].afPosition);
         glLightfv(aiIndexToID[i], GL_SPOT_DIRECTION,
                   ld.aLights[i].afSpotDirection);
         glLightf(aiIndexToID[i],GL_SPOT_EXPONENT,ld.aLights[i].fSpotExponent);
         glLightf(aiIndexToID[i], GL_SPOT_CUTOFF, ld.aLights[i].fSpotCutoff);
         glLightf(aiIndexToID[i], GL_CONSTANT_ATTENUATION,
                  ld.aLights[i].afAttenuation[0]);
         glLightf(aiIndexToID[i], GL_LINEAR_ATTENUATION,
                  ld.aLights[i].afAttenuation[1]);
         glLightf(aiIndexToID[i], GL_QUADRATIC_ATTENUATION,
                  ld.aLights[i].afAttenuation[2]);
         glEnable(aiIndexToID[i]);
      }
   }
}

#ifndef NO_UI_IN_CNFG

void lighting_EnableOrDisableWindows(HWND hDlg)
{
   static int aiCommands[] =
   {  L_IDC_AMBIENT1,     L_IDC_AMBIENT2,     L_IDC_AMBIENT3,  L_IDC_AMBIENT4,
      L_IDC_DIFFUSE1,     L_IDC_DIFFUSE2,     L_IDC_DIFFUSE3,  L_IDC_DIFFUSE4,
      L_IDC_SPECULAR1,    L_IDC_SPECULAR2,    L_IDC_SPECULAR3, L_IDC_SPECULAR4,
      L_IDC_POSITION1,    L_IDC_POSITION2,    L_IDC_POSITION3, L_IDC_POSITION4,
      L_IDC_SPOTDIR1,     L_IDC_SPOTDIR2,     L_IDC_SPOTDIR3,
      L_IDC_CUTOFF,       L_IDC_EXPONENT,
      L_IDC_ATTENUATION1, L_IDC_ATTENUATION2, L_IDC_ATTENUATION3 };
   const int iNumCommands = sizeof(aiCommands) / sizeof(aiCommands[0]);
   BOOL b;
   int i;
   
   b = (BOOL) IsDlgButtonChecked(hDlg, IDC_ENABLE);
   EnableWindow(GetDlgItem(hDlg, L_IDC_TWOSIDED),       b);
   EnableWindow(GetDlgItem(hDlg, L_IDC_ENABLELIGHT),    b);
   EnableWindow(GetDlgItem(hDlg, L_IDC_LOCALVIEWER),    b);
   EnableWindow(GetDlgItem(hDlg, L_IDC_INFINITEVIEWER), b);
   if (b)
      b = IsDlgButtonChecked(hDlg, L_IDC_ENABLELIGHT) ? TRUE :0;
   for (i = 0 ; i < iNumCommands ; i++) {
      EnableWindow(GetDlgItem(hDlg,aiCommands[i]),b);
   }
}

void lighting_SetDisplayFromData(HWND hDlg, const LIGHTINGDATA *pld, int i)
{
   static char acBuffer[100];
   
   sprintf(acBuffer, "Light number: %d", i);
   SetDlgItemText(hDlg, L_IDC_LIGHT, acBuffer);
   
   CheckDlgButton(hDlg, IDC_ENABLE,             pld->bEnable);
   CheckDlgButton(hDlg, L_IDC_TWOSIDED,         pld->bTwoSided);
   CheckDlgButton(hDlg, L_IDC_LOCALVIEWER,      pld->bLocalViewer);
   CheckDlgButton(hDlg, L_IDC_INFINITEVIEWER, !(pld->bLocalViewer));
   
   CheckDlgButton(hDlg, L_IDC_ENABLELIGHT, pld->aLights[i].bEnable);
   SetDlgFloatString(hDlg, L_IDC_AMBIENT1, pld->aLights[i].afAmbient[0]);
   SetDlgFloatString(hDlg, L_IDC_AMBIENT2, pld->aLights[i].afAmbient[1]);
   SetDlgFloatString(hDlg, L_IDC_AMBIENT3, pld->aLights[i].afAmbient[2]);
   SetDlgFloatString(hDlg, L_IDC_AMBIENT4, pld->aLights[i].afAmbient[3]);
   SetDlgFloatString(hDlg, L_IDC_DIFFUSE1, pld->aLights[i].afDiffuse[0]);
   SetDlgFloatString(hDlg, L_IDC_DIFFUSE2, pld->aLights[i].afDiffuse[1]);
   SetDlgFloatString(hDlg, L_IDC_DIFFUSE3, pld->aLights[i].afDiffuse[2]);
   SetDlgFloatString(hDlg, L_IDC_DIFFUSE4, pld->aLights[i].afDiffuse[3]);
   SetDlgFloatString(hDlg, L_IDC_SPECULAR1, pld->aLights[i].afSpecular[0]);
   SetDlgFloatString(hDlg, L_IDC_SPECULAR2, pld->aLights[i].afSpecular[1]);
   SetDlgFloatString(hDlg, L_IDC_SPECULAR3, pld->aLights[i].afSpecular[2]);
   SetDlgFloatString(hDlg, L_IDC_SPECULAR4, pld->aLights[i].afSpecular[3]);
   SetDlgFloatString(hDlg, L_IDC_POSITION1, pld->aLights[i].afPosition[0]);
   SetDlgFloatString(hDlg, L_IDC_POSITION2, pld->aLights[i].afPosition[1]);
   SetDlgFloatString(hDlg, L_IDC_POSITION3, pld->aLights[i].afPosition[2]);
   SetDlgFloatString(hDlg, L_IDC_POSITION4, pld->aLights[i].afPosition[3]);
   SetDlgFloatString(hDlg, L_IDC_SPOTDIR1, pld->aLights[i].afSpotDirection[0]);
   SetDlgFloatString(hDlg, L_IDC_SPOTDIR2, pld->aLights[i].afSpotDirection[1]);
   SetDlgFloatString(hDlg, L_IDC_SPOTDIR3, pld->aLights[i].afSpotDirection[2]);
   SetDlgFloatString(hDlg, L_IDC_CUTOFF,   pld->aLights[i].fSpotCutoff);
   SetDlgFloatString(hDlg, L_IDC_EXPONENT, pld->aLights[i].fSpotExponent);
   SetDlgFloatString(hDlg,L_IDC_ATTENUATION1,pld->aLights[i].afAttenuation[0]);
   SetDlgFloatString(hDlg,L_IDC_ATTENUATION2,pld->aLights[i].afAttenuation[1]);
   SetDlgFloatString(hDlg,L_IDC_ATTENUATION3,pld->aLights[i].afAttenuation[2]);
   
   lighting_EnableOrDisableWindows(hDlg);
}

void lighting_GetDataFromDisplay(HWND hDlg, LIGHTINGDATA *pld, int i)
{
   pld->bEnable      = IsDlgButtonChecked(hDlg, IDC_ENABLE);
   pld->bTwoSided    = IsDlgButtonChecked(hDlg, L_IDC_TWOSIDED);
   pld->bLocalViewer = IsDlgButtonChecked(hDlg, L_IDC_LOCALVIEWER);
   
   pld->aLights[i].bEnable = IsDlgButtonChecked(hDlg, L_IDC_ENABLELIGHT);
   pld->aLights[i].afAmbient[0] = GetDlgFloatString(hDlg, L_IDC_AMBIENT1);
   pld->aLights[i].afAmbient[1] = GetDlgFloatString(hDlg, L_IDC_AMBIENT2);
   pld->aLights[i].afAmbient[2] = GetDlgFloatString(hDlg, L_IDC_AMBIENT3);
   pld->aLights[i].afAmbient[3] = GetDlgFloatString(hDlg, L_IDC_AMBIENT4);
   pld->aLights[i].afDiffuse[0] = GetDlgFloatString(hDlg, L_IDC_DIFFUSE1);
   pld->aLights[i].afDiffuse[1] = GetDlgFloatString(hDlg, L_IDC_DIFFUSE2);
   pld->aLights[i].afDiffuse[2] = GetDlgFloatString(hDlg, L_IDC_DIFFUSE3);
   pld->aLights[i].afDiffuse[3] = GetDlgFloatString(hDlg, L_IDC_DIFFUSE4);
   pld->aLights[i].afSpecular[0] = GetDlgFloatString(hDlg, L_IDC_SPECULAR1);
   pld->aLights[i].afSpecular[1] = GetDlgFloatString(hDlg, L_IDC_SPECULAR2);
   pld->aLights[i].afSpecular[2] = GetDlgFloatString(hDlg, L_IDC_SPECULAR3);
   pld->aLights[i].afSpecular[3] = GetDlgFloatString(hDlg, L_IDC_SPECULAR4);
   pld->aLights[i].afPosition[0] = GetDlgFloatString(hDlg, L_IDC_POSITION1);
   pld->aLights[i].afPosition[1] = GetDlgFloatString(hDlg, L_IDC_POSITION2);
   pld->aLights[i].afPosition[2] = GetDlgFloatString(hDlg, L_IDC_POSITION3);
   pld->aLights[i].afPosition[3] = GetDlgFloatString(hDlg, L_IDC_POSITION4);
   pld->aLights[i].afSpotDirection[0] = GetDlgFloatString(hDlg,L_IDC_SPOTDIR1);
   pld->aLights[i].afSpotDirection[1] = GetDlgFloatString(hDlg,L_IDC_SPOTDIR2);
   pld->aLights[i].afSpotDirection[2] = GetDlgFloatString(hDlg,L_IDC_SPOTDIR3);
   pld->aLights[i].fSpotCutoff   = GetDlgFloatString(hDlg, L_IDC_CUTOFF);
   pld->aLights[i].fSpotExponent = GetDlgFloatString(hDlg, L_IDC_EXPONENT);
   pld->aLights[i].afAttenuation[0]=GetDlgFloatString(hDlg,L_IDC_ATTENUATION1);
   pld->aLights[i].afAttenuation[1]=GetDlgFloatString(hDlg,L_IDC_ATTENUATION2);
   pld->aLights[i].afAttenuation[2]=GetDlgFloatString(hDlg,L_IDC_ATTENUATION3);
}

BOOL CALLBACK hugeLightDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   static LIGHTINGDATA *pld = NULL, ld;
   static int          index;
   
   switch (msg)
      {
      case WM_INITDIALOG:
         index = 0;
         UD_DlgSetPos  (hDlg, L_IDC_WHICHLIGHT, index);
         UD_DlgSetRange(hDlg, L_IDC_WHICHLIGHT, 7, 0);
         pld = (LIGHTINGDATA*) (((PROPSHEETPAGE*)lParam)->lParam);
         bcopy(pld, &ld, sizeof(ld));
         lighting_SetDisplayFromData(hDlg, &ld, index);
         lighting_EnableOrDisableWindows(hDlg);
         return TRUE;

      case WM_COMMAND:
         {
            int    iControl, iNote;
            iControl = LOWORD(wParam);
            iNote = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case IDC_ENABLE:
               case L_IDC_ENABLELIGHT:
                  lighting_EnableOrDisableWindows(hDlg);
                  ld.bEnable = IsDlgButtonChecked(hDlg, IDC_ENABLE);
                  ld.aLights[index].bEnable
                     = IsDlgButtonChecked(hDlg, L_IDC_ENABLELIGHT);
                  break;

               case L_IDC_AMBIENT1:
               case L_IDC_AMBIENT2:
               case L_IDC_AMBIENT3:
               case L_IDC_AMBIENT4:
               case L_IDC_ATTENUATION1:
               case L_IDC_ATTENUATION2:
               case L_IDC_ATTENUATION3:
               case L_IDC_CUTOFF:
               case L_IDC_DIFFUSE1:
               case L_IDC_DIFFUSE2:
               case L_IDC_DIFFUSE3:
               case L_IDC_DIFFUSE4:
               case L_IDC_EXPONENT:
               case L_IDC_POSITION1:
               case L_IDC_POSITION2:
               case L_IDC_POSITION3:
               case L_IDC_POSITION4:
               case L_IDC_SPECULAR1:
               case L_IDC_SPECULAR2:
               case L_IDC_SPECULAR3:
               case L_IDC_SPECULAR4:
               case L_IDC_SPOTDIR1:
               case L_IDC_SPOTDIR2:
               case L_IDC_SPOTDIR3:
                  if (EN_KILLFOCUS == iNote) {
                     PropSheet_Changed(GetParent(hDlg),hDlg);
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               case L_IDC_TWOSIDED:
                  ld.bTwoSided = IsDlgButtonChecked(hDlg,L_IDC_TWOSIDED);
                  break;

               case L_IDC_LOCALVIEWER:
               case L_IDC_INFINITEVIEWER:
                  ld.bLocalViewer = IsDlgButtonChecked(hDlg,L_IDC_LOCALVIEWER);
                  break;

               default:
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;
               }
         }
      break;

      case WM_HSCROLL:
         lighting_GetDataFromDisplay(hDlg, &ld, index);
         index = LOWORD(UD_DlgGetPos(hDlg, L_IDC_WHICHLIGHT));
         lighting_SetDisplayFromData(hDlg, &ld, index);
         break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  lighting_GetDataFromDisplay(hDlg, &ld, index);
                  bcopy(&ld, pld, sizeof(ld));
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}


#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\prfl.h ===
#ifndef PROFILE_H
#define PROFILE_H

#include "skeltest.h"

#define PRFL_NO_ERROR           0
#define PRFL_ERROR_OPENFILE     1
#define PRFL_ERROR_LOADFILE     2
#define PRFL_ERROR_FILESEEK     3
#define PRFL_ERROR_CLOSEFILE    4
#define PRFL_ERROR_UNKNOWN_TYPE 5

typedef void void_void(void);

BOOL prfl_RegisterClass(HINSTANCE hInstance);

/*
 * if *piError is 0, then no error, cast prfl_Autoload to SkeletonTest*
 * if *piError is not 0, then error, cast prfl_Autoload to char* for message
 */
void *prfl_AutoLoad(const char *szFileName, int *piError);

BOOL prfl_StartTest(SkeletonTest *ptest, LPCTSTR lpzWinName, void_void EndFn);
BOOL prfl_StopTest(void);
BOOL prfl_TestRunning(void);
double prfl_GetCount(void);
double prfl_GetDuration(void);
char * prfl_GetTestStatName(void);
double prfl_GetResult(void);

#endif // PROFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\primtest.h ===
#ifndef PRIMTEST_H
#define PRIMTEST_H

#include "hugetest.h"
#include "pntlist.h"

#define NUMBEROFPRIMATIVES 10
// 0 = points,    1 = lines,     2 = polygon,   3 = triangles, 4 = quads
// 5 = line stip, 6 = line loop, 7 = tri strip, 8 = tri fan,   9 = quad strip

class PrimativeTest : public HugeTest
{
private:
   typedef HugeTest parent;

public:
   PrimativeTest();
   ~PrimativeTest() {};
   
   virtual void RENDFUNCTION();
   virtual void IDLEFUNCTION();
   
   virtual void SaveData();
   virtual void RestoreSaved();
   virtual void ForgetSaved();
   
   virtual int Save(HANDLE hFile);
   virtual int Load(HANDLE hFile);

protected:
   PointList aPntLst[NUMBEROFPRIMATIVES];
   GLfloat   fClr4, fClr5, fClr6; // not saved
   BOOL      bRotCol;             // not saved
};

#endif // PRIMTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\primtest.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <memory.h>

#include "hugetest.h"
#include "pntlist.h"
#include "primtest.h"
#include "UI_huge.h"
#include "resource.h"
#include "macros.h"

typedef BOOL CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);

DlgProc PrimativeDlgProc;

extern HINSTANCE hInstance;

PrimativeTest::PrimativeTest()
{
   PROPSHEETPAGE pspage;
   
   SetThisType("Primative");
   SetThisVersion("1.0");
   sprintf(td.acName,"Primatives");
   
   afDrawColor[0] = 1.0;
   afDrawColor[1] = 1.0;
   afDrawColor[2] = 0.0;
   fClr4 = 0.0f,
   fClr5 = 1.0f,
   fClr6 = 0.0f;
   bRotCol = TRUE;

   // Zero out property PAGE data
   bzero (&pspage, sizeof(pspage)) ;
   
   pspage.dwSize      = sizeof(PROPSHEETPAGE);
   pspage.dwFlags     = PSP_USECALLBACK;
   pspage.hInstance   = hInstance;
   pspage.pszTemplate = MAKEINTRESOURCE (IDD_PRIMATIVES);
   pspage.pfnDlgProc  = (DLGPROC) PrimativeDlgProc;
   pspage.lParam      = (LPARAM) aPntLst;
   
   AddPropertyPages(1, &pspage);
}

static PointList prim_pl[NUMBEROFPRIMATIVES];

// optimize this
void PrimativeTest::SaveData()
{
   for (int i = 0 ; i < NUMBEROFPRIMATIVES ; i++)
      prim_pl[i].Duplicate(&(aPntLst[i]));
   parent::SaveData();
}

// optimize this
void PrimativeTest::RestoreSaved()
{
   for (int i = 0 ; i < NUMBEROFPRIMATIVES ; i++) {
      aPntLst[i].Duplicate(&(prim_pl[i]));
      prim_pl[i].ResetPoints();
   }
   parent::RestoreSaved();
}

// optimize this
void PrimativeTest::ForgetSaved()
{
   for (int i = 0 ; i < NUMBEROFPRIMATIVES ; i++)
      prim_pl[i].ResetPoints();
   parent::ForgetSaved();
}

int PrimativeTest::Save(HANDLE hFile)
{
   ulong ul,p;
   int i,j;
   
   p = parent::Save(hFile);
   if (p < 0) return p;
   
   ul = 0;
   for (i = 0 ; i < NUMBEROFPRIMATIVES ; i++) {
      ul += j = aPntLst[i].Save(hFile);
      if (j == -1) return -1;
   }
   j = ul;
   FlushFileBuffers(hFile);
   return j + p;
}

int PrimativeTest::Load(HANDLE hFile)
{
   ulong ul,p;
   int i,j;
   
   p = parent::Load(hFile);
   if (p < 0) return p;
   
   ul = 0;
   for (i = 0 ; i < NUMBEROFPRIMATIVES ; i++) {
      ul += j = aPntLst[i].Load(hFile);
      if (j == -2) return -2;
   }
   j = ul;
   return j + p;
}

void PrimativeTest::IDLEFUNCTION()
{
   GLfloat fClr;
   if (bRotCol) {
      fClr           = afDrawColor[0];
      afDrawColor[0] = afDrawColor[1];
      afDrawColor[1] = afDrawColor[2];
      afDrawColor[2] = fClr4;
      fClr4          = fClr5;
      fClr5          = fClr6;
      fClr6          = fClr;
   }
}

void PrimativeTest::RENDFUNCTION()
{
   static int iType[NUMBEROFPRIMATIVES] = {
      GL_POINTS, GL_LINES, GL_POLYGON, GL_TRIANGLES, GL_QUADS, GL_LINE_STRIP,
      GL_LINE_LOOP, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUAD_STRIP
   };
   int i, j;
   
   glClearColor(bd.fClearColor[0],bd.fClearColor[1],
                bd.fClearColor[2],bd.fClearColor[3]);
   glClear(bd.uiClear);
   
   for (j = 0; j < NUMBEROFPRIMATIVES; j++) {
      glBegin(iType[j]); {
         glColor3f(afDrawColor[0],afDrawColor[1],afDrawColor[2]);
         for (i = 0 ; i < aPntLst[j].iNum ; i++) {
            glVertex3f(aPntLst[j].aPoints[i][0],aPntLst[j].aPoints[i][1],
                       aPntLst[j].aPoints[i][2]);
         }
      }
      glEnd();
   }
   
   glFlush();
} // PrimativeTest::RENDFUNCTION()


#ifndef NO_UI_IN_CNFG

BOOL CALLBACK PrimativeDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
   static PointList *aPntLst;
   static PointList *pPntLst;
   char szBuffer[100];
   char szBuf1[20],szBuf2[20],szBuf3[20];
   int  i;

   switch (msg)
      {
      case WM_INITDIALOG:
         SetDlgItemInt(hDlg, P_IDC_POINT1, 0, TRUE);
         SetDlgItemInt(hDlg, P_IDC_POINT2, 0, TRUE);
         SetDlgItemInt(hDlg, P_IDC_POINT3, 0, TRUE);
         SendDlgItemMessage(hDlg, IDC_POINTS, BM_SETCHECK, 1, 0);
         aPntLst = (PointList*) (((PROPSHEETPAGE*)lParam)->lParam);
         pPntLst = aPntLst;
         pPntLst->DisplayPointList(hDlg, P_IDC_POINTLIST);
         sprintf(szBuffer,"Polygons (%d Points)", pPntLst->QueryNumber());
         SetDlgItemText(hDlg, P_IDC_POLY, szBuffer);
         return TRUE;

      case WM_COMMAND:
         {
            int     iControl, iNote;
            GLfloat f1, f2, f3;
            iControl = LOWORD(wParam);
            iNote = HIWORD(wParam); // notification code for edit boxes
            
            switch (iControl)
               {
               case P_IDC_POINT1:
               case P_IDC_POINT2:
               case P_IDC_POINT3:
                  if (EN_KILLFOCUS == iNote) {
                     VerifyEditboxFloat(hDlg,iControl);
                  }
                  break;

               case P_IDC_ADD: // ADD
                  i =SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_GETCURSEL,0,0);
                  if (i == LB_ERR)   i = -1;
                  GetDlgItemText(hDlg, P_IDC_POINT1, szBuf1, sizeof(szBuf1));
                  GetDlgItemText(hDlg, P_IDC_POINT2, szBuf2, sizeof(szBuf2));
                  GetDlgItemText(hDlg, P_IDC_POINT3, szBuf3, sizeof(szBuf3));
                  f1 = (GLfloat) atof(szBuf1);
                  f2 = (GLfloat) atof(szBuf2);
                  f3 = (GLfloat) atof(szBuf3);
                  sprintf(szBuffer,"(%g, %g, %g)", f1, f2, f3);
                  SendDlgItemMessage(hDlg,P_IDC_POINTLIST, LB_INSERTSTRING,
                                     i, (LPARAM) szBuffer);
                  pPntLst->AddPoint(f1,f2,f3);
                  pPntLst->SwapPoints(-1,i);
                  sprintf(szBuffer,"Polygons (%d Points)",
                          pPntLst->QueryNumber());
                  SetDlgItemText(hDlg, P_IDC_POLY, szBuffer);
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;        // P_IDC_ADD

               case P_IDC_REMOVE:
                  i =SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_GETCURSEL,0,0);
                  if (i != LB_ERR) {
                     SendDlgItemMessage(hDlg,P_IDC_POINTLIST,
                                        LB_DELETESTRING,i,0);
                     pPntLst->RemovePoint(i);
                  }
                  sprintf(szBuffer,"Polygons (%d Points)",
                          pPntLst->QueryNumber());
                  SetDlgItemText(hDlg, P_IDC_POLY, szBuffer);
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;        // P_IDC_REMOVE

               case P_IDC_MOVEUP:
                  i =SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_GETCURSEL,0,0);
                  if ((i == LB_ERR) || (i == 0))
                     break;
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_GETTEXT,
                                     i, (LPARAM)szBuffer);
                  SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_DELETESTRING,i,0);
                  i--;
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_INSERTSTRING,
                                     i, (LPARAM) szBuffer);
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_SETCURSEL, i,0);
                  pPntLst->SwapPoints(i,i+1);
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;        // P_IDC_MOVEUP

               case P_IDC_MOVEDOWN:
                  i =SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_GETCURSEL,0,0);
                  if ((i == LB_ERR) ||
                      (i==SendDlgItemMessage(hDlg,P_IDC_POINTLIST,
                                             LB_GETCOUNT,0,0)-1))
                     break;
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_GETTEXT,
                                     i, (LPARAM)szBuffer);
                  SendDlgItemMessage(hDlg,P_IDC_POINTLIST,LB_DELETESTRING,i,0);
                  i++;
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_INSERTSTRING,
                                     i, (LPARAM) szBuffer);
                  SendDlgItemMessage(hDlg, P_IDC_POINTLIST, LB_SETCURSEL, i,0);
                  pPntLst->SwapPoints(i,i-1);
                  PropSheet_Changed(GetParent(hDlg),hDlg);
                  break;        // P_IDC_MOVEDOWN

               default:
                  if ((IDC_POINTS <= iControl) && 
                      (iControl < IDC_POINTS + NUMBEROFPRIMATIVES)) {
                     i = iControl - IDC_POINTS;
                     pPntLst = &(aPntLst[i]);
                     pPntLst->DisplayPointList(hDlg, P_IDC_POINTLIST);
                     sprintf(szBuffer,"Polygons (%d Points)",
                             pPntLst->QueryNumber());
                     SetDlgItemText(hDlg, P_IDC_POLY, szBuffer);
                  }
                  break;
               }
         }
      break;

      case WM_NOTIFY:
         {
            LPNMHDR pnmh = (LPNMHDR) lParam;
            switch (pnmh->code)
               {
               case PSN_APPLY:  // user clicked on OK or Apply
                  break;

               case PSN_RESET:  // user clicked on Cancel
                  break;

               case PSN_HELP:   // user clicked help
                  break;
               }
         }
      break;

      default:
         return FALSE;
      }
   return TRUE;
}

#else
#endif // NO_UI_IN_CNFG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\profiler.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <commdlg.h>

#include "prfl.h"
#include "skeltest.h"
#include "hugetest.h"
#include "primtest.h"
#include "resource.h"
#include "macros.h"

#include "square.h"
#include "large1.h"
#include "small1.h"
#include "teapot.h"
#include "large2.h"
#include "small2.h"
#include "tptlght.h"
#include "tpttxtr.h"

static LPCTSTR lpszAppName = "Profiler";

typedef PrimativeTest NewTestType;

HINSTANCE hInstance;
HWND      hWndMain;

#define MAXNUMBEROFTESTS 40

SkeletonTest *tests[MAXNUMBEROFTESTS];
static int    iNumberOfTests = 0;

#define DisableWindow(x) EnableWindow(x,FALSE)
LRESULT CALLBACK mainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK renameDlgProc(HWND, UINT, WPARAM, LPARAM);

// Entry point of all Windows programs
int APIENTRY WinMain(HINSTANCE hInst,     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine, int       iCmdShow)
{
   MSG        msg;
   WNDCLASSEX wc;
   HACCEL     hAccel;
   
   hInstance = hInst;
   
   // Register Window style
   wc.cbSize               = sizeof(wc);
   wc.style                = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc          = (WNDPROC) mainWndProc;
   wc.cbClsExtra           = 0;
   wc.cbWndExtra           = DLGWINDOWEXTRA;
   wc.hInstance            = hInstance;
   wc.hIcon                = NULL;
   wc.hCursor              = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground        = (HBRUSH) COLOR_BTNSHADOW;
   wc.lpszMenuName         = NULL;
   wc.lpszClassName        = lpszAppName;
   wc.hIconSm              = NULL;
   
   // Register the window class
   if(RegisterClassEx(&wc) == 0)
      exit(-1);
   if (prfl_RegisterClass(hInstance) == FALSE)
      exit(-1);

   bzero(tests,sizeof(tests));
   tests[0] = new SkeletonTest;
   tests[1] = new HugeTest;
   tests[2] = new PrimativeTest;
   tests[3] = new TeapotTest;
   tests[4] = new LargeTriangle;
   tests[5] = new SmallTriangle;
   tests[6] = new SquareTest;
   tests[7] = new TeapotTextureTest;
   tests[8] = new TeapotLightTest;
   tests[9] = new LargeTriangle2;
   tests[10] = new SmallTriangle2;
   iNumberOfTests = 11;

   hWndMain = CreateDialog(hInstance, lpszAppName, 0, NULL);
   // I'm not sure why, but my window isn't getting a WM_INITDIALOG
   // message, so we'll just force it to get one.
   // Perhaps because I'm using CreateDialog instead of DialogBox?
   SendMessage(hWndMain, WM_INITDIALOG, 0, 0);
   
   hAccel = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATOR1));
   
   while(GetMessage(&msg, NULL, 0, 0)) {
      if (!TranslateAccelerator(hWndMain, hAccel, &msg)) {
         TranslateMessage(&msg);
         DispatchMessage(&msg);
      }
   }
   
   return msg.wParam;
}

void EnableRunmode(HWND hDlg, BOOL f) {
   EnableWindow(GetDlgItem(hDlg,M_IDC_WHICHTEST), !f); // Test list
   EnableWindow(GetDlgItem(hDlg,M_IDC_CONFIG),    !f); // Config
   EnableWindow(GetDlgItem(hDlg,M_IDC_NEW),       !f); // New
   EnableWindow(GetDlgItem(hDlg,M_IDC_DELETE),    !f); // Delete
   EnableWindow(GetDlgItem(hDlg,M_IDC_RENAME),    !f); // Rename
   EnableWindow(GetDlgItem(hDlg,M_IDC_RUN),       !f); // Run
   EnableWindow(GetDlgItem(hDlg,M_IDC_ABORT),          f); // Abort
   EnableWindow(GetDlgItem(hDlg,M_IDC_QUIT),        !f); // Quit
   if (iNumberOfTests == MAXNUMBEROFTESTS) {
      EnableWindow(GetDlgItem(hDlg, M_IDC_NEW), FALSE);
      EnableWindow(GetDlgItem(hDlg, M_IDC_LOAD), FALSE);
   }
   if (iNumberOfTests == 1)
      EnableWindow(GetDlgItem(hDlg, M_IDC_DELETE), FALSE);
}

int UpdateTestList(HWND hDlg, int iRadio)
{
   int i;
   if (iRadio >= iNumberOfTests)
      iRadio = 0;
   CB_DlgResetContent(hDlg, M_IDC_WHICHTEST);
   CB_DlgSetRedraw(hDlg, M_IDC_WHICHTEST, FALSE);
   for (i = 0 ; i < iNumberOfTests ; i++) {
      CB_DlgAddString(hDlg, M_IDC_WHICHTEST, tests[i]->QueryName());
   }
   CB_DlgSetRedraw(hDlg, M_IDC_WHICHTEST, TRUE);
   CB_DlgSetSelect(hDlg, M_IDC_WHICHTEST, iRadio);
   SetFocus(GetDlgItem(hDlg, M_IDC_RUN));
   return iRadio;
};

void main_test_end_callback()
{
   PostMessage(hWndMain, WM_USER, 0, 0);
}

// Window procedure, handles all messages for this window
LRESULT CALLBACK mainWndProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static char      szFileName[_MAX_PATH];
   static char      szTitleName[_MAX_FNAME + _MAX_EXT];
   static OPENFILENAME ofn;
   static int iRadio = 0;
   static char szFilter[] = "Test Files (*.TST)\0*.tst\0"  \
      "All Files (*.*)\0*.*\0\0" ;
   static char acBuffer[120];
   void  *pTmp;
   char  *pc;
   HANDLE hFile;
   int    iControl;
   int    i;

   switch (msg)
      {
      case WM_CREATE:
         ofn.lStructSize       = sizeof (OPENFILENAME);
         ofn.hwndOwner         = hDlg;
         ofn.hInstance         = NULL;
         ofn.lpstrFilter       = szFilter;
         ofn.lpstrCustomFilter = NULL;
         ofn.nMaxCustFilter    = 0;
         ofn.nFilterIndex      = 0;
         ofn.lpstrFile         = szFileName;
         ofn.nMaxFile          = _MAX_PATH;
         ofn.lpstrFileTitle    = szTitleName;
         ofn.nMaxFileTitle     = _MAX_FNAME + _MAX_EXT;
         ofn.lpstrInitialDir   = NULL;
         ofn.lpstrTitle        = NULL;
         ofn.Flags             = 0; // Set in Open and Close functions
         ofn.nFileOffset       = 0;
         ofn.nFileExtension    = 0;
         ofn.lpstrDefExt       = "tst";
         ofn.lCustData         = 0L;
         ofn.lpfnHook          = NULL;
         ofn.lpTemplateName    = NULL;
         break;

      case WM_INITDIALOG:
         iRadio = UpdateTestList(hDlg,iRadio);
         return 0;              // WM_INITDIALOG

      case WM_COMMAND:
         {
            iControl = LOWORD(wParam);
            
            switch (iControl)
               {

               case M_IDC_WHICHTEST:
                  iRadio = CB_DlgGetSelect(hDlg, M_IDC_WHICHTEST);
                  break;

               case M_IDC_CONFIG:
                  // if (tests[iRadio])
                  if (-1 == tests[iRadio]->cnfgfunct(hDlg)) {
                     MessageBeep(MB_OK);
                     fprintf(stderr,"error calling cnfgfunct()\n");
                     MessageBox(hDlg,"An error occured.",NULL,
                                MB_OK|MB_ICONERROR);
                  }
                  break;

               case M_IDC_NEW:  // New
                  if (iNumberOfTests == MAXNUMBEROFTESTS) {
                     MessageBox(hDlg,
                                "Sorry, you've already got too many tests.",
                                NULL, MB_OK|MB_ICONERROR);
                     break;
                  }
                  tests[iNumberOfTests] = new NewTestType;
                  iNumberOfTests++;
                  if (iNumberOfTests == MAXNUMBEROFTESTS) {
                     EnableWindow(GetDlgItem(hDlg, M_IDC_NEW), FALSE);
                     EnableWindow(GetDlgItem(hDlg, M_IDC_LOAD), FALSE);
                  }
                  iRadio = UpdateTestList(hDlg,iRadio);
                  break;

               case M_IDC_DELETE: // Delete
                  if (iNumberOfTests == 1)
                     break;
                  delete(tests[iRadio]);
                  iNumberOfTests--;
                  tests[iRadio] = tests[iNumberOfTests];
                  if (iNumberOfTests == 1)
                     EnableWindow(GetDlgItem(hDlg, M_IDC_DELETE), FALSE);
                  iRadio = UpdateTestList(hDlg,iRadio);
                  break;

               case M_IDC_RENAME: // Rename
                  pc = (char*)DialogBoxParam(hInstance,
                                             MAKEINTRESOURCE(IDD_RENAME),hDlg,
                                             (DLGPROC)renameDlgProc,
                                           (LPARAM)tests[iRadio]->QueryName());
                  if (pc) {
                     tests[iRadio]->Rename(pc);
                  }
                  iRadio = UpdateTestList(hDlg,iRadio);
                  break;

               case M_IDC_LOAD:   // Load
                  if (iNumberOfTests == MAXNUMBEROFTESTS) {
                     MessageBox(hDlg,
                                "Sorry, you've already got too many tests.",
                                NULL, MB_OK|MB_ICONERROR);
                     break;
                  }
                  
                  ofn.hwndOwner = hDlg;
                  ofn.Flags     = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;
                  if (GetOpenFileName (&ofn)) {
                     fprintf(stderr, "file to open: %s\n", szFileName);
                  } else {
                     fprintf(stderr, "load canceled\n");
                     break;
                  }
                  
                  pTmp = prfl_AutoLoad(szFileName, &i);
                  if (i) {
                     MessageBox(hDlg, (char*)pTmp, NULL, MB_OK | MB_ICONERROR);
                     break;
                  }
                  
                  tests[iNumberOfTests] = (SkeletonTest*) pTmp;
                  iRadio = iNumberOfTests;
                  iNumberOfTests++;
                  if (iNumberOfTests == MAXNUMBEROFTESTS) {
                     EnableWindow(GetDlgItem(hDlg, M_IDC_NEW), FALSE);
                     EnableWindow(GetDlgItem(hDlg, M_IDC_LOAD), FALSE);
                  }
                  iRadio = UpdateTestList(hDlg,iRadio);
                  break;

               case M_IDC_SAVE:   // Save
                  ofn.hwndOwner = hDlg;
                  ofn.Flags     = OFN_HIDEREADONLY;
                  if (GetSaveFileName (&ofn)) {
                     fprintf(stderr,"file to save: %s\n",szFileName);
                  } else {
                     fprintf(stderr,"save canceled\n");
                     break;
                  }
                  hFile = CreateFile(szFileName, GENERIC_WRITE, 0, NULL,
                                     CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
                  if (hFile == INVALID_HANDLE_VALUE) {
                     fprintf(stderr,"Error opening file: %d\n",GetLastError());
                     break;
                  }
                  i = tests[iRadio]->Save(hFile);
                  if (i < 0) {
                     sprintf(acBuffer,"Error number %d while reading file",i);
                     MessageBox(hDlg,acBuffer,NULL,MB_OK|MB_ICONERROR);
                  }
                  if (!CloseHandle(hFile))
                     fprintf(stderr,"Error closing file: %d\n",GetLastError());
                  break;

               case M_IDC_RUN:       // Run
                  EnableRunmode(hDlg,TRUE);
                  if (!prfl_StartTest(tests[iRadio],
                                      tests[iRadio]->QueryName(),
                                      main_test_end_callback)) {
                     fprintf(stderr,"%cError: StartTest == FALSE\n",7);
                  }
                  break;

               case M_IDC_ABORT:
                  prfl_StopTest();
                  KillTimer(hDlg,101);
                  EnableRunmode(hDlg,FALSE);
                  break;

               case M_IDC_QUIT:   // Quit
                  DestroyWindow(hDlg);
                  break;

               default:         // This is an error!
                  MessageBeep(0);
                  return DefWindowProc(hDlg,msg,wParam,lParam);
               }
            
         }
      return 0;                 // WM_COMMAND

      case WM_TIMER:
         KillTimer(hDlg,101);
      case WM_USER:
         if (prfl_TestRunning()) {
            SetTimer(hDlg, 101, 1, NULL);
         } else {
            char   acStr[200];
            double dNumCalls, dDuration, dResult;
            
            dNumCalls = prfl_GetCount();
            dDuration = prfl_GetDuration();
            dResult   = prfl_GetResult();
            
            sprintf(acStr,
                    "Test:\t%s\r"
                    "duration (ms):\t%.10g\r"
                    "frames drawn: \t%.10g\r"
                    "FPS:          \t%.10g\r"
                    "%-12s: \t%.10g\r"
                    "%cPS:        \t%.10g",
                    tests[iRadio]->QueryName(),
                    dDuration,
                    dNumCalls,
                    dNumCalls*1000/dDuration,
                    tests[iRadio]->td.acTestStatName, dResult,
                    *tests[iRadio]->td.acTestStatName,dResult*1000/dDuration);
            MessageBox(hDlg,acStr,"Test Results",MB_ICONINFORMATION|MB_OK);
            EnableRunmode(hDlg,FALSE);
         }
         return 0;              // WM_TIMER

      case WM_DESTROY:
         PostQuitMessage(0);
         return 0;              // WM_DESTROY
      }
   
   return DefWindowProc(hDlg,msg,wParam,lParam);
}

BOOL CALLBACK renameDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
   static char acBuffer[120];
   switch (msg)
      {
      case WM_INITDIALOG:
         SetDlgItemText(hDlg, M_IDC_NEWNAME, (char*) lParam);
         return TRUE;

      case WM_COMMAND:
         {
            int i = LOWORD(wParam);
            switch (i)
               {
               case IDOK:
                  GetDlgItemText(hDlg,M_IDC_NEWNAME,acBuffer,sizeof(acBuffer));
                  EndDialog(hDlg, (int) acBuffer);
                  break;

               case IDCANCEL:
                  EndDialog(hDlg, 0);
                  break;
               }
         }
      return 0;                 // WM_COMMAND
      }

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\prfl.cpp ===
#include <stdlib.h>
#include <stdio.h>              // for debugging
#include <windows.h>
#include <commctrl.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <gl\gl.h>

#include "macros.h"
#include "prfl.h"
#include "skeltest.h"
#include "hugetest.h"
#include "primtest.h"
#include "teapot.h"

// Window procedure, handles all messages for this program
LRESULT CALLBACK prfl_WndProc(HWND, UINT msg, WPARAM, LPARAM);

extern HINSTANCE  hInstance;

static LPCTSTR       lpszClassName = "GL Profiler";
static SkeletonTest *pst = NULL;
static HINSTANCE     hInst = NULL;
static HWND          hwndTest = NULL;
static long          lIdleCount = 0;

static struct _timeb timeStart;
static struct _timeb timeEnd;

void_void *prfl_EndFunct = NULL;

// Select the pixel format for a given device context
void SetDCPixelFormat(HDC hDC)
{
   int nPixelFormat;
   
   DWORD mode =
      PFD_DRAW_TO_WINDOW |      // Draw to Window (not to bitmap)
      PFD_SUPPORT_OPENGL |      // Support OpenGL calls in window
      (pst->td.swapbuffers ? PFD_DOUBLEBUFFER : 0);    // Double buffered mode?
   
   static PIXELFORMATDESCRIPTOR pfd = {
      sizeof(PIXELFORMATDESCRIPTOR),  // Size of this structure
      1,                        // Version of this structure    
      -1,
      PFD_TYPE_RGBA,            // RGBA Color mode
      -1,
      0,0,0,0,0,0,              // Not used to select mode
      0,0,                      // Not used to select mode
      0,0,0,0,0,                // Not used to select mode
      -1,
      0,                        // Not used to select mode
      0,                        // Not used to select mode
      PFD_MAIN_PLANE,           // Draw in main plane
      0,                        // Not used to select mode
      0,0,0 };                  // Not used to select mode
   
   pfd.dwFlags = mode;
   pfd.cDepthBits = pst->bd.cDepthBits;
   pfd.cColorBits = GetDeviceCaps(hDC,BITSPIXEL)*GetDeviceCaps(hDC,PLANES);
   
   // Choose a pixel format that best matches that described in pfd
   nPixelFormat = ChoosePixelFormat(hDC, &pfd);
   
   // Set the pixel format for the device context
   SetPixelFormat(hDC, nPixelFormat, &pfd);
}

HWND prfl_InitWindow(LPCTSTR lpszWinName)
{
   if (prfl_RegisterClass(NULL) == FALSE) {
      fprintf(stderr,"Can't register class for test window.\n");
      return NULL;
   }
   
   if (hwndTest != NULL)
      return NULL;
   
   hwndTest = CreateWindow(lpszClassName, lpszWinName,
                         // OpenGL requires WS_CLIPCHILDREN and WS_CLIPSIBLINGS
                           WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                           WS_VISIBLE | DS_SYSMODAL,
                           // Window position and size
                           pst->td.iX, pst->td.iY, pst->td.iW, pst->td.iH,
                           NULL, NULL, hInst, NULL);
   if (!hwndTest) {
      fprintf(stderr,"Couldn't create test window.\n");
      return NULL;
   }
   SetWindowPos(hwndTest, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOMOVE|SWP_NOSIZE|SWP_NOSENDCHANGING);
   return hwndTest;
}

// If necessary, creates a 3-3-2 palette for the device context listed.
HPALETTE GetOpenGLPalette(HDC hDC)
{
   HPALETTE hRetPal = NULL;     // Handle to palette to be created
   PIXELFORMATDESCRIPTOR pfd;   // Pixel Format Descriptor
   LOGPALETTE *pPal;            // Pointer to memory for logical palette
   int nPixelFormat;            // Pixel format index
   int nColors;                 // Number of entries in palette
   int i;                       // Counting variable
   BYTE RedRange,GreenRange,BlueRange;
   // Range for each color entry (7,7,and 3)
   
   // Get the pixel format index and retrieve the pixel format description
   nPixelFormat = GetPixelFormat(hDC);
   DescribePixelFormat(hDC, nPixelFormat, sizeof(PIXELFORMATDESCRIPTOR), &pfd);
   
   // Does this pixel format require a palette?  If not, do not create a
   // palette and just return NULL
   if(!(pfd.dwFlags & PFD_NEED_PALETTE))
      return NULL;
   
   // Number of entries in palette.  8 bits yeilds 256 entries
   nColors = 1 << pfd.cColorBits;  
   
   // Allocate space for a logical palette structure
   // plus all the palette entries
   pPal = (LOGPALETTE*)malloc(sizeof(LOGPALETTE)+nColors*sizeof(PALETTEENTRY));
   
   // Fill in palette header 
   pPal->palVersion = 0x300;               // Windows 3.0
   pPal->palNumEntries = nColors; // table size
   
   // Build mask of all 1's.  This creates a number represented by having
   // the low order x bits set, where x = pfd.cRedBits, pfd.cGreenBits, and
   // pfd.cBlueBits.  
   RedRange = (1 << pfd.cRedBits) - 1;
   GreenRange = (1 << pfd.cGreenBits) - 1;
   BlueRange = (1 << pfd.cBlueBits) - 1;
   
   // Loop through all the palette entries
   for(i = 0; i < nColors; i++) {
      // Fill in the 8-bit equivalents for each component
      pPal->palPalEntry[i].peRed = (i >> pfd.cRedShift) & RedRange;
      pPal->palPalEntry[i].peRed =
         (unsigned char)((double) pPal->palPalEntry[i].peRed
                         * 255.0 / RedRange);
      
      pPal->palPalEntry[i].peGreen = (i >> pfd.cGreenShift) & GreenRange;
      pPal->palPalEntry[i].peGreen =
         (unsigned char)((double)pPal->palPalEntry[i].peGreen
                         * 255.0 / GreenRange);
      
      pPal->palPalEntry[i].peBlue = (i >> pfd.cBlueShift) & BlueRange;
      pPal->palPalEntry[i].peBlue = 
         (unsigned char)((double)pPal->palPalEntry[i].peBlue
                         * 255.0 / BlueRange);
      
      pPal->palPalEntry[i].peFlags = (unsigned char) NULL;
   }
   
   // Create the palette
   hRetPal = CreatePalette(pPal);
   
   // Go ahead and select and realize the palette for this device context
   SelectPalette(hDC, hRetPal, FALSE);
   RealizePalette(hDC);
   
   // Free the memory used for the logical palette structure
   free(pPal);
   
   // Return the handle to the new palette
   return hRetPal;
}

// Window procedure, handles all messages for this program
LRESULT CALLBACK prfl_WndProc(HWND hWnd, UINT msg,WPARAM wParam, LPARAM lParam)
{
   static HGLRC hRC;            // Permenant Rendering context
   static HDC hDC;              // Private GDI Device context
   static HPALETTE hPalette = NULL;
   //!!! Debug
   static BOOL bStartOnce = TRUE;

   switch (msg)
      {
      case WM_CREATE:
         // Window creation, setup for OpenGL
         // Store the device context
         hDC = GetDC(hWnd);
         
         // Select the pixel format
         SetDCPixelFormat(hDC);
         
         // Create the rendering context and make it current
         hRC = wglCreateContext(hDC);
         wglMakeCurrent(hDC, hRC);
         
         // Create the palette
         hPalette = GetOpenGLPalette(hDC);
         
         // New window, restart timer state
         bStartOnce = TRUE;
         break;

      case WM_SIZE:
         if (bStartOnce) {
            // do any initialization
            if (pst)
               pst->initfunct(LOWORD(lParam), HIWORD(lParam));
            
            glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
            glClear(GL_COLOR_BUFFER_BIT     | GL_DEPTH_BUFFER_BIT
                    | GL_STENCIL_BUFFER_BIT | GL_ACCUM_BUFFER_BIT);
            glFlush();
            if (pst && pst->td.swapbuffers) {
               SwapBuffers(hDC);
               glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
               glClear(GL_COLOR_BUFFER_BIT     | GL_DEPTH_BUFFER_BIT
                       | GL_STENCIL_BUFFER_BIT | GL_ACCUM_BUFFER_BIT);
               glFlush();
            }
            ValidateRect(hWnd,NULL);
            lIdleCount = 0;
            
            // Create a timer that fires every millisecond
            SetTimer(hWnd,101,1,NULL);
            // Only run for X seconds
            SetTimer(hWnd,102,pst->td.iDuration,NULL);
            _ftime(&timeStart);
            // Only once!
            bStartOnce = FALSE;
         }
         break;

      case WM_DESTROY:
         _ftime(&timeEnd);
         // Kill the timers that we created
         KillTimer(hWnd,101);
         KillTimer(hWnd,102);
         
         // do any test-specific cleaning up
         if (pst)
            pst->destfunct();
         
         // Deselect the current rendering context and delete it
         wglMakeCurrent(hDC,NULL);
         wglDeleteContext(hRC);
         
         // Delete the palette
         if(hPalette != NULL)
            DeleteObject(hPalette);
         
         hwndTest = NULL;
         break;

      case WM_TIMER:
         // Call the idle function, if it exists, then force a repaint
         if (wParam == 101) {
            if (pst)
               pst->idlefunct();
            lIdleCount++;
            InvalidateRect(hWnd,NULL,FALSE);
         } else if (wParam == 102) {
            DestroyWindow(hWnd);
            // alert the caller of the test that it's over.
            if (prfl_EndFunct)
               prfl_EndFunct();
         }
         break;

      case WM_PAINT:
         // Call OpenGL drawing code
         if (pst)
            pst->rendfunct();
         
         // Call function to swap the buffers
         if (pst && pst->td.swapbuffers)
            SwapBuffers(hDC);
         
         // Validate the newly painted client area
         ValidateRect(hWnd,NULL);
         break;

      case WM_QUERYNEWPALETTE:
         // Windows is telling the application that it may modify
         // the system palette.  This message in essance asks the
         // application for a new palette.
         // 
         // If the palette was created.
         if(hPalette) {
            int nRet;
            
            // Selects the palette into the current device context
            SelectPalette(hDC, hPalette, FALSE);
            
            // Map entries from the currently selected palette to
            // the system palette.  The return value is the number
            // of palette entries modified.
            nRet = RealizePalette(hDC);
            
            // Repaint, forces remap of palette in current window
            InvalidateRect(hWnd,NULL,FALSE);
            
            return TRUE; // nRet
         }
         break;

      case WM_PALETTECHANGED:
         // This window may set the palette, even though it is not the
         // currently active window.
         // 
         // Don't do anything if the palette does not exist, or if
         // this is the window that changed the palette.
         if((hPalette != NULL) && ((HWND)wParam != hWnd)) {
            // Select the palette into the device context
            SelectPalette(hDC,hPalette,FALSE);
            
            // Map entries to system palette
            RealizePalette(hDC);
            
            // Remap the current colors to the newly realized palette
            UpdateColors(hDC);
            return TRUE; // 0
         }
         break;

      default:   // Passes it on if unproccessed
         return (DefWindowProc(hWnd, msg, wParam, lParam));
         // return FALSE;
      }
   //   return TRUE;
   return (0L);
}

// Above are internal functions


// Below are public functions

void *prfl_AutoLoad(const char *szFileName, int *piError)
{
   static char szErrorMsg[120];
   static SkeletonTest st;
   SkeletonTest *pst = NULL;
   HANDLE        hFile;
   int           i;
   char         *szType;
   DWORD         dwPointer;
   
   if (!piError || !szFileName)
      return NULL;
   
   *piError = PRFL_NO_ERROR;
   
   hFile = CreateFile(szFileName, GENERIC_READ, 0, NULL,
                      OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if (hFile == INVALID_HANDLE_VALUE) {
      sprintf(szErrorMsg, "Error opening file: %d\n", GetLastError());
      *piError = PRFL_ERROR_OPENFILE;
      return szErrorMsg;
   }
   i = st.Load(hFile);
   if (i < 0) {
      CloseHandle(hFile);
      sprintf(szErrorMsg, "Error number %d while reading file", i);
      *piError = PRFL_ERROR_LOADFILE;
      return szErrorMsg;
   }
   dwPointer = SetFilePointer(hFile, 0, NULL, FILE_BEGIN);
   if (dwPointer == 0xFFFFFFFF) {
      sprintf(szErrorMsg, "Error rewinding file: %d\n", GetLastError());
      *piError = PRFL_ERROR_FILESEEK;
      CloseHandle(hFile);       // hope for no errors
      return szErrorMsg;
   }
   
   szType = (char*) st.QueryType();
   pst = NULL;
   switch(szType[0])
      {
      case 's':
      case 'S':
         if (!strcasecmp(szType, "skeleton"))
            pst = new(SkeletonTest);
         break;

      case 'h':
      case 'H':
         if (!strcasecmp(szType, "huge"))
            pst = new(HugeTest);
         break;

      case 'p':
      case 'P':
         if (!strcasecmp(szType, "primative"))
            pst = new(PrimativeTest);
         break;

      case 't':
      case 'T':
         if (!strcasecmp(szType, "teapot"))
            pst = new(TeapotTest);
         break;

      default:
         sprintf(szErrorMsg, "Unknown test type: %s", szType);
         *piError = PRFL_ERROR_UNKNOWN_TYPE;
         return szErrorMsg;
   }
   
   i = pst->Load(hFile);
   if (i < 0) {
      CloseHandle(hFile);
      sprintf(szErrorMsg, "Error number %d while reading file", i);
      *piError = PRFL_ERROR_LOADFILE;
      return szErrorMsg;
   }
   if (!CloseHandle(hFile)) {
      sprintf(szErrorMsg, "Error closing file: %d\n", GetLastError());
      *piError = PRFL_ERROR_CLOSEFILE;
      return szErrorMsg;
   }
   
   return pst;
}

BOOL prfl_RegisterClass(HINSTANCE hInstance)
{
   static BOOL fRet = FALSE;
   WNDCLASS        wc;          // Windows class structure
   
   if ((fRet == TRUE) || (!hInstance))
      return fRet;
   
   fRet = TRUE;
   hInst = hInstance;
   
   // Register Window style
   wc.style                = CS_HREDRAW | CS_VREDRAW;
   wc.lpfnWndProc          = (WNDPROC) prfl_WndProc;
   wc.cbClsExtra           = 0;
   wc.cbWndExtra           = 0;
   wc.hInstance            = hInstance;
   wc.hIcon                = NULL;
   wc.hCursor              = LoadCursor(NULL, IDC_ARROW);
   
   // No need for background brush for OpenGL window
   wc.hbrBackground        = NULL;         
   
   wc.lpszMenuName         = NULL;
   wc.lpszClassName        = lpszClassName;
   
   // Register the window class
   if(RegisterClass(&wc) == 0)
      fRet = FALSE;
   
   return fRet;
}

BOOL prfl_StartTest(SkeletonTest *ptest, LPCTSTR lpzWinName, void_void EndFn)
{
   prfl_EndFunct = EndFn;
   
   if (hwndTest) {
      fprintf(stderr,"Error: Test is already running.\n");
      return FALSE;
   }
   if (ptest)
      pst = ptest;
   else
      return FALSE;
   
   if (NULL == prfl_InitWindow(lpzWinName)) {
      return FALSE;
   }
   return TRUE;
}

BOOL prfl_StopTest(void)
{
   if (hwndTest == NULL)
      return TRUE;
   DestroyWindow(hwndTest);
   hwndTest = NULL;
   return TRUE;
}

BOOL prfl_TestRunning()
{
   return (BOOL) hwndTest;
}

double prfl_GetDuration()
{
   long   lSecDiff;
   long   lMilDiff;
   double dRet;
   
   lSecDiff = (timeEnd.time    - timeStart.time);
   lMilDiff = (timeEnd.millitm - timeStart.millitm);
   dRet = 1000*(lSecDiff + ((double) lMilDiff/1000));
   return dRet;
}

double prfl_GetCount()
{
   return (double) lIdleCount;
}

double prfl_GetResult()
{
   if (!pst)
      return -1.0;
   return (pst->td.dResult * lIdleCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\raster.h ===
#ifndef RASTER_H
#define RASTER_H

typedef enum { POLY_POINT, POLY_LINE, POLY_FILL } PolygonFaceModeType;
typedef enum { CULL_FRONT, CULL_BACK, CULL_FRONT_AND_BACK } CullFaceModeType;

typedef struct {
   char     acDummy1[16];
   GLfloat  fPointSize;          // GL_POINT_SIZE
   BOOL     bPointSmooth;        // GL_POINT_SMOOTH
   
   GLfloat  fLineWidth;          // GL_LINE_WIDTH
   BOOL     bLineSmooth;         // GL_LINE_SMOOTH
   GLushort usLineStipple;       // GL_LINE_STIPPLE_PATTERN
   int      iLineStippleRepeat;  // GL_LINE_STIPPLE_REPEAT
   BOOL     bLineStippleEnable;  // GL_LINE_STIPPLE
   
   BOOL     bPolyCullFaceEnable; // GL_CULL_FACE
   int      iPolyCullMode;       // GL_CULL_FACE_MODE
   int      iPolyDir;            // GL_FRONT_FACE (CW/CCW indicator)
   
   BOOL     bPolySmooth;         // GL_POLYGON_SMOOTH
   int      iPolyFrontMode;      // GL_POLYGON_MODE
   int      iPolyBackMode;       // GL_POLYGON_MODE
   BOOL     bPolyStippleEnable;  // GL_POLYGON_STIPPLE
   uint     uiPolyStipple;       //      --
   
   int      iPointQuality;
   int      iLineQuality;
   int      iPolyQuality;
   char     acDummy2[16];
} RASTERDATA;

void InitRD(RASTERDATA *prd);
void raster_init(RASTERDATA rd);

#endif // RASTER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\profiler\raster.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include "hugetest.h"
#include "raster.h"
#include "resource.h"
#include "ui_huge.h"
#include "macros.h"

void InitRD(RASTERDATA *prd)
{
   bzero(prd,sizeof(RASTERDATA));
   BEGINstring(prd, "raster");
   ENDstring(prd,   "raster");
   prd->fPointSize          = 1.0;
   prd->bPointSmooth        = FALSE;
   prd->fLineWidth          = 1.0;
   prd->bLineSmooth         = FALSE;
   prd->usLineStipple       = ~0;
   
   prd->iLineStippleRepeat  = 1;
   prd->bLineStippleEnable  = FALSE;
   prd->bPolyCullFaceEnable = FALSE;
   prd->iPolyCullMode       = CULL_BACK;
   prd->iPolyDir            = GL_CCW;
   
   prd->bPolySmooth         = FALSE;
   prd->iPolyFrontMode      = POLY_FILL;
   prd->iPolyBackMode       = POLY_FILL;
   prd->bPolyStippleEnable  = FALSE;
   prd->uiPolyStipple       = ~0;
   
   prd->iPointQuality       = DONT_CARE;
   prd->iLineQuality        = DONT_CARE;
   prd->iPolyQuality        = DONT_CARE;
}

void raster_init(const RASTERDATA rd)
{
   glPointSize(rd.fPointSize);
   GL_EnableOrDisable(rd.bPointSmooth, GL_POINT_SMOOTH);
   glLineWidth(rd.fLineWidth);
   GL_EnableOrDisable(rd.bPointSmooth, GL_LINE_SMOOTH);
   glLineStipple(rd.iLineStippleRepeat, rd.usLineStipple);
   GL_EnableOrDisable(rd.bLineStippleEnable, GL_LINE_STIPPLE);
   GL_EnableOrDisable(rd.bPolyCullFaceEnable, GL_CULL_FACE);
   switch(rd.iPolyCullMode) {
   case CULL_FRONT:          glCullFace(GL_FRONT);          break;
   case CULL_BACK:           glCullFace(GL_BACK);           break;
   case CULL_FRONT_AND_BACK: glCullFace(GL_FRONT_AND_BACK); break;
   }
   switch (rd.iPolyFrontMode) {
   case POLY_POINT: glPolygonMode(GL_FRONT, GL_POINT); break;
   case POLY_LINE:  glPolygonMode(GL_FRONT, GL_LINE);  break;
   case POLY_FILL:  glPolygonMode(GL_FRONT, GL_FILL);  break;
   }
   switch (rd.iPolyBackMode) {
   case POLY_POINT: glPolygonMode(GL_BACK, GL_POINT); break;
   case POLY_LINE:  glPolygonMode(GL_BACK, GL_LINE);  break;
   case POLY_FILL:  glPolygonMode(GL_BACK, GL_FILL);  break;
   }
   GL_EnableOrDisable(rd.bPolySmooth, GL_POLYGON_SMOOTH);
   GL_EnableOrDisable(rd.bPolyStippleEnable, GL_POLYGON_STIPPLE);
   glFrontFace(rd.iPolyDir);
   switch (rd.iPointQuality) {
   case FASTEST:   glHint(GL_POINT_SMOOTH_HINT, GL_FASTEST);   break;
   case DONT_CARE: glHint(GL_POINT_SMOOTH_HINT, GL_DONT_CARE); break;
   case NICEST:    glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);    break;
   }
   switch (rd.iLineQuality) {
   case FASTEST:   glHint(GL_LINE_SMOOTH_HINT, GL_FASTEST);   break;
   case DONT_CARE: glHint(GL_LINE_SMOOTH_HINT, GL_DONT_CARE); break;
   case NICEST:    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);    break;
   }
   switch (rd.iPolyQuality) {
   case FASTEST:   glHint(GL_POLYGON_SMOOTH_HINT, GL_FASTEST);   break;
   case DONT_CARE: glHint(GL_POLYGON_SMOOTH_HINT, GL_DONT_CARE); break;
   case NICEST:    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);    break;
   }
}

#ifndef NO_UI_IN_CNFG

#define SetDlgIntString(hDlg,iCntl,iVal) SetDlgItemInt(hDlg,iCntl,iVal,FALSE)
#define GetDlgIntString(hDlg,iCntl)      GetDlgItemInt(hDlg,iCntl,NULL,TRUE)

void raster_SetDisplayFromData(HWND hDlg, const RASTERDATA *prd)
{
   SetDlgFloatString(hDlg, R_IDC_POINT_SIZE,          prd->fPointSize);
   CheckDlgButton(   hDlg, R_IDC_POINT_SMOOTH,        prd->bPointSmooth);
   SetDlgFloatString(hDlg, R_IDC_LINE_WIDTH,          prd->fLineWidth);
   CheckDlgButton(   hDlg, R_IDC_LINE_SMOOTH,         prd->bLineSmooth);
   SetDlgHexString(  hDlg, R_IDC_LINE_STIPPLE_PATTERN,prd->usLineStipple);
   SetDlgIntString(  hDlg, R_IDC_LINE_STIPPLE_REPEAT, prd->iLineStippleRepeat);
   CheckDlgButton(   hDlg, R_IDC_LINE_SMOOTH,         prd->bLineStippleEnable);
   CheckDlgButton(   hDlg, R_IDC_CULL_FACE_ENABLE,  prd->bPolyCullFaceEnable);
   CheckDlgButton(   hDlg, R_IDC_POLY_SMOOTH,         prd->bPolySmooth);
   CheckDlgButton(   hDlg, R_IDC_POLY_STIPPLE_ENABLE, prd->bPolyStippleEnable);
   SetDlgHexString(  hDlg, R_IDC_POLY_STIPPLE_PATTERN,prd->uiPolyStipple);
   CB_DlgSetSelect(  hDlg, R_IDC_CULL_FACE_MODE,      prd->iPolyCullMode);
   CB_DlgSetSelect(  hDlg, R_IDC_FRONT_FACE,        prd->iPolyDir==GL_CCW?1:0);
   CB_DlgSetSelect(  hDlg, R_IDC_POLY_FRONT_MODE,     prd->iPolyFrontMode);
   CB_DlgSetSelect(  hDlg, R_IDC_POLY_BACK_MODE,      prd->iPolyBackMode);
   CB_DlgSetSelect(  hDlg, R_IDC_POINT_QUALITY,       prd->iPointQuality);
   CB_DlgSetSelect(  hDlg, R_IDC_LINE_QUALITY,        prd->iLineQuality);
   CB_DlgSetSelect(  hDlg, R_IDC_POLY_QUALITY,        prd->iPolyQuality);
}

void raster_GetDataFromDisplay(HWND hDlg, RASTERDATA *prd)
{
   prd->fPointSize         =GetDlgFloatString( hDlg,R_IDC_POINT_SIZE);
   prd->bPointSmooth       =IsDlgButtonChecked(hDlg,R_IDC_POINT_SMOOTH);
   prd->fLineWidth         =GetDlgFloatString( hDlg,R_IDC_LINE_WIDTH);
   prd->bLineSmooth        =IsDlgButtonChecked(hDlg,R_IDC_LINE_SMOOTH);
   prd->usLineStipple      =GetDlgHexString( hDlg, R_IDC_LINE_STIPPLE_PATTERN);
   prd->iLineStippleRepeat =GetDlgIntString( hDlg, R_IDC_LINE_STIPPLE_REPEAT);
   prd->bLineStippleEnable =IsDlgButtonChecked(hDlg,R_IDC_LINE_SMOOTH);
   prd->bPolyCullFaceEnable=IsDlgButtonChecked(hDlg,R_IDC_CULL_FACE_ENABLE);
   prd->bPolySmooth        =IsDlgButtonChecked(hDlg,R_IDC_POLY_SMOOTH);
   prd->bPolyStippleEnable =IsDlgButtonChecked(hDlg,R_IDC_POLY_STIPPLE_ENABLE);
   prd->uiPolyStipple      =GetDlgHexString( hDlg, R_IDC_POLY_STIPPLE_PATTERN);
   prd->iPolyCullMode      =CB_DlgGetSelect(hDlg, R_IDC_CULL_FACE_MODE);
   prd->iPolyDir = CB_DlgGetSelect(hDlg, R_IDC_FRONT_FACE) ? GL_CCW : GL_CW;
   prd->iPolyFrontMode     =CB_